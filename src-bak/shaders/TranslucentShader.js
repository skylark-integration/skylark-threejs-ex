define(["skylark-threejs"], function (a) {
    'use strict';
    var TranslucentShader = {
        uniforms: a.UniformsUtils.merge([
            a.UniformsLib['common'],
            a.UniformsLib['lights'],
            {
                'color': { value: new a.Color(16777215) },
                'diffuse': { value: new a.Color(16777215) },
                'specular': { value: new a.Color(16777215) },
                'emissive': { value: new a.Color(0) },
                'opacity': { value: 1 },
                'shininess': { value: 1 },
                'thicknessMap': { value: null },
                'thicknessColor': { value: new a.Color(16777215) },
                'thicknessDistortion': { value: 0.1 },
                'thicknessAmbient': { value: 0 },
                'thicknessAttenuation': { value: 0.1 },
                'thicknessPower': { value: 2 },
                'thicknessScale': { value: 10 }
            }
        ]),
        vertexShader: [
            'varying vec3 vNormal;',
            'varying vec2 vUv;',
            'varying vec3 vViewPosition;',
            a.ShaderChunk['common'],
            'void main() {',
            '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',
            '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
            '\tvViewPosition = -mvPosition.xyz;',
            '\tvNormal = normalize( normalMatrix * normal );',
            '\tvUv = uv;',
            '\tgl_Position = projectionMatrix * mvPosition;',
            '}'
        ].join('\n'),
        fragmentShader: [
            '#define USE_UV',
            '#define USE_MAP',
            '#define PHONG',
            '#define TRANSLUCENT',
            '#include <common>',
            '#include <bsdfs>',
            '#include <uv_pars_fragment>',
            '#include <map_pars_fragment>',
            '#include <lights_phong_pars_fragment>',
            'varying vec3 vColor;',
            'uniform vec3 diffuse;',
            'uniform vec3 specular;',
            'uniform vec3 emissive;',
            'uniform float opacity;',
            'uniform float shininess;',
            'uniform sampler2D thicknessMap;',
            'uniform float thicknessPower;',
            'uniform float thicknessScale;',
            'uniform float thicknessDistortion;',
            'uniform float thicknessAmbient;',
            'uniform float thicknessAttenuation;',
            'uniform vec3 thicknessColor;',
            a.ShaderChunk['lights_pars_begin'],
            'void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {',
            '\tvec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;',
            '\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));',
            '\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;',
            '\tvec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;',
            '\treflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;',
            '}',
            'void main() {',
            '\tvec3 normal = normalize( vNormal );',
            '\tvec3 viewerDirection = normalize( vViewPosition );',
            '\tvec4 diffuseColor = vec4( diffuse, opacity );',
            '\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );',
            a.ShaderChunk['map_fragment'],
            a.ShaderChunk['color_fragment'],
            a.ShaderChunk['specularmap_fragment'],
            '\tvec3 totalEmissiveRadiance = emissive;',
            a.ShaderChunk['lights_phong_fragment'],
            '\tGeometricContext geometry;',
            '\tgeometry.position = - vViewPosition;',
            '\tgeometry.normal = normal;',
            '\tgeometry.viewDir = normalize( vViewPosition );',
            '\tIncidentLight directLight;',
            '\t#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )',
            '\t\tPointLight pointLight;',
            '\t\t#pragma unroll_loop_start',
            '\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {',
            '\t\t \tpointLight = pointLights[ i ];',
            '\t\t \tgetPointDirectLightIrradiance( pointLight, geometry, directLight );',
            '\t\t\t#ifdef USE_SHADOWMAP',
            '\t\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;',
            '\t\t\t#endif',
            '\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );',
            '\t\t\t#if defined( TRANSLUCENT ) && defined( USE_UV )',
            '\t\t\tRE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);',
            '\t\t\t#endif',
            '\t\t}',
            '\t\t#pragma unroll_loop_end',
            '\t\t#endif',
            '\t#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )',
            '\t\tDirectionalLight directionalLight;',
            '\t\t#pragma unroll_loop_start',
            '\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {',
            '\t\t\tdirectionalLight = directionalLights[ i ];',
            '\t\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );',
            '\t\t\t#ifdef USE_SHADOWMAP',
            '\t\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;',
            '\t\t\t#endif',
            '\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );',
            '\t\t\t#if defined( TRANSLUCENT ) && defined( USE_UV )',
            '\t\t\tRE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);',
            '\t\t\t#endif',
            '\t\t}',
            '\t\t#pragma unroll_loop_end',
            '\t#endif',
            '\t#if defined( RE_IndirectDiffuse )',
            '\t\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );',
            '\t\t#if ( NUM_HEMI_LIGHTS > 0 )',
            '\t\t\t#pragma unroll_loop_start',
            '\t\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {',
            '\t\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );',
            '\t\t\t}',
            '\t\t\t#pragma unroll_loop_end',
            '\t\t#endif',
            '\t#endif',
            '\t#if defined( RE_IndirectSpecular )',
            '\t\tvec3 radiance = vec3( 0.0 );',
            '\t\tvec3 clearcoatRadiance = vec3( 0.0 );',
            '\t#endif',
            a.ShaderChunk['lights_fragment_end'],
            '\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;',
            '\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );',
            a.ShaderChunk['encodings_fragment'],
            '}'
        ].join('\n')
    };
    return TranslucentShader ;
});