{"version":3,"sources":["skylark-threejs-ex.js"],"names":["define","THREE","CopyShader","uniforms","tDiffuse","value","opacity","vertexShader","join","fragmentShader","BokehShader","defines","DEPTH_PACKING","PERSPECTIVE_CAMERA","tColor","tDepth","focus","aspect","aperture","maxblur","nearClip","farClip","SAOShader","NUM_SAMPLES","NUM_RINGS","NORMAL_TEXTURE","DIFFUSE_TEXTURE","tNormal","size","Vector2","cameraNear","cameraFar","cameraProjectionMatrix","Matrix4","cameraInverseProjectionMatrix","scale","intensity","bias","minResolution","kernelRadius","randomSeed","DepthLimitedBlurShader","KERNEL_RADIUS","sampleUvOffsets","sampleWeights","depthCutoff","BlurShaderUtils","createSampleWeights","stdDev","gaussian","x","Math","exp","sqrt","PI","weights","i","push","createSampleOffsets","uvIncrement","offsets","clone","multiplyScalar","configure","material","needsUpdate","UnpackDepthRGBAShader","ConvolutionShader","KERNEL_SIZE_FLOAT","KERNEL_SIZE_INT","uImageIncrement","cKernel","buildKernel","sigma","gauss","values","sum","halfWidth","kernelSize","ceil","Array","LuminosityHighPassShader","shaderID","luminosityThreshold","smoothWidth","defaultColor","Color","defaultOpacity","FXAAShader","resolution","SSAOShader","KERNEL_SIZE","tNoise","kernel","minDistance","maxDistance","SSAODepthShader","SSAOBlurShader","FilmShader","time","nIntensity","sIntensity","sCount","grayscale","DotScreenShader","tSize","center","angle","LuminosityShader","SobelOperatorShader","ColorifyShader","color","ToneMapShader","averageLuminance","luminanceMap","maxLuminance","minLuminance","middleGrey","TechnicolorShader","HueSaturationShader","hue","saturation","camera","geometry","FullScreenQuad","Pass","this","enabled","needsSwap","clear","renderToScreen","Object","assign","prototype","setSize","render","console","error","OrthographicCamera","PlaneBufferGeometry","_mesh","Mesh","defineProperty","get","set","dispose","renderer","ShaderPass","shader","textureID","call","undefined","ShaderMaterial","UniformsUtils","fsQuad","create","constructor","writeBuffer","readBuffer","texture","setRenderTarget","autoClearColor","autoClearDepth","autoClearStencil","MaskPass","scene","inverse","writeValue","clearValue","context","getContext","state","buffers","setMask","depth","setLocked","stencil","setTest","setOp","REPLACE","setFunc","ALWAYS","setClear","EQUAL","KEEP","ClearMaskPass","EffectComposer","renderTarget","parameters","minFilter","LinearFilter","magFilter","format","RGBAFormat","stencilBuffer","getSize","_pixelRatio","getPixelRatio","_width","width","_height","height","WebGLRenderTarget","name","renderTarget1","renderTarget2","passes","copyPass","clock","Clock","swapBuffers","tmp","addPass","pass","insertPass","index","splice","isLastEnabledPass","passIndex","length","deltaTime","getDelta","currentRenderTarget","getRenderTarget","maskActive","il","NOTEQUAL","reset","effectiveWidth","effectiveHeight","setPixelRatio","pixelRatio","RenderPass","overrideMaterial","clearColor","clearAlpha","clearDepth","oldClearColor","oldClearAlpha","oldOverrideMaterial","oldAutoClear","autoClear","getClearColor","getHex","getClearAlpha","setClearColor","NURBSUtils","findSpan","p","u","U","n","low","high","mid","floor","calcBasisFunctions","span","N","left","right","j","saved","r","rv","lv","temp","calcBSplinePoint","P","C","Vector4","point","Nj","wNj","w","y","z","calcBasisFunctionDerivatives","zeroArr","ders","slice","ndu","s1","s2","a","k","d","rk","pk","j1","j2","calcBSplineDerivatives","nd","du","CK","nders","Pw","add","calcKoverI","nom","denom","calcRationalCurveDerivatives","Pders","Aders","wders","Vector3","v","sub","divideScalar","calcNURBSDerivatives","calcSurfacePoint","q","V","target","uspan","vspan","Nu","Nv","l","Sw","NURBSCurve","degree","knots","controlPoints","startKnot","endKnot","Curve","getPoint","t","hpoint","getTangent","tangent","normalize","NURBSSurface","degree1","degree2","knots1","knots2","len1","len2","t1","t2","float32Array","interleavedBuffer","Lensflare","Geometry","MeshBasicMaterial","transparent","type","frustumCulled","renderOrder","Infinity","positionScreen","positionView","tempMap","DataTexture","Uint8Array","RGBFormat","NearestFilter","wrapS","ClampToEdgeWrapping","wrapT","occlusionMap","material1a","RawShaderMaterial","screenPosition","depthTest","depthWrite","material1b","map","mesh1","elements","LensflareElement","Shader","material2","blending","AdditiveBlending","mesh2","addElement","element","screenPositionPixels","validArea","Box2","viewport","onBeforeRender","getCurrentViewport","invAspect","halfViewportWidth","halfViewportHeight","min","max","setFromMatrixPosition","matrixWorld","applyMatrix4","matrixWorldInverse","copy","projectionMatrix","containsPoint","copyFramebufferToTexture","renderBufferDirect","vecX","vecY","distance","uniformsNeedUpdate","isLensflare","BufferGeometry","Float32Array","InterleavedBuffer","setIndex","setAttribute","InterleavedBufferAttribute","Reflector","options","scope","textureWidth","textureHeight","clipBias","ReflectorShader","recursion","encoding","LinearEncoding","reflectorPlane","Plane","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","lookAtPosition","clipPlane","view","textureMatrix","virtualCamera","PerspectiveCamera","MathUtils","isPowerOfTwo","generateMipmaps","userData","extractRotation","subVectors","dot","reflect","negate","position","up","lookAt","far","updateMatrixWorld","multiply","setFromNormalAndCoplanarPoint","constant","sign","visible","currentXrEnabled","xr","currentShadowAutoUpdate","shadowMap","autoUpdate","Refractor","RefractorShader","matrixAutoUpdate","refractor","refractorPlane","refractorWorldPosition","clipVector","updateRefractorPlane","quaternion","Quaternion","decompose","applyQuaternion","updateVirtualCamera","getInverse","updateTextureMatrix","TTFLoader","manager","Loader","reversed","load","url","onLoad","onProgress","onError","loader","FileLoader","setPath","path","setResponseType","buffer","parse","arraybuffer","reverseCommands","commands","paths","forEach","c","toLowerCase","result","command","x2","y2","x1","y1","opentype","warn","font","round","glyphs","unitsPerEm","glyphIndexMap","cmap","unicodes","keys","unicode","glyph","token","ha","advanceWidth","x_min","xMin","x_max","xMax","o","String","fromCodePoint","familyName","getEnglishName","ascender","descender","underlinePosition","tables","post","underlineThickness","boundingBox","head","yMin","yMax","original_font_information","convert","ThreeMFLoader","availableExtensions","data","textureLoader","TextureLoader","parseRelsXml","relsFileText","relationships","relsXmlData","DOMParser","parseFromString","relsNodes","querySelectorAll","relsNode","relationship","getAttribute","id","parseBasematerialsNode","basematerialsNode","basematerialsData","basematerials","basematerialNodes","basematerialNode","basematerialData","parseBasematerialNode","parseTextures2DGroupNode","texture2DGroupNode","texture2DGroupData","texid","displaypropertiesid","tex2coordNodes","uvs","tex2coordNode","parseFloat","parseColorGroupNode","colorGroupNode","colorGroupData","colorNodes","colors","colorObject","colorNode","setStyle","substring","convertSRGBToLinear","g","b","parseMetallicDisplaypropertiesNode","metallicDisplaypropetiesNode","metallicDisplaypropertiesData","metallicNodes","metallicData","metallicNode","metallicness","roughness","parseComponentNode","componentNode","componentData","transform","parseTransform","split","s","matrix","parseObjectNode","objectNode","objectData","pid","pindex","thumbnail","partnumber","meshNode","querySelector","meshData","vertices","vertexNodes","vertexNode","triangleProperties","triangles","triangleNodes","triangleNode","v1","v2","v3","p1","p2","p3","triangleProperty","parseInt","Uint32Array","parseMeshNode","componentsNode","components","componentNodes","parseComponentsNode","parseModelNode","modelNode","modelData","unit","metadataNodes","metadataData","metadataNode","indexOf","textContent","parseMetadataNodes","resourcesNode","resourcesData","basematerialsNodes","textures2DNodes","textures2DNode","texture2DData","texture2DNode","texture2dData","contenttype","tilestyleu","tilestylev","filter","colorGroupNodes","pbmetallicdisplaypropertiesNodes","pbmetallicdisplaypropertiesNode","pbmetallicdisplaypropertiesData","textures2DGroupNodes","textures2DGroupNode","textures2DGroupData","objectNodes","parseResourcesNode","buildNode","buildData","itemNodes","itemNode","buildItem","objectId","parseBuildNode","buildTexture","texture2dgroup","objects","textureData","texture2ds","resources","texture2d","blob","Blob","sourceURI","URL","createObjectURL","revokeObjectURL","sRGBEncoding","RepeatWrapping","MirroredRepeatWrapping","LinearMipmapLinearFilter","buildBasematerialsMeshes","objectPindex","materialMap","meshes","materialIndex","trianglePropertiesProps","getBuild","buildBasematerial","positionData","jl","Float32BufferAttribute","mesh","buildTexturedMesh","uvData","MeshPhongMaterial","flatShading","buildVertexColorMesh","colorgroup","colorData","vertexColors","buildDefaultMesh","BufferAttribute","getResourceType","buildGroup","group","Group","resourceMap","objectPid","analyzeObject","resourceId","resourceType","newMeshes","buildMeshes","builder","build","materialData","pbmetallicdisplayproperties","pbmetallicdisplayproperty","MeshStandardMaterial","metalness","displaycolor","charAt","buildComposite","compositeData","composite","component","buildObject","object3D","extensions","modelXml","ns","extension","apply","applyExtensions","data3mf","relsName","modelRelsName","rels","modelRels","zip","file","modelPartNames","printTicketPartNames","texturesPartNames","otherPartNames","modelParts","texturesParts","JSZip","e","ReferenceError","files","match","relsView","asArrayBuffer","LoaderUtils","decodeText","modelPart","fileText","xmlData","documentElement","nodeName","attributes","attr","RegExp","$1","texturesPartName","model","printTicket","other","loadDocument","modelsData","modelsKeys","modelRel","textureKey","modelsKey","objectIds","buildObjects","addExtension","AMFLoader","text","loadMaterials","node","matName","matId","loadedMaterial","childNodes","matChildEl","loadColor","matColor","loadMeshVolume","volume","materialid","currVolumeNode","firstElementChild","materialId","nodeValue","getElementsByTagName","nextElementSibling","loadMeshVertices","vertArray","normalArray","currVerticesNode","vNode","nx","ny","nz","normals","loadObject","objId","loadedObject","currColor","currObjNode","currMeshNode","volumes","loadedVertices","concat","obj","DataView","fromCharCode","getUint8","log","substr","amfName","amfAuthor","amfScale","scaleUnits","millimeter","inch","feet","meter","micron","loadDocumentScale","amfMaterials","amfObjects","child","sceneObject","defaultMaterial","author","part","newObject","objDefaultMaterial","newGeometry","AssimpLoader","extractUrlBase","resourcePath","setCrossOrigin","crossOrigin","Virtulous","KeyFrame","lerp","nextKey","dist","l2","keypos","keyrot","key2pos","key2rot","tempAniPos","tempAniQuat","slerp","tempAniMatrix","compose","tempAniScale","KeyFrameTrack","_accelTable","fps","addKey","key","init","sortKeys","parseFromThree","track","hierarchy","targets","parseFromCollada","sort","keySortFunc","reTarget","root","compareitor","TrackTargetNodeNameCompare","keySearchAccel","setTime","abs","key0","key1","matrixWorldNeedsUpdate","find","children","Animation","tracks","addTrack","ASSBIN_CHUNK_AICAMERA","ASSBIN_CHUNK_AILIGHT","ASSBIN_CHUNK_AITEXTURE","ASSBIN_CHUNK_AIMESH","ASSBIN_CHUNK_AINODEANIM","ASSBIN_CHUNK_AISCENE","ASSBIN_CHUNK_AIBONE","ASSBIN_CHUNK_AIANIMATION","ASSBIN_CHUNK_AINODE","ASSBIN_CHUNK_AIMATERIAL","ASSBIN_CHUNK_AIMATERIALPROPERTY","ASSBIN_MESH_HAS_POSITIONS","ASSBIN_MESH_HAS_NORMALS","ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS","ASSBIN_MESH_HAS_TEXCOORD_BASE","ASSBIN_MESH_HAS_COLOR_BASE","AI_MAX_NUMBER_OF_COLOR_SETS","AI_MAX_NUMBER_OF_TEXTURECOORDS","aiLightSource_DIRECTIONAL","aiLightSource_SPOT","aiTextureType_DIFFUSE","aiTextureType_NORMALS","aiTextureType_OPACITY","aiTextureType_LIGHTMAP","BONESPERVERT","ASSBIN_MESH_HAS_TEXCOORD","ASSBIN_MESH_HAS_COLOR","cloneTreeToBones","rootBone","Bone","nodeCount","toString","nodeToBoneMap","sortWeights","indexes","pairs","findMatchingBone","ret","aiMesh","mPrimitiveTypes","mNumVertices","mNumFaces","mNumBones","mMaterialIndex","mVertices","mNormals","mTangents","mBitangents","mColors","mTextureCoords","mFaces","mBones","hookupSkeletons","allBones","offsetMatrix","skeletonRoot","findNode","mName","mParent","isBone","threeSkeletonRoot","toTHREE","threeSkeletonRootBone","threeNode","bone","tbone","mOffsetMatrix","skeleton","Skeleton","bind","skinning","mat","mMaterials","MeshLambertMaterial","mIndexArray","mVertexBuffer","mNormalBuffer","mColorBuffer","mTexCoordsBuffers","mTangentBuffer","mBitangentBuffer","bones","mWeights","weight","mVertexId","mWeight","_weights","_bones","SkinnedMesh","normalizeSkinWeights","aiFace","mNumIndices","mIndices","aiString","str","replace","aiNode","mTransformation","mNumChildren","mNumMeshes","mMeshes","mChildren","Object3D","aiBone","mNumWeights","aiMaterialProperty","mKey","mSemantic","mIndex","mData","mDataLength","mType","dataAsColor","array","reader","getFloat32","dataAsFloat","dataAsBool","dataAsString","dataAsMap","lastIndexOf","namePropMapping","?mat.name","$mat.shadingm","$mat.twosided","$mat.wireframe","$clr.ambient","$clr.diffuse","$clr.specular","$clr.emissive","$clr.transparent","$clr.reflective","$mat.shininess","$mat.reflectivity","$mat.refracti","$tex.file","nameTypeMapping","aiMaterial","mNumAllocated","mNumProperties","mProperties","prop","normalMap","lightMap","alphaMap","ambient","veclerp","lm1","quatlerp","q1","q2","sampleTrack","lne","mValue","timeDist","mTime","dT","T","aiNodeAnim","mNodeName","mNumPositionKeys","mNumRotationKeys","mNumScalingKeys","mPositionKeys","mRotationKeys","mScalingKeys","mPreState","mPostState","tps","comp","getLength","pos","rotation","aiAnimation","mDuration","mTicksPerSecond","mNumChannels","mChannels","animationHandle","aiTexture","mWidth","mHeight","texAchFormatHint","pcData","aiLight","mAttenuationConstant","mAttenuationLinear","mAttenuationQuadratic","mAngleInnerCone","mAngleOuterCone","mColorDiffuse","mColorSpecular","mColorAmbient","aiCamera","mPosition","mLookAt","mUp","mHorizontalFOV","mClipPlaneNear","mClipPlaneFar","mAspect","littleEndian","readFloat","dataview","val","readOffset","Read_double","getFloat64","Read_uint8_t","Read_uint16_t","getUint16","Read_unsigned_int","getUint32","Read_uint32_t","Read_aiVector3D","stream","Read_aiColor3D","Read_aiQuaternion","Read_aiString","stringlengthbytes","ReadBytes","Read_aiVertexWeight","Read_aiMatrix4x4","m","i2","Read_aiVectorKey","Read_aiQuatKey","ReadArray_aiVectorKey","ReadBounds","Seek","sizeof","aiOrigin_CUR","ai_assert","bool","ReadBinaryBone","chunkID","shortened","ReadArray_aiVertexWeight","ReadBinaryMesh","mNumUVComponents","subArray32","uv","f","Error","ReadBinaryMaterialProperty","ReadBinaryMaterial","ReadBinaryNodeAnim","ReadArray_aiQuatKey","ReadBinaryAnim","anim","ReadBinaryTexture","tex","achFormatHint","ReadBinaryLight","ReadBinaryCamera","cam","ReadBinaryScene","mFlags","mNumMaterials","mNumAnimations","mNumTextures","mNumLights","mNumCameras","mRootNode","ReadBinaryNode","parent","mDepth","node2","mAnimations","mTextures","mLights","mCameras","compressed","aiOrigin_BEG","pFiledata","pScene","versionMajor","versionMinor","versionRevision","compileFlags","boneNode","markBones","object","animation","off","ori","buff","bytes","start","end","newbuff","subArrayUint16","Uint16Array","subArrayUint8","subArrayUint32","extendStream","uncompressedSize","compressedSize","FileSize","Tell","compressedData","Read","uncompressedData","uncompress","ArrayBuffer","InternReadFile","TGALoader","Texture","image","TGA_TYPE_NO_DATA","TGA_TYPE_INDEXED","TGA_TYPE_RGB","TGA_TYPE_GREY","TGA_TYPE_RLE_INDEXED","TGA_TYPE_RLE_RGB","TGA_TYPE_RLE_GREY","TGA_ORIGIN_MASK","TGA_ORIGIN_SHIFT","TGA_ORIGIN_BL","TGA_ORIGIN_BR","TGA_ORIGIN_UL","TGA_ORIGIN_UR","content","offset","header","id_length","colormap_type","image_type","colormap_index","colormap_length","colormap_size","origin","pixel_size","flags","tgaCheckHeader","use_rle","use_pal","use_grey","useOffscreen","OffscreenCanvas","canvas","document","createElement","imageData","createImageData","pixel_data","pixel_total","palettes","subarray","count","shift","pixels","tgaParse","palette","x_start","y_start","x_step","y_step","x_end","y_end","tgaGetImageDataGrey8bits","tgaGetImageDataGrey16bits","colormap","tgaGetImageData8bits","tgaGetImageData16bits","tgaGetImageData24bits","tgaGetImageData32bits","getTgaRGBA","putImageData","transferToImageBitmap","ColladaLoader","convertUpAxis","xml","parseStrings","parts","trim","parseFloats","parseInts","parseId","isEmpty","parseLibrary","libraryName","parser","library","buildLibrary","parseAnimationSampler","inputs","nodeType","semantic","parseAnimationChannel","sid","arraySyntax","memberSyntax","member","indices","sampler","buildAnimation","channels","samplers","sources","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","inputSource","outputSource","buildAnimationChannel","createKeyframeTracks","getAnimation","animations","stride","nodes","getNode","transforms","defaultMatrix","transpose","keyframes","transformAnimationData","prepareAnimationData","uuid","times","quaternionData","scaleData","keyframe","fromArray","VectorKeyframeTrack","QuaternionKeyframeTrack","property","defaultValue","empty","prev","next","getPrev","getNext","interpolate","createMissingKeyframes","buildAnimationClip","duration","animationTracks","AnimationClip","getAnimationClip","clips","parseSkin","bindShapeMatrix","parseSource","joints","parseJoints","vertexWeights","parseVertexWeights","vcount","buildController","geometries","skin","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","weightId","skinWeight","descending","bindMatrix","identity","boneInverse","buildSkin","skinIndices","skinWeights","buildImage","init_from","getImage","images","parseEffectProfileCOMMON","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechnique","buildEffect","buildMaterial","effect","effects","profile","getTexture","textureObject","surface","tgaLoader","getTextureLoader","wrapU","wrapV","offsetU","offsetV","repeat","repeatU","repeatV","parameter","specular","specularMap","float","shininess","emissive","emissiveMap","transparency","double_sided","side","DoubleSide","getMaterial","materials","parseCameraOptics","parseCameraTechnique","parseCameraParameters","buildCamera","optics","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","getCamera","cameras","parseLightTechnique","parseLightParameters","falloffAngle","buildLight","light","DirectionalLight","PointLight","SpotLight","AmbientLight","getLight","lights","accessor","parseGeometryVertices","parseGeometryPrimitive","primitive","hasUV","inputname","checkUVCoordinates","primitives","uvsNeedsFix","buildGeometry","groupedPrimitives","groupPrimitives","primitiveType","buildGeometryType","uv2","materialKeys","vc","addGroup","input","prevLength","buildGeometryData","pushVector","sourceStride","sourceArray","kl","getGeometry","buildKinematicsModel","parseKinematicsTechniqueCommon","parseKinematicsJoint","links","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","degToRad","parsePhysicsRigidBody","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsBindJointAxis","param","tmpJointIndex","jointIndex","buildKinematicsScene","vector","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","makeTranslation","makeRotationAxis","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","buildBoneHierarchy","visualScenes","visualScene","processed","boneInverses","traverse","instanceCamera","controller","controllers","newObjects","isSkinnedMesh","instanceLight","fallbackMaterial","resolveMaterialBinding","instanceMaterials","LineBasicMaterial","LineSegments","Line","buildVisualScene","getVisualScene","Scene","collada","parserError","errorText","errorElement","stack","Node","TEXT_NODE","parserErrorToText","version","asset","hasAttribute","parseAssetUnit","upAxis","parseAssetUpAxis","parseAsset","kinematics","kinematicsModels","physicsModels","kinematicsScenes","prepareNodes","rigidBodies","bindJointAxis","setupAnimations","kinematicsModelId","kinematicsSceneId","visualSceneId","kinematicsModel","kinematicsScene","getKinematicsScene","jointMap","targetElement","parentVisualElement","parentElement","connect","visualElement","visualElementName","buildTransformList","m0","getJointValue","jointData","setJointValue","setupKinematics","parseScene","setFromEuler","Euler","DRACOLoader","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","defaultAttributeTypes","setDecoderPath","setDecoderConfig","config","setWorkerLimit","setVerbosity","setDrawMode","setSkipDequantization","setWithCredentials","taskConfig","attributeIDs","attributeTypes","useUniqueIDs","decodeGeometry","then","catch","decodeDracoFile","callback","attribute","BYTES_PER_ELEMENT","worker","taskKey","JSON","stringify","taskCache","has","cachedTask","promise","byteLength","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","message","_createGeometry","finally","_releaseTask","geometryData","itemSize","_loadLibrary","responseType","preload","_initDecoder","useJS","WebAssembly","librariesPending","all","libraries","jsContent","wasmBinary","fn","DRACOWorker","body","Worker","_taskCosts","_taskLoad","onmessage","debug","terminate","decodeAttribute","draco","decoder","dracoGeometry","attributeName","attributeType","dracoArray","numComponents","num_components","numPoints","num_points","numValues","DracoFloat32Array","GetAttributeFloatForAllPoints","Int8Array","DracoInt8Array","GetAttributeInt8ForAllPoints","Int16Array","DracoInt16Array","GetAttributeInt16ForAllPoints","Int32Array","DracoInt32Array","GetAttributeInt32ForAllPoints","DracoUInt8Array","GetAttributeUInt8ForAllPoints","DracoUInt16Array","GetAttributeUInt16ForAllPoints","DracoUInt32Array","GetAttributeUInt32ForAllPoints","GetValue","destroy","onModuleLoaded","DracoDecoderModule","module","Decoder","decoderBuffer","DecoderBuffer","Init","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","ptr","error_msg","attributeID","self","GetAttributeByUniqueId","GetAttributeId","GetAttribute","numFaces","num_faces","numIndices","indexArray","GetFaceFromMesh","WeakMap","releaseDecoderModule","getDecoderModule","Zlib","FBXLoader","fbxTree","connections","sceneGraph","FBXTreeParser","GeometryParser","AnimationParser","TextParser","BinaryParser","BinaryReader","dv","FBXTree","getFbxVersion","convertFBXTimeToSeconds","setTimeout","itemError","FBXBuffer","CORRECT","convertArrayBufferToString","FBXText","cursor","read","num","isFbxFormatASCII","parseConnections","parseImages","textures","parseTextures","parseMaterials","deformers","parseDeformers","geometryMap","connectionMap","Map","rawConnections","Connections","rawConnection","fromID","toID","parents","parentRelationship","ID","childRelationship","blobs","Objects","videoNodes","Video","nodeID","videoNode","RelativeFilename","Filename","arrayBufferContent","Content","base64Content","parseImage","filename","fileName","getHandler","window","textureMap","textureNodes","parseTexture","textureNode","loadTexture","attrName","wrapModeU","WrapModeU","wrapModeV","WrapModeV","valueU","valueV","Scaling","currentPath","FileName","materialNodes","Material","parseMaterial","materialNode","ShadingModel","parseParameters","setValues","BumpFactor","bumpScale","Diffuse","DiffuseColor","DisplacementFactor","displacementScale","Emissive","EmissiveColor","EmissiveFactor","emissiveIntensity","Opacity","ReflectionFactor","reflectivity","Shininess","Specular","SpecularColor","bumpMap","aoMap","displacementMap","envMap","mapping","EquirectangularReflectionMapping","LayeredTexture","morphTargets","DeformerNodes","Deformer","deformerNode","attrType","parseSkeleton","geometryID","morphTarget","rawTargets","parseMorphTargets","deformerNodes","rawBones","rawBone","transformLink","TransformLink","Indexes","Weights","rawMorphTargets","morphTargetNode","rawMorphTarget","initialWeight","DeformPercent","fullWeights","FullWeights","geoID","modelMap","parseModels","modelNodes","Model","setLookAtProperties","parentConnections","connection","bindSkeleton","createAmbientLight","setupMorphMaterials","transformData","parentMatrixWorld","generateTransform","isGroup","createCamera","createLight","createMesh","createCurve","PropertyBinding","sanitizeNodeName","getTransformData","subBone","cameraAttribute","NodeAttribute","CameraProjectionType","nearClippingPlane","NearPlane","farClippingPlane","FarPlane","innerWidth","innerHeight","AspectWidth","AspectHeight","fov","FieldOfView","focalLength","FocalLength","setFocalLength","lightAttribute","LightType","Intensity","CastLightOnObject","FarAttenuationEnd","EnableFarAttenuation","InnerAngle","penumbra","OuterAngle","CastShadows","castShadow","FBX_Deformer","reduce","geo","linewidth","inheritType","InheritType","eulerOrder","getEulerOrder","RotationOrder","translation","Lcl_Translation","preRotation","PreRotation","Lcl_Rotation","postRotation","PostRotation","Lcl_Scaling","scalingOffset","ScalingOffset","scalingPivot","ScalingPivot","rotationOffset","RotationOffset","rotationPivot","RotationPivot","lookAtTarget","bindMatrices","parsePoseNodes","geoRelationships","geoConnParent","BindPoseNode","Pose","poseNodes","PoseNode","isArray","poseNode","Matrix","GlobalSettings","ambientColor","AmbientColor","isMesh","morphAttributes","setupMorphMaterial","matUuid","sharedMat","clonedMat","geoNodes","parseGeometry","geoNode","parseMeshGeometry","parseNurbsGeometry","GeometricTranslation","GeometricRotation","GeometricScaling","genGeometry","preTransform","geoInfo","parseGeoNode","genBuffers","positionAttribute","vertex","Uint16BufferAttribute","weightsIndices","normalMatrix","Matrix3","getNormalMatrix","normalAttribute","applyNormalMatrix","uvBuffer","mappingType","prevMaterialIndex","startIndex","currentIndex","groups","lastGroup","lastIndex","addMorphTargets","vertexPositions","Vertices","vertexIndices","PolygonVertexIndex","LayerElementColor","parseVertexColors","LayerElementMaterial","parseMaterialIndices","LayerElementNormal","parseNormals","LayerElementUV","parseUVs","weightTable","polygonIndex","faceLength","displayedWeightsWarning","facePositionIndexes","faceNormals","faceColors","faceUVs","faceWeights","faceWeightIndices","vertexIndex","polygonVertexIndex","endOfFace","weightIndices","getData","wt","wIndex","Weight","weightIndex","currentWeight","comparedWeight","comparedWeightIndex","comparedWeightArray","genFace","parentGeo","parentGeoNode","morphTargetsRelative","rawTarget","morphGeoNode","genMorphGeometry","morphPositionsSparse","morphPositions","morphIndex","morphGeoInfo","morphBuffers","NormalNode","MappingInformationType","referenceType","ReferenceInformationType","Normals","indexBuffer","NormalIndex","NormalsIndex","dataSize","UVNode","UV","UVIndex","ColorNode","Colors","ColorIndex","MaterialNode","materialIndexBuffer","Materials","materialIndices","order","Order","isNaN","KnotVector","pointsValues","Points","Form","curve","getPoints","positions","toArray","animationClips","rawClips","parseClips","rawClip","clip","addClip","AnimationCurve","curveNodesMap","parseAnimationCurveNodes","parseAnimationCurves","layersMap","parseAnimationLayers","parseAnimStacks","rawCurveNodes","AnimationCurveNode","rawCurveNode","curveNode","curves","rawCurves","animationCurve","KeyTime","KeyValueFloat","animationCurveID","animationCurveRelationship","rawLayers","AnimationLayer","layerCurveNodes","modelID","rawModel","modelName","initialPosition","initialRotation","initialScale","morph","deformerID","morpherID","morphName","rawStacks","AnimationStack","layer","rawTracks","generateTracks","setFromQuaternion","positionTrack","generateVectorTrack","R","rotationTrack","generateRotationTrack","S","scaleTrack","morphTrack","generateMorphTrack","initialValue","getTimesForAllAxes","getKeyframeTrackValues","interpolateRotations","euler","quaternionValues","premultiply","morphNum","getObjectByName","morphTargetDictionary","NumberKeyframeTrack","elem","prevValue","xIndex","yIndex","zIndex","xValue","yValue","zValue","valuesSpan","absoluteSpan","numSubIntervals","step","nextValue","initialTime","timeSpan","interval","nextTime","interpolatedTimes","interpolatedValues","inject","getPrevNode","nodeStack","currentIndent","getCurrentNode","getCurrentProp","currentProp","pushStack","popStack","setCurrentProp","currentPropName","allNodes","line","matchComment","matchEmpty","matchBeginning","matchProperty","matchEnd","parseNodeBegin","parseNodeProperty","parseNodePropertyContinued","nodeAttrs","attrs","parseNodeAttr","currentNode","contentLine","propName","propValue","parentName","connProps","from","to","rest","append","parseNumberArray","parseNodeSpecialProperty","props","innerPropName","innerPropType1","innerPropType2","innerPropFlag","innerPropValue","type2","flag","skip","endOfContent","getOffset","endOffset","getUint64","numProperties","nameLen","getString","propertyList","parseProperty","singleProperty","subNode","parseSubNode","getBoolean","getInt32","getInt64","getArrayBuffer","getInt16","arrayLength","compressedLength","getBooleanArray","getFloat64Array","getFloat32Array","getInt32Array","getInt64Array","inflate","Inflate","reader2","decompress","nullByte","dataArray","infoObject","tempEuler","tempVec","lTranslationM","lPreRotationM","lRotationM","lPostRotationM","lScalingM","lScalingPivotM","lScalingOffsetM","lRotationOffsetM","lRotationPivotM","lParentGX","lGlobalT","setPosition","makeRotationFromEuler","lLRM","lParentGRM","lLSM","lParentGSM","lParentGRSM","lGlobalRS","lParentTM","copyPosition","lParentLSM","lParentGSM_noLocal","lTransform","lLocalTWithAllPivotAndOffsetInfo","lGlobalTranslation","enums","a1","a2","GCodeLoader","splitLayer","extruding","relative","layers","currentLayer","pathMaterial","extrudingMaterial","newLayer","pathVertex","addSegment","delta","absolute","lines","tokens","cmd","args","addObject","segments","GLTFLoader","dracoLoader","ddsLoader","itemStart","_onError","itemEnd","gltf","setDRACOLoader","setDDSLoader","magic","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","headerView","BINARY_EXTENSION_HEADER_LENGTH","chunkView","chunkIndex","chunkLength","chunkType","BINARY_EXTENSION_CHUNK_TYPES","contentArray","BIN","byteOffset","json","extensionsUsed","extensionName","extensionsRequired","KHR_LIGHTS_PUNCTUAL","GLTFLightsExtension","KHR_MATERIALS_CLEARCOAT","GLTFMaterialsClearcoatExtension","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS","GLTFMaterialsPbrSpecularGlossinessExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","MSFT_TEXTURE_DDS","GLTFTextureDDSExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","GLTFParser","lightDefs","loadLight","lightIndex","lightNode","lightDef","range","spot","innerConeAngle","outerConeAngle","decay","getMaterialType","extendParams","materialParams","materialDef","pending","metallicRoughness","pbrMetallicRoughness","baseColorFactor","baseColorTexture","assignTexture","MeshPhysicalMaterial","clearcoatFactor","clearcoat","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessTexture","clearcoatNormalTexture","clearcoatNormalScale","GLTFMeshStandardSGMaterial","params","isGLTFSpecularGlossinessMaterial","specularMapParsFragmentChunk","glossinessMapParsFragmentChunk","specularMapFragmentChunk","glossinessMapFragmentChunk","lightPhysicalFragmentChunk","setHex","glossiness","glossinessMap","_extraUniforms","onBeforeCompile","uniformName","defineProperties","USE_GLOSSINESSMAP","USE_ROUGHNESSMAP","metalnessMap","roughnessMap","specularGlossinessParams","pbrSpecularGlossiness","diffuseFactor","diffuseTexture","glossinessFactor","specularFactor","specularGlossinessTexture","specGlossMapDef","createMaterial","fog","lightMapIntensity","aoMapIntensity","normalMapType","TangentSpaceNormalMap","normalScale","displacementBias","envMapIntensity","refractionRatio","GLTFCubicSplineInterpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","Interpolant","decodePrimitive","bufferViewIndex","bufferView","gltfAttributeMap","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","threeAttributeName","ATTRIBUTES","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","normalized","getDependency","extendTexture","texCoord","copySampleValue_","valueSize","beforeStart_","afterEnd_","interpolate_","i1","t0","stride2","stride3","td","pp","ppp","offset1","offset0","s3","s0","p0","m1","WEBGL_CONSTANTS","FLOAT","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","LINEAR","REPEAT","SAMPLER_2D","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","UNSIGNED_BYTE","UNSIGNED_SHORT","5120","5121","5122","5123","5125","5126","WEBGL_FILTERS","9728","9729","9984","NearestMipmapNearestFilter","9985","LinearMipmapNearestFilter","9986","NearestMipmapLinearFilter","9987","WEBGL_WRAPPINGS","33071","33648","10497","WEBGL_TYPE_SIZES","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","INTERPOLATION","CUBICSPLINE","InterpolateLinear","STEP","InterpolateDiscrete","ALPHA_MODES","OPAQUE","MASK","BLEND","MIME_TYPE_FORMATS","image/png","image/jpeg","resolveURL","test","createDefaultMaterial","cache","FrontSide","addUnknownExtensionsToUserData","knownExtensions","objectDef","gltfExtensions","assignExtrasToUserData","gltfDef","extras","updateMorphTargets","meshDef","morphTargetInfluences","targetNames","createPrimitiveKey","primitiveDef","dracoExtension","createAttributesKey","mode","attributesKey","remove","removeAll","primitiveCache","fileLoader","addPrimitiveAttributes","assignAttributeAccessor","accessorIndex","gltfAttributeName","box","Box3","maxDisplacement","setX","setY","setZ","expandByVector","sphere","Sphere","getCenter","radius","distanceTo","boundingSphere","computeBounds","hasMorphPosition","hasMorphNormal","pendingPositionAccessors","pendingNormalAccessors","pendingAccessor","morphNormals","toTrianglesDrawMode","drawMode","getIndex","numberOfTriangles","newIndices","TriangleFanDrawMode","getX","markDefs","getDependencies","dependencies","scenes","nodeDefs","skinDefs","skins","meshDefs","meshReferences","meshUses","skinLength","nodeIndex","nodeLength","nodeDef","cacheKey","dependency","loadScene","loadNode","loadMesh","loadAccessor","loadBufferView","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","defs","def","bufferIndex","bufferDef","uri","bufferViewDef","bufferViews","sparse","pendingBufferViews","bufferAttribute","TypedArray","elementBytes","itemBytes","byteStride","ibSlice","ibCacheKey","ib","itemSizeIndices","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setW","textureIndex","webkitURL","textureDef","textureExtensions","isObjectURL","mimeType","flipY","mapName","mapDef","isCompressedTexture","assignFinalMaterial","useVertexTangents","useVertexColors","useFlatShading","useSkinning","useMorphTargets","useMorphNormals","isPoints","pointsMaterial","PointsMaterial","sizeAttenuation","isLine","lineMaterial","cachedMaterial","vertexTangents","materialType","materialExtensions","sgExtension","kmuExtension","metallicFactor","roughnessFactor","metallicRoughnessTexture","doubleSided","alphaMode","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","emissiveFactor","emissiveTexture","clearcoatExtension","loadGeometries","createDracoPrimitive","geometryPromise","cached","meshIndex","results","TriangleStripDrawMode","LineLoop","cameraIndex","cameraDef","radToDeg","skinDef","skinEntry","inverseBindMatrices","animationIndex","animationDef","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","output","inputAccessors","outputAccessors","inputAccessor","outputAccessor","TypedKeyframeTrack","updateMatrix","targetName","interpolation","outputArray","scaled","createInterpolant","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","instanceNum","buildNodeHierachy","nodeId","parentObject","pendingJoints","jointNodes","jointNode","sceneIndex","sceneDef","nodeIds","MTLLoader","setMaterialOptions","materialOptions","info","delimiter_pattern","materialsInfo","ss","materialCreator","MaterialCreator","setManager","setMaterials","baseUrl","materialsArray","nameLookup","wrap","converted","mn","covmat","save","lprop","normalizeRGB","ignoreZeroRGBs","materialName","getAsArray","createMaterial_","setMapForType","mapType","texParams","getTextureParams","invertTrProperty","matParams","items","DefaultLoadingManager","OBJLoader","object_pattern","material_library_pattern","material_use_pattern","map_use_pattern","materialLibraries","startObject","fromDeclaration","previousMaterial","currentMaterial","_finalize","smooth","startMaterial","previous","inherited","groupCount","mtllib","groupStart","groupEnd","cloned","lastMultiMaterial","mi","declared","finalize","parseVertexIndex","len","parseNormalIndex","parseUVIndex","addVertex","src","dst","addVertexPoint","addVertexLine","addNormal","addColor","addUV","addUVLine","addFace","ua","ub","uc","na","nb","nc","vLen","ia","ic","uvLen","nLen","addPointGeometry","vi","addLineGeometry","uvi","lineFirstChar","trimLeft","lineData","vertexData","faceVertices","vertexParts","lineParts","lineVertices","lineUVs","li","llen","pointData","exec","container","hasVertexColors","buffergeometry","computeVertexNormals","createdMaterials","miLen","sourceMaterial","materialHash","materialPoints","materialLine","PCDLoader","textData","PCDheader","result1","search","result2","headerLen","fields","viewpoint","points","sizeSum","rowSize","parseHeader","pcdData","rgb","normal_x","normal_y","normal_z","sizes","decompressedSize","decompressed","inData","outLength","ctrl","ref","inLength","outData","inPtr","outPtr","decompressLZF","row","computeBoundingSphere","random","reverse","PLYLoader","propertyNameMapping","setPropertyNameMapping","headerText","headerLength","currentElement","lineType","lineValues","comments","make_ply_element_property","propertValues","countType","itemType","properties","parseASCIINumber","parseASCIIElement","list","parseASCII","faceVertexUvs","currentElementCount","handleElement","postProcess","toNonIndexed","elementName","red","green","blue","vertex_indices","vertex_index","texcoord","binaryRead","at","little_endian","getInt8","binaryReadElement","loc","parseBinary","PRWMLoader","bigEndianPlatform","isBigEndianPlatform","uint8Array","uint16Array","InvertedEncodingTypes","getMethods","Float64Array","copyFromBuffer","sourceArrayBuffer","viewType","fromBigEndian","bytesPerElement","readView","getMethod","arrayBuffer","indexedGeometry","indicesType","bigEndian","attributesNumber","valuesNumber","indicesNumber","char","cardinality","arrayType","decodePrwm","bufferGeometry","STLLoader","exception","matchDataViewAt","query","binData","array_buffer","charCodeAt","ensureBinary","n_faces","solid","isBinary","defaultR","defaultG","defaultB","alpha","faces","hasColors","face","normalX","normalY","normalZ","packedColor","vertexstart","componentIdx","patternSolid","patternFace","faceCounter","patternFloat","patternVertex","patternNormal","startVertex","endVertex","vertexCountPerFace","normalCountPerFace","ensureString","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","SVGLoader","defaultDPI","defaultUnit","parseArcCommand","rx","ry","x_axis_rotation","large_arc_flag","sweep_flag","dx2","dy2","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","dq","pq","cxp","cyp","cx","cy","theta","svgAngle","absellipse","ux","uy","vx","vy","ang","acos","parseStyle","style","addStyle","svgName","jsName","adjustFunction","clamp","parseFloatWithUnits","positive","getReflection","string","number","units","unitConversion","mm","cm","in","pt","pc","px","theUnit","endsWith","getNodeTransform","currentTransform","tempTransform0","transformsTexts","tIndex","transformText","openParPos","closeParPos","transformType","tx","ty","translate","tempTransform1","tempTransform2","rotate","tempTransform3","multiplyMatrices","scaleX","scaleY","tan","parseNodeTransform","transformStack","getTransformScaleX","te","getTransformScaleY","tempV2","tempV3","ShapePath","control","firstPoint","isFirstPoint","doSetFirstPoint","numbers","moveTo","lineTo","bezierCurveTo","quadraticCurveTo","autoClose","currentPoint","parsePathNode","h","parseRectNode","parsePolygonNode","parsePolylineNode","subpath","Path","absarc","subPaths","parseCircleNode","parseEllipseNode","parseLineNode","fill","transfVec2","applyMatrix3","isRotated","isTransformRotated","subPath","isLineCurve","isCubicBezierCurve","v0","isQuadraticBezierCurve","isEllipseCurve","aX","aY","xRadius","yRadius","transformPath","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","getStrokeStyle","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","arcDivisions","pointsToStrokeWithBuffers","vertexOffset","dupPoints","newPoints","removeDuplicatedPoints","nextPoint","innerSideModified","joinIsOnLeftSide","isMiter","isClosed","equals","previousPoint","strokeWidth2","deltaU","u0","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","iPoint","normal1","u1","miterSide","setLength","miterLength2","segmentLengthPrev","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addCapGeometry","lastOuter","lastInner","rotateAround","addVectors","vl","TDSLoader","readFile","chunk","readChunk","MLIBMAGIC","CMAGIC","M3DMAGIC","nextChunk","M3D_VERSION","readDWord","debugMessage","MDATA","resetPosition","readMeshData","MESH_VERSION","MASTER_SCALE","NAMED_OBJECT","readNamedObject","MAT_ENTRY","readMaterialEntry","readString","cur","N_TRI_OBJECT","readMesh","endChunk","MAT_NAME","MAT_WIRE","wireframe","MAT_WIRE_SIZE","readByte","wireframeLinewidth","MAT_TWO_SIDE","MAT_ADDITIVE","MAT_DIFFUSE","readColor","MAT_SPECULAR","MAT_AMBIENT","MAT_SHININESS","readWord","MAT_TRANSPARENCY","MAT_TEXMAP","readMap","MAT_BUMPMAP","MAT_OPACMAP","MAT_SPECMAP","POINT_ARRAY","FACE_ARRAY","readFaceArray","TEX_VERTS","texels","MESH_MATRIX","MSH_MAT_GROUP","readMaterialGroup","MAT_MAPNAME","MAT_MAP_UOFFSET","MAT_MAP_VOFFSET","MAT_MAP_USCALE","MAT_MAP_VSCALE","COLOR_24","LIN_COLOR_24","setRGB","COLOR_F","LIN_COLOR_F","readInt","readShort","maxLength","VTKLoader","Float32Concat","first","second","firstLength","Int32Concat","getStringFile","stringFile","charArray","meta","Base64toByteArray","b64","placeHolders","arr","Arr","lookup","revLookup","code","L","parseDataArray","ele","numBytes","header_type","rawData","byteData","blocks","cSizeStart","headerSize","dataOffsets","currentOffset","txt","currentBlockSize","resize","verify","el","idx","dom","ActiveXObject","async","loadXML","parseError","reason","srcText","xmlToJson","item","hasChildNodes","old","PolyData","piece","Piece","sections","sectionIndex","numberOfSections","section","DataArray","dataArrayIndex","numberOfDataArrays","numberOfPoints","NumberOfPoints","normalsName","Name","NumberOfComponents","numberOfStrips","NumberOfStrips","connectivity","indicesIndex","strip","len0","numberOfPolys","NumberOfPolys","connectivityIndex","poly","parseXML","includes","patWord","pat3Floats","patConnectivity","patPOINTS","patPOLYGONS","patTRIANGLE_STRIPS","patPOINT_DATA","patCELL_DATA","patCOLOR_SCALARS","patNORMALS","inPointsSection","inPolygonsSection","inTriangleStripSection","inPointDataSection","inCellDataSection","inColorSection","inNormalsSection","dataset","inds","i0","numTriangles","newColors","pointIndex","dataView","vtk","findString","parsedString","indexCount","classCallCheck","createClass","XAnimationInfo","XAnimationObj","XKeyFrameInfo","XLoader","Constructor","TypeError","descriptor","enumerable","configurable","writable","protoProps","staticProps","animeName","boneName","targetBone","keyType","frameStartLv","keyFrames","InverseMx","_flags","putFlags","putPos","putRot","putScl","XAnimationInfoArray","makeBonekeys","refObj","keyFrameRefactor","rot","scl","setFromRotationMatrix","setFromMatrixScale","Frame","texloader","_putMatLength","_nowMat","_nowFrameName","frameHierarchie","Hierarchies","HieStack","_currentObject","_currentFrame","_data","IsUvYReverse","Meshes","animTicksPerSecond","_currentGeo","_currentAnime","_currentAnimeFrames","_arg","_start","arguments","_this","_setArgOption","response","readed","foundNewLine","expect","fileLength","buf","_ensureBinary","_ensureString","_isBinary","_parseBinary","_parseASCII","_hierarchieParse","_changeRoot","_mainloop","_parent","_end","endRead","find1","findEnd","findNext","nameData","_readLine","word","refs","DataEnder","nextStart","_refs","_this2","_mainProc","worked","models","breakFlag","_setFrame","_setFrameTransformMatrix","_getParentName","VertexSetedBoneCount","GeometryData","normalVectors","BoneInfs","baseFrame","_makeBoneFrom_CurrentFrame","_readVertexDatas","_setMeshTextureCoords","_setMeshMaterialList","_setMaterial","_setSkinWeights","AnimeFrames","_readAnimationKey","_makeOutputGeometry","_makeOutputAnimation","_obj","FrameTransformMatrix","_ParseMatrixData","putBone","frame","mode_local","changeMode","refO","_readInt1","_readVertex1","_readFace1","_readNormalVector1","refI","stride4","_computeGroups","currentMaterialIndex","data2","data3","localObject","boneInf","XboneInf","BoneIndex","Indeces","initMatrix","OffsetMatrix","_i","_RootName","putting","rotq","putBones","_makePutBoneList","bi","boneIndex","bb","nowVertexID","nowVal","sk","offsetList","_bi","_buildGeometry","_initSkeleton","_bufferGeometry","worldBaseMx","currentMxFrame","boneList","gbone","nowKeyType","keyInfo","frameFound","frameValue","animationObj","make","_model","_animation","put","findAnimation","c_key","_c_key","parseAnimation","animationMixer","AnimationMixer","targetMatrix","DDSLoader","CompressedTextureLoader","loadMipmaps","dds","mipmaps","mipmapCount","fourCCToInt32","loadARGBMip","dataOffset","dataLength","srcBuffer","byteArray","blockBytes","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","FOURCC_ETC1","fourCC","isRGBAUncompressed","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_ETC1_Format","caps2","isCubemap","mipmap","PVRLoader","pvrDatas","_parseV3","_parseV2","bpp","metaLen","pixelFormat","numMipmaps","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_PVRTC_4BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","dataPtr","numSurfaces","_extract","bitmaskAlpha","numSurfs","formatFlags","_hasAlpha","pvr","blockSize","blockWidth","blockHeight","widthBlocks","heightBlocks","mipLevel","sWidth","sHeight","surfIndex","KTXLoader","ktx","KhronosTextureContainer","pixelWidth","pixelHeight","glInternalFormat","numberOfFaces","numberOfMipmapLevels","facesExpected","identifier","headerDataView","endianness","glType","glTypeSize","glFormat","glBaseInternalFormat","pixelDepth","numberOfArrayElements","bytesOfKeyValueData","loadType","COMPRESSED_2D","HEADER_LEN","level","imageSize","COMPRESSED_3D","TEX_2D","TEX_3D","SimplifyModifier","cb","ab","removeFromArray","computeEdgeCollapseCost","sideFace","edgelength","curvature","sideFaces","hasVertex","minCurvature","dotProd","amt","computeEdgeCostAtVertex","neighbors","collapseNeighbor","collapseCost","minCost","totalCost","costCount","removeVertex","assert","removeFace","vs","removeIfNonNeighbor","collapse","tmpVertices","replaceVertex","minimumCostEdge","least","Triangle","computeNormal","addUniqueNeighbor","Vertex","vA","vB","vC","cross","oldv","newv","modify","isBufferGeometry","fromBufferGeometry","mergeVertices","nextVertex","oldVertices","oldFaces","triangle","simplifiedGeometry","SubdivisionModifier","subdivisions","repeats","computeFaceNormals","ABC","getEdge","vertexIndexA","vertexIndexB","processEdge","metaVertices","edge","vertexA","vertexB","newEdge","edges","newFace","newFaces","Face3","midpoint","newUv","newUvs","oldUvs","newVertices","sourceEdges","newEdgeVertices","newSourceVertices","newUVs","currentEdge","edgeVertexWeight","adjacentVertexWeight","connectedFaces","beta","sourceVertexWeight","connectingVertexWeight","connectingEdge","connectingEdges","oldVertex","newSourceVertex","hasUvs","generateLookups","edge1","edge2","edge3","x0","sl","x3","x4","x5","DRACOExporter","DracoEncoderModule","decodeSpeed","encodeSpeed","encoderMethod","MESH_EDGEBREAKER_ENCODING","quantization","exportUvs","exportNormals","exportColor","dracoEncoder","encoder","Encoder","MeshBuilder","isGeometry","fromGeometry","AddFloatAttributeToMesh","AddFacesToMesh","TEX_COORD","COLOR","encodedData","SetSpeedOptions","SetEncodingMethod","SetAttributeQuantization","EncodeMeshToDracoBuffer","outputData","MESH_SEQUENTIAL_ENCODING","INVALID","GENERIC","OBJExporter","indexVertex","indexVertexUvs","indexNormals","nbVertex","nbNormals","nbVertexUvs","normalMatrixWorld","setFromObject","getY","getZ","parseMesh","parseLine","STLExporter","binary","bufferLength","setUint32","setFloat32","setUint16","UNSIGNED_INT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","THREE_TO_WEBGL","GLTFExporter","onDone","DEFAULT_OPTIONS","trs","onlyVisible","truncateDrawRange","embedImages","maxTextureSize","forceIndices","forcePowerOfTwoTextures","includeCustomExtensions","cachedCanvas","outputJSON","generator","nodeMap","cachedData","attributesNormalized","uids","uid","getUID","equalArray","array1","array2","every","getPaddedBufferSize","bufferSize","getPaddedArrayBuffer","paddingByte","paddedLength","serializeUserData","gltfProperty","applyTextureTransform","didTransform","transformDef","processBuffer","processAccessor","end2","drawRange","bufferViewTarget","minMax","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","getMinMax","componentSize","setUint8","gltfBufferView","processBufferView","gltfAccessor","1","2","3","4","16","processImage","cachedImages","gltfImage","floorPowerOfTwo","ctx","drawImage","toBlob","FileReader","readAsArrayBuffer","onloadend","processBufferViewImage","toDataURL","processTexture","gltfTexture","gltfSampler","processSampler","processMaterial","isShaderMaterial","gltfMaterial","isMeshBasicMaterial","KHR_materials_unlit","KHR_materials_pbrSpecularGlossiness","isMeshStandardMaterial","metalRoughMapDef","baseColorMapDef","specularMapDef","emissiveMapDef","normalMapDef","occlusionMapDef","processMesh","meshCacheKeyParts","meshCacheKey","isLineSegments","isLineLoop","gltfMesh","nameConversion","originalNormal","isNormalizedNormalAttribute","createNormalizedNormalAttribute","modifiedAttribute","reverseDictionary","warned","baseAttribute","relativeAttribute","setXYZ","isMultiMaterial","didForceIndices","processAnimation","Utils","mergeMorphTargetTracks","trackBinding","parseTrackName","trackNode","trackProperty","propertyName","objectName","getBoneByName","objectIndex","outputItemSize","getInterpolation","processSkin","rootJoint","processNode","gltfNode","isCamera","isOrtho","isOrthographicCamera","gltfCamera","orthographic","top","near","perspective","processCamera","isDirectionalLight","isPointLight","isSpotLight","processLight","isLight","processScene","gltfScene","objectsWithoutScene","processObjects","processInput","extensionsUsedList","binaryChunk","binaryChunkPrefix","jsonChunk","TextEncoder","encode","stringToArrayBuffer","jsonChunkPrefix","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","insertKeyframe","TimeBufferType","ValueBufferType","interpolant","evaluate","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","setInterpolation","mergedTrack","targetCount","targetIndex","sourceInterpolant","keyframeIndex","ColladaExporter","textureDirectory","imageToData","ext","naturalWidth","naturalHeight","atob","base64ToBuffer","transMat","getFuncs","attrBufferToArray","isInterleavedBufferAttribute","subArray","st","ct","res","imageMap","libraryImages","imageNode","directory","original","geometryInfo","libraryGeometries","libraryEffects","libraryMaterials","libraryVisualScenes","processObject","getTransform","geomInfo","meshid","gname","gnode","posName","vertName","triangleInputs","normName","uvName","colName","subarr","polycount","processGeometry","matids","matidsArray","matid","diffuse","transparencyNode","techniqueNode","effectnode","specLink","dae","Date","toISOString","urdf","IS_END_TAG","IS_SELF_CLOSING","HAS_TEXT","pad","tagnum","ch","tag","requestAnimationFrame","PLYExporter","traverseMeshes","geomToBufferGeom","excludeAttributes","includeNormals","includeColors","includeUVs","vertexCount","faceCount","includeIndices","headerBin","vertexListLength","faceListLength","vOffset","fOffset","writtenVertices","vertexList","faceList","main"],"mappings":"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KAEAC,KAAA,MAEAC,gBACA,yBACA,GACA,8BACA,GACA,2BACA,GACA,oBACA,GACA,6FACA,GACA,uFACA,kEACA,wBACA,uCACA,+CACA,KACA,uEACA,KACA,wEACA,wEACA,cACA,uEACA,sEACA,0EACA,4EACA,6EACA,oEACA,wEACA,sEACA,KACA,0EACA,uEACA,wEACA,uEACA,2EACA,yEACA,wEACA,yEACA,kEACA,2EACA,0EACA,KACA,uFACA,GACA,oBACA,0BACA,iCACA,GACA,+BACA,GACA,iFACA,0BACA,SACA,kDACA,4DACA,yEACA,SACA,gCACA,SACA,iFACA,wBACA,8BACA,SACA,iFACA,wBACA,8BACA,SACA,iFACA,sBACA,4BACA,SACA,iFACA,sBACA,4BACA,SACA,iFACA,sBACA,4BACA,SACA,iFACA,6BACA,SACA,2CACA,sEACA,mEACA,8DACA,SACA,6EACA,2EACA,SACA,oDACA,wCACA,wCACA,iEACA,gDACA,SACA,iBACA,kBACA,SACA,mCACA,SACA,iFACA,0BACA,SACA,+CACA,6DACA,4EACA,yEACA,iCACA,SACA,iBACA,kBACA,SACA,gCACA,SACA,iFACA,uBACA,SACA,6CACA,6DACA,SACA,wDACA,yEACA,mEACA,SACA,6BACA,SACA,iFACA,iCACA,SACA,iCACA,SACA,gDACA,2CACA,SACA,gCACA,2CACA,aACA,+BACA,2CACA,aACA,gCACA,2CACA,aACA,qCACA,2CACA,aACA,SACA,iFACA,6BACA,SACA,oDACA,4DACA,SACA,6BACA,uCACA,aACA,gCACA,uCACA,aACA,+BACA,uCACA,aACA,iCACA,uCACA,aACA,SACA,GACA,GACA,iFACA,sDACA,iFACA,qEACA,iFACA,8BACA,SACA,oCACA,uEACA,uDACA,mEACA,SACA,iBACA,iFACA,2EACA,iFACA,8CACA,SACA,eACA,iFACA,8EACA,8DACA,gEACA,kEACA,6DACA,SACA,qCACA,SACA,GACA,GACA,iFACA,GACA,oDACA,GACA,iFACA,GACA,iFACA,4DACA,iFACA,kCACA,gCACA,kCACA,kCACA,mCACA,SACA,iFACA,kCACA,gCACA,kCACA,kCACA,kCACA,mCACA,SACA,iFACA,kCACA,gCACA,kCACA,kCACA,kCACA,kCACA,mCACA,SACA,iFACA,kCACA,gCACA,kCACA,kCACA,kCACA,kCACA,kCACA,mCACA,SACA,iFACA,kCACA,gCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,mCACA,SACA,iFACA,kCACA,gCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,mCACA,SACA,GACA,iFACA,yDACA,iFACA,kCACA,gCACA,kCACA,kCACA,kCACA,SACA,iFACA,kCACA,gCACA,kCACA,kCACA,kCACA,kCACA,SACA,iFACA,kCACA,gCACA,kCACA,kCACA,kCACA,kCACA,kCACA,SACA,iFACA,kCACA,gCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,SACA,iFACA,kCACA,gCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,SACA,iFACA,kCACA,gCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,SACA,iFACA,kCACA,gCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,SACA,iFACA,kCACA,iCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,SACA,iFACA,kCACA,iCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,mCACA,SACA,iFACA,kCACA,iCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,mCACA,mCACA,SACA,GACA,iFACA,sDACA,iFACA,kCACA,iCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,kCACA,mCACA,mCACA,SACA,GACA,GACA,GACA,iFACA,GACA,8CACA,GACA,iFACA,2EACA,4BACA,kCACA,8BACA,8BACA,8BACA,8BACA,6BACA,6BACA,6BACA,6BACA,6BACA,4CACA,gCACA,QACA,4BACA,mCACA,8BACA,gCACA,gCACA,gCACA,4BACA,8BACA,8BACA,8BACA,qCACA,SACA,iFACA,2BACA,kDACA,kEACA,SACA,iFACA,2BACA,mBACA,uBACA,uBACA,iDACA,6DACA,uDACA,wCACA,0EACA,YACA,2EACA,aACA,oCACA,wDACA,6DACA,4EACA,6DACA,4EACA,aACA,SACA,iFACA,2BACA,2CACA,qDACA,oEACA,oCACA,wDACA,6DACA,4EACA,6DACA,4EACA,aACA,SACA,iFACA,yBACA,8BACA,gCACA,gEACA,4EACA,SACA,iFACA,yBACA,4BACA,4DACA,iEACA,0EACA,SACA,iFACA,yBACA,4BACA,4DACA,iEACA,0EACA,+DACA,wEACA,+DACA,wEACA,SACA,GACA,GACA,iFACA,2DACA,iFACA,gCACA,6DACA,QACA,6DACA,SACA,GACA,GACA,GACA,GACA,iFACA,GACA,kDACA,GACA,iFACA,qBACA,iFACA,8BACA,SACA,oFACA,gCACA,sBACA,SACA,sEACA,oFACA,qCACA,sCACA,oCACA,SACA,8BACA,4DACA,sCACA,iEACA,mBACA,SACA,iEACA,4EACA,+DACA,4DACA,8CACA,SACA,iEACA,4EACA,+DACA,4DACA,8CACA,SACA,oCACA,+CACA,wCACA,yCACA,sCACA,SACA,oCACA,+CACA,oEACA,mCACA,gCACA,gCACA,wCACA,yCACA,wCACA,yCACA,yCACA,SACA,oCACA,kDACA,+CACA,0CACA,2CACA,0CACA,2CACA,0CACA,SACA,oCACA,+DACA,+CACA,0CACA,2CACA,0CACA,2CACA,6CACA,SACA,oCACA,yDACA,gDACA,0DACA,oCACA,uCACA,8CACA,yEACA,6BACA,iCACA,mCACA,SACA,oCACA,iEACA,gDACA,2EACA,uCACA,+BACA,2BACA,gCACA,qCACA,0CACA,SACA,oCACA,qEACA,gDACA,oDACA,iFACA,0CACA,2CACA,sDACA,4CACA,+CACA,uDACA,wDACA,wEACA,6CACA,SACA,oCACA,iEACA,gDACA,oEACA,wDACA,2CACA,iEACA,yEACA,4DACA,uCACA,yBACA,qEACA,0CACA,SACA,oCACA,iEACA,gDACA,oEACA,wDACA,2CACA,6DACA,yEACA,+EACA,+CACA,kEACA,qDACA,0CACA,SACA,oCACA,qEACA,gDACA,oDACA,+EACA,sDACA,qCACA,+DACA,oDACA,0BACA,oDACA,sDACA,4CACA,+CACA,uDACA,wDACA,wEACA,6CACA,SACA,oDACA,yDACA,0EACA,2DACA,iDACA,wCACA,MACA,iFACA,uBACA,sBACA,sBACA,oCACA,kCACA,wDACA,4CACA,wCACA,oBACA,wCACA,qBACA,iBACA,wCACA,4DACA,iFACA,gBACA,4DACA,iFACA,iBACA,kCACA,qCACA,iBACA,iCACA,iCACA,kCACA,kCACA,iCACA,iCACA,YACA,oDACA,wCACA,oCACA,gBACA,oCACA,iBACA,mCACA,8GACA,8GACA,8GACA,8GACA,gBACA,wGACA,wGACA,wGACA,wGACA,iBACA,aACA,iFACA,2CACA,2CACA,4CACA,4CACA,2CACA,2CACA,+CACA,+CACA,sEACA,6CACA,oFACA,oDACA,iFACA,oBACA,kCACA,2BACA,gBACA,4BACA,iBACA,iFACA,oCACA,mCACA,+GACA,+GACA,+GACA,+GACA,gBACA,yGACA,yGACA,yGACA,yGACA,iBACA,YACA,uGACA,uGACA,aACA,iFACA,wCACA,wCACA,4CACA,8CACA,qDACA,qDACA,iFACA,4CACA,4CACA,uDACA,uDACA,iFACA,4CACA,4CACA,qEACA,qEACA,uDACA,uDACA,uDACA,uDACA,iFACA,sDACA,oDACA,gDACA,6DACA,iFACA,mCACA,mCACA,uDACA,0DACA,iFACA,2CACA,2CACA,wCACA,wCACA,yDACA,gEACA,0CACA,kEACA,iFACA,uBACA,uBACA,uBACA,wBACA,2DACA,2DACA,gDACA,gDACA,iFACA,uBACA,mDACA,mDACA,uBACA,mDACA,mDACA,kDACA,4DACA,6CACA,4DACA,iFACA,kCACA,qDACA,+CACA,6CACA,2CACA,iFACA,gCACA,gCACA,wDACA,wDACA,sDACA,sDACA,8CACA,sDACA,sDACA,iFACA,mBACA,oEACA,oEACA,yDACA,yDACA,mDACA,mDACA,0DACA,0DACA,yCACA,0DACA,0DACA,iFACA,oCACA,uBACA,wEACA,wEACA,6DACA,6DACA,uDACA,uDACA,8DACA,8DACA,6CACA,8DACA,8DACA,iFACA,wCACA,2BACA,4EACA,4EACA,iEACA,iEACA,2DACA,2DACA,kEACA,kEACA,iDACA,kEACA,kEACA,iFACA,4CACA,+BACA,gFACA,gFACA,qEACA,qEACA,+DACA,+DACA,sEACA,sEACA,qDACA,sEACA,sEACA,iFACA,gDACA,mCACA,oFACA,oFACA,yEACA,yEACA,mEACA,mEACA,0EACA,0EACA,yDACA,0EACA,0EACA,iFACA,oDACA,uCACA,wFACA,wFACA,6EACA,6EACA,uEACA,uEACA,8EACA,8EACA,6DACA,8EACA,8EACA,iFACA,gCACA,mBACA,oEACA,oEACA,yDACA,yDACA,mDACA,mDACA,0DACA,0DACA,yCACA,0DACA,0DACA,iFACA,oCACA,uBACA,wEACA,wEACA,6DACA,6DACA,uDACA,uDACA,8DACA,8DACA,6CACA,8DACA,8DACA,iFACA,yCACA,2BACA,4EACA,4EACA,iEACA,iEACA,2DACA,2DACA,mEACA,mEACA,iDACA,mEACA,mEACA,iFACA,6CACA,+BACA,gFACA,gFACA,qEACA,qEACA,+DACA,+DACA,uEACA,uEACA,qDACA,uEACA,uEACA,iFACA,iDACA,mCACA,oFACA,oFACA,yEACA,yEACA,mEACA,mEACA,2EACA,2EACA,yDACA,2EACA,2EACA,iFACA,wBACA,6BACA,iFACA,oBACA,yBACA,iFACA,gBACA,qBACA,iFACA,YACA,iBACA,iFACA,QACA,aACA,iFACA,4BACA,iCACA,iFACA,wBACA,6BACA,iFACA,oBACA,yBACA,iFACA,gB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","file":"../skylark-threejs-ex.js","sourcesContent":["define('skylark-threejs-ex/shaders/CopyShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Full-screen textured quad shader\n\t */\n\n\tTHREE.CopyShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"opacity\": { value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 texel = texture2D( tDiffuse, vUv );\",\n\t\t\t\"\tgl_FragColor = opacity * texel;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.CopyShader;\n});\n\ndefine('skylark-threejs-ex/shaders/BokehShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Depth-of-field shader with bokeh\n\t * ported from GLSL shader by Martins Upitis\n\t * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html\n\t */\n\n\tTHREE.BokehShader = {\n\n\t\tdefines: {\n\t\t\t\"DEPTH_PACKING\": 1,\n\t\t\t\"PERSPECTIVE_CAMERA\": 1,\n\t\t},\n\n\t\tuniforms: {\n\n\t\t\t\"tColor\": { value: null },\n\t\t\t\"tDepth\": { value: null },\n\t\t\t\"focus\": { value: 1.0 },\n\t\t\t\"aspect\": { value: 1.0 },\n\t\t\t\"aperture\": { value: 0.025 },\n\t\t\t\"maxblur\": { value: 1.0 },\n\t\t\t\"nearClip\": { value: 1.0 },\n\t\t\t\"farClip\": { value: 1000.0 },\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\t\t\t\"#include <common>\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform sampler2D tColor;\",\n\t\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\t\"uniform float maxblur;\", // max blur amount\n\t\t\t\"uniform float aperture;\", // aperture - bigger values for shallower depth of field\n\n\t\t\t\"uniform float nearClip;\",\n\t\t\t\"uniform float farClip;\",\n\n\t\t\t\"uniform float focus;\",\n\t\t\t\"uniform float aspect;\",\n\n\t\t\t\"#include <packing>\",\n\n\t\t\t\"float getDepth( const in vec2 screenPosition ) {\",\n\t\t\t\"\t#if DEPTH_PACKING == 1\",\n\t\t\t\"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"float getViewZ( const in float depth ) {\",\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\t\t\t\"\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn orthographicDepthToViewZ( depth, nearClip, farClip );\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec2 aspectcorrect = vec2( 1.0, aspect );\",\n\n\t\t\t\"\tfloat viewZ = getViewZ( getDepth( vUv ) );\",\n\n\t\t\t\"\tfloat factor = ( focus + viewZ );\", // viewZ is <= 0, so this is a difference equation\n\n\t\t\t\"\tvec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\",\n\n\t\t\t\"\tvec2 dofblur9 = dofblur * 0.9;\",\n\t\t\t\"\tvec2 dofblur7 = dofblur * 0.7;\",\n\t\t\t\"\tvec2 dofblur4 = dofblur * 0.4;\",\n\n\t\t\t\"\tvec4 col = vec4( 0.0 );\",\n\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\",\n\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\",\n\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\",\n\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\",\n\n\t\t\t\"\tgl_FragColor = col / 41.0;\",\n\t\t\t\"\tgl_FragColor.a = 1.0;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.BokehShader;\n});\n\ndefine('skylark-threejs-ex/shaders/SAOShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * TODO\n\t */\n\n\tTHREE.SAOShader = {\n\t\tdefines: {\n\t\t\t\"NUM_SAMPLES\": 7,\n\t\t\t\"NUM_RINGS\": 4,\n\t\t\t\"NORMAL_TEXTURE\": 0,\n\t\t\t\"DIFFUSE_TEXTURE\": 0,\n\t\t\t\"DEPTH_PACKING\": 1,\n\t\t\t\"PERSPECTIVE_CAMERA\": 1\n\t\t},\n\t\tuniforms: {\n\n\t\t\t\"tDepth\": { value: null },\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"tNormal\": { value: null },\n\t\t\t\"size\": { value: new THREE.Vector2( 512, 512 ) },\n\n\t\t\t\"cameraNear\": { value: 1 },\n\t\t\t\"cameraFar\": { value: 100 },\n\t\t\t\"cameraProjectionMatrix\": { value: new THREE.Matrix4() },\n\t\t\t\"cameraInverseProjectionMatrix\": { value: new THREE.Matrix4() },\n\n\t\t\t\"scale\": { value: 1.0 },\n\t\t\t\"intensity\": { value: 0.1 },\n\t\t\t\"bias\": { value: 0.5 },\n\n\t\t\t\"minResolution\": { value: 0.0 },\n\t\t\t\"kernelRadius\": { value: 100.0 },\n\t\t\t\"randomSeed\": { value: 0.0 }\n\t\t},\n\t\tvertexShader: [\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\t\tfragmentShader: [\n\t\t\t\"#include <common>\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"#if DIFFUSE_TEXTURE == 1\",\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"#endif\",\n\n\t\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\t\"#if NORMAL_TEXTURE == 1\",\n\t\t\t\"uniform sampler2D tNormal;\",\n\t\t\t\"#endif\",\n\n\t\t\t\"uniform float cameraNear;\",\n\t\t\t\"uniform float cameraFar;\",\n\t\t\t\"uniform mat4 cameraProjectionMatrix;\",\n\t\t\t\"uniform mat4 cameraInverseProjectionMatrix;\",\n\n\t\t\t\"uniform float scale;\",\n\t\t\t\"uniform float intensity;\",\n\t\t\t\"uniform float bias;\",\n\t\t\t\"uniform float kernelRadius;\",\n\t\t\t\"uniform float minResolution;\",\n\t\t\t\"uniform vec2 size;\",\n\t\t\t\"uniform float randomSeed;\",\n\n\t\t\t\"// RGBA depth\",\n\n\t\t\t\"#include <packing>\",\n\n\t\t\t\"vec4 getDefaultColor( const in vec2 screenPosition ) {\",\n\t\t\t\"\t#if DIFFUSE_TEXTURE == 1\",\n\t\t\t\"\treturn texture2D( tDiffuse, vUv );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn vec4( 1.0 );\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"float getDepth( const in vec2 screenPosition ) {\",\n\t\t\t\"\t#if DEPTH_PACKING == 1\",\n\t\t\t\"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"float getViewZ( const in float depth ) {\",\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\t\t\t\"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\",\n\t\t\t\"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\",\n\t\t\t\"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\",\n\t\t\t\"\tclipPosition *= clipW; // unprojection.\",\n\n\t\t\t\"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\",\n\t\t\t\"}\",\n\n\t\t\t\"vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {\",\n\t\t\t\"\t#if NORMAL_TEXTURE == 1\",\n\t\t\t\"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"float scaleDividedByCameraFar;\",\n\t\t\t\"float minResolutionMultipliedByCameraFar;\",\n\n\t\t\t\"float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\",\n\t\t\t\"\tvec3 viewDelta = sampleViewPosition - centerViewPosition;\",\n\t\t\t\"\tfloat viewDistance = length( viewDelta );\",\n\t\t\t\"\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\",\n\n\t\t\t\"\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );\",\n\t\t\t\"}\",\n\n\t\t\t\"// moving costly divides into consts\",\n\t\t\t\"const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\",\n\t\t\t\"const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\",\n\n\t\t\t\"float getAmbientOcclusion( const in vec3 centerViewPosition ) {\",\n\t\t\t\"\t// precompute some variables require in getOcclusion.\",\n\t\t\t\"\tscaleDividedByCameraFar = scale / cameraFar;\",\n\t\t\t\"\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;\",\n\t\t\t\"\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );\",\n\n\t\t\t\"\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\",\n\t\t\t\"\tfloat angle = rand( vUv + randomSeed ) * PI2;\",\n\t\t\t\"\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;\",\n\t\t\t\"\tvec2 radiusStep = radius;\",\n\n\t\t\t\"\tfloat occlusionSum = 0.0;\",\n\t\t\t\"\tfloat weightSum = 0.0;\",\n\n\t\t\t\"\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\",\n\t\t\t\"\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;\",\n\t\t\t\"\t\tradius += radiusStep;\",\n\t\t\t\"\t\tangle += ANGLE_STEP;\",\n\n\t\t\t\"\t\tfloat sampleDepth = getDepth( sampleUv );\",\n\t\t\t\"\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\",\n\t\t\t\"\t\t\tcontinue;\",\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t\tfloat sampleViewZ = getViewZ( sampleDepth );\",\n\t\t\t\"\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );\",\n\t\t\t\"\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\",\n\t\t\t\"\t\tweightSum += 1.0;\",\n\t\t\t\"\t}\",\n\n\t\t\t\"\tif( weightSum == 0.0 ) discard;\",\n\n\t\t\t\"\treturn occlusionSum * ( intensity / weightSum );\",\n\t\t\t\"}\",\n\n\n\t\t\t\"void main() {\",\n\t\t\t\"\tfloat centerDepth = getDepth( vUv );\",\n\t\t\t\"\tif( centerDepth >= ( 1.0 - EPSILON ) ) {\",\n\t\t\t\"\t\tdiscard;\",\n\t\t\t\"\t}\",\n\n\t\t\t\"\tfloat centerViewZ = getViewZ( centerDepth );\",\n\t\t\t\"\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\",\n\n\t\t\t\"\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\",\n\n\t\t\t\"\tgl_FragColor = getDefaultColor( vUv );\",\n\t\t\t\"\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\t};\n\t\n\treturn THREE.SAOShader;\n});\n\ndefine('skylark-threejs-ex/shaders/DepthLimitedBlurShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * TODO\n\t */\n\n\tTHREE.DepthLimitedBlurShader = {\n\t\tdefines: {\n\t\t\t\"KERNEL_RADIUS\": 4,\n\t\t\t\"DEPTH_PACKING\": 1,\n\t\t\t\"PERSPECTIVE_CAMERA\": 1\n\t\t},\n\t\tuniforms: {\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"size\": { value: new THREE.Vector2( 512, 512 ) },\n\t\t\t\"sampleUvOffsets\": { value: [ new THREE.Vector2( 0, 0 ) ] },\n\t\t\t\"sampleWeights\": { value: [ 1.0 ] },\n\t\t\t\"tDepth\": { value: null },\n\t\t\t\"cameraNear\": { value: 10 },\n\t\t\t\"cameraFar\": { value: 1000 },\n\t\t\t\"depthCutoff\": { value: 10 },\n\t\t},\n\t\tvertexShader: [\n\t\t\t\"#include <common>\",\n\n\t\t\t\"uniform vec2 size;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"varying vec2 vInvSize;\",\n\n\t\t\t\"void main() {\",\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tvInvSize = 1.0 / size;\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\t\tfragmentShader: [\n\t\t\t\"#include <common>\",\n\t\t\t\"#include <packing>\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\t\"uniform float cameraNear;\",\n\t\t\t\"uniform float cameraFar;\",\n\t\t\t\"uniform float depthCutoff;\",\n\n\t\t\t\"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\",\n\t\t\t\"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\",\n\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"varying vec2 vInvSize;\",\n\n\t\t\t\"float getDepth( const in vec2 screenPosition ) {\",\n\t\t\t\"\t#if DEPTH_PACKING == 1\",\n\t\t\t\"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"float getViewZ( const in float depth ) {\",\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\t\t\t\"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\t\t\t\"\tfloat depth = getDepth( vUv );\",\n\t\t\t\"\tif( depth >= ( 1.0 - EPSILON ) ) {\",\n\t\t\t\"\t\tdiscard;\",\n\t\t\t\"\t}\",\n\n\t\t\t\"\tfloat centerViewZ = -getViewZ( depth );\",\n\t\t\t\"\tbool rBreak = false, lBreak = false;\",\n\n\t\t\t\"\tfloat weightSum = sampleWeights[0];\",\n\t\t\t\"\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\",\n\n\t\t\t\"\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\",\n\n\t\t\t\"\t\tfloat sampleWeight = sampleWeights[i];\",\n\t\t\t\"\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\",\n\n\t\t\t\"\t\tvec2 sampleUv = vUv + sampleUvOffset;\",\n\t\t\t\"\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\",\n\n\t\t\t\"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\",\n\n\t\t\t\"\t\tif( ! rBreak ) {\",\n\t\t\t\"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\",\n\t\t\t\"\t\t\tweightSum += sampleWeight;\",\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t\tsampleUv = vUv - sampleUvOffset;\",\n\t\t\t\"\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\",\n\n\t\t\t\"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\",\n\n\t\t\t\"\t\tif( ! lBreak ) {\",\n\t\t\t\"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\",\n\t\t\t\"\t\t\tweightSum += sampleWeight;\",\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\tgl_FragColor = diffuseSum / weightSum;\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\t};\n\n\tTHREE.BlurShaderUtils = {\n\n\t\tcreateSampleWeights: function ( kernelRadius, stdDev ) {\n\n\t\t\tvar gaussian = function ( x, stdDev ) {\n\n\t\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * ( stdDev * stdDev ) ) ) / ( Math.sqrt( 2.0 * Math.PI ) * stdDev );\n\n\t\t\t};\n\n\t\t\tvar weights = [];\n\n\t\t\tfor ( var i = 0; i <= kernelRadius; i ++ ) {\n\n\t\t\t\tweights.push( gaussian( i, stdDev ) );\n\n\t\t\t}\n\n\t\t\treturn weights;\n\n\t\t},\n\n\t\tcreateSampleOffsets: function ( kernelRadius, uvIncrement ) {\n\n\t\t\tvar offsets = [];\n\n\t\t\tfor ( var i = 0; i <= kernelRadius; i ++ ) {\n\n\t\t\t\toffsets.push( uvIncrement.clone().multiplyScalar( i ) );\n\n\t\t\t}\n\n\t\t\treturn offsets;\n\n\t\t},\n\n\t\tconfigure: function ( material, kernelRadius, stdDev, uvIncrement ) {\n\n\t\t\tmaterial.defines[ \"KERNEL_RADIUS\" ] = kernelRadius;\n\t\t\tmaterial.uniforms[ \"sampleUvOffsets\" ].value = THREE.BlurShaderUtils.createSampleOffsets( kernelRadius, uvIncrement );\n\t\t\tmaterial.uniforms[ \"sampleWeights\" ].value = THREE.BlurShaderUtils.createSampleWeights( kernelRadius, stdDev );\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.DepthLimitedBlurShader;\n});\n\ndefine('skylark-threejs-ex/shaders/UnpackDepthRGBAShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Unpack RGBA depth shader\n\t * - show RGBA encoded depth as monochrome color\n\t */\n\n\tTHREE.UnpackDepthRGBAShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"opacity\": { value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"#include <packing>\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tfloat depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );\",\n\t\t\t\"\tgl_FragColor = vec4( vec3( depth ), opacity );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.UnpackDepthRGBAShader;\n});\n\ndefine('skylark-threejs-ex/shaders/ConvolutionShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Convolution shader\n\t * ported from o3d sample to WebGL / GLSL\n\t * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n\t */\n\n\tTHREE.ConvolutionShader = {\n\n\t\tdefines: {\n\n\t\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\n\t\t\t\"KERNEL_SIZE_INT\": \"25\"\n\n\t\t},\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"uImageIncrement\": { value: new THREE.Vector2( 0.001953125, 0.0 ) },\n\t\t\t\"cKernel\": { value: [] }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float cKernel[ KERNEL_SIZE_INT ];\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec2 imageCoord = vUv;\",\n\t\t\t\"\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\n\n\t\t\t\"\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\",\n\n\t\t\t\"\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\n\t\t\t\"\t\timageCoord += uImageIncrement;\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\tgl_FragColor = sum;\",\n\n\t\t\t\"}\"\n\n\n\t\t].join( \"\\n\" ),\n\n\t\tbuildKernel: function ( sigma ) {\n\n\t\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n\t\t\tfunction gauss( x, sigma ) {\n\n\t\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\n\n\t\t\t}\n\n\t\t\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\n\n\t\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\n\t\t\thalfWidth = ( kernelSize - 1 ) * 0.5;\n\n\t\t\tvalues = new Array( kernelSize );\n\t\t\tsum = 0.0;\n\t\t\tfor ( i = 0; i < kernelSize; ++ i ) {\n\n\t\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\n\t\t\t\tsum += values[ i ];\n\n\t\t\t}\n\n\t\t\t// normalize the kernel\n\n\t\t\tfor ( i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;\n\n\t\t\treturn values;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.ConvolutionShader;\n});\ndefine('skylark-threejs-ex/shaders/LuminosityHighPassShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author bhouston / http://clara.io/\n\t *\n\t * Luminosity\n\t * http://en.wikipedia.org/wiki/Luminosity\n\t */\n\n\tTHREE.LuminosityHighPassShader = {\n\n\t\tshaderID: \"luminosityHighPass\",\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"luminosityThreshold\": { value: 1.0 },\n\t\t\t\"smoothWidth\": { value: 1.0 },\n\t\t\t\"defaultColor\": { value: new THREE.Color( 0x000000 ) },\n\t\t\t\"defaultOpacity\": { value: 0.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform vec3 defaultColor;\",\n\t\t\t\"uniform float defaultOpacity;\",\n\t\t\t\"uniform float luminosityThreshold;\",\n\t\t\t\"uniform float smoothWidth;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 texel = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\",\n\n\t\t\t\"\tfloat v = dot( texel.xyz, luma );\",\n\n\t\t\t\"\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\",\n\n\t\t\t\"\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\",\n\n\t\t\t\"\tgl_FragColor = mix( outputColor, texel, alpha );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.LuminosityHighPassShader;\n});\n\ndefine('skylark-threejs-ex/shaders/FXAAShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author davidedc / http://www.sketchpatch.net/\n\t *\n\t * NVIDIA FXAA by Timothy Lottes\n\t * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\n\t * - WebGL port by @supereggbert\n\t * http://www.glge.org/demos/fxaa/\n\t */\n\n\tTHREE.FXAAShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"resolution\": { value: new THREE.Vector2( 1 / 1024, 1 / 512 ) }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\t\t\t\"precision highp float;\",\n\t\t\t\"\",\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"\",\n\t\t\t\"uniform vec2 resolution;\",\n\t\t\t\"\",\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"\",\n\t\t\t\"// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\",\n\t\t\t\"\",\n\t\t\t\"//----------------------------------------------------------------------------------\",\n\t\t\t\"// File:        es3-kepler\\FXAA\\assets\\shaders/FXAA_DefaultES.frag\",\n\t\t\t\"// SDK Version: v3.00\",\n\t\t\t\"// Email:       gameworks@nvidia.com\",\n\t\t\t\"// Site:        http://developer.nvidia.com/\",\n\t\t\t\"//\",\n\t\t\t\"// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\",\n\t\t\t\"//\",\n\t\t\t\"// Redistribution and use in source and binary forms, with or without\",\n\t\t\t\"// modification, are permitted provided that the following conditions\",\n\t\t\t\"// are met:\",\n\t\t\t\"//  * Redistributions of source code must retain the above copyright\",\n\t\t\t\"//    notice, this list of conditions and the following disclaimer.\",\n\t\t\t\"//  * Redistributions in binary form must reproduce the above copyright\",\n\t\t\t\"//    notice, this list of conditions and the following disclaimer in the\",\n\t\t\t\"//    documentation and/or other materials provided with the distribution.\",\n\t\t\t\"//  * Neither the name of NVIDIA CORPORATION nor the names of its\",\n\t\t\t\"//    contributors may be used to endorse or promote products derived\",\n\t\t\t\"//    from this software without specific prior written permission.\",\n\t\t\t\"//\",\n\t\t\t\"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\",\n\t\t\t\"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\",\n\t\t\t\"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\",\n\t\t\t\"// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\",\n\t\t\t\"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\",\n\t\t\t\"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\",\n\t\t\t\"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\",\n\t\t\t\"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\",\n\t\t\t\"// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\",\n\t\t\t\"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\",\n\t\t\t\"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\",\n\t\t\t\"//\",\n\t\t\t\"//----------------------------------------------------------------------------------\",\n\t\t\t\"\",\n\t\t\t\"#define FXAA_PC 1\",\n\t\t\t\"#define FXAA_GLSL_100 1\",\n\t\t\t\"#define FXAA_QUALITY_PRESET 12\",\n\t\t\t\"\",\n\t\t\t\"#define FXAA_GREEN_AS_LUMA 1\",\n\t\t\t\"\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_PC_CONSOLE\",\n\t\t\t\"    //\",\n\t\t\t\"    // The console algorithm for PC is included\",\n\t\t\t\"    // for developers targeting really low spec machines.\",\n\t\t\t\"    // Likely better to just run FXAA_PC, and use a really low preset.\",\n\t\t\t\"    //\",\n\t\t\t\"    #define FXAA_PC_CONSOLE 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_GLSL_120\",\n\t\t\t\"    #define FXAA_GLSL_120 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_GLSL_130\",\n\t\t\t\"    #define FXAA_GLSL_130 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_HLSL_3\",\n\t\t\t\"    #define FXAA_HLSL_3 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_HLSL_4\",\n\t\t\t\"    #define FXAA_HLSL_4 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_HLSL_5\",\n\t\t\t\"    #define FXAA_HLSL_5 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*==========================================================================*/\",\n\t\t\t\"#ifndef FXAA_GREEN_AS_LUMA\",\n\t\t\t\"    //\",\n\t\t\t\"    // For those using non-linear color,\",\n\t\t\t\"    // and either not able to get luma in alpha, or not wanting to,\",\n\t\t\t\"    // this enables FXAA to run using green as a proxy for luma.\",\n\t\t\t\"    // So with this enabled, no need to pack luma in alpha.\",\n\t\t\t\"    //\",\n\t\t\t\"    // This will turn off AA on anything which lacks some amount of green.\",\n\t\t\t\"    // Pure red and blue or combination of only R and B, will get no AA.\",\n\t\t\t\"    //\",\n\t\t\t\"    // Might want to lower the settings for both,\",\n\t\t\t\"    //    fxaaConsoleEdgeThresholdMin\",\n\t\t\t\"    //    fxaaQualityEdgeThresholdMin\",\n\t\t\t\"    // In order to insure AA does not get turned off on colors\",\n\t\t\t\"    // which contain a minor amount of green.\",\n\t\t\t\"    //\",\n\t\t\t\"    // 1 = On.\",\n\t\t\t\"    // 0 = Off.\",\n\t\t\t\"    //\",\n\t\t\t\"    #define FXAA_GREEN_AS_LUMA 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_EARLY_EXIT\",\n\t\t\t\"    //\",\n\t\t\t\"    // Controls algorithm's early exit path.\",\n\t\t\t\"    // On PS3 turning this ON adds 2 cycles to the shader.\",\n\t\t\t\"    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\",\n\t\t\t\"    // Turning this off on console will result in a more blurry image.\",\n\t\t\t\"    // So this defaults to on.\",\n\t\t\t\"    //\",\n\t\t\t\"    // 1 = On.\",\n\t\t\t\"    // 0 = Off.\",\n\t\t\t\"    //\",\n\t\t\t\"    #define FXAA_EARLY_EXIT 1\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_DISCARD\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only valid for PC OpenGL currently.\",\n\t\t\t\"    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\",\n\t\t\t\"    //\",\n\t\t\t\"    // 1 = Use discard on pixels which don't need AA.\",\n\t\t\t\"    //     For APIs which enable concurrent TEX+ROP from same surface.\",\n\t\t\t\"    // 0 = Return unchanged color on pixels which don't need AA.\",\n\t\t\t\"    //\",\n\t\t\t\"    #define FXAA_DISCARD 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_FAST_PIXEL_OFFSET\",\n\t\t\t\"    //\",\n\t\t\t\"    // Used for GLSL 120 only.\",\n\t\t\t\"    //\",\n\t\t\t\"    // 1 = GL API supports fast pixel offsets\",\n\t\t\t\"    // 0 = do not use fast pixel offsets\",\n\t\t\t\"    //\",\n\t\t\t\"    #ifdef GL_EXT_gpu_shader4\",\n\t\t\t\"        #define FXAA_FAST_PIXEL_OFFSET 1\",\n\t\t\t\"    #endif\",\n\t\t\t\"    #ifdef GL_NV_gpu_shader5\",\n\t\t\t\"        #define FXAA_FAST_PIXEL_OFFSET 1\",\n\t\t\t\"    #endif\",\n\t\t\t\"    #ifdef GL_ARB_gpu_shader5\",\n\t\t\t\"        #define FXAA_FAST_PIXEL_OFFSET 1\",\n\t\t\t\"    #endif\",\n\t\t\t\"    #ifndef FXAA_FAST_PIXEL_OFFSET\",\n\t\t\t\"        #define FXAA_FAST_PIXEL_OFFSET 0\",\n\t\t\t\"    #endif\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_GATHER4_ALPHA\",\n\t\t\t\"    //\",\n\t\t\t\"    // 1 = API supports gather4 on alpha channel.\",\n\t\t\t\"    // 0 = API does not support gather4 on alpha channel.\",\n\t\t\t\"    //\",\n\t\t\t\"    #if (FXAA_HLSL_5 == 1)\",\n\t\t\t\"        #define FXAA_GATHER4_ALPHA 1\",\n\t\t\t\"    #endif\",\n\t\t\t\"    #ifdef GL_ARB_gpu_shader5\",\n\t\t\t\"        #define FXAA_GATHER4_ALPHA 1\",\n\t\t\t\"    #endif\",\n\t\t\t\"    #ifdef GL_NV_gpu_shader5\",\n\t\t\t\"        #define FXAA_GATHER4_ALPHA 1\",\n\t\t\t\"    #endif\",\n\t\t\t\"    #ifndef FXAA_GATHER4_ALPHA\",\n\t\t\t\"        #define FXAA_GATHER4_ALPHA 0\",\n\t\t\t\"    #endif\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"                        FXAA QUALITY - TUNING KNOBS\",\n\t\t\t\"------------------------------------------------------------------------------\",\n\t\t\t\"NOTE the other tuning knobs are now in the shader function inputs!\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"#ifndef FXAA_QUALITY_PRESET\",\n\t\t\t\"    //\",\n\t\t\t\"    // Choose the quality preset.\",\n\t\t\t\"    // This needs to be compiled into the shader as it effects code.\",\n\t\t\t\"    // Best option to include multiple presets is to\",\n\t\t\t\"    // in each shader define the preset, then include this file.\",\n\t\t\t\"    //\",\n\t\t\t\"    // OPTIONS\",\n\t\t\t\"    // -----------------------------------------------------------------------\",\n\t\t\t\"    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\",\n\t\t\t\"    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\",\n\t\t\t\"    // 39       - no dither, very expensive\",\n\t\t\t\"    //\",\n\t\t\t\"    // NOTES\",\n\t\t\t\"    // -----------------------------------------------------------------------\",\n\t\t\t\"    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\",\n\t\t\t\"    // 13 = about same speed as FXAA 3.9 and better than 12\",\n\t\t\t\"    // 23 = closest to FXAA 3.9 visually and performance wise\",\n\t\t\t\"    //  _ = the lowest digit is directly related to performance\",\n\t\t\t\"    // _  = the highest digit is directly related to style\",\n\t\t\t\"    //\",\n\t\t\t\"    #define FXAA_QUALITY_PRESET 12\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"\",\n\t\t\t\"                           FXAA QUALITY - PRESETS\",\n\t\t\t\"\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"                     FXAA QUALITY - MEDIUM DITHER PRESETS\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 10)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 3\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P1 3.0\",\n\t\t\t\"    #define FXAA_QUALITY_P2 12.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 11)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 4\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 3.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 12.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 12)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 5\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 12.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 13)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 6\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 12.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 14)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 7\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 12.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 15)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 8\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P7 12.0\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"                     FXAA QUALITY - LOW DITHER PRESETS\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 20)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 3\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P1 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P2 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 21)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 4\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 22)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 5\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 23)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 6\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 24)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 7\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 3.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 25)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 8\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P7 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 26)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 9\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P7 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P8 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 27)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 10\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P7 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P8 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P9 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 28)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 11\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P7 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P8 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P9 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P10 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 29)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 12\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P7 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P8 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P9 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P10 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P11 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"                     FXAA QUALITY - EXTREME QUALITY\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 39)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 12\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P2 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P6 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P7 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P8 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P9 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P10 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P11 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"\",\n\t\t\t\"                                API PORTING\",\n\t\t\t\"\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\",\n\t\t\t\"    #define FxaaBool bool\",\n\t\t\t\"    #define FxaaDiscard discard\",\n\t\t\t\"    #define FxaaFloat float\",\n\t\t\t\"    #define FxaaFloat2 vec2\",\n\t\t\t\"    #define FxaaFloat3 vec3\",\n\t\t\t\"    #define FxaaFloat4 vec4\",\n\t\t\t\"    #define FxaaHalf float\",\n\t\t\t\"    #define FxaaHalf2 vec2\",\n\t\t\t\"    #define FxaaHalf3 vec3\",\n\t\t\t\"    #define FxaaHalf4 vec4\",\n\t\t\t\"    #define FxaaInt2 ivec2\",\n\t\t\t\"    #define FxaaSat(x) clamp(x, 0.0, 1.0)\",\n\t\t\t\"    #define FxaaTex sampler2D\",\n\t\t\t\"#else\",\n\t\t\t\"    #define FxaaBool bool\",\n\t\t\t\"    #define FxaaDiscard clip(-1)\",\n\t\t\t\"    #define FxaaFloat float\",\n\t\t\t\"    #define FxaaFloat2 float2\",\n\t\t\t\"    #define FxaaFloat3 float3\",\n\t\t\t\"    #define FxaaFloat4 float4\",\n\t\t\t\"    #define FxaaHalf half\",\n\t\t\t\"    #define FxaaHalf2 half2\",\n\t\t\t\"    #define FxaaHalf3 half3\",\n\t\t\t\"    #define FxaaHalf4 half4\",\n\t\t\t\"    #define FxaaSat(x) saturate(x)\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_GLSL_100 == 1)\",\n\t\t\t\"  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\",\n\t\t\t\"  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_GLSL_120 == 1)\",\n\t\t\t\"    // Requires,\",\n\t\t\t\"    //  #version 120\",\n\t\t\t\"    // And at least,\",\n\t\t\t\"    //  #extension GL_EXT_gpu_shader4 : enable\",\n\t\t\t\"    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\",\n\t\t\t\"    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\",\n\t\t\t\"    #if (FXAA_FAST_PIXEL_OFFSET == 1)\",\n\t\t\t\"        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\",\n\t\t\t\"    #else\",\n\t\t\t\"        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\",\n\t\t\t\"    #endif\",\n\t\t\t\"    #if (FXAA_GATHER4_ALPHA == 1)\",\n\t\t\t\"        // use #extension GL_ARB_gpu_shader5 : enable\",\n\t\t\t\"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\",\n\t\t\t\"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\",\n\t\t\t\"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\",\n\t\t\t\"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\",\n\t\t\t\"    #endif\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_GLSL_130 == 1)\",\n\t\t\t\"    // Requires \\\"#version 130\\\" or better\",\n\t\t\t\"    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\",\n\t\t\t\"    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\",\n\t\t\t\"    #if (FXAA_GATHER4_ALPHA == 1)\",\n\t\t\t\"        // use #extension GL_ARB_gpu_shader5 : enable\",\n\t\t\t\"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\",\n\t\t\t\"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\",\n\t\t\t\"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\",\n\t\t\t\"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\",\n\t\t\t\"    #endif\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_HLSL_3 == 1)\",\n\t\t\t\"    #define FxaaInt2 float2\",\n\t\t\t\"    #define FxaaTex sampler2D\",\n\t\t\t\"    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\",\n\t\t\t\"    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_HLSL_4 == 1)\",\n\t\t\t\"    #define FxaaInt2 int2\",\n\t\t\t\"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\",\n\t\t\t\"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\",\n\t\t\t\"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_HLSL_5 == 1)\",\n\t\t\t\"    #define FxaaInt2 int2\",\n\t\t\t\"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\",\n\t\t\t\"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\",\n\t\t\t\"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\",\n\t\t\t\"    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\",\n\t\t\t\"    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\",\n\t\t\t\"    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\",\n\t\t\t\"    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"                   GREEN AS LUMA OPTION SUPPORT FUNCTION\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"#if (FXAA_GREEN_AS_LUMA == 0)\",\n\t\t\t\"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\",\n\t\t\t\"#else\",\n\t\t\t\"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"\",\n\t\t\t\"                             FXAA3 QUALITY - PC\",\n\t\t\t\"\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"#if (FXAA_PC == 1)\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"FxaaFloat4 FxaaPixelShader(\",\n\t\t\t\"    //\",\n\t\t\t\"    // Use noperspective interpolation here (turn off perspective interpolation).\",\n\t\t\t\"    // {xy} = center of pixel\",\n\t\t\t\"    FxaaFloat2 pos,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Used only for FXAA Console, and not used on the 360 version.\",\n\t\t\t\"    // Use noperspective interpolation here (turn off perspective interpolation).\",\n\t\t\t\"    // {xy_} = upper left of pixel\",\n\t\t\t\"    // {_zw} = lower right of pixel\",\n\t\t\t\"    FxaaFloat4 fxaaConsolePosPos,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Input color texture.\",\n\t\t\t\"    // {rgb_} = color in linear or perceptual color space\",\n\t\t\t\"    // if (FXAA_GREEN_AS_LUMA == 0)\",\n\t\t\t\"    //     {__a} = luma in perceptual color space (not linear)\",\n\t\t\t\"    FxaaTex tex,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on the optimized 360 version of FXAA Console.\",\n\t\t\t\"    // For everything but 360, just use the same input here as for \\\"tex\\\".\",\n\t\t\t\"    // For 360, same texture, just alias with a 2nd sampler.\",\n\t\t\t\"    // This sampler needs to have an exponent bias of -1.\",\n\t\t\t\"    FxaaTex fxaaConsole360TexExpBiasNegOne,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on the optimized 360 version of FXAA Console.\",\n\t\t\t\"    // For everything but 360, just use the same input here as for \\\"tex\\\".\",\n\t\t\t\"    // For 360, same texture, just alias with a 3nd sampler.\",\n\t\t\t\"    // This sampler needs to have an exponent bias of -2.\",\n\t\t\t\"    FxaaTex fxaaConsole360TexExpBiasNegTwo,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Quality.\",\n\t\t\t\"    // This must be from a constant/uniform.\",\n\t\t\t\"    // {x_} = 1.0/screenWidthInPixels\",\n\t\t\t\"    // {_y} = 1.0/screenHeightInPixels\",\n\t\t\t\"    FxaaFloat2 fxaaQualityRcpFrame,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Console.\",\n\t\t\t\"    // This must be from a constant/uniform.\",\n\t\t\t\"    // This effects sub-pixel AA quality and inversely sharpness.\",\n\t\t\t\"    //   Where N ranges between,\",\n\t\t\t\"    //     N = 0.50 (default)\",\n\t\t\t\"    //     N = 0.33 (sharper)\",\n\t\t\t\"    // {x__} = -N/screenWidthInPixels\",\n\t\t\t\"    // {_y_} = -N/screenHeightInPixels\",\n\t\t\t\"    // {_z_} =  N/screenWidthInPixels\",\n\t\t\t\"    // {__w} =  N/screenHeightInPixels\",\n\t\t\t\"    FxaaFloat4 fxaaConsoleRcpFrameOpt,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Console.\",\n\t\t\t\"    // Not used on 360, but used on PS3 and PC.\",\n\t\t\t\"    // This must be from a constant/uniform.\",\n\t\t\t\"    // {x__} = -2.0/screenWidthInPixels\",\n\t\t\t\"    // {_y_} = -2.0/screenHeightInPixels\",\n\t\t\t\"    // {_z_} =  2.0/screenWidthInPixels\",\n\t\t\t\"    // {__w} =  2.0/screenHeightInPixels\",\n\t\t\t\"    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Console.\",\n\t\t\t\"    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\",\n\t\t\t\"    // This must be from a constant/uniform.\",\n\t\t\t\"    // {x__} =  8.0/screenWidthInPixels\",\n\t\t\t\"    // {_y_} =  8.0/screenHeightInPixels\",\n\t\t\t\"    // {_z_} = -4.0/screenWidthInPixels\",\n\t\t\t\"    // {__w} = -4.0/screenHeightInPixels\",\n\t\t\t\"    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Quality.\",\n\t\t\t\"    // This used to be the FXAA_QUALITY_SUBPIX define.\",\n\t\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\t\"    // Choose the amount of sub-pixel aliasing removal.\",\n\t\t\t\"    // This can effect sharpness.\",\n\t\t\t\"    //   1.00 - upper limit (softer)\",\n\t\t\t\"    //   0.75 - default amount of filtering\",\n\t\t\t\"    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\",\n\t\t\t\"    //   0.25 - almost off\",\n\t\t\t\"    //   0.00 - completely off\",\n\t\t\t\"    FxaaFloat fxaaQualitySubpix,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Quality.\",\n\t\t\t\"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\",\n\t\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\t\"    // The minimum amount of local contrast required to apply algorithm.\",\n\t\t\t\"    //   0.333 - too little (faster)\",\n\t\t\t\"    //   0.250 - low quality\",\n\t\t\t\"    //   0.166 - default\",\n\t\t\t\"    //   0.125 - high quality\",\n\t\t\t\"    //   0.063 - overkill (slower)\",\n\t\t\t\"    FxaaFloat fxaaQualityEdgeThreshold,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Quality.\",\n\t\t\t\"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\",\n\t\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\t\"    // Trims the algorithm from processing darks.\",\n\t\t\t\"    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\",\n\t\t\t\"    //   0.0625 - high quality (faster)\",\n\t\t\t\"    //   0.0312 - visible limit (slower)\",\n\t\t\t\"    // Special notes when using FXAA_GREEN_AS_LUMA,\",\n\t\t\t\"    //   Likely want to set this to zero.\",\n\t\t\t\"    //   As colors that are mostly not-green\",\n\t\t\t\"    //   will appear very dark in the green channel!\",\n\t\t\t\"    //   Tune by looking at mostly non-green content,\",\n\t\t\t\"    //   then start at zero and increase until aliasing is a problem.\",\n\t\t\t\"    FxaaFloat fxaaQualityEdgeThresholdMin,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Console.\",\n\t\t\t\"    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\",\n\t\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\t\"    // This does not effect PS3, as this needs to be compiled in.\",\n\t\t\t\"    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\",\n\t\t\t\"    //   Due to the PS3 being ALU bound,\",\n\t\t\t\"    //   there are only three safe values here: 2 and 4 and 8.\",\n\t\t\t\"    //   These options use the shaders ability to a free *|/ by 2|4|8.\",\n\t\t\t\"    // For all other platforms can be a non-power of two.\",\n\t\t\t\"    //   8.0 is sharper (default!!!)\",\n\t\t\t\"    //   4.0 is softer\",\n\t\t\t\"    //   2.0 is really soft (good only for vector graphics inputs)\",\n\t\t\t\"    FxaaFloat fxaaConsoleEdgeSharpness,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Console.\",\n\t\t\t\"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\",\n\t\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\t\"    // This does not effect PS3, as this needs to be compiled in.\",\n\t\t\t\"    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\",\n\t\t\t\"    //   Due to the PS3 being ALU bound,\",\n\t\t\t\"    //   there are only two safe values here: 1/4 and 1/8.\",\n\t\t\t\"    //   These options use the shaders ability to a free *|/ by 2|4|8.\",\n\t\t\t\"    // The console setting has a different mapping than the quality setting.\",\n\t\t\t\"    // Other platforms can use other values.\",\n\t\t\t\"    //   0.125 leaves less aliasing, but is softer (default!!!)\",\n\t\t\t\"    //   0.25 leaves more aliasing, and is sharper\",\n\t\t\t\"    FxaaFloat fxaaConsoleEdgeThreshold,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Console.\",\n\t\t\t\"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\",\n\t\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\t\"    // Trims the algorithm from processing darks.\",\n\t\t\t\"    // The console setting has a different mapping than the quality setting.\",\n\t\t\t\"    // This only applies when FXAA_EARLY_EXIT is 1.\",\n\t\t\t\"    // This does not apply to PS3,\",\n\t\t\t\"    // PS3 was simplified to avoid more shader instructions.\",\n\t\t\t\"    //   0.06 - faster but more aliasing in darks\",\n\t\t\t\"    //   0.05 - default\",\n\t\t\t\"    //   0.04 - slower and less aliasing in darks\",\n\t\t\t\"    // Special notes when using FXAA_GREEN_AS_LUMA,\",\n\t\t\t\"    //   Likely want to set this to zero.\",\n\t\t\t\"    //   As colors that are mostly not-green\",\n\t\t\t\"    //   will appear very dark in the green channel!\",\n\t\t\t\"    //   Tune by looking at mostly non-green content,\",\n\t\t\t\"    //   then start at zero and increase until aliasing is a problem.\",\n\t\t\t\"    FxaaFloat fxaaConsoleEdgeThresholdMin,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Extra constants for 360 FXAA Console only.\",\n\t\t\t\"    // Use zeros or anything else for other platforms.\",\n\t\t\t\"    // These must be in physical constant registers and NOT immediates.\",\n\t\t\t\"    // Immediates will result in compiler un-optimizing.\",\n\t\t\t\"    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\",\n\t\t\t\"    FxaaFloat4 fxaaConsole360ConstDir\",\n\t\t\t\") {\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat2 posM;\",\n\t\t\t\"    posM.x = pos.x;\",\n\t\t\t\"    posM.y = pos.y;\",\n\t\t\t\"    #if (FXAA_GATHER4_ALPHA == 1)\",\n\t\t\t\"        #if (FXAA_DISCARD == 0)\",\n\t\t\t\"            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\",\n\t\t\t\"            #if (FXAA_GREEN_AS_LUMA == 0)\",\n\t\t\t\"                #define lumaM rgbyM.w\",\n\t\t\t\"            #else\",\n\t\t\t\"                #define lumaM rgbyM.y\",\n\t\t\t\"            #endif\",\n\t\t\t\"        #endif\",\n\t\t\t\"        #if (FXAA_GREEN_AS_LUMA == 0)\",\n\t\t\t\"            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\",\n\t\t\t\"            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\",\n\t\t\t\"        #else\",\n\t\t\t\"            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\",\n\t\t\t\"            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\",\n\t\t\t\"        #endif\",\n\t\t\t\"        #if (FXAA_DISCARD == 1)\",\n\t\t\t\"            #define lumaM luma4A.w\",\n\t\t\t\"        #endif\",\n\t\t\t\"        #define lumaE luma4A.z\",\n\t\t\t\"        #define lumaS luma4A.x\",\n\t\t\t\"        #define lumaSE luma4A.y\",\n\t\t\t\"        #define lumaNW luma4B.w\",\n\t\t\t\"        #define lumaN luma4B.z\",\n\t\t\t\"        #define lumaW luma4B.x\",\n\t\t\t\"    #else\",\n\t\t\t\"        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\",\n\t\t\t\"        #if (FXAA_GREEN_AS_LUMA == 0)\",\n\t\t\t\"            #define lumaM rgbyM.w\",\n\t\t\t\"        #else\",\n\t\t\t\"            #define lumaM rgbyM.y\",\n\t\t\t\"        #endif\",\n\t\t\t\"        #if (FXAA_GLSL_100 == 1)\",\n\t\t\t\"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"        #else\",\n\t\t\t\"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"        #endif\",\n\t\t\t\"    #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat maxSM = max(lumaS, lumaM);\",\n\t\t\t\"    FxaaFloat minSM = min(lumaS, lumaM);\",\n\t\t\t\"    FxaaFloat maxESM = max(lumaE, maxSM);\",\n\t\t\t\"    FxaaFloat minESM = min(lumaE, minSM);\",\n\t\t\t\"    FxaaFloat maxWN = max(lumaN, lumaW);\",\n\t\t\t\"    FxaaFloat minWN = min(lumaN, lumaW);\",\n\t\t\t\"    FxaaFloat rangeMax = max(maxWN, maxESM);\",\n\t\t\t\"    FxaaFloat rangeMin = min(minWN, minESM);\",\n\t\t\t\"    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\",\n\t\t\t\"    FxaaFloat range = rangeMax - rangeMin;\",\n\t\t\t\"    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\",\n\t\t\t\"    FxaaBool earlyExit = range < rangeMaxClamped;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    if(earlyExit)\",\n\t\t\t\"        #if (FXAA_DISCARD == 1)\",\n\t\t\t\"            FxaaDiscard;\",\n\t\t\t\"        #else\",\n\t\t\t\"            return rgbyM;\",\n\t\t\t\"        #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    #if (FXAA_GATHER4_ALPHA == 0)\",\n\t\t\t\"        #if (FXAA_GLSL_100 == 1)\",\n\t\t\t\"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"        #else\",\n\t\t\t\"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"        #endif\",\n\t\t\t\"    #else\",\n\t\t\t\"        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"    #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat lumaNS = lumaN + lumaS;\",\n\t\t\t\"    FxaaFloat lumaWE = lumaW + lumaE;\",\n\t\t\t\"    FxaaFloat subpixRcpRange = 1.0/range;\",\n\t\t\t\"    FxaaFloat subpixNSWE = lumaNS + lumaWE;\",\n\t\t\t\"    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\",\n\t\t\t\"    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat lumaNESE = lumaNE + lumaSE;\",\n\t\t\t\"    FxaaFloat lumaNWNE = lumaNW + lumaNE;\",\n\t\t\t\"    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\",\n\t\t\t\"    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat lumaNWSW = lumaNW + lumaSW;\",\n\t\t\t\"    FxaaFloat lumaSWSE = lumaSW + lumaSE;\",\n\t\t\t\"    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\",\n\t\t\t\"    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\",\n\t\t\t\"    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\",\n\t\t\t\"    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\",\n\t\t\t\"    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\",\n\t\t\t\"    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\",\n\t\t\t\"    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\",\n\t\t\t\"    FxaaBool horzSpan = edgeHorz >= edgeVert;\",\n\t\t\t\"    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    if(!horzSpan) lumaN = lumaW;\",\n\t\t\t\"    if(!horzSpan) lumaS = lumaE;\",\n\t\t\t\"    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\",\n\t\t\t\"    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat gradientN = lumaN - lumaM;\",\n\t\t\t\"    FxaaFloat gradientS = lumaS - lumaM;\",\n\t\t\t\"    FxaaFloat lumaNN = lumaN + lumaM;\",\n\t\t\t\"    FxaaFloat lumaSS = lumaS + lumaM;\",\n\t\t\t\"    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\",\n\t\t\t\"    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\",\n\t\t\t\"    if(pairN) lengthSign = -lengthSign;\",\n\t\t\t\"    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat2 posB;\",\n\t\t\t\"    posB.x = posM.x;\",\n\t\t\t\"    posB.y = posM.y;\",\n\t\t\t\"    FxaaFloat2 offNP;\",\n\t\t\t\"    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\",\n\t\t\t\"    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\",\n\t\t\t\"    if(!horzSpan) posB.x += lengthSign * 0.5;\",\n\t\t\t\"    if( horzSpan) posB.y += lengthSign * 0.5;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat2 posN;\",\n\t\t\t\"    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\",\n\t\t\t\"    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\",\n\t\t\t\"    FxaaFloat2 posP;\",\n\t\t\t\"    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\",\n\t\t\t\"    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\",\n\t\t\t\"    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\",\n\t\t\t\"    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\",\n\t\t\t\"    FxaaFloat subpixE = subpixC * subpixC;\",\n\t\t\t\"    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    if(!pairN) lumaNN = lumaSS;\",\n\t\t\t\"    FxaaFloat gradientScaled = gradient * 1.0/4.0;\",\n\t\t\t\"    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\",\n\t\t\t\"    FxaaFloat subpixF = subpixD * subpixE;\",\n\t\t\t\"    FxaaBool lumaMLTZero = lumaMM < 0.0;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    lumaEndN -= lumaNN * 0.5;\",\n\t\t\t\"    lumaEndP -= lumaNN * 0.5;\",\n\t\t\t\"    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\",\n\t\t\t\"    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\",\n\t\t\t\"    FxaaBool doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\",\n\t\t\t\"    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    if(doneNP) {\",\n\t\t\t\"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"        doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"        doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\",\n\t\t\t\"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\",\n\t\t\t\"        doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\",\n\t\t\t\"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"        #if (FXAA_QUALITY_PS > 3)\",\n\t\t\t\"        if(doneNP) {\",\n\t\t\t\"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"            doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"            doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\",\n\t\t\t\"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\",\n\t\t\t\"            doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\",\n\t\t\t\"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"            #if (FXAA_QUALITY_PS > 4)\",\n\t\t\t\"            if(doneNP) {\",\n\t\t\t\"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"                doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"                doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\",\n\t\t\t\"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\",\n\t\t\t\"                doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\",\n\t\t\t\"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                #if (FXAA_QUALITY_PS > 5)\",\n\t\t\t\"                if(doneNP) {\",\n\t\t\t\"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"                    doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"                    doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\",\n\t\t\t\"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\",\n\t\t\t\"                    doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\",\n\t\t\t\"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                    #if (FXAA_QUALITY_PS > 6)\",\n\t\t\t\"                    if(doneNP) {\",\n\t\t\t\"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"                        doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"                        doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\",\n\t\t\t\"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\",\n\t\t\t\"                        doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\",\n\t\t\t\"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                        #if (FXAA_QUALITY_PS > 7)\",\n\t\t\t\"                        if(doneNP) {\",\n\t\t\t\"                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"                            doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"                            doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\",\n\t\t\t\"                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\",\n\t\t\t\"                            doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\",\n\t\t\t\"                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    #if (FXAA_QUALITY_PS > 8)\",\n\t\t\t\"    if(doneNP) {\",\n\t\t\t\"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"        doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"        doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\",\n\t\t\t\"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\",\n\t\t\t\"        doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\",\n\t\t\t\"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"        #if (FXAA_QUALITY_PS > 9)\",\n\t\t\t\"        if(doneNP) {\",\n\t\t\t\"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"            doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"            doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\",\n\t\t\t\"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\",\n\t\t\t\"            doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\",\n\t\t\t\"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"            #if (FXAA_QUALITY_PS > 10)\",\n\t\t\t\"            if(doneNP) {\",\n\t\t\t\"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"                doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"                doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\",\n\t\t\t\"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\",\n\t\t\t\"                doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\",\n\t\t\t\"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                #if (FXAA_QUALITY_PS > 11)\",\n\t\t\t\"                if(doneNP) {\",\n\t\t\t\"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"                    doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"                    doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\",\n\t\t\t\"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\",\n\t\t\t\"                    doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\",\n\t\t\t\"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                    #if (FXAA_QUALITY_PS > 12)\",\n\t\t\t\"                    if(doneNP) {\",\n\t\t\t\"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"                        doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"                        doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\",\n\t\t\t\"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\",\n\t\t\t\"                        doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\",\n\t\t\t\"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                    }\",\n\t\t\t\"                    #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                }\",\n\t\t\t\"                #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"            }\",\n\t\t\t\"            #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"        }\",\n\t\t\t\"        #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    }\",\n\t\t\t\"    #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                        }\",\n\t\t\t\"                        #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                    }\",\n\t\t\t\"                    #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                }\",\n\t\t\t\"                #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"            }\",\n\t\t\t\"            #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"        }\",\n\t\t\t\"        #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    }\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat dstN = posM.x - posN.x;\",\n\t\t\t\"    FxaaFloat dstP = posP.x - posM.x;\",\n\t\t\t\"    if(!horzSpan) dstN = posM.y - posN.y;\",\n\t\t\t\"    if(!horzSpan) dstP = posP.y - posM.y;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\",\n\t\t\t\"    FxaaFloat spanLength = (dstP + dstN);\",\n\t\t\t\"    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\",\n\t\t\t\"    FxaaFloat spanLengthRcp = 1.0/spanLength;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaBool directionN = dstN < dstP;\",\n\t\t\t\"    FxaaFloat dst = min(dstN, dstP);\",\n\t\t\t\"    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\",\n\t\t\t\"    FxaaFloat subpixG = subpixF * subpixF;\",\n\t\t\t\"    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\",\n\t\t\t\"    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\",\n\t\t\t\"    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\",\n\t\t\t\"    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\",\n\t\t\t\"    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\",\n\t\t\t\"    #if (FXAA_DISCARD == 1)\",\n\t\t\t\"        return FxaaTexTop(tex, posM);\",\n\t\t\t\"    #else\",\n\t\t\t\"        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\",\n\t\t\t\"    #endif\",\n\t\t\t\"}\",\n\t\t\t\"/*==========================================================================*/\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"void main() {\",\n\t\t\t\"  gl_FragColor = FxaaPixelShader(\",\n\t\t\t\"    vUv,\",\n\t\t\t\"    vec4(0.0),\",\n\t\t\t\"    tDiffuse,\",\n\t\t\t\"    tDiffuse,\",\n\t\t\t\"    tDiffuse,\",\n\t\t\t\"    resolution,\",\n\t\t\t\"    vec4(0.0),\",\n\t\t\t\"    vec4(0.0),\",\n\t\t\t\"    vec4(0.0),\",\n\t\t\t\"    0.75,\",\n\t\t\t\"    0.166,\",\n\t\t\t\"    0.0833,\",\n\t\t\t\"    0.0,\",\n\t\t\t\"    0.0,\",\n\t\t\t\"    0.0,\",\n\t\t\t\"    vec4(0.0)\",\n\t\t\t\"  );\",\n\t\t\t\"\",\n\t\t\t\"  // TODO avoid querying texture twice for same texel\",\n\t\t\t\"  gl_FragColor.a = texture2D(tDiffuse, vUv).a;\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.FXAAShader;\n});\n\ndefine('skylark-threejs-ex/shaders/SSAOShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * References:\n\t * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n\t * https://learnopengl.com/Advanced-Lighting/SSAO\n\t * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n\t */\n\n\tTHREE.SSAOShader = {\n\n\t\tdefines: {\n\t\t\t\"PERSPECTIVE_CAMERA\": 1,\n\t\t\t\"KERNEL_SIZE\": 32\n\t\t},\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"tNormal\": { value: null },\n\t\t\t\"tDepth\": { value: null },\n\t\t\t\"tNoise\": { value: null },\n\t\t\t\"kernel\": { value: null },\n\t\t\t\"cameraNear\": { value: null },\n\t\t\t\"cameraFar\": { value: null },\n\t\t\t\"resolution\": { value: new THREE.Vector2() },\n\t\t\t\"cameraProjectionMatrix\": { value: new THREE.Matrix4() },\n\t\t\t\"cameraInverseProjectionMatrix\": { value: new THREE.Matrix4() },\n\t\t\t\"kernelRadius\": { value: 8 },\n\t\t\t\"minDistance\": { value: 0.005 },\n\t\t\t\"maxDistance\": { value: 0.05 },\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform sampler2D tNormal;\",\n\t\t\t\"uniform sampler2D tDepth;\",\n\t\t\t\"uniform sampler2D tNoise;\",\n\n\t\t\t\"uniform vec3 kernel[ KERNEL_SIZE ];\",\n\n\t\t\t\"uniform vec2 resolution;\",\n\n\t\t\t\"uniform float cameraNear;\",\n\t\t\t\"uniform float cameraFar;\",\n\t\t\t\"uniform mat4 cameraProjectionMatrix;\",\n\t\t\t\"uniform mat4 cameraInverseProjectionMatrix;\",\n\n\t\t\t\"uniform float kernelRadius;\",\n\t\t\t\"uniform float minDistance;\", // avoid artifacts caused by neighbour fragments with minimal depth difference\n\t\t\t\"uniform float maxDistance;\", // avoid the influence of fragments which are too far away\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"#include <packing>\",\n\n\t\t\t\"float getDepth( const in vec2 screenPosition ) {\",\n\n\t\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"float getLinearDepth( const in vec2 screenPosition ) {\",\n\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\n\t\t\t\"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\",\n\t\t\t\"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\",\n\t\t\t\"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\",\n\n\t\t\t\"\t#else\",\n\n\t\t\t\"\t\treturn texture2D( depthSampler, coord ).x;\",\n\n\t\t\t\"\t#endif\",\n\n\t\t\t\"}\",\n\n\t\t\t\"float getViewZ( const in float depth ) {\",\n\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\n\t\t\t\"\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n\n\t\t\t\"\t#else\",\n\n\t\t\t\"\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n\n\t\t\t\"\t#endif\",\n\n\t\t\t\"}\",\n\n\t\t\t\"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\",\n\n\t\t\t\"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\",\n\n\t\t\t\"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\",\n\n\t\t\t\"\tclipPosition *= clipW; // unprojection.\",\n\n\t\t\t\"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"vec3 getViewNormal( const in vec2 screenPosition ) {\",\n\n\t\t\t\"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tfloat depth = getDepth( vUv );\",\n\t\t\t\"\tfloat viewZ = getViewZ( depth );\",\n\n\t\t\t\"\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\",\n\t\t\t\"\tvec3 viewNormal = getViewNormal( vUv );\",\n\n\t\t\t\" vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\",\n\t\t\t\"\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\",\n\n\t\t\t// compute matrix used to reorient a kernel vector\n\n\t\t\t\"\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\",\n\t\t\t\"\tvec3 bitangent = cross( viewNormal, tangent );\",\n\t\t\t\"\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\",\n\n\t\t\t\" float occlusion = 0.0;\",\n\n\t\t\t\" for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\",\n\n\t\t\t\"\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];\", // reorient sample vector in view space\n\t\t\t\"\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );\", // calculate sample point\n\n\t\t\t\"\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\", // project point and calculate NDC\n\t\t\t\"\t\tsamplePointNDC /= samplePointNDC.w;\",\n\n\t\t\t\"\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\", // compute uv coordinates\n\n\t\t\t\"\t\tfloat realDepth = getLinearDepth( samplePointUv );\", // get linear depth from depth texture\n\t\t\t\"\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\", // compute linear depth of the sample view Z value\n\t\t\t\"\t\tfloat delta = sampleDepth - realDepth;\",\n\n\t\t\t\"\t\tif ( delta > minDistance && delta < maxDistance ) {\", // if fragment is before sample point, increase occlusion\n\n\t\t\t\"\t\t\tocclusion += 1.0;\",\n\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\",\n\n\t\t\t\"\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n\tTHREE.SSAODepthShader = {\n\n\t\tdefines: {\n\t\t\t\"PERSPECTIVE_CAMERA\": 1\n\t\t},\n\n\t\tuniforms: {\n\n\t\t\t\"tDepth\": { value: null },\n\t\t\t\"cameraNear\": { value: null },\n\t\t\t\"cameraFar\": { value: null },\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\t\"uniform float cameraNear;\",\n\t\t\t\"uniform float cameraFar;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"#include <packing>\",\n\n\t\t\t\"float getLinearDepth( const in vec2 screenPosition ) {\",\n\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\n\t\t\t\"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\",\n\t\t\t\"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\",\n\t\t\t\"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\",\n\n\t\t\t\"\t#else\",\n\n\t\t\t\"\t\treturn texture2D( depthSampler, coord ).x;\",\n\n\t\t\t\"\t#endif\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tfloat depth = getLinearDepth( vUv );\",\n\t\t\t\"\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n\tTHREE.SSAOBlurShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"resolution\": { value: new THREE.Vector2() }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"uniform vec2 resolution;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec2 texelSize = ( 1.0 / resolution );\",\n\t\t\t\"\tfloat result = 0.0;\",\n\n\t\t\t\"\tfor ( int i = - 2; i <= 2; i ++ ) {\",\n\n\t\t\t\"\t\tfor ( int j = - 2; j <= 2; j ++ ) {\",\n\n\t\t\t\"\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\",\n\t\t\t\"\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\",\n\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.SSAOShader;\n});\n\ndefine('skylark-threejs-ex/shaders/FilmShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Film grain & scanlines shader\n\t *\n\t * - ported from HLSL to WebGL / GLSL\n\t * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n\t *\n\t * Screen Space Static Postprocessor\n\t *\n\t * Produces an analogue noise overlay similar to a film grain / TV static\n\t *\n\t * Original implementation and noise algorithm\n\t * Pat 'Hawthorne' Shearon\n\t *\n\t * Optimized scanlines + noise version with intensity scaling\n\t * Georg 'Leviathan' Steinrohder\n\t *\n\t * This version is provided under a Creative Commons Attribution 3.0 License\n\t * http://creativecommons.org/licenses/by/3.0/\n\t */\n\n\tTHREE.FilmShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"time\": { value: 0.0 },\n\t\t\t\"nIntensity\": { value: 0.5 },\n\t\t\t\"sIntensity\": { value: 0.05 },\n\t\t\t\"sCount\": { value: 4096 },\n\t\t\t\"grayscale\": { value: 1 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"#include <common>\",\n\n\t\t\t// control parameter\n\t\t\t\"uniform float time;\",\n\n\t\t\t\"uniform bool grayscale;\",\n\n\t\t\t// noise effect intensity value (0 = no effect, 1 = full effect)\n\t\t\t\"uniform float nIntensity;\",\n\n\t\t\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\n\t\t\t\"uniform float sIntensity;\",\n\n\t\t\t// scanlines effect count value (0 = no effect, 4096 = full effect)\n\t\t\t\"uniform float sCount;\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t// sample the source\n\t\t\t\"\tvec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\n\n\t\t\t// make some noise\n\t\t\t\"\tfloat dx = rand( vUv + time );\",\n\n\t\t\t// add noise\n\t\t\t\"\tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\",\n\n\t\t\t// get us a sine and cosine\n\t\t\t\"\tvec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\",\n\n\t\t\t// add scanlines\n\t\t\t\"\tcResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\",\n\n\t\t\t// interpolate between source and result by intensity\n\t\t\t\"\tcResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\",\n\n\t\t\t// convert to grayscale if desired\n\t\t\t\"\tif( grayscale ) {\",\n\n\t\t\t\"\t\tcResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\tgl_FragColor =  vec4( cResult, cTextureScreen.a );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.FilmShader;\n});\n\ndefine('skylark-threejs-ex/shaders/DotScreenShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Dot screen shader\n\t * based on glfx.js sepia shader\n\t * https://github.com/evanw/glfx.js\n\t */\n\n\tTHREE.DotScreenShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"tSize\": { value: new THREE.Vector2( 256, 256 ) },\n\t\t\t\"center\": { value: new THREE.Vector2( 0.5, 0.5 ) },\n\t\t\t\"angle\": { value: 1.57 },\n\t\t\t\"scale\": { value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec2 center;\",\n\t\t\t\"uniform float angle;\",\n\t\t\t\"uniform float scale;\",\n\t\t\t\"uniform vec2 tSize;\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"float pattern() {\",\n\n\t\t\t\"\tfloat s = sin( angle ), c = cos( angle );\",\n\n\t\t\t\"\tvec2 tex = vUv * tSize - center;\",\n\t\t\t\"\tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\",\n\n\t\t\t\"\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 color = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"\tfloat average = ( color.r + color.g + color.b ) / 3.0;\",\n\n\t\t\t\"\tgl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.DotScreenShader;\n});\n\ndefine('skylark-threejs-ex/shaders/LuminosityShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Luminosity\n\t * http://en.wikipedia.org/wiki/Luminosity\n\t */\n\n\tTHREE.LuminosityShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"#include <common>\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 texel = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"\tfloat l = linearToRelativeLuminance( texel.rgb );\",\n\n\t\t\t\"\tgl_FragColor = vec4( l, l, l, texel.w );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.LuminosityShader;\n});\ndefine('skylark-threejs-ex/shaders/SobelOperatorShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\n\t *\n\t * As mentioned in the video the Sobel operator expects a grayscale image as input.\n\t *\n\t */\n\n\tTHREE.SobelOperatorShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"resolution\": { value: new THREE.Vector2() }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform vec2 resolution;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );\",\n\n\t\t\t// kernel definition (in glsl matrices are filled in column-major order)\n\n\t\t\t\"\tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );\", // x direction kernel\n\t\t\t\"\tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );\", // y direction kernel\n\n\t\t\t// fetch the 3x3 neighbourhood of a fragment\n\n\t\t\t// first column\n\n\t\t\t\"\tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;\",\n\t\t\t\"\tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;\",\n\t\t\t\"\tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;\",\n\n\t\t\t// second column\n\n\t\t\t\"\tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;\",\n\t\t\t\"\tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;\",\n\t\t\t\"\tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;\",\n\n\t\t\t// third column\n\n\t\t\t\"\tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;\",\n\t\t\t\"\tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;\",\n\t\t\t\"\tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;\",\n\n\t\t\t// gradient value in x direction\n\n\t\t\t\"\tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + \",\n\t\t\t\"\t\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + \",\n\t\t\t\"\t\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; \",\n\n\t\t\t// gradient value in y direction\n\n\t\t\t\"\tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + \",\n\t\t\t\"\t\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + \",\n\t\t\t\"\t\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; \",\n\n\t\t\t// magnitute of the total gradient\n\n\t\t\t\"\tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );\",\n\n\t\t\t\"\tgl_FragColor = vec4( vec3( G ), 1 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.SobelOperatorShader;\n});\n\ndefine('skylark-threejs-ex/shaders/ColorifyShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Colorify shader\n\t */\n\n\tTHREE.ColorifyShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"color\": { value: new THREE.Color( 0xffffff ) }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 color;\",\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 texel = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\",\n\t\t\t\"\tfloat v = dot( texel.xyz, luma );\",\n\n\t\t\t\"\tgl_FragColor = vec4( v * color, texel.w );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.ColorifyShader;\n});\n\ndefine('skylark-threejs-ex/shaders/ToneMapShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author miibond\n\t *\n\t * Full-screen tone-mapping shader based on http://www.cis.rit.edu/people/faculty/ferwerda/publications/sig02_paper.pdf\n\t */\n\n\tTHREE.ToneMapShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"averageLuminance\": { value: 1.0 },\n\t\t\t\"luminanceMap\": { value: null },\n\t\t\t\"maxLuminance\": { value: 16.0 },\n\t\t\t\"minLuminance\": { value: 0.01 },\n\t\t\t\"middleGrey\": { value: 0.6 }\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"#include <common>\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform float middleGrey;\",\n\t\t\t\"uniform float minLuminance;\",\n\t\t\t\"uniform float maxLuminance;\",\n\t\t\t\"#ifdef ADAPTED_LUMINANCE\",\n\t\t\t\"\tuniform sampler2D luminanceMap;\",\n\t\t\t\"#else\",\n\t\t\t\"\tuniform float averageLuminance;\",\n\t\t\t\"#endif\",\n\n\t\t\t\"vec3 ToneMap( vec3 vColor ) {\",\n\t\t\t\"\t#ifdef ADAPTED_LUMINANCE\",\n\t\t\t// Get the calculated average luminance\n\t\t\t\"\t\tfloat fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;\",\n\t\t\t\"\t#else\",\n\t\t\t\"\t\tfloat fLumAvg = averageLuminance;\",\n\t\t\t\"\t#endif\",\n\n\t\t\t// Calculate the luminance of the current pixel\n\t\t\t\"\tfloat fLumPixel = linearToRelativeLuminance( vColor );\",\n\n\t\t\t// Apply the modified operator (Eq. 4)\n\t\t\t\"\tfloat fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );\",\n\n\t\t\t\"\tfloat fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);\",\n\t\t\t\"\treturn fLumCompressed * vColor;\",\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 texel = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"\tgl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.ToneMapShader;\n});\n\ndefine('skylark-threejs-ex/shaders/TechnicolorShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author flimshaw / http://charliehoey.com\n\t *\n\t * Technicolor Shader\n\t * Simulates the look of the two-strip technicolor process popular in early 20th century films.\n\t * More historical info here: http://www.widescreenmuseum.com/oldcolor/technicolor1.htm\n\t * Demo here: http://charliehoey.com/technicolor_shader/shader_test.html\n\t */\n\n\tTHREE.TechnicolorShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );\",\n\t\t\t\"\tvec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);\",\n\n\t\t\t\"\tgl_FragColor = newTex;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.TechnicolorShader;\n});\n\ndefine('skylark-threejs-ex/shaders/HueSaturationShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author tapio / http://tapio.github.com/\n\t *\n\t * Hue and saturation adjustment\n\t * https://github.com/evanw/glfx.js\n\t * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.\n\t * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n\t */\n\n\tTHREE.HueSaturationShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"hue\": { value: 0 },\n\t\t\t\"saturation\": { value: 0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform float hue;\",\n\t\t\t\"uniform float saturation;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tgl_FragColor = texture2D( tDiffuse, vUv );\",\n\n\t\t\t// hue\n\t\t\t\"\tfloat angle = hue * 3.14159265;\",\n\t\t\t\"\tfloat s = sin(angle), c = cos(angle);\",\n\t\t\t\"\tvec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\",\n\t\t\t\"\tfloat len = length(gl_FragColor.rgb);\",\n\t\t\t\"\tgl_FragColor.rgb = vec3(\",\n\t\t\t\"\t\tdot(gl_FragColor.rgb, weights.xyz),\",\n\t\t\t\"\t\tdot(gl_FragColor.rgb, weights.zxy),\",\n\t\t\t\"\t\tdot(gl_FragColor.rgb, weights.yzx)\",\n\t\t\t\"\t);\",\n\n\t\t\t// saturation\n\t\t\t\"\tfloat average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\",\n\t\t\t\"\tif (saturation > 0.0) {\",\n\t\t\t\"\t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));\",\n\t\t\t\"\t} else {\",\n\t\t\t\"\t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);\",\n\t\t\t\"\t}\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.HueSaturationShader;\n});\n\ndefine('skylark-threejs-ex/postprocessing/Pass',[\r\n\t\"skylark-threejs\"\r\n],function(THREE){\r\n\tTHREE.Pass = function () {\r\n\r\n\t\t// if set to true, the pass is processed by the composer\r\n\t\tthis.enabled = true;\r\n\r\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\r\n\t\tthis.needsSwap = true;\r\n\r\n\t\t// if set to true, the pass clears its buffer before rendering\r\n\t\tthis.clear = false;\r\n\r\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\r\n\t\tthis.renderToScreen = false;\r\n\r\n\t};\r\n\r\n\tObject.assign( THREE.Pass.prototype, {\r\n\r\n\t\tsetSize: function ( /* width, height */ ) {},\r\n\r\n\t\trender: function ( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\t// Helper for passes that need to fill the viewport with a single quad.\r\n\tTHREE.Pass.FullScreenQuad = ( function () {\r\n\r\n\t\tvar camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\t\tvar geometry = new THREE.PlaneBufferGeometry( 2, 2 );\r\n\r\n\t\tvar FullScreenQuad = function ( material ) {\r\n\r\n\t\t\tthis._mesh = new THREE.Mesh( geometry, material );\r\n\r\n\t\t};\r\n\r\n\t\tObject.defineProperty( FullScreenQuad.prototype, 'material', {\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this._mesh.material;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis._mesh.material = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tObject.assign( FullScreenQuad.prototype, {\r\n\r\n\t\t\tdispose: function () {\r\n\r\n\t\t\t\tthis._mesh.geometry.dispose();\r\n\r\n\t\t\t},\r\n\r\n\t\t\trender: function ( renderer ) {\r\n\r\n\t\t\t\trenderer.render( this._mesh, camera );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn FullScreenQuad;\r\n\r\n\t} )();\r\n\r\n\treturn THREE.Pass;\r\n});\ndefine('skylark-threejs-ex/postprocessing/ShaderPass',[\n\t\"skylark-threejs\",\n\t\"./Pass\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tTHREE.ShaderPass = function ( shader, textureID ) {\n\n\t\tTHREE.Pass.call( this );\n\n\t\tthis.textureID = ( textureID !== undefined ) ? textureID : \"tDiffuse\";\n\n\t\tif ( shader instanceof THREE.ShaderMaterial ) {\n\n\t\t\tthis.uniforms = shader.uniforms;\n\n\t\t\tthis.material = shader;\n\n\t\t} else if ( shader ) {\n\n\t\t\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\t\tthis.material = new THREE.ShaderMaterial( {\n\n\t\t\t\tdefines: Object.assign( {}, shader.defines ),\n\t\t\t\tuniforms: this.uniforms,\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t\t} );\n\n\t\t}\n\n\t\tthis.fsQuad = new THREE.Pass.FullScreenQuad( this.material );\n\n\t};\n\n\tTHREE.ShaderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\n\t\tconstructor: THREE.ShaderPass,\n\n\t\trender: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\n\n\t\t\t}\n\n\t\t\tthis.fsQuad.material = this.material;\n\n\t\t\tif ( this.renderToScreen ) {\n\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.ShaderPass;\n});\n\ndefine('skylark-threejs-ex/postprocessing/MaskPass',[\n\t\"skylark-threejs\",\n\t\"./Pass\"\n],function(THREE,Pass){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tTHREE.MaskPass = function ( scene, camera ) {\n\n\t\tTHREE.Pass.call( this );\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.clear = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis.inverse = false;\n\n\t};\n\n\tTHREE.MaskPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\n\t\tconstructor: THREE.MaskPass,\n\n\t\trender: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\t\tvar context = renderer.getContext();\n\t\t\tvar state = renderer.state;\n\n\t\t\t// don't update color or depth\n\n\t\t\tstate.buffers.color.setMask( false );\n\t\t\tstate.buffers.depth.setMask( false );\n\n\t\t\t// lock buffers\n\n\t\t\tstate.buffers.color.setLocked( true );\n\t\t\tstate.buffers.depth.setLocked( true );\n\n\t\t\t// set up stencil\n\n\t\t\tvar writeValue, clearValue;\n\n\t\t\tif ( this.inverse ) {\n\n\t\t\t\twriteValue = 0;\n\t\t\t\tclearValue = 1;\n\n\t\t\t} else {\n\n\t\t\t\twriteValue = 1;\n\t\t\t\tclearValue = 0;\n\n\t\t\t}\n\n\t\t\tstate.buffers.stencil.setTest( true );\n\t\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\n\t\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\n\t\t\tstate.buffers.stencil.setClear( clearValue );\n\t\t\tstate.buffers.stencil.setLocked( true );\n\n\t\t\t// draw into the stencil buffer\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tif ( this.clear ) renderer.clear();\n\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\tif ( this.clear ) renderer.clear();\n\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\t// unlock color and depth buffer for subsequent rendering\n\n\t\t\tstate.buffers.color.setLocked( false );\n\t\t\tstate.buffers.depth.setLocked( false );\n\n\t\t\t// only render where stencil is set to 1\n\n\t\t\tstate.buffers.stencil.setLocked( false );\n\t\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1\n\t\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\n\t\t\tstate.buffers.stencil.setLocked( true );\n\n\t\t}\n\n\t} );\n\n\n\tTHREE.ClearMaskPass = function () {\n\n\t\tTHREE.Pass.call( this );\n\n\t\tthis.needsSwap = false;\n\n\t};\n\n\tTHREE.ClearMaskPass.prototype = Object.create( THREE.Pass.prototype );\n\n\tObject.assign( THREE.ClearMaskPass.prototype, {\n\n\t\trender: function ( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\t\trenderer.state.buffers.stencil.setLocked( false );\n\t\t\trenderer.state.buffers.stencil.setTest( false );\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.MaskPass;\n});\n\ndefine('skylark-threejs-ex/postprocessing/EffectComposer',[\n\t\"skylark-threejs\",\n\t\"../shaders/CopyShader\",\n\t\"./ShaderPass\",\n\t\"./MaskPass\"\n],function(THREE){\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tTHREE.EffectComposer = function ( renderer, renderTarget ) {\n\n\t\tthis.renderer = renderer;\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\tvar parameters = {\n\t\t\t\tminFilter: THREE.LinearFilter,\n\t\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\t\tformat: THREE.RGBAFormat,\n\t\t\t\tstencilBuffer: false\n\t\t\t};\n\n\t\t\tvar size = renderer.getSize( new THREE.Vector2() );\n\t\t\tthis._pixelRatio = renderer.getPixelRatio();\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = new THREE.WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, parameters );\n\t\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\n\t\t} else {\n\n\t\t\tthis._pixelRatio = 1;\n\t\t\tthis._width = renderTarget.width;\n\t\t\tthis._height = renderTarget.height;\n\n\t\t}\n\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\t\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t\tthis.renderToScreen = true;\n\n\t\tthis.passes = [];\n\n\t\t// dependencies\n\n\t\tif ( THREE.CopyShader === undefined ) {\n\n\t\t\tconsole.error( 'THREE.EffectComposer relies on THREE.CopyShader' );\n\n\t\t}\n\n\t\tif ( THREE.ShaderPass === undefined ) {\n\n\t\t\tconsole.error( 'THREE.EffectComposer relies on THREE.ShaderPass' );\n\n\t\t}\n\n\t\tthis.copyPass = new THREE.ShaderPass( THREE.CopyShader );\n\n\t\tthis.clock = new THREE.Clock();\n\n\t};\n\n\tObject.assign( THREE.EffectComposer.prototype, {\n\n\t\tswapBuffers: function () {\n\n\t\t\tvar tmp = this.readBuffer;\n\t\t\tthis.readBuffer = this.writeBuffer;\n\t\t\tthis.writeBuffer = tmp;\n\n\t\t},\n\n\t\taddPass: function ( pass ) {\n\n\t\t\tthis.passes.push( pass );\n\t\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t\t},\n\n\t\tinsertPass: function ( pass, index ) {\n\n\t\t\tthis.passes.splice( index, 0, pass );\n\n\t\t},\n\n\t\tisLastEnabledPass: function ( passIndex ) {\n\n\t\t\tfor ( var i = passIndex + 1; i < this.passes.length; i ++ ) {\n\n\t\t\t\tif ( this.passes[ i ].enabled ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\trender: function ( deltaTime ) {\n\n\t\t\t// deltaTime value is in seconds\n\n\t\t\tif ( deltaTime === undefined ) {\n\n\t\t\t\tdeltaTime = this.clock.getDelta();\n\n\t\t\t}\n\n\t\t\tvar currentRenderTarget = this.renderer.getRenderTarget();\n\n\t\t\tvar maskActive = false;\n\n\t\t\tvar pass, i, il = this.passes.length;\n\n\t\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\t\tpass = this.passes[ i ];\n\n\t\t\t\tif ( pass.enabled === false ) continue;\n\n\t\t\t\tpass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );\n\t\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );\n\n\t\t\t\tif ( pass.needsSwap ) {\n\n\t\t\t\t\tif ( maskActive ) {\n\n\t\t\t\t\t\tvar context = this.renderer.getContext();\n\t\t\t\t\t\tvar stencil = this.renderer.state.buffers.stencil;\n\n\t\t\t\t\t\t//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n\t\t\t\t\t\tstencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );\n\n\t\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );\n\n\t\t\t\t\t\t//context.stencilFunc( context.EQUAL, 1, 0xffffffff );\n\t\t\t\t\t\tstencil.setFunc( context.EQUAL, 1, 0xffffffff );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.swapBuffers();\n\n\t\t\t\t}\n\n\t\t\t\tif ( THREE.MaskPass !== undefined ) {\n\n\t\t\t\t\tif ( pass instanceof THREE.MaskPass ) {\n\n\t\t\t\t\t\tmaskActive = true;\n\n\t\t\t\t\t} else if ( pass instanceof THREE.ClearMaskPass ) {\n\n\t\t\t\t\t\tmaskActive = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.renderer.setRenderTarget( currentRenderTarget );\n\n\t\t},\n\n\t\treset: function ( renderTarget ) {\n\n\t\t\tif ( renderTarget === undefined ) {\n\n\t\t\t\tvar size = this.renderer.getSize( new THREE.Vector2() );\n\t\t\t\tthis._pixelRatio = this.renderer.getPixelRatio();\n\t\t\t\tthis._width = size.width;\n\t\t\t\tthis._height = size.height;\n\n\t\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\t\trenderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t\t\t}\n\n\t\t\tthis.renderTarget1.dispose();\n\t\t\tthis.renderTarget2.dispose();\n\t\t\tthis.renderTarget1 = renderTarget;\n\t\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\t\tthis.writeBuffer = this.renderTarget1;\n\t\t\tthis.readBuffer = this.renderTarget2;\n\n\t\t},\n\n\t\tsetSize: function ( width, height ) {\n\n\t\t\tthis._width = width;\n\t\t\tthis._height = height;\n\n\t\t\tvar effectiveWidth = this._width * this._pixelRatio;\n\t\t\tvar effectiveHeight = this._height * this._pixelRatio;\n\n\t\t\tthis.renderTarget1.setSize( effectiveWidth, effectiveHeight );\n\t\t\tthis.renderTarget2.setSize( effectiveWidth, effectiveHeight );\n\n\t\t\tfor ( var i = 0; i < this.passes.length; i ++ ) {\n\n\t\t\t\tthis.passes[ i ].setSize( effectiveWidth, effectiveHeight );\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetPixelRatio: function ( pixelRatio ) {\n\n\t\t\tthis._pixelRatio = pixelRatio;\n\n\t\t\tthis.setSize( this._width, this._height );\n\n\t\t}\n\n\t} );\n\n\n\t\n\treturn THREE.EffectComposer;\n});\n\ndefine('skylark-threejs-ex/postprocessing/RenderPass',[\n\t\"skylark-threejs\",\n\t\"./Pass\"\n],function(THREE,Pass){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tTHREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {\n\n\t\tTHREE.Pass.call( this );\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.overrideMaterial = overrideMaterial;\n\n\t\tthis.clearColor = clearColor;\n\t\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\n\n\t\tthis.clear = true;\n\t\tthis.clearDepth = false;\n\t\tthis.needsSwap = false;\n\n\t};\n\n\tTHREE.RenderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\n\t\tconstructor: THREE.RenderPass,\n\n\t\trender: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\t\tvar oldAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\n\t\t\tvar oldClearColor, oldClearAlpha, oldOverrideMaterial;\n\n\t\t\tif ( this.overrideMaterial !== undefined ) {\n\n\t\t\t\toldOverrideMaterial = this.scene.overrideMaterial;\n\n\t\t\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\t\t}\n\n\t\t\tif ( this.clearColor ) {\n\n\t\t\t\toldClearColor = renderer.getClearColor().getHex();\n\t\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\n\n\t\t\t}\n\n\t\t\tif ( this.clearDepth ) {\n\n\t\t\t\trenderer.clearDepth();\n\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget( this.renderToScreen ? null : readBuffer );\n\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\tif ( this.clearColor ) {\n\n\t\t\t\trenderer.setClearColor( oldClearColor, oldClearAlpha );\n\n\t\t\t}\n\n\t\t\tif ( this.overrideMaterial !== undefined ) {\n\n\t\t\t\tthis.scene.overrideMaterial = oldOverrideMaterial;\n\n\t\t\t}\n\n\t\t\trenderer.autoClear = oldAutoClear;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.RenderPass;\n});\n\ndefine('skylark-threejs-ex/curves/NURBSUtils',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author renej\n\t * NURBS utils\n\t *\n\t * See NURBSCurve and NURBSSurface.\n\t *\n\t **/\n\n\n\t/**************************************************************\n\t *\tNURBS Utils\n\t **************************************************************/\n\n\tTHREE.NURBSUtils = {\n\n\t\t/*\n\t\tFinds knot vector span.\n\n\t\tp : degree\n\t\tu : parametric value\n\t\tU : knot vector\n\n\t\treturns the span\n\t\t*/\n\t\tfindSpan: function ( p, u, U ) {\n\n\t\t\tvar n = U.length - p - 1;\n\n\t\t\tif ( u >= U[ n ] ) {\n\n\t\t\t\treturn n - 1;\n\n\t\t\t}\n\n\t\t\tif ( u <= U[ p ] ) {\n\n\t\t\t\treturn p;\n\n\t\t\t}\n\n\t\t\tvar low = p;\n\t\t\tvar high = n;\n\t\t\tvar mid = Math.floor( ( low + high ) / 2 );\n\n\t\t\twhile ( u < U[ mid ] || u >= U[ mid + 1 ] ) {\n\n\t\t\t\tif ( u < U[ mid ] ) {\n\n\t\t\t\t\thigh = mid;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlow = mid;\n\n\t\t\t\t}\n\n\t\t\t\tmid = Math.floor( ( low + high ) / 2 );\n\n\t\t\t}\n\n\t\t\treturn mid;\n\n\t\t},\n\n\n\t\t/*\n\t\tCalculate basis functions. See The NURBS Book, page 70, algorithm A2.2\n\n\t\tspan : span in which u lies\n\t\tu    : parametric point\n\t\tp    : degree\n\t\tU    : knot vector\n\n\t\treturns array[p+1] with basis functions values.\n\t\t*/\n\t\tcalcBasisFunctions: function ( span, u, p, U ) {\n\n\t\t\tvar N = [];\n\t\t\tvar left = [];\n\t\t\tvar right = [];\n\t\t\tN[ 0 ] = 1.0;\n\n\t\t\tfor ( var j = 1; j <= p; ++ j ) {\n\n\t\t\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\t\t\tright[ j ] = U[ span + j ] - u;\n\n\t\t\t\tvar saved = 0.0;\n\n\t\t\t\tfor ( var r = 0; r < j; ++ r ) {\n\n\t\t\t\t\tvar rv = right[ r + 1 ];\n\t\t\t\t\tvar lv = left[ j - r ];\n\t\t\t\t\tvar temp = N[ r ] / ( rv + lv );\n\t\t\t\t\tN[ r ] = saved + rv * temp;\n\t\t\t\t\tsaved = lv * temp;\n\n\t\t\t\t }\n\n\t\t\t\t N[ j ] = saved;\n\n\t\t\t }\n\n\t\t\t return N;\n\n\t\t},\n\n\n\t\t/*\n\t\tCalculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\n\n\t\tp : degree of B-Spline\n\t\tU : knot vector\n\t\tP : control points (x, y, z, w)\n\t\tu : parametric point\n\n\t\treturns point for given u\n\t\t*/\n\t\tcalcBSplinePoint: function ( p, U, P, u ) {\n\n\t\t\tvar span = this.findSpan( p, u, U );\n\t\t\tvar N = this.calcBasisFunctions( span, u, p, U );\n\t\t\tvar C = new THREE.Vector4( 0, 0, 0, 0 );\n\n\t\t\tfor ( var j = 0; j <= p; ++ j ) {\n\n\t\t\t\tvar point = P[ span - p + j ];\n\t\t\t\tvar Nj = N[ j ];\n\t\t\t\tvar wNj = point.w * Nj;\n\t\t\t\tC.x += point.x * wNj;\n\t\t\t\tC.y += point.y * wNj;\n\t\t\t\tC.z += point.z * wNj;\n\t\t\t\tC.w += point.w * Nj;\n\n\t\t\t}\n\n\t\t\treturn C;\n\n\t\t},\n\n\n\t\t/*\n\t\tCalculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\n\n\t\tspan : span in which u lies\n\t\tu    : parametric point\n\t\tp    : degree\n\t\tn    : number of derivatives to calculate\n\t\tU    : knot vector\n\n\t\treturns array[n+1][p+1] with basis functions derivatives\n\t\t*/\n\t\tcalcBasisFunctionDerivatives: function ( span, u, p, n, U ) {\n\n\t\t\tvar zeroArr = [];\n\t\t\tfor ( var i = 0; i <= p; ++ i )\n\t\t\t\tzeroArr[ i ] = 0.0;\n\n\t\t\tvar ders = [];\n\t\t\tfor ( var i = 0; i <= n; ++ i )\n\t\t\t\tders[ i ] = zeroArr.slice( 0 );\n\n\t\t\tvar ndu = [];\n\t\t\tfor ( var i = 0; i <= p; ++ i )\n\t\t\t\tndu[ i ] = zeroArr.slice( 0 );\n\n\t\t\tndu[ 0 ][ 0 ] = 1.0;\n\n\t\t\tvar left = zeroArr.slice( 0 );\n\t\t\tvar right = zeroArr.slice( 0 );\n\n\t\t\tfor ( var j = 1; j <= p; ++ j ) {\n\n\t\t\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\t\t\tright[ j ] = U[ span + j ] - u;\n\n\t\t\t\tvar saved = 0.0;\n\n\t\t\t\tfor ( var r = 0; r < j; ++ r ) {\n\n\t\t\t\t\tvar rv = right[ r + 1 ];\n\t\t\t\t\tvar lv = left[ j - r ];\n\t\t\t\t\tndu[ j ][ r ] = rv + lv;\n\n\t\t\t\t\tvar temp = ndu[ r ][ j - 1 ] / ndu[ j ][ r ];\n\t\t\t\t\tndu[ r ][ j ] = saved + rv * temp;\n\t\t\t\t\tsaved = lv * temp;\n\n\t\t\t\t}\n\n\t\t\t\tndu[ j ][ j ] = saved;\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0; j <= p; ++ j ) {\n\n\t\t\t\tders[ 0 ][ j ] = ndu[ j ][ p ];\n\n\t\t\t}\n\n\t\t\tfor ( var r = 0; r <= p; ++ r ) {\n\n\t\t\t\tvar s1 = 0;\n\t\t\t\tvar s2 = 1;\n\n\t\t\t\tvar a = [];\n\t\t\t\tfor ( var i = 0; i <= p; ++ i ) {\n\n\t\t\t\t\ta[ i ] = zeroArr.slice( 0 );\n\n\t\t\t\t}\n\t\t\t\ta[ 0 ][ 0 ] = 1.0;\n\n\t\t\t\tfor ( var k = 1; k <= n; ++ k ) {\n\n\t\t\t\t\tvar d = 0.0;\n\t\t\t\t\tvar rk = r - k;\n\t\t\t\t\tvar pk = p - k;\n\n\t\t\t\t\tif ( r >= k ) {\n\n\t\t\t\t\t\ta[ s2 ][ 0 ] = a[ s1 ][ 0 ] / ndu[ pk + 1 ][ rk ];\n\t\t\t\t\t\td = a[ s2 ][ 0 ] * ndu[ rk ][ pk ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar j1 = ( rk >= - 1 ) ? 1 : - rk;\n\t\t\t\t\tvar j2 = ( r - 1 <= pk ) ? k - 1 : p - r;\n\n\t\t\t\t\tfor ( var j = j1; j <= j2; ++ j ) {\n\n\t\t\t\t\t\ta[ s2 ][ j ] = ( a[ s1 ][ j ] - a[ s1 ][ j - 1 ] ) / ndu[ pk + 1 ][ rk + j ];\n\t\t\t\t\t\td += a[ s2 ][ j ] * ndu[ rk + j ][ pk ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( r <= pk ) {\n\n\t\t\t\t\t\ta[ s2 ][ k ] = - a[ s1 ][ k - 1 ] / ndu[ pk + 1 ][ r ];\n\t\t\t\t\t\td += a[ s2 ][ k ] * ndu[ r ][ pk ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tders[ k ][ r ] = d;\n\n\t\t\t\t\tvar j = s1;\n\t\t\t\t\ts1 = s2;\n\t\t\t\t\ts2 = j;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar r = p;\n\n\t\t\tfor ( var k = 1; k <= n; ++ k ) {\n\n\t\t\t\tfor ( var j = 0; j <= p; ++ j ) {\n\n\t\t\t\t\tders[ k ][ j ] *= r;\n\n\t\t\t\t}\n\t\t\t\tr *= p - k;\n\n\t\t\t}\n\n\t\t\treturn ders;\n\n\t\t},\n\n\n\t\t/*\n\t\t\tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\n\n\t\t\tp  : degree\n\t\t\tU  : knot vector\n\t\t\tP  : control points\n\t\t\tu  : Parametric points\n\t\t\tnd : number of derivatives\n\n\t\t\treturns array[d+1] with derivatives\n\t\t\t*/\n\t\tcalcBSplineDerivatives: function ( p, U, P, u, nd ) {\n\n\t\t\tvar du = nd < p ? nd : p;\n\t\t\tvar CK = [];\n\t\t\tvar span = this.findSpan( p, u, U );\n\t\t\tvar nders = this.calcBasisFunctionDerivatives( span, u, p, du, U );\n\t\t\tvar Pw = [];\n\n\t\t\tfor ( var i = 0; i < P.length; ++ i ) {\n\n\t\t\t\tvar point = P[ i ].clone();\n\t\t\t\tvar w = point.w;\n\n\t\t\t\tpoint.x *= w;\n\t\t\t\tpoint.y *= w;\n\t\t\t\tpoint.z *= w;\n\n\t\t\t\tPw[ i ] = point;\n\n\t\t\t}\n\t\t\tfor ( var k = 0; k <= du; ++ k ) {\n\n\t\t\t\tvar point = Pw[ span - p ].clone().multiplyScalar( nders[ k ][ 0 ] );\n\n\t\t\t\tfor ( var j = 1; j <= p; ++ j ) {\n\n\t\t\t\t\tpoint.add( Pw[ span - p + j ].clone().multiplyScalar( nders[ k ][ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tCK[ k ] = point;\n\n\t\t\t}\n\n\t\t\tfor ( var k = du + 1; k <= nd + 1; ++ k ) {\n\n\t\t\t\tCK[ k ] = new THREE.Vector4( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn CK;\n\n\t\t},\n\n\n\t\t/*\n\t\tCalculate \"K over I\"\n\n\t\treturns k!/(i!(k-i)!)\n\t\t*/\n\t\tcalcKoverI: function ( k, i ) {\n\n\t\t\tvar nom = 1;\n\n\t\t\tfor ( var j = 2; j <= k; ++ j ) {\n\n\t\t\t\tnom *= j;\n\n\t\t\t}\n\n\t\t\tvar denom = 1;\n\n\t\t\tfor ( var j = 2; j <= i; ++ j ) {\n\n\t\t\t\tdenom *= j;\n\n\t\t\t}\n\n\t\t\tfor ( var j = 2; j <= k - i; ++ j ) {\n\n\t\t\t\tdenom *= j;\n\n\t\t\t}\n\n\t\t\treturn nom / denom;\n\n\t\t},\n\n\n\t\t/*\n\t\tCalculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\n\n\t\tPders : result of function calcBSplineDerivatives\n\n\t\treturns array with derivatives for rational curve.\n\t\t*/\n\t\tcalcRationalCurveDerivatives: function ( Pders ) {\n\n\t\t\tvar nd = Pders.length;\n\t\t\tvar Aders = [];\n\t\t\tvar wders = [];\n\n\t\t\tfor ( var i = 0; i < nd; ++ i ) {\n\n\t\t\t\tvar point = Pders[ i ];\n\t\t\t\tAders[ i ] = new THREE.Vector3( point.x, point.y, point.z );\n\t\t\t\twders[ i ] = point.w;\n\n\t\t\t}\n\n\t\t\tvar CK = [];\n\n\t\t\tfor ( var k = 0; k < nd; ++ k ) {\n\n\t\t\t\tvar v = Aders[ k ].clone();\n\n\t\t\t\tfor ( var i = 1; i <= k; ++ i ) {\n\n\t\t\t\t\tv.sub( CK[ k - i ].clone().multiplyScalar( this.calcKoverI( k, i ) * wders[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tCK[ k ] = v.divideScalar( wders[ 0 ] );\n\n\t\t\t}\n\n\t\t\treturn CK;\n\n\t\t},\n\n\n\t\t/*\n\t\tCalculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\n\n\t\tp  : degree\n\t\tU  : knot vector\n\t\tP  : control points in homogeneous space\n\t\tu  : parametric points\n\t\tnd : number of derivatives\n\n\t\treturns array with derivatives.\n\t\t*/\n\t\tcalcNURBSDerivatives: function ( p, U, P, u, nd ) {\n\n\t\t\tvar Pders = this.calcBSplineDerivatives( p, U, P, u, nd );\n\t\t\treturn this.calcRationalCurveDerivatives( Pders );\n\n\t\t},\n\n\n\t\t/*\n\t\tCalculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n\n\t\tp1, p2 : degrees of B-Spline surface\n\t\tU1, U2 : knot vectors\n\t\tP      : control points (x, y, z, w)\n\t\tu, v   : parametric values\n\n\t\treturns point for given (u, v)\n\t\t*/\n\t\tcalcSurfacePoint: function ( p, q, U, V, P, u, v, target ) {\n\n\t\t\tvar uspan = this.findSpan( p, u, U );\n\t\t\tvar vspan = this.findSpan( q, v, V );\n\t\t\tvar Nu = this.calcBasisFunctions( uspan, u, p, U );\n\t\t\tvar Nv = this.calcBasisFunctions( vspan, v, q, V );\n\t\t\tvar temp = [];\n\n\t\t\tfor ( var l = 0; l <= q; ++ l ) {\n\n\t\t\t\ttemp[ l ] = new THREE.Vector4( 0, 0, 0, 0 );\n\t\t\t\tfor ( var k = 0; k <= p; ++ k ) {\n\n\t\t\t\t\tvar point = P[ uspan - p + k ][ vspan - q + l ].clone();\n\t\t\t\t\tvar w = point.w;\n\t\t\t\t\tpoint.x *= w;\n\t\t\t\t\tpoint.y *= w;\n\t\t\t\t\tpoint.z *= w;\n\t\t\t\t\ttemp[ l ].add( point.multiplyScalar( Nu[ k ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar Sw = new THREE.Vector4( 0, 0, 0, 0 );\n\t\t\tfor ( var l = 0; l <= q; ++ l ) {\n\n\t\t\t\tSw.add( temp[ l ].multiplyScalar( Nv[ l ] ) );\n\n\t\t\t}\n\n\t\t\tSw.divideScalar( Sw.w );\n\t\t\ttarget.set( Sw.x, Sw.y, Sw.z );\n\n\t\t}\n\n\t};\n\treturn THREE.NURBSUtils;\n});\n\ndefine('skylark-threejs-ex/curves/NURBSCurve',[\n\t\"skylark-threejs\",\n\t\"./NURBSUtils\"\n],function(THREE){\n\t/**\n\t * @author renej\n\t * NURBS curve object\n\t *\n\t * Derives from Curve, overriding getPoint and getTangent.\n\t *\n\t * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n\t *\n\t **/\n\n\n\t/**************************************************************\n\t *\tNURBS curve\n\t **************************************************************/\n\n\tTHREE.NURBSCurve = function ( degree, knots /* array of reals */, controlPoints /* array of Vector(2|3|4) */, startKnot /* index in knots */, endKnot /* index in knots */ ) {\n\n\t\tTHREE.Curve.call( this );\n\n\t\tthis.degree = degree;\n\t\tthis.knots = knots;\n\t\tthis.controlPoints = [];\n\t\t// Used by periodic NURBS to remove hidden spans\n\t\tthis.startKnot = startKnot || 0;\n\t\tthis.endKnot = endKnot || ( this.knots.length - 1 );\n\t\tfor ( var i = 0; i < controlPoints.length; ++ i ) {\n\n\t\t\t// ensure Vector4 for control points\n\t\t\tvar point = controlPoints[ i ];\n\t\t\tthis.controlPoints[ i ] = new THREE.Vector4( point.x, point.y, point.z, point.w );\n\n\t\t}\n\n\t};\n\n\n\tTHREE.NURBSCurve.prototype = Object.create( THREE.Curve.prototype );\n\tTHREE.NURBSCurve.prototype.constructor = THREE.NURBSCurve;\n\n\n\tTHREE.NURBSCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u\n\n\t\t// following results in (wx, wy, wz, w) homogeneous point\n\t\tvar hpoint = THREE.NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );\n\n\t\tif ( hpoint.w != 1.0 ) {\n\n\t\t\t// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n\t\t\thpoint.divideScalar( hpoint.w );\n\n\t\t}\n\n\t\treturn new THREE.Vector3( hpoint.x, hpoint.y, hpoint.z );\n\n\t};\n\n\n\tTHREE.NURBSCurve.prototype.getTangent = function ( t ) {\n\n\t\tvar u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );\n\t\tvar ders = THREE.NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );\n\t\tvar tangent = ders[ 1 ].clone();\n\t\ttangent.normalize();\n\n\t\treturn tangent;\n\n\t};\n\treturn THREE.NURBSCurve;\n});\n\ndefine('skylark-threejs-ex/curves/NURBSSurface',[\n\t\"skylark-threejs\",\n\t\"./NURBSUtils\"\n],function(THREE){\n\t/**\n\t * @author renej\n\t * NURBS surface object\n\t *\n\t * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n\t *\n\t **/\n\n\n\t/**************************************************************\n\t *\tNURBS surface\n\t **************************************************************/\n\n\tTHREE.NURBSSurface = function ( degree1, degree2, knots1, knots2 /* arrays of reals */, controlPoints /* array^2 of Vector(2|3|4) */ ) {\n\n\t\tthis.degree1 = degree1;\n\t\tthis.degree2 = degree2;\n\t\tthis.knots1 = knots1;\n\t\tthis.knots2 = knots2;\n\t\tthis.controlPoints = [];\n\n\t\tvar len1 = knots1.length - degree1 - 1;\n\t\tvar len2 = knots2.length - degree2 - 1;\n\n\t\t// ensure Vector4 for control points\n\t\tfor ( var i = 0; i < len1; ++ i ) {\n\n\t\t\tthis.controlPoints[ i ] = [];\n\t\t\tfor ( var j = 0; j < len2; ++ j ) {\n\n\t\t\t\tvar point = controlPoints[ i ][ j ];\n\t\t\t\tthis.controlPoints[ i ][ j ] = new THREE.Vector4( point.x, point.y, point.z, point.w );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\tTHREE.NURBSSurface.prototype = {\n\n\t\tconstructor: THREE.NURBSSurface,\n\n\t\tgetPoint: function ( t1, t2, target ) {\n\n\t\t\tvar u = this.knots1[ 0 ] + t1 * ( this.knots1[ this.knots1.length - 1 ] - this.knots1[ 0 ] ); // linear mapping t1->u\n\t\t\tvar v = this.knots2[ 0 ] + t2 * ( this.knots2[ this.knots2.length - 1 ] - this.knots2[ 0 ] ); // linear mapping t2->u\n\n\t\t\tTHREE.NURBSUtils.calcSurfacePoint( this.degree1, this.degree2, this.knots1, this.knots2, this.controlPoints, u, v, target );\n\n\t\t}\n\t};\n\treturn THREE.NURBSSurface;\n});\n\ndefine('skylark-threejs-ex/objects/Lensflare',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tTHREE.Lensflare = function () {\n\n\t\tTHREE.Mesh.call( this, THREE.Lensflare.Geometry, new THREE.MeshBasicMaterial( { opacity: 0, transparent: true } ) );\n\n\t\tthis.type = 'Lensflare';\n\t\tthis.frustumCulled = false;\n\t\tthis.renderOrder = Infinity;\n\n\t\t//\n\n\t\tvar positionScreen = new THREE.Vector3();\n\t\tvar positionView = new THREE.Vector3();\n\n\t\t// textures\n\n\t\tvar tempMap = new THREE.DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, THREE.RGBFormat );\n\t\ttempMap.minFilter = THREE.NearestFilter;\n\t\ttempMap.magFilter = THREE.NearestFilter;\n\t\ttempMap.wrapS = THREE.ClampToEdgeWrapping;\n\t\ttempMap.wrapT = THREE.ClampToEdgeWrapping;\n\n\t\tvar occlusionMap = new THREE.DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, THREE.RGBFormat );\n\t\tocclusionMap.minFilter = THREE.NearestFilter;\n\t\tocclusionMap.magFilter = THREE.NearestFilter;\n\t\tocclusionMap.wrapS = THREE.ClampToEdgeWrapping;\n\t\tocclusionMap.wrapT = THREE.ClampToEdgeWrapping;\n\n\t\t// material\n\n\t\tvar geometry = THREE.Lensflare.Geometry;\n\n\t\tvar material1a = new THREE.RawShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\t'scale': { value: null },\n\t\t\t\t'screenPosition': { value: null }\n\t\t\t},\n\t\t\tvertexShader: [\n\n\t\t\t\t'precision highp float;',\n\n\t\t\t\t'uniform vec3 screenPosition;',\n\t\t\t\t'uniform vec2 scale;',\n\n\t\t\t\t'attribute vec3 position;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ),\n\t\t\tfragmentShader: [\n\n\t\t\t\t'precision highp float;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ),\n\t\t\tdepthTest: true,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: false\n\t\t} );\n\n\t\tvar material1b = new THREE.RawShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\t'map': { value: tempMap },\n\t\t\t\t'scale': { value: null },\n\t\t\t\t'screenPosition': { value: null }\n\t\t\t},\n\t\t\tvertexShader: [\n\n\t\t\t\t'precision highp float;',\n\n\t\t\t\t'uniform vec3 screenPosition;',\n\t\t\t\t'uniform vec2 scale;',\n\n\t\t\t\t'attribute vec3 position;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tvUV = uv;',\n\n\t\t\t\t'\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ),\n\t\t\tfragmentShader: [\n\n\t\t\t\t'precision highp float;',\n\n\t\t\t\t'uniform sampler2D map;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tgl_FragColor = texture2D( map, vUV );',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ),\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: false\n\t\t} );\n\n\t\t// the following object is used for occlusionMap generation\n\n\t\tvar mesh1 = new THREE.Mesh( geometry, material1a );\n\n\t\t//\n\n\t\tvar elements = [];\n\n\t\tvar shader = THREE.LensflareElement.Shader;\n\n\t\tvar material2 = new THREE.RawShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\t'map': { value: null },\n\t\t\t\t'occlusionMap': { value: occlusionMap },\n\t\t\t\t'color': { value: new THREE.Color( 0xffffff ) },\n\t\t\t\t'scale': { value: new THREE.Vector2() },\n\t\t\t\t'screenPosition': { value: new THREE.Vector3() }\n\t\t\t},\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tblending: THREE.AdditiveBlending,\n\t\t\ttransparent: true,\n\t\t\tdepthWrite: false\n\t\t} );\n\n\t\tvar mesh2 = new THREE.Mesh( geometry, material2 );\n\n\t\tthis.addElement = function ( element ) {\n\n\t\t\telements.push( element );\n\n\t\t};\n\n\t\t//\n\n\t\tvar scale = new THREE.Vector2();\n\t\tvar screenPositionPixels = new THREE.Vector2();\n\t\tvar validArea = new THREE.Box2();\n\t\tvar viewport = new THREE.Vector4();\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\trenderer.getCurrentViewport( viewport );\n\n\t\t\tvar invAspect = viewport.w / viewport.z;\n\t\t\tvar halfViewportWidth = viewport.z / 2.0;\n\t\t\tvar halfViewportHeight = viewport.w / 2.0;\n\n\t\t\tvar size = 16 / viewport.w;\n\t\t\tscale.set( size * invAspect, size );\n\n\t\t\tvalidArea.min.set( viewport.x, viewport.y );\n\t\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\n\n\t\t\t// calculate position in screen space\n\n\t\t\tpositionView.setFromMatrixPosition( this.matrixWorld );\n\t\t\tpositionView.applyMatrix4( camera.matrixWorldInverse );\n\n\t\t\tif ( positionView.z > 0 ) return; // lensflare is behind the camera\n\n\t\t\tpositionScreen.copy( positionView ).applyMatrix4( camera.projectionMatrix );\n\n\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\tscreenPositionPixels.x = viewport.x + ( positionScreen.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\tscreenPositionPixels.y = viewport.y + ( positionScreen.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t// screen cull\n\n\t\t\tif ( validArea.containsPoint( screenPositionPixels ) ) {\n\n\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\trenderer.copyFramebufferToTexture( screenPositionPixels, tempMap );\n\n\t\t\t\t// render pink quad\n\n\t\t\t\tvar uniforms = material1a.uniforms;\n\t\t\t\tuniforms[ \"scale\" ].value = scale;\n\t\t\t\tuniforms[ \"screenPosition\" ].value = positionScreen;\n\n\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1a, mesh1, null );\n\n\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\trenderer.copyFramebufferToTexture( screenPositionPixels, occlusionMap );\n\n\t\t\t\t// restore graphics\n\n\t\t\t\tvar uniforms = material1b.uniforms;\n\t\t\t\tuniforms[ \"scale\" ].value = scale;\n\t\t\t\tuniforms[ \"screenPosition\" ].value = positionScreen;\n\n\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1b, mesh1, null );\n\n\t\t\t\t// render elements\n\n\t\t\t\tvar vecX = - positionScreen.x * 2;\n\t\t\t\tvar vecY = - positionScreen.y * 2;\n\n\t\t\t\tfor ( var i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar element = elements[ i ];\n\n\t\t\t\t\tvar uniforms = material2.uniforms;\n\n\t\t\t\t\tuniforms[ \"color\" ].value.copy( element.color );\n\t\t\t\t\tuniforms[ \"map\" ].value = element.texture;\n\t\t\t\t\tuniforms[ \"screenPosition\" ].value.x = positionScreen.x + vecX * element.distance;\n\t\t\t\t\tuniforms[ \"screenPosition\" ].value.y = positionScreen.y + vecY * element.distance;\n\n\t\t\t\t\tvar size = element.size / viewport.w;\n\t\t\t\t\tvar invAspect = viewport.w / viewport.z;\n\n\t\t\t\t\tuniforms[ \"scale\" ].value.set( size * invAspect, size );\n\n\t\t\t\t\tmaterial2.uniformsNeedUpdate = true;\n\n\t\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material2, mesh2, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.dispose = function () {\n\n\t\t\tmaterial1a.dispose();\n\t\t\tmaterial1b.dispose();\n\t\t\tmaterial2.dispose();\n\n\t\t\ttempMap.dispose();\n\t\t\tocclusionMap.dispose();\n\n\t\t\tfor ( var i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\t\telements[ i ].texture.dispose();\n\n\t\t\t}\n\n\t\t};\n\n\t};\n\n\tTHREE.Lensflare.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.Lensflare.prototype.constructor = THREE.Lensflare;\n\tTHREE.Lensflare.prototype.isLensflare = true;\n\n\t//\n\n\tTHREE.LensflareElement = function ( texture, size, distance, color ) {\n\n\t\tthis.texture = texture;\n\t\tthis.size = size || 1;\n\t\tthis.distance = distance || 0;\n\t\tthis.color = color || new THREE.Color( 0xffffff );\n\n\t};\n\n\tTHREE.LensflareElement.Shader = {\n\n\t\tuniforms: {\n\n\t\t\t'map': { value: null },\n\t\t\t'occlusionMap': { value: null },\n\t\t\t'color': { value: null },\n\t\t\t'scale': { value: null },\n\t\t\t'screenPosition': { value: null }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t'precision highp float;',\n\n\t\t\t'uniform vec3 screenPosition;',\n\t\t\t'uniform vec2 scale;',\n\n\t\t\t'uniform sampler2D occlusionMap;',\n\n\t\t\t'attribute vec3 position;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'varying vec2 vUV;',\n\t\t\t'varying float vVisibility;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvUV = uv;',\n\n\t\t\t'\tvec2 pos = position.xy;',\n\n\t\t\t'\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',\n\n\t\t\t'\tvVisibility =        visibility.r / 9.0;',\n\t\t\t'\tvVisibility *= 1.0 - visibility.g / 9.0;',\n\t\t\t'\tvVisibility *=       visibility.b / 9.0;',\n\n\t\t\t'\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\n\t\t\t'precision highp float;',\n\n\t\t\t'uniform sampler2D map;',\n\t\t\t'uniform vec3 color;',\n\n\t\t\t'varying vec2 vUV;',\n\t\t\t'varying float vVisibility;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvec4 texture = texture2D( map, vUV );',\n\t\t\t'\ttexture.a *= vVisibility;',\n\t\t\t'\tgl_FragColor = texture;',\n\t\t\t'\tgl_FragColor.rgb *= color;',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' )\n\n\t};\n\n\tTHREE.Lensflare.Geometry = ( function () {\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\tvar float32Array = new Float32Array( [\n\t\t\t- 1, - 1, 0, 0, 0,\n\t\t\t1, - 1, 0, 1, 0,\n\t\t\t1, 1, 0, 1, 1,\n\t\t\t- 1, 1, 0, 0, 1\n\t\t] );\n\n\t\tvar interleavedBuffer = new THREE.InterleavedBuffer( float32Array, 5 );\n\n\t\tgeometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\t\tgeometry.setAttribute( 'position', new THREE.InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\t\tgeometry.setAttribute( 'uv', new THREE.InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\t\treturn geometry;\n\n\t} )();\n\t\n\treturn THREE.Lensflare;\n});\n\ndefine('skylark-threejs-ex/objects/Reflector',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Slayvin / http://slayvin.net\n\t */\n\n\tTHREE.Reflector = function ( geometry, options ) {\n\n\t\tTHREE.Mesh.call( this, geometry );\n\n\t\tthis.type = 'Reflector';\n\n\t\tvar scope = this;\n\n\t\toptions = options || {};\n\n\t\tvar color = ( options.color !== undefined ) ? new THREE.Color( options.color ) : new THREE.Color( 0x7F7F7F );\n\t\tvar textureWidth = options.textureWidth || 512;\n\t\tvar textureHeight = options.textureHeight || 512;\n\t\tvar clipBias = options.clipBias || 0;\n\t\tvar shader = options.shader || THREE.Reflector.ReflectorShader;\n\t\tvar recursion = options.recursion !== undefined ? options.recursion : 0;\n\t\tvar encoding = options.encoding !== undefined ? options.encoding : THREE.LinearEncoding;\n\n\t\t//\n\n\t\tvar reflectorPlane = new THREE.Plane();\n\t\tvar normal = new THREE.Vector3();\n\t\tvar reflectorWorldPosition = new THREE.Vector3();\n\t\tvar cameraWorldPosition = new THREE.Vector3();\n\t\tvar rotationMatrix = new THREE.Matrix4();\n\t\tvar lookAtPosition = new THREE.Vector3( 0, 0, - 1 );\n\t\tvar clipPlane = new THREE.Vector4();\n\n\t\tvar view = new THREE.Vector3();\n\t\tvar target = new THREE.Vector3();\n\t\tvar q = new THREE.Vector4();\n\n\t\tvar textureMatrix = new THREE.Matrix4();\n\t\tvar virtualCamera = new THREE.PerspectiveCamera();\n\n\t\tvar parameters = {\n\t\t\tminFilter: THREE.LinearFilter,\n\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\tformat: THREE.RGBFormat,\n\t\t\tstencilBuffer: false,\n\t\t\tencoding: encoding\n\t\t};\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\t\tif ( ! THREE.MathUtils.isPowerOfTwo( textureWidth ) || ! THREE.MathUtils.isPowerOfTwo( textureHeight ) ) {\n\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\t}\n\n\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader\n\t\t} );\n\n\t\tmaterial.uniforms[ \"tDiffuse\" ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ \"color\" ].value = color;\n\t\tmaterial.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\n\t\tthis.material = material;\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\tif ( 'recursion' in camera.userData ) {\n\n\t\t\t\tif ( camera.userData.recursion === recursion ) return;\n\n\t\t\t\tcamera.userData.recursion ++;\n\n\t\t\t}\n\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when reflector is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( reflectorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( reflectorWorldPosition );\n\n\t\t\tvirtualCamera.position.copy( view );\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tvirtualCamera.up.reflect( normal );\n\t\t\tvirtualCamera.lookAt( target );\n\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\tvirtualCamera.userData.recursion = 0;\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// Calculate the scaled plane vector\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t\t// Replacing the third row of the projection matrix\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t\t// Render\n\n\t\t\tscope.visible = false;\n\n\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tvar currentXrEnabled = renderer.xr.enabled;\n\t\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification and recursion\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tvar viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t};\n\n\tTHREE.Reflector.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.Reflector.prototype.constructor = THREE.Reflector;\n\n\tTHREE.Reflector.ReflectorShader = {\n\n\t\tuniforms: {\n\n\t\t\t'color': {\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'tDiffuse': {\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'textureMatrix': {\n\t\t\t\tvalue: null\n\t\t\t}\n\n\t\t},\n\n\t\tvertexShader: [\n\t\t\t'uniform mat4 textureMatrix;',\n\t\t\t'varying vec4 vUv;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvUv = textureMatrix * vec4( position, 1.0 );',\n\n\t\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t\t'}'\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\t\t\t'uniform vec3 color;',\n\t\t\t'uniform sampler2D tDiffuse;',\n\t\t\t'varying vec4 vUv;',\n\n\t\t\t'float blendOverlay( float base, float blend ) {',\n\n\t\t\t'\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\n\n\t\t\t'}',\n\n\t\t\t'vec3 blendOverlay( vec3 base, vec3 blend ) {',\n\n\t\t\t'\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\n\n\t\t\t'}',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvec4 base = texture2DProj( tDiffuse, vUv );',\n\t\t\t'\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\n\n\t\t\t'}'\n\t\t].join( '\\n' )\n\t};\n\t\n\treturn THREE.Reflector;\n});\n\ndefine('skylark-threejs-ex/objects/Refractor',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t */\n\n\tTHREE.Refractor = function ( geometry, options ) {\n\n\t\tTHREE.Mesh.call( this, geometry );\n\n\t\tthis.type = 'Refractor';\n\n\t\tvar scope = this;\n\n\t\toptions = options || {};\n\n\t\tvar color = ( options.color !== undefined ) ? new THREE.Color( options.color ) : new THREE.Color( 0x7F7F7F );\n\t\tvar textureWidth = options.textureWidth || 512;\n\t\tvar textureHeight = options.textureHeight || 512;\n\t\tvar clipBias = options.clipBias || 0;\n\t\tvar shader = options.shader || THREE.Refractor.RefractorShader;\n\t\tvar encoding = options.encoding !== undefined ? options.encoding : THREE.LinearEncoding;\n\n\t\t//\n\n\t\tvar virtualCamera = new THREE.PerspectiveCamera();\n\t\tvirtualCamera.matrixAutoUpdate = false;\n\t\tvirtualCamera.userData.refractor = true;\n\n\t\t//\n\n\t\tvar refractorPlane = new THREE.Plane();\n\t\tvar textureMatrix = new THREE.Matrix4();\n\n\t\t// render target\n\n\t\tvar parameters = {\n\t\t\tminFilter: THREE.LinearFilter,\n\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\tformat: THREE.RGBFormat,\n\t\t\tstencilBuffer: false,\n\t\t\tencoding: encoding\n\t\t};\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\t\tif ( ! THREE.MathUtils.isPowerOfTwo( textureWidth ) || ! THREE.MathUtils.isPowerOfTwo( textureHeight ) ) {\n\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\t}\n\n\t\t// material\n\n\t\tthis.material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\ttransparent: true // ensures, refractors are drawn from farthest to closest\n\t\t} );\n\n\t\tthis.material.uniforms[ \"color\" ].value = color;\n\t\tthis.material.uniforms[ \"tDiffuse\" ].value = renderTarget.texture;\n\t\tthis.material.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\n\t\t// functions\n\n\t\tvar visible = ( function () {\n\n\t\t\tvar refractorWorldPosition = new THREE.Vector3();\n\t\t\tvar cameraWorldPosition = new THREE.Vector3();\n\t\t\tvar rotationMatrix = new THREE.Matrix4();\n\n\t\t\tvar view = new THREE.Vector3();\n\t\t\tvar normal = new THREE.Vector3();\n\n\t\t\treturn function visible( camera ) {\n\n\t\t\t\trefractorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\t\tview.subVectors( refractorWorldPosition, cameraWorldPosition );\n\n\t\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\t\tnormal.set( 0, 0, 1 );\n\t\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\t\treturn view.dot( normal ) < 0;\n\n\t\t\t};\n\n\t\t} )();\n\n\t\tvar updateRefractorPlane = ( function () {\n\n\t\t\tvar normal = new THREE.Vector3();\n\t\t\tvar position = new THREE.Vector3();\n\t\t\tvar quaternion = new THREE.Quaternion();\n\t\t\tvar scale = new THREE.Vector3();\n\n\t\t\treturn function updateRefractorPlane() {\n\n\t\t\t\tscope.matrixWorld.decompose( position, quaternion, scale );\n\t\t\t\tnormal.set( 0, 0, 1 ).applyQuaternion( quaternion ).normalize();\n\n\t\t\t\t// flip the normal because we want to cull everything above the plane\n\n\t\t\t\tnormal.negate();\n\n\t\t\t\trefractorPlane.setFromNormalAndCoplanarPoint( normal, position );\n\n\t\t\t};\n\n\t\t} )();\n\n\t\tvar updateVirtualCamera = ( function () {\n\n\t\t\tvar clipPlane = new THREE.Plane();\n\t\t\tvar clipVector = new THREE.Vector4();\n\t\t\tvar q = new THREE.Vector4();\n\n\t\t\treturn function updateVirtualCamera( camera ) {\n\n\t\t\t\tvirtualCamera.matrixWorld.copy( camera.matrixWorld );\n\t\t\t\tvirtualCamera.matrixWorldInverse.getInverse( virtualCamera.matrixWorld );\n\t\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\t\t\t\tvirtualCamera.far = camera.far; // used in WebGLBackground\n\n\t\t\t\t// The following code creates an oblique view frustum for clipping.\n\t\t\t\t// see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n\t\t\t\t// Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n\t\t\t\tclipPlane.copy( refractorPlane );\n\t\t\t\tclipPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\t\tclipVector.set( clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant );\n\n\t\t\t\t// calculate the clip-space corner point opposite the clipping plane and\n\t\t\t\t// transform it into camera space by multiplying it by the inverse of the projection matrix\n\n\t\t\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\t\tq.x = ( Math.sign( clipVector.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\t\tq.y = ( Math.sign( clipVector.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\t\tq.z = - 1.0;\n\t\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t\t// calculate the scaled plane vector\n\n\t\t\t\tclipVector.multiplyScalar( 2.0 / clipVector.dot( q ) );\n\n\t\t\t\t// replacing the third row of the projection matrix\n\n\t\t\t\tprojectionMatrix.elements[ 2 ] = clipVector.x;\n\t\t\t\tprojectionMatrix.elements[ 6 ] = clipVector.y;\n\t\t\t\tprojectionMatrix.elements[ 10 ] = clipVector.z + 1.0 - clipBias;\n\t\t\t\tprojectionMatrix.elements[ 14 ] = clipVector.w;\n\n\t\t\t};\n\n\t\t} )();\n\n\t\t// This will update the texture matrix that is used for projective texture mapping in the shader.\n\t\t// see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\t\tfunction updateTextureMatrix( camera ) {\n\n\t\t\t// this matrix does range mapping to [ 0, 1 ]\n\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\n\t\t\t// we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n\t\t\t// (matrix above) with the projection and view matrix of the virtual camera\n\t\t\t// and the model matrix of the refractor\n\n\t\t\ttextureMatrix.multiply( camera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction render( renderer, scene, camera ) {\n\n\t\t\tscope.visible = false;\n\n\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\t\t\tvar currentXrEnabled = renderer.xr.enabled;\n\t\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// restore viewport\n\n\t\t\tvar viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t}\n\n\t\t//\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t// ensure refractors are rendered only once per frame\n\n\t\t\tif ( camera.userData.refractor === true ) return;\n\n\t\t\t// avoid rendering when the refractor is viewed from behind\n\n\t\t\tif ( ! visible( camera ) === true ) return;\n\n\t\t\t// update\n\n\t\t\tupdateRefractorPlane();\n\n\t\t\tupdateTextureMatrix( camera );\n\n\t\t\tupdateVirtualCamera( camera );\n\n\t\t\trender( renderer, scene, camera );\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t};\n\n\tTHREE.Refractor.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.Refractor.prototype.constructor = THREE.Refractor;\n\n\tTHREE.Refractor.RefractorShader = {\n\n\t\tuniforms: {\n\n\t\t\t'color': {\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'tDiffuse': {\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'textureMatrix': {\n\t\t\t\tvalue: null\n\t\t\t}\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t'uniform mat4 textureMatrix;',\n\n\t\t\t'varying vec4 vUv;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvUv = textureMatrix * vec4( position, 1.0 );',\n\n\t\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\n\t\t\t'uniform vec3 color;',\n\t\t\t'uniform sampler2D tDiffuse;',\n\n\t\t\t'varying vec4 vUv;',\n\n\t\t\t'float blendOverlay( float base, float blend ) {',\n\n\t\t\t'\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\n\n\t\t\t'}',\n\n\t\t\t'vec3 blendOverlay( vec3 base, vec3 blend ) {',\n\n\t\t\t'\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\n\n\t\t\t'}',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvec4 base = texture2DProj( tDiffuse, vUv );',\n\n\t\t\t'\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' )\n\t};\n\t\n\treturn THREE.Refractor;\n});\n\ndefine('skylark-threejs-ex/loaders/TTFLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author gero3 / https://github.com/gero3\n\t * @author tentone / https://github.com/tentone\n\t * @author troy351 / https://github.com/troy351\n\t *\n\t * Requires opentype.js to be included in the project.\n\t * Loads TTF files and converts them into typeface JSON that can be used directly\n\t * to create THREE.Font objects.\n\t */\n\n\tTHREE.TTFLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.reversed = false;\n\n\t};\n\n\n\tTHREE.TTFLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.TTFLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tonLoad( scope.parse( buffer ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( arraybuffer ) {\n\n\t\t\tfunction convert( font, reversed ) {\n\n\t\t\t\tvar round = Math.round;\n\n\t\t\t\tvar glyphs = {};\n\t\t\t\tvar scale = ( 100000 ) / ( ( font.unitsPerEm || 2048 ) * 72 );\n\n\t\t\t\tvar glyphIndexMap = font.encoding.cmap.glyphIndexMap;\n\t\t\t\tvar unicodes = Object.keys( glyphIndexMap );\n\n\t\t\t\tfor ( var i = 0; i < unicodes.length; i ++ ) {\n\n\t\t\t\t\tvar unicode = unicodes[ i ];\n\t\t\t\t\tvar glyph = font.glyphs.glyphs[ glyphIndexMap[ unicode ] ];\n\n\t\t\t\t\tif ( unicode !== undefined ) {\n\n\t\t\t\t\t\tvar token = {\n\t\t\t\t\t\t\tha: round( glyph.advanceWidth * scale ),\n\t\t\t\t\t\t\tx_min: round( glyph.xMin * scale ),\n\t\t\t\t\t\t\tx_max: round( glyph.xMax * scale ),\n\t\t\t\t\t\t\to: ''\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif ( reversed ) {\n\n\t\t\t\t\t\t\tglyph.path.commands = reverseCommands( glyph.path.commands );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tglyph.path.commands.forEach( function ( command ) {\n\n\t\t\t\t\t\t\tif ( command.type.toLowerCase() === 'c' ) {\n\n\t\t\t\t\t\t\t\tcommand.type = 'b';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttoken.o += command.type.toLowerCase() + ' ';\n\n\t\t\t\t\t\t\tif ( command.x !== undefined && command.y !== undefined ) {\n\n\t\t\t\t\t\t\t\ttoken.o += round( command.x * scale ) + ' ' + round( command.y * scale ) + ' ';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( command.x1 !== undefined && command.y1 !== undefined ) {\n\n\t\t\t\t\t\t\t\ttoken.o += round( command.x1 * scale ) + ' ' + round( command.y1 * scale ) + ' ';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( command.x2 !== undefined && command.y2 !== undefined ) {\n\n\t\t\t\t\t\t\t\ttoken.o += round( command.x2 * scale ) + ' ' + round( command.y2 * scale ) + ' ';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tglyphs[ String.fromCodePoint( glyph.unicode ) ] = token;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tglyphs: glyphs,\n\t\t\t\t\tfamilyName: font.getEnglishName( 'fullName' ),\n\t\t\t\t\tascender: round( font.ascender * scale ),\n\t\t\t\t\tdescender: round( font.descender * scale ),\n\t\t\t\t\tunderlinePosition: font.tables.post.underlinePosition,\n\t\t\t\t\tunderlineThickness: font.tables.post.underlineThickness,\n\t\t\t\t\tboundingBox: {\n\t\t\t\t\t\txMin: font.tables.head.xMin,\n\t\t\t\t\t\txMax: font.tables.head.xMax,\n\t\t\t\t\t\tyMin: font.tables.head.yMin,\n\t\t\t\t\t\tyMax: font.tables.head.yMax\n\t\t\t\t\t},\n\t\t\t\t\tresolution: 1000,\n\t\t\t\t\toriginal_font_information: font.tables.name\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction reverseCommands( commands ) {\n\n\t\t\t\tvar paths = [];\n\t\t\t\tvar path;\n\n\t\t\t\tcommands.forEach( function ( c ) {\n\n\t\t\t\t\tif ( c.type.toLowerCase() === 'm' ) {\n\n\t\t\t\t\t\tpath = [ c ];\n\t\t\t\t\t\tpaths.push( path );\n\n\t\t\t\t\t} else if ( c.type.toLowerCase() !== 'z' ) {\n\n\t\t\t\t\t\tpath.push( c );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tvar reversed = [];\n\n\t\t\t\tpaths.forEach( function ( p ) {\n\n\t\t\t\t\tvar result = {\n\t\t\t\t\t\ttype: 'm',\n\t\t\t\t\t\tx: p[ p.length - 1 ].x,\n\t\t\t\t\t\ty: p[ p.length - 1 ].y\n\t\t\t\t\t};\n\n\t\t\t\t\treversed.push( result );\n\n\t\t\t\t\tfor ( var i = p.length - 1; i > 0; i -- ) {\n\n\t\t\t\t\t\tvar command = p[ i ];\n\t\t\t\t\t\tvar result = { type: command.type };\n\n\t\t\t\t\t\tif ( command.x2 !== undefined && command.y2 !== undefined ) {\n\n\t\t\t\t\t\t\tresult.x1 = command.x2;\n\t\t\t\t\t\t\tresult.y1 = command.y2;\n\t\t\t\t\t\t\tresult.x2 = command.x1;\n\t\t\t\t\t\t\tresult.y2 = command.y1;\n\n\t\t\t\t\t\t} else if ( command.x1 !== undefined && command.y1 !== undefined ) {\n\n\t\t\t\t\t\t\tresult.x1 = command.x1;\n\t\t\t\t\t\t\tresult.y1 = command.y1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult.x = p[ i - 1 ].x;\n\t\t\t\t\t\tresult.y = p[ i - 1 ].y;\n\t\t\t\t\t\treversed.push( result );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn reversed;\n\n\t\t\t}\n\n\t\t\tif ( typeof opentype === 'undefined' ) {\n\n\t\t\t\tconsole.warn( 'THREE.TTFLoader: The loader requires opentype.js. Make sure it\\'s included before using the loader.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\treturn convert( opentype.parse( arraybuffer ), this.reversed );\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.TTFLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/3MFLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author technohippy / https://github.com/technohippy\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * 3D Manufacturing Format (3MF) specification: https://3mf.io/specification/\n\t *\n\t * The following features from the core specification are supported:\n\t *\n\t * - 3D Models\n\t * - Object Resources (Meshes and Components)\n\t * - Material Resources (Base Materials)\n\t *\n\t * 3MF Materials and Properties Extension are only partially supported.\n\t *\n\t * - Texture 2D\n\t * - Texture 2D Groups\n\t * - Color Groups (Vertex Colors)\n\t * - Metallic Display Properties (PBR)\n\t */\n\n\tTHREE.ThreeMFLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.availableExtensions = [];\n\n\t};\n\n\tTHREE.ThreeMFLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.ThreeMFLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tonLoad( scope.parse( buffer ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data ) {\n\n\t\t\tvar scope = this;\n\t\t\tvar textureLoader = new THREE.TextureLoader( this.manager );\n\n\t\t\tfunction loadDocument( data ) {\n\n\t\t\t\tvar zip = null;\n\t\t\t\tvar file = null;\n\n\t\t\t\tvar relsName;\n\t\t\t\tvar modelRelsName;\n\t\t\t\tvar modelPartNames = [];\n\t\t\t\tvar printTicketPartNames = [];\n\t\t\t\tvar texturesPartNames = [];\n\t\t\t\tvar otherPartNames = [];\n\n\t\t\t\tvar rels;\n\t\t\t\tvar modelRels;\n\t\t\t\tvar modelParts = {};\n\t\t\t\tvar printTicketParts = {};\n\t\t\t\tvar texturesParts = {};\n\t\t\t\tvar otherParts = {};\n\n\t\t\t\ttry {\n\n\t\t\t\t\tzip = new JSZip( data ); // eslint-disable-line no-undef\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( e instanceof ReferenceError ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.3MFLoader: jszip missing and file is compressed.' );\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( file in zip.files ) {\n\n\t\t\t\t\tif ( file.match( /\\_rels\\/.rels$/ ) ) {\n\n\t\t\t\t\t\trelsName = file;\n\n\t\t\t\t\t} else if ( file.match( /3D\\/_rels\\/.*\\.model\\.rels$/ ) ) {\n\n\t\t\t\t\t\tmodelRelsName = file;\n\n\t\t\t\t\t} else if ( file.match( /^3D\\/.*\\.model$/ ) ) {\n\n\t\t\t\t\t\tmodelPartNames.push( file );\n\n\t\t\t\t\t} else if ( file.match( /^3D\\/Metadata\\/.*\\.xml$/ ) ) {\n\n\t\t\t\t\t\tprintTicketPartNames.push( file );\n\n\t\t\t\t\t} else if ( file.match( /^3D\\/Textures?\\/.*/ ) ) {\n\n\t\t\t\t\t\ttexturesPartNames.push( file );\n\n\t\t\t\t\t} else if ( file.match( /^3D\\/Other\\/.*/ ) ) {\n\n\t\t\t\t\t\totherPartNames.push( file );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar relsView = new Uint8Array( zip.file( relsName ).asArrayBuffer() );\n\t\t\t\tvar relsFileText = THREE.LoaderUtils.decodeText( relsView );\n\t\t\t\trels = parseRelsXml( relsFileText );\n\n\t\t\t\t//\n\n\t\t\t\tif ( modelRelsName ) {\n\n\t\t\t\t\tvar relsView = new Uint8Array( zip.file( modelRelsName ).asArrayBuffer() );\n\t\t\t\t\tvar relsFileText = THREE.LoaderUtils.decodeText( relsView );\n\t\t\t\t\tmodelRels = parseRelsXml( relsFileText );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tfor ( var i = 0; i < modelPartNames.length; i ++ ) {\n\n\t\t\t\t\tvar modelPart = modelPartNames[ i ];\n\t\t\t\t\tvar view = new Uint8Array( zip.file( modelPart ).asArrayBuffer() );\n\n\t\t\t\t\tvar fileText = THREE.LoaderUtils.decodeText( view );\n\t\t\t\t\tvar xmlData = new DOMParser().parseFromString( fileText, 'application/xml' );\n\n\t\t\t\t\tif ( xmlData.documentElement.nodeName.toLowerCase() !== 'model' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.3MFLoader: Error loading 3MF - no 3MF document found: ', modelPart );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar modelNode = xmlData.querySelector( 'model' );\n\t\t\t\t\tvar extensions = {};\n\n\t\t\t\t\tfor ( var i = 0; i < modelNode.attributes.length; i ++ ) {\n\n\t\t\t\t\t\tvar attr = modelNode.attributes[ i ];\n\t\t\t\t\t\tif ( attr.name.match( /^xmlns:(.+)$/ ) ) {\n\n\t\t\t\t\t\t\textensions[ attr.value ] = RegExp.$1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar modelData = parseModelNode( modelNode );\n\t\t\t\t\tmodelData[ 'xml' ] = modelNode;\n\n\t\t\t\t\tif ( 0 < Object.keys( extensions ).length ) {\n\n\t\t\t\t\t\tmodelData[ 'extensions' ] = extensions;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmodelParts[ modelPart ] = modelData;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tfor ( var i = 0; i < texturesPartNames.length; i ++ ) {\n\n\t\t\t\t\tvar texturesPartName = texturesPartNames[ i ];\n\t\t\t\t\ttexturesParts[ texturesPartName ] = zip.file( texturesPartName ).asArrayBuffer();\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\trels: rels,\n\t\t\t\t\tmodelRels: modelRels,\n\t\t\t\t\tmodel: modelParts,\n\t\t\t\t\tprintTicket: printTicketParts,\n\t\t\t\t\ttexture: texturesParts,\n\t\t\t\t\tother: otherParts\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction parseRelsXml( relsFileText ) {\n\n\t\t\t\tvar relationships = [];\n\n\t\t\t\tvar relsXmlData = new DOMParser().parseFromString( relsFileText, 'application/xml' );\n\n\t\t\t\tvar relsNodes = relsXmlData.querySelectorAll( 'Relationship' );\n\n\t\t\t\tfor ( var i = 0; i < relsNodes.length; i ++ ) {\n\n\t\t\t\t\tvar relsNode = relsNodes[ i ];\n\n\t\t\t\t\tvar relationship = {\n\t\t\t\t\t\ttarget: relsNode.getAttribute( 'Target' ), //required\n\t\t\t\t\t\tid: relsNode.getAttribute( 'Id' ), //required\n\t\t\t\t\t\ttype: relsNode.getAttribute( 'Type' ) //required\n\t\t\t\t\t};\n\n\t\t\t\t\trelationships.push( relationship );\n\n\t\t\t\t}\n\n\t\t\t\treturn relationships;\n\n\t\t\t}\n\n\t\t\tfunction parseMetadataNodes( metadataNodes ) {\n\n\t\t\t\tvar metadataData = {};\n\n\t\t\t\tfor ( var i = 0; i < metadataNodes.length; i ++ ) {\n\n\t\t\t\t\tvar metadataNode = metadataNodes[ i ];\n\t\t\t\t\tvar name = metadataNode.getAttribute( 'name' );\n\t\t\t\t\tvar validNames = [\n\t\t\t\t\t\t'Title',\n\t\t\t\t\t\t'Designer',\n\t\t\t\t\t\t'Description',\n\t\t\t\t\t\t'Copyright',\n\t\t\t\t\t\t'LicenseTerms',\n\t\t\t\t\t\t'Rating',\n\t\t\t\t\t\t'CreationDate',\n\t\t\t\t\t\t'ModificationDate'\n\t\t\t\t\t];\n\n\t\t\t\t\tif ( 0 <= validNames.indexOf( name ) ) {\n\n\t\t\t\t\t\tmetadataData[ name ] = metadataNode.textContent;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn metadataData;\n\n\t\t\t}\n\n\t\t\tfunction parseBasematerialsNode( basematerialsNode ) {\n\n\t\t\t\tvar basematerialsData = {\n\t\t\t\t\tid: basematerialsNode.getAttribute( 'id' ), // required\n\t\t\t\t\tbasematerials: []\n\t\t\t\t};\n\n\t\t\t\tvar basematerialNodes = basematerialsNode.querySelectorAll( 'base' );\n\n\t\t\t\tfor ( var i = 0; i < basematerialNodes.length; i ++ ) {\n\n\t\t\t\t\tvar basematerialNode = basematerialNodes[ i ];\n\t\t\t\t\tvar basematerialData = parseBasematerialNode( basematerialNode );\n\t\t\t\t\tbasematerialData.index = i; // the order and count of the material nodes form an implicit 0-based index\n\t\t\t\t\tbasematerialsData.basematerials.push( basematerialData );\n\n\t\t\t\t}\n\n\t\t\t\treturn basematerialsData;\n\n\t\t\t}\n\n\t\t\tfunction parseTexture2DNode( texture2DNode ) {\n\n\t\t\t\tvar texture2dData = {\n\t\t\t\t\tid: texture2DNode.getAttribute( 'id' ), // required\n\t\t\t\t\tpath: texture2DNode.getAttribute( 'path' ), // required\n\t\t\t\t\tcontenttype: texture2DNode.getAttribute( 'contenttype' ), // required\n\t\t\t\t\ttilestyleu: texture2DNode.getAttribute( 'tilestyleu' ),\n\t\t\t\t\ttilestylev: texture2DNode.getAttribute( 'tilestylev' ),\n\t\t\t\t\tfilter: texture2DNode.getAttribute( 'filter' ),\n\t\t\t\t};\n\n\t\t\t\treturn texture2dData;\n\n\t\t\t}\n\n\t\t\tfunction parseTextures2DGroupNode( texture2DGroupNode ) {\n\n\t\t\t\tvar texture2DGroupData = {\n\t\t\t\t\tid: texture2DGroupNode.getAttribute( 'id' ), // required\n\t\t\t\t\ttexid: texture2DGroupNode.getAttribute( 'texid' ), // required\n\t\t\t\t\tdisplaypropertiesid: texture2DGroupNode.getAttribute( 'displaypropertiesid' )\n\t\t\t\t};\n\n\t\t\t\tvar tex2coordNodes = texture2DGroupNode.querySelectorAll( 'tex2coord' );\n\n\t\t\t\tvar uvs = [];\n\n\t\t\t\tfor ( var i = 0; i < tex2coordNodes.length; i ++ ) {\n\n\t\t\t\t\tvar tex2coordNode = tex2coordNodes[ i ];\n\t\t\t\t\tvar u = tex2coordNode.getAttribute( 'u' );\n\t\t\t\t\tvar v = tex2coordNode.getAttribute( 'v' );\n\n\t\t\t\t\tuvs.push( parseFloat( u ), parseFloat( v ) );\n\n\t\t\t\t}\n\n\t\t\t\ttexture2DGroupData[ 'uvs' ] = new Float32Array( uvs );\n\n\t\t\t\treturn texture2DGroupData;\n\n\t\t\t}\n\n\t\t\tfunction parseColorGroupNode( colorGroupNode ) {\n\n\t\t\t\tvar colorGroupData = {\n\t\t\t\t\tid: colorGroupNode.getAttribute( 'id' ), // required\n\t\t\t\t\tdisplaypropertiesid: colorGroupNode.getAttribute( 'displaypropertiesid' )\n\t\t\t\t};\n\n\t\t\t\tvar colorNodes = colorGroupNode.querySelectorAll( 'color' );\n\n\t\t\t\tvar colors = [];\n\t\t\t\tvar colorObject = new THREE.Color();\n\n\t\t\t\tfor ( var i = 0; i < colorNodes.length; i ++ ) {\n\n\t\t\t\t\tvar colorNode = colorNodes[ i ];\n\t\t\t\t\tvar color = colorNode.getAttribute( 'color' );\n\n\t\t\t\t\tcolorObject.setStyle( color.substring( 0, 7 ) );\n\t\t\t\t\tcolorObject.convertSRGBToLinear(); // color is in sRGB\n\n\t\t\t\t\tcolors.push( colorObject.r, colorObject.g, colorObject.b );\n\n\t\t\t\t}\n\n\t\t\t\tcolorGroupData[ 'colors' ] = new Float32Array( colors );\n\n\t\t\t\treturn colorGroupData;\n\n\t\t\t}\n\n\t\t\tfunction parseMetallicDisplaypropertiesNode( metallicDisplaypropetiesNode ) {\n\n\t\t\t\tvar metallicDisplaypropertiesData = {\n\t\t\t\t\tid: metallicDisplaypropetiesNode.getAttribute( 'id' ) // required\n\t\t\t\t};\n\n\t\t\t\tvar metallicNodes = metallicDisplaypropetiesNode.querySelectorAll( 'pbmetallic' );\n\n\t\t\t\tvar metallicData = [];\n\n\t\t\t\tfor ( var i = 0; i < metallicNodes.length; i ++ ) {\n\n\t\t\t\t\tvar metallicNode = metallicNodes[ i ];\n\n\t\t\t\t\tmetallicData.push( {\n\t\t\t\t\t\tname: metallicNode.getAttribute( 'name' ), // required\n\t\t\t\t\t\tmetallicness: parseFloat( metallicNode.getAttribute( 'metallicness' ) ), // required\n\t\t\t\t\t\troughness: parseFloat( metallicNode.getAttribute( 'roughness' ) ) // required\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tmetallicDisplaypropertiesData.data = metallicData;\n\n\t\t\t\treturn metallicDisplaypropertiesData;\n\n\t\t\t}\n\n\t\t\tfunction parseBasematerialNode( basematerialNode ) {\n\n\t\t\t\tvar basematerialData = {};\n\n\t\t\t\tbasematerialData[ 'name' ] = basematerialNode.getAttribute( 'name' ); // required\n\t\t\t\tbasematerialData[ 'displaycolor' ] = basematerialNode.getAttribute( 'displaycolor' ); // required\n\t\t\t\tbasematerialData[ 'displaypropertiesid' ] = basematerialNode.getAttribute( 'displaypropertiesid' );\n\n\t\t\t\treturn basematerialData;\n\n\t\t\t}\n\n\t\t\tfunction parseMeshNode( meshNode ) {\n\n\t\t\t\tvar meshData = {};\n\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar vertexNodes = meshNode.querySelectorAll( 'vertices vertex' );\n\n\t\t\t\tfor ( var i = 0; i < vertexNodes.length; i ++ ) {\n\n\t\t\t\t\tvar vertexNode = vertexNodes[ i ];\n\t\t\t\t\tvar x = vertexNode.getAttribute( 'x' );\n\t\t\t\t\tvar y = vertexNode.getAttribute( 'y' );\n\t\t\t\t\tvar z = vertexNode.getAttribute( 'z' );\n\n\t\t\t\t\tvertices.push( parseFloat( x ), parseFloat( y ), parseFloat( z ) );\n\n\t\t\t\t}\n\n\t\t\t\tmeshData[ 'vertices' ] = new Float32Array( vertices );\n\n\t\t\t\tvar triangleProperties = [];\n\t\t\t\tvar triangles = [];\n\t\t\t\tvar triangleNodes = meshNode.querySelectorAll( 'triangles triangle' );\n\n\t\t\t\tfor ( var i = 0; i < triangleNodes.length; i ++ ) {\n\n\t\t\t\t\tvar triangleNode = triangleNodes[ i ];\n\t\t\t\t\tvar v1 = triangleNode.getAttribute( 'v1' );\n\t\t\t\t\tvar v2 = triangleNode.getAttribute( 'v2' );\n\t\t\t\t\tvar v3 = triangleNode.getAttribute( 'v3' );\n\t\t\t\t\tvar p1 = triangleNode.getAttribute( 'p1' );\n\t\t\t\t\tvar p2 = triangleNode.getAttribute( 'p2' );\n\t\t\t\t\tvar p3 = triangleNode.getAttribute( 'p3' );\n\t\t\t\t\tvar pid = triangleNode.getAttribute( 'pid' );\n\n\t\t\t\t\tvar triangleProperty = {};\n\n\t\t\t\t\ttriangleProperty[ 'v1' ] = parseInt( v1, 10 );\n\t\t\t\t\ttriangleProperty[ 'v2' ] = parseInt( v2, 10 );\n\t\t\t\t\ttriangleProperty[ 'v3' ] = parseInt( v3, 10 );\n\n\t\t\t\t\ttriangles.push( triangleProperty[ 'v1' ], triangleProperty[ 'v2' ], triangleProperty[ 'v3' ] );\n\n\t\t\t\t\t// optional\n\n\t\t\t\t\tif ( p1 ) {\n\n\t\t\t\t\t\ttriangleProperty[ 'p1' ] = parseInt( p1, 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( p2 ) {\n\n\t\t\t\t\t\ttriangleProperty[ 'p2' ] = parseInt( p2, 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( p3 ) {\n\n\t\t\t\t\t\ttriangleProperty[ 'p3' ] = parseInt( p3, 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( pid ) {\n\n\t\t\t\t\t\ttriangleProperty[ 'pid' ] = pid;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 0 < Object.keys( triangleProperty ).length ) {\n\n\t\t\t\t\t\ttriangleProperties.push( triangleProperty );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmeshData[ 'triangleProperties' ] = triangleProperties;\n\t\t\t\tmeshData[ 'triangles' ] = new Uint32Array( triangles );\n\n\t\t\t\treturn meshData;\n\n\t\t\t}\n\n\t\t\tfunction parseComponentsNode( componentsNode ) {\n\n\t\t\t\tvar components = [];\n\n\t\t\t\tvar componentNodes = componentsNode.querySelectorAll( 'component' );\n\n\t\t\t\tfor ( var i = 0; i < componentNodes.length; i ++ ) {\n\n\t\t\t\t\tvar componentNode = componentNodes[ i ];\n\t\t\t\t\tvar componentData = parseComponentNode( componentNode );\n\t\t\t\t\tcomponents.push( componentData );\n\n\t\t\t\t}\n\n\t\t\t\treturn components;\n\n\t\t\t}\n\n\t\t\tfunction parseComponentNode( componentNode ) {\n\n\t\t\t\tvar componentData = {};\n\n\t\t\t\tcomponentData[ 'objectId' ] = componentNode.getAttribute( 'objectid' ); // required\n\n\t\t\t\tvar transform = componentNode.getAttribute( 'transform' );\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tcomponentData[ 'transform' ] = parseTransform( transform );\n\n\t\t\t\t}\n\n\t\t\t\treturn componentData;\n\n\t\t\t}\n\n\t\t\tfunction parseTransform( transform ) {\n\n\t\t\t\tvar t = [];\n\t\t\t\ttransform.split( ' ' ).forEach( function ( s ) {\n\n\t\t\t\t\tt.push( parseFloat( s ) );\n\n\t\t\t\t} );\n\n\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\tmatrix.set(\n\t\t\t\t\tt[ 0 ], t[ 3 ], t[ 6 ], t[ 9 ],\n\t\t\t\t\tt[ 1 ], t[ 4 ], t[ 7 ], t[ 10 ],\n\t\t\t\t\tt[ 2 ], t[ 5 ], t[ 8 ], t[ 11 ],\n\t\t\t\t\t 0.0, 0.0, 0.0, 1.0\n\t\t\t\t);\n\n\t\t\t\treturn matrix;\n\n\t\t\t}\n\n\t\t\tfunction parseObjectNode( objectNode ) {\n\n\t\t\t\tvar objectData = {\n\t\t\t\t\ttype: objectNode.getAttribute( 'type' )\n\t\t\t\t};\n\n\t\t\t\tvar id = objectNode.getAttribute( 'id' );\n\n\t\t\t\tif ( id ) {\n\n\t\t\t\t\tobjectData[ 'id' ] = id;\n\n\t\t\t\t}\n\n\t\t\t\tvar pid = objectNode.getAttribute( 'pid' );\n\n\t\t\t\tif ( pid ) {\n\n\t\t\t\t\tobjectData[ 'pid' ] = pid;\n\n\t\t\t\t}\n\n\t\t\t\tvar pindex = objectNode.getAttribute( 'pindex' );\n\n\t\t\t\tif ( pindex ) {\n\n\t\t\t\t\tobjectData[ 'pindex' ] = pindex;\n\n\t\t\t\t}\n\n\t\t\t\tvar thumbnail = objectNode.getAttribute( 'thumbnail' );\n\n\t\t\t\tif ( thumbnail ) {\n\n\t\t\t\t\tobjectData[ 'thumbnail' ] = thumbnail;\n\n\t\t\t\t}\n\n\t\t\t\tvar partnumber = objectNode.getAttribute( 'partnumber' );\n\n\t\t\t\tif ( partnumber ) {\n\n\t\t\t\t\tobjectData[ 'partnumber' ] = partnumber;\n\n\t\t\t\t}\n\n\t\t\t\tvar name = objectNode.getAttribute( 'name' );\n\n\t\t\t\tif ( name ) {\n\n\t\t\t\t\tobjectData[ 'name' ] = name;\n\n\t\t\t\t}\n\n\t\t\t\tvar meshNode = objectNode.querySelector( 'mesh' );\n\n\t\t\t\tif ( meshNode ) {\n\n\t\t\t\t\tobjectData[ 'mesh' ] = parseMeshNode( meshNode );\n\n\t\t\t\t}\n\n\t\t\t\tvar componentsNode = objectNode.querySelector( 'components' );\n\n\t\t\t\tif ( componentsNode ) {\n\n\t\t\t\t\tobjectData[ 'components' ] = parseComponentsNode( componentsNode );\n\n\t\t\t\t}\n\n\t\t\t\treturn objectData;\n\n\t\t\t}\n\n\t\t\tfunction parseResourcesNode( resourcesNode ) {\n\n\t\t\t\tvar resourcesData = {};\n\n\t\t\t\tresourcesData[ 'basematerials' ] = {};\n\t\t\t\tvar basematerialsNodes = resourcesNode.querySelectorAll( 'basematerials' );\n\n\t\t\t\tfor ( var i = 0; i < basematerialsNodes.length; i ++ ) {\n\n\t\t\t\t\tvar basematerialsNode = basematerialsNodes[ i ];\n\t\t\t\t\tvar basematerialsData = parseBasematerialsNode( basematerialsNode );\n\t\t\t\t\tresourcesData[ 'basematerials' ][ basematerialsData[ 'id' ] ] = basematerialsData;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tresourcesData[ 'texture2d' ] = {};\n\t\t\t\tvar textures2DNodes = resourcesNode.querySelectorAll( 'texture2d' );\n\n\t\t\t\tfor ( var i = 0; i < textures2DNodes.length; i ++ ) {\n\n\t\t\t\t\tvar textures2DNode = textures2DNodes[ i ];\n\t\t\t\t\tvar texture2DData = parseTexture2DNode( textures2DNode );\n\t\t\t\t\tresourcesData[ 'texture2d' ][ texture2DData[ 'id' ] ] = texture2DData;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tresourcesData[ 'colorgroup' ] = {};\n\t\t\t\tvar colorGroupNodes = resourcesNode.querySelectorAll( 'colorgroup' );\n\n\t\t\t\tfor ( var i = 0; i < colorGroupNodes.length; i ++ ) {\n\n\t\t\t\t\tvar colorGroupNode = colorGroupNodes[ i ];\n\t\t\t\t\tvar colorGroupData = parseColorGroupNode( colorGroupNode );\n\t\t\t\t\tresourcesData[ 'colorgroup' ][ colorGroupData[ 'id' ] ] = colorGroupData;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tresourcesData[ 'pbmetallicdisplayproperties' ] = {};\n\t\t\t\tvar pbmetallicdisplaypropertiesNodes = resourcesNode.querySelectorAll( 'pbmetallicdisplayproperties' );\n\n\t\t\t\tfor ( var i = 0; i < pbmetallicdisplaypropertiesNodes.length; i ++ ) {\n\n\t\t\t\t\tvar pbmetallicdisplaypropertiesNode = pbmetallicdisplaypropertiesNodes[ i ];\n\t\t\t\t\tvar pbmetallicdisplaypropertiesData = parseMetallicDisplaypropertiesNode( pbmetallicdisplaypropertiesNode );\n\t\t\t\t\tresourcesData[ 'pbmetallicdisplayproperties' ][ pbmetallicdisplaypropertiesData[ 'id' ] ] = pbmetallicdisplaypropertiesData;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tresourcesData[ 'texture2dgroup' ] = {};\n\t\t\t\tvar textures2DGroupNodes = resourcesNode.querySelectorAll( 'texture2dgroup' );\n\n\t\t\t\tfor ( var i = 0; i < textures2DGroupNodes.length; i ++ ) {\n\n\t\t\t\t\tvar textures2DGroupNode = textures2DGroupNodes[ i ];\n\t\t\t\t\tvar textures2DGroupData = parseTextures2DGroupNode( textures2DGroupNode );\n\t\t\t\t\tresourcesData[ 'texture2dgroup' ][ textures2DGroupData[ 'id' ] ] = textures2DGroupData;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tresourcesData[ 'object' ] = {};\n\t\t\t\tvar objectNodes = resourcesNode.querySelectorAll( 'object' );\n\n\t\t\t\tfor ( var i = 0; i < objectNodes.length; i ++ ) {\n\n\t\t\t\t\tvar objectNode = objectNodes[ i ];\n\t\t\t\t\tvar objectData = parseObjectNode( objectNode );\n\t\t\t\t\tresourcesData[ 'object' ][ objectData[ 'id' ] ] = objectData;\n\n\t\t\t\t}\n\n\t\t\t\treturn resourcesData;\n\n\t\t\t}\n\n\t\t\tfunction parseBuildNode( buildNode ) {\n\n\t\t\t\tvar buildData = [];\n\t\t\t\tvar itemNodes = buildNode.querySelectorAll( 'item' );\n\n\t\t\t\tfor ( var i = 0; i < itemNodes.length; i ++ ) {\n\n\t\t\t\t\tvar itemNode = itemNodes[ i ];\n\t\t\t\t\tvar buildItem = {\n\t\t\t\t\t\tobjectId: itemNode.getAttribute( 'objectid' )\n\t\t\t\t\t};\n\t\t\t\t\tvar transform = itemNode.getAttribute( 'transform' );\n\n\t\t\t\t\tif ( transform ) {\n\n\t\t\t\t\t\tbuildItem[ 'transform' ] = parseTransform( transform );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbuildData.push( buildItem );\n\n\t\t\t\t}\n\n\t\t\t\treturn buildData;\n\n\t\t\t}\n\n\t\t\tfunction parseModelNode( modelNode ) {\n\n\t\t\t\tvar modelData = { unit: modelNode.getAttribute( 'unit' ) || 'millimeter' };\n\t\t\t\tvar metadataNodes = modelNode.querySelectorAll( 'metadata' );\n\n\t\t\t\tif ( metadataNodes ) {\n\n\t\t\t\t\tmodelData[ 'metadata' ] = parseMetadataNodes( metadataNodes );\n\n\t\t\t\t}\n\n\t\t\t\tvar resourcesNode = modelNode.querySelector( 'resources' );\n\n\t\t\t\tif ( resourcesNode ) {\n\n\t\t\t\t\tmodelData[ 'resources' ] = parseResourcesNode( resourcesNode );\n\n\t\t\t\t}\n\n\t\t\t\tvar buildNode = modelNode.querySelector( 'build' );\n\n\t\t\t\tif ( buildNode ) {\n\n\t\t\t\t\tmodelData[ 'build' ] = parseBuildNode( buildNode );\n\n\t\t\t\t}\n\n\t\t\t\treturn modelData;\n\n\t\t\t}\n\n\t\t\tfunction buildTexture( texture2dgroup, objects, modelData, textureData ) {\n\n\t\t\t\tvar texid = texture2dgroup.texid;\n\t\t\t\tvar texture2ds = modelData.resources.texture2d;\n\t\t\t\tvar texture2d = texture2ds[ texid ];\n\n\t\t\t\tif ( texture2d ) {\n\n\t\t\t\t\tvar data = textureData[ texture2d.path ];\n\t\t\t\t\tvar type = texture2d.contenttype;\n\n\t\t\t\t\tvar blob = new Blob( [ data ], { type: type } );\n\t\t\t\t\tvar sourceURI = URL.createObjectURL( blob );\n\n\t\t\t\t\tvar texture = textureLoader.load( sourceURI, function () {\n\n\t\t\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\ttexture.encoding = THREE.sRGBEncoding;\n\n\t\t\t\t\t// texture parameters\n\n\t\t\t\t\tswitch ( texture2d.tilestyleu ) {\n\n\t\t\t\t\t\tcase 'wrap':\n\t\t\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'mirror':\n\t\t\t\t\t\t\ttexture.wrapS = THREE.MirroredRepeatWrapping;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'none':\n\t\t\t\t\t\tcase 'clamp':\n\t\t\t\t\t\t\ttexture.wrapS = THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( texture2d.tilestylev ) {\n\n\t\t\t\t\t\tcase 'wrap':\n\t\t\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'mirror':\n\t\t\t\t\t\t\ttexture.wrapT = THREE.MirroredRepeatWrapping;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'none':\n\t\t\t\t\t\tcase 'clamp':\n\t\t\t\t\t\t\ttexture.wrapT = THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( texture2d.filter ) {\n\n\t\t\t\t\t\tcase 'auto':\n\t\t\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\t\t\ttexture.minFilter = THREE.LinearMipmapLinearFilter;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'linear':\n\t\t\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'nearest':\n\t\t\t\t\t\t\ttexture.magFilter = THREE.NearestFilter;\n\t\t\t\t\t\t\ttexture.minFilter = THREE.NearestFilter;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\t\t\ttexture.minFilter = THREE.LinearMipmapLinearFilter;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn texture;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction buildBasematerialsMeshes( basematerials, triangleProperties, modelData, meshData, textureData, objectData ) {\n\n\t\t\t\tvar objectPindex = objectData.pindex;\n\n\t\t\t\tvar materialMap = {};\n\n\t\t\t\tfor ( var i = 0, l = triangleProperties.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar triangleProperty = triangleProperties[ i ];\n\t\t\t\t\tvar pindex = ( triangleProperty.p1 !== undefined ) ? triangleProperty.p1 : objectPindex;\n\n\t\t\t\t\tif ( materialMap[ pindex ] === undefined ) materialMap[ pindex ] = [];\n\n\t\t\t\t\tmaterialMap[ pindex ].push( triangleProperty );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar keys = Object.keys( materialMap );\n\t\t\t\tvar meshes = [];\n\n\t\t\t\tfor ( var i = 0, l = keys.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar materialIndex = keys[ i ];\n\t\t\t\t\tvar trianglePropertiesProps = materialMap[ materialIndex ];\n\t\t\t\t\tvar basematerialData = basematerials.basematerials[ materialIndex ];\n\t\t\t\t\tvar material = getBuild( basematerialData, objects, modelData, textureData, objectData, buildBasematerial );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\t\tvar positionData = [];\n\n\t\t\t\t\tvar vertices = meshData.vertices;\n\n\t\t\t\t\tfor ( var j = 0, jl = trianglePropertiesProps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar triangleProperty = trianglePropertiesProps[ j ];\n\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 0 ] );\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 1 ] );\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 2 ] );\n\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 0 ] );\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 1 ] );\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 2 ] );\n\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 0 ] );\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 1 ] );\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 2 ] );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positionData, 3 ) );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tvar mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\t}\n\n\t\t\t\treturn meshes;\n\n\t\t\t}\n\n\t\t\tfunction buildTexturedMesh( texture2dgroup, triangleProperties, modelData, meshData, textureData, objectData ) {\n\n\t\t\t\t// geometry\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\tvar positionData = [];\n\t\t\t\tvar uvData = [];\n\n\t\t\t\tvar vertices = meshData.vertices;\n\t\t\t\tvar uvs = texture2dgroup.uvs;\n\n\t\t\t\tfor ( var i = 0, l = triangleProperties.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar triangleProperty = triangleProperties[ i ];\n\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 0 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 1 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 2 ] );\n\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 0 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 1 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 2 ] );\n\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 0 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 1 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 2 ] );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tuvData.push( uvs[ ( triangleProperty.p1 * 2 ) + 0 ] );\n\t\t\t\t\tuvData.push( uvs[ ( triangleProperty.p1 * 2 ) + 1 ] );\n\n\t\t\t\t\tuvData.push( uvs[ ( triangleProperty.p2 * 2 ) + 0 ] );\n\t\t\t\t\tuvData.push( uvs[ ( triangleProperty.p2 * 2 ) + 1 ] );\n\n\t\t\t\t\tuvData.push( uvs[ ( triangleProperty.p3 * 2 ) + 0 ] );\n\t\t\t\t\tuvData.push( uvs[ ( triangleProperty.p3 * 2 ) + 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positionData, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvData, 2 ) );\n\n\t\t\t\t// material\n\n\t\t\t\tvar texture = getBuild( texture2dgroup, objects, modelData, textureData, objectData, buildTexture );\n\n\t\t\t\tvar material = new THREE.MeshPhongMaterial( { map: texture, flatShading: true } );\n\n\t\t\t\t// mesh\n\n\t\t\t\tvar mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\treturn mesh;\n\n\t\t\t}\n\n\t\t\tfunction buildVertexColorMesh( colorgroup, triangleProperties, modelData, meshData ) {\n\n\t\t\t\t// geometry\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\tvar positionData = [];\n\t\t\t\tvar colorData = [];\n\n\t\t\t\tvar vertices = meshData.vertices;\n\t\t\t\tvar colors = colorgroup.colors;\n\n\t\t\t\tfor ( var i = 0, l = triangleProperties.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar triangleProperty = triangleProperties[ i ];\n\n\t\t\t\t\tvar v1 = triangleProperty.v1;\n\t\t\t\t\tvar v2 = triangleProperty.v2;\n\t\t\t\t\tvar v3 = triangleProperty.v3;\n\n\t\t\t\t\tpositionData.push( vertices[ ( v1 * 3 ) + 0 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( v1 * 3 ) + 1 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( v1 * 3 ) + 2 ] );\n\n\t\t\t\t\tpositionData.push( vertices[ ( v2 * 3 ) + 0 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( v2 * 3 ) + 1 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( v2 * 3 ) + 2 ] );\n\n\t\t\t\t\tpositionData.push( vertices[ ( v3 * 3 ) + 0 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( v3 * 3 ) + 1 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( v3 * 3 ) + 2 ] );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tvar p1 = triangleProperty.p1;\n\t\t\t\t\tvar p2 = triangleProperty.p2;\n\t\t\t\t\tvar p3 = triangleProperty.p3;\n\n\t\t\t\t\tcolorData.push( colors[ ( p1 * 3 ) + 0 ] );\n\t\t\t\t\tcolorData.push( colors[ ( p1 * 3 ) + 1 ] );\n\t\t\t\t\tcolorData.push( colors[ ( p1 * 3 ) + 2 ] );\n\n\t\t\t\t\tcolorData.push( colors[ ( ( p2 || p1 ) * 3 ) + 0 ] );\n\t\t\t\t\tcolorData.push( colors[ ( ( p2 || p1 ) * 3 ) + 1 ] );\n\t\t\t\t\tcolorData.push( colors[ ( ( p2 || p1 ) * 3 ) + 2 ] );\n\n\t\t\t\t\tcolorData.push( colors[ ( ( p3 || p1 ) * 3 ) + 0 ] );\n\t\t\t\t\tcolorData.push( colors[ ( ( p3 || p1 ) * 3 ) + 1 ] );\n\t\t\t\t\tcolorData.push( colors[ ( ( p3 || p1 ) * 3 ) + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positionData, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colorData, 3 ) );\n\n\t\t\t\t// material\n\n\t\t\t\tvar material = new THREE.MeshPhongMaterial( { vertexColors: true, flatShading: true } );\n\n\t\t\t\t// mesh\n\n\t\t\t\tvar mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\treturn mesh;\n\n\t\t\t}\n\n\t\t\tfunction buildDefaultMesh( meshData ) {\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( meshData[ 'triangles' ], 1 ) );\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( meshData[ 'vertices' ], 3 ) );\n\n\t\t\t\tvar material = new THREE.MeshPhongMaterial( { color: 0xaaaaff, flatShading: true } );\n\n\t\t\t\tvar mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\treturn mesh;\n\n\t\t\t}\n\n\t\t\tfunction buildMeshes( resourceMap, modelData, meshData, textureData, objectData ) {\n\n\t\t\t\tvar keys = Object.keys( resourceMap );\n\t\t\t\tvar meshes = [];\n\n\t\t\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar resourceId = keys[ i ];\n\t\t\t\t\tvar triangleProperties = resourceMap[ resourceId ];\n\t\t\t\t\tvar resourceType = getResourceType( resourceId, modelData );\n\n\t\t\t\t\tswitch ( resourceType ) {\n\n\t\t\t\t\t\tcase 'material':\n\t\t\t\t\t\t\tvar basematerials = modelData.resources.basematerials[ resourceId ];\n\t\t\t\t\t\t\tvar newMeshes = buildBasematerialsMeshes( basematerials, triangleProperties, modelData, meshData, textureData, objectData );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = newMeshes.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tmeshes.push( newMeshes[ j ] );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\t\tvar texture2dgroup = modelData.resources.texture2dgroup[ resourceId ];\n\t\t\t\t\t\t\tmeshes.push( buildTexturedMesh( texture2dgroup, triangleProperties, modelData, meshData, textureData, objectData ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\t\tvar colorgroup = modelData.resources.colorgroup[ resourceId ];\n\t\t\t\t\t\t\tmeshes.push( buildVertexColorMesh( colorgroup, triangleProperties, modelData, meshData ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'default':\n\t\t\t\t\t\t\tmeshes.push( buildDefaultMesh( meshData ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.3MFLoader: Unsupported resource type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn meshes;\n\n\t\t\t}\n\n\t\t\tfunction getResourceType( pid, modelData ) {\n\n\t\t\t\tif ( modelData.resources.texture2dgroup[ pid ] !== undefined ) {\n\n\t\t\t\t\treturn 'texture';\n\n\t\t\t\t} else if ( modelData.resources.basematerials[ pid ] !== undefined ) {\n\n\t\t\t\t\treturn 'material';\n\n\t\t\t\t} else if ( modelData.resources.colorgroup[ pid ] !== undefined ) {\n\n\t\t\t\t\treturn 'vertexColors';\n\n\t\t\t\t} else if ( pid === 'default' ) {\n\n\t\t\t\t\treturn 'default';\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction analyzeObject( modelData, meshData, objectData ) {\n\n\t\t\t\tvar resourceMap = {};\n\n\t\t\t\tvar triangleProperties = meshData[ 'triangleProperties' ];\n\n\t\t\t\tvar objectPid = objectData.pid;\n\n\t\t\t\tfor ( var i = 0, l = triangleProperties.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar triangleProperty = triangleProperties[ i ];\n\t\t\t\t\tvar pid = ( triangleProperty.pid !== undefined ) ? triangleProperty.pid : objectPid;\n\n\t\t\t\t\tif ( pid === undefined ) pid = 'default';\n\n\t\t\t\t\tif ( resourceMap[ pid ] === undefined ) resourceMap[ pid ] = [];\n\n\t\t\t\t\tresourceMap[ pid ].push( triangleProperty );\n\n\t\t\t\t}\n\n\t\t\t\treturn resourceMap;\n\n\t\t\t}\n\n\t\t\tfunction buildGroup( meshData, objects, modelData, textureData, objectData ) {\n\n\t\t\t\tvar group = new THREE.Group();\n\n\t\t\t\tvar resourceMap = analyzeObject( modelData, meshData, objectData );\n\t\t\t\tvar meshes = buildMeshes( resourceMap, modelData, meshData, textureData, objectData );\n\n\t\t\t\tfor ( var i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn group;\n\n\t\t\t}\n\n\t\t\tfunction applyExtensions( extensions, meshData, modelXml ) {\n\n\t\t\t\tif ( ! extensions ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvar availableExtensions = [];\n\t\t\t\tvar keys = Object.keys( extensions );\n\n\t\t\t\tfor ( var i = 0; i < keys.length; i ++ ) {\n\n\t\t\t\t\tvar ns = keys[ i ];\n\n\t\t\t\t\tfor ( var j = 0; j < scope.availableExtensions.length; j ++ ) {\n\n\t\t\t\t\t\tvar extension = scope.availableExtensions[ j ];\n\n\t\t\t\t\t\tif ( extension.ns === ns ) {\n\n\t\t\t\t\t\t\tavailableExtensions.push( extension );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < availableExtensions.length; i ++ ) {\n\n\t\t\t\t\tvar extension = availableExtensions[ i ];\n\t\t\t\t\textension.apply( modelXml, extensions[ extension[ 'ns' ] ], meshData );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getBuild( data, objects, modelData, textureData, objectData, builder ) {\n\n\t\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\t\tdata.build = builder( data, objects, modelData, textureData, objectData );\n\n\t\t\t\treturn data.build;\n\n\t\t\t}\n\n\t\t\tfunction buildBasematerial( materialData, objects, modelData ) {\n\n\t\t\t\tvar material;\n\n\t\t\t\tvar displaypropertiesid = materialData.displaypropertiesid;\n\t\t\t\tvar pbmetallicdisplayproperties = modelData.resources.pbmetallicdisplayproperties;\n\n\t\t\t\tif ( displaypropertiesid !== null && pbmetallicdisplayproperties[ displaypropertiesid ] !== undefined ) {\n\n\t\t\t\t\t// metallic display property, use StandardMaterial\n\n\t\t\t\t\tvar pbmetallicdisplayproperty = pbmetallicdisplayproperties[ displaypropertiesid ];\n\t\t\t\t\tvar metallicData = pbmetallicdisplayproperty.data[ materialData.index ];\n\n\t\t\t\t\tmaterial = new THREE.MeshStandardMaterial( { flatShading: true, roughness: metallicData.roughness, metalness: metallicData.metallicness } );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// otherwise use PhongMaterial\n\n\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial( { flatShading: true } );\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.name = materialData.name;\n\n\t\t\t\t// displaycolor MUST be specified with a value of a 6 or 8 digit hexadecimal number, e.g. \"#RRGGBB\" or \"#RRGGBBAA\"\n\n\t\t\t\tvar displaycolor = materialData.displaycolor;\n\n\t\t\t\tvar color = displaycolor.substring( 0, 7 );\n\t\t\t\tmaterial.color.setStyle( color );\n\t\t\t\tmaterial.color.convertSRGBToLinear(); // displaycolor is in sRGB\n\n\t\t\t\t// process alpha if set\n\n\t\t\t\tif ( displaycolor.length === 9 ) {\n\n\t\t\t\t\tmaterial.opacity = parseInt( displaycolor.charAt( 7 ) + displaycolor.charAt( 8 ), 16 ) / 255;\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t\tfunction buildComposite( compositeData, objects, modelData, textureData ) {\n\n\t\t\t\tvar composite = new THREE.Group();\n\n\t\t\t\tfor ( var j = 0; j < compositeData.length; j ++ ) {\n\n\t\t\t\t\tvar component = compositeData[ j ];\n\t\t\t\t\tvar build = objects[ component.objectId ];\n\n\t\t\t\t\tif ( build === undefined ) {\n\n\t\t\t\t\t\tbuildObject( component.objectId, objects, modelData, textureData );\n\t\t\t\t\t\tbuild = objects[ component.objectId ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar object3D = build.clone();\n\n\t\t\t\t\t// apply component transfrom\n\n\t\t\t\t\tvar transform = component.transform;\n\n\t\t\t\t\tif ( transform ) {\n\n\t\t\t\t\t\tobject3D.applyMatrix4( transform );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcomposite.add( object3D );\n\n\t\t\t\t}\n\n\t\t\t\treturn composite;\n\n\t\t\t}\n\n\t\t\tfunction buildObject( objectId, objects, modelData, textureData ) {\n\n\t\t\t\tvar objectData = modelData[ 'resources' ][ 'object' ][ objectId ];\n\n\t\t\t\tif ( objectData[ 'mesh' ] ) {\n\n\t\t\t\t\tvar meshData = objectData[ 'mesh' ];\n\n\t\t\t\t\tvar extensions = modelData[ 'extensions' ];\n\t\t\t\t\tvar modelXml = modelData[ 'xml' ];\n\n\t\t\t\t\tapplyExtensions( extensions, meshData, modelXml );\n\n\t\t\t\t\tobjects[ objectData.id ] = getBuild( meshData, objects, modelData, textureData, objectData, buildGroup );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar compositeData = objectData[ 'components' ];\n\n\t\t\t\t\tobjects[ objectData.id ] = getBuild( compositeData, objects, modelData, textureData, objectData, buildComposite );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction buildObjects( data3mf ) {\n\n\t\t\t\tvar modelsData = data3mf.model;\n\t\t\t\tvar modelRels = data3mf.modelRels;\n\t\t\t\tvar objects = {};\n\t\t\t\tvar modelsKeys = Object.keys( modelsData );\n\t\t\t\tvar textureData = {};\n\n\t\t\t\t// evaluate model relationships to textures\n\n\t\t\t\tif ( modelRels ) {\n\n\t\t\t\t\tfor ( var i = 0, l = modelRels.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar modelRel = modelRels[ i ];\n\t\t\t\t\t\tvar textureKey = modelRel.target.substring( 1 );\n\n\t\t\t\t\t\tif ( data3mf.texture[ textureKey ] ) {\n\n\t\t\t\t\t\t\ttextureData[ modelRel.target ] = data3mf.texture[ textureKey ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// start build\n\n\t\t\t\tfor ( var i = 0; i < modelsKeys.length; i ++ ) {\n\n\t\t\t\t\tvar modelsKey = modelsKeys[ i ];\n\t\t\t\t\tvar modelData = modelsData[ modelsKey ];\n\n\t\t\t\t\tvar objectIds = Object.keys( modelData[ 'resources' ][ 'object' ] );\n\n\t\t\t\t\tfor ( var j = 0; j < objectIds.length; j ++ ) {\n\n\t\t\t\t\t\tvar objectId = objectIds[ j ];\n\n\t\t\t\t\t\tbuildObject( objectId, objects, modelData, textureData );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn objects;\n\n\t\t\t}\n\n\t\t\tfunction build( objects, data3mf ) {\n\n\t\t\t\tvar group = new THREE.Group();\n\n\t\t\t\tvar relationship = data3mf[ 'rels' ][ 0 ];\n\t\t\t\tvar buildData = data3mf.model[ relationship[ 'target' ].substring( 1 ) ][ 'build' ];\n\n\t\t\t\tfor ( var i = 0; i < buildData.length; i ++ ) {\n\n\t\t\t\t\tvar buildItem = buildData[ i ];\n\t\t\t\t\tvar object3D = objects[ buildItem[ 'objectId' ] ];\n\n\t\t\t\t\t// apply transform\n\n\t\t\t\t\tvar transform = buildItem[ 'transform' ];\n\n\t\t\t\t\tif ( transform ) {\n\n\t\t\t\t\t\tobject3D.applyMatrix4( transform );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgroup.add( object3D );\n\n\t\t\t\t}\n\n\t\t\t\treturn group;\n\n\t\t\t}\n\n\t\t\tvar data3mf = loadDocument( data );\n\t\t\tvar objects = buildObjects( data3mf );\n\n\t\t\treturn build( objects, data3mf );\n\n\t\t},\n\n\t\taddExtension: function ( extension ) {\n\n\t\t\tthis.availableExtensions.push( extension );\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.ThreeMFLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/AMFLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author tamarintech / https://tamarintech.com\n\t *\n\t * Description: Early release of an AMF Loader following the pattern of the\n\t * example loaders in the three.js project.\n\t *\n\t * More information about the AMF format: http://amf.wikispaces.com\n\t *\n\t * Usage:\n\t *\tvar loader = new AMFLoader();\n\t *\tloader.load('/path/to/project.amf', function(objecttree) {\n\t *\t\tscene.add(objecttree);\n\t *\t});\n\t *\n\t * Materials now supported, material colors supported\n\t * Zip support, requires jszip\n\t * No constellation support (yet)!\n\t *\n\t */\n\n\tTHREE.AMFLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.AMFLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.AMFLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data ) {\n\n\t\t\tfunction loadDocument( data ) {\n\n\t\t\t\tvar view = new DataView( data );\n\t\t\t\tvar magic = String.fromCharCode( view.getUint8( 0 ), view.getUint8( 1 ) );\n\n\t\t\t\tif ( magic === 'PK' ) {\n\n\t\t\t\t\tvar zip = null;\n\t\t\t\t\tvar file = null;\n\n\t\t\t\t\tconsole.log( 'THREE.AMFLoader: Loading Zip' );\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tzip = new JSZip( data ); // eslint-disable-line no-undef\n\n\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\tif ( e instanceof ReferenceError ) {\n\n\t\t\t\t\t\t\tconsole.log( 'THREE.AMFLoader: jszip missing and file is compressed.' );\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( file in zip.files ) {\n\n\t\t\t\t\t\tif ( file.toLowerCase().substr( - 4 ) === '.amf' ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.log( 'THREE.AMFLoader: Trying to load file asset: ' + file );\n\t\t\t\t\tview = new DataView( zip.file( file ).asArrayBuffer() );\n\n\t\t\t\t}\n\n\t\t\t\tvar fileText = THREE.LoaderUtils.decodeText( view );\n\t\t\t\tvar xmlData = new DOMParser().parseFromString( fileText, 'application/xml' );\n\n\t\t\t\tif ( xmlData.documentElement.nodeName.toLowerCase() !== 'amf' ) {\n\n\t\t\t\t\tconsole.log( 'THREE.AMFLoader: Error loading AMF - no AMF document found.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\treturn xmlData;\n\n\t\t\t}\n\n\t\t\tfunction loadDocumentScale( node ) {\n\n\t\t\t\tvar scale = 1.0;\n\t\t\t\tvar unit = 'millimeter';\n\n\t\t\t\tif ( node.documentElement.attributes.unit !== undefined ) {\n\n\t\t\t\t\tunit = node.documentElement.attributes.unit.value.toLowerCase();\n\n\t\t\t\t}\n\n\t\t\t\tvar scaleUnits = {\n\t\t\t\t\tmillimeter: 1.0,\n\t\t\t\t\tinch: 25.4,\n\t\t\t\t\tfeet: 304.8,\n\t\t\t\t\tmeter: 1000.0,\n\t\t\t\t\tmicron: 0.001\n\t\t\t\t};\n\n\t\t\t\tif ( scaleUnits[ unit ] !== undefined ) {\n\n\t\t\t\t\tscale = scaleUnits[ unit ];\n\n\t\t\t\t}\n\n\t\t\t\tconsole.log( 'THREE.AMFLoader: Unit scale: ' + scale );\n\t\t\t\treturn scale;\n\n\t\t\t}\n\n\t\t\tfunction loadMaterials( node ) {\n\n\t\t\t\tvar matName = 'AMF Material';\n\t\t\t\tvar matId = node.attributes.id.textContent;\n\t\t\t\tvar color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\n\n\t\t\t\tvar loadedMaterial = null;\n\n\t\t\t\tfor ( var i = 0; i < node.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar matChildEl = node.childNodes[ i ];\n\n\t\t\t\t\tif ( matChildEl.nodeName === 'metadata' && matChildEl.attributes.type !== undefined ) {\n\n\t\t\t\t\t\tif ( matChildEl.attributes.type.value === 'name' ) {\n\n\t\t\t\t\t\t\tmatName = matChildEl.textContent;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( matChildEl.nodeName === 'color' ) {\n\n\t\t\t\t\t\tcolor = loadColor( matChildEl );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tloadedMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tflatShading: true,\n\t\t\t\t\tcolor: new THREE.Color( color.r, color.g, color.b ),\n\t\t\t\t\tname: matName\n\t\t\t\t} );\n\n\t\t\t\tif ( color.a !== 1.0 ) {\n\n\t\t\t\t\tloadedMaterial.transparent = true;\n\t\t\t\t\tloadedMaterial.opacity = color.a;\n\n\t\t\t\t}\n\n\t\t\t\treturn { id: matId, material: loadedMaterial };\n\n\t\t\t}\n\n\t\t\tfunction loadColor( node ) {\n\n\t\t\t\tvar color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\n\n\t\t\t\tfor ( var i = 0; i < node.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar matColor = node.childNodes[ i ];\n\n\t\t\t\t\tif ( matColor.nodeName === 'r' ) {\n\n\t\t\t\t\t\tcolor.r = matColor.textContent;\n\n\t\t\t\t\t} else if ( matColor.nodeName === 'g' ) {\n\n\t\t\t\t\t\tcolor.g = matColor.textContent;\n\n\t\t\t\t\t} else if ( matColor.nodeName === 'b' ) {\n\n\t\t\t\t\t\tcolor.b = matColor.textContent;\n\n\t\t\t\t\t} else if ( matColor.nodeName === 'a' ) {\n\n\t\t\t\t\t\tcolor.a = matColor.textContent;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn color;\n\n\t\t\t}\n\n\t\t\tfunction loadMeshVolume( node ) {\n\n\t\t\t\tvar volume = { name: '', triangles: [], materialid: null };\n\n\t\t\t\tvar currVolumeNode = node.firstElementChild;\n\n\t\t\t\tif ( node.attributes.materialid !== undefined ) {\n\n\t\t\t\t\tvolume.materialId = node.attributes.materialid.nodeValue;\n\n\t\t\t\t}\n\n\t\t\t\twhile ( currVolumeNode ) {\n\n\t\t\t\t\tif ( currVolumeNode.nodeName === 'metadata' ) {\n\n\t\t\t\t\t\tif ( currVolumeNode.attributes.type !== undefined ) {\n\n\t\t\t\t\t\t\tif ( currVolumeNode.attributes.type.value === 'name' ) {\n\n\t\t\t\t\t\t\t\tvolume.name = currVolumeNode.textContent;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( currVolumeNode.nodeName === 'triangle' ) {\n\n\t\t\t\t\t\tvar v1 = currVolumeNode.getElementsByTagName( 'v1' )[ 0 ].textContent;\n\t\t\t\t\t\tvar v2 = currVolumeNode.getElementsByTagName( 'v2' )[ 0 ].textContent;\n\t\t\t\t\t\tvar v3 = currVolumeNode.getElementsByTagName( 'v3' )[ 0 ].textContent;\n\n\t\t\t\t\t\tvolume.triangles.push( v1, v2, v3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrVolumeNode = currVolumeNode.nextElementSibling;\n\n\t\t\t\t}\n\n\t\t\t\treturn volume;\n\n\t\t\t}\n\n\t\t\tfunction loadMeshVertices( node ) {\n\n\t\t\t\tvar vertArray = [];\n\t\t\t\tvar normalArray = [];\n\t\t\t\tvar currVerticesNode = node.firstElementChild;\n\n\t\t\t\twhile ( currVerticesNode ) {\n\n\t\t\t\t\tif ( currVerticesNode.nodeName === 'vertex' ) {\n\n\t\t\t\t\t\tvar vNode = currVerticesNode.firstElementChild;\n\n\t\t\t\t\t\twhile ( vNode ) {\n\n\t\t\t\t\t\t\tif ( vNode.nodeName === 'coordinates' ) {\n\n\t\t\t\t\t\t\t\tvar x = vNode.getElementsByTagName( 'x' )[ 0 ].textContent;\n\t\t\t\t\t\t\t\tvar y = vNode.getElementsByTagName( 'y' )[ 0 ].textContent;\n\t\t\t\t\t\t\t\tvar z = vNode.getElementsByTagName( 'z' )[ 0 ].textContent;\n\n\t\t\t\t\t\t\t\tvertArray.push( x, y, z );\n\n\t\t\t\t\t\t\t} else if ( vNode.nodeName === 'normal' ) {\n\n\t\t\t\t\t\t\t\tvar nx = vNode.getElementsByTagName( 'nx' )[ 0 ].textContent;\n\t\t\t\t\t\t\t\tvar ny = vNode.getElementsByTagName( 'ny' )[ 0 ].textContent;\n\t\t\t\t\t\t\t\tvar nz = vNode.getElementsByTagName( 'nz' )[ 0 ].textContent;\n\n\t\t\t\t\t\t\t\tnormalArray.push( nx, ny, nz );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvNode = vNode.nextElementSibling;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tcurrVerticesNode = currVerticesNode.nextElementSibling;\n\n\t\t\t\t}\n\n\t\t\t\treturn { 'vertices': vertArray, 'normals': normalArray };\n\n\t\t\t}\n\n\t\t\tfunction loadObject( node ) {\n\n\t\t\t\tvar objId = node.attributes.id.textContent;\n\t\t\t\tvar loadedObject = { name: 'amfobject', meshes: [] };\n\t\t\t\tvar currColor = null;\n\t\t\t\tvar currObjNode = node.firstElementChild;\n\n\t\t\t\twhile ( currObjNode ) {\n\n\t\t\t\t\tif ( currObjNode.nodeName === 'metadata' ) {\n\n\t\t\t\t\t\tif ( currObjNode.attributes.type !== undefined ) {\n\n\t\t\t\t\t\t\tif ( currObjNode.attributes.type.value === 'name' ) {\n\n\t\t\t\t\t\t\t\tloadedObject.name = currObjNode.textContent;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( currObjNode.nodeName === 'color' ) {\n\n\t\t\t\t\t\tcurrColor = loadColor( currObjNode );\n\n\t\t\t\t\t} else if ( currObjNode.nodeName === 'mesh' ) {\n\n\t\t\t\t\t\tvar currMeshNode = currObjNode.firstElementChild;\n\t\t\t\t\t\tvar mesh = { vertices: [], normals: [], volumes: [], color: currColor };\n\n\t\t\t\t\t\twhile ( currMeshNode ) {\n\n\t\t\t\t\t\t\tif ( currMeshNode.nodeName === 'vertices' ) {\n\n\t\t\t\t\t\t\t\tvar loadedVertices = loadMeshVertices( currMeshNode );\n\n\t\t\t\t\t\t\t\tmesh.normals = mesh.normals.concat( loadedVertices.normals );\n\t\t\t\t\t\t\t\tmesh.vertices = mesh.vertices.concat( loadedVertices.vertices );\n\n\t\t\t\t\t\t\t} else if ( currMeshNode.nodeName === 'volume' ) {\n\n\t\t\t\t\t\t\t\tmesh.volumes.push( loadMeshVolume( currMeshNode ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcurrMeshNode = currMeshNode.nextElementSibling;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tloadedObject.meshes.push( mesh );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrObjNode = currObjNode.nextElementSibling;\n\n\t\t\t\t}\n\n\t\t\t\treturn { 'id': objId, 'obj': loadedObject };\n\n\t\t\t}\n\n\t\t\tvar xmlData = loadDocument( data );\n\t\t\tvar amfName = '';\n\t\t\tvar amfAuthor = '';\n\t\t\tvar amfScale = loadDocumentScale( xmlData );\n\t\t\tvar amfMaterials = {};\n\t\t\tvar amfObjects = {};\n\t\t\tvar childNodes = xmlData.documentElement.childNodes;\n\n\t\t\tvar i, j;\n\n\t\t\tfor ( i = 0; i < childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = childNodes[ i ];\n\n\t\t\t\tif ( child.nodeName === 'metadata' ) {\n\n\t\t\t\t\tif ( child.attributes.type !== undefined ) {\n\n\t\t\t\t\t\tif ( child.attributes.type.value === 'name' ) {\n\n\t\t\t\t\t\t\tamfName = child.textContent;\n\n\t\t\t\t\t\t} else if ( child.attributes.type.value === 'author' ) {\n\n\t\t\t\t\t\t\tamfAuthor = child.textContent;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( child.nodeName === 'material' ) {\n\n\t\t\t\t\tvar loadedMaterial = loadMaterials( child );\n\n\t\t\t\t\tamfMaterials[ loadedMaterial.id ] = loadedMaterial.material;\n\n\t\t\t\t} else if ( child.nodeName === 'object' ) {\n\n\t\t\t\t\tvar loadedObject = loadObject( child );\n\n\t\t\t\t\tamfObjects[ loadedObject.id ] = loadedObject.obj;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar sceneObject = new THREE.Group();\n\t\t\tvar defaultMaterial = new THREE.MeshPhongMaterial( { color: 0xaaaaff, flatShading: true } );\n\n\t\t\tsceneObject.name = amfName;\n\t\t\tsceneObject.userData.author = amfAuthor;\n\t\t\tsceneObject.userData.loader = 'AMF';\n\n\t\t\tfor ( var id in amfObjects ) {\n\n\t\t\t\tvar part = amfObjects[ id ];\n\t\t\t\tvar meshes = part.meshes;\n\t\t\t\tvar newObject = new THREE.Group();\n\t\t\t\tnewObject.name = part.name || '';\n\n\t\t\t\tfor ( i = 0; i < meshes.length; i ++ ) {\n\n\t\t\t\t\tvar objDefaultMaterial = defaultMaterial;\n\t\t\t\t\tvar mesh = meshes[ i ];\n\t\t\t\t\tvar vertices = new THREE.Float32BufferAttribute( mesh.vertices, 3 );\n\t\t\t\t\tvar normals = null;\n\n\t\t\t\t\tif ( mesh.normals.length ) {\n\n\t\t\t\t\t\tnormals = new THREE.Float32BufferAttribute( mesh.normals, 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( mesh.color ) {\n\n\t\t\t\t\t\tvar color = mesh.color;\n\n\t\t\t\t\t\tobjDefaultMaterial = defaultMaterial.clone();\n\t\t\t\t\t\tobjDefaultMaterial.color = new THREE.Color( color.r, color.g, color.b );\n\n\t\t\t\t\t\tif ( color.a !== 1.0 ) {\n\n\t\t\t\t\t\t\tobjDefaultMaterial.transparent = true;\n\t\t\t\t\t\t\tobjDefaultMaterial.opacity = color.a;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar volumes = mesh.volumes;\n\n\t\t\t\t\tfor ( j = 0; j < volumes.length; j ++ ) {\n\n\t\t\t\t\t\tvar volume = volumes[ j ];\n\t\t\t\t\t\tvar newGeometry = new THREE.BufferGeometry();\n\t\t\t\t\t\tvar material = objDefaultMaterial;\n\n\t\t\t\t\t\tnewGeometry.setIndex( volume.triangles );\n\t\t\t\t\t\tnewGeometry.setAttribute( 'position', vertices.clone() );\n\n\t\t\t\t\t\tif ( normals ) {\n\n\t\t\t\t\t\t\tnewGeometry.setAttribute( 'normal', normals.clone() );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( amfMaterials[ volume.materialId ] !== undefined ) {\n\n\t\t\t\t\t\t\tmaterial = amfMaterials[ volume.materialId ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnewGeometry.scale( amfScale, amfScale, amfScale );\n\t\t\t\t\t\tnewObject.add( new THREE.Mesh( newGeometry, material.clone() ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tsceneObject.add( newObject );\n\n\t\t\t}\n\n\t\t\treturn sceneObject;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.AMFLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/AssimpLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Virtulous / https://virtulo.us/\n\t */\n\n\tTHREE.AssimpLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.AssimpLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.AssimpLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( scope.path === '' ) ? THREE.LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tonLoad( scope.parse( buffer, path ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( buffer, path ) {\n\n\t\t\tvar textureLoader = new THREE.TextureLoader( this.manager );\n\t\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar Virtulous = {};\n\n\t\t\tVirtulous.KeyFrame = function ( time, matrix ) {\n\n\t\t\t\tthis.time = time;\n\t\t\t\tthis.matrix = matrix.clone();\n\t\t\t\tthis.position = new THREE.Vector3();\n\t\t\t\tthis.quaternion = new THREE.Quaternion();\n\t\t\t\tthis.scale = new THREE.Vector3( 1, 1, 1 );\n\t\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\t\t\t\tthis.clone = function () {\n\n\t\t\t\t\tvar n = new Virtulous.KeyFrame( this.time, this.matrix );\n\t\t\t\t\treturn n;\n\n\t\t\t\t};\n\t\t\t\tthis.lerp = function ( nextKey, time ) {\n\n\t\t\t\t\ttime -= this.time;\n\t\t\t\t\tvar dist = ( nextKey.time - this.time );\n\t\t\t\t\tvar l = time / dist;\n\t\t\t\t\tvar l2 = 1 - l;\n\t\t\t\t\tvar keypos = this.position;\n\t\t\t\t\tvar keyrot = this.quaternion;\n\t\t\t\t\t//      var keyscl =  key.parentspaceScl || key.scl;\n\t\t\t\t\tvar key2pos = nextKey.position;\n\t\t\t\t\tvar key2rot = nextKey.quaternion;\n\t\t\t\t\t//  var key2scl =  key2.parentspaceScl || key2.scl;\n\t\t\t\t\tVirtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n\t\t\t\t\tVirtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n\t\t\t\t\tVirtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;\n\t\t\t\t\t//     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\n\t\t\t\t\t//     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\n\t\t\t\t\t//     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\n\t\t\t\t\tVirtulous.KeyFrame.tempAniQuat.set( keyrot.x, keyrot.y, keyrot.z, keyrot.w );\n\t\t\t\t\tVirtulous.KeyFrame.tempAniQuat.slerp( key2rot, l );\n\t\t\t\t\treturn Virtulous.KeyFrame.tempAniMatrix.compose( Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale );\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t\tVirtulous.KeyFrame.tempAniPos = new THREE.Vector3();\n\t\t\tVirtulous.KeyFrame.tempAniQuat = new THREE.Quaternion();\n\t\t\tVirtulous.KeyFrame.tempAniScale = new THREE.Vector3( 1, 1, 1 );\n\t\t\tVirtulous.KeyFrame.tempAniMatrix = new THREE.Matrix4();\n\t\t\tVirtulous.KeyFrameTrack = function () {\n\n\t\t\t\tthis.keys = [];\n\t\t\t\tthis.target = null;\n\t\t\t\tthis.time = 0;\n\t\t\t\tthis.length = 0;\n\t\t\t\tthis._accelTable = {};\n\t\t\t\tthis.fps = 20;\n\t\t\t\tthis.addKey = function ( key ) {\n\n\t\t\t\t\tthis.keys.push( key );\n\n\t\t\t\t};\n\t\t\t\tthis.init = function () {\n\n\t\t\t\t\tthis.sortKeys();\n\n\t\t\t\t\tif ( this.keys.length > 0 )\n\t\t\t\t\t\tthis.length = this.keys[ this.keys.length - 1 ].time;\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.length = 0;\n\n\t\t\t\t\tif ( ! this.fps ) return;\n\n\t\t\t\t\tfor ( var j = 0; j < this.length * this.fps; j ++ ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < this.keys.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( this.keys[ i ].time == j ) {\n\n\t\t\t\t\t\t\t\tthis._accelTable[ j ] = i;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t} else if ( this.keys[ i ].time < j / this.fps && this.keys[ i + 1 ] && this.keys[ i + 1 ].time >= j / this.fps ) {\n\n\t\t\t\t\t\t\t\tthis._accelTable[ j ] = i;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tthis.parseFromThree = function ( data ) {\n\n\t\t\t\t\tvar fps = data.fps;\n\t\t\t\t\tthis.target = data.node;\n\t\t\t\t\tvar track = data.hierarchy[ 0 ].keys;\n\t\t\t\t\tfor ( var i = 0; i < track.length; i ++ ) {\n\n\t\t\t\t\t\tthis.addKey( new Virtulous.KeyFrame( i / fps || track[ i ].time, track[ i ].targets[ 0 ].data ) );\n\n\t\t\t\t\t}\n\t\t\t\t\tthis.init();\n\n\t\t\t\t};\n\n\t\t\t\tthis.parseFromCollada = function ( data ) {\n\n\t\t\t\t\tvar track = data.keys;\n\t\t\t\t\tvar fps = this.fps;\n\n\t\t\t\t\tfor ( var i = 0; i < track.length; i ++ ) {\n\n\t\t\t\t\t\tthis.addKey( new Virtulous.KeyFrame( i / fps || track[ i ].time, track[ i ].matrix ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.init();\n\n\t\t\t\t};\n\n\t\t\t\tthis.sortKeys = function () {\n\n\t\t\t\t\tthis.keys.sort( this.keySortFunc );\n\n\t\t\t\t};\n\n\t\t\t\tthis.keySortFunc = function ( a, b ) {\n\n\t\t\t\t\treturn a.time - b.time;\n\n\t\t\t\t};\n\n\t\t\t\tthis.clone = function () {\n\n\t\t\t\t\tvar t = new Virtulous.KeyFrameTrack();\n\t\t\t\t\tt.target = this.target;\n\t\t\t\t\tt.time = this.time;\n\t\t\t\t\tt.length = this.length;\n\n\t\t\t\t\tfor ( var i = 0; i < this.keys.length; i ++ ) {\n\n\t\t\t\t\t\tt.addKey( this.keys[ i ].clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tt.init();\n\t\t\t\t\treturn t;\n\n\t\t\t\t};\n\n\t\t\t\tthis.reTarget = function ( root, compareitor ) {\n\n\t\t\t\t\tif ( ! compareitor ) compareitor = Virtulous.TrackTargetNodeNameCompare;\n\t\t\t\t\tthis.target = compareitor( root, this.target );\n\n\t\t\t\t};\n\n\t\t\t\tthis.keySearchAccel = function ( time ) {\n\n\t\t\t\t\ttime *= this.fps;\n\t\t\t\t\ttime = Math.floor( time );\n\t\t\t\t\treturn this._accelTable[ time ] || 0;\n\n\t\t\t\t};\n\n\t\t\t\tthis.setTime = function ( time ) {\n\n\t\t\t\t\ttime = Math.abs( time );\n\t\t\t\t\tif ( this.length )\n\t\t\t\t\t\ttime = time % this.length + .05;\n\t\t\t\t\tvar key0 = null;\n\t\t\t\t\tvar key1 = null;\n\n\t\t\t\t\tfor ( var i = this.keySearchAccel( time ); i < this.keys.length; i ++ ) {\n\n\t\t\t\t\t\tif ( this.keys[ i ].time == time ) {\n\n\t\t\t\t\t\t\tkey0 = this.keys[ i ];\n\t\t\t\t\t\t\tkey1 = this.keys[ i ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if ( this.keys[ i ].time < time && this.keys[ i + 1 ] && this.keys[ i + 1 ].time > time ) {\n\n\t\t\t\t\t\t\tkey0 = this.keys[ i ];\n\t\t\t\t\t\t\tkey1 = this.keys[ i + 1 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if ( this.keys[ i ].time < time && i == this.keys.length - 1 ) {\n\n\t\t\t\t\t\t\tkey0 = this.keys[ i ];\n\t\t\t\t\t\t\tkey1 = this.keys[ 0 ].clone();\n\t\t\t\t\t\t\tkey1.time += this.length + .05;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( key0 && key1 && key0 !== key1 ) {\n\n\t\t\t\t\t\tthis.target.matrixAutoUpdate = false;\n\t\t\t\t\t\tthis.target.matrix.copy( key0.lerp( key1, time ) );\n\t\t\t\t\t\tthis.target.matrixWorldNeedsUpdate = true;\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( key0 && key1 && key0 == key1 ) {\n\n\t\t\t\t\t\tthis.target.matrixAutoUpdate = false;\n\t\t\t\t\t\tthis.target.matrix.copy( key0.matrix );\n\t\t\t\t\t\tthis.target.matrixWorldNeedsUpdate = true;\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t\tVirtulous.TrackTargetNodeNameCompare = function ( root, target ) {\n\n\t\t\t\tfunction find( node, name ) {\n\n\t\t\t\t\tif ( node.name == name )\n\t\t\t\t\t\treturn node;\n\n\t\t\t\t\tfor ( var i = 0; i < node.children.length; i ++ ) {\n\n\t\t\t\t\t\tvar r = find( node.children[ i ], name );\n\t\t\t\t\t\tif ( r ) return r;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\treturn find( root, target.name );\n\n\t\t\t};\n\n\t\t\tVirtulous.Animation = function () {\n\n\t\t\t\tthis.tracks = [];\n\t\t\t\tthis.length = 0;\n\n\t\t\t\tthis.addTrack = function ( track ) {\n\n\t\t\t\t\tthis.tracks.push( track );\n\t\t\t\t\tthis.length = Math.max( track.length, this.length );\n\n\t\t\t\t};\n\n\t\t\t\tthis.setTime = function ( time ) {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ )\n\t\t\t\t\t\tthis.tracks[ i ].setTime( time );\n\n\t\t\t\t};\n\n\t\t\t\tthis.clone = function ( target, compareitor ) {\n\n\t\t\t\t\tif ( ! compareitor ) compareitor = Virtulous.TrackTargetNodeNameCompare;\n\t\t\t\t\tvar n = new Virtulous.Animation();\n\t\t\t\t\tn.target = target;\n\t\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\t\t\t\tvar track = this.tracks[ i ].clone();\n\t\t\t\t\t\ttrack.reTarget( target, compareitor );\n\t\t\t\t\t\tn.addTrack( track );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn n;\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t\tvar ASSBIN_CHUNK_AICAMERA = 0x1234;\n\t\t\tvar ASSBIN_CHUNK_AILIGHT = 0x1235;\n\t\t\tvar ASSBIN_CHUNK_AITEXTURE = 0x1236;\n\t\t\tvar ASSBIN_CHUNK_AIMESH = 0x1237;\n\t\t\tvar ASSBIN_CHUNK_AINODEANIM = 0x1238;\n\t\t\tvar ASSBIN_CHUNK_AISCENE = 0x1239;\n\t\t\tvar ASSBIN_CHUNK_AIBONE = 0x123a;\n\t\t\tvar ASSBIN_CHUNK_AIANIMATION = 0x123b;\n\t\t\tvar ASSBIN_CHUNK_AINODE = 0x123c;\n\t\t\tvar ASSBIN_CHUNK_AIMATERIAL = 0x123d;\n\t\t\tvar ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;\n\t\t\tvar ASSBIN_MESH_HAS_POSITIONS = 0x1;\n\t\t\tvar ASSBIN_MESH_HAS_NORMALS = 0x2;\n\t\t\tvar ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;\n\t\t\tvar ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;\n\t\t\tvar ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;\n\t\t\tvar AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n\t\t\tvar AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;\n\t\t\t//var aiLightSource_UNDEFINED = 0x0;\n\t\t\t//! A directional light source has a well-defined direction\n\t\t\t//! but is infinitely far away. That's quite a good\n\t\t\t//! approximation for sun light.\n\t\t\tvar aiLightSource_DIRECTIONAL = 0x1;\n\t\t\t//! A point light source has a well-defined position\n\t\t\t//! in space but no direction - it emits light in all\n\t\t\t//! directions. A normal bulb is a point light.\n\t\t\t//var aiLightSource_POINT = 0x2;\n\t\t\t//! A spot light source emits light in a specific\n\t\t\t//! angle. It has a position and a direction it is pointing to.\n\t\t\t//! A good example for a spot light is a light spot in\n\t\t\t//! sport arenas.\n\t\t\tvar aiLightSource_SPOT = 0x3;\n\t\t\t//! The generic light level of the world, including the bounces\n\t\t\t//! of all other lightsources.\n\t\t\t//! Typically, there's at most one ambient light in a scene.\n\t\t\t//! This light type doesn't have a valid position, direction, or\n\t\t\t//! other properties, just a color.\n\t\t\t//var aiLightSource_AMBIENT = 0x4;\n\t\t\t/** Flat shading. Shading is done on per-face base,\n\t\t\t *  diffuse only. Also known as 'faceted shading'.\n\t\t\t */\n\t\t\t//var aiShadingMode_Flat = 0x1;\n\t\t\t/** Simple Gouraud shading.\n\t\t\t */\n\t\t\t//var aiShadingMode_Gouraud = 0x2;\n\t\t\t/** Phong-Shading -\n\t\t\t */\n\t\t\t//var aiShadingMode_Phong = 0x3;\n\t\t\t/** Phong-Blinn-Shading\n\t\t\t */\n\t\t\t//var aiShadingMode_Blinn = 0x4;\n\t\t\t/** Toon-Shading per pixel\n\t\t\t *\n\t\t\t *  Also known as 'comic' shader.\n\t\t\t */\n\t\t\t//var aiShadingMode_Toon = 0x5;\n\t\t\t/** OrenNayar-Shading per pixel\n\t\t\t *\n\t\t\t *  Extension to standard Lambertian shading, taking the\n\t\t\t *  roughness of the material into account\n\t\t\t */\n\t\t\t//var aiShadingMode_OrenNayar = 0x6;\n\t\t\t/** Minnaert-Shading per pixel\n\t\t\t *\n\t\t\t *  Extension to standard Lambertian shading, taking the\n\t\t\t *  \"darkness\" of the material into account\n\t\t\t */\n\t\t\t//var aiShadingMode_Minnaert = 0x7;\n\t\t\t/** CookTorrance-Shading per pixel\n\t\t\t *\n\t\t\t *  Special shader for metallic surfaces.\n\t\t\t */\n\t\t\t//var aiShadingMode_CookTorrance = 0x8;\n\t\t\t/** No shading at all. Constant light influence of 1.0.\n\t\t\t */\n\t\t\t//var aiShadingMode_NoShading = 0x9;\n\t\t\t/** Fresnel shading\n\t\t\t */\n\t\t\t//var aiShadingMode_Fresnel = 0xa;\n\t\t\t//var aiTextureType_NONE = 0x0;\n\t\t\t/** The texture is combined with the result of the diffuse\n\t\t\t *  lighting equation.\n\t\t\t */\n\t\t\tvar aiTextureType_DIFFUSE = 0x1;\n\t\t\t/** The texture is combined with the result of the specular\n\t\t\t *  lighting equation.\n\t\t\t */\n\t\t\t//var aiTextureType_SPECULAR = 0x2;\n\t\t\t/** The texture is combined with the result of the ambient\n\t\t\t *  lighting equation.\n\t\t\t */\n\t\t\t//var aiTextureType_AMBIENT = 0x3;\n\t\t\t/** The texture is added to the result of the lighting\n\t\t\t *  calculation. It isn't influenced by incoming light.\n\t\t\t */\n\t\t\t//var aiTextureType_EMISSIVE = 0x4;\n\t\t\t/** The texture is a height map.\n\t\t\t *\n\t\t\t *  By convention, higher gray-scale values stand for\n\t\t\t *  higher elevations from the base height.\n\t\t\t */\n\t\t\t//var aiTextureType_HEIGHT = 0x5;\n\t\t\t/** The texture is a (tangent space) normal-map.\n\t\t\t *\n\t\t\t *  Again, there are several conventions for tangent-space\n\t\t\t *  normal maps. Assimp does (intentionally) not\n\t\t\t *  distinguish here.\n\t\t\t */\n\t\t\tvar aiTextureType_NORMALS = 0x6;\n\t\t\t/** The texture defines the glossiness of the material.\n\t\t\t *\n\t\t\t *  The glossiness is in fact the exponent of the specular\n\t\t\t *  (phong) lighting equation. Usually there is a conversion\n\t\t\t *  function defined to map the linear color values in the\n\t\t\t *  texture to a suitable exponent. Have fun.\n\t\t\t */\n\t\t\t//var aiTextureType_SHININESS = 0x7;\n\t\t\t/** The texture defines per-pixel opacity.\n\t\t\t *\n\t\t\t *  Usually 'white' means opaque and 'black' means\n\t\t\t *  'transparency'. Or quite the opposite. Have fun.\n\t\t\t */\n\t\t\tvar aiTextureType_OPACITY = 0x8;\n\t\t\t/** Displacement texture\n\t\t\t *\n\t\t\t *  The exact purpose and format is application-dependent.\n\t\t\t *  Higher color values stand for higher vertex displacements.\n\t\t\t */\n\t\t\t//var aiTextureType_DISPLACEMENT = 0x9;\n\t\t\t/** Lightmap texture (aka Ambient Occlusion)\n\t\t\t *\n\t\t\t *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n\t\t\t *  covered by this material property. The texture contains a\n\t\t\t *  scaling value for the final color value of a pixel. Its\n\t\t\t *  intensity is not affected by incoming light.\n\t\t\t */\n\t\t\tvar aiTextureType_LIGHTMAP = 0xA;\n\t\t\t/** Reflection texture\n\t\t\t *\n\t\t\t * Contains the color of a perfect mirror reflection.\n\t\t\t * Rarely used, almost never for real-time applications.\n\t\t\t */\n\t\t\t//var aiTextureType_REFLECTION = 0xB;\n\t\t\t/** Unknown texture\n\t\t\t *\n\t\t\t *  A texture reference that does not match any of the definitions\n\t\t\t *  above is considered to be 'unknown'. It is still imported,\n\t\t\t *  but is excluded from any further postprocessing.\n\t\t\t */\n\t\t\t//var aiTextureType_UNKNOWN = 0xC;\n\t\t\tvar BONESPERVERT = 4;\n\n\t\t\tfunction ASSBIN_MESH_HAS_TEXCOORD( n ) {\n\n\t\t\t\treturn ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n\n\t\t\t}\n\n\t\t\tfunction ASSBIN_MESH_HAS_COLOR( n ) {\n\n\t\t\t\treturn ASSBIN_MESH_HAS_COLOR_BASE << n;\n\n\t\t\t}\n\n\t\t\tfunction markBones( scene ) {\n\n\t\t\t\tfor ( var i in scene.mMeshes ) {\n\n\t\t\t\t\tvar mesh = scene.mMeshes[ i ];\n\t\t\t\t\tfor ( var k in mesh.mBones ) {\n\n\t\t\t\t\t\tvar boneNode = scene.findNode( mesh.mBones[ k ].mName );\n\t\t\t\t\t\tif ( boneNode )\n\t\t\t\t\t\t\tboneNode.isBone = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfunction cloneTreeToBones( root, scene ) {\n\n\t\t\t\tvar rootBone = new THREE.Bone();\n\t\t\t\trootBone.matrix.copy( root.matrix );\n\t\t\t\trootBone.matrixWorld.copy( root.matrixWorld );\n\t\t\t\trootBone.position.copy( root.position );\n\t\t\t\trootBone.quaternion.copy( root.quaternion );\n\t\t\t\trootBone.scale.copy( root.scale );\n\t\t\t\tscene.nodeCount ++;\n\t\t\t\trootBone.name = \"bone_\" + root.name + scene.nodeCount.toString();\n\n\t\t\t\tif ( ! scene.nodeToBoneMap[ root.name ] )\n\t\t\t\t\tscene.nodeToBoneMap[ root.name ] = [];\n\t\t\t\tscene.nodeToBoneMap[ root.name ].push( rootBone );\n\t\t\t\tfor ( var i in root.children ) {\n\n\t\t\t\t\tvar child = cloneTreeToBones( root.children[ i ], scene );\n\t\t\t\t\trootBone.add( child );\n\n\t\t\t\t}\n\n\t\t\t\treturn rootBone;\n\n\t\t\t}\n\n\t\t\tfunction sortWeights( indexes, weights ) {\n\n\t\t\t\tvar pairs = [];\n\n\t\t\t\tfor ( var i = 0; i < indexes.length; i ++ ) {\n\n\t\t\t\t\tpairs.push( {\n\t\t\t\t\t\ti: indexes[ i ],\n\t\t\t\t\t\tw: weights[ i ]\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tpairs.sort( function ( a, b ) {\n\n\t\t\t\t\treturn b.w - a.w;\n\n\t\t\t\t } );\n\n\t\t\t\twhile ( pairs.length < 4 ) {\n\n\t\t\t\t\tpairs.push( {\n\t\t\t\t\t\ti: 0,\n\t\t\t\t\t\tw: 0\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tif ( pairs.length > 4 )\n\t\t\t\t\tpairs.length = 4;\n\t\t\t\tvar sum = 0;\n\n\t\t\t\tfor ( var i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tsum += pairs[ i ].w * pairs[ i ].w;\n\n\t\t\t\t}\n\n\t\t\t\tsum = Math.sqrt( sum );\n\n\t\t\t\tfor ( var i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tpairs[ i ].w = pairs[ i ].w / sum;\n\t\t\t\t\tindexes[ i ] = pairs[ i ].i;\n\t\t\t\t\tweights[ i ] = pairs[ i ].w;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction findMatchingBone( root, name ) {\n\n\t\t\t\tif ( root.name.indexOf( \"bone_\" + name ) == 0 )\n\t\t\t\t\treturn root;\n\n\t\t\t\tfor ( var i in root.children ) {\n\n\t\t\t\t\tvar ret = findMatchingBone( root.children[ i ], name );\n\n\t\t\t\t\tif ( ret )\n\t\t\t\t\t\treturn ret;\n\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\tfunction aiMesh() {\n\n\t\t\t\tthis.mPrimitiveTypes = 0;\n\t\t\t\tthis.mNumVertices = 0;\n\t\t\t\tthis.mNumFaces = 0;\n\t\t\t\tthis.mNumBones = 0;\n\t\t\t\tthis.mMaterialIndex = 0;\n\t\t\t\tthis.mVertices = [];\n\t\t\t\tthis.mNormals = [];\n\t\t\t\tthis.mTangents = [];\n\t\t\t\tthis.mBitangents = [];\n\t\t\t\tthis.mColors = [\n\t\t\t\t\t[]\n\t\t\t\t];\n\t\t\t\tthis.mTextureCoords = [\n\t\t\t\t\t[]\n\t\t\t\t];\n\t\t\t\tthis.mFaces = [];\n\t\t\t\tthis.mBones = [];\n\t\t\t\tthis.hookupSkeletons = function ( scene ) {\n\n\t\t\t\t\tif ( this.mBones.length == 0 ) return;\n\n\t\t\t\t\tvar allBones = [];\n\t\t\t\t\tvar offsetMatrix = [];\n\t\t\t\t\tvar skeletonRoot = scene.findNode( this.mBones[ 0 ].mName );\n\n\t\t\t\t\twhile ( skeletonRoot.mParent && skeletonRoot.mParent.isBone ) {\n\n\t\t\t\t\t\tskeletonRoot = skeletonRoot.mParent;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar threeSkeletonRoot = skeletonRoot.toTHREE( scene );\n\t\t\t\t\tvar threeSkeletonRootBone = cloneTreeToBones( threeSkeletonRoot, scene );\n\t\t\t\t\tthis.threeNode.add( threeSkeletonRootBone );\n\n\t\t\t\t\tfor ( var i = 0; i < this.mBones.length; i ++ ) {\n\n\t\t\t\t\t\tvar bone = findMatchingBone( threeSkeletonRootBone, this.mBones[ i ].mName );\n\n\t\t\t\t\t\tif ( bone ) {\n\n\t\t\t\t\t\t\tvar tbone = bone;\n\t\t\t\t\t\t\tallBones.push( tbone );\n\t\t\t\t\t\t\t//tbone.matrixAutoUpdate = false;\n\t\t\t\t\t\t\toffsetMatrix.push( this.mBones[ i ].mOffsetMatrix.toTHREE() );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar skeletonRoot = scene.findNode( this.mBones[ i ].mName );\n\t\t\t\t\t\t\tif ( ! skeletonRoot ) return;\n\t\t\t\t\t\t\tvar threeSkeletonRoot = skeletonRoot.toTHREE( scene );\n\t\t\t\t\t\t\tvar threeSkeletonRootBone = cloneTreeToBones( threeSkeletonRoot, scene );\n\t\t\t\t\t\t\tthis.threeNode.add( threeSkeletonRootBone );\n\t\t\t\t\t\t\tvar bone = findMatchingBone( threeSkeletonRootBone, this.mBones[ i ].mName );\n\t\t\t\t\t\t\tvar tbone = bone;\n\t\t\t\t\t\t\tallBones.push( tbone );\n\t\t\t\t\t\t\t//tbone.matrixAutoUpdate = false;\n\t\t\t\t\t\t\toffsetMatrix.push( this.mBones[ i ].mOffsetMatrix.toTHREE() );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tvar skeleton = new THREE.Skeleton( allBones, offsetMatrix );\n\n\t\t\t\t\tthis.threeNode.bind( skeleton, new THREE.Matrix4() );\n\t\t\t\t\tthis.threeNode.material.skinning = true;\n\n\t\t\t\t};\n\n\t\t\t\tthis.toTHREE = function ( scene ) {\n\n\t\t\t\t\tif ( this.threeNode ) return this.threeNode;\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\t\tvar mat;\n\t\t\t\t\tif ( scene.mMaterials[ this.mMaterialIndex ] )\n\t\t\t\t\t\tmat = scene.mMaterials[ this.mMaterialIndex ].toTHREE( scene );\n\t\t\t\t\telse\n\t\t\t\t\t\tmat = new THREE.MeshLambertMaterial();\n\t\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( new Uint32Array( this.mIndexArray ), 1 ) );\n\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( this.mVertexBuffer, 3 ) );\n\t\t\t\t\tif ( this.mNormalBuffer && this.mNormalBuffer.length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'normal', new THREE.BufferAttribute( this.mNormalBuffer, 3 ) );\n\t\t\t\t\tif ( this.mColorBuffer && this.mColorBuffer.length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.BufferAttribute( this.mColorBuffer, 4 ) );\n\t\t\t\t\tif ( this.mTexCoordsBuffers[ 0 ] && this.mTexCoordsBuffers[ 0 ].length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( this.mTexCoordsBuffers[ 0 ] ), 2 ) );\n\t\t\t\t\tif ( this.mTexCoordsBuffers[ 1 ] && this.mTexCoordsBuffers[ 1 ].length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'uv1', new THREE.BufferAttribute( new Float32Array( this.mTexCoordsBuffers[ 1 ] ), 2 ) );\n\t\t\t\t\tif ( this.mTangentBuffer && this.mTangentBuffer.length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'tangents', new THREE.BufferAttribute( this.mTangentBuffer, 3 ) );\n\t\t\t\t\tif ( this.mBitangentBuffer && this.mBitangentBuffer.length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'bitangents', new THREE.BufferAttribute( this.mBitangentBuffer, 3 ) );\n\t\t\t\t\tif ( this.mBones.length > 0 ) {\n\n\t\t\t\t\t\tvar weights = [];\n\t\t\t\t\t\tvar bones = [];\n\n\t\t\t\t\t\tfor ( var i = 0; i < this.mBones.length; i ++ ) {\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < this.mBones[ i ].mWeights.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar weight = this.mBones[ i ].mWeights[ j ];\n\t\t\t\t\t\t\t\tif ( weight ) {\n\n\t\t\t\t\t\t\t\t\tif ( ! weights[ weight.mVertexId ] ) weights[ weight.mVertexId ] = [];\n\t\t\t\t\t\t\t\t\tif ( ! bones[ weight.mVertexId ] ) bones[ weight.mVertexId ] = [];\n\t\t\t\t\t\t\t\t\tweights[ weight.mVertexId ].push( weight.mWeight );\n\t\t\t\t\t\t\t\t\tbones[ weight.mVertexId ].push( parseInt( i ) );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( var i in bones ) {\n\n\t\t\t\t\t\t\tsortWeights( bones[ i ], weights[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar _weights = [];\n\t\t\t\t\t\tvar _bones = [];\n\n\t\t\t\t\t\tfor ( var i = 0; i < weights.length; i ++ ) {\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\tif ( weights[ i ] && bones[ i ] ) {\n\n\t\t\t\t\t\t\t\t\t_weights.push( weights[ i ][ j ] );\n\t\t\t\t\t\t\t\t\t_bones.push( bones[ i ][ j ] );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t_weights.push( 0 );\n\t\t\t\t\t\t\t\t\t_bones.push( 0 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.setAttribute( 'skinWeight', new THREE.BufferAttribute( new Float32Array( _weights ), BONESPERVERT ) );\n\t\t\t\t\t\tgeometry.setAttribute( 'skinIndex', new THREE.BufferAttribute( new Float32Array( _bones ), BONESPERVERT ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar mesh;\n\n\t\t\t\t\tif ( this.mBones.length == 0 )\n\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, mat );\n\n\t\t\t\t\tif ( this.mBones.length > 0 ) {\n\n\t\t\t\t\t\tmesh = new THREE.SkinnedMesh( geometry, mat );\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.threeNode = mesh;\n\t\t\t\t\t//mesh.matrixAutoUpdate = false;\n\t\t\t\t\treturn mesh;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiFace() {\n\n\t\t\t\tthis.mNumIndices = 0;\n\t\t\t\tthis.mIndices = [];\n\n\t\t\t}\n\n\t\t\tfunction aiVector3D() {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\treturn new THREE.Vector3( this.x, this.y, this.z );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiColor3D() {\n\n\t\t\t\tthis.r = 0;\n\t\t\t\tthis.g = 0;\n\t\t\t\tthis.b = 0;\n\t\t\t\tthis.a = 0;\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\treturn new THREE.Color( this.r, this.g, this.b );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiQuaternion() {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\t\t\tthis.w = 0;\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\treturn new THREE.Quaternion( this.x, this.y, this.z, this.w );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiVertexWeight() {\n\n\t\t\t\tthis.mVertexId = 0;\n\t\t\t\tthis.mWeight = 0;\n\n\t\t\t}\n\n\t\t\tfunction aiString() {\n\n\t\t\t\tthis.data = [];\n\t\t\t\tthis.toString = function () {\n\n\t\t\t\t\tvar str = '';\n\t\t\t\t\tthis.data.forEach( function ( i ) {\n\n\t\t\t\t\t\tstr += ( String.fromCharCode( i ) );\n\n\t\t\t\t\t} );\n\t\t\t\t\treturn str.replace( /[^\\x20-\\x7E]+/g, '' );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiVectorKey() {\n\n\t\t\t\tthis.mTime = 0;\n\t\t\t\tthis.mValue = null;\n\n\t\t\t}\n\n\t\t\tfunction aiQuatKey() {\n\n\t\t\t\tthis.mTime = 0;\n\t\t\t\tthis.mValue = null;\n\n\t\t\t}\n\n\t\t\tfunction aiNode() {\n\n\t\t\t\tthis.mName = '';\n\t\t\t\tthis.mTransformation = [];\n\t\t\t\tthis.mNumChildren = 0;\n\t\t\t\tthis.mNumMeshes = 0;\n\t\t\t\tthis.mMeshes = [];\n\t\t\t\tthis.mChildren = [];\n\t\t\t\tthis.toTHREE = function ( scene ) {\n\n\t\t\t\t\tif ( this.threeNode ) return this.threeNode;\n\t\t\t\t\tvar o = new THREE.Object3D();\n\t\t\t\t\to.name = this.mName;\n\t\t\t\t\to.matrix = this.mTransformation.toTHREE();\n\n\t\t\t\t\tfor ( var i = 0; i < this.mChildren.length; i ++ ) {\n\n\t\t\t\t\t\to.add( this.mChildren[ i ].toTHREE( scene ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < this.mMeshes.length; i ++ ) {\n\n\t\t\t\t\t\to.add( scene.mMeshes[ this.mMeshes[ i ] ].toTHREE( scene ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.threeNode = o;\n\t\t\t\t\t//o.matrixAutoUpdate = false;\n\t\t\t\t\to.matrix.decompose( o.position, o.quaternion, o.scale );\n\t\t\t\t\treturn o;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiBone() {\n\n\t\t\t\tthis.mName = '';\n\t\t\t\tthis.mNumWeights = 0;\n\t\t\t\tthis.mOffsetMatrix = 0;\n\n\t\t\t}\n\n\t\t\tfunction aiMaterialProperty() {\n\n\t\t\t\tthis.mKey = \"\";\n\t\t\t\tthis.mSemantic = 0;\n\t\t\t\tthis.mIndex = 0;\n\t\t\t\tthis.mData = [];\n\t\t\t\tthis.mDataLength = 0;\n\t\t\t\tthis.mType = 0;\n\t\t\t\tthis.dataAsColor = function () {\n\n\t\t\t\t\tvar array = ( new Uint8Array( this.mData ) ).buffer;\n\t\t\t\t\tvar reader = new DataView( array );\n\t\t\t\t\tvar r = reader.getFloat32( 0, true );\n\t\t\t\t\tvar g = reader.getFloat32( 4, true );\n\t\t\t\t\tvar b = reader.getFloat32( 8, true );\n\t\t\t\t\t//var a = reader.getFloat32(12, true);\n\t\t\t\t\treturn new THREE.Color( r, g, b );\n\n\t\t\t\t};\n\n\t\t\t\tthis.dataAsFloat = function () {\n\n\t\t\t\t\tvar array = ( new Uint8Array( this.mData ) ).buffer;\n\t\t\t\t\tvar reader = new DataView( array );\n\t\t\t\t\tvar r = reader.getFloat32( 0, true );\n\t\t\t\t\treturn r;\n\n\t\t\t\t};\n\n\t\t\t\tthis.dataAsBool = function () {\n\n\t\t\t\t\tvar array = ( new Uint8Array( this.mData ) ).buffer;\n\t\t\t\t\tvar reader = new DataView( array );\n\t\t\t\t\tvar r = reader.getFloat32( 0, true );\n\t\t\t\t\treturn !! r;\n\n\t\t\t\t};\n\n\t\t\t\tthis.dataAsString = function () {\n\n\t\t\t\t\tvar s = new aiString();\n\t\t\t\t\ts.data = this.mData;\n\t\t\t\t\treturn s.toString();\n\n\t\t\t\t};\n\n\t\t\t\tthis.dataAsMap = function () {\n\n\t\t\t\t\tvar s = new aiString();\n\t\t\t\t\ts.data = this.mData;\n\t\t\t\t\tvar path = s.toString();\n\t\t\t\t\tpath = path.replace( /\\\\/g, '/' );\n\n\t\t\t\t\tif ( path.indexOf( '/' ) != - 1 ) {\n\n\t\t\t\t\t\tpath = path.substr( path.lastIndexOf( '/' ) + 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn textureLoader.load( path );\n\n\t\t\t\t};\n\n\t\t\t}\n\t\t\tvar namePropMapping = {\n\n\t\t\t\t\"?mat.name\": \"name\",\n\t\t\t\t\"$mat.shadingm\": \"shading\",\n\t\t\t\t\"$mat.twosided\": \"twoSided\",\n\t\t\t\t\"$mat.wireframe\": \"wireframe\",\n\t\t\t\t\"$clr.ambient\": \"ambient\",\n\t\t\t\t\"$clr.diffuse\": \"color\",\n\t\t\t\t\"$clr.specular\": \"specular\",\n\t\t\t\t\"$clr.emissive\": \"emissive\",\n\t\t\t\t\"$clr.transparent\": \"transparent\",\n\t\t\t\t\"$clr.reflective\": \"reflect\",\n\t\t\t\t\"$mat.shininess\": \"shininess\",\n\t\t\t\t\"$mat.reflectivity\": \"reflectivity\",\n\t\t\t\t\"$mat.refracti\": \"refraction\",\n\t\t\t\t\"$tex.file\": \"map\"\n\n\t\t\t};\n\n\t\t\tvar nameTypeMapping = {\n\n\t\t\t\t\"?mat.name\": \"string\",\n\t\t\t\t\"$mat.shadingm\": \"bool\",\n\t\t\t\t\"$mat.twosided\": \"bool\",\n\t\t\t\t\"$mat.wireframe\": \"bool\",\n\t\t\t\t\"$clr.ambient\": \"color\",\n\t\t\t\t\"$clr.diffuse\": \"color\",\n\t\t\t\t\"$clr.specular\": \"color\",\n\t\t\t\t\"$clr.emissive\": \"color\",\n\t\t\t\t\"$clr.transparent\": \"color\",\n\t\t\t\t\"$clr.reflective\": \"color\",\n\t\t\t\t\"$mat.shininess\": \"float\",\n\t\t\t\t\"$mat.reflectivity\": \"float\",\n\t\t\t\t\"$mat.refracti\": \"float\",\n\t\t\t\t\"$tex.file\": \"map\"\n\n\t\t\t};\n\n\t\t\tfunction aiMaterial() {\n\n\t\t\t\tthis.mNumAllocated = 0;\n\t\t\t\tthis.mNumProperties = 0;\n\t\t\t\tthis.mProperties = [];\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\tvar mat = new THREE.MeshPhongMaterial();\n\n\t\t\t\t\tfor ( var i = 0; i < this.mProperties.length; i ++ ) {\n\n\t\t\t\t\t\tif ( nameTypeMapping[ this.mProperties[ i ].mKey ] == 'float' )\n\t\t\t\t\t\t\tmat[ namePropMapping[ this.mProperties[ i ].mKey ] ] = this.mProperties[ i ].dataAsFloat();\n\t\t\t\t\t\tif ( nameTypeMapping[ this.mProperties[ i ].mKey ] == 'color' )\n\t\t\t\t\t\t\tmat[ namePropMapping[ this.mProperties[ i ].mKey ] ] = this.mProperties[ i ].dataAsColor();\n\t\t\t\t\t\tif ( nameTypeMapping[ this.mProperties[ i ].mKey ] == 'bool' )\n\t\t\t\t\t\t\tmat[ namePropMapping[ this.mProperties[ i ].mKey ] ] = this.mProperties[ i ].dataAsBool();\n\t\t\t\t\t\tif ( nameTypeMapping[ this.mProperties[ i ].mKey ] == 'string' )\n\t\t\t\t\t\t\tmat[ namePropMapping[ this.mProperties[ i ].mKey ] ] = this.mProperties[ i ].dataAsString();\n\t\t\t\t\t\tif ( nameTypeMapping[ this.mProperties[ i ].mKey ] == 'map' ) {\n\n\t\t\t\t\t\t\tvar prop = this.mProperties[ i ];\n\t\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_DIFFUSE )\n\t\t\t\t\t\t\t\tmat.map = this.mProperties[ i ].dataAsMap();\n\t\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_NORMALS )\n\t\t\t\t\t\t\t\tmat.normalMap = this.mProperties[ i ].dataAsMap();\n\t\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_LIGHTMAP )\n\t\t\t\t\t\t\t\tmat.lightMap = this.mProperties[ i ].dataAsMap();\n\t\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_OPACITY )\n\t\t\t\t\t\t\t\tmat.alphaMap = this.mProperties[ i ].dataAsMap();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmat.ambient.r = .53;\n\t\t\t\t\tmat.ambient.g = .53;\n\t\t\t\t\tmat.ambient.b = .53;\n\t\t\t\t\tmat.color.r = 1;\n\t\t\t\t\tmat.color.g = 1;\n\t\t\t\t\tmat.color.b = 1;\n\t\t\t\t\treturn mat;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\n\t\t\tfunction veclerp( v1, v2, l ) {\n\n\t\t\t\tvar v = new THREE.Vector3();\n\t\t\t\tvar lm1 = 1 - l;\n\t\t\t\tv.x = v1.x * l + v2.x * lm1;\n\t\t\t\tv.y = v1.y * l + v2.y * lm1;\n\t\t\t\tv.z = v1.z * l + v2.z * lm1;\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction quatlerp( q1, q2, l ) {\n\n\t\t\t\treturn q1.clone().slerp( q2, 1 - l );\n\n\t\t\t}\n\n\t\t\tfunction sampleTrack( keys, time, lne, lerp ) {\n\n\t\t\t\tif ( keys.length == 1 ) return keys[ 0 ].mValue.toTHREE();\n\n\t\t\t\tvar dist = Infinity;\n\t\t\t\tvar key = null;\n\t\t\t\tvar nextKey = null;\n\n\t\t\t\tfor ( var i = 0; i < keys.length; i ++ ) {\n\n\t\t\t\t\tvar timeDist = Math.abs( keys[ i ].mTime - time );\n\n\t\t\t\t\tif ( timeDist < dist && keys[ i ].mTime <= time ) {\n\n\t\t\t\t\t\tdist = timeDist;\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tnextKey = keys[ i + 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! key ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t} else if ( nextKey ) {\n\n\t\t\t\t\tvar dT = nextKey.mTime - key.mTime;\n\t\t\t\t\tvar T = key.mTime - time;\n\t\t\t\t\tvar l = T / dT;\n\n\t\t\t\t\treturn lerp( key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnextKey = keys[ 0 ].clone();\n\t\t\t\t\tnextKey.mTime += lne;\n\n\t\t\t\t\tvar dT = nextKey.mTime - key.mTime;\n\t\t\t\t\tvar T = key.mTime - time;\n\t\t\t\t\tvar l = T / dT;\n\n\t\t\t\t\treturn lerp( key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction aiNodeAnim() {\n\n\t\t\t\tthis.mNodeName = \"\";\n\t\t\t\tthis.mNumPositionKeys = 0;\n\t\t\t\tthis.mNumRotationKeys = 0;\n\t\t\t\tthis.mNumScalingKeys = 0;\n\t\t\t\tthis.mPositionKeys = [];\n\t\t\t\tthis.mRotationKeys = [];\n\t\t\t\tthis.mScalingKeys = [];\n\t\t\t\tthis.mPreState = \"\";\n\t\t\t\tthis.mPostState = \"\";\n\t\t\t\tthis.init = function ( tps ) {\n\n\t\t\t\t\tif ( ! tps ) tps = 1;\n\n\t\t\t\t\tfunction t( t ) {\n\n\t\t\t\t\t\tt.mTime /= tps;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.mPositionKeys.forEach( t );\n\t\t\t\t\tthis.mRotationKeys.forEach( t );\n\t\t\t\t\tthis.mScalingKeys.forEach( t );\n\n\t\t\t\t};\n\n\t\t\t\tthis.sortKeys = function () {\n\n\t\t\t\t\tfunction comp( a, b ) {\n\n\t\t\t\t\t\treturn a.mTime - b.mTime;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.mPositionKeys.sort( comp );\n\t\t\t\t\tthis.mRotationKeys.sort( comp );\n\t\t\t\t\tthis.mScalingKeys.sort( comp );\n\n\t\t\t\t};\n\n\t\t\t\tthis.getLength = function () {\n\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\tMath.max.apply( null, this.mPositionKeys.map( function ( a ) {\n\n\t\t\t\t\t\t\treturn a.mTime;\n\n\t\t\t\t\t\t} ) ),\n\t\t\t\t\t\tMath.max.apply( null, this.mRotationKeys.map( function ( a ) {\n\n\t\t\t\t\t\t\treturn a.mTime;\n\n\t\t\t\t\t\t} ) ),\n\t\t\t\t\t\tMath.max.apply( null, this.mScalingKeys.map( function ( a ) {\n\n\t\t\t\t\t\t\treturn a.mTime;\n\n\t\t\t\t\t } ) )\n\t\t\t\t\t);\n\n\t\t\t\t};\n\n\t\t\t\tthis.toTHREE = function ( o ) {\n\n\t\t\t\t\tthis.sortKeys();\n\t\t\t\t\tvar length = this.getLength();\n\t\t\t\t\tvar track = new Virtulous.KeyFrameTrack();\n\n\t\t\t\t\tfor ( var i = 0; i < length; i += .05 ) {\n\n\t\t\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\t\t\tvar time = i;\n\t\t\t\t\t\tvar pos = sampleTrack( this.mPositionKeys, time, length, veclerp );\n\t\t\t\t\t\tvar scale = sampleTrack( this.mScalingKeys, time, length, veclerp );\n\t\t\t\t\t\tvar rotation = sampleTrack( this.mRotationKeys, time, length, quatlerp );\n\t\t\t\t\t\tmatrix.compose( pos, rotation, scale );\n\n\t\t\t\t\t\tvar key = new Virtulous.KeyFrame( time, matrix );\n\t\t\t\t\t\ttrack.addKey( key );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttrack.target = o.findNode( this.mNodeName ).toTHREE();\n\n\t\t\t\t\tvar tracks = [ track ];\n\n\t\t\t\t\tif ( o.nodeToBoneMap[ this.mNodeName ] ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < o.nodeToBoneMap[ this.mNodeName ].length; i ++ ) {\n\n\t\t\t\t\t\t\tvar t2 = track.clone();\n\t\t\t\t\t\t\tt2.target = o.nodeToBoneMap[ this.mNodeName ][ i ];\n\t\t\t\t\t\t\ttracks.push( t2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tracks;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiAnimation() {\n\n\t\t\t\tthis.mName = \"\";\n\t\t\t\tthis.mDuration = 0;\n\t\t\t\tthis.mTicksPerSecond = 0;\n\t\t\t\tthis.mNumChannels = 0;\n\t\t\t\tthis.mChannels = [];\n\t\t\t\tthis.toTHREE = function ( root ) {\n\n\t\t\t\t\tvar animationHandle = new Virtulous.Animation();\n\n\t\t\t\t\tfor ( var i in this.mChannels ) {\n\n\t\t\t\t\t\tthis.mChannels[ i ].init( this.mTicksPerSecond );\n\n\t\t\t\t\t\tvar tracks = this.mChannels[ i ].toTHREE( root );\n\n\t\t\t\t\t\tfor ( var j in tracks ) {\n\n\t\t\t\t\t\t\ttracks[ j ].init();\n\t\t\t\t\t\t\tanimationHandle.addTrack( tracks[ j ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationHandle.length = Math.max.apply( null, animationHandle.tracks.map( function ( e ) {\n\n\t\t\t\t\t\treturn e.length;\n\n\t\t\t\t\t} ) );\n\t\t\t\t\treturn animationHandle;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiTexture() {\n\n\t\t\t\tthis.mWidth = 0;\n\t\t\t\tthis.mHeight = 0;\n\t\t\t\tthis.texAchFormatHint = [];\n\t\t\t\tthis.pcData = [];\n\n\t\t\t}\n\n\t\t\tfunction aiLight() {\n\n\t\t\t\tthis.mName = '';\n\t\t\t\tthis.mType = 0;\n\t\t\t\tthis.mAttenuationConstant = 0;\n\t\t\t\tthis.mAttenuationLinear = 0;\n\t\t\t\tthis.mAttenuationQuadratic = 0;\n\t\t\t\tthis.mAngleInnerCone = 0;\n\t\t\t\tthis.mAngleOuterCone = 0;\n\t\t\t\tthis.mColorDiffuse = null;\n\t\t\t\tthis.mColorSpecular = null;\n\t\t\t\tthis.mColorAmbient = null;\n\n\t\t\t}\n\n\t\t\tfunction aiCamera() {\n\n\t\t\t\tthis.mName = '';\n\t\t\t\tthis.mPosition = null;\n\t\t\t\tthis.mLookAt = null;\n\t\t\t\tthis.mUp = null;\n\t\t\t\tthis.mHorizontalFOV = 0;\n\t\t\t\tthis.mClipPlaneNear = 0;\n\t\t\t\tthis.mClipPlaneFar = 0;\n\t\t\t\tthis.mAspect = 0;\n\n\t\t\t}\n\n\t\t\tfunction aiScene() {\n\n\t\t\t\tthis.versionMajor = 0;\n\t\t\t\tthis.versionMinor = 0;\n\t\t\t\tthis.versionRevision = 0;\n\t\t\t\tthis.compileFlags = 0;\n\t\t\t\tthis.mFlags = 0;\n\t\t\t\tthis.mNumMeshes = 0;\n\t\t\t\tthis.mNumMaterials = 0;\n\t\t\t\tthis.mNumAnimations = 0;\n\t\t\t\tthis.mNumTextures = 0;\n\t\t\t\tthis.mNumLights = 0;\n\t\t\t\tthis.mNumCameras = 0;\n\t\t\t\tthis.mRootNode = null;\n\t\t\t\tthis.mMeshes = [];\n\t\t\t\tthis.mMaterials = [];\n\t\t\t\tthis.mAnimations = [];\n\t\t\t\tthis.mLights = [];\n\t\t\t\tthis.mCameras = [];\n\t\t\t\tthis.nodeToBoneMap = {};\n\t\t\t\tthis.findNode = function ( name, root ) {\n\n\t\t\t\t\tif ( ! root ) {\n\n\t\t\t\t\t\troot = this.mRootNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( root.mName == name ) {\n\n\t\t\t\t\t\treturn root;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < root.mChildren.length; i ++ ) {\n\n\t\t\t\t\t\tvar ret = this.findNode( name, root.mChildren[ i ] );\n\t\t\t\t\t\tif ( ret ) return ret;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t};\n\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\tthis.nodeCount = 0;\n\n\t\t\t\t\tmarkBones( this );\n\n\t\t\t\t\tvar o = this.mRootNode.toTHREE( this );\n\n\t\t\t\t\tfor ( var i in this.mMeshes )\n\t\t\t\t\t\tthis.mMeshes[ i ].hookupSkeletons( this );\n\n\t\t\t\t\tif ( this.mAnimations.length > 0 ) {\n\n\t\t\t\t\t\tvar a = this.mAnimations[ 0 ].toTHREE( this );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { object: o, animation: a };\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiMatrix4() {\n\n\t\t\t\tthis.elements = [\n\t\t\t\t\t[],\n\t\t\t\t\t[],\n\t\t\t\t\t[],\n\t\t\t\t\t[]\n\t\t\t\t];\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\tvar m = new THREE.Matrix4();\n\n\t\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\t\tfor ( var i2 = 0; i2 < 4; ++ i2 ) {\n\n\t\t\t\t\t\t\tm.elements[ i * 4 + i2 ] = this.elements[ i2 ][ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn m;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar littleEndian = true;\n\n\t\t\tfunction readFloat( dataview ) {\n\n\t\t\t\tvar val = dataview.getFloat32( dataview.readOffset, littleEndian );\n\t\t\t\tdataview.readOffset += 4;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_double( dataview ) {\n\n\t\t\t\tvar val = dataview.getFloat64( dataview.readOffset, littleEndian );\n\t\t\t\tdataview.readOffset += 8;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_uint8_t( dataview ) {\n\n\t\t\t\tvar val = dataview.getUint8( dataview.readOffset );\n\t\t\t\tdataview.readOffset += 1;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_uint16_t( dataview ) {\n\n\t\t\t\tvar val = dataview.getUint16( dataview.readOffset, littleEndian );\n\t\t\t\tdataview.readOffset += 2;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_unsigned_int( dataview ) {\n\n\t\t\t\tvar val = dataview.getUint32( dataview.readOffset, littleEndian );\n\t\t\t\tdataview.readOffset += 4;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_uint32_t( dataview ) {\n\n\t\t\t\tvar val = dataview.getUint32( dataview.readOffset, littleEndian );\n\t\t\t\tdataview.readOffset += 4;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiVector3D( stream ) {\n\n\t\t\t\tvar v = new aiVector3D();\n\t\t\t\tv.x = readFloat( stream );\n\t\t\t\tv.y = readFloat( stream );\n\t\t\t\tv.z = readFloat( stream );\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiColor3D( stream ) {\n\n\t\t\t\tvar c = new aiColor3D();\n\t\t\t\tc.r = readFloat( stream );\n\t\t\t\tc.g = readFloat( stream );\n\t\t\t\tc.b = readFloat( stream );\n\t\t\t\treturn c;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiQuaternion( stream ) {\n\n\t\t\t\tvar v = new aiQuaternion();\n\t\t\t\tv.w = readFloat( stream );\n\t\t\t\tv.x = readFloat( stream );\n\t\t\t\tv.y = readFloat( stream );\n\t\t\t\tv.z = readFloat( stream );\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiString( stream ) {\n\n\t\t\t\tvar s = new aiString();\n\t\t\t\tvar stringlengthbytes = Read_unsigned_int( stream );\n\t\t\t\tstream.ReadBytes( s.data, 1, stringlengthbytes );\n\t\t\t\treturn s.toString();\n\n\t\t\t}\n\n\t\t\tfunction Read_aiVertexWeight( stream ) {\n\n\t\t\t\tvar w = new aiVertexWeight();\n\t\t\t\tw.mVertexId = Read_unsigned_int( stream );\n\t\t\t\tw.mWeight = readFloat( stream );\n\t\t\t\treturn w;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiMatrix4x4( stream ) {\n\n\t\t\t\tvar m = new aiMatrix4();\n\n\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\tfor ( var i2 = 0; i2 < 4; ++ i2 ) {\n\n\t\t\t\t\t\tm.elements[ i ][ i2 ] = readFloat( stream );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn m;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiVectorKey( stream ) {\n\n\t\t\t\tvar v = new aiVectorKey();\n\t\t\t\tv.mTime = Read_double( stream );\n\t\t\t\tv.mValue = Read_aiVector3D( stream );\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiQuatKey( stream ) {\n\n\t\t\t\tvar v = new aiQuatKey();\n\t\t\t\tv.mTime = Read_double( stream );\n\t\t\t\tv.mValue = Read_aiQuaternion( stream );\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction ReadArray_aiVertexWeight( stream, data, size ) {\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) data[ i ] = Read_aiVertexWeight( stream );\n\n\t\t\t}\n\n\t\t\tfunction ReadArray_aiVectorKey( stream, data, size ) {\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) data[ i ] = Read_aiVectorKey( stream );\n\n\t\t\t}\n\n\t\t\tfunction ReadArray_aiQuatKey( stream, data, size ) {\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) data[ i ] = Read_aiQuatKey( stream );\n\n\t\t\t}\n\n\t\t\tfunction ReadBounds( stream, T /*p*/, n ) {\n\n\t\t\t\t// not sure what to do here, the data isn't really useful.\n\t\t\t\treturn stream.Seek( sizeof( T ) * n, aiOrigin_CUR );\n\n\t\t\t}\n\n\t\t\tfunction ai_assert( bool ) {\n\n\t\t\t\tif ( ! bool )\n\t\t\t\t\tthrow ( \"asset failed\" );\n\n\t\t\t}\n\n\t\t\tfunction ReadBinaryNode( stream, parent, depth ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AINODE );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tvar node = new aiNode();\n\t\t\t\tnode.mParent = parent;\n\t\t\t\tnode.mDepth = depth;\n\t\t\t\tnode.mName = Read_aiString( stream );\n\t\t\t\tnode.mTransformation = Read_aiMatrix4x4( stream );\n\t\t\t\tnode.mNumChildren = Read_unsigned_int( stream );\n\t\t\t\tnode.mNumMeshes = Read_unsigned_int( stream );\n\n\t\t\t\tif ( node.mNumMeshes ) {\n\n\t\t\t\t\tnode.mMeshes = [];\n\n\t\t\t\t\tfor ( var i = 0; i < node.mNumMeshes; ++ i ) {\n\n\t\t\t\t\t\tnode.mMeshes[ i ] = Read_unsigned_int( stream );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( node.mNumChildren ) {\n\n\t\t\t\t\tnode.mChildren = [];\n\n\t\t\t\t\tfor ( var i = 0; i < node.mNumChildren; ++ i ) {\n\n\t\t\t\t\t\tvar node2 = ReadBinaryNode( stream, node, depth ++ );\n\t\t\t\t\t\tnode.mChildren[ i ] = node2;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t\t// -----------------------------------------------------------------------------------\n\n\t\t\tfunction ReadBinaryBone( stream, b ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIBONE );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tb.mName = Read_aiString( stream );\n\t\t\t\tb.mNumWeights = Read_unsigned_int( stream );\n\t\t\t\tb.mOffsetMatrix = Read_aiMatrix4x4( stream );\n\t\t\t\t// for the moment we write dumb min/max values for the bones, too.\n\t\t\t\t// maybe I'll add a better, hash-like solution later\n\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\tReadBounds( stream, b.mWeights, b.mNumWeights );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tb.mWeights = [];\n\t\t\t\t\tReadArray_aiVertexWeight( stream, b.mWeights, b.mNumWeights );\n\n\t\t\t\t}\n\n\t\t\t\treturn b;\n\n\t\t\t}\n\n\t\t\tfunction ReadBinaryMesh( stream, mesh ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIMESH );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tmesh.mPrimitiveTypes = Read_unsigned_int( stream );\n\t\t\t\tmesh.mNumVertices = Read_unsigned_int( stream );\n\t\t\t\tmesh.mNumFaces = Read_unsigned_int( stream );\n\t\t\t\tmesh.mNumBones = Read_unsigned_int( stream );\n\t\t\t\tmesh.mMaterialIndex = Read_unsigned_int( stream );\n\t\t\t\tmesh.mNumUVComponents = [];\n\t\t\t\t// first of all, write bits for all existent vertex components\n\t\t\t\tvar c = Read_unsigned_int( stream );\n\n\t\t\t\tif ( c & ASSBIN_MESH_HAS_POSITIONS ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, mesh.mVertices, mesh.mNumVertices );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tmesh.mVertices = [];\n\t\t\t\t\t\tmesh.mVertexBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\n\t\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( c & ASSBIN_MESH_HAS_NORMALS ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, mesh.mNormals, mesh.mNumVertices );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tmesh.mNormals = [];\n\t\t\t\t\t\tmesh.mNormalBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\n\t\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, mesh.mTangents, mesh.mNumVertices );\n\t\t\t\t\t\tReadBounds( stream, mesh.mBitangents, mesh.mNumVertices );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tmesh.mTangents = [];\n\t\t\t\t\t\tmesh.mTangentBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\n\t\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\n\t\t\t\t\t\tmesh.mBitangents = [];\n\t\t\t\t\t\tmesh.mBitangentBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\n\t\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++ n ) {\n\n\t\t\t\t\tif ( ! ( c & ASSBIN_MESH_HAS_COLOR( n ) ) ) break;\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, mesh.mColors[ n ], mesh.mNumVertices );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tmesh.mColors[ n ] = [];\n\t\t\t\t\t\tmesh.mColorBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4 );\n\t\t\t\t\t\tstream.Seek( mesh.mNumVertices * 4 * 4, aiOrigin_CUR );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmesh.mTexCoordsBuffers = [];\n\n\t\t\t\tfor ( var n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++ n ) {\n\n\t\t\t\t\tif ( ! ( c & ASSBIN_MESH_HAS_TEXCOORD( n ) ) ) break;\n\n\t\t\t\t\t// write number of UV components\n\t\t\t\t\tmesh.mNumUVComponents[ n ] = Read_unsigned_int( stream );\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, mesh.mTextureCoords[ n ], mesh.mNumVertices );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tmesh.mTextureCoords[ n ] = [];\n\t\t\t\t\t\t//note that assbin always writes 3d texcoords\n\t\t\t\t\t\tmesh.mTexCoordsBuffers[ n ] = [];\n\n\t\t\t\t\t\tfor ( var uv = 0; uv < mesh.mNumVertices; uv ++ ) {\n\n\t\t\t\t\t\t\tmesh.mTexCoordsBuffers[ n ].push( readFloat( stream ) );\n\t\t\t\t\t\t\tmesh.mTexCoordsBuffers[ n ].push( readFloat( stream ) );\n\t\t\t\t\t\t\treadFloat( stream );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// write faces. There are no floating-point calculations involved\n\t\t\t\t// in these, so we can write a simple hash over the face data\n\t\t\t\t// to the dump file. We generate a single 32 Bit hash for 512 faces\n\t\t\t\t// using Assimp's standard hashing function.\n\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\tRead_unsigned_int( stream );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t// if there are less than 2^16 vertices, we can simply use 16 bit integers ...\n\t\t\t\t\tmesh.mFaces = [];\n\t\t\t\t\tmesh.mIndexArray = [];\n\n\t\t\t\t\tfor ( var i = 0; i < mesh.mNumFaces; ++ i ) {\n\n\t\t\t\t\t\tvar f = mesh.mFaces[ i ] = new aiFace();\n\t\t\t\t\t\t// BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\n\t\t\t\t\t\tf.mNumIndices = Read_uint16_t( stream );\n\t\t\t\t\t\tf.mIndices = [];\n\n\t\t\t\t\t\tfor ( var a = 0; a < f.mNumIndices; ++ a ) {\n\n\t\t\t\t\t\t\tif ( mesh.mNumVertices < ( 1 << 16 ) ) {\n\n\t\t\t\t\t\t\t\tf.mIndices[ a ] = Read_uint16_t( stream );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tf.mIndices[ a ] = Read_unsigned_int( stream );\n\n\t\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( f.mNumIndices === 3 ) {\n\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 0 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 1 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 2 ] );\n\n\t\t\t\t\t\t} else if ( f.mNumIndices === 4 ) {\n\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 0 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 1 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 2 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 2 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 3 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 0 ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthrow ( new Error( \"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\" ) );\n\n\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// write bones\n\t\t\t\tif ( mesh.mNumBones ) {\n\n\t\t\t\t\tmesh.mBones = [];\n\n\t\t\t\t\tfor ( var a = 0; a < mesh.mNumBones; ++ a ) {\n\n\t\t\t\t\t\tmesh.mBones[ a ] = new aiBone();\n\t\t\t\t\t\tReadBinaryBone( stream, mesh.mBones[ a ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction ReadBinaryMaterialProperty( stream, prop ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tprop.mKey = Read_aiString( stream );\n\t\t\t\tprop.mSemantic = Read_unsigned_int( stream );\n\t\t\t\tprop.mIndex = Read_unsigned_int( stream );\n\t\t\t\tprop.mDataLength = Read_unsigned_int( stream );\n\t\t\t\tprop.mType = Read_unsigned_int( stream );\n\t\t\t\tprop.mData = [];\n\t\t\t\tstream.ReadBytes( prop.mData, 1, prop.mDataLength );\n\n\t\t\t}\n\n\t\t\t// -----------------------------------------------------------------------------------\n\n\t\t\tfunction ReadBinaryMaterial( stream, mat ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIMATERIAL );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tmat.mNumAllocated = mat.mNumProperties = Read_unsigned_int( stream );\n\n\t\t\t\tif ( mat.mNumProperties ) {\n\n\t\t\t\t\tif ( mat.mProperties ) {\n\n\t\t\t\t\t\tdelete mat.mProperties;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmat.mProperties = [];\n\n\t\t\t\t\tfor ( var i = 0; i < mat.mNumProperties; ++ i ) {\n\n\t\t\t\t\t\tmat.mProperties[ i ] = new aiMaterialProperty();\n\t\t\t\t\t\tReadBinaryMaterialProperty( stream, mat.mProperties[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// -----------------------------------------------------------------------------------\n\t\t\tfunction ReadBinaryNodeAnim( stream, nd ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AINODEANIM );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tnd.mNodeName = Read_aiString( stream );\n\t\t\t\tnd.mNumPositionKeys = Read_unsigned_int( stream );\n\t\t\t\tnd.mNumRotationKeys = Read_unsigned_int( stream );\n\t\t\t\tnd.mNumScalingKeys = Read_unsigned_int( stream );\n\t\t\t\tnd.mPreState = Read_unsigned_int( stream );\n\t\t\t\tnd.mPostState = Read_unsigned_int( stream );\n\n\t\t\t\tif ( nd.mNumPositionKeys ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, nd.mPositionKeys, nd.mNumPositionKeys );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tnd.mPositionKeys = [];\n\t\t\t\t\t\tReadArray_aiVectorKey( stream, nd.mPositionKeys, nd.mNumPositionKeys );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( nd.mNumRotationKeys ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, nd.mRotationKeys, nd.mNumRotationKeys );\n\n\t\t\t\t\t} else {\n\n\t\t\t \t\t\t// else write as usual\n\n\t\t\t\t\t\tnd.mRotationKeys = [];\n\t\t\t\t\t\tReadArray_aiQuatKey( stream, nd.mRotationKeys, nd.mNumRotationKeys );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( nd.mNumScalingKeys ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, nd.mScalingKeys, nd.mNumScalingKeys );\n\n\t\t\t\t\t} else {\n\n\t\t \t\t\t\t// else write as usual\n\n\t\t\t\t\t\tnd.mScalingKeys = [];\n\t\t\t\t\t\tReadArray_aiVectorKey( stream, nd.mScalingKeys, nd.mNumScalingKeys );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// -----------------------------------------------------------------------------------\n\t\t\tfunction ReadBinaryAnim( stream, anim ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIANIMATION );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tanim.mName = Read_aiString( stream );\n\t\t\t\tanim.mDuration = Read_double( stream );\n\t\t\t\tanim.mTicksPerSecond = Read_double( stream );\n\t\t\t\tanim.mNumChannels = Read_unsigned_int( stream );\n\n\t\t\t\tif ( anim.mNumChannels ) {\n\n\t\t\t\t\tanim.mChannels = [];\n\n\t\t\t\t\tfor ( var a = 0; a < anim.mNumChannels; ++ a ) {\n\n\t\t\t\t\t\tanim.mChannels[ a ] = new aiNodeAnim();\n\t\t\t\t\t\tReadBinaryNodeAnim( stream, anim.mChannels[ a ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction ReadBinaryTexture( stream, tex ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AITEXTURE );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\ttex.mWidth = Read_unsigned_int( stream );\n\t\t\t\ttex.mHeight = Read_unsigned_int( stream );\n\t\t\t\tstream.ReadBytes( tex.achFormatHint, 1, 4 );\n\n\t\t\t\tif ( ! shortened ) {\n\n\t\t\t\t\tif ( ! tex.mHeight ) {\n\n\t\t\t\t\t\ttex.pcData = [];\n\t\t\t\t\t\tstream.ReadBytes( tex.pcData, 1, tex.mWidth );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttex.pcData = [];\n\t\t\t\t\t\tstream.ReadBytes( tex.pcData, 1, tex.mWidth * tex.mHeight * 4 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// -----------------------------------------------------------------------------------\n\t\t\tfunction ReadBinaryLight( stream, l ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AILIGHT );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tl.mName = Read_aiString( stream );\n\t\t\t\tl.mType = Read_unsigned_int( stream );\n\n\t\t\t\tif ( l.mType != aiLightSource_DIRECTIONAL ) {\n\n\t\t\t\t\tl.mAttenuationConstant = readFloat( stream );\n\t\t\t\t\tl.mAttenuationLinear = readFloat( stream );\n\t\t\t\t\tl.mAttenuationQuadratic = readFloat( stream );\n\n\t\t\t\t}\n\n\t\t\t\tl.mColorDiffuse = Read_aiColor3D( stream );\n\t\t\t\tl.mColorSpecular = Read_aiColor3D( stream );\n\t\t\t\tl.mColorAmbient = Read_aiColor3D( stream );\n\n\t\t\t\tif ( l.mType == aiLightSource_SPOT ) {\n\n\t\t\t\t\tl.mAngleInnerCone = readFloat( stream );\n\t\t\t\t\tl.mAngleOuterCone = readFloat( stream );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// -----------------------------------------------------------------------------------\n\t\t\tfunction ReadBinaryCamera( stream, cam ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AICAMERA );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tcam.mName = Read_aiString( stream );\n\t\t\t\tcam.mPosition = Read_aiVector3D( stream );\n\t\t\t\tcam.mLookAt = Read_aiVector3D( stream );\n\t\t\t\tcam.mUp = Read_aiVector3D( stream );\n\t\t\t\tcam.mHorizontalFOV = readFloat( stream );\n\t\t\t\tcam.mClipPlaneNear = readFloat( stream );\n\t\t\t\tcam.mClipPlaneFar = readFloat( stream );\n\t\t\t\tcam.mAspect = readFloat( stream );\n\n\t\t\t}\n\n\t\t\tfunction ReadBinaryScene( stream, scene ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AISCENE );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tscene.mFlags = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumMeshes = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumMaterials = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumAnimations = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumTextures = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumLights = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumCameras = Read_unsigned_int( stream );\n\t\t\t\t// Read node graph\n\t\t\t\tscene.mRootNode = new aiNode();\n\t\t\t\tscene.mRootNode = ReadBinaryNode( stream, null, 0 );\n\t\t\t\t// Read all meshes\n\t\t\t\tif ( scene.mNumMeshes ) {\n\n\t\t\t\t\tscene.mMeshes = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumMeshes; ++ i ) {\n\n\t\t\t\t\t\tscene.mMeshes[ i ] = new aiMesh();\n\t\t\t\t\t\tReadBinaryMesh( stream, scene.mMeshes[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// Read materials\n\t\t\t\tif ( scene.mNumMaterials ) {\n\n\t\t\t\t\tscene.mMaterials = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumMaterials; ++ i ) {\n\n\t\t\t\t\t\tscene.mMaterials[ i ] = new aiMaterial();\n\t\t\t\t\t\tReadBinaryMaterial( stream, scene.mMaterials[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// Read all animations\n\t\t\t\tif ( scene.mNumAnimations ) {\n\n\t\t\t\t\tscene.mAnimations = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumAnimations; ++ i ) {\n\n\t\t\t\t\t\tscene.mAnimations[ i ] = new aiAnimation();\n\t\t\t\t\t\tReadBinaryAnim( stream, scene.mAnimations[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// Read all textures\n\t\t\t\tif ( scene.mNumTextures ) {\n\n\t\t\t\t\tscene.mTextures = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumTextures; ++ i ) {\n\n\t\t\t\t\t\tscene.mTextures[ i ] = new aiTexture();\n\t\t\t\t\t\tReadBinaryTexture( stream, scene.mTextures[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// Read lights\n\t\t\t\tif ( scene.mNumLights ) {\n\n\t\t\t\t\tscene.mLights = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumLights; ++ i ) {\n\n\t\t\t\t\t\tscene.mLights[ i ] = new aiLight();\n\t\t\t\t\t\tReadBinaryLight( stream, scene.mLights[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// Read cameras\n\t\t\t\tif ( scene.mNumCameras ) {\n\n\t\t\t\t\tscene.mCameras = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumCameras; ++ i ) {\n\n\t\t\t\t\t\tscene.mCameras[ i ] = new aiCamera();\n\t\t\t\t\t\tReadBinaryCamera( stream, scene.mCameras[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tvar aiOrigin_CUR = 0;\n\t\t\tvar aiOrigin_BEG = 1;\n\n\t\t\tfunction extendStream( stream ) {\n\n\t\t\t\tstream.readOffset = 0;\n\t\t\t\tstream.Seek = function ( off, ori ) {\n\n\t\t\t\t\tif ( ori == aiOrigin_CUR ) {\n\n\t\t\t\t\t\tstream.readOffset += off;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ori == aiOrigin_BEG ) {\n\n\t\t\t\t\t\tstream.readOffset = off;\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tstream.ReadBytes = function ( buff, size, n ) {\n\n\t\t\t\t\tvar bytes = size * n;\n\t\t\t\t\tfor ( var i = 0; i < bytes; i ++ )\n\t\t\t\t\t\tbuff[ i ] = Read_uint8_t( this );\n\n\t\t\t\t};\n\n\t\t\t\tstream.subArray32 = function ( start, end ) {\n\n\t\t\t\t\tvar buff = this.buffer;\n\t\t\t\t\tvar newbuff = buff.slice( start, end );\n\t\t\t\t\treturn new Float32Array( newbuff );\n\n\t\t\t\t};\n\n\t\t\t\tstream.subArrayUint16 = function ( start, end ) {\n\n\t\t\t\t\tvar buff = this.buffer;\n\t\t\t\t\tvar newbuff = buff.slice( start, end );\n\t\t\t\t\treturn new Uint16Array( newbuff );\n\n\t\t\t\t};\n\n\t\t\t\tstream.subArrayUint8 = function ( start, end ) {\n\n\t\t\t\t\tvar buff = this.buffer;\n\t\t\t\t\tvar newbuff = buff.slice( start, end );\n\t\t\t\t\treturn new Uint8Array( newbuff );\n\n\t\t\t\t};\n\n\t\t\t\tstream.subArrayUint32 = function ( start, end ) {\n\n\t\t\t\t\tvar buff = this.buffer;\n\t\t\t\t\tvar newbuff = buff.slice( start, end );\n\t\t\t\t\treturn new Uint32Array( newbuff );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar shortened, compressed;\n\n\t\t\tfunction InternReadFile( pFiledata ) {\n\n\t\t\t\tvar pScene = new aiScene();\n\t\t\t\tvar stream = new DataView( pFiledata );\n\t\t\t\textendStream( stream );\n\t\t\t\tstream.Seek( 44, aiOrigin_CUR ); // signature\n\t\t\t\t/*unsigned int versionMajor =*/\n\t\t\t\tpScene.versionMajor = Read_unsigned_int( stream );\n\t\t\t\t/*unsigned int versionMinor =*/\n\t\t\t\tpScene.versionMinor = Read_unsigned_int( stream );\n\t\t\t\t/*unsigned int versionRevision =*/\n\t\t\t\tpScene.versionRevision = Read_unsigned_int( stream );\n\t\t\t\t/*unsigned int compileFlags =*/\n\t\t\t\tpScene.compileFlags = Read_unsigned_int( stream );\n\t\t\t\tshortened = Read_uint16_t( stream ) > 0;\n\t\t\t\tcompressed = Read_uint16_t( stream ) > 0;\n\t\t\t\tif ( shortened )\n\t\t\t\t\tthrow \"Shortened binaries are not supported!\";\n\t\t\t\tstream.Seek( 256, aiOrigin_CUR ); // original filename\n\t\t\t\tstream.Seek( 128, aiOrigin_CUR ); // options\n\t\t\t\tstream.Seek( 64, aiOrigin_CUR ); // padding\n\t\t\t\tif ( compressed ) {\n\n\t\t\t\t\tvar uncompressedSize = Read_uint32_t( stream );\n\t\t\t\t\tvar compressedSize = stream.FileSize() - stream.Tell();\n\t\t\t\t\tvar compressedData = [];\n\t\t\t\t\tstream.Read( compressedData, 1, compressedSize );\n\t\t\t\t\tvar uncompressedData = [];\n\t\t\t\t\tuncompress( uncompressedData, uncompressedSize, compressedData, compressedSize );\n\t\t\t\t\tvar buff = new ArrayBuffer( uncompressedData );\n\t\t\t\t\tReadBinaryScene( buff, pScene );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tReadBinaryScene( stream, pScene );\n\n\t\t\t\t}\n\n\t\t\t\treturn pScene.toTHREE();\n\n\t\t\t}\n\n\t\t\treturn InternReadFile( buffer );\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.AssimpLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/TGALoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Daosheng Mu / https://github.com/DaoshengMu/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author takahirox / https://github.com/takahirox/\n\t */\n\n\tTHREE.TGALoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.TGALoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.TGALoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texture = new THREE.Texture();\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.setPath( this.path );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\ttexture.image = scope.parse( buffer );\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\t\tonLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tparse: function ( buffer ) {\n\n\t\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n\t\t\tfunction tgaCheckHeader( header ) {\n\n\t\t\t\tswitch ( header.image_type ) {\n\n\t\t\t\t\t// check indexed type\n\n\t\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\t\tif ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// check colormap type\n\n\t\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\t\tif ( header.colormap_type ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// What the need of a file without data ?\n\n\t\t\t\t\tcase TGA_TYPE_NO_DATA:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t\t\t\t\t// Invalid type ?\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type \"%s\".', header.image_type );\n\n\t\t\t\t}\n\n\t\t\t\t// check image width and height\n\n\t\t\t\tif ( header.width <= 0 || header.height <= 0 ) {\n\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid image size.' );\n\n\t\t\t\t}\n\n\t\t\t\t// check image pixel size\n\n\t\t\t\tif ( header.pixel_size !== 8 && header.pixel_size !== 16 &&\n\t\t\t\t\theader.pixel_size !== 24 && header.pixel_size !== 32 ) {\n\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// parse tga image buffer\n\n\t\t\tfunction tgaParse( use_rle, use_pal, header, offset, data ) {\n\n\t\t\t\tvar pixel_data,\n\t\t\t\t\tpixel_size,\n\t\t\t\t\tpixel_total,\n\t\t\t\t\tpalettes;\n\n\t\t\t\tpixel_size = header.pixel_size >> 3;\n\t\t\t\tpixel_total = header.width * header.height * pixel_size;\n\n\t\t\t\t // read palettes\n\n\t\t\t\t if ( use_pal ) {\n\n\t\t\t\t\t palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );\n\n\t\t\t\t }\n\n\t\t\t\t // read RLE\n\n\t\t\t\t if ( use_rle ) {\n\n\t\t\t\t\t pixel_data = new Uint8Array( pixel_total );\n\n\t\t\t\t\tvar c, count, i;\n\t\t\t\t\tvar shift = 0;\n\t\t\t\t\tvar pixels = new Uint8Array( pixel_size );\n\n\t\t\t\t\twhile ( shift < pixel_total ) {\n\n\t\t\t\t\t\tc = data[ offset ++ ];\n\t\t\t\t\t\tcount = ( c & 0x7f ) + 1;\n\n\t\t\t\t\t\t// RLE pixels\n\n\t\t\t\t\t\tif ( c & 0x80 ) {\n\n\t\t\t\t\t\t\t// bind pixel tmp array\n\n\t\t\t\t\t\t\tfor ( i = 0; i < pixel_size; ++ i ) {\n\n\t\t\t\t\t\t\t\tpixels[ i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// copy pixel array\n\n\t\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\t\tpixel_data.set( pixels, shift + i * pixel_size );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tshift += pixel_size * count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\t\tcount *= pixel_size;\n\t\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\t\tpixel_data[ shift + i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tshift += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t } else {\n\n\t\t\t\t\t// raw pixels\n\n\t\t\t\t\tpixel_data = data.subarray(\n\t\t\t\t\t\t offset, offset += ( use_pal ? header.width * header.height : pixel_total )\n\t\t\t\t\t);\n\n\t\t\t\t }\n\n\t\t\t\t return {\n\t\t\t\t\tpixel_data: pixel_data,\n\t\t\t\t\tpalettes: palettes\n\t\t\t\t };\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {\n\n\t\t\t\tvar colormap = palettes;\n\t\t\t\tvar color, i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\t\tvar color, i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\t\tcolor = image[ i + 0 ] + ( image[ i + 1 ] << 8 ); // Inversed ?\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) >> 3;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\t\tvar i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 3 ) {\n\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\t\tvar i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 4 ) {\n\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\t\tvar color, i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = color;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = color;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = color;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\t\tvar i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction getTgaRGBA( data, width, height, image, palette ) {\n\n\t\t\t\tvar x_start,\n\t\t\t\t\ty_start,\n\t\t\t\t\tx_step,\n\t\t\t\t\ty_step,\n\t\t\t\t\tx_end,\n\t\t\t\t\ty_end;\n\n\t\t\t\tswitch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {\n\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase TGA_ORIGIN_UL:\n\t\t\t\t\t\tx_start = 0;\n\t\t\t\t\t\tx_step = 1;\n\t\t\t\t\t\tx_end = width;\n\t\t\t\t\t\ty_start = 0;\n\t\t\t\t\t\ty_step = 1;\n\t\t\t\t\t\ty_end = height;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TGA_ORIGIN_BL:\n\t\t\t\t\t\tx_start = 0;\n\t\t\t\t\t\tx_step = 1;\n\t\t\t\t\t\tx_end = width;\n\t\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\t\ty_step = - 1;\n\t\t\t\t\t\ty_end = - 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TGA_ORIGIN_UR:\n\t\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\t\tx_step = - 1;\n\t\t\t\t\t\tx_end = - 1;\n\t\t\t\t\t\ty_start = 0;\n\t\t\t\t\t\ty_step = 1;\n\t\t\t\t\t\ty_end = height;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TGA_ORIGIN_BR:\n\t\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\t\tx_step = - 1;\n\t\t\t\t\t\tx_end = - 1;\n\t\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\t\ty_step = - 1;\n\t\t\t\t\t\ty_end = - 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( use_grey ) {\n\n\t\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\ttgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 16:\n\t\t\t\t\t\t\ttgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\ttgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 16:\n\t\t\t\t\t\t\ttgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 24:\n\t\t\t\t\t\t\ttgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 32:\n\t\t\t\t\t\t\ttgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Load image data according to specific method\n\t\t\t\t// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n\t\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\t// TGA constants\n\n\t\t\tvar TGA_TYPE_NO_DATA = 0,\n\t\t\t\tTGA_TYPE_INDEXED = 1,\n\t\t\t\tTGA_TYPE_RGB = 2,\n\t\t\t\tTGA_TYPE_GREY = 3,\n\t\t\t\tTGA_TYPE_RLE_INDEXED = 9,\n\t\t\t\tTGA_TYPE_RLE_RGB = 10,\n\t\t\t\tTGA_TYPE_RLE_GREY = 11,\n\n\t\t\t\tTGA_ORIGIN_MASK = 0x30,\n\t\t\t\tTGA_ORIGIN_SHIFT = 0x04,\n\t\t\t\tTGA_ORIGIN_BL = 0x00,\n\t\t\t\tTGA_ORIGIN_BR = 0x01,\n\t\t\t\tTGA_ORIGIN_UL = 0x02,\n\t\t\t\tTGA_ORIGIN_UR = 0x03;\n\n\t\t\tif ( buffer.length < 19 ) console.error( 'THREE.TGALoader: Not enough data to contain header.' );\n\n\t\t\tvar content = new Uint8Array( buffer ),\n\t\t\t\toffset = 0,\n\t\t\t\theader = {\n\t\t\t\t\tid_length: content[ offset ++ ],\n\t\t\t\t\tcolormap_type: content[ offset ++ ],\n\t\t\t\t\timage_type: content[ offset ++ ],\n\t\t\t\t\tcolormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tcolormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tcolormap_size: content[ offset ++ ],\n\t\t\t\t\torigin: [\n\t\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8\n\t\t\t\t\t],\n\t\t\t\t\twidth: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\theight: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tpixel_size: content[ offset ++ ],\n\t\t\t\t\tflags: content[ offset ++ ]\n\t\t\t\t};\n\n\t\t\t// check tga if it is valid format\n\n\t\t\ttgaCheckHeader( header );\n\n\t\t\tif ( header.id_length + offset > buffer.length ) {\n\n\t\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t\t}\n\n\t\t\t// skip the needn't data\n\n\t\t\toffset += header.id_length;\n\n\t\t\t// get targa information about RLE compression and palette\n\n\t\t\tvar use_rle = false,\n\t\t\t\tuse_pal = false,\n\t\t\t\tuse_grey = false;\n\n\t\t\tswitch ( header.image_type ) {\n\n\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\tuse_rle = true;\n\t\t\t\t\tuse_pal = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\t\tuse_pal = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\t\tuse_rle = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\tuse_rle = true;\n\t\t\t\t\tuse_grey = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\t\tuse_grey = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar useOffscreen = typeof OffscreenCanvas !== 'undefined';\n\n\t\t\tvar canvas = useOffscreen ? new OffscreenCanvas( header.width, header.height ) : document.createElement( 'canvas' );\n\t\t\tcanvas.width = header.width;\n\t\t\tcanvas.height = header.height;\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tvar imageData = context.createImageData( header.width, header.height );\n\n\t\t\tvar result = tgaParse( use_rle, use_pal, header, offset, content );\n\t\t\tvar rgbaData = getTgaRGBA( imageData.data, header.width, header.height, result.pixel_data, result.palettes );\n\n\t\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\t\treturn useOffscreen ? canvas.transferToImageBitmap() : canvas;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.TGALoader;\n});\n\ndefine('skylark-threejs-ex/loaders/ColladaLoader',[\n\t\"skylark-threejs\",\n\t\"./TGALoader\"\n],function(THREE,TGALoader){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tTHREE.ColladaLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.ColladaLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.ColladaLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( scope.path === '' ) ? THREE.LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\toptions: {\n\n\t\t\tset convertUpAxis( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.' );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparse: function ( text, path ) {\n\n\t\t\tfunction getElementsByTagName( xml, name ) {\n\n\t\t\t\t// Non recursive xml.getElementsByTagName() ...\n\n\t\t\t\tvar array = [];\n\t\t\t\tvar childNodes = xml.childNodes;\n\n\t\t\t\tfor ( var i = 0, l = childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeName === name ) {\n\n\t\t\t\t\t\tarray.push( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tfunction parseStrings( text ) {\n\n\t\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\t\tvar parts = text.trim().split( /\\s+/ );\n\t\t\t\tvar array = new Array( parts.length );\n\n\t\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = parts[ i ];\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tfunction parseFloats( text ) {\n\n\t\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\t\tvar parts = text.trim().split( /\\s+/ );\n\t\t\t\tvar array = new Array( parts.length );\n\n\t\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = parseFloat( parts[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tfunction parseInts( text ) {\n\n\t\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\t\tvar parts = text.trim().split( /\\s+/ );\n\t\t\t\tvar array = new Array( parts.length );\n\n\t\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = parseInt( parts[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tfunction parseId( text ) {\n\n\t\t\t\treturn text.substring( 1 );\n\n\t\t\t}\n\n\t\t\tfunction generateId() {\n\n\t\t\t\treturn 'three_default_' + ( count ++ );\n\n\t\t\t}\n\n\t\t\tfunction isEmpty( object ) {\n\n\t\t\t\treturn Object.keys( object ).length === 0;\n\n\t\t\t}\n\n\t\t\t// asset\n\n\t\t\tfunction parseAsset( xml ) {\n\n\t\t\t\treturn {\n\t\t\t\t\tunit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),\n\t\t\t\t\tupAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction parseAssetUnit( xml ) {\n\n\t\t\t\tif ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {\n\n\t\t\t\t\treturn parseFloat( xml.getAttribute( 'meter' ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn 1; // default 1 meter\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseAssetUpAxis( xml ) {\n\n\t\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\n\n\t\t\t}\n\n\t\t\t// library\n\n\t\t\tfunction parseLibrary( xml, libraryName, nodeName, parser ) {\n\n\t\t\t\tvar library = getElementsByTagName( xml, libraryName )[ 0 ];\n\n\t\t\t\tif ( library !== undefined ) {\n\n\t\t\t\t\tvar elements = getElementsByTagName( library, nodeName );\n\n\t\t\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\t\tparser( elements[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction buildLibrary( data, builder ) {\n\n\t\t\t\tfor ( var name in data ) {\n\n\t\t\t\t\tvar object = data[ name ];\n\t\t\t\t\tobject.build = builder( data[ name ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// get\n\n\t\t\tfunction getBuild( data, builder ) {\n\n\t\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\t\tdata.build = builder( data );\n\n\t\t\t\treturn data.build;\n\n\t\t\t}\n\n\t\t\t// animation\n\n\t\t\tfunction parseAnimation( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tsources: {},\n\t\t\t\t\tsamplers: {},\n\t\t\t\t\tchannels: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tvar id;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'source':\n\t\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'sampler':\n\t\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\t\tdata.samplers[ id ] = parseAnimationSampler( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'channel':\n\t\t\t\t\t\t\tid = child.getAttribute( 'target' );\n\t\t\t\t\t\t\tdata.channels[ id ] = parseAnimationChannel( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.animations[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parseAnimationSampler( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tinputs: {},\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'input':\n\t\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseAnimationChannel( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tvar target = xml.getAttribute( 'target' );\n\n\t\t\t\t// parsing SID Addressing Syntax\n\n\t\t\t\tvar parts = target.split( '/' );\n\n\t\t\t\tvar id = parts.shift();\n\t\t\t\tvar sid = parts.shift();\n\n\t\t\t\t// check selection syntax\n\n\t\t\t\tvar arraySyntax = ( sid.indexOf( '(' ) !== - 1 );\n\t\t\t\tvar memberSyntax = ( sid.indexOf( '.' ) !== - 1 );\n\n\t\t\t\tif ( memberSyntax ) {\n\n\t\t\t\t\t//  member selection access\n\n\t\t\t\t\tparts = sid.split( '.' );\n\t\t\t\t\tsid = parts.shift();\n\t\t\t\t\tdata.member = parts.shift();\n\n\t\t\t\t} else if ( arraySyntax ) {\n\n\t\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n\t\t\t\t\tvar indices = sid.split( '(' );\n\t\t\t\t\tsid = indices.shift();\n\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\t\tindices[ i ] = parseInt( indices[ i ].replace( /\\)/, '' ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.indices = indices;\n\n\t\t\t\t}\n\n\t\t\t\tdata.id = id;\n\t\t\t\tdata.sid = sid;\n\n\t\t\t\tdata.arraySyntax = arraySyntax;\n\t\t\t\tdata.memberSyntax = memberSyntax;\n\n\t\t\t\tdata.sampler = parseId( xml.getAttribute( 'source' ) );\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction buildAnimation( data ) {\n\n\t\t\t\tvar tracks = [];\n\n\t\t\t\tvar channels = data.channels;\n\t\t\t\tvar samplers = data.samplers;\n\t\t\t\tvar sources = data.sources;\n\n\t\t\t\tfor ( var target in channels ) {\n\n\t\t\t\t\tif ( channels.hasOwnProperty( target ) ) {\n\n\t\t\t\t\t\tvar channel = channels[ target ];\n\t\t\t\t\t\tvar sampler = samplers[ channel.sampler ];\n\n\t\t\t\t\t\tvar inputId = sampler.inputs.INPUT;\n\t\t\t\t\t\tvar outputId = sampler.inputs.OUTPUT;\n\n\t\t\t\t\t\tvar inputSource = sources[ inputId ];\n\t\t\t\t\t\tvar outputSource = sources[ outputId ];\n\n\t\t\t\t\t\tvar animation = buildAnimationChannel( channel, inputSource, outputSource );\n\n\t\t\t\t\t\tcreateKeyframeTracks( animation, tracks );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn tracks;\n\n\t\t\t}\n\n\t\t\tfunction getAnimation( id ) {\n\n\t\t\t\treturn getBuild( library.animations[ id ], buildAnimation );\n\n\t\t\t}\n\n\t\t\tfunction buildAnimationChannel( channel, inputSource, outputSource ) {\n\n\t\t\t\tvar node = library.nodes[ channel.id ];\n\t\t\t\tvar object3D = getNode( node.id );\n\n\t\t\t\tvar transform = node.transforms[ channel.sid ];\n\t\t\t\tvar defaultMatrix = node.matrix.clone().transpose();\n\n\t\t\t\tvar time, stride;\n\t\t\t\tvar i, il, j, jl;\n\n\t\t\t\tvar data = {};\n\n\t\t\t\t// the collada spec allows the animation of data in various ways.\n\t\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n\t\t\t\tswitch ( transform ) {\n\n\t\t\t\t\tcase 'matrix':\n\n\t\t\t\t\t\tfor ( i = 0, il = inputSource.array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\ttime = inputSource.array[ i ];\n\t\t\t\t\t\t\tstride = i * outputSource.stride;\n\n\t\t\t\t\t\t\tif ( data[ time ] === undefined ) data[ time ] = {};\n\n\t\t\t\t\t\t\tif ( channel.arraySyntax === true ) {\n\n\t\t\t\t\t\t\t\tvar value = outputSource.array[ stride ];\n\t\t\t\t\t\t\t\tvar index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];\n\n\t\t\t\t\t\t\t\tdata[ time ][ index ] = value;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tfor ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tdata[ time ][ j ] = outputSource.array[ stride + j ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tvar keyframes = prepareAnimationData( data, defaultMatrix );\n\n\t\t\t\tvar animation = {\n\t\t\t\t\tname: object3D.uuid,\n\t\t\t\t\tkeyframes: keyframes\n\t\t\t\t};\n\n\t\t\t\treturn animation;\n\n\t\t\t}\n\n\t\t\tfunction prepareAnimationData( data, defaultMatrix ) {\n\n\t\t\t\tvar keyframes = [];\n\n\t\t\t\t// transfer data into a sortable array\n\n\t\t\t\tfor ( var time in data ) {\n\n\t\t\t\t\tkeyframes.push( { time: parseFloat( time ), value: data[ time ] } );\n\n\t\t\t\t}\n\n\t\t\t\t// ensure keyframes are sorted by time\n\n\t\t\t\tkeyframes.sort( ascending );\n\n\t\t\t\t// now we clean up all animation data, so we can use them for keyframe tracks\n\n\t\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\t\ttransformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn keyframes;\n\n\t\t\t\t// array sort function\n\n\t\t\t\tfunction ascending( a, b ) {\n\n\t\t\t\t\treturn a.time - b.time;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar position = new THREE.Vector3();\n\t\t\tvar scale = new THREE.Vector3();\n\t\t\tvar quaternion = new THREE.Quaternion();\n\n\t\t\tfunction createKeyframeTracks( animation, tracks ) {\n\n\t\t\t\tvar keyframes = animation.keyframes;\n\t\t\t\tvar name = animation.name;\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar positionData = [];\n\t\t\t\tvar quaternionData = [];\n\t\t\t\tvar scaleData = [];\n\n\t\t\t\tfor ( var i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\t\tvar time = keyframe.time;\n\t\t\t\t\tvar value = keyframe.value;\n\n\t\t\t\t\tmatrix.fromArray( value ).transpose();\n\t\t\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\t\t\ttimes.push( time );\n\t\t\t\t\tpositionData.push( position.x, position.y, position.z );\n\t\t\t\t\tquaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );\n\t\t\t\t\tscaleData.push( scale.x, scale.y, scale.z );\n\n\t\t\t\t}\n\n\t\t\t\tif ( positionData.length > 0 ) tracks.push( new THREE.VectorKeyframeTrack( name + '.position', times, positionData ) );\n\t\t\t\tif ( quaternionData.length > 0 ) tracks.push( new THREE.QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) );\n\t\t\t\tif ( scaleData.length > 0 ) tracks.push( new THREE.VectorKeyframeTrack( name + '.scale', times, scaleData ) );\n\n\t\t\t\treturn tracks;\n\n\t\t\t}\n\n\t\t\tfunction transformAnimationData( keyframes, property, defaultValue ) {\n\n\t\t\t\tvar keyframe;\n\n\t\t\t\tvar empty = true;\n\t\t\t\tvar i, l;\n\n\t\t\t\t// check, if values of a property are missing in our keyframes\n\n\t\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\t\tif ( keyframe.value[ property ] === undefined ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = null; // mark as missing\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tempty = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( empty === true ) {\n\n\t\t\t\t\t// no values at all, so we set a default value\n\n\t\t\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\t\t\tkeyframe.value[ property ] = defaultValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// filling gaps\n\n\t\t\t\t\tcreateMissingKeyframes( keyframes, property );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction createMissingKeyframes( keyframes, property ) {\n\n\t\t\t\tvar prev, next;\n\n\t\t\t\tfor ( var i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\t\tif ( keyframe.value[ property ] === null ) {\n\n\t\t\t\t\t\tprev = getPrev( keyframes, i, property );\n\t\t\t\t\t\tnext = getNext( keyframes, i, property );\n\n\t\t\t\t\t\tif ( prev === null ) {\n\n\t\t\t\t\t\t\tkeyframe.value[ property ] = next.value[ property ];\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( next === null ) {\n\n\t\t\t\t\t\t\tkeyframe.value[ property ] = prev.value[ property ];\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinterpolate( keyframe, prev, next, property );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getPrev( keyframes, i, property ) {\n\n\t\t\t\twhile ( i >= 0 ) {\n\n\t\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\t\ti --;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tfunction getNext( keyframes, i, property ) {\n\n\t\t\t\twhile ( i < keyframes.length ) {\n\n\t\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\t\ti ++;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tfunction interpolate( key, prev, next, property ) {\n\n\t\t\t\tif ( ( next.time - prev.time ) === 0 ) {\n\n\t\t\t\t\tkey.value[ property ] = prev.value[ property ];\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tkey.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];\n\n\t\t\t}\n\n\t\t\t// animation clips\n\n\t\t\tfunction parseAnimationClip( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'id' ) || 'default',\n\t\t\t\t\tstart: parseFloat( xml.getAttribute( 'start' ) || 0 ),\n\t\t\t\t\tend: parseFloat( xml.getAttribute( 'end' ) || 0 ),\n\t\t\t\t\tanimations: []\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'instance_animation':\n\t\t\t\t\t\t\tdata.animations.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.clips[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction buildAnimationClip( data ) {\n\n\t\t\t\tvar tracks = [];\n\n\t\t\t\tvar name = data.name;\n\t\t\t\tvar duration = ( data.end - data.start ) || - 1;\n\t\t\t\tvar animations = data.animations;\n\n\t\t\t\tfor ( var i = 0, il = animations.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar animationTracks = getAnimation( animations[ i ] );\n\n\t\t\t\t\tfor ( var j = 0, jl = animationTracks.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\ttracks.push( animationTracks[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new THREE.AnimationClip( name, duration, tracks );\n\n\t\t\t}\n\n\t\t\tfunction getAnimationClip( id ) {\n\n\t\t\t\treturn getBuild( library.clips[ id ], buildAnimationClip );\n\n\t\t\t}\n\n\t\t\t// controller\n\n\t\t\tfunction parseController( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\t\t// there is exactly one skin per controller\n\t\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\t\tdata.skin = parseSkin( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'morph':\n\t\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.controllers[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parseSkin( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tsources: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'bind_shape_matrix':\n\t\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'source':\n\t\t\t\t\t\t\tvar id = child.getAttribute( 'id' );\n\t\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'joints':\n\t\t\t\t\t\t\tdata.joints = parseJoints( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'vertex_weights':\n\t\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseJoints( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tinputs: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'input':\n\t\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseVertexWeights( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tinputs: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'input':\n\t\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\t\tvar offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\t\tdata.inputs[ semantic ] = { id: id, offset: offset };\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\t\tdata.vcount = parseInts( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tdata.v = parseInts( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction buildController( data ) {\n\n\t\t\t\tvar build = {\n\t\t\t\t\tid: data.id\n\t\t\t\t};\n\n\t\t\t\tvar geometry = library.geometries[ build.id ];\n\n\t\t\t\tif ( data.skin !== undefined ) {\n\n\t\t\t\t\tbuild.skin = buildSkin( data.skin );\n\n\t\t\t\t\t// we enhance the 'sources' property of the corresponding geometry with our skin data\n\n\t\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\n\t\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\n\n\t\t\t\t}\n\n\t\t\t\treturn build;\n\n\t\t\t}\n\n\t\t\tfunction buildSkin( data ) {\n\n\t\t\t\tvar BONE_LIMIT = 4;\n\n\t\t\t\tvar build = {\n\t\t\t\t\tjoints: [], // this must be an array to preserve the joint order\n\t\t\t\t\tindices: {\n\t\t\t\t\t\tarray: [],\n\t\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t\t},\n\t\t\t\t\tweights: {\n\t\t\t\t\t\tarray: [],\n\t\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tvar sources = data.sources;\n\t\t\t\tvar vertexWeights = data.vertexWeights;\n\n\t\t\t\tvar vcount = vertexWeights.vcount;\n\t\t\t\tvar v = vertexWeights.v;\n\t\t\t\tvar jointOffset = vertexWeights.inputs.JOINT.offset;\n\t\t\t\tvar weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\n\t\t\t\tvar jointSource = data.sources[ data.joints.inputs.JOINT ];\n\t\t\t\tvar inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];\n\n\t\t\t\tvar weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;\n\t\t\t\tvar stride = 0;\n\n\t\t\t\tvar i, j, l;\n\n\t\t\t\t// procces skin data for each vertex\n\n\t\t\t\tfor ( i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex\n\t\t\t\t\tvar vertexSkinData = [];\n\n\t\t\t\t\tfor ( j = 0; j < jointCount; j ++ ) {\n\n\t\t\t\t\t\tvar skinIndex = v[ stride + jointOffset ];\n\t\t\t\t\t\tvar weightId = v[ stride + weightOffset ];\n\t\t\t\t\t\tvar skinWeight = weights[ weightId ];\n\n\t\t\t\t\t\tvertexSkinData.push( { index: skinIndex, weight: skinWeight } );\n\n\t\t\t\t\t\tstride += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// we sort the joints in descending order based on the weights.\n\t\t\t\t\t// this ensures, we only procced the most important joints of the vertex\n\n\t\t\t\t\tvertexSkinData.sort( descending );\n\n\t\t\t\t\t// now we provide for each vertex a set of four index and weight values.\n\t\t\t\t\t// the order of the skin data matches the order of vertices\n\n\t\t\t\t\tfor ( j = 0; j < BONE_LIMIT; j ++ ) {\n\n\t\t\t\t\t\tvar d = vertexSkinData[ j ];\n\n\t\t\t\t\t\tif ( d !== undefined ) {\n\n\t\t\t\t\t\t\tbuild.indices.array.push( d.index );\n\t\t\t\t\t\t\tbuild.weights.array.push( d.weight );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbuild.indices.array.push( 0 );\n\t\t\t\t\t\t\tbuild.weights.array.push( 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// setup bind matrix\n\n\t\t\t\tif ( data.bindShapeMatrix ) {\n\n\t\t\t\t\tbuild.bindMatrix = new THREE.Matrix4().fromArray( data.bindShapeMatrix ).transpose();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbuild.bindMatrix = new THREE.Matrix4().identity();\n\n\t\t\t\t}\n\n\t\t\t\t// process bones and inverse bind matrix data\n\n\t\t\t\tfor ( i = 0, l = jointSource.array.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar name = jointSource.array[ i ];\n\t\t\t\t\tvar boneInverse = new THREE.Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();\n\n\t\t\t\t\tbuild.joints.push( { name: name, boneInverse: boneInverse } );\n\n\t\t\t\t}\n\n\t\t\t\treturn build;\n\n\t\t\t\t// array sort function\n\n\t\t\t\tfunction descending( a, b ) {\n\n\t\t\t\t\treturn b.weight - a.weight;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getController( id ) {\n\n\t\t\t\treturn getBuild( library.controllers[ id ], buildController );\n\n\t\t\t}\n\n\t\t\t// image\n\n\t\t\tfunction parseImage( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tinit_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent\n\t\t\t\t};\n\n\t\t\t\tlibrary.images[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction buildImage( data ) {\n\n\t\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\t\treturn data.init_from;\n\n\t\t\t}\n\n\t\t\tfunction getImage( id ) {\n\n\t\t\t\tvar data = library.images[ id ];\n\n\t\t\t\tif ( data !== undefined ) {\n\n\t\t\t\t\treturn getBuild( data, buildImage );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find image with ID:', id );\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// effect\n\n\t\t\tfunction parseEffect( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'profile_COMMON':\n\t\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.effects[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectProfileCOMMON( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tsurfaces: {},\n\t\t\t\t\tsamplers: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'newparam':\n\t\t\t\t\t\t\tparseEffectNewparam( child, data );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\t\tdata.technique = parseEffectTechnique( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectNewparam( xml, data ) {\n\n\t\t\t\tvar sid = xml.getAttribute( 'sid' );\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'surface':\n\t\t\t\t\t\t\tdata.surfaces[ sid ] = parseEffectSurface( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'sampler2D':\n\t\t\t\t\t\t\tdata.samplers[ sid ] = parseEffectSampler( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseEffectSurface( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'init_from':\n\t\t\t\t\t\t\tdata.init_from = child.textContent;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectSampler( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'source':\n\t\t\t\t\t\t\tdata.source = child.textContent;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectTechnique( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'constant':\n\t\t\t\t\t\tcase 'lambert':\n\t\t\t\t\t\tcase 'blinn':\n\t\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\t\tdata.type = child.nodeName;\n\t\t\t\t\t\t\tdata.parameters = parseEffectParameters( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectParameters( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tcase 'ambient':\n\t\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectParameter( child );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\t\tdata[ child.nodeName ] = {\n\t\t\t\t\t\t\t\topaque: child.getAttribute( 'opaque' ),\n\t\t\t\t\t\t\t\tdata: parseEffectParameter( child )\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectParameter( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tdata[ child.nodeName ] = parseFloats( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'float':\n\t\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectParameterTexture( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\ttechnique: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\t\tparseEffectParameterTextureExtra( child, data );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectParameterTextureExtra( xml, data ) {\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique( child, data );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseEffectParameterTextureExtraTechnique( xml, data ) {\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'repeatU':\n\t\t\t\t\t\tcase 'repeatV':\n\t\t\t\t\t\tcase 'offsetU':\n\t\t\t\t\t\tcase 'offsetV':\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'wrapU':\n\t\t\t\t\t\tcase 'wrapV':\n\n\t\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\n\n\t\t\t\t\t\t\tif ( child.textContent.toUpperCase() === 'TRUE' ) {\n\n\t\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 1;\n\n\t\t\t\t\t\t\t} else if ( child.textContent.toUpperCase() === 'FALSE' ) {\n\n\t\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 0;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseInt( child.textContent );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseEffectExtra( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectExtraTechnique( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\t\tdata[ child.nodeName ] = parseInt( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction buildEffect( data ) {\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction getEffect( id ) {\n\n\t\t\t\treturn getBuild( library.effects[ id ], buildEffect );\n\n\t\t\t}\n\n\t\t\t// material\n\n\t\t\tfunction parseMaterial( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'instance_effect':\n\t\t\t\t\t\t\tdata.url = parseId( child.getAttribute( 'url' ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.materials[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction getTextureLoader( image ) {\n\n\t\t\t\tvar loader;\n\n\t\t\t\tvar extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/\n\t\t\t\textension = extension.toLowerCase();\n\n\t\t\t\tswitch ( extension ) {\n\n\t\t\t\t\tcase 'tga':\n\t\t\t\t\t\tloader = tgaLoader;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tloader = textureLoader;\n\n\t\t\t\t}\n\n\t\t\t\treturn loader;\n\n\t\t\t}\n\n\t\t\tfunction buildMaterial( data ) {\n\n\t\t\t\tvar effect = getEffect( data.url );\n\t\t\t\tvar technique = effect.profile.technique;\n\t\t\t\tvar extra = effect.profile.extra;\n\n\t\t\t\tvar material;\n\n\t\t\t\tswitch ( technique.type ) {\n\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\tcase 'blinn':\n\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmaterial = new THREE.MeshBasicMaterial();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.name = data.name || '';\n\n\t\t\t\tfunction getTexture( textureObject ) {\n\n\t\t\t\t\tvar sampler = effect.profile.samplers[ textureObject.id ];\n\t\t\t\t\tvar image = null;\n\n\t\t\t\t\t// get image\n\n\t\t\t\t\tif ( sampler !== undefined ) {\n\n\t\t\t\t\t\tvar surface = effect.profile.surfaces[ sampler.source ];\n\t\t\t\t\t\timage = getImage( surface.init_from );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );\n\t\t\t\t\t\timage = getImage( textureObject.id );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// create texture if image is avaiable\n\n\t\t\t\t\tif ( image !== null ) {\n\n\t\t\t\t\t\tvar loader = getTextureLoader( image );\n\n\t\t\t\t\t\tif ( loader !== undefined ) {\n\n\t\t\t\t\t\t\tvar texture = loader.load( image );\n\n\t\t\t\t\t\t\tvar extra = textureObject.extra;\n\n\t\t\t\t\t\t\tif ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {\n\n\t\t\t\t\t\t\t\tvar technique = extra.technique;\n\n\t\t\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n\t\t\t\t\t\t\t\ttexture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );\n\t\t\t\t\t\t\t\ttexture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn texture;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image );\n\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id );\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar parameters = technique.parameters;\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tvar parameter = parameters[ key ];\n\n\t\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\t\tif ( parameter.color ) material.color.fromArray( parameter.color );\n\t\t\t\t\t\t\tif ( parameter.texture ) material.map = getTexture( parameter.texture );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\t\tif ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );\n\t\t\t\t\t\t\tif ( parameter.texture ) material.specularMap = getTexture( parameter.texture );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\t\tif ( parameter.texture ) material.normalMap = getTexture( parameter.texture );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'ambient':\n\t\t\t\t\t\t\tif ( parameter.texture ) material.lightMap = getTexture( parameter.texture );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\t\tif ( parameter.float && material.shininess ) material.shininess = parameter.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\t\tif ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color );\n\t\t\t\t\t\t\tif ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar transparent = parameters[ 'transparent' ];\n\t\t\t\tvar transparency = parameters[ 'transparency' ];\n\n\t\t\t\t// <transparency> does not exist but <transparent>\n\n\t\t\t\tif ( transparency === undefined && transparent ) {\n\n\t\t\t\t\ttransparency = {\n\t\t\t\t\t\tfloat: 1\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\t// <transparent> does not exist but <transparency>\n\n\t\t\t\tif ( transparent === undefined && transparency ) {\n\n\t\t\t\t\ttransparent = {\n\t\t\t\t\t\topaque: 'A_ONE',\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tcolor: [ 1, 1, 1, 1 ]\n\t\t\t\t\t\t} };\n\n\t\t\t\t}\n\n\t\t\t\tif ( transparent && transparency ) {\n\n\t\t\t\t\t// handle case if a texture exists but no color\n\n\t\t\t\t\tif ( transparent.data.texture ) {\n\n\t\t\t\t\t\t// we do not set an alpha map (see #13792)\n\n\t\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar color = transparent.data.color;\n\n\t\t\t\t\t\tswitch ( transparent.opaque ) {\n\n\t\t\t\t\t\t\tcase 'A_ONE':\n\t\t\t\t\t\t\t\tmaterial.opacity = color[ 3 ] * transparency.float;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'RGB_ZERO':\n\t\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 0 ] * transparency.float );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'A_ZERO':\n\t\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 3 ] * transparency.float );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'RGB_ONE':\n\t\t\t\t\t\t\t\tmaterial.opacity = color[ 0 ] * transparency.float;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( material.opacity < 1 ) material.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tif ( extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1 ) {\n\n\t\t\t\t\tmaterial.side = THREE.DoubleSide;\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t\tfunction getMaterial( id ) {\n\n\t\t\t\treturn getBuild( library.materials[ id ], buildMaterial );\n\n\t\t\t}\n\n\t\t\t// camera\n\n\t\t\tfunction parseCamera( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'optics':\n\t\t\t\t\t\t\tdata.optics = parseCameraOptics( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.cameras[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parseCameraOptics( xml ) {\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\t\treturn parseCameraTechnique( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn {};\n\n\t\t\t}\n\n\t\t\tfunction parseCameraTechnique( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'perspective':\n\t\t\t\t\t\tcase 'orthographic':\n\n\t\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\t\tdata.parameters = parseCameraParameters( child );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseCameraParameters( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'xfov':\n\t\t\t\t\t\tcase 'yfov':\n\t\t\t\t\t\tcase 'xmag':\n\t\t\t\t\t\tcase 'ymag':\n\t\t\t\t\t\tcase 'znear':\n\t\t\t\t\t\tcase 'zfar':\n\t\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction buildCamera( data ) {\n\n\t\t\t\tvar camera;\n\n\t\t\t\tswitch ( data.optics.technique ) {\n\n\t\t\t\t\tcase 'perspective':\n\t\t\t\t\t\tcamera = new THREE.PerspectiveCamera(\n\t\t\t\t\t\t\tdata.optics.parameters.yfov,\n\t\t\t\t\t\t\tdata.optics.parameters.aspect_ratio,\n\t\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'orthographic':\n\t\t\t\t\t\tvar ymag = data.optics.parameters.ymag;\n\t\t\t\t\t\tvar xmag = data.optics.parameters.xmag;\n\t\t\t\t\t\tvar aspectRatio = data.optics.parameters.aspect_ratio;\n\n\t\t\t\t\t\txmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;\n\t\t\t\t\t\tymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;\n\n\t\t\t\t\t\txmag *= 0.5;\n\t\t\t\t\t\tymag *= 0.5;\n\n\t\t\t\t\t\tcamera = new THREE.OrthographicCamera(\n\t\t\t\t\t\t\t- xmag, xmag, ymag, - ymag, // left, right, top, bottom\n\t\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcamera = new THREE.PerspectiveCamera();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcamera.name = data.name || '';\n\n\t\t\t\treturn camera;\n\n\t\t\t}\n\n\t\t\tfunction getCamera( id ) {\n\n\t\t\t\tvar data = library.cameras[ id ];\n\n\t\t\t\tif ( data !== undefined ) {\n\n\t\t\t\t\treturn getBuild( data, buildCamera );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find camera with ID:', id );\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// light\n\n\t\t\tfunction parseLight( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\t\tdata = parseLightTechnique( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.lights[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parseLightTechnique( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'directional':\n\t\t\t\t\t\tcase 'point':\n\t\t\t\t\t\tcase 'spot':\n\t\t\t\t\t\tcase 'ambient':\n\n\t\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\t\tdata.parameters = parseLightParameters( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseLightParameters( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tdata.color = new THREE.Color().fromArray( array );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'falloff_angle':\n\t\t\t\t\t\t\tdata.falloffAngle = parseFloat( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'quadratic_attenuation':\n\t\t\t\t\t\t\tvar f = parseFloat( child.textContent );\n\t\t\t\t\t\t\tdata.distance = f ? Math.sqrt( 1 / f ) : 0;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction buildLight( data ) {\n\n\t\t\t\tvar light;\n\n\t\t\t\tswitch ( data.technique ) {\n\n\t\t\t\t\tcase 'directional':\n\t\t\t\t\t\tlight = new THREE.DirectionalLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'point':\n\t\t\t\t\t\tlight = new THREE.PointLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'spot':\n\t\t\t\t\t\tlight = new THREE.SpotLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\t\tlight = new THREE.AmbientLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.parameters.color ) light.color.copy( data.parameters.color );\n\t\t\t\tif ( data.parameters.distance ) light.distance = data.parameters.distance;\n\n\t\t\t\treturn light;\n\n\t\t\t}\n\n\t\t\tfunction getLight( id ) {\n\n\t\t\t\tvar data = library.lights[ id ];\n\n\t\t\t\tif ( data !== undefined ) {\n\n\t\t\t\t\treturn getBuild( data, buildLight );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find light with ID:', id );\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// geometry\n\n\t\t\tfunction parseGeometry( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\t\tsources: {},\n\t\t\t\t\tvertices: {},\n\t\t\t\t\tprimitives: []\n\t\t\t\t};\n\n\t\t\t\tvar mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];\n\n\t\t\t\t// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\t\t\t\tif ( mesh === undefined ) return;\n\n\t\t\t\tfor ( var i = 0; i < mesh.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = mesh.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tvar id = child.getAttribute( 'id' );\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'source':\n\t\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'vertices':\n\t\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n\t\t\t\t\t\t\tdata.vertices = parseGeometryVertices( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'polygons':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\t\tdata.primitives.push( parseGeometryPrimitive( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.geometries[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parseSource( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: 3\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'float_array':\n\t\t\t\t\t\t\tdata.array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Name_array':\n\t\t\t\t\t\t\tdata.array = parseStrings( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\t\tvar accessor = getElementsByTagName( child, 'accessor' )[ 0 ];\n\n\t\t\t\t\t\t\tif ( accessor !== undefined ) {\n\n\t\t\t\t\t\t\t\tdata.stride = parseInt( accessor.getAttribute( 'stride' ) );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseGeometryVertices( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tdata[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseGeometryPrimitive( xml ) {\n\n\t\t\t\tvar primitive = {\n\t\t\t\t\ttype: xml.nodeName,\n\t\t\t\t\tmaterial: xml.getAttribute( 'material' ),\n\t\t\t\t\tcount: parseInt( xml.getAttribute( 'count' ) ),\n\t\t\t\t\tinputs: {},\n\t\t\t\t\tstride: 0,\n\t\t\t\t\thasUV: false\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'input':\n\t\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\t\tvar offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\t\tvar set = parseInt( child.getAttribute( 'set' ) );\n\t\t\t\t\t\t\tvar inputname = ( set > 0 ? semantic + set : semantic );\n\t\t\t\t\t\t\tprimitive.inputs[ inputname ] = { id: id, offset: offset };\n\t\t\t\t\t\t\tprimitive.stride = Math.max( primitive.stride, offset + 1 );\n\t\t\t\t\t\t\tif ( semantic === 'TEXCOORD' ) primitive.hasUV = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\t\tprimitive.vcount = parseInts( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'p':\n\t\t\t\t\t\t\tprimitive.p = parseInts( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn primitive;\n\n\t\t\t}\n\n\t\t\tfunction groupPrimitives( primitives ) {\n\n\t\t\t\tvar build = {};\n\n\t\t\t\tfor ( var i = 0; i < primitives.length; i ++ ) {\n\n\t\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\t\tif ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];\n\n\t\t\t\t\tbuild[ primitive.type ].push( primitive );\n\n\t\t\t\t}\n\n\t\t\t\treturn build;\n\n\t\t\t}\n\n\t\t\tfunction checkUVCoordinates( primitives ) {\n\n\t\t\t\tvar count = 0;\n\n\t\t\t\tfor ( var i = 0, l = primitives.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\t\tif ( primitive.hasUV === true ) {\n\n\t\t\t\t\t\tcount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( count > 0 && count < primitives.length ) {\n\n\t\t\t\t\tprimitives.uvsNeedsFix = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction buildGeometry( data ) {\n\n\t\t\t\tvar build = {};\n\n\t\t\t\tvar sources = data.sources;\n\t\t\t\tvar vertices = data.vertices;\n\t\t\t\tvar primitives = data.primitives;\n\n\t\t\t\tif ( primitives.length === 0 ) return {};\n\n\t\t\t\t// our goal is to create one buffer geometry for a single type of primitives\n\t\t\t\t// first, we group all primitives by their type\n\n\t\t\t\tvar groupedPrimitives = groupPrimitives( primitives );\n\n\t\t\t\tfor ( var type in groupedPrimitives ) {\n\n\t\t\t\t\tvar primitiveType = groupedPrimitives[ type ];\n\n\t\t\t\t\t// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n\t\t\t\t\tcheckUVCoordinates( primitiveType );\n\n\t\t\t\t\t// third, create a buffer geometry for each type of primitives\n\n\t\t\t\t\tbuild[ type ] = buildGeometryType( primitiveType, sources, vertices );\n\n\t\t\t\t}\n\n\t\t\t\treturn build;\n\n\t\t\t}\n\n\t\t\tfunction buildGeometryType( primitives, sources, vertices ) {\n\n\t\t\t\tvar build = {};\n\n\t\t\t\tvar position = { array: [], stride: 0 };\n\t\t\t\tvar normal = { array: [], stride: 0 };\n\t\t\t\tvar uv = { array: [], stride: 0 };\n\t\t\t\tvar uv2 = { array: [], stride: 0 };\n\t\t\t\tvar color = { array: [], stride: 0 };\n\n\t\t\t\tvar skinIndex = { array: [], stride: 4 };\n\t\t\t\tvar skinWeight = { array: [], stride: 4 };\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\tvar materialKeys = [];\n\n\t\t\t\tvar start = 0;\n\n\t\t\t\tfor ( var p = 0; p < primitives.length; p ++ ) {\n\n\t\t\t\t\tvar primitive = primitives[ p ];\n\t\t\t\t\tvar inputs = primitive.inputs;\n\n\t\t\t\t\t// groups\n\n\t\t\t\t\tvar count = 0;\n\n\t\t\t\t\tswitch ( primitive.type ) {\n\n\t\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\t\tcount = primitive.count * 2;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\t\tcount = primitive.count * 3;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'polylist':\n\n\t\t\t\t\t\t\tfor ( var g = 0; g < primitive.count; g ++ ) {\n\n\t\t\t\t\t\t\t\tvar vc = primitive.vcount[ g ];\n\n\t\t\t\t\t\t\t\tswitch ( vc ) {\n\n\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\tcount += 3; // single triangle\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t\tcount += 6; // quad, subdivided into two triangles\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tcount += ( vc - 2 ) * 3; // polylist with more than four vertices\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknow primitive type:', primitive.type );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.addGroup( start, count, p );\n\t\t\t\t\tstart += count;\n\n\t\t\t\t\t// material\n\n\t\t\t\t\tif ( primitive.material ) {\n\n\t\t\t\t\t\tmaterialKeys.push( primitive.material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// geometry data\n\n\t\t\t\t\tfor ( var name in inputs ) {\n\n\t\t\t\t\t\tvar input = inputs[ name ];\n\n\t\t\t\t\t\tswitch ( name )\t{\n\n\t\t\t\t\t\t\tcase 'VERTEX':\n\t\t\t\t\t\t\t\tfor ( var key in vertices ) {\n\n\t\t\t\t\t\t\t\t\tvar id = vertices[ key ];\n\n\t\t\t\t\t\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'POSITION':\n\t\t\t\t\t\t\t\t\t\t\tvar prevLength = position.array.length;\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, position.array );\n\t\t\t\t\t\t\t\t\t\t\tposition.stride = sources[ id ].stride;\n\n\t\t\t\t\t\t\t\t\t\t\tif ( sources.skinWeights && sources.skinIndices ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );\n\t\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// see #3803\n\n\t\t\t\t\t\t\t\t\t\t\tif ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar count = ( position.array.length - prevLength ) / position.stride;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// fill missing uv coordinates\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tuv.array.push( 0, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, normal.array );\n\t\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, color.array );\n\t\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv.array );\n\t\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv2.array );\n\t\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );\n\t\t\t\t\t\t\t\tnormal.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, color.array );\n\t\t\t\t\t\t\t\tcolor.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );\n\t\t\t\t\t\t\t\tuv.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv2.array );\n\t\t\t\t\t\t\t\tuv2.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// build geometry\n\n\t\t\t\tif ( position.array.length > 0 ) geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( position.array, position.stride ) );\n\t\t\t\tif ( normal.array.length > 0 ) geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normal.array, normal.stride ) );\n\t\t\t\tif ( color.array.length > 0 ) geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( color.array, color.stride ) );\n\t\t\t\tif ( uv.array.length > 0 ) geometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uv.array, uv.stride ) );\n\t\t\t\tif ( uv2.array.length > 0 ) geometry.setAttribute( 'uv2', new THREE.Float32BufferAttribute( uv2.array, uv2.stride ) );\n\n\t\t\t\tif ( skinIndex.array.length > 0 ) geometry.setAttribute( 'skinIndex', new THREE.Float32BufferAttribute( skinIndex.array, skinIndex.stride ) );\n\t\t\t\tif ( skinWeight.array.length > 0 ) geometry.setAttribute( 'skinWeight', new THREE.Float32BufferAttribute( skinWeight.array, skinWeight.stride ) );\n\n\t\t\t\tbuild.data = geometry;\n\t\t\t\tbuild.type = primitives[ 0 ].type;\n\t\t\t\tbuild.materialKeys = materialKeys;\n\n\t\t\t\treturn build;\n\n\t\t\t}\n\n\t\t\tfunction buildGeometryData( primitive, source, offset, array ) {\n\n\t\t\t\tvar indices = primitive.p;\n\t\t\t\tvar stride = primitive.stride;\n\t\t\t\tvar vcount = primitive.vcount;\n\n\t\t\t\tfunction pushVector( i ) {\n\n\t\t\t\t\tvar index = indices[ i + offset ] * sourceStride;\n\t\t\t\t\tvar length = index + sourceStride;\n\n\t\t\t\t\tfor ( ; index < length; index ++ ) {\n\n\t\t\t\t\t\tarray.push( sourceArray[ index ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar sourceArray = source.array;\n\t\t\t\tvar sourceStride = source.stride;\n\n\t\t\t\tif ( primitive.vcount !== undefined ) {\n\n\t\t\t\t\tvar index = 0;\n\n\t\t\t\t\tfor ( var i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar count = vcount[ i ];\n\n\t\t\t\t\t\tif ( count === 4 ) {\n\n\t\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\t\tvar c = index + stride * 2;\n\t\t\t\t\t\t\tvar d = index + stride * 3;\n\n\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( d );\n\t\t\t\t\t\t\tpushVector( b ); pushVector( c ); pushVector( d );\n\n\t\t\t\t\t\t} else if ( count === 3 ) {\n\n\t\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\t\tvar c = index + stride * 2;\n\n\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t\t} else if ( count > 4 ) {\n\n\t\t\t\t\t\t\tfor ( var k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {\n\n\t\t\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\t\t\tvar b = index + stride * k;\n\t\t\t\t\t\t\t\tvar c = index + stride * ( k + 1 );\n\n\t\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tindex += stride * count;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += stride ) {\n\n\t\t\t\t\t\tpushVector( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getGeometry( id ) {\n\n\t\t\t\treturn getBuild( library.geometries[ id ], buildGeometry );\n\n\t\t\t}\n\n\t\t\t// kinematics\n\n\t\t\tfunction parseKinematicsModel( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\t\tjoints: {},\n\t\t\t\t\tlinks: []\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\t\tparseKinematicsTechniqueCommon( child, data );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction buildKinematicsModel( data ) {\n\n\t\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction getKinematicsModel( id ) {\n\n\t\t\t\treturn getBuild( library.kinematicsModels[ id ], buildKinematicsModel );\n\n\t\t\t}\n\n\t\t\tfunction parseKinematicsTechniqueCommon( xml, data ) {\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'joint':\n\t\t\t\t\t\t\tdata.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'link':\n\t\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseKinematicsJoint( xml ) {\n\n\t\t\t\tvar data;\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\tdata = parseKinematicsJointParameter( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseKinematicsJointParameter( xml, data ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\t\taxis: new THREE.Vector3(),\n\t\t\t\t\tlimits: {\n\t\t\t\t\t\tmin: 0,\n\t\t\t\t\t\tmax: 0\n\t\t\t\t\t},\n\t\t\t\t\ttype: xml.nodeName,\n\t\t\t\t\tstatic: false,\n\t\t\t\t\tzeroPosition: 0,\n\t\t\t\t\tmiddlePosition: 0\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tdata.axis.fromArray( array );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'limits':\n\t\t\t\t\t\t\tvar max = child.getElementsByTagName( 'max' )[ 0 ];\n\t\t\t\t\t\t\tvar min = child.getElementsByTagName( 'min' )[ 0 ];\n\n\t\t\t\t\t\t\tdata.limits.max = parseFloat( max.textContent );\n\t\t\t\t\t\t\tdata.limits.min = parseFloat( min.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// if min is equal to or greater than max, consider the joint static\n\n\t\t\t\tif ( data.limits.min >= data.limits.max ) {\n\n\t\t\t\t\tdata.static = true;\n\n\t\t\t\t}\n\n\t\t\t\t// calculate middle position\n\n\t\t\t\tdata.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseKinematicsLink( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\t\tattachments: [],\n\t\t\t\t\ttransforms: []\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'attachment_full':\n\t\t\t\t\t\t\tdata.attachments.push( parseKinematicsAttachment( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseKinematicsAttachment( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tjoint: xml.getAttribute( 'joint' ).split( '/' ).pop(),\n\t\t\t\t\ttransforms: [],\n\t\t\t\t\tlinks: []\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'link':\n\t\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseKinematicsTransform( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\ttype: xml.nodeName\n\t\t\t\t};\n\n\t\t\t\tvar array = parseFloats( xml.textContent );\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tdata.obj = new THREE.Matrix4();\n\t\t\t\t\t\tdata.obj.fromArray( array ).transpose();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tdata.obj = new THREE.Vector3();\n\t\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.obj = new THREE.Vector3();\n\t\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\t\tdata.angle = THREE.MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\t// physics\n\n\t\t\tfunction parsePhysicsModel( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\t\trigidBodies: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'rigid_body':\n\t\t\t\t\t\t\tdata.rigidBodies[ child.getAttribute( 'name' ) ] = {};\n\t\t\t\t\t\t\tparsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.physicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parsePhysicsRigidBody( xml, data ) {\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\t\tparsePhysicsTechniqueCommon( child, data );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parsePhysicsTechniqueCommon( xml, data ) {\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'inertia':\n\t\t\t\t\t\t\tdata.inertia = parseFloats( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'mass':\n\t\t\t\t\t\t\tdata.mass = parseFloats( child.textContent )[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// scene\n\n\t\t\tfunction parseKinematicsScene( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tbindJointAxis: []\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'bind_joint_axis':\n\t\t\t\t\t\t\tdata.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parseKinematicsBindJointAxis( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\ttarget: xml.getAttribute( 'target' ).split( '/' ).pop()\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\t\tvar param = child.getElementsByTagName( 'param' )[ 0 ];\n\t\t\t\t\t\t\tdata.axis = param.textContent;\n\t\t\t\t\t\t\tvar tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];\n\t\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substr( 0, tmpJointIndex.length - 1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction buildKinematicsScene( data ) {\n\n\t\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction getKinematicsScene( id ) {\n\n\t\t\t\treturn getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );\n\n\t\t\t}\n\n\t\t\tfunction setupKinematics() {\n\n\t\t\t\tvar kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];\n\t\t\t\tvar kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];\n\t\t\t\tvar visualSceneId = Object.keys( library.visualScenes )[ 0 ];\n\n\t\t\t\tif ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;\n\n\t\t\t\tvar kinematicsModel = getKinematicsModel( kinematicsModelId );\n\t\t\t\tvar kinematicsScene = getKinematicsScene( kinematicsSceneId );\n\t\t\t\tvar visualScene = getVisualScene( visualSceneId );\n\n\t\t\t\tvar bindJointAxis = kinematicsScene.bindJointAxis;\n\t\t\t\tvar jointMap = {};\n\n\t\t\t\tfor ( var i = 0, l = bindJointAxis.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar axis = bindJointAxis[ i ];\n\n\t\t\t\t\t// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n\t\t\t\t\tvar targetElement = collada.querySelector( '[sid=\"' + axis.target + '\"]' );\n\n\t\t\t\t\tif ( targetElement ) {\n\n\t\t\t\t\t\t// get the parent of the transfrom element\n\n\t\t\t\t\t\tvar parentVisualElement = targetElement.parentElement;\n\n\t\t\t\t\t\t// connect the joint of the kinematics model with the element in the visual scene\n\n\t\t\t\t\t\tconnect( axis.jointIndex, parentVisualElement );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfunction connect( jointIndex, visualElement ) {\n\n\t\t\t\t\tvar visualElementName = visualElement.getAttribute( 'name' );\n\t\t\t\t\tvar joint = kinematicsModel.joints[ jointIndex ];\n\n\t\t\t\t\tvisualScene.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.name === visualElementName ) {\n\n\t\t\t\t\t\t\tjointMap[ jointIndex ] = {\n\t\t\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\t\t\ttransforms: buildTransformList( visualElement ),\n\t\t\t\t\t\t\t\tjoint: joint,\n\t\t\t\t\t\t\t\tposition: joint.zeroPosition\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tvar m0 = new THREE.Matrix4();\n\n\t\t\t\tkinematics = {\n\n\t\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\n\n\t\t\t\t\tgetJointValue: function ( jointIndex ) {\n\n\t\t\t\t\t\tvar jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\t\treturn jointData.position;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\n\t\t\t\t\tsetJointValue: function ( jointIndex, value ) {\n\n\t\t\t\t\t\tvar jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\t\tvar joint = jointData.joint;\n\n\t\t\t\t\t\t\tif ( value > joint.limits.max || value < joint.limits.min ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );\n\n\t\t\t\t\t\t\t} else if ( joint.static ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar object = jointData.object;\n\t\t\t\t\t\t\t\tvar axis = joint.axis;\n\t\t\t\t\t\t\t\tvar transforms = jointData.transforms;\n\n\t\t\t\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t\t\t\t\t// each update, we have to apply all transforms in the correct order\n\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < transforms.length; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar transform = transforms[ i ];\n\n\t\t\t\t\t\t\t\t\t// if there is a connection of the transform node with a joint, apply the joint value\n\n\t\t\t\t\t\t\t\t\tif ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {\n\n\t\t\t\t\t\t\t\t\t\tswitch ( joint.type ) {\n\n\t\t\t\t\t\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( axis, THREE.MathUtils.degToRad( value ) ) );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tswitch ( transform.type ) {\n\n\t\t\t\t\t\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.scale( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tobject.matrix.copy( matrix );\n\t\t\t\t\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t\t\t\t\tjointMap[ jointIndex ].position = value;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction buildTransformList( node ) {\n\n\t\t\t\tvar transforms = [];\n\n\t\t\t\tvar xml = collada.querySelector( '[id=\"' + node.id + '\"]' );\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tvar matrix = new THREE.Matrix4().fromArray( array ).transpose();\n\t\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\t\tobj: matrix\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tvar vector = new THREE.Vector3().fromArray( array );\n\t\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\t\tobj: vector\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tvar vector = new THREE.Vector3().fromArray( array );\n\t\t\t\t\t\t\tvar angle = THREE.MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\t\tobj: vector,\n\t\t\t\t\t\t\t\tangle: angle\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn transforms;\n\n\t\t\t}\n\n\t\t\t// nodes\n\n\t\t\tfunction prepareNodes( xml ) {\n\n\t\t\t\tvar elements = xml.getElementsByTagName( 'node' );\n\n\t\t\t\t// ensure all node elements have id attributes\n\n\t\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\tvar element = elements[ i ];\n\n\t\t\t\t\tif ( element.hasAttribute( 'id' ) === false ) {\n\n\t\t\t\t\t\telement.setAttribute( 'id', generateId() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\tvar vector = new THREE.Vector3();\n\n\t\t\tfunction parseNode( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\t\ttype: xml.getAttribute( 'type' ),\n\t\t\t\t\tid: xml.getAttribute( 'id' ),\n\t\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\t\tmatrix: new THREE.Matrix4(),\n\t\t\t\t\tnodes: [],\n\t\t\t\t\tinstanceCameras: [],\n\t\t\t\t\tinstanceControllers: [],\n\t\t\t\t\tinstanceLights: [],\n\t\t\t\t\tinstanceGeometries: [],\n\t\t\t\t\tinstanceNodes: [],\n\t\t\t\t\ttransforms: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'node':\n\t\t\t\t\t\t\tdata.nodes.push( child.getAttribute( 'id' ) );\n\t\t\t\t\t\t\tparseNode( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'instance_camera':\n\t\t\t\t\t\t\tdata.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'instance_controller':\n\t\t\t\t\t\t\tdata.instanceControllers.push( parseNodeInstance( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'instance_light':\n\t\t\t\t\t\t\tdata.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'instance_geometry':\n\t\t\t\t\t\t\tdata.instanceGeometries.push( parseNodeInstance( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'instance_node':\n\t\t\t\t\t\t\tdata.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tdata.matrix.multiply( matrix.fromArray( array ).transpose() );\n\t\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tvector.fromArray( array );\n\t\t\t\t\t\t\tdata.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );\n\t\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tvar angle = THREE.MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\t\tdata.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );\n\t\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tdata.matrix.scale( vector.fromArray( array ) );\n\t\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasNode( data.id ) ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlibrary.nodes[ data.id ] = data;\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseNodeInstance( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tid: parseId( xml.getAttribute( 'url' ) ),\n\t\t\t\t\tmaterials: {},\n\t\t\t\t\tskeletons: []\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'bind_material':\n\t\t\t\t\t\t\tvar instances = child.getElementsByTagName( 'instance_material' );\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < instances.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar instance = instances[ j ];\n\t\t\t\t\t\t\t\tvar symbol = instance.getAttribute( 'symbol' );\n\t\t\t\t\t\t\t\tvar target = instance.getAttribute( 'target' );\n\n\t\t\t\t\t\t\t\tdata.materials[ symbol ] = parseId( target );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'skeleton':\n\t\t\t\t\t\t\tdata.skeletons.push( parseId( child.textContent ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction buildSkeleton( skeletons, joints ) {\n\n\t\t\t\tvar boneData = [];\n\t\t\t\tvar sortedBoneData = [];\n\n\t\t\t\tvar i, j, data;\n\n\t\t\t\t// a skeleton can have multiple root bones. collada expresses this\n\t\t\t\t// situtation with multiple \"skeleton\" tags per controller instance\n\n\t\t\t\tfor ( i = 0; i < skeletons.length; i ++ ) {\n\n\t\t\t\t\tvar skeleton = skeletons[ i ];\n\n\t\t\t\t\tvar root;\n\n\t\t\t\t\tif ( hasNode( skeleton ) ) {\n\n\t\t\t\t\t\troot = getNode( skeleton );\n\t\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t\t} else if ( hasVisualScene( skeleton ) ) {\n\n\t\t\t\t\t\t// handle case where the skeleton refers to the visual scene (#13335)\n\n\t\t\t\t\t\tvar visualScene = library.visualScenes[ skeleton ];\n\t\t\t\t\t\tvar children = visualScene.children;\n\n\t\t\t\t\t\tfor ( var j = 0; j < children.length; j ++ ) {\n\n\t\t\t\t\t\t\tvar child = children[ j ];\n\n\t\t\t\t\t\t\tif ( child.type === 'JOINT' ) {\n\n\t\t\t\t\t\t\t\tvar root = getNode( child.id );\n\t\t\t\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// sort bone data (the order is defined in the corresponding controller)\n\n\t\t\t\tfor ( i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\t\tfor ( j = 0; j < boneData.length; j ++ ) {\n\n\t\t\t\t\t\tdata = boneData[ j ];\n\n\t\t\t\t\t\tif ( data.bone.name === joints[ i ].name ) {\n\n\t\t\t\t\t\t\tsortedBoneData[ i ] = data;\n\t\t\t\t\t\t\tdata.processed = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// add unprocessed bone data at the end of the list\n\n\t\t\t\tfor ( i = 0; i < boneData.length; i ++ ) {\n\n\t\t\t\t\tdata = boneData[ i ];\n\n\t\t\t\t\tif ( data.processed === false ) {\n\n\t\t\t\t\t\tsortedBoneData.push( data );\n\t\t\t\t\t\tdata.processed = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// setup arrays for skeleton creation\n\n\t\t\t\tvar bones = [];\n\t\t\t\tvar boneInverses = [];\n\n\t\t\t\tfor ( i = 0; i < sortedBoneData.length; i ++ ) {\n\n\t\t\t\t\tdata = sortedBoneData[ i ];\n\n\t\t\t\t\tbones.push( data.bone );\n\t\t\t\t\tboneInverses.push( data.boneInverse );\n\n\t\t\t\t}\n\n\t\t\t\treturn new THREE.Skeleton( bones, boneInverses );\n\n\t\t\t}\n\n\t\t\tfunction buildBoneHierarchy( root, joints, boneData ) {\n\n\t\t\t\t// setup bone data from visual scene\n\n\t\t\t\troot.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.isBone === true ) {\n\n\t\t\t\t\t\tvar boneInverse;\n\n\t\t\t\t\t\t// retrieve the boneInverse from the controller data\n\n\t\t\t\t\t\tfor ( var i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\t\t\t\tvar joint = joints[ i ];\n\n\t\t\t\t\t\t\tif ( joint.name === object.name ) {\n\n\t\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( boneInverse === undefined ) {\n\n\t\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\n\t\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\n\t\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\n\t\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n\t\t\t\t\t\t\t// ensure a correct animation of the model.\n\n\t\t\t\t\t\t\tboneInverse = new THREE.Matrix4();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tboneData.push( { bone: object, boneInverse: boneInverse, processed: false } );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction buildNode( data ) {\n\n\t\t\t\tvar objects = [];\n\n\t\t\t\tvar matrix = data.matrix;\n\t\t\t\tvar nodes = data.nodes;\n\t\t\t\tvar type = data.type;\n\t\t\t\tvar instanceCameras = data.instanceCameras;\n\t\t\t\tvar instanceControllers = data.instanceControllers;\n\t\t\t\tvar instanceLights = data.instanceLights;\n\t\t\t\tvar instanceGeometries = data.instanceGeometries;\n\t\t\t\tvar instanceNodes = data.instanceNodes;\n\n\t\t\t\t// nodes\n\n\t\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tobjects.push( getNode( nodes[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\t// instance cameras\n\n\t\t\t\tfor ( var i = 0, l = instanceCameras.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar instanceCamera = getCamera( instanceCameras[ i ] );\n\n\t\t\t\t\tif ( instanceCamera !== null ) {\n\n\t\t\t\t\t\tobjects.push( instanceCamera.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// instance controllers\n\n\t\t\t\tfor ( var i = 0, l = instanceControllers.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar instance = instanceControllers[ i ];\n\t\t\t\t\tvar controller = getController( instance.id );\n\t\t\t\t\tvar geometries = getGeometry( controller.id );\n\t\t\t\t\tvar newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\t\tvar skeletons = instance.skeletons;\n\t\t\t\t\tvar joints = controller.skin.joints;\n\n\t\t\t\t\tvar skeleton = buildSkeleton( skeletons, joints );\n\n\t\t\t\t\tfor ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar object = newObjects[ j ];\n\n\t\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\t\tobject.bind( skeleton, controller.skin.bindMatrix );\n\t\t\t\t\t\t\tobject.normalizeSkinWeights();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// instance lights\n\n\t\t\t\tfor ( var i = 0, l = instanceLights.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar instanceLight = getLight( instanceLights[ i ] );\n\n\t\t\t\t\tif ( instanceLight !== null ) {\n\n\t\t\t\t\t\tobjects.push( instanceLight.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// instance geometries\n\n\t\t\t\tfor ( var i = 0, l = instanceGeometries.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar instance = instanceGeometries[ i ];\n\n\t\t\t\t\t// a single geometry instance in collada can lead to multiple object3Ds.\n\t\t\t\t\t// this is the case when primitives are combined like triangles and lines\n\n\t\t\t\t\tvar geometries = getGeometry( instance.id );\n\t\t\t\t\tvar newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\t\tfor ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tobjects.push( newObjects[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// instance nodes\n\n\t\t\t\tfor ( var i = 0, l = instanceNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tobjects.push( getNode( instanceNodes[ i ] ).clone() );\n\n\t\t\t\t}\n\n\t\t\t\tvar object;\n\n\t\t\t\tif ( nodes.length === 0 && objects.length === 1 ) {\n\n\t\t\t\t\tobject = objects[ 0 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject = ( type === 'JOINT' ) ? new THREE.Bone() : new THREE.Group();\n\n\t\t\t\t\tfor ( var i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\t\tobject.add( objects[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.name === '' ) {\n\n\t\t\t\t\tobject.name = ( type === 'JOINT' ) ? data.sid : data.name;\n\n\t\t\t\t}\n\n\t\t\t\tobject.matrix.copy( matrix );\n\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t\tvar fallbackMaterial = new THREE.MeshBasicMaterial( { color: 0xff00ff } );\n\n\t\t\tfunction resolveMaterialBinding( keys, instanceMaterials ) {\n\n\t\t\t\tvar materials = [];\n\n\t\t\t\tfor ( var i = 0, l = keys.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar id = instanceMaterials[ keys[ i ] ];\n\n\t\t\t\t\tif ( id === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );\n\t\t\t\t\t\tmaterials.push( fallbackMaterial );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( getMaterial( id ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn materials;\n\n\t\t\t}\n\n\t\t\tfunction buildObjects( geometries, instanceMaterials ) {\n\n\t\t\t\tvar objects = [];\n\n\t\t\t\tfor ( var type in geometries ) {\n\n\t\t\t\t\tvar geometry = geometries[ type ];\n\n\t\t\t\t\tvar materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );\n\n\t\t\t\t\t// handle case if no materials are defined\n\n\t\t\t\t\tif ( materials.length === 0 ) {\n\n\t\t\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\n\n\t\t\t\t\t\t\tmaterials.push( new THREE.LineBasicMaterial() );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmaterials.push( new THREE.MeshPhongMaterial() );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// regard skinning\n\n\t\t\t\t\tvar skinning = ( geometry.data.attributes.skinIndex !== undefined );\n\n\t\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tmaterials[ i ].skinning = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// choose between a single or multi materials (material array)\n\n\t\t\t\t\tvar material = ( materials.length === 1 ) ? materials[ 0 ] : materials;\n\n\t\t\t\t\t// now create a specific 3D object\n\n\t\t\t\t\tvar object;\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\t\tobject = new THREE.LineSegments( geometry.data, material );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\t\tobject = new THREE.Line( geometry.data, material );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry.data, material );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry.data, material );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t}\n\n\t\t\t\treturn objects;\n\n\t\t\t}\n\n\t\t\tfunction hasNode( id ) {\n\n\t\t\t\treturn library.nodes[ id ] !== undefined;\n\n\t\t\t}\n\n\t\t\tfunction getNode( id ) {\n\n\t\t\t\treturn getBuild( library.nodes[ id ], buildNode );\n\n\t\t\t}\n\n\t\t\t// visual scenes\n\n\t\t\tfunction parseVisualScene( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\t\tchildren: []\n\t\t\t\t};\n\n\t\t\t\tprepareNodes( xml );\n\n\t\t\t\tvar elements = getElementsByTagName( xml, 'node' );\n\n\t\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\tdata.children.push( parseNode( elements[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.visualScenes[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction buildVisualScene( data ) {\n\n\t\t\t\tvar group = new THREE.Group();\n\t\t\t\tgroup.name = data.name;\n\n\t\t\t\tvar children = data.children;\n\n\t\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tvar child = children[ i ];\n\n\t\t\t\t\tgroup.add( getNode( child.id ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn group;\n\n\t\t\t}\n\n\t\t\tfunction hasVisualScene( id ) {\n\n\t\t\t\treturn library.visualScenes[ id ] !== undefined;\n\n\t\t\t}\n\n\t\t\tfunction getVisualScene( id ) {\n\n\t\t\t\treturn getBuild( library.visualScenes[ id ], buildVisualScene );\n\n\t\t\t}\n\n\t\t\t// scenes\n\n\t\t\tfunction parseScene( xml ) {\n\n\t\t\t\tvar instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];\n\t\t\t\treturn getVisualScene( parseId( instance.getAttribute( 'url' ) ) );\n\n\t\t\t}\n\n\t\t\tfunction setupAnimations() {\n\n\t\t\t\tvar clips = library.clips;\n\n\t\t\t\tif ( isEmpty( clips ) === true ) {\n\n\t\t\t\t\tif ( isEmpty( library.animations ) === false ) {\n\n\t\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\n\n\t\t\t\t\t\tvar tracks = [];\n\n\t\t\t\t\t\tfor ( var id in library.animations ) {\n\n\t\t\t\t\t\t\tvar animationTracks = getAnimation( id );\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = animationTracks.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\ttracks.push( animationTracks[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tanimations.push( new THREE.AnimationClip( 'default', - 1, tracks ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var id in clips ) {\n\n\t\t\t\t\t\tanimations.push( getAnimationClip( id ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// convert the parser error element into text with each child elements text\n\t\t\t// separated by new lines.\n\n\t\t\tfunction parserErrorToText( parserError ) {\n\n\t\t\t\tvar result = '';\n\t\t\t\tvar stack = [ parserError ];\n\n\t\t\t\twhile ( stack.length ) {\n\n\t\t\t\t\tvar node = stack.shift();\n\n\t\t\t\t\tif ( node.nodeType === Node.TEXT_NODE ) {\n\n\t\t\t\t\t\tresult += node.textContent;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tresult += '\\n';\n\t\t\t\t\t\tstack.push.apply( stack, node.childNodes );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn result.trim();\n\n\t\t\t}\n\n\t\t\tif ( text.length === 0 ) {\n\n\t\t\t\treturn { scene: new THREE.Scene() };\n\n\t\t\t}\n\n\t\t\tvar xml = new DOMParser().parseFromString( text, 'application/xml' );\n\n\t\t\tvar collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];\n\n\t\t\tvar parserError = xml.getElementsByTagName( 'parsererror' )[ 0 ];\n\t\t\tif ( parserError !== undefined ) {\n\n\t\t\t\t// Chrome will return parser error with a div in it\n\n\t\t\t\tvar errorElement = getElementsByTagName( parserError, 'div' )[ 0 ];\n\t\t\t\tvar errorText;\n\n\t\t\t\tif ( errorElement ) {\n\n\t\t\t\t\terrorText = errorElement.textContent;\n\n\t\t\t\t} else {\n\n\t\t\t\t\terrorText = parserErrorToText( parserError );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.error( 'THREE.ColladaLoader: Failed to parse collada file.\\n', errorText );\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// metadata\n\n\t\t\tvar version = collada.getAttribute( 'version' );\n\t\t\tconsole.log( 'THREE.ColladaLoader: File version', version );\n\n\t\t\tvar asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );\n\t\t\tvar textureLoader = new THREE.TextureLoader( this.manager );\n\t\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar tgaLoader;\n\n\t\t\tif ( THREE.TGALoader ) {\n\n\t\t\t\ttgaLoader = new THREE.TGALoader( this.manager );\n\t\t\t\ttgaLoader.setPath( this.resourcePath || path );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar animations = [];\n\t\t\tvar kinematics = {};\n\t\t\tvar count = 0;\n\n\t\t\t//\n\n\t\t\tvar library = {\n\t\t\t\tanimations: {},\n\t\t\t\tclips: {},\n\t\t\t\tcontrollers: {},\n\t\t\t\timages: {},\n\t\t\t\teffects: {},\n\t\t\t\tmaterials: {},\n\t\t\t\tcameras: {},\n\t\t\t\tlights: {},\n\t\t\t\tgeometries: {},\n\t\t\t\tnodes: {},\n\t\t\t\tvisualScenes: {},\n\t\t\t\tkinematicsModels: {},\n\t\t\t\tphysicsModels: {},\n\t\t\t\tkinematicsScenes: {}\n\t\t\t};\n\n\t\t\tparseLibrary( collada, 'library_animations', 'animation', parseAnimation );\n\t\t\tparseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );\n\t\t\tparseLibrary( collada, 'library_controllers', 'controller', parseController );\n\t\t\tparseLibrary( collada, 'library_images', 'image', parseImage );\n\t\t\tparseLibrary( collada, 'library_effects', 'effect', parseEffect );\n\t\t\tparseLibrary( collada, 'library_materials', 'material', parseMaterial );\n\t\t\tparseLibrary( collada, 'library_cameras', 'camera', parseCamera );\n\t\t\tparseLibrary( collada, 'library_lights', 'light', parseLight );\n\t\t\tparseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );\n\t\t\tparseLibrary( collada, 'library_nodes', 'node', parseNode );\n\t\t\tparseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );\n\t\t\tparseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );\n\t\t\tparseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );\n\t\t\tparseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );\n\n\t\t\tbuildLibrary( library.animations, buildAnimation );\n\t\t\tbuildLibrary( library.clips, buildAnimationClip );\n\t\t\tbuildLibrary( library.controllers, buildController );\n\t\t\tbuildLibrary( library.images, buildImage );\n\t\t\tbuildLibrary( library.effects, buildEffect );\n\t\t\tbuildLibrary( library.materials, buildMaterial );\n\t\t\tbuildLibrary( library.cameras, buildCamera );\n\t\t\tbuildLibrary( library.lights, buildLight );\n\t\t\tbuildLibrary( library.geometries, buildGeometry );\n\t\t\tbuildLibrary( library.visualScenes, buildVisualScene );\n\n\t\t\tsetupAnimations();\n\t\t\tsetupKinematics();\n\n\t\t\tvar scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );\n\n\t\t\tif ( asset.upAxis === 'Z_UP' ) {\n\n\t\t\t\tscene.quaternion.setFromEuler( new THREE.Euler( - Math.PI / 2, 0, 0 ) );\n\n\t\t\t}\n\n\t\t\tscene.scale.multiplyScalar( asset.unit );\n\n\t\t\treturn {\n\t\t\t\tanimations: animations,\n\t\t\t\tkinematics: kinematics,\n\t\t\t\tlibrary: library,\n\t\t\t\tscene: scene\n\t\t\t};\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.ColladaLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/DRACOLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Don McCurdy / https://www.donmccurdy.com\n\t */\n\n\tTHREE.DRACOLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.decoderPath = '';\n\t\tthis.decoderConfig = {};\n\t\tthis.decoderBinary = null;\n\t\tthis.decoderPending = null;\n\n\t\tthis.workerLimit = 4;\n\t\tthis.workerPool = [];\n\t\tthis.workerNextTaskID = 1;\n\t\tthis.workerSourceURL = '';\n\n\t\tthis.defaultAttributeIDs = {\n\t\t\tposition: 'POSITION',\n\t\t\tnormal: 'NORMAL',\n\t\t\tcolor: 'COLOR',\n\t\t\tuv: 'TEX_COORD'\n\t\t};\n\t\tthis.defaultAttributeTypes = {\n\t\t\tposition: 'Float32Array',\n\t\t\tnormal: 'Float32Array',\n\t\t\tcolor: 'Float32Array',\n\t\t\tuv: 'Float32Array'\n\t\t};\n\n\t};\n\n\tTHREE.DRACOLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.DRACOLoader,\n\n\t\tsetDecoderPath: function ( path ) {\n\n\t\t\tthis.decoderPath = path;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetDecoderConfig: function ( config ) {\n\n\t\t\tthis.decoderConfig = config;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWorkerLimit: function ( workerLimit ) {\n\n\t\t\tthis.workerLimit = workerLimit;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t/** @deprecated */\n\t\tsetVerbosity: function () {\n\n\t\t\tconsole.warn( 'THREE.DRACOLoader: The .setVerbosity() method has been removed.' );\n\n\t\t},\n\n\t\t/** @deprecated */\n\t\tsetDrawMode: function () {\n\n\t\t\tconsole.warn( 'THREE.DRACOLoader: The .setDrawMode() method has been removed.' );\n\n\t\t},\n\n\t\t/** @deprecated */\n\t\tsetSkipDequantization: function () {\n\n\t\t\tconsole.warn( 'THREE.DRACOLoader: The .setSkipDequantization() method has been removed.' );\n\n\t\t},\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tif ( this.crossOrigin === 'use-credentials' ) {\n\n\t\t\t\tloader.setWithCredentials( true );\n\n\t\t\t}\n\n\t\t\tloader.load( url, ( buffer ) => {\n\n\t\t\t\tvar taskConfig = {\n\t\t\t\t\tattributeIDs: this.defaultAttributeIDs,\n\t\t\t\t\tattributeTypes: this.defaultAttributeTypes,\n\t\t\t\t\tuseUniqueIDs: false\n\t\t\t\t};\n\n\t\t\t\tthis.decodeGeometry( buffer, taskConfig )\n\t\t\t\t\t.then( onLoad )\n\t\t\t\t\t.catch( onError );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\t/** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n\t\tdecodeDracoFile: function ( buffer, callback, attributeIDs, attributeTypes ) {\n\n\t\t\tvar taskConfig = {\n\t\t\t\tattributeIDs: attributeIDs || this.defaultAttributeIDs,\n\t\t\t\tattributeTypes: attributeTypes || this.defaultAttributeTypes,\n\t\t\t\tuseUniqueIDs: !! attributeIDs\n\t\t\t};\n\n\t\t\tthis.decodeGeometry( buffer, taskConfig ).then( callback );\n\n\t\t},\n\n\t\tdecodeGeometry: function ( buffer, taskConfig ) {\n\n\t\t\t// TODO: For backward-compatibility, support 'attributeTypes' objects containing\n\t\t\t// references (rather than names) to typed array constructors. These must be\n\t\t\t// serialized before sending them to the worker.\n\t\t\tfor ( var attribute in taskConfig.attributeTypes ) {\n\n\t\t\t\tvar type = taskConfig.attributeTypes[ attribute ];\n\n\t\t\t\tif ( type.BYTES_PER_ELEMENT !== undefined ) {\n\n\t\t\t\t\ttaskConfig.attributeTypes[ attribute ] = type.name;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar taskKey = JSON.stringify( taskConfig );\n\n\t\t\t// Check for an existing task using this buffer. A transferred buffer cannot be transferred\n\t\t\t// again from this thread.\n\t\t\tif ( THREE.DRACOLoader.taskCache.has( buffer ) ) {\n\n\t\t\t\tvar cachedTask = THREE.DRACOLoader.taskCache.get( buffer );\n\n\t\t\t\tif ( cachedTask.key === taskKey ) {\n\n\t\t\t\t\treturn cachedTask.promise;\n\n\t\t\t\t} else if ( buffer.byteLength === 0 ) {\n\n\t\t\t\t\t// Technically, it would be possible to wait for the previous task to complete,\n\t\t\t\t\t// transfer the buffer back, and decode again with the second configuration. That\n\t\t\t\t\t// is complex, and I don't know of any reason to decode a Draco buffer twice in\n\t\t\t\t\t// different ways, so this is left unimplemented.\n\t\t\t\t\tthrow new Error(\n\n\t\t\t\t\t\t'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n\t\t\t\t\t\t'settings. Buffer has already been transferred.'\n\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar worker;\n\t\t\tvar taskID = this.workerNextTaskID ++;\n\t\t\tvar taskCost = buffer.byteLength;\n\n\t\t\t// Obtain a worker and assign a task, and construct a geometry instance\n\t\t\t// when the task completes.\n\t\t\tvar geometryPending = this._getWorker( taskID, taskCost )\n\t\t\t\t.then( ( _worker ) => {\n\n\t\t\t\t\tworker = _worker;\n\n\t\t\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\t\t\tworker._callbacks[ taskID ] = { resolve, reject };\n\n\t\t\t\t\t\tworker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );\n\n\t\t\t\t\t\t// this.debug();\n\n\t\t\t\t\t} );\n\n\t\t\t\t} )\n\t\t\t\t.then( ( message ) => this._createGeometry( message.geometry ) );\n\n\t\t\t// Remove task from the task list.\n\t\t\tgeometryPending\n\t\t\t\t.finally( () => {\n\n\t\t\t\t\tif ( worker && taskID ) {\n\n\t\t\t\t\t\tthis._releaseTask( worker, taskID );\n\n\t\t\t\t\t\t// this.debug();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t// Cache the task result.\n\t\t\tTHREE.DRACOLoader.taskCache.set( buffer, {\n\n\t\t\t\tkey: taskKey,\n\t\t\t\tpromise: geometryPending\n\n\t\t\t} );\n\n\t\t\treturn geometryPending;\n\n\t\t},\n\n\t\t_createGeometry: function ( geometryData ) {\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tif ( geometryData.index ) {\n\n\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( geometryData.index.array, 1 ) );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < geometryData.attributes.length; i ++ ) {\n\n\t\t\t\tvar attribute = geometryData.attributes[ i ];\n\t\t\t\tvar name = attribute.name;\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tgeometry.setAttribute( name, new THREE.BufferAttribute( array, itemSize ) );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t},\n\n\t\t_loadLibrary: function ( url, responseType ) {\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setPath( this.decoderPath );\n\t\t\tloader.setResponseType( responseType );\n\n\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\tloader.load( url, resolve, undefined, reject );\n\n\t\t\t} );\n\n\t\t},\n\n\t\tpreload: function () {\n\n\t\t\tthis._initDecoder();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t_initDecoder: function () {\n\n\t\t\tif ( this.decoderPending ) return this.decoderPending;\n\n\t\t\tvar useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n\t\t\tvar librariesPending = [];\n\n\t\t\tif ( useJS ) {\n\n\t\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );\n\n\t\t\t} else {\n\n\t\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );\n\t\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );\n\n\t\t\t}\n\n\t\t\tthis.decoderPending = Promise.all( librariesPending )\n\t\t\t\t.then( ( libraries ) => {\n\n\t\t\t\t\tvar jsContent = libraries[ 0 ];\n\n\t\t\t\t\tif ( ! useJS ) {\n\n\t\t\t\t\t\tthis.decoderConfig.wasmBinary = libraries[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar fn = THREE.DRACOLoader.DRACOWorker.toString();\n\n\t\t\t\t\tvar body = [\n\t\t\t\t\t\t'/* draco decoder */',\n\t\t\t\t\t\tjsContent,\n\t\t\t\t\t\t'',\n\t\t\t\t\t\t'/* worker */',\n\t\t\t\t\t\tfn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )\n\t\t\t\t\t].join( '\\n' );\n\n\t\t\t\t\tthis.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );\n\n\t\t\t\t} );\n\n\t\t\treturn this.decoderPending;\n\n\t\t},\n\n\t\t_getWorker: function ( taskID, taskCost ) {\n\n\t\t\treturn this._initDecoder().then( () => {\n\n\t\t\t\tif ( this.workerPool.length < this.workerLimit ) {\n\n\t\t\t\t\tvar worker = new Worker( this.workerSourceURL );\n\n\t\t\t\t\tworker._callbacks = {};\n\t\t\t\t\tworker._taskCosts = {};\n\t\t\t\t\tworker._taskLoad = 0;\n\n\t\t\t\t\tworker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );\n\n\t\t\t\t\tworker.onmessage = function ( e ) {\n\n\t\t\t\t\t\tvar message = e.data;\n\n\t\t\t\t\t\tswitch ( message.type ) {\n\n\t\t\t\t\t\t\tcase 'decode':\n\t\t\t\t\t\t\t\tworker._callbacks[ message.id ].resolve( message );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'error':\n\t\t\t\t\t\t\t\tworker._callbacks[ message.id ].reject( message );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\n\t\t\t\t\tthis.workerPool.push( worker );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.workerPool.sort( function ( a, b ) {\n\n\t\t\t\t\t\treturn a._taskLoad > b._taskLoad ? - 1 : 1;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tvar worker = this.workerPool[ this.workerPool.length - 1 ];\n\t\t\t\tworker._taskCosts[ taskID ] = taskCost;\n\t\t\t\tworker._taskLoad += taskCost;\n\t\t\t\treturn worker;\n\n\t\t\t} );\n\n\t\t},\n\n\t\t_releaseTask: function ( worker, taskID ) {\n\n\t\t\tworker._taskLoad -= worker._taskCosts[ taskID ];\n\t\t\tdelete worker._callbacks[ taskID ];\n\t\t\tdelete worker._taskCosts[ taskID ];\n\n\t\t},\n\n\t\tdebug: function () {\n\n\t\t\tconsole.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tfor ( var i = 0; i < this.workerPool.length; ++ i ) {\n\n\t\t\t\tthis.workerPool[ i ].terminate();\n\n\t\t\t}\n\n\t\t\tthis.workerPool.length = 0;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/* WEB WORKER */\n\n\tTHREE.DRACOLoader.DRACOWorker = function () {\n\n\t\tvar decoderConfig;\n\t\tvar decoderPending;\n\n\t\tonmessage = function ( e ) {\n\n\t\t\tvar message = e.data;\n\n\t\t\tswitch ( message.type ) {\n\n\t\t\t\tcase 'init':\n\t\t\t\t\tdecoderConfig = message.decoderConfig;\n\t\t\t\t\tdecoderPending = new Promise( function ( resolve/*, reject*/ ) {\n\n\t\t\t\t\t\tdecoderConfig.onModuleLoaded = function ( draco ) {\n\n\t\t\t\t\t\t\t// Module is Promise-like. Wrap before resolving to avoid loop.\n\t\t\t\t\t\t\tresolve( { draco: draco } );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tDracoDecoderModule( decoderConfig );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'decode':\n\t\t\t\t\tvar buffer = message.buffer;\n\t\t\t\t\tvar taskConfig = message.taskConfig;\n\t\t\t\t\tdecoderPending.then( ( module ) => {\n\n\t\t\t\t\t\tvar draco = module.draco;\n\t\t\t\t\t\tvar decoder = new draco.Decoder();\n\t\t\t\t\t\tvar decoderBuffer = new draco.DecoderBuffer();\n\t\t\t\t\t\tdecoderBuffer.Init( new Int8Array( buffer ), buffer.byteLength );\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\tvar geometry = decodeGeometry( draco, decoder, decoderBuffer, taskConfig );\n\n\t\t\t\t\t\t\tvar buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );\n\n\t\t\t\t\t\t\tif ( geometry.index ) buffers.push( geometry.index.array.buffer );\n\n\t\t\t\t\t\t\tself.postMessage( { type: 'decode', id: message.id, geometry }, buffers );\n\n\t\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\t\t\tself.postMessage( { type: 'error', id: message.id, error: error.message } );\n\n\t\t\t\t\t\t} finally {\n\n\t\t\t\t\t\t\tdraco.destroy( decoderBuffer );\n\t\t\t\t\t\t\tdraco.destroy( decoder );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction decodeGeometry( draco, decoder, decoderBuffer, taskConfig ) {\n\n\t\t\tvar attributeIDs = taskConfig.attributeIDs;\n\t\t\tvar attributeTypes = taskConfig.attributeTypes;\n\n\t\t\tvar dracoGeometry;\n\t\t\tvar decodingStatus;\n\n\t\t\tvar geometryType = decoder.GetEncodedGeometryType( decoderBuffer );\n\n\t\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\t\tdracoGeometry = new draco.Mesh();\n\t\t\t\tdecodingStatus = decoder.DecodeBufferToMesh( decoderBuffer, dracoGeometry );\n\n\t\t\t} else if ( geometryType === draco.POINT_CLOUD ) {\n\n\t\t\t\tdracoGeometry = new draco.PointCloud();\n\t\t\t\tdecodingStatus = decoder.DecodeBufferToPointCloud( decoderBuffer, dracoGeometry );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );\n\n\t\t\t}\n\n\t\t\tif ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );\n\n\t\t\t}\n\n\t\t\tvar geometry = { index: null, attributes: [] };\n\n\t\t\t// Gather all vertex attributes.\n\t\t\tfor ( var attributeName in attributeIDs ) {\n\n\t\t\t\tvar attributeType = self[ attributeTypes[ attributeName ] ];\n\n\t\t\t\tvar attribute;\n\t\t\t\tvar attributeID;\n\n\t\t\t\t// A Draco file may be created with default vertex attributes, whose attribute IDs\n\t\t\t\t// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n\t\t\t\t// a Draco file may contain a custom set of attributes, identified by known unique\n\t\t\t\t// IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\t\t\t\tif ( taskConfig.useUniqueIDs ) {\n\n\t\t\t\t\tattributeID = attributeIDs[ attributeName ];\n\t\t\t\t\tattribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tattributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );\n\n\t\t\t\t\tif ( attributeID === - 1 ) continue;\n\n\t\t\t\t\tattribute = decoder.GetAttribute( dracoGeometry, attributeID );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.attributes.push( decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) );\n\n\t\t\t}\n\n\t\t\t// Add index.\n\t\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\t\t// Generate mesh faces.\n\t\t\t\tvar numFaces = dracoGeometry.num_faces();\n\t\t\t\tvar numIndices = numFaces * 3;\n\t\t\t\tvar index = new Uint32Array( numIndices );\n\t\t\t\tvar indexArray = new draco.DracoInt32Array();\n\n\t\t\t\tfor ( var i = 0; i < numFaces; ++ i ) {\n\n\t\t\t\t\tdecoder.GetFaceFromMesh( dracoGeometry, i, indexArray );\n\n\t\t\t\t\tfor ( var j = 0; j < 3; ++ j ) {\n\n\t\t\t\t\t\tindex[ i * 3 + j ] = indexArray.GetValue( j );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.index = { array: index, itemSize: 1 };\n\n\t\t\t\tdraco.destroy( indexArray );\n\n\t\t\t}\n\n\t\t\tdraco.destroy( dracoGeometry );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {\n\n\t\t\tvar numComponents = attribute.num_components();\n\t\t\tvar numPoints = dracoGeometry.num_points();\n\t\t\tvar numValues = numPoints * numComponents;\n\t\t\tvar dracoArray;\n\n\t\t\tvar array;\n\n\t\t\tswitch ( attributeType ) {\n\n\t\t\t\tcase Float32Array:\n\t\t\t\t\tdracoArray = new draco.DracoFloat32Array();\n\t\t\t\t\tdecoder.GetAttributeFloatForAllPoints( dracoGeometry, attribute, dracoArray );\n\t\t\t\t\tarray = new Float32Array( numValues );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int8Array:\n\t\t\t\t\tdracoArray = new draco.DracoInt8Array();\n\t\t\t\t\tdecoder.GetAttributeInt8ForAllPoints( dracoGeometry, attribute, dracoArray );\n\t\t\t\t\tarray = new Int8Array( numValues );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int16Array:\n\t\t\t\t\tdracoArray = new draco.DracoInt16Array();\n\t\t\t\t\tdecoder.GetAttributeInt16ForAllPoints( dracoGeometry, attribute, dracoArray );\n\t\t\t\t\tarray = new Int16Array( numValues );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int32Array:\n\t\t\t\t\tdracoArray = new draco.DracoInt32Array();\n\t\t\t\t\tdecoder.GetAttributeInt32ForAllPoints( dracoGeometry, attribute, dracoArray );\n\t\t\t\t\tarray = new Int32Array( numValues );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint8Array:\n\t\t\t\t\tdracoArray = new draco.DracoUInt8Array();\n\t\t\t\t\tdecoder.GetAttributeUInt8ForAllPoints( dracoGeometry, attribute, dracoArray );\n\t\t\t\t\tarray = new Uint8Array( numValues );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint16Array:\n\t\t\t\t\tdracoArray = new draco.DracoUInt16Array();\n\t\t\t\t\tdecoder.GetAttributeUInt16ForAllPoints( dracoGeometry, attribute, dracoArray );\n\t\t\t\t\tarray = new Uint16Array( numValues );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint32Array:\n\t\t\t\t\tdracoArray = new draco.DracoUInt32Array();\n\t\t\t\t\tdecoder.GetAttributeUInt32ForAllPoints( dracoGeometry, attribute, dracoArray );\n\t\t\t\t\tarray = new Uint32Array( numValues );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'THREE.DRACOLoader: Unexpected attribute type.' );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < numValues; i ++ ) {\n\n\t\t\t\tarray[ i ] = dracoArray.GetValue( i );\n\n\t\t\t}\n\n\t\t\tdraco.destroy( dracoArray );\n\n\t\t\treturn {\n\t\t\t\tname: attributeName,\n\t\t\t\tarray: array,\n\t\t\t\titemSize: numComponents\n\t\t\t};\n\n\t\t}\n\n\t};\n\n\tTHREE.DRACOLoader.taskCache = new WeakMap();\n\n\t/** Deprecated static methods */\n\n\t/** @deprecated */\n\tTHREE.DRACOLoader.setDecoderPath = function () {\n\n\t\tconsole.warn( 'THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.' );\n\n\t};\n\n\t/** @deprecated */\n\tTHREE.DRACOLoader.setDecoderConfig = function () {\n\n\t\tconsole.warn( 'THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.' );\n\n\t};\n\n\t/** @deprecated */\n\tTHREE.DRACOLoader.releaseDecoderModule = function () {\n\n\t\tconsole.warn( 'THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.' );\n\n\t};\n\n\t/** @deprecated */\n\tTHREE.DRACOLoader.getDecoderModule = function () {\n\n\t\tconsole.warn( 'THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.' );\n\n\t};\n\t\n\treturn THREE.DRACOLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/FBXLoader',[\n\t\"skylark-threejs\",\n\t\"../curves/NURBSCurve\"\n],function(THREE,NURBSCurve,Zlib){\n\t/**\n\t * @author Kyle-Larson https://github.com/Kyle-Larson\n\t * @author Takahiro https://github.com/takahirox\n\t * @author Lewy Blue https://github.com/looeee\n\t *\n\t * Loader loads FBX file and generates Group representing FBX scene.\n\t * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n\t * Versions lower than this may load but will probably have errors\n\t *\n\t * Needs Support:\n\t *  Morph normals / blend shape normals\n\t *\n\t * FBX format references:\n\t * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\n\t * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n\t *\n\t * \tBinary format specification:\n\t *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n\t */\n\n\n\tTHREE.FBXLoader = ( function () {\n\n\t\tvar fbxTree;\n\t\tvar connections;\n\t\tvar sceneGraph;\n\n\t\tfunction FBXLoader( manager ) {\n\n\t\t\tTHREE.Loader.call( this, manager );\n\n\t\t}\n\n\t\tFBXLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\t\tconstructor: FBXLoader,\n\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar self = this;\n\n\t\t\t\tvar path = ( self.path === '' ) ? THREE.LoaderUtils.extractUrlBase( url ) : self.path;\n\n\t\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\t\tloader.setPath( self.path );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tonLoad( self.parse( buffer, path ) );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\t\t\tself.manager.itemError( url );\n\n\t\t\t\t\t\t}, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t},\n\n\t\t\tparse: function ( FBXBuffer, path ) {\n\n\t\t\t\tif ( isFbxFormatBinary( FBXBuffer ) ) {\n\n\t\t\t\t\tfbxTree = new BinaryParser().parse( FBXBuffer );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar FBXText = convertArrayBufferToString( FBXBuffer );\n\n\t\t\t\t\tif ( ! isFbxFormatASCII( FBXText ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown format.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( getFbxVersion( FBXText ) < 7000 ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfbxTree = new TextParser().parse( FBXText );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( fbxTree );\n\n\t\t\t\tvar textureLoader = new THREE.TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\t\treturn new FBXTreeParser( textureLoader, this.manager ).parse( fbxTree );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Parse the FBXTree object returned by the BinaryParser or TextParser and return a THREE.Group\n\t\tfunction FBXTreeParser( textureLoader, manager ) {\n\n\t\t\tthis.textureLoader = textureLoader;\n\t\t\tthis.manager = manager;\n\n\t\t}\n\n\t\tFBXTreeParser.prototype = {\n\n\t\t\tconstructor: FBXTreeParser,\n\n\t\t\tparse: function () {\n\n\t\t\t\tconnections = this.parseConnections();\n\n\t\t\t\tvar images = this.parseImages();\n\t\t\t\tvar textures = this.parseTextures( images );\n\t\t\t\tvar materials = this.parseMaterials( textures );\n\t\t\t\tvar deformers = this.parseDeformers();\n\t\t\t\tvar geometryMap = new GeometryParser().parse( deformers );\n\n\t\t\t\tthis.parseScene( deformers, geometryMap, materials );\n\n\t\t\t\treturn sceneGraph;\n\n\t\t\t},\n\n\t\t\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n\t\t\t// and details the connection type\n\t\t\tparseConnections: function () {\n\n\t\t\t\tvar connectionMap = new Map();\n\n\t\t\t\tif ( 'Connections' in fbxTree ) {\n\n\t\t\t\t\tvar rawConnections = fbxTree.Connections.connections;\n\n\t\t\t\t\trawConnections.forEach( function ( rawConnection ) {\n\n\t\t\t\t\t\tvar fromID = rawConnection[ 0 ];\n\t\t\t\t\t\tvar toID = rawConnection[ 1 ];\n\t\t\t\t\t\tvar relationship = rawConnection[ 2 ];\n\n\t\t\t\t\t\tif ( ! connectionMap.has( fromID ) ) {\n\n\t\t\t\t\t\t\tconnectionMap.set( fromID, {\n\t\t\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\t\t\tchildren: []\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar parentRelationship = { ID: toID, relationship: relationship };\n\t\t\t\t\t\tconnectionMap.get( fromID ).parents.push( parentRelationship );\n\n\t\t\t\t\t\tif ( ! connectionMap.has( toID ) ) {\n\n\t\t\t\t\t\t\tconnectionMap.set( toID, {\n\t\t\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\t\t\tchildren: []\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar childRelationship = { ID: fromID, relationship: relationship };\n\t\t\t\t\t\tconnectionMap.get( toID ).children.push( childRelationship );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\treturn connectionMap;\n\n\t\t\t},\n\n\t\t\t// Parse FBXTree.Objects.Video for embedded image data\n\t\t\t// These images are connected to textures in FBXTree.Objects.Textures\n\t\t\t// via FBXTree.Connections.\n\t\t\tparseImages: function () {\n\n\t\t\t\tvar images = {};\n\t\t\t\tvar blobs = {};\n\n\t\t\t\tif ( 'Video' in fbxTree.Objects ) {\n\n\t\t\t\t\tvar videoNodes = fbxTree.Objects.Video;\n\n\t\t\t\t\tfor ( var nodeID in videoNodes ) {\n\n\t\t\t\t\t\tvar videoNode = videoNodes[ nodeID ];\n\n\t\t\t\t\t\tvar id = parseInt( nodeID );\n\n\t\t\t\t\t\timages[ id ] = videoNode.RelativeFilename || videoNode.Filename;\n\n\t\t\t\t\t\t// raw image data is in videoNode.Content\n\t\t\t\t\t\tif ( 'Content' in videoNode ) {\n\n\t\t\t\t\t\t\tvar arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );\n\t\t\t\t\t\t\tvar base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );\n\n\t\t\t\t\t\t\tif ( arrayBufferContent || base64Content ) {\n\n\t\t\t\t\t\t\t\tvar image = this.parseImage( videoNodes[ nodeID ] );\n\n\t\t\t\t\t\t\t\tblobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var id in images ) {\n\n\t\t\t\t\tvar filename = images[ id ];\n\n\t\t\t\t\tif ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];\n\t\t\t\t\telse images[ id ] = images[ id ].split( '\\\\' ).pop();\n\n\t\t\t\t}\n\n\t\t\t\treturn images;\n\n\t\t\t},\n\n\t\t\t// Parse embedded image data in FBXTree.Video.Content\n\t\t\tparseImage: function ( videoNode ) {\n\n\t\t\t\tvar content = videoNode.Content;\n\t\t\t\tvar fileName = videoNode.RelativeFilename || videoNode.Filename;\n\t\t\t\tvar extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();\n\n\t\t\t\tvar type;\n\n\t\t\t\tswitch ( extension ) {\n\n\t\t\t\t\tcase 'bmp':\n\n\t\t\t\t\t\ttype = 'image/bmp';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'jpg':\n\t\t\t\t\tcase 'jpeg':\n\n\t\t\t\t\t\ttype = 'image/jpeg';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'png':\n\n\t\t\t\t\t\ttype = 'image/png';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'tif':\n\n\t\t\t\t\t\ttype = 'image/tiff';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'tga':\n\n\t\t\t\t\t\tif ( this.manager.getHandler( '.tga' ) === null ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'FBXLoader: TGA loader not found, skipping ', fileName );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttype = 'image/tga';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.warn( 'FBXLoader: Image type \"' + extension + '\" is not supported.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( typeof content === 'string' ) { // ASCII format\n\n\t\t\t\t\treturn 'data:' + type + ';base64,' + content;\n\n\t\t\t\t} else { // Binary Format\n\n\t\t\t\t\tvar array = new Uint8Array( content );\n\t\t\t\t\treturn window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t// Parse nodes in FBXTree.Objects.Texture\n\t\t\t// These contain details such as UV scaling, cropping, rotation etc and are connected\n\t\t\t// to images in FBXTree.Objects.Video\n\t\t\tparseTextures: function ( images ) {\n\n\t\t\t\tvar textureMap = new Map();\n\n\t\t\t\tif ( 'Texture' in fbxTree.Objects ) {\n\n\t\t\t\t\tvar textureNodes = fbxTree.Objects.Texture;\n\t\t\t\t\tfor ( var nodeID in textureNodes ) {\n\n\t\t\t\t\t\tvar texture = this.parseTexture( textureNodes[ nodeID ], images );\n\t\t\t\t\t\ttextureMap.set( parseInt( nodeID ), texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn textureMap;\n\n\t\t\t},\n\n\t\t\t// Parse individual node in FBXTree.Objects.Texture\n\t\t\tparseTexture: function ( textureNode, images ) {\n\n\t\t\t\tvar texture = this.loadTexture( textureNode, images );\n\n\t\t\t\ttexture.ID = textureNode.id;\n\n\t\t\t\ttexture.name = textureNode.attrName;\n\n\t\t\t\tvar wrapModeU = textureNode.WrapModeU;\n\t\t\t\tvar wrapModeV = textureNode.WrapModeV;\n\n\t\t\t\tvar valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n\t\t\t\tvar valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n\t\t\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n\t\t\t\t// 0: repeat(default), 1: clamp\n\n\t\t\t\ttexture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n\t\t\t\tif ( 'Scaling' in textureNode ) {\n\n\t\t\t\t\tvar values = textureNode.Scaling.value;\n\n\t\t\t\t\ttexture.repeat.x = values[ 0 ];\n\t\t\t\t\ttexture.repeat.y = values[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\treturn texture;\n\n\t\t\t},\n\n\t\t\t// load a texture specified as a blob or data URI, or via an external URL using THREE.TextureLoader\n\t\t\tloadTexture: function ( textureNode, images ) {\n\n\t\t\t\tvar fileName;\n\n\t\t\t\tvar currentPath = this.textureLoader.path;\n\n\t\t\t\tvar children = connections.get( textureNode.id ).children;\n\n\t\t\t\tif ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {\n\n\t\t\t\t\tfileName = images[ children[ 0 ].ID ];\n\n\t\t\t\t\tif ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\t\t\tthis.textureLoader.setPath( undefined );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar texture;\n\n\t\t\t\tvar extension = textureNode.FileName.slice( - 3 ).toLowerCase();\n\n\t\t\t\tif ( extension === 'tga' ) {\n\n\t\t\t\t\tvar loader = this.manager.getHandler( '.tga' );\n\n\t\t\t\t\tif ( loader === null ) {\n\n\t\t\t\t\t\tconsole.warn( 'FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename );\n\t\t\t\t\t\ttexture = new THREE.Texture();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture = loader.load( fileName );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( extension === 'psd' ) {\n\n\t\t\t\t\tconsole.warn( 'FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename );\n\t\t\t\t\ttexture = new THREE.Texture();\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture = this.textureLoader.load( fileName );\n\n\t\t\t\t}\n\n\t\t\t\tthis.textureLoader.setPath( currentPath );\n\n\t\t\t\treturn texture;\n\n\t\t\t},\n\n\t\t\t// Parse nodes in FBXTree.Objects.Material\n\t\t\tparseMaterials: function ( textureMap ) {\n\n\t\t\t\tvar materialMap = new Map();\n\n\t\t\t\tif ( 'Material' in fbxTree.Objects ) {\n\n\t\t\t\t\tvar materialNodes = fbxTree.Objects.Material;\n\n\t\t\t\t\tfor ( var nodeID in materialNodes ) {\n\n\t\t\t\t\t\tvar material = this.parseMaterial( materialNodes[ nodeID ], textureMap );\n\n\t\t\t\t\t\tif ( material !== null ) materialMap.set( parseInt( nodeID ), material );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn materialMap;\n\n\t\t\t},\n\n\t\t\t// Parse single node in FBXTree.Objects.Material\n\t\t\t// Materials are connected to texture maps in FBXTree.Objects.Textures\n\t\t\t// FBX format currently only supports Lambert and Phong shading models\n\t\t\tparseMaterial: function ( materialNode, textureMap ) {\n\n\t\t\t\tvar ID = materialNode.id;\n\t\t\t\tvar name = materialNode.attrName;\n\t\t\t\tvar type = materialNode.ShadingModel;\n\n\t\t\t\t// Case where FBX wraps shading model in property object.\n\t\t\t\tif ( typeof type === 'object' ) {\n\n\t\t\t\t\ttype = type.value;\n\n\t\t\t\t}\n\n\t\t\t\t// Ignore unused materials which don't have any connections.\n\t\t\t\tif ( ! connections.has( ID ) ) return null;\n\n\t\t\t\tvar parameters = this.parseParameters( materialNode, textureMap, ID );\n\n\t\t\t\tvar material;\n\n\t\t\t\tswitch ( type.toLowerCase() ) {\n\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type );\n\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.setValues( parameters );\n\t\t\t\tmaterial.name = name;\n\n\t\t\t\treturn material;\n\n\t\t\t},\n\n\t\t\t// Parse FBX material and return parameters suitable for a three.js material\n\t\t\t// Also parse the texture map and return any textures associated with the material\n\t\t\tparseParameters: function ( materialNode, textureMap, ID ) {\n\n\t\t\t\tvar parameters = {};\n\n\t\t\t\tif ( materialNode.BumpFactor ) {\n\n\t\t\t\t\tparameters.bumpScale = materialNode.BumpFactor.value;\n\n\t\t\t\t}\n\t\t\t\tif ( materialNode.Diffuse ) {\n\n\t\t\t\t\tparameters.color = new THREE.Color().fromArray( materialNode.Diffuse.value );\n\n\t\t\t\t} else if ( materialNode.DiffuseColor && materialNode.DiffuseColor.type === 'Color' ) {\n\n\t\t\t\t\t// The blender exporter exports diffuse here instead of in materialNode.Diffuse\n\t\t\t\t\tparameters.color = new THREE.Color().fromArray( materialNode.DiffuseColor.value );\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialNode.DisplacementFactor ) {\n\n\t\t\t\t\tparameters.displacementScale = materialNode.DisplacementFactor.value;\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialNode.Emissive ) {\n\n\t\t\t\t\tparameters.emissive = new THREE.Color().fromArray( materialNode.Emissive.value );\n\n\t\t\t\t} else if ( materialNode.EmissiveColor && materialNode.EmissiveColor.type === 'Color' ) {\n\n\t\t\t\t\t// The blender exporter exports emissive color here instead of in materialNode.Emissive\n\t\t\t\t\tparameters.emissive = new THREE.Color().fromArray( materialNode.EmissiveColor.value );\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialNode.EmissiveFactor ) {\n\n\t\t\t\t\tparameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value );\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialNode.Opacity ) {\n\n\t\t\t\t\tparameters.opacity = parseFloat( materialNode.Opacity.value );\n\n\t\t\t\t}\n\n\t\t\t\tif ( parameters.opacity < 1.0 ) {\n\n\t\t\t\t\tparameters.transparent = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialNode.ReflectionFactor ) {\n\n\t\t\t\t\tparameters.reflectivity = materialNode.ReflectionFactor.value;\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialNode.Shininess ) {\n\n\t\t\t\t\tparameters.shininess = materialNode.Shininess.value;\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialNode.Specular ) {\n\n\t\t\t\t\tparameters.specular = new THREE.Color().fromArray( materialNode.Specular.value );\n\n\t\t\t\t} else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {\n\n\t\t\t\t\t// The blender exporter exports specular color here instead of in materialNode.Specular\n\t\t\t\t\tparameters.specular = new THREE.Color().fromArray( materialNode.SpecularColor.value );\n\n\t\t\t\t}\n\n\t\t\t\tvar self = this;\n\t\t\t\tconnections.get( ID ).children.forEach( function ( child ) {\n\n\t\t\t\t\tvar type = child.relationship;\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'Bump':\n\t\t\t\t\t\t\tparameters.bumpMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Maya|TEX_ao_map':\n\t\t\t\t\t\t\tparameters.aoMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'DiffuseColor':\n\t\t\t\t\t\tcase 'Maya|TEX_color_map':\n\t\t\t\t\t\t\tparameters.map = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tparameters.map.encoding = THREE.sRGBEncoding;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'DisplacementColor':\n\t\t\t\t\t\t\tparameters.displacementMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'EmissiveColor':\n\t\t\t\t\t\t\tparameters.emissiveMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tparameters.emissiveMap.encoding = THREE.sRGBEncoding;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'NormalMap':\n\t\t\t\t\t\tcase 'Maya|TEX_normal_map':\n\t\t\t\t\t\t\tparameters.normalMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ReflectionColor':\n\t\t\t\t\t\t\tparameters.envMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tparameters.envMap.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\t\t\tparameters.envMap.encoding = THREE.sRGBEncoding;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'SpecularColor':\n\t\t\t\t\t\t\tparameters.specularMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tparameters.specularMap.encoding = THREE.sRGBEncoding;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TransparentColor':\n\t\t\t\t\t\t\tparameters.alphaMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'AmbientColor':\n\t\t\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\n\t\t\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\n\t\t\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn parameters;\n\n\t\t\t},\n\n\t\t\t// get a texture from the textureMap for use by a material.\n\t\t\tgetTexture: function ( textureMap, id ) {\n\n\t\t\t\t// if the texture is a layered texture, just use the first layer and issue a warning\n\t\t\t\tif ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );\n\t\t\t\t\tid = connections.get( id ).children[ 0 ].ID;\n\n\t\t\t\t}\n\n\t\t\t\treturn textureMap.get( id );\n\n\t\t\t},\n\n\t\t\t// Parse nodes in FBXTree.Objects.Deformer\n\t\t\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n\t\t\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\t\t\tparseDeformers: function () {\n\n\t\t\t\tvar skeletons = {};\n\t\t\t\tvar morphTargets = {};\n\n\t\t\t\tif ( 'Deformer' in fbxTree.Objects ) {\n\n\t\t\t\t\tvar DeformerNodes = fbxTree.Objects.Deformer;\n\n\t\t\t\t\tfor ( var nodeID in DeformerNodes ) {\n\n\t\t\t\t\t\tvar deformerNode = DeformerNodes[ nodeID ];\n\n\t\t\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\n\t\t\t\t\t\tif ( deformerNode.attrType === 'Skin' ) {\n\n\t\t\t\t\t\t\tvar skeleton = this.parseSkeleton( relationships, DeformerNodes );\n\t\t\t\t\t\t\tskeleton.ID = nodeID;\n\n\t\t\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );\n\t\t\t\t\t\t\tskeleton.geometryID = relationships.parents[ 0 ].ID;\n\n\t\t\t\t\t\t\tskeletons[ nodeID ] = skeleton;\n\n\t\t\t\t\t\t} else if ( deformerNode.attrType === 'BlendShape' ) {\n\n\t\t\t\t\t\t\tvar morphTarget = {\n\t\t\t\t\t\t\t\tid: nodeID,\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tmorphTarget.rawTargets = this.parseMorphTargets( relationships, DeformerNodes );\n\t\t\t\t\t\t\tmorphTarget.id = nodeID;\n\n\t\t\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );\n\n\t\t\t\t\t\t\tmorphTargets[ nodeID ] = morphTarget;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\n\t\t\t\t\tskeletons: skeletons,\n\t\t\t\t\tmorphTargets: morphTargets,\n\n\t\t\t\t};\n\n\t\t\t},\n\n\t\t\t// Parse single nodes in FBXTree.Objects.Deformer\n\t\t\t// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n\t\t\t// Each skin node represents a skeleton and each cluster node represents a bone\n\t\t\tparseSkeleton: function ( relationships, deformerNodes ) {\n\n\t\t\t\tvar rawBones = [];\n\n\t\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\t\tvar boneNode = deformerNodes[ child.ID ];\n\n\t\t\t\t\tif ( boneNode.attrType !== 'Cluster' ) return;\n\n\t\t\t\t\tvar rawBone = {\n\n\t\t\t\t\t\tID: child.ID,\n\t\t\t\t\t\tindices: [],\n\t\t\t\t\t\tweights: [],\n\t\t\t\t\t\ttransformLink: new THREE.Matrix4().fromArray( boneNode.TransformLink.a ),\n\t\t\t\t\t\t// transform: new THREE.Matrix4().fromArray( boneNode.Transform.a ),\n\t\t\t\t\t\t// linkMode: boneNode.Mode,\n\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( 'Indexes' in boneNode ) {\n\n\t\t\t\t\t\trawBone.indices = boneNode.Indexes.a;\n\t\t\t\t\t\trawBone.weights = boneNode.Weights.a;\n\n\t\t\t\t\t}\n\n\t\t\t\t\trawBones.push( rawBone );\n\n\t\t\t\t} );\n\n\t\t\t\treturn {\n\n\t\t\t\t\trawBones: rawBones,\n\t\t\t\t\tbones: []\n\n\t\t\t\t};\n\n\t\t\t},\n\n\t\t\t// The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\t\t\tparseMorphTargets: function ( relationships, deformerNodes ) {\n\n\t\t\t\tvar rawMorphTargets = [];\n\n\t\t\t\tfor ( var i = 0; i < relationships.children.length; i ++ ) {\n\n\t\t\t\t\tvar child = relationships.children[ i ];\n\n\t\t\t\t\tvar morphTargetNode = deformerNodes[ child.ID ];\n\n\t\t\t\t\tvar rawMorphTarget = {\n\n\t\t\t\t\t\tname: morphTargetNode.attrName,\n\t\t\t\t\t\tinitialWeight: morphTargetNode.DeformPercent,\n\t\t\t\t\t\tid: morphTargetNode.id,\n\t\t\t\t\t\tfullWeights: morphTargetNode.FullWeights.a\n\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return;\n\n\t\t\t\t\trawMorphTarget.geoID = connections.get( parseInt( child.ID ) ).children.filter( function ( child ) {\n\n\t\t\t\t\t\treturn child.relationship === undefined;\n\n\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\trawMorphTargets.push( rawMorphTarget );\n\n\t\t\t\t}\n\n\t\t\t\treturn rawMorphTargets;\n\n\t\t\t},\n\n\t\t\t// create the main THREE.Group() to be returned by the loader\n\t\t\tparseScene: function ( deformers, geometryMap, materialMap ) {\n\n\t\t\t\tsceneGraph = new THREE.Group();\n\n\t\t\t\tvar modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap );\n\n\t\t\t\tvar modelNodes = fbxTree.Objects.Model;\n\n\t\t\t\tvar self = this;\n\t\t\t\tmodelMap.forEach( function ( model ) {\n\n\t\t\t\t\tvar modelNode = modelNodes[ model.ID ];\n\t\t\t\t\tself.setLookAtProperties( model, modelNode );\n\n\t\t\t\t\tvar parentConnections = connections.get( model.ID ).parents;\n\n\t\t\t\t\tparentConnections.forEach( function ( connection ) {\n\n\t\t\t\t\t\tvar parent = modelMap.get( connection.ID );\n\t\t\t\t\t\tif ( parent !== undefined ) parent.add( model );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( model.parent === null ) {\n\n\t\t\t\t\t\tsceneGraph.add( model );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} );\n\n\t\t\t\tthis.bindSkeleton( deformers.skeletons, geometryMap, modelMap );\n\n\t\t\t\tthis.createAmbientLight();\n\n\t\t\t\tthis.setupMorphMaterials();\n\n\t\t\t\tsceneGraph.traverse( function ( node ) {\n\n\t\t\t\t\tif ( node.userData.transformData ) {\n\n\t\t\t\t\t\tif ( node.parent ) node.userData.transformData.parentMatrixWorld = node.parent.matrix;\n\n\t\t\t\t\t\tvar transform = generateTransform( node.userData.transformData );\n\n\t\t\t\t\t\tnode.applyMatrix4( transform );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tvar animations = new AnimationParser().parse();\n\n\t\t\t\t// if all the models where already combined in a single group, just return that\n\t\t\t\tif ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) {\n\n\t\t\t\t\tsceneGraph.children[ 0 ].animations = animations;\n\t\t\t\t\tsceneGraph = sceneGraph.children[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tsceneGraph.animations = animations;\n\n\t\t\t},\n\n\t\t\t// parse nodes in FBXTree.Objects.Model\n\t\t\tparseModels: function ( skeletons, geometryMap, materialMap ) {\n\n\t\t\t\tvar modelMap = new Map();\n\t\t\t\tvar modelNodes = fbxTree.Objects.Model;\n\n\t\t\t\tfor ( var nodeID in modelNodes ) {\n\n\t\t\t\t\tvar id = parseInt( nodeID );\n\t\t\t\t\tvar node = modelNodes[ nodeID ];\n\t\t\t\t\tvar relationships = connections.get( id );\n\n\t\t\t\t\tvar model = this.buildSkeleton( relationships, skeletons, id, node.attrName );\n\n\t\t\t\t\tif ( ! model ) {\n\n\t\t\t\t\t\tswitch ( node.attrType ) {\n\n\t\t\t\t\t\t\tcase 'Camera':\n\t\t\t\t\t\t\t\tmodel = this.createCamera( relationships );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'Light':\n\t\t\t\t\t\t\t\tmodel = this.createLight( relationships );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\t\t\tmodel = this.createMesh( relationships, geometryMap, materialMap );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\t\t\tmodel = this.createCurve( relationships, geometryMap );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'LimbNode':\n\t\t\t\t\t\t\tcase 'Root':\n\t\t\t\t\t\t\t\tmodel = new THREE.Bone();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'Null':\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tmodel = new THREE.Group();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmodel.name = node.attrName ? THREE.PropertyBinding.sanitizeNodeName( node.attrName ) : '';\n\n\t\t\t\t\t\tmodel.ID = id;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.getTransformData( model, node );\n\t\t\t\t\tmodelMap.set( id, model );\n\n\t\t\t\t}\n\n\t\t\t\treturn modelMap;\n\n\t\t\t},\n\n\t\t\tbuildSkeleton: function ( relationships, skeletons, id, name ) {\n\n\t\t\t\tvar bone = null;\n\n\t\t\t\trelationships.parents.forEach( function ( parent ) {\n\n\t\t\t\t\tfor ( var ID in skeletons ) {\n\n\t\t\t\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\t\t\tif ( rawBone.ID === parent.ID ) {\n\n\t\t\t\t\t\t\t\tvar subBone = bone;\n\t\t\t\t\t\t\t\tbone = new THREE.Bone();\n\n\t\t\t\t\t\t\t\tbone.matrixWorld.copy( rawBone.transformLink );\n\n\t\t\t\t\t\t\t\t// set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n\t\t\t\t\t\t\t\tbone.name = name ? THREE.PropertyBinding.sanitizeNodeName( name ) : '';\n\t\t\t\t\t\t\t\tbone.ID = id;\n\n\t\t\t\t\t\t\t\tskeleton.bones[ i ] = bone;\n\n\t\t\t\t\t\t\t\t// In cases where a bone is shared between multiple meshes\n\t\t\t\t\t\t\t\t// duplicate the bone here and and it as a child of the first bone\n\t\t\t\t\t\t\t\tif ( subBone !== null ) {\n\n\t\t\t\t\t\t\t\t\tbone.add( subBone );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn bone;\n\n\t\t\t},\n\n\t\t\t// create a THREE.PerspectiveCamera or THREE.OrthographicCamera\n\t\t\tcreateCamera: function ( relationships ) {\n\n\t\t\t\tvar model;\n\t\t\t\tvar cameraAttribute;\n\n\t\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\t\tvar attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\t\t\tcameraAttribute = attr;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tif ( cameraAttribute === undefined ) {\n\n\t\t\t\t\tmodel = new THREE.Object3D();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar type = 0;\n\t\t\t\t\tif ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {\n\n\t\t\t\t\t\ttype = 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar nearClippingPlane = 1;\n\t\t\t\t\tif ( cameraAttribute.NearPlane !== undefined ) {\n\n\t\t\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar farClippingPlane = 1000;\n\t\t\t\t\tif ( cameraAttribute.FarPlane !== undefined ) {\n\n\t\t\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tvar width = window.innerWidth;\n\t\t\t\t\tvar height = window.innerHeight;\n\n\t\t\t\t\tif ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {\n\n\t\t\t\t\t\twidth = cameraAttribute.AspectWidth.value;\n\t\t\t\t\t\theight = cameraAttribute.AspectHeight.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar aspect = width / height;\n\n\t\t\t\t\tvar fov = 45;\n\t\t\t\t\tif ( cameraAttribute.FieldOfView !== undefined ) {\n\n\t\t\t\t\t\tfov = cameraAttribute.FieldOfView.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 0: // Perspective\n\t\t\t\t\t\t\tmodel = new THREE.PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );\n\t\t\t\t\t\t\tif ( focalLength !== null ) model.setFocalLength( focalLength );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 1: // Orthographic\n\t\t\t\t\t\t\tmodel = new THREE.OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );\n\t\t\t\t\t\t\tmodel = new THREE.Object3D();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn model;\n\n\t\t\t},\n\n\t\t\t// Create a THREE.DirectionalLight, THREE.PointLight or THREE.SpotLight\n\t\t\tcreateLight: function ( relationships ) {\n\n\t\t\t\tvar model;\n\t\t\t\tvar lightAttribute;\n\n\t\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\t\tvar attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\t\t\tlightAttribute = attr;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tif ( lightAttribute === undefined ) {\n\n\t\t\t\t\tmodel = new THREE.Object3D();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar type;\n\n\t\t\t\t\t// LightType can be undefined for Point lights\n\t\t\t\t\tif ( lightAttribute.LightType === undefined ) {\n\n\t\t\t\t\t\ttype = 0;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttype = lightAttribute.LightType.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar color = 0xffffff;\n\n\t\t\t\t\tif ( lightAttribute.Color !== undefined ) {\n\n\t\t\t\t\t\tcolor = new THREE.Color().fromArray( lightAttribute.Color.value );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;\n\n\t\t\t\t\t// light disabled\n\t\t\t\t\tif ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {\n\n\t\t\t\t\t\tintensity = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar distance = 0;\n\t\t\t\t\tif ( lightAttribute.FarAttenuationEnd !== undefined ) {\n\n\t\t\t\t\t\tif ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {\n\n\t\t\t\t\t\t\tdistance = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\t\t\t\t\tvar decay = 1;\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 0: // Point\n\t\t\t\t\t\t\tmodel = new THREE.PointLight( color, intensity, distance, decay );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 1: // Directional\n\t\t\t\t\t\t\tmodel = new THREE.DirectionalLight( color, intensity );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2: // Spot\n\t\t\t\t\t\t\tvar angle = Math.PI / 3;\n\n\t\t\t\t\t\t\tif ( lightAttribute.InnerAngle !== undefined ) {\n\n\t\t\t\t\t\t\t\tangle = THREE.MathUtils.degToRad( lightAttribute.InnerAngle.value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar penumbra = 0;\n\t\t\t\t\t\t\tif ( lightAttribute.OuterAngle !== undefined ) {\n\n\t\t\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\n\t\t\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n\t\t\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n\t\t\t\t\t\t\t\tpenumbra = THREE.MathUtils.degToRad( lightAttribute.OuterAngle.value );\n\t\t\t\t\t\t\t\tpenumbra = Math.max( penumbra, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmodel = new THREE.SpotLight( color, intensity, distance, angle, penumbra, decay );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a THREE.PointLight.' );\n\t\t\t\t\t\t\tmodel = new THREE.PointLight( color, intensity );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {\n\n\t\t\t\t\t\tmodel.castShadow = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn model;\n\n\t\t\t},\n\n\t\t\tcreateMesh: function ( relationships, geometryMap, materialMap ) {\n\n\t\t\t\tvar model;\n\t\t\t\tvar geometry = null;\n\t\t\t\tvar material = null;\n\t\t\t\tvar materials = [];\n\n\t\t\t\t// get geometry and materials(s) from connections\n\t\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\t\tif ( geometryMap.has( child.ID ) ) {\n\n\t\t\t\t\t\tgeometry = geometryMap.get( child.ID );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( materialMap.has( child.ID ) ) {\n\n\t\t\t\t\t\tmaterials.push( materialMap.get( child.ID ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tif ( materials.length > 1 ) {\n\n\t\t\t\t\tmaterial = materials;\n\n\t\t\t\t} else if ( materials.length > 0 ) {\n\n\t\t\t\t\tmaterial = materials[ 0 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial( { color: 0xcccccc } );\n\t\t\t\t\tmaterials.push( material );\n\n\t\t\t\t}\n\n\t\t\t\tif ( 'color' in geometry.attributes ) {\n\n\t\t\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.FBX_Deformer ) {\n\n\t\t\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\t\t\tmaterial.skinning = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tmodel = new THREE.SkinnedMesh( geometry, material );\n\t\t\t\t\tmodel.normalizeSkinWeights();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmodel = new THREE.Mesh( geometry, material );\n\n\t\t\t\t}\n\n\t\t\t\treturn model;\n\n\t\t\t},\n\n\t\t\tcreateCurve: function ( relationships, geometryMap ) {\n\n\t\t\t\tvar geometry = relationships.children.reduce( function ( geo, child ) {\n\n\t\t\t\t\tif ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );\n\n\t\t\t\t\treturn geo;\n\n\t\t\t\t}, null );\n\n\t\t\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\t\t\t\tvar material = new THREE.LineBasicMaterial( { color: 0x3300ff, linewidth: 1 } );\n\t\t\t\treturn new THREE.Line( geometry, material );\n\n\t\t\t},\n\n\t\t\t// parse the model node for transform data\n\t\t\tgetTransformData: function ( model, modelNode ) {\n\n\t\t\t\tvar transformData = {};\n\n\t\t\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\t\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\t\t\telse transformData.eulerOrder = 'ZYX';\n\n\t\t\t\tif ( 'Lcl_Translation' in modelNode ) transformData.translation = modelNode.Lcl_Translation.value;\n\n\t\t\t\tif ( 'PreRotation' in modelNode ) transformData.preRotation = modelNode.PreRotation.value;\n\t\t\t\tif ( 'Lcl_Rotation' in modelNode ) transformData.rotation = modelNode.Lcl_Rotation.value;\n\t\t\t\tif ( 'PostRotation' in modelNode ) transformData.postRotation = modelNode.PostRotation.value;\n\n\t\t\t\tif ( 'Lcl_Scaling' in modelNode ) transformData.scale = modelNode.Lcl_Scaling.value;\n\n\t\t\t\tif ( 'ScalingOffset' in modelNode ) transformData.scalingOffset = modelNode.ScalingOffset.value;\n\t\t\t\tif ( 'ScalingPivot' in modelNode ) transformData.scalingPivot = modelNode.ScalingPivot.value;\n\n\t\t\t\tif ( 'RotationOffset' in modelNode ) transformData.rotationOffset = modelNode.RotationOffset.value;\n\t\t\t\tif ( 'RotationPivot' in modelNode ) transformData.rotationPivot = modelNode.RotationPivot.value;\n\n\t\t\t\tmodel.userData.transformData = transformData;\n\n\t\t\t},\n\n\t\t\tsetLookAtProperties: function ( model, modelNode ) {\n\n\t\t\t\tif ( 'LookAtProperty' in modelNode ) {\n\n\t\t\t\t\tvar children = connections.get( model.ID ).children;\n\n\t\t\t\t\tchildren.forEach( function ( child ) {\n\n\t\t\t\t\t\tif ( child.relationship === 'LookAtProperty' ) {\n\n\t\t\t\t\t\t\tvar lookAtTarget = fbxTree.Objects.Model[ child.ID ];\n\n\t\t\t\t\t\t\tif ( 'Lcl_Translation' in lookAtTarget ) {\n\n\t\t\t\t\t\t\t\tvar pos = lookAtTarget.Lcl_Translation.value;\n\n\t\t\t\t\t\t\t\t// DirectionalLight, SpotLight\n\t\t\t\t\t\t\t\tif ( model.target !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tmodel.target.position.fromArray( pos );\n\t\t\t\t\t\t\t\t\tsceneGraph.add( model.target );\n\n\t\t\t\t\t\t\t\t} else { // Cameras and other Object3Ds\n\n\t\t\t\t\t\t\t\t\tmodel.lookAt( new THREE.Vector3().fromArray( pos ) );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tbindSkeleton: function ( skeletons, geometryMap, modelMap ) {\n\n\t\t\t\tvar bindMatrices = this.parsePoseNodes();\n\n\t\t\t\tfor ( var ID in skeletons ) {\n\n\t\t\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\t\t\tvar parents = connections.get( parseInt( skeleton.ID ) ).parents;\n\n\t\t\t\t\tparents.forEach( function ( parent ) {\n\n\t\t\t\t\t\tif ( geometryMap.has( parent.ID ) ) {\n\n\t\t\t\t\t\t\tvar geoID = parent.ID;\n\t\t\t\t\t\t\tvar geoRelationships = connections.get( geoID );\n\n\t\t\t\t\t\t\tgeoRelationships.parents.forEach( function ( geoConnParent ) {\n\n\t\t\t\t\t\t\t\tif ( modelMap.has( geoConnParent.ID ) ) {\n\n\t\t\t\t\t\t\t\t\tvar model = modelMap.get( geoConnParent.ID );\n\n\t\t\t\t\t\t\t\t\tmodel.bind( new THREE.Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tparsePoseNodes: function () {\n\n\t\t\t\tvar bindMatrices = {};\n\n\t\t\t\tif ( 'Pose' in fbxTree.Objects ) {\n\n\t\t\t\t\tvar BindPoseNode = fbxTree.Objects.Pose;\n\n\t\t\t\t\tfor ( var nodeID in BindPoseNode ) {\n\n\t\t\t\t\t\tif ( BindPoseNode[ nodeID ].attrType === 'BindPose' ) {\n\n\t\t\t\t\t\t\tvar poseNodes = BindPoseNode[ nodeID ].PoseNode;\n\n\t\t\t\t\t\t\tif ( Array.isArray( poseNodes ) ) {\n\n\t\t\t\t\t\t\t\tposeNodes.forEach( function ( poseNode ) {\n\n\t\t\t\t\t\t\t\t\tbindMatrices[ poseNode.Node ] = new THREE.Matrix4().fromArray( poseNode.Matrix.a );\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tbindMatrices[ poseNodes.Node ] = new THREE.Matrix4().fromArray( poseNodes.Matrix.a );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn bindMatrices;\n\n\t\t\t},\n\n\t\t\t// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\t\t\tcreateAmbientLight: function () {\n\n\t\t\t\tif ( 'GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings ) {\n\n\t\t\t\t\tvar ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\n\t\t\t\t\tvar r = ambientColor[ 0 ];\n\t\t\t\t\tvar g = ambientColor[ 1 ];\n\t\t\t\t\tvar b = ambientColor[ 2 ];\n\n\t\t\t\t\tif ( r !== 0 || g !== 0 || b !== 0 ) {\n\n\t\t\t\t\t\tvar color = new THREE.Color( r, g, b );\n\t\t\t\t\t\tsceneGraph.add( new THREE.AmbientLight( color, 1 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetupMorphMaterials: function () {\n\n\t\t\t\tvar self = this;\n\t\t\t\tsceneGraph.traverse( function ( child ) {\n\n\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\tif ( child.geometry.morphAttributes.position && child.geometry.morphAttributes.position.length ) {\n\n\t\t\t\t\t\t\tif ( Array.isArray( child.material ) ) {\n\n\t\t\t\t\t\t\t\tchild.material.forEach( function ( material, i ) {\n\n\t\t\t\t\t\t\t\t\tself.setupMorphMaterial( child, material, i );\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tself.setupMorphMaterial( child, child.material );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t},\n\n\t\t\tsetupMorphMaterial: function ( child, material, index ) {\n\n\t\t\t\tvar uuid = child.uuid;\n\t\t\t\tvar matUuid = material.uuid;\n\n\t\t\t\t// if a geometry has morph targets, it cannot share the material with other geometries\n\t\t\t\tvar sharedMat = false;\n\n\t\t\t\tsceneGraph.traverse( function ( node ) {\n\n\t\t\t\t\tif ( node.isMesh ) {\n\n\t\t\t\t\t\tif ( Array.isArray( node.material ) ) {\n\n\t\t\t\t\t\t\tnode.material.forEach( function ( mat ) {\n\n\t\t\t\t\t\t\t\tif ( mat.uuid === matUuid && node.uuid !== uuid ) sharedMat = true;\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} else if ( node.material.uuid === matUuid && node.uuid !== uuid ) sharedMat = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tif ( sharedMat === true ) {\n\n\t\t\t\t\tvar clonedMat = material.clone();\n\t\t\t\t\tclonedMat.morphTargets = true;\n\n\t\t\t\t\tif ( index === undefined ) child.material = clonedMat;\n\t\t\t\t\telse child.material[ index ] = clonedMat;\n\n\t\t\t\t} else material.morphTargets = true;\n\n\t\t\t}\n\n\t\t};\n\n\t\t// parse Geometry data from FBXTree and return map of BufferGeometries\n\t\tfunction GeometryParser() {}\n\n\t\tGeometryParser.prototype = {\n\n\t\t\tconstructor: GeometryParser,\n\n\t\t\t// Parse nodes in FBXTree.Objects.Geometry\n\t\t\tparse: function ( deformers ) {\n\n\t\t\t\tvar geometryMap = new Map();\n\n\t\t\t\tif ( 'Geometry' in fbxTree.Objects ) {\n\n\t\t\t\t\tvar geoNodes = fbxTree.Objects.Geometry;\n\n\t\t\t\t\tfor ( var nodeID in geoNodes ) {\n\n\t\t\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\t\t\t\t\t\tvar geo = this.parseGeometry( relationships, geoNodes[ nodeID ], deformers );\n\n\t\t\t\t\t\tgeometryMap.set( parseInt( nodeID ), geo );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn geometryMap;\n\n\t\t\t},\n\n\t\t\t// Parse single node in FBXTree.Objects.Geometry\n\t\t\tparseGeometry: function ( relationships, geoNode, deformers ) {\n\n\t\t\t\tswitch ( geoNode.attrType ) {\n\n\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\treturn this.parseMeshGeometry( relationships, geoNode, deformers );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\treturn this.parseNurbsGeometry( geoNode );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\n\t\t\t// Parse single node mesh geometry in FBXTree.Objects.Geometry\n\t\t\tparseMeshGeometry: function ( relationships, geoNode, deformers ) {\n\n\t\t\t\tvar skeletons = deformers.skeletons;\n\t\t\t\tvar morphTargets = [];\n\n\t\t\t\tvar modelNodes = relationships.parents.map( function ( parent ) {\n\n\t\t\t\t\treturn fbxTree.Objects.Model[ parent.ID ];\n\n\t\t\t\t} );\n\n\t\t\t\t// don't create geometry if it is not associated with any models\n\t\t\t\tif ( modelNodes.length === 0 ) return;\n\n\t\t\t\tvar skeleton = relationships.children.reduce( function ( skeleton, child ) {\n\n\t\t\t\t\tif ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];\n\n\t\t\t\t\treturn skeleton;\n\n\t\t\t\t}, null );\n\n\t\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\t\tif ( deformers.morphTargets[ child.ID ] !== undefined ) {\n\n\t\t\t\t\t\tmorphTargets.push( deformers.morphTargets[ child.ID ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\t// Assume one model and get the preRotation from that\n\t\t\t\t// if there is more than one model associated with the geometry this may cause problems\n\t\t\t\tvar modelNode = modelNodes[ 0 ];\n\n\t\t\t\tvar transformData = {};\n\n\t\t\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\t\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\t\t\tif ( 'GeometricTranslation' in modelNode ) transformData.translation = modelNode.GeometricTranslation.value;\n\t\t\t\tif ( 'GeometricRotation' in modelNode ) transformData.rotation = modelNode.GeometricRotation.value;\n\t\t\t\tif ( 'GeometricScaling' in modelNode ) transformData.scale = modelNode.GeometricScaling.value;\n\n\t\t\t\tvar transform = generateTransform( transformData );\n\n\t\t\t\treturn this.genGeometry( geoNode, skeleton, morphTargets, transform );\n\n\t\t\t},\n\n\t\t\t// Generate a THREE.BufferGeometry from a node in FBXTree.Objects.Geometry\n\t\t\tgenGeometry: function ( geoNode, skeleton, morphTargets, preTransform ) {\n\n\t\t\t\tvar geo = new THREE.BufferGeometry();\n\t\t\t\tif ( geoNode.attrName ) geo.name = geoNode.attrName;\n\n\t\t\t\tvar geoInfo = this.parseGeoNode( geoNode, skeleton );\n\t\t\t\tvar buffers = this.genBuffers( geoInfo );\n\n\t\t\t\tvar positionAttribute = new THREE.Float32BufferAttribute( buffers.vertex, 3 );\n\n\t\t\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\t\t\tgeo.setAttribute( 'position', positionAttribute );\n\n\t\t\t\tif ( buffers.colors.length > 0 ) {\n\n\t\t\t\t\tgeo.setAttribute( 'color', new THREE.Float32BufferAttribute( buffers.colors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( skeleton ) {\n\n\t\t\t\t\tgeo.setAttribute( 'skinIndex', new THREE.Uint16BufferAttribute( buffers.weightsIndices, 4 ) );\n\n\t\t\t\t\tgeo.setAttribute( 'skinWeight', new THREE.Float32BufferAttribute( buffers.vertexWeights, 4 ) );\n\n\t\t\t\t\t// used later to bind the skeleton to the model\n\t\t\t\t\tgeo.FBX_Deformer = skeleton;\n\n\t\t\t\t}\n\n\t\t\t\tif ( buffers.normal.length > 0 ) {\n\n\t\t\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( preTransform );\n\n\t\t\t\t\tvar normalAttribute = new THREE.Float32BufferAttribute( buffers.normal, 3 );\n\t\t\t\t\tnormalAttribute.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t\tgeo.setAttribute( 'normal', normalAttribute );\n\n\t\t\t\t}\n\n\t\t\t\tbuffers.uvs.forEach( function ( uvBuffer, i ) {\n\n\t\t\t\t\t// subsequent uv buffers are called 'uv1', 'uv2', ...\n\t\t\t\t\tvar name = 'uv' + ( i + 1 ).toString();\n\n\t\t\t\t\t// the first uv buffer is just called 'uv'\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tname = 'uv';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeo.setAttribute( name, new THREE.Float32BufferAttribute( buffers.uvs[ i ], 2 ) );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\n\t\t\t\t\tvar prevMaterialIndex = buffers.materialIndex[ 0 ];\n\t\t\t\t\tvar startIndex = 0;\n\n\t\t\t\t\tbuffers.materialIndex.forEach( function ( currentIndex, i ) {\n\n\t\t\t\t\t\tif ( currentIndex !== prevMaterialIndex ) {\n\n\t\t\t\t\t\t\tgeo.addGroup( startIndex, i - startIndex, prevMaterialIndex );\n\n\t\t\t\t\t\t\tprevMaterialIndex = currentIndex;\n\t\t\t\t\t\t\tstartIndex = i;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\t\t\tif ( geo.groups.length > 0 ) {\n\n\t\t\t\t\t\tvar lastGroup = geo.groups[ geo.groups.length - 1 ];\n\t\t\t\t\t\tvar lastIndex = lastGroup.start + lastGroup.count;\n\n\t\t\t\t\t\tif ( lastIndex !== buffers.materialIndex.length ) {\n\n\t\t\t\t\t\t\tgeo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// case where there are multiple materials but the whole geometry is only\n\t\t\t\t\t// using one of them\n\t\t\t\t\tif ( geo.groups.length === 0 ) {\n\n\t\t\t\t\t\tgeo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.addMorphTargets( geo, geoNode, morphTargets, preTransform );\n\n\t\t\t\treturn geo;\n\n\t\t\t},\n\n\t\t\tparseGeoNode: function ( geoNode, skeleton ) {\n\n\t\t\t\tvar geoInfo = {};\n\n\t\t\t\tgeoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];\n\t\t\t\tgeoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];\n\n\t\t\t\tif ( geoNode.LayerElementColor ) {\n\n\t\t\t\t\tgeoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoNode.LayerElementMaterial ) {\n\n\t\t\t\t\tgeoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoNode.LayerElementNormal ) {\n\n\t\t\t\t\tgeoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoNode.LayerElementUV ) {\n\n\t\t\t\t\tgeoInfo.uv = [];\n\n\t\t\t\t\tvar i = 0;\n\t\t\t\t\twhile ( geoNode.LayerElementUV[ i ] ) {\n\n\t\t\t\t\t\tgeoInfo.uv.push( this.parseUVs( geoNode.LayerElementUV[ i ] ) );\n\t\t\t\t\t\ti ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeoInfo.weightTable = {};\n\n\t\t\t\tif ( skeleton !== null ) {\n\n\t\t\t\t\tgeoInfo.skeleton = skeleton;\n\n\t\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\t\t// loop over the bone's vertex indices and weights\n\t\t\t\t\t\trawBone.indices.forEach( function ( index, j ) {\n\n\t\t\t\t\t\t\tif ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];\n\n\t\t\t\t\t\t\tgeoInfo.weightTable[ index ].push( {\n\n\t\t\t\t\t\t\t\tid: i,\n\t\t\t\t\t\t\t\tweight: rawBone.weights[ j ],\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\treturn geoInfo;\n\n\t\t\t},\n\n\t\t\tgenBuffers: function ( geoInfo ) {\n\n\t\t\t\tvar buffers = {\n\t\t\t\t\tvertex: [],\n\t\t\t\t\tnormal: [],\n\t\t\t\t\tcolors: [],\n\t\t\t\t\tuvs: [],\n\t\t\t\t\tmaterialIndex: [],\n\t\t\t\t\tvertexWeights: [],\n\t\t\t\t\tweightsIndices: [],\n\t\t\t\t};\n\n\t\t\t\tvar polygonIndex = 0;\n\t\t\t\tvar faceLength = 0;\n\t\t\t\tvar displayedWeightsWarning = false;\n\n\t\t\t\t// these will hold data for a single face\n\t\t\t\tvar facePositionIndexes = [];\n\t\t\t\tvar faceNormals = [];\n\t\t\t\tvar faceColors = [];\n\t\t\t\tvar faceUVs = [];\n\t\t\t\tvar faceWeights = [];\n\t\t\t\tvar faceWeightIndices = [];\n\n\t\t\t\tvar self = this;\n\t\t\t\tgeoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {\n\n\t\t\t\t\tvar endOfFace = false;\n\n\t\t\t\t\t// Face index and vertex index arrays are combined in a single array\n\t\t\t\t\t// A cube with quad faces looks like this:\n\t\t\t\t\t// PolygonVertexIndex: *24 {\n\t\t\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n\t\t\t\t\t//  }\n\t\t\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n\t\t\t\t\t// to find index of last vertex bit shift the index: ^ - 1\n\t\t\t\t\tif ( vertexIndex < 0 ) {\n\n\t\t\t\t\t\tvertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1\n\t\t\t\t\t\tendOfFace = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar weightIndices = [];\n\t\t\t\t\tvar weights = [];\n\n\t\t\t\t\tfacePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );\n\n\t\t\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );\n\n\t\t\t\t\t\tfaceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\t\t\tif ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {\n\n\t\t\t\t\t\t\tgeoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {\n\n\t\t\t\t\t\t\t\tweights.push( wt.weight );\n\t\t\t\t\t\t\t\tweightIndices.push( wt.id );\n\n\t\t\t\t\t\t\t} );\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( weights.length > 4 ) {\n\n\t\t\t\t\t\t\tif ( ! displayedWeightsWarning ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );\n\t\t\t\t\t\t\t\tdisplayedWeightsWarning = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar wIndex = [ 0, 0, 0, 0 ];\n\t\t\t\t\t\t\tvar Weight = [ 0, 0, 0, 0 ];\n\n\t\t\t\t\t\t\tweights.forEach( function ( weight, weightIndex ) {\n\n\t\t\t\t\t\t\t\tvar currentWeight = weight;\n\t\t\t\t\t\t\t\tvar currentIndex = weightIndices[ weightIndex ];\n\n\t\t\t\t\t\t\t\tWeight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {\n\n\t\t\t\t\t\t\t\t\tif ( currentWeight > comparedWeight ) {\n\n\t\t\t\t\t\t\t\t\t\tcomparedWeightArray[ comparedWeightIndex ] = currentWeight;\n\t\t\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\n\n\t\t\t\t\t\t\t\t\t\tvar tmp = wIndex[ comparedWeightIndex ];\n\t\t\t\t\t\t\t\t\t\twIndex[ comparedWeightIndex ] = currentIndex;\n\t\t\t\t\t\t\t\t\t\tcurrentIndex = tmp;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tweightIndices = wIndex;\n\t\t\t\t\t\t\tweights = Weight;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if the weight array is shorter than 4 pad with 0s\n\t\t\t\t\t\twhile ( weights.length < 4 ) {\n\n\t\t\t\t\t\t\tweights.push( 0 );\n\t\t\t\t\t\t\tweightIndices.push( 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\t\t\tfaceWeights.push( weights[ i ] );\n\t\t\t\t\t\t\tfaceWeightIndices.push( weightIndices[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );\n\n\t\t\t\t\t\tfaceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\t\t\tvar materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\t\t\tgeoInfo.uv.forEach( function ( uv, i ) {\n\n\t\t\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );\n\n\t\t\t\t\t\t\tif ( faceUVs[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\tfaceUVs[ i ] = [];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfaceUVs[ i ].push( data[ 0 ] );\n\t\t\t\t\t\t\tfaceUVs[ i ].push( data[ 1 ] );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceLength ++;\n\n\t\t\t\t\tif ( endOfFace ) {\n\n\t\t\t\t\t\tself.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );\n\n\t\t\t\t\t\tpolygonIndex ++;\n\t\t\t\t\t\tfaceLength = 0;\n\n\t\t\t\t\t\t// reset arrays for the next face\n\t\t\t\t\t\tfacePositionIndexes = [];\n\t\t\t\t\t\tfaceNormals = [];\n\t\t\t\t\t\tfaceColors = [];\n\t\t\t\t\t\tfaceUVs = [];\n\t\t\t\t\t\tfaceWeights = [];\n\t\t\t\t\t\tfaceWeightIndices = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn buffers;\n\n\t\t\t},\n\n\t\t\t// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\t\t\tgenFace: function ( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {\n\n\t\t\t\tfor ( var i = 2; i < faceLength; i ++ ) {\n\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] );\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] );\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] );\n\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] );\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] );\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] );\n\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] );\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] );\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] );\n\n\t\t\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 0 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 1 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 2 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 3 ] );\n\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] );\n\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 0 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 1 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 2 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 3 ] );\n\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ 0 ] );\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ 1 ] );\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ 2 ] );\n\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 ] );\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 ] );\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 1 ] );\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ 0 ] );\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ 1 ] );\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ 2 ] );\n\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] );\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 ] );\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 1 ] );\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\t\t\tgeoInfo.uv.forEach( function ( uv, j ) {\n\n\t\t\t\t\t\t\tif ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];\n\n\t\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 0 ] );\n\t\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 1 ] );\n\n\t\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] );\n\t\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] );\n\n\t\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] );\n\t\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\taddMorphTargets: function ( parentGeo, parentGeoNode, morphTargets, preTransform ) {\n\n\t\t\t\tif ( morphTargets.length === 0 ) return;\n\n\t\t\t\tparentGeo.morphTargetsRelative = true;\n\n\t\t\t\tparentGeo.morphAttributes.position = [];\n\t\t\t\t// parentGeo.morphAttributes.normal = []; // not implemented\n\n\t\t\t\tvar self = this;\n\t\t\t\tmorphTargets.forEach( function ( morphTarget ) {\n\n\t\t\t\t\tmorphTarget.rawTargets.forEach( function ( rawTarget ) {\n\n\t\t\t\t\t\tvar morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ];\n\n\t\t\t\t\t\tif ( morphGeoNode !== undefined ) {\n\n\t\t\t\t\t\t\tself.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t},\n\n\t\t\t// a morph geometry node is similar to a standard  node, and the node is also contained\n\t\t\t// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n\t\t\t// and a special attribute Index defining which vertices of the original geometry are affected\n\t\t\t// Normal and position attributes only have data for the vertices that are affected by the morph\n\t\t\tgenMorphGeometry: function ( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) {\n\n\t\t\t\tvar vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : [];\n\n\t\t\t\tvar morphPositionsSparse = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : [];\n\t\t\t\tvar indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : [];\n\n\t\t\t\tvar length = parentGeo.attributes.position.count * 3;\n\t\t\t\tvar morphPositions = new Float32Array( length );\n\n\t\t\t\tfor ( var i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\tvar morphIndex = indices[ i ] * 3;\n\n\t\t\t\t\tmorphPositions[ morphIndex ] = morphPositionsSparse[ i * 3 ];\n\t\t\t\t\tmorphPositions[ morphIndex + 1 ] = morphPositionsSparse[ i * 3 + 1 ];\n\t\t\t\t\tmorphPositions[ morphIndex + 2 ] = morphPositionsSparse[ i * 3 + 2 ];\n\n\t\t\t\t}\n\n\t\t\t\t// TODO: add morph normal support\n\t\t\t\tvar morphGeoInfo = {\n\t\t\t\t\tvertexIndices: vertexIndices,\n\t\t\t\t\tvertexPositions: morphPositions,\n\n\t\t\t\t};\n\n\t\t\t\tvar morphBuffers = this.genBuffers( morphGeoInfo );\n\n\t\t\t\tvar positionAttribute = new THREE.Float32BufferAttribute( morphBuffers.vertex, 3 );\n\t\t\t\tpositionAttribute.name = name || morphGeoNode.attrName;\n\n\t\t\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\t\t\tparentGeo.morphAttributes.position.push( positionAttribute );\n\n\t\t\t},\n\n\t\t\t// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\t\t\tparseNormals: function ( NormalNode ) {\n\n\t\t\t\tvar mappingType = NormalNode.MappingInformationType;\n\t\t\t\tvar referenceType = NormalNode.ReferenceInformationType;\n\t\t\t\tvar buffer = NormalNode.Normals.a;\n\t\t\t\tvar indexBuffer = [];\n\t\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\t\tif ( 'NormalIndex' in NormalNode ) {\n\n\t\t\t\t\t\tindexBuffer = NormalNode.NormalIndex.a;\n\n\t\t\t\t\t} else if ( 'NormalsIndex' in NormalNode ) {\n\n\t\t\t\t\t\tindexBuffer = NormalNode.NormalsIndex.a;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdataSize: 3,\n\t\t\t\t\tbuffer: buffer,\n\t\t\t\t\tindices: indexBuffer,\n\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\treferenceType: referenceType\n\t\t\t\t};\n\n\t\t\t},\n\n\t\t\t// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\t\t\tparseUVs: function ( UVNode ) {\n\n\t\t\t\tvar mappingType = UVNode.MappingInformationType;\n\t\t\t\tvar referenceType = UVNode.ReferenceInformationType;\n\t\t\t\tvar buffer = UVNode.UV.a;\n\t\t\t\tvar indexBuffer = [];\n\t\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\t\tindexBuffer = UVNode.UVIndex.a;\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdataSize: 2,\n\t\t\t\t\tbuffer: buffer,\n\t\t\t\t\tindices: indexBuffer,\n\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\treferenceType: referenceType\n\t\t\t\t};\n\n\t\t\t},\n\n\t\t\t// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\t\t\tparseVertexColors: function ( ColorNode ) {\n\n\t\t\t\tvar mappingType = ColorNode.MappingInformationType;\n\t\t\t\tvar referenceType = ColorNode.ReferenceInformationType;\n\t\t\t\tvar buffer = ColorNode.Colors.a;\n\t\t\t\tvar indexBuffer = [];\n\t\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\t\tindexBuffer = ColorNode.ColorIndex.a;\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdataSize: 4,\n\t\t\t\t\tbuffer: buffer,\n\t\t\t\t\tindices: indexBuffer,\n\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\treferenceType: referenceType\n\t\t\t\t};\n\n\t\t\t},\n\n\t\t\t// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\t\t\tparseMaterialIndices: function ( MaterialNode ) {\n\n\t\t\t\tvar mappingType = MaterialNode.MappingInformationType;\n\t\t\t\tvar referenceType = MaterialNode.ReferenceInformationType;\n\n\t\t\t\tif ( mappingType === 'NoMappingInformation' ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdataSize: 1,\n\t\t\t\t\t\tbuffer: [ 0 ],\n\t\t\t\t\t\tindices: [ 0 ],\n\t\t\t\t\t\tmappingType: 'AllSame',\n\t\t\t\t\t\treferenceType: referenceType\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tvar materialIndexBuffer = MaterialNode.Materials.a;\n\n\t\t\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n\t\t\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\n\t\t\t\t// for conforming with the other functions we've written for other data.\n\t\t\t\tvar materialIndices = [];\n\n\t\t\t\tfor ( var i = 0; i < materialIndexBuffer.length; ++ i ) {\n\n\t\t\t\t\tmaterialIndices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdataSize: 1,\n\t\t\t\t\tbuffer: materialIndexBuffer,\n\t\t\t\t\tindices: materialIndices,\n\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\treferenceType: referenceType\n\t\t\t\t};\n\n\t\t\t},\n\n\t\t\t// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\t\t\tparseNurbsGeometry: function ( geoNode ) {\n\n\t\t\t\tif ( THREE.NURBSCurve === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.' );\n\t\t\t\t\treturn new THREE.BufferGeometry();\n\n\t\t\t\t}\n\n\t\t\t\tvar order = parseInt( geoNode.Order );\n\n\t\t\t\tif ( isNaN( order ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );\n\t\t\t\t\treturn new THREE.BufferGeometry();\n\n\t\t\t\t}\n\n\t\t\t\tvar degree = order - 1;\n\n\t\t\t\tvar knots = geoNode.KnotVector.a;\n\t\t\t\tvar controlPoints = [];\n\t\t\t\tvar pointsValues = geoNode.Points.a;\n\n\t\t\t\tfor ( var i = 0, l = pointsValues.length; i < l; i += 4 ) {\n\n\t\t\t\t\tcontrolPoints.push( new THREE.Vector4().fromArray( pointsValues, i ) );\n\n\t\t\t\t}\n\n\t\t\t\tvar startKnot, endKnot;\n\n\t\t\t\tif ( geoNode.Form === 'Closed' ) {\n\n\t\t\t\t\tcontrolPoints.push( controlPoints[ 0 ] );\n\n\t\t\t\t} else if ( geoNode.Form === 'Periodic' ) {\n\n\t\t\t\t\tstartKnot = degree;\n\t\t\t\t\tendKnot = knots.length - 1 - startKnot;\n\n\t\t\t\t\tfor ( var i = 0; i < degree; ++ i ) {\n\n\t\t\t\t\t\tcontrolPoints.push( controlPoints[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar curve = new THREE.NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );\n\t\t\t\tvar vertices = curve.getPoints( controlPoints.length * 7 );\n\n\t\t\t\tvar positions = new Float32Array( vertices.length * 3 );\n\n\t\t\t\tvertices.forEach( function ( vertex, i ) {\n\n\t\t\t\t\tvertex.toArray( positions, i * 3 );\n\n\t\t\t\t} );\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\n\t\t\t\treturn geometry;\n\n\t\t\t},\n\n\t\t};\n\n\t\t// parse animation data from FBXTree\n\t\tfunction AnimationParser() {}\n\n\t\tAnimationParser.prototype = {\n\n\t\t\tconstructor: AnimationParser,\n\n\t\t\t// take raw animation clips and turn them into three.js animation clips\n\t\t\tparse: function () {\n\n\t\t\t\tvar animationClips = [];\n\n\t\t\t\tvar rawClips = this.parseClips();\n\n\t\t\t\tif ( rawClips !== undefined ) {\n\n\t\t\t\t\tfor ( var key in rawClips ) {\n\n\t\t\t\t\t\tvar rawClip = rawClips[ key ];\n\n\t\t\t\t\t\tvar clip = this.addClip( rawClip );\n\n\t\t\t\t\t\tanimationClips.push( clip );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn animationClips;\n\n\t\t\t},\n\n\t\t\tparseClips: function () {\n\n\t\t\t\t// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n\t\t\t\t// if this is undefined we can safely assume there are no animations\n\t\t\t\tif ( fbxTree.Objects.AnimationCurve === undefined ) return undefined;\n\n\t\t\t\tvar curveNodesMap = this.parseAnimationCurveNodes();\n\n\t\t\t\tthis.parseAnimationCurves( curveNodesMap );\n\n\t\t\t\tvar layersMap = this.parseAnimationLayers( curveNodesMap );\n\t\t\t\tvar rawClips = this.parseAnimStacks( layersMap );\n\n\t\t\t\treturn rawClips;\n\n\t\t\t},\n\n\t\t\t// parse nodes in FBXTree.Objects.AnimationCurveNode\n\t\t\t// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n\t\t\t// and is referenced by an AnimationLayer\n\t\t\tparseAnimationCurveNodes: function () {\n\n\t\t\t\tvar rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\n\n\t\t\t\tvar curveNodesMap = new Map();\n\n\t\t\t\tfor ( var nodeID in rawCurveNodes ) {\n\n\t\t\t\t\tvar rawCurveNode = rawCurveNodes[ nodeID ];\n\n\t\t\t\t\tif ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) {\n\n\t\t\t\t\t\tvar curveNode = {\n\n\t\t\t\t\t\t\tid: rawCurveNode.id,\n\t\t\t\t\t\t\tattr: rawCurveNode.attrName,\n\t\t\t\t\t\t\tcurves: {},\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tcurveNodesMap.set( curveNode.id, curveNode );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn curveNodesMap;\n\n\t\t\t},\n\n\t\t\t// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n\t\t\t// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n\t\t\t// axis ( e.g. times and values of x rotation)\n\t\t\tparseAnimationCurves: function ( curveNodesMap ) {\n\n\t\t\t\tvar rawCurves = fbxTree.Objects.AnimationCurve;\n\n\t\t\t\t// TODO: Many values are identical up to roundoff error, but won't be optimised\n\t\t\t\t// e.g. position times: [0, 0.4, 0. 8]\n\t\t\t\t// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n\t\t\t\t// clearly, this should be optimised to\n\t\t\t\t// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n\t\t\t\t// this shows up in nearly every FBX file, and generally time array is length > 100\n\n\t\t\t\tfor ( var nodeID in rawCurves ) {\n\n\t\t\t\t\tvar animationCurve = {\n\n\t\t\t\t\t\tid: rawCurves[ nodeID ].id,\n\t\t\t\t\t\ttimes: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),\n\t\t\t\t\t\tvalues: rawCurves[ nodeID ].KeyValueFloat.a,\n\n\t\t\t\t\t};\n\n\t\t\t\t\tvar relationships = connections.get( animationCurve.id );\n\n\t\t\t\t\tif ( relationships !== undefined ) {\n\n\t\t\t\t\t\tvar animationCurveID = relationships.parents[ 0 ].ID;\n\t\t\t\t\t\tvar animationCurveRelationship = relationships.parents[ 0 ].relationship;\n\n\t\t\t\t\t\tif ( animationCurveRelationship.match( /X/ ) ) {\n\n\t\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;\n\n\t\t\t\t\t\t} else if ( animationCurveRelationship.match( /Y/ ) ) {\n\n\t\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;\n\n\t\t\t\t\t\t} else if ( animationCurveRelationship.match( /Z/ ) ) {\n\n\t\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;\n\n\t\t\t\t\t\t} else if ( animationCurveRelationship.match( /d|DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) {\n\n\t\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n\t\t\t// to various AnimationCurveNodes and is referenced by an AnimationStack node\n\t\t\t// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\t\t\tparseAnimationLayers: function ( curveNodesMap ) {\n\n\t\t\t\tvar rawLayers = fbxTree.Objects.AnimationLayer;\n\n\t\t\t\tvar layersMap = new Map();\n\n\t\t\t\tfor ( var nodeID in rawLayers ) {\n\n\t\t\t\t\tvar layerCurveNodes = [];\n\n\t\t\t\t\tvar connection = connections.get( parseInt( nodeID ) );\n\n\t\t\t\t\tif ( connection !== undefined ) {\n\n\t\t\t\t\t\t// all the animationCurveNodes used in the layer\n\t\t\t\t\t\tvar children = connection.children;\n\n\t\t\t\t\t\tchildren.forEach( function ( child, i ) {\n\n\t\t\t\t\t\t\tif ( curveNodesMap.has( child.ID ) ) {\n\n\t\t\t\t\t\t\t\tvar curveNode = curveNodesMap.get( child.ID );\n\n\t\t\t\t\t\t\t\t// check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\t\t\t\t\t\t\t\tif ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\t\t\tvar modelID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\t\tif ( modelID !== undefined ) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar rawModel = fbxTree.Objects.Model[ modelID.toString() ];\n\n\t\t\t\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? THREE.PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\t\t\t\tID: rawModel.id,\n\t\t\t\t\t\t\t\t\t\t\t\tinitialPosition: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\t\t\tinitialRotation: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\t\t\tinitialScale: [ 1, 1, 1 ],\n\n\t\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\t\tsceneGraph.traverse( function ( child ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( child.ID === rawModel.id ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tnode.transform = child.matrix;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tif ( child.userData.transformData ) node.eulerOrder = child.userData.transformData.eulerOrder;\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( ! node.transform ) node.transform = new THREE.Matrix4();\n\n\t\t\t\t\t\t\t\t\t\t\t// if the animated model is pre rotated, we'll have to apply the pre rotations to every\n\t\t\t\t\t\t\t\t\t\t\t// animation value as well\n\t\t\t\t\t\t\t\t\t\t\tif ( 'PreRotation' in rawModel ) node.preRotation = rawModel.PreRotation.value;\n\t\t\t\t\t\t\t\t\t\t\tif ( 'PostRotation' in rawModel ) node.postRotation = rawModel.PostRotation.value;\n\n\t\t\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] ) layerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t\t\t} else if ( curveNode.curves.morph !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\t\t\tvar deformerID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\t\tvar morpherID = connections.get( deformerID ).parents[ 0 ].ID;\n\t\t\t\t\t\t\t\t\t\tvar geoID = connections.get( morpherID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\t\t// assuming geometry is not used in more than one model\n\t\t\t\t\t\t\t\t\t\tvar modelID = connections.get( geoID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\t\tvar rawModel = fbxTree.Objects.Model[ modelID ];\n\n\t\t\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? THREE.PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\t\t\tmorphName: fbxTree.Objects.Deformer[ deformerID ].attrName,\n\n\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tlayersMap.set( parseInt( nodeID ), layerCurveNodes );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn layersMap;\n\n\t\t\t},\n\n\t\t\t// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n\t\t\t// hierarchy. Each Stack node will be used to create a THREE.AnimationClip\n\t\t\tparseAnimStacks: function ( layersMap ) {\n\n\t\t\t\tvar rawStacks = fbxTree.Objects.AnimationStack;\n\n\t\t\t\t// connect the stacks (clips) up to the layers\n\t\t\t\tvar rawClips = {};\n\n\t\t\t\tfor ( var nodeID in rawStacks ) {\n\n\t\t\t\t\tvar children = connections.get( parseInt( nodeID ) ).children;\n\n\t\t\t\t\tif ( children.length > 1 ) {\n\n\t\t\t\t\t\t// it seems like stacks will always be associated with a single layer. But just in case there are files\n\t\t\t\t\t\t// where there are multiple layers per stack, we'll display a warning\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar layer = layersMap.get( children[ 0 ].ID );\n\n\t\t\t\t\trawClips[ nodeID ] = {\n\n\t\t\t\t\t\tname: rawStacks[ nodeID ].attrName,\n\t\t\t\t\t\tlayer: layer,\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\treturn rawClips;\n\n\t\t\t},\n\n\t\t\taddClip: function ( rawClip ) {\n\n\t\t\t\tvar tracks = [];\n\n\t\t\t\tvar self = this;\n\t\t\t\trawClip.layer.forEach( function ( rawTracks ) {\n\n\t\t\t\t\ttracks = tracks.concat( self.generateTracks( rawTracks ) );\n\n\t\t\t\t} );\n\n\t\t\t\treturn new THREE.AnimationClip( rawClip.name, - 1, tracks );\n\n\t\t\t},\n\n\t\t\tgenerateTracks: function ( rawTracks ) {\n\n\t\t\t\tvar tracks = [];\n\n\t\t\t\tvar initialPosition = new THREE.Vector3();\n\t\t\t\tvar initialRotation = new THREE.Quaternion();\n\t\t\t\tvar initialScale = new THREE.Vector3();\n\n\t\t\t\tif ( rawTracks.transform ) rawTracks.transform.decompose( initialPosition, initialRotation, initialScale );\n\n\t\t\t\tinitialPosition = initialPosition.toArray();\n\t\t\t\tinitialRotation = new THREE.Euler().setFromQuaternion( initialRotation, rawTracks.eulerOrder ).toArray();\n\t\t\t\tinitialScale = initialScale.toArray();\n\n\t\t\t\tif ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {\n\n\t\t\t\t\tvar positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' );\n\t\t\t\t\tif ( positionTrack !== undefined ) tracks.push( positionTrack );\n\n\t\t\t\t}\n\n\t\t\t\tif ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {\n\n\t\t\t\t\tvar rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder );\n\t\t\t\t\tif ( rotationTrack !== undefined ) tracks.push( rotationTrack );\n\n\t\t\t\t}\n\n\t\t\t\tif ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {\n\n\t\t\t\t\tvar scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' );\n\t\t\t\t\tif ( scaleTrack !== undefined ) tracks.push( scaleTrack );\n\n\t\t\t\t}\n\n\t\t\t\tif ( rawTracks.DeformPercent !== undefined ) {\n\n\t\t\t\t\tvar morphTrack = this.generateMorphTrack( rawTracks );\n\t\t\t\t\tif ( morphTrack !== undefined ) tracks.push( morphTrack );\n\n\t\t\t\t}\n\n\t\t\t\treturn tracks;\n\n\t\t\t},\n\n\t\t\tgenerateVectorTrack: function ( modelName, curves, initialValue, type ) {\n\n\t\t\t\tvar times = this.getTimesForAllAxes( curves );\n\t\t\t\tvar values = this.getKeyframeTrackValues( times, curves, initialValue );\n\n\t\t\t\treturn new THREE.VectorKeyframeTrack( modelName + '.' + type, times, values );\n\n\t\t\t},\n\n\t\t\tgenerateRotationTrack: function ( modelName, curves, initialValue, preRotation, postRotation, eulerOrder ) {\n\n\t\t\t\tif ( curves.x !== undefined ) {\n\n\t\t\t\t\tthis.interpolateRotations( curves.x );\n\t\t\t\t\tcurves.x.values = curves.x.values.map( THREE.MathUtils.degToRad );\n\n\t\t\t\t}\n\t\t\t\tif ( curves.y !== undefined ) {\n\n\t\t\t\t\tthis.interpolateRotations( curves.y );\n\t\t\t\t\tcurves.y.values = curves.y.values.map( THREE.MathUtils.degToRad );\n\n\t\t\t\t}\n\t\t\t\tif ( curves.z !== undefined ) {\n\n\t\t\t\t\tthis.interpolateRotations( curves.z );\n\t\t\t\t\tcurves.z.values = curves.z.values.map( THREE.MathUtils.degToRad );\n\n\t\t\t\t}\n\n\t\t\t\tvar times = this.getTimesForAllAxes( curves );\n\t\t\t\tvar values = this.getKeyframeTrackValues( times, curves, initialValue );\n\n\t\t\t\tif ( preRotation !== undefined ) {\n\n\t\t\t\t\tpreRotation = preRotation.map( THREE.MathUtils.degToRad );\n\t\t\t\t\tpreRotation.push( eulerOrder );\n\n\t\t\t\t\tpreRotation = new THREE.Euler().fromArray( preRotation );\n\t\t\t\t\tpreRotation = new THREE.Quaternion().setFromEuler( preRotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( postRotation !== undefined ) {\n\n\t\t\t\t\tpostRotation = postRotation.map( THREE.MathUtils.degToRad );\n\t\t\t\t\tpostRotation.push( eulerOrder );\n\n\t\t\t\t\tpostRotation = new THREE.Euler().fromArray( postRotation );\n\t\t\t\t\tpostRotation = new THREE.Quaternion().setFromEuler( postRotation ).inverse();\n\n\t\t\t\t}\n\n\t\t\t\tvar quaternion = new THREE.Quaternion();\n\t\t\t\tvar euler = new THREE.Euler();\n\n\t\t\t\tvar quaternionValues = [];\n\n\t\t\t\tfor ( var i = 0; i < values.length; i += 3 ) {\n\n\t\t\t\t\teuler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], eulerOrder );\n\n\t\t\t\t\tquaternion.setFromEuler( euler );\n\n\t\t\t\t\tif ( preRotation !== undefined ) quaternion.premultiply( preRotation );\n\t\t\t\t\tif ( postRotation !== undefined ) quaternion.multiply( postRotation );\n\n\t\t\t\t\tquaternion.toArray( quaternionValues, ( i / 3 ) * 4 );\n\n\t\t\t\t}\n\n\t\t\t\treturn new THREE.QuaternionKeyframeTrack( modelName + '.quaternion', times, quaternionValues );\n\n\t\t\t},\n\n\t\t\tgenerateMorphTrack: function ( rawTracks ) {\n\n\t\t\t\tvar curves = rawTracks.DeformPercent.curves.morph;\n\t\t\t\tvar values = curves.values.map( function ( val ) {\n\n\t\t\t\t\treturn val / 100;\n\n\t\t\t\t} );\n\n\t\t\t\tvar morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ];\n\n\t\t\t\treturn new THREE.NumberKeyframeTrack( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values );\n\n\t\t\t},\n\n\t\t\t// For all animated objects, times are defined separately for each axis\n\t\t\t// Here we'll combine the times into one sorted array without duplicates\n\t\t\tgetTimesForAllAxes: function ( curves ) {\n\n\t\t\t\tvar times = [];\n\n\t\t\t\t// first join together the times for each axis, if defined\n\t\t\t\tif ( curves.x !== undefined ) times = times.concat( curves.x.times );\n\t\t\t\tif ( curves.y !== undefined ) times = times.concat( curves.y.times );\n\t\t\t\tif ( curves.z !== undefined ) times = times.concat( curves.z.times );\n\n\t\t\t\t// then sort them and remove duplicates\n\t\t\t\ttimes = times.sort( function ( a, b ) {\n\n\t\t\t\t\treturn a - b;\n\n\t\t\t\t} ).filter( function ( elem, index, array ) {\n\n\t\t\t\t\treturn array.indexOf( elem ) == index;\n\n\t\t\t\t} );\n\n\t\t\t\treturn times;\n\n\t\t\t},\n\n\t\t\tgetKeyframeTrackValues: function ( times, curves, initialValue ) {\n\n\t\t\t\tvar prevValue = initialValue;\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tvar xIndex = - 1;\n\t\t\t\tvar yIndex = - 1;\n\t\t\t\tvar zIndex = - 1;\n\n\t\t\t\ttimes.forEach( function ( time ) {\n\n\t\t\t\t\tif ( curves.x ) xIndex = curves.x.times.indexOf( time );\n\t\t\t\t\tif ( curves.y ) yIndex = curves.y.times.indexOf( time );\n\t\t\t\t\tif ( curves.z ) zIndex = curves.z.times.indexOf( time );\n\n\t\t\t\t\t// if there is an x value defined for this frame, use that\n\t\t\t\t\tif ( xIndex !== - 1 ) {\n\n\t\t\t\t\t\tvar xValue = curves.x.values[ xIndex ];\n\t\t\t\t\t\tvalues.push( xValue );\n\t\t\t\t\t\tprevValue[ 0 ] = xValue;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// otherwise use the x value from the previous frame\n\t\t\t\t\t\tvalues.push( prevValue[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( yIndex !== - 1 ) {\n\n\t\t\t\t\t\tvar yValue = curves.y.values[ yIndex ];\n\t\t\t\t\t\tvalues.push( yValue );\n\t\t\t\t\t\tprevValue[ 1 ] = yValue;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvalues.push( prevValue[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( zIndex !== - 1 ) {\n\n\t\t\t\t\t\tvar zValue = curves.z.values[ zIndex ];\n\t\t\t\t\t\tvalues.push( zValue );\n\t\t\t\t\t\tprevValue[ 2 ] = zValue;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvalues.push( prevValue[ 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn values;\n\n\t\t\t},\n\n\t\t\t// Rotations are defined as Euler angles which can have values  of any size\n\t\t\t// These will be converted to quaternions which don't support values greater than\n\t\t\t// PI, so we'll interpolate large rotations\n\t\t\tinterpolateRotations: function ( curve ) {\n\n\t\t\t\tfor ( var i = 1; i < curve.values.length; i ++ ) {\n\n\t\t\t\t\tvar initialValue = curve.values[ i - 1 ];\n\t\t\t\t\tvar valuesSpan = curve.values[ i ] - initialValue;\n\n\t\t\t\t\tvar absoluteSpan = Math.abs( valuesSpan );\n\n\t\t\t\t\tif ( absoluteSpan >= 180 ) {\n\n\t\t\t\t\t\tvar numSubIntervals = absoluteSpan / 180;\n\n\t\t\t\t\t\tvar step = valuesSpan / numSubIntervals;\n\t\t\t\t\t\tvar nextValue = initialValue + step;\n\n\t\t\t\t\t\tvar initialTime = curve.times[ i - 1 ];\n\t\t\t\t\t\tvar timeSpan = curve.times[ i ] - initialTime;\n\t\t\t\t\t\tvar interval = timeSpan / numSubIntervals;\n\t\t\t\t\t\tvar nextTime = initialTime + interval;\n\n\t\t\t\t\t\tvar interpolatedTimes = [];\n\t\t\t\t\t\tvar interpolatedValues = [];\n\n\t\t\t\t\t\twhile ( nextTime < curve.times[ i ] ) {\n\n\t\t\t\t\t\t\tinterpolatedTimes.push( nextTime );\n\t\t\t\t\t\t\tnextTime += interval;\n\n\t\t\t\t\t\t\tinterpolatedValues.push( nextValue );\n\t\t\t\t\t\t\tnextValue += step;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurve.times = inject( curve.times, i, interpolatedTimes );\n\t\t\t\t\t\tcurve.values = inject( curve.values, i, interpolatedValues );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t};\n\n\t\t// parse an FBX file in ASCII format\n\t\tfunction TextParser() {}\n\n\t\tTextParser.prototype = {\n\n\t\t\tconstructor: TextParser,\n\n\t\t\tgetPrevNode: function () {\n\n\t\t\t\treturn this.nodeStack[ this.currentIndent - 2 ];\n\n\t\t\t},\n\n\t\t\tgetCurrentNode: function () {\n\n\t\t\t\treturn this.nodeStack[ this.currentIndent - 1 ];\n\n\t\t\t},\n\n\t\t\tgetCurrentProp: function () {\n\n\t\t\t\treturn this.currentProp;\n\n\t\t\t},\n\n\t\t\tpushStack: function ( node ) {\n\n\t\t\t\tthis.nodeStack.push( node );\n\t\t\t\tthis.currentIndent += 1;\n\n\t\t\t},\n\n\t\t\tpopStack: function () {\n\n\t\t\t\tthis.nodeStack.pop();\n\t\t\t\tthis.currentIndent -= 1;\n\n\t\t\t},\n\n\t\t\tsetCurrentProp: function ( val, name ) {\n\n\t\t\t\tthis.currentProp = val;\n\t\t\t\tthis.currentPropName = name;\n\n\t\t\t},\n\n\t\t\tparse: function ( text ) {\n\n\t\t\t\tthis.currentIndent = 0;\n\n\t\t\t\tthis.allNodes = new FBXTree();\n\t\t\t\tthis.nodeStack = [];\n\t\t\t\tthis.currentProp = [];\n\t\t\t\tthis.currentPropName = '';\n\n\t\t\t\tvar self = this;\n\n\t\t\t\tvar split = text.split( /[\\r\\n]+/ );\n\n\t\t\t\tsplit.forEach( function ( line, i ) {\n\n\t\t\t\t\tvar matchComment = line.match( /^[\\s\\t]*;/ );\n\t\t\t\t\tvar matchEmpty = line.match( /^[\\s\\t]*$/ );\n\n\t\t\t\t\tif ( matchComment || matchEmpty ) return;\n\n\t\t\t\t\tvar matchBeginning = line.match( '^\\\\t{' + self.currentIndent + '}(\\\\w+):(.*){', '' );\n\t\t\t\t\tvar matchProperty = line.match( '^\\\\t{' + ( self.currentIndent ) + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)' );\n\t\t\t\t\tvar matchEnd = line.match( '^\\\\t{' + ( self.currentIndent - 1 ) + '}}' );\n\n\t\t\t\t\tif ( matchBeginning ) {\n\n\t\t\t\t\t\tself.parseNodeBegin( line, matchBeginning );\n\n\t\t\t\t\t} else if ( matchProperty ) {\n\n\t\t\t\t\t\tself.parseNodeProperty( line, matchProperty, split[ ++ i ] );\n\n\t\t\t\t\t} else if ( matchEnd ) {\n\n\t\t\t\t\t\tself.popStack();\n\n\t\t\t\t\t} else if ( line.match( /^[^\\s\\t}]/ ) ) {\n\n\t\t\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\n\t\t\t\t\t\t// if this is encountered the line needs to be joined to the previous line\n\t\t\t\t\t\tself.parseNodePropertyContinued( line );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn this.allNodes;\n\n\t\t\t},\n\n\t\t\tparseNodeBegin: function ( line, property ) {\n\n\t\t\t\tvar nodeName = property[ 1 ].trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\t\tvar nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {\n\n\t\t\t\t\treturn attr.trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\t\t} );\n\n\t\t\t\tvar node = { name: nodeName };\n\t\t\t\tvar attrs = this.parseNodeAttr( nodeAttrs );\n\n\t\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\t\t// a top node\n\t\t\t\tif ( this.currentIndent === 0 ) {\n\n\t\t\t\t\tthis.allNodes.add( nodeName, node );\n\n\t\t\t\t} else { // a subnode\n\n\t\t\t\t\t// if the subnode already exists, append it\n\t\t\t\t\tif ( nodeName in currentNode ) {\n\n\t\t\t\t\t\t// special case Pose needs PoseNodes as an array\n\t\t\t\t\t\tif ( nodeName === 'PoseNode' ) {\n\n\t\t\t\t\t\t\tcurrentNode.PoseNode.push( node );\n\n\t\t\t\t\t\t} else if ( currentNode[ nodeName ].id !== undefined ) {\n\n\t\t\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\t\t\tcurrentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t\t} else if ( typeof attrs.id === 'number' ) {\n\n\t\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\t\tcurrentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t\t} else if ( nodeName !== 'Properties70' ) {\n\n\t\t\t\t\t\tif ( nodeName === 'PoseNode' )\tcurrentNode[ nodeName ] = [ node ];\n\t\t\t\t\t\telse currentNode[ nodeName ] = node;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( typeof attrs.id === 'number' ) node.id = attrs.id;\n\t\t\t\tif ( attrs.name !== '' ) node.attrName = attrs.name;\n\t\t\t\tif ( attrs.type !== '' ) node.attrType = attrs.type;\n\n\t\t\t\tthis.pushStack( node );\n\n\t\t\t},\n\n\t\t\tparseNodeAttr: function ( attrs ) {\n\n\t\t\t\tvar id = attrs[ 0 ];\n\n\t\t\t\tif ( attrs[ 0 ] !== '' ) {\n\n\t\t\t\t\tid = parseInt( attrs[ 0 ] );\n\n\t\t\t\t\tif ( isNaN( id ) ) {\n\n\t\t\t\t\t\tid = attrs[ 0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar name = '', type = '';\n\n\t\t\t\tif ( attrs.length > 1 ) {\n\n\t\t\t\t\tname = attrs[ 1 ].replace( /^(\\w+)::/, '' );\n\t\t\t\t\ttype = attrs[ 2 ];\n\n\t\t\t\t}\n\n\t\t\t\treturn { id: id, name: name, type: type };\n\n\t\t\t},\n\n\t\t\tparseNodeProperty: function ( line, property, contentLine ) {\n\n\t\t\t\tvar propName = property[ 1 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\t\t\t\tvar propValue = property[ 2 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\n\t\t\t\t// for special case: base64 image data follows \"Content: ,\" line\n\t\t\t\t//\tContent: ,\n\t\t\t\t//\t \"/9j/4RDaRXhpZgAATU0A...\"\n\t\t\t\tif ( propName === 'Content' && propValue === ',' ) {\n\n\t\t\t\t\tpropValue = contentLine.replace( /\"/g, '' ).replace( /,$/, '' ).trim();\n\n\t\t\t\t}\n\n\t\t\t\tvar currentNode = this.getCurrentNode();\n\t\t\t\tvar parentName = currentNode.name;\n\n\t\t\t\tif ( parentName === 'Properties70' ) {\n\n\t\t\t\t\tthis.parseNodeSpecialProperty( line, propName, propValue );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\t// Connections\n\t\t\t\tif ( propName === 'C' ) {\n\n\t\t\t\t\tvar connProps = propValue.split( ',' ).slice( 1 );\n\t\t\t\t\tvar from = parseInt( connProps[ 0 ] );\n\t\t\t\t\tvar to = parseInt( connProps[ 1 ] );\n\n\t\t\t\t\tvar rest = propValue.split( ',' ).slice( 3 );\n\n\t\t\t\t\trest = rest.map( function ( elem ) {\n\n\t\t\t\t\t\treturn elem.trim().replace( /^\"/, '' );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tpropName = 'connections';\n\t\t\t\t\tpropValue = [ from, to ];\n\t\t\t\t\tappend( propValue, rest );\n\n\t\t\t\t\tif ( currentNode[ propName ] === undefined ) {\n\n\t\t\t\t\t\tcurrentNode[ propName ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Node\n\t\t\t\tif ( propName === 'Node' ) currentNode.id = propValue;\n\n\t\t\t\t// connections\n\t\t\t\tif ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {\n\n\t\t\t\t\tcurrentNode[ propName ].push( propValue );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( propName !== 'a' ) currentNode[ propName ] = propValue;\n\t\t\t\t\telse currentNode.a = propValue;\n\n\t\t\t\t}\n\n\t\t\t\tthis.setCurrentProp( currentNode, propName );\n\n\t\t\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\n\t\t\t\tif ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {\n\n\t\t\t\t\tcurrentNode.a = parseNumberArray( propValue );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tparseNodePropertyContinued: function ( line ) {\n\n\t\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\t\tcurrentNode.a += line;\n\n\t\t\t\t// if the line doesn't end in ',' we have reached the end of the property value\n\t\t\t\t// so convert the string to an array\n\t\t\t\tif ( line.slice( - 1 ) !== ',' ) {\n\n\t\t\t\t\tcurrentNode.a = parseNumberArray( currentNode.a );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t// parse \"Property70\"\n\t\t\tparseNodeSpecialProperty: function ( line, propName, propValue ) {\n\n\t\t\t\t// split this\n\t\t\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n\t\t\t\t// into array like below\n\t\t\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n\t\t\t\tvar props = propValue.split( '\",' ).map( function ( prop ) {\n\n\t\t\t\t\treturn prop.trim().replace( /^\\\"/, '' ).replace( /\\s/, '_' );\n\n\t\t\t\t} );\n\n\t\t\t\tvar innerPropName = props[ 0 ];\n\t\t\t\tvar innerPropType1 = props[ 1 ];\n\t\t\t\tvar innerPropType2 = props[ 2 ];\n\t\t\t\tvar innerPropFlag = props[ 3 ];\n\t\t\t\tvar innerPropValue = props[ 4 ];\n\n\t\t\t\t// cast values where needed, otherwise leave as strings\n\t\t\t\tswitch ( innerPropType1 ) {\n\n\t\t\t\t\tcase 'int':\n\t\t\t\t\tcase 'enum':\n\t\t\t\t\tcase 'bool':\n\t\t\t\t\tcase 'ULongLong':\n\t\t\t\t\tcase 'double':\n\t\t\t\t\tcase 'Number':\n\t\t\t\t\tcase 'FieldOfView':\n\t\t\t\t\t\tinnerPropValue = parseFloat( innerPropValue );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Color':\n\t\t\t\t\tcase 'ColorRGB':\n\t\t\t\t\tcase 'Vector3D':\n\t\t\t\t\tcase 'Lcl_Translation':\n\t\t\t\t\tcase 'Lcl_Rotation':\n\t\t\t\t\tcase 'Lcl_Scaling':\n\t\t\t\t\t\tinnerPropValue = parseNumberArray( innerPropValue );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// CAUTION: these props must append to parent's parent\n\t\t\t\tthis.getPrevNode()[ innerPropName ] = {\n\n\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t'value': innerPropValue\n\n\t\t\t\t};\n\n\t\t\t\tthis.setCurrentProp( this.getPrevNode(), innerPropName );\n\n\t\t\t},\n\n\t\t};\n\n\t\t// Parse an FBX file in Binary format\n\t\tfunction BinaryParser() {}\n\n\t\tBinaryParser.prototype = {\n\n\t\t\tconstructor: BinaryParser,\n\n\t\t\tparse: function ( buffer ) {\n\n\t\t\t\tvar reader = new BinaryReader( buffer );\n\t\t\t\treader.skip( 23 ); // skip magic 23 bytes\n\n\t\t\t\tvar version = reader.getUint32();\n\n\t\t\t\tconsole.log( 'THREE.FBXLoader: FBX binary version: ' + version );\n\n\t\t\t\tvar allNodes = new FBXTree();\n\n\t\t\t\twhile ( ! this.endOfContent( reader ) ) {\n\n\t\t\t\t\tvar node = this.parseNode( reader, version );\n\t\t\t\t\tif ( node !== null ) allNodes.add( node.name, node );\n\n\t\t\t\t}\n\n\t\t\t\treturn allNodes;\n\n\t\t\t},\n\n\t\t\t// Check if reader has reached the end of content.\n\t\t\tendOfContent: function ( reader ) {\n\n\t\t\t\t// footer size: 160bytes + 16-byte alignment padding\n\t\t\t\t// - 16bytes: magic\n\t\t\t\t// - padding til 16-byte alignment (at least 1byte?)\n\t\t\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\n\t\t\t\t// - 4bytes: magic\n\t\t\t\t// - 4bytes: version\n\t\t\t\t// - 120bytes: zero\n\t\t\t\t// - 16bytes: magic\n\t\t\t\tif ( reader.size() % 16 === 0 ) {\n\n\t\t\t\t\treturn ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t// recursively parse nodes until the end of the file is reached\n\t\t\tparseNode: function ( reader, version ) {\n\n\t\t\t\tvar node = {};\n\n\t\t\t\t// The first three data sizes depends on version.\n\t\t\t\tvar endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\t\t\t\tvar numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t\t\t// note: do not remove this even if you get a linter warning as it moves the buffer forward\n\t\t\t\tvar propertyListLen = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t\t\tvar nameLen = reader.getUint8();\n\t\t\t\tvar name = reader.getString( nameLen );\n\n\t\t\t\t// Regards this node as NULL-record if endOffset is zero\n\t\t\t\tif ( endOffset === 0 ) return null;\n\n\t\t\t\tvar propertyList = [];\n\n\t\t\t\tfor ( var i = 0; i < numProperties; i ++ ) {\n\n\t\t\t\t\tpropertyList.push( this.parseProperty( reader ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\n\t\t\t\tvar id = propertyList.length > 0 ? propertyList[ 0 ] : '';\n\t\t\t\tvar attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';\n\t\t\t\tvar attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';\n\n\t\t\t\t// check if this node represents just a single property\n\t\t\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\t\t\t\tnode.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;\n\n\t\t\t\twhile ( endOffset > reader.getOffset() ) {\n\n\t\t\t\t\tvar subNode = this.parseNode( reader, version );\n\n\t\t\t\t\tif ( subNode !== null ) this.parseSubNode( name, node, subNode );\n\n\t\t\t\t}\n\n\t\t\t\tnode.propertyList = propertyList; // raw property list used by parent\n\n\t\t\t\tif ( typeof id === 'number' ) node.id = id;\n\t\t\t\tif ( attrName !== '' ) node.attrName = attrName;\n\t\t\t\tif ( attrType !== '' ) node.attrType = attrType;\n\t\t\t\tif ( name !== '' ) node.name = name;\n\n\t\t\t\treturn node;\n\n\t\t\t},\n\n\t\t\tparseSubNode: function ( name, node, subNode ) {\n\n\t\t\t\t// special case: child node is single property\n\t\t\t\tif ( subNode.singleProperty === true ) {\n\n\t\t\t\t\tvar value = subNode.propertyList[ 0 ];\n\n\t\t\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t\t\tsubNode.a = value;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode[ subNode.name ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( name === 'Connections' && subNode.name === 'C' ) {\n\n\t\t\t\t\tvar array = [];\n\n\t\t\t\t\tsubNode.propertyList.forEach( function ( property, i ) {\n\n\t\t\t\t\t\t// first Connection is FBX type (OO, OP, etc.). We'll discard these\n\t\t\t\t\t\tif ( i !== 0 ) array.push( property );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( node.connections === undefined ) {\n\n\t\t\t\t\t\tnode.connections = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnode.connections.push( array );\n\n\t\t\t\t} else if ( subNode.name === 'Properties70' ) {\n\n\t\t\t\t\tvar keys = Object.keys( subNode );\n\n\t\t\t\t\tkeys.forEach( function ( key ) {\n\n\t\t\t\t\t\tnode[ key ] = subNode[ key ];\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else if ( name === 'Properties70' && subNode.name === 'P' ) {\n\n\t\t\t\t\tvar innerPropName = subNode.propertyList[ 0 ];\n\t\t\t\t\tvar innerPropType1 = subNode.propertyList[ 1 ];\n\t\t\t\t\tvar innerPropType2 = subNode.propertyList[ 2 ];\n\t\t\t\t\tvar innerPropFlag = subNode.propertyList[ 3 ];\n\t\t\t\t\tvar innerPropValue;\n\n\t\t\t\t\tif ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );\n\t\t\t\t\tif ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );\n\n\t\t\t\t\tif ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {\n\n\t\t\t\t\t\tinnerPropValue = [\n\t\t\t\t\t\t\tsubNode.propertyList[ 4 ],\n\t\t\t\t\t\t\tsubNode.propertyList[ 5 ],\n\t\t\t\t\t\t\tsubNode.propertyList[ 6 ]\n\t\t\t\t\t\t];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tinnerPropValue = subNode.propertyList[ 4 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// this will be copied to parent, see above\n\t\t\t\t\tnode[ innerPropName ] = {\n\n\t\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t\t'value': innerPropValue\n\n\t\t\t\t\t};\n\n\t\t\t\t} else if ( node[ subNode.name ] === undefined ) {\n\n\t\t\t\t\tif ( typeof subNode.id === 'number' ) {\n\n\t\t\t\t\t\tnode[ subNode.name ] = {};\n\t\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( subNode.name === 'PoseNode' ) {\n\n\t\t\t\t\t\tif ( ! Array.isArray( node[ subNode.name ] ) ) {\n\n\t\t\t\t\t\t\tnode[ subNode.name ] = [ node[ subNode.name ] ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnode[ subNode.name ].push( subNode );\n\n\t\t\t\t\t} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {\n\n\t\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tparseProperty: function ( reader ) {\n\n\t\t\t\tvar type = reader.getString( 1 );\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\treturn reader.getBoolean();\n\n\t\t\t\t\tcase 'D':\n\t\t\t\t\t\treturn reader.getFloat64();\n\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\treturn reader.getFloat32();\n\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\treturn reader.getInt32();\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\treturn reader.getInt64();\n\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\t\treturn reader.getArrayBuffer( length );\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\t\treturn reader.getString( length );\n\n\t\t\t\t\tcase 'Y':\n\t\t\t\t\t\treturn reader.getInt16();\n\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'c':\n\t\t\t\t\tcase 'd':\n\t\t\t\t\tcase 'f':\n\t\t\t\t\tcase 'i':\n\t\t\t\t\tcase 'l':\n\n\t\t\t\t\t\tvar arrayLength = reader.getUint32();\n\t\t\t\t\t\tvar encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\t\t\t\t\t\tvar compressedLength = reader.getUint32();\n\n\t\t\t\t\t\tif ( encoding === 0 ) {\n\n\t\t\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\t\treturn reader.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\t\treturn reader.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\t\treturn reader.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\t\treturn reader.getInt32Array( arrayLength );\n\n\t\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\t\treturn reader.getInt64Array( arrayLength );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( typeof Zlib === 'undefined' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar inflate = new Zlib.Inflate( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) ); // eslint-disable-line no-undef\n\t\t\t\t\t\tvar reader2 = new BinaryReader( inflate.decompress().buffer );\n\n\t\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\treturn reader2.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\treturn reader2.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\treturn reader2.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\treturn reader2.getInt32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\treturn reader2.getInt64Array( arrayLength );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown property type ' + type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction BinaryReader( buffer, littleEndian ) {\n\n\t\t\tthis.dv = new DataView( buffer );\n\t\t\tthis.offset = 0;\n\t\t\tthis.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;\n\n\t\t}\n\n\t\tBinaryReader.prototype = {\n\n\t\t\tconstructor: BinaryReader,\n\n\t\t\tgetOffset: function () {\n\n\t\t\t\treturn this.offset;\n\n\t\t\t},\n\n\t\t\tsize: function () {\n\n\t\t\t\treturn this.dv.buffer.byteLength;\n\n\t\t\t},\n\n\t\t\tskip: function ( length ) {\n\n\t\t\t\tthis.offset += length;\n\n\t\t\t},\n\n\t\t\t// seems like true/false representation depends on exporter.\n\t\t\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n\t\t\t// then sees LSB.\n\t\t\tgetBoolean: function () {\n\n\t\t\t\treturn ( this.getUint8() & 1 ) === 1;\n\n\t\t\t},\n\n\t\t\tgetBooleanArray: function ( size ) {\n\n\t\t\t\tvar a = [];\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\t\ta.push( this.getBoolean() );\n\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\n\t\t\t},\n\n\t\t\tgetUint8: function () {\n\n\t\t\t\tvar value = this.dv.getUint8( this.offset );\n\t\t\t\tthis.offset += 1;\n\t\t\t\treturn value;\n\n\t\t\t},\n\n\t\t\tgetInt16: function () {\n\n\t\t\t\tvar value = this.dv.getInt16( this.offset, this.littleEndian );\n\t\t\t\tthis.offset += 2;\n\t\t\t\treturn value;\n\n\t\t\t},\n\n\t\t\tgetInt32: function () {\n\n\t\t\t\tvar value = this.dv.getInt32( this.offset, this.littleEndian );\n\t\t\t\tthis.offset += 4;\n\t\t\t\treturn value;\n\n\t\t\t},\n\n\t\t\tgetInt32Array: function ( size ) {\n\n\t\t\t\tvar a = [];\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\t\ta.push( this.getInt32() );\n\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\n\t\t\t},\n\n\t\t\tgetUint32: function () {\n\n\t\t\t\tvar value = this.dv.getUint32( this.offset, this.littleEndian );\n\t\t\t\tthis.offset += 4;\n\t\t\t\treturn value;\n\n\t\t\t},\n\n\t\t\t// JavaScript doesn't support 64-bit integer so calculate this here\n\t\t\t// 1 << 32 will return 1 so using multiply operation instead here.\n\t\t\t// There's a possibility that this method returns wrong value if the value\n\t\t\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n\t\t\t// TODO: safely handle 64-bit integer\n\t\t\tgetInt64: function () {\n\n\t\t\t\tvar low, high;\n\n\t\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\t\tlow = this.getUint32();\n\t\t\t\t\thigh = this.getUint32();\n\n\t\t\t\t} else {\n\n\t\t\t\t\thigh = this.getUint32();\n\t\t\t\t\tlow = this.getUint32();\n\n\t\t\t\t}\n\n\t\t\t\t// calculate negative value\n\t\t\t\tif ( high & 0x80000000 ) {\n\n\t\t\t\t\thigh = ~ high & 0xFFFFFFFF;\n\t\t\t\t\tlow = ~ low & 0xFFFFFFFF;\n\n\t\t\t\t\tif ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\t\tlow = ( low + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\t\treturn - ( high * 0x100000000 + low );\n\n\t\t\t\t}\n\n\t\t\t\treturn high * 0x100000000 + low;\n\n\t\t\t},\n\n\t\t\tgetInt64Array: function ( size ) {\n\n\t\t\t\tvar a = [];\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\t\ta.push( this.getInt64() );\n\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\n\t\t\t},\n\n\t\t\t// Note: see getInt64() comment\n\t\t\tgetUint64: function () {\n\n\t\t\t\tvar low, high;\n\n\t\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\t\tlow = this.getUint32();\n\t\t\t\t\thigh = this.getUint32();\n\n\t\t\t\t} else {\n\n\t\t\t\t\thigh = this.getUint32();\n\t\t\t\t\tlow = this.getUint32();\n\n\t\t\t\t}\n\n\t\t\t\treturn high * 0x100000000 + low;\n\n\t\t\t},\n\n\t\t\tgetFloat32: function () {\n\n\t\t\t\tvar value = this.dv.getFloat32( this.offset, this.littleEndian );\n\t\t\t\tthis.offset += 4;\n\t\t\t\treturn value;\n\n\t\t\t},\n\n\t\t\tgetFloat32Array: function ( size ) {\n\n\t\t\t\tvar a = [];\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\t\ta.push( this.getFloat32() );\n\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\n\t\t\t},\n\n\t\t\tgetFloat64: function () {\n\n\t\t\t\tvar value = this.dv.getFloat64( this.offset, this.littleEndian );\n\t\t\t\tthis.offset += 8;\n\t\t\t\treturn value;\n\n\t\t\t},\n\n\t\t\tgetFloat64Array: function ( size ) {\n\n\t\t\t\tvar a = [];\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\t\ta.push( this.getFloat64() );\n\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\n\t\t\t},\n\n\t\t\tgetArrayBuffer: function ( size ) {\n\n\t\t\t\tvar value = this.dv.buffer.slice( this.offset, this.offset + size );\n\t\t\t\tthis.offset += size;\n\t\t\t\treturn value;\n\n\t\t\t},\n\n\t\t\tgetString: function ( size ) {\n\n\t\t\t\t// note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n\t\t\t\tvar a = [];\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\t\ta[ i ] = this.getUint8();\n\n\t\t\t\t}\n\n\t\t\t\tvar nullByte = a.indexOf( 0 );\n\t\t\t\tif ( nullByte >= 0 ) a = a.slice( 0, nullByte );\n\n\t\t\t\treturn THREE.LoaderUtils.decodeText( new Uint8Array( a ) );\n\n\t\t\t}\n\n\t\t};\n\n\t\t// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n\t\t// and BinaryParser( FBX Binary format)\n\t\tfunction FBXTree() {}\n\n\t\tFBXTree.prototype = {\n\n\t\t\tconstructor: FBXTree,\n\n\t\t\tadd: function ( key, val ) {\n\n\t\t\t\tthis[ key ] = val;\n\n\t\t\t},\n\n\t\t};\n\n\t\t// ************** UTILITY FUNCTIONS **************\n\n\t\tfunction isFbxFormatBinary( buffer ) {\n\n\t\t\tvar CORRECT = 'Kaydara FBX Binary  \\0';\n\n\t\t\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );\n\n\t\t}\n\n\t\tfunction isFbxFormatASCII( text ) {\n\n\t\t\tvar CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\' ];\n\n\t\t\tvar cursor = 0;\n\n\t\t\tfunction read( offset ) {\n\n\t\t\t\tvar result = text[ offset - 1 ];\n\t\t\t\ttext = text.slice( cursor + offset );\n\t\t\t\tcursor ++;\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < CORRECT.length; ++ i ) {\n\n\t\t\t\tvar num = read( 1 );\n\t\t\t\tif ( num === CORRECT[ i ] ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction getFbxVersion( text ) {\n\n\t\t\tvar versionRegExp = /FBXVersion: (\\d+)/;\n\t\t\tvar match = text.match( versionRegExp );\n\t\t\tif ( match ) {\n\n\t\t\t\tvar version = parseInt( match[ 1 ] );\n\t\t\t\treturn version;\n\n\t\t\t}\n\t\t\tthrow new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );\n\n\t\t}\n\n\t\t// Converts FBX ticks into real time seconds.\n\t\tfunction convertFBXTimeToSeconds( time ) {\n\n\t\t\treturn time / 46186158000;\n\n\t\t}\n\n\t\tvar dataArray = [];\n\n\t\t// extracts the data from the correct position in the FBX array based on indexing type\n\t\tfunction getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {\n\n\t\t\tvar index;\n\n\t\t\tswitch ( infoObject.mappingType ) {\n\n\t\t\t\tcase 'ByPolygonVertex' :\n\t\t\t\t\tindex = polygonVertexIndex;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ByPolygon' :\n\t\t\t\t\tindex = polygonIndex;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ByVertice' :\n\t\t\t\t\tindex = vertexIndex;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AllSame' :\n\t\t\t\t\tindex = infoObject.indices[ 0 ];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault :\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );\n\n\t\t\t}\n\n\t\t\tif ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];\n\n\t\t\tvar from = index * infoObject.dataSize;\n\t\t\tvar to = from + infoObject.dataSize;\n\n\t\t\treturn slice( dataArray, infoObject.buffer, from, to );\n\n\t\t}\n\n\t\tvar tempEuler = new THREE.Euler();\n\t\tvar tempVec = new THREE.Vector3();\n\n\t\t// generate transformation from FBX transform data\n\t\t// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n\t\t// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\n\t\tfunction generateTransform( transformData ) {\n\n\t\t\tvar lTranslationM = new THREE.Matrix4();\n\t\t\tvar lPreRotationM = new THREE.Matrix4();\n\t\t\tvar lRotationM = new THREE.Matrix4();\n\t\t\tvar lPostRotationM = new THREE.Matrix4();\n\n\t\t\tvar lScalingM = new THREE.Matrix4();\n\t\t\tvar lScalingPivotM = new THREE.Matrix4();\n\t\t\tvar lScalingOffsetM = new THREE.Matrix4();\n\t\t\tvar lRotationOffsetM = new THREE.Matrix4();\n\t\t\tvar lRotationPivotM = new THREE.Matrix4();\n\n\t\t\tvar lParentGX = new THREE.Matrix4();\n\t\t\tvar lGlobalT = new THREE.Matrix4();\n\n\t\t\tvar inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0;\n\n\t\t\tif ( transformData.translation ) lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) );\n\n\t\t\tif ( transformData.preRotation ) {\n\n\t\t\t\tvar array = transformData.preRotation.map( THREE.MathUtils.degToRad );\n\t\t\t\tarray.push( transformData.eulerOrder );\n\t\t\t\tlPreRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t\t\t}\n\n\t\t\tif ( transformData.rotation ) {\n\n\t\t\t\tvar array = transformData.rotation.map( THREE.MathUtils.degToRad );\n\t\t\t\tarray.push( transformData.eulerOrder );\n\t\t\t\tlRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t\t\t}\n\n\t\t\tif ( transformData.postRotation ) {\n\n\t\t\t\tvar array = transformData.postRotation.map( THREE.MathUtils.degToRad );\n\t\t\t\tarray.push( transformData.eulerOrder );\n\t\t\t\tlPostRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t\t\t}\n\n\t\t\tif ( transformData.scale ) lScalingM.scale( tempVec.fromArray( transformData.scale ) );\n\n\t\t\t// Pivots and offsets\n\t\t\tif ( transformData.scalingOffset ) lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) );\n\t\t\tif ( transformData.scalingPivot ) lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) );\n\t\t\tif ( transformData.rotationOffset ) lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) );\n\t\t\tif ( transformData.rotationPivot ) lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) );\n\n\t\t\t// parent transform\n\t\t\tif ( transformData.parentMatrixWorld ) lParentGX = transformData.parentMatrixWorld;\n\n\t\t\t// Global Rotation\n\t\t\tvar lLRM = lPreRotationM.multiply( lRotationM ).multiply( lPostRotationM );\n\t\t\tvar lParentGRM = new THREE.Matrix4();\n\t\t\tlParentGX.extractRotation( lParentGRM );\n\n\t\t\t// Global Shear*Scaling\n\t\t\tvar lParentTM = new THREE.Matrix4();\n\t\t\tvar lLSM;\n\t\t\tvar lParentGSM;\n\t\t\tvar lParentGRSM;\n\n\t\t\tlParentTM.copyPosition( lParentGX );\n\t\t\tlParentGRSM = lParentTM.getInverse( lParentTM ).multiply( lParentGX );\n\t\t\tlParentGSM = lParentGRM.getInverse( lParentGRM ).multiply( lParentGRSM );\n\t\t\tlLSM = lScalingM;\n\n\t\t\tvar lGlobalRS;\n\t\t\tif ( inheritType === 0 ) {\n\n\t\t\t\tlGlobalRS = lParentGRM.multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM );\n\n\t\t\t} else if ( inheritType === 1 ) {\n\n\t\t\t\tlGlobalRS = lParentGRM.multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM );\n\n\t\t\t} else {\n\n\t\t\t\tvar lParentLSM = new THREE.Matrix4().copy( lScalingM );\n\n\t\t\t\tvar lParentGSM_noLocal = lParentGSM.multiply( lParentLSM.getInverse( lParentLSM ) );\n\n\t\t\t\tlGlobalRS = lParentGRM.multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM );\n\n\t\t\t}\n\n\t\t\t// Calculate the local transform matrix\n\t\t\tvar lTransform = lTranslationM.multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM.getInverse( lRotationPivotM ) ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM.getInverse( lScalingPivotM ) );\n\n\t\t\tvar lLocalTWithAllPivotAndOffsetInfo = new THREE.Matrix4().copyPosition( lTransform );\n\n\t\t\tvar lGlobalTranslation = lParentGX.multiply( lLocalTWithAllPivotAndOffsetInfo );\n\t\t\tlGlobalT.copyPosition( lGlobalTranslation );\n\n\t\t\tlTransform = lGlobalT.multiply( lGlobalRS );\n\n\t\t\treturn lTransform;\n\n\t\t}\n\n\t\t// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n\t\t// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n\t\tfunction getEulerOrder( order ) {\n\n\t\t\torder = order || 0;\n\n\t\t\tvar enums = [\n\t\t\t\t'ZYX', // -> XYZ extrinsic\n\t\t\t\t'YZX', // -> XZY extrinsic\n\t\t\t\t'XZY', // -> YZX extrinsic\n\t\t\t\t'ZXY', // -> YXZ extrinsic\n\t\t\t\t'YXZ', // -> ZXY extrinsic\n\t\t\t\t'XYZ', // -> ZYX extrinsic\n\t\t\t\t//'SphericXYZ', // not possible to support\n\t\t\t];\n\n\t\t\tif ( order === 6 ) {\n\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );\n\t\t\t\treturn enums[ 0 ];\n\n\t\t\t}\n\n\t\t\treturn enums[ order ];\n\n\t\t}\n\n\t\t// Parses comma separated list of numbers and returns them an array.\n\t\t// Used internally by the TextParser\n\t\tfunction parseNumberArray( value ) {\n\n\t\t\tvar array = value.split( ',' ).map( function ( val ) {\n\n\t\t\t\treturn parseFloat( val );\n\n\t\t\t} );\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction convertArrayBufferToString( buffer, from, to ) {\n\n\t\t\tif ( from === undefined ) from = 0;\n\t\t\tif ( to === undefined ) to = buffer.byteLength;\n\n\t\t\treturn THREE.LoaderUtils.decodeText( new Uint8Array( buffer, from, to ) );\n\n\t\t}\n\n\t\tfunction append( a, b ) {\n\n\t\t\tfor ( var i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {\n\n\t\t\t\ta[ j ] = b[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction slice( a, b, from, to ) {\n\n\t\t\tfor ( var i = from, j = 0; i < to; i ++, j ++ ) {\n\n\t\t\t\ta[ j ] = b[ i ];\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t}\n\n\t\t// inject array a2 into array a1 at index\n\t\tfunction inject( a1, index, a2 ) {\n\n\t\t\treturn a1.slice( 0, index ).concat( a2 ).concat( a1.slice( index ) );\n\n\t\t}\n\n\t\treturn FBXLoader;\n\n\t} )();\n\t\n\treturn THREE.FBXLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/GCodeLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * THREE.GCodeLoader is used to load gcode files usually used for 3D printing or CNC applications.\n\t *\n\t * Gcode files are composed by commands used by machines to create objects.\n\t *\n\t * @class THREE.GCodeLoader\n\t * @param {Manager} manager Loading manager.\n\t * @author tentone\n\t * @author joewalnes\n\t */\n\n\tTHREE.GCodeLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.splitLayer = false;\n\n\t};\n\n\tTHREE.GCodeLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.GCodeLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar self = this;\n\n\t\t\tvar loader = new THREE.FileLoader( self.manager );\n\t\t\tloader.setPath( self.path );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( self.parse( text ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data ) {\n\n\t\t\tvar state = { x: 0, y: 0, z: 0, e: 0, f: 0, extruding: false, relative: false };\n\t\t\tvar layers = [];\n\n\t\t\tvar currentLayer = undefined;\n\n\t\t\tvar pathMaterial = new THREE.LineBasicMaterial( { color: 0xFF0000 } );\n\t\t\tpathMaterial.name = 'path';\n\n\t\t\tvar extrudingMaterial = new THREE.LineBasicMaterial( { color: 0x00FF00 } );\n\t\t\textrudingMaterial.name = 'extruded';\n\n\t\t\tfunction newLayer( line ) {\n\n\t\t\t\tcurrentLayer = { vertex: [], pathVertex: [], z: line.z };\n\t\t\t\tlayers.push( currentLayer );\n\n\t\t\t}\n\n\t\t\t//Create lie segment between p1 and p2\n\t\t\tfunction addSegment( p1, p2 ) {\n\n\t\t\t\tif ( currentLayer === undefined ) {\n\n\t\t\t\t\tnewLayer( p1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( line.extruding ) {\n\n\t\t\t\t\tcurrentLayer.vertex.push( p1.x, p1.y, p1.z );\n\t\t\t\t\tcurrentLayer.vertex.push( p2.x, p2.y, p2.z );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentLayer.pathVertex.push( p1.x, p1.y, p1.z );\n\t\t\t\t\tcurrentLayer.pathVertex.push( p2.x, p2.y, p2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction delta( v1, v2 ) {\n\n\t\t\t\treturn state.relative ? v2 : v2 - v1;\n\n\t\t\t}\n\n\t\t\tfunction absolute( v1, v2 ) {\n\n\t\t\t\treturn state.relative ? v1 + v2 : v2;\n\n\t\t\t}\n\n\t\t\tvar lines = data.replace( /;.+/g, '' ).split( '\\n' );\n\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tvar tokens = lines[ i ].split( ' ' );\n\t\t\t\tvar cmd = tokens[ 0 ].toUpperCase();\n\n\t\t\t\t//Argumments\n\t\t\t\tvar args = {};\n\t\t\t\ttokens.splice( 1 ).forEach( function ( token ) {\n\n\t\t\t\t\tif ( token[ 0 ] !== undefined ) {\n\n\t\t\t\t\t\tvar key = token[ 0 ].toLowerCase();\n\t\t\t\t\t\tvar value = parseFloat( token.substring( 1 ) );\n\t\t\t\t\t\targs[ key ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\t//Process commands\n\t\t\t\t//G0/G1 – Linear Movement\n\t\t\t\tif ( cmd === 'G0' || cmd === 'G1' ) {\n\n\t\t\t\t\tvar line = {\n\t\t\t\t\t\tx: args.x !== undefined ? absolute( state.x, args.x ) : state.x,\n\t\t\t\t\t\ty: args.y !== undefined ? absolute( state.y, args.y ) : state.y,\n\t\t\t\t\t\tz: args.z !== undefined ? absolute( state.z, args.z ) : state.z,\n\t\t\t\t\t\te: args.e !== undefined ? absolute( state.e, args.e ) : state.e,\n\t\t\t\t\t\tf: args.f !== undefined ? absolute( state.f, args.f ) : state.f,\n\t\t\t\t\t};\n\n\t\t\t\t\t//Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position\n\t\t\t\t\tif ( delta( state.e, line.e ) > 0 ) {\n\n\t\t\t\t\t\tline.extruding = delta( state.e, line.e ) > 0;\n\n\t\t\t\t\t\tif ( currentLayer == undefined || line.z != currentLayer.z ) {\n\n\t\t\t\t\t\t\tnewLayer( line );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\taddSegment( state, line );\n\t\t\t\t\tstate = line;\n\n\t\t\t\t} else if ( cmd === 'G2' || cmd === 'G3' ) {\n\n\t\t\t\t\t//G2/G3 - Arc Movement ( G2 clock wise and G3 counter clock wise )\n\t\t\t\t\t//console.warn( 'THREE.GCodeLoader: Arc command not supported' );\n\n\t\t\t\t} else if ( cmd === 'G90' ) {\n\n\t\t\t\t\t//G90: Set to Absolute Positioning\n\t\t\t\t\tstate.relative = false;\n\n\t\t\t\t} else if ( cmd === 'G91' ) {\n\n\t\t\t\t\t//G91: Set to state.relative Positioning\n\t\t\t\t\tstate.relative = true;\n\n\t\t\t\t} else if ( cmd === 'G92' ) {\n\n\t\t\t\t\t//G92: Set Position\n\t\t\t\t\tvar line = state;\n\t\t\t\t\tline.x = args.x !== undefined ? args.x : line.x;\n\t\t\t\t\tline.y = args.y !== undefined ? args.y : line.y;\n\t\t\t\t\tline.z = args.z !== undefined ? args.z : line.z;\n\t\t\t\t\tline.e = args.e !== undefined ? args.e : line.e;\n\t\t\t\t\tstate = line;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t//console.warn( 'THREE.GCodeLoader: Command not supported:' + cmd );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction addObject( vertex, extruding ) {\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertex, 3 ) );\n\n\t\t\t\tvar segments = new THREE.LineSegments( geometry, extruding ? extrudingMaterial : pathMaterial );\n\t\t\t\tsegments.name = 'layer' + i;\n\t\t\t\tobject.add( segments );\n\n\t\t\t}\n\n\t\t\tvar object = new THREE.Group();\n\t\t\tobject.name = 'gcode';\n\n\t\t\tif ( this.splitLayer ) {\n\n\t\t\t\tfor ( var i = 0; i < layers.length; i ++ ) {\n\n\t\t\t\t\tvar layer = layers[ i ];\n\t\t\t\t\taddObject( layer.vertex, true );\n\t\t\t\t\taddObject( layer.pathVertex, false );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar vertex = [], pathVertex = [];\n\n\t\t\t\tfor ( var i = 0; i < layers.length; i ++ ) {\n\n\t\t\t\t\tvar layer = layers[ i ];\n\n\t\t\t\t\tvertex = vertex.concat( layer.vertex );\n\t\t\t\t\tpathVertex = pathVertex.concat( layer.pathVertex );\n\n\t\t\t\t}\n\n\t\t\t\taddObject( vertex, true );\n\t\t\t\taddObject( pathVertex, false );\n\n\t\t\t}\n\n\t\t\tobject.quaternion.setFromEuler( new THREE.Euler( - Math.PI / 2, 0, 0 ) );\n\n\t\t\treturn object;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.GCodeLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/GLTFLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Rich Tibbett / https://github.com/richtr\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Tony Parisi / http://www.tonyparisi.com/\n\t * @author Takahiro / https://github.com/takahirox\n\t * @author Don McCurdy / https://www.donmccurdy.com\n\t */\n\n\tTHREE.GLTFLoader = ( function () {\n\n\t\tfunction GLTFLoader( manager ) {\n\n\t\t\tTHREE.Loader.call( this, manager );\n\n\t\t\tthis.dracoLoader = null;\n\t\t\tthis.ddsLoader = null;\n\n\t\t}\n\n\t\tGLTFLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\t\tconstructor: GLTFLoader,\n\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tvar resourcePath;\n\n\t\t\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\t\t\tresourcePath = this.resourcePath;\n\n\t\t\t\t} else if ( this.path !== '' ) {\n\n\t\t\t\t\tresourcePath = this.path;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresourcePath = THREE.LoaderUtils.extractUrlBase( url );\n\n\t\t\t\t}\n\n\t\t\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\tvar _onError = function ( e ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t};\n\n\t\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\t\tif ( scope.crossOrigin === 'use-credentials' ) {\n\n\t\t\t\t\tloader.setWithCredentials( true );\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( url, function ( data ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t\t}, _onError );\n\n\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t_onError( e );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, onProgress, _onError );\n\n\t\t\t},\n\n\t\t\tsetDRACOLoader: function ( dracoLoader ) {\n\n\t\t\t\tthis.dracoLoader = dracoLoader;\n\t\t\t\treturn this;\n\n\t\t\t},\n\n\t\t\tsetDDSLoader: function ( ddsLoader ) {\n\n\t\t\t\tthis.ddsLoader = ddsLoader;\n\t\t\t\treturn this;\n\n\t\t\t},\n\n\t\t\tparse: function ( data, path, onLoad, onError ) {\n\n\t\t\t\tvar content;\n\t\t\t\tvar extensions = {};\n\n\t\t\t\tif ( typeof data === 'string' ) {\n\n\t\t\t\t\tcontent = data;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar magic = THREE.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );\n\n\t\t\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcontent = THREE.LoaderUtils.decodeText( new Uint8Array( data ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar json = JSON.parse( content );\n\n\t\t\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.extensionsUsed ) {\n\n\t\t\t\t\tfor ( var i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\t\t\tvar extensionName = json.extensionsUsed[ i ];\n\t\t\t\t\t\tvar extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\t\t\tcase EXTENSIONS.KHR_LIGHTS_PUNCTUAL:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFLightsExtension( json );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_CLEARCOAT:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsClearcoatExtension();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EXTENSIONS.MSFT_TEXTURE_DDS:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureDDSExtension( this.ddsLoader );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 ) {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar parser = new GLTFParser( json, extensions, {\n\n\t\t\t\t\tpath: path || this.resourcePath || '',\n\t\t\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\t\t\tmanager: this.manager\n\n\t\t\t\t} );\n\n\t\t\t\tparser.parse( onLoad, onError );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t/* GLTFREGISTRY */\n\n\t\tfunction GLTFRegistry() {\n\n\t\t\tvar objects = {};\n\n\t\t\treturn\t{\n\n\t\t\t\tget: function ( key ) {\n\n\t\t\t\t\treturn objects[ key ];\n\n\t\t\t\t},\n\n\t\t\t\tadd: function ( key, object ) {\n\n\t\t\t\t\tobjects[ key ] = object;\n\n\t\t\t\t},\n\n\t\t\t\tremove: function ( key ) {\n\n\t\t\t\t\tdelete objects[ key ];\n\n\t\t\t\t},\n\n\t\t\t\tremoveAll: function () {\n\n\t\t\t\t\tobjects = {};\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t/*********************************/\n\t\t/********** EXTENSIONS ***********/\n\t\t/*********************************/\n\n\t\tvar EXTENSIONS = {\n\t\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\t\t\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\t\t\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\t\t\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\t\t\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n\t\t\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\t\t\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\t\t\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\t\t\tMSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n\t\t};\n\n\t\t/**\n\t\t * DDS Texture Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\n\t\t *\n\t\t */\n\t\tfunction GLTFTextureDDSExtension( ddsLoader ) {\n\n\t\t\tif ( ! ddsLoader ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader' );\n\n\t\t\t}\n\n\t\t\tthis.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n\t\t\tthis.ddsLoader = ddsLoader;\n\n\t\t}\n\n\t\t/**\n\t\t * Punctual Lights Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\t\t */\n\t\tfunction GLTFLightsExtension( json ) {\n\n\t\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t\tvar extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ] ) || {};\n\t\t\tthis.lightDefs = extension.lights || [];\n\n\t\t}\n\n\t\tGLTFLightsExtension.prototype.loadLight = function ( lightIndex ) {\n\n\t\t\tvar lightDef = this.lightDefs[ lightIndex ];\n\t\t\tvar lightNode;\n\n\t\t\tvar color = new THREE.Color( 0xffffff );\n\t\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\n\n\t\t\tvar range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\t\tswitch ( lightDef.type ) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlightNode = new THREE.DirectionalLight( color );\n\t\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlightNode = new THREE.PointLight( color );\n\t\t\t\t\tlightNode.distance = range;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlightNode = new THREE.SpotLight( color );\n\t\t\t\t\tlightNode.distance = range;\n\t\t\t\t\t// Handle spotlight properties.\n\t\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".' );\n\n\t\t\t}\n\n\t\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\t\tlightNode.decay = 2;\n\n\t\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\t\tlightNode.name = lightDef.name || ( 'light_' + lightIndex );\n\n\t\t\treturn Promise.resolve( lightNode );\n\n\t\t};\n\n\t\t/**\n\t\t * Unlit Materials Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n\t\t */\n\t\tfunction GLTFMaterialsUnlitExtension() {\n\n\t\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t\t}\n\n\t\tGLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {\n\n\t\t\treturn THREE.MeshBasicMaterial;\n\n\t\t};\n\n\t\tGLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, materialDef, parser ) {\n\n\t\t\tvar pending = [];\n\n\t\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\t\tif ( metallicRoughness ) {\n\n\t\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pending );\n\n\t\t};\n\n\t\t/**\n\t\t * Clearcoat Materials Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n\t\t */\n\t\tfunction GLTFMaterialsClearcoatExtension() {\n\n\t\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t\t}\n\n\t\tGLTFMaterialsClearcoatExtension.prototype.getMaterialType = function () {\n\n\t\t\treturn THREE.MeshPhysicalMaterial;\n\n\t\t};\n\n\t\tGLTFMaterialsClearcoatExtension.prototype.extendParams = function ( materialParams, materialDef, parser ) {\n\n\t\t\tvar pending = [];\n\n\t\t\tvar extension = materialDef.extensions[ this.name ];\n\n\t\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t\t}\n\n\t\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t\t}\n\n\t\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t\t}\n\n\t\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\t\tvar scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\t\tmaterialParams.clearcoatNormalScale = new THREE.Vector2( scale, scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pending );\n\n\t\t};\n\n\t\t/* BINARY EXTENSION */\n\t\tvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n\t\tvar BINARY_EXTENSION_HEADER_LENGTH = 12;\n\t\tvar BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\n\t\tfunction GLTFBinaryExtension( data ) {\n\n\t\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\t\tthis.content = null;\n\t\t\tthis.body = null;\n\n\t\t\tvar headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\n\t\t\tthis.header = {\n\t\t\t\tmagic: THREE.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\t\tlength: headerView.getUint32( 8, true )\n\t\t\t};\n\n\t\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t\t}\n\n\t\t\tvar chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\t\tvar chunkIndex = 0;\n\n\t\t\twhile ( chunkIndex < chunkView.byteLength ) {\n\n\t\t\t\tvar chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\t\tchunkIndex += 4;\n\n\t\t\t\tvar chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\t\tchunkIndex += 4;\n\n\t\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\t\tvar contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\t\tthis.content = THREE.LoaderUtils.decodeText( contentArray );\n\n\t\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\t\tvar byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t\t}\n\n\t\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\t\tchunkIndex += chunkLength;\n\n\t\t\t}\n\n\t\t\tif ( this.content === null ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * DRACO Mesh Compression Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n\t\t */\n\t\tfunction GLTFDracoMeshCompressionExtension( json, dracoLoader ) {\n\n\t\t\tif ( ! dracoLoader ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t\t}\n\n\t\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\t\tthis.json = json;\n\t\t\tthis.dracoLoader = dracoLoader;\n\t\t\tthis.dracoLoader.preload();\n\n\t\t}\n\n\t\tGLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar dracoLoader = this.dracoLoader;\n\t\t\tvar bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\t\tvar gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\t\tvar threeAttributeMap = {};\n\t\t\tvar attributeNormalizedMap = {};\n\t\t\tvar attributeTypeMap = {};\n\n\t\t\tfor ( var attributeName in gltfAttributeMap ) {\n\n\t\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t\t}\n\n\t\t\tfor ( attributeName in primitive.attributes ) {\n\n\t\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\t\tvar accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\t\tvar componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType;\n\t\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\t\tfor ( var attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\t\tvar normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t\t}, threeAttributeMap, attributeTypeMap );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Texture Transform Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n\t\t */\n\t\tfunction GLTFTextureTransformExtension() {\n\n\t\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t\t}\n\n\t\tGLTFTextureTransformExtension.prototype.extendTexture = function ( texture, transform ) {\n\n\t\t\ttexture = texture.clone();\n\n\t\t\tif ( transform.offset !== undefined ) {\n\n\t\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t\t}\n\n\t\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\t\ttexture.rotation = transform.rotation;\n\n\t\t\t}\n\n\t\t\tif ( transform.scale !== undefined ) {\n\n\t\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t\t}\n\n\t\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.' );\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\treturn texture;\n\n\t\t};\n\n\t\t/**\n\t\t * Specular-Glossiness Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n\t\t */\n\n\t\t/**\n\t\t * A sub class of THREE.StandardMaterial with some of the functionality\n\t\t * changed via the `onBeforeCompile` callback\n\t\t * @pailhead\n\t\t */\n\n\t\tfunction GLTFMeshStandardSGMaterial( params ) {\n\n\t\t\tTHREE.MeshStandardMaterial.call( this );\n\n\t\t\tthis.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t\t//various chunks that need replacing\n\t\t\tvar specularMapParsFragmentChunk = [\n\t\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t\t'\tuniform sampler2D specularMap;',\n\t\t\t\t'#endif'\n\t\t\t].join( '\\n' );\n\n\t\t\tvar glossinessMapParsFragmentChunk = [\n\t\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t\t'\tuniform sampler2D glossinessMap;',\n\t\t\t\t'#endif'\n\t\t\t].join( '\\n' );\n\n\t\t\tvar specularMapFragmentChunk = [\n\t\t\t\t'vec3 specularFactor = specular;',\n\t\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t\t'\tvec4 texelSpecular = texture2D( specularMap, vUv );',\n\t\t\t\t'\ttexelSpecular = sRGBToLinear( texelSpecular );',\n\t\t\t\t'\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t\t'\tspecularFactor *= texelSpecular.rgb;',\n\t\t\t\t'#endif'\n\t\t\t].join( '\\n' );\n\n\t\t\tvar glossinessMapFragmentChunk = [\n\t\t\t\t'float glossinessFactor = glossiness;',\n\t\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t\t'\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\n\t\t\t\t'\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t\t'\tglossinessFactor *= texelGlossiness.a;',\n\t\t\t\t'#endif'\n\t\t\t].join( '\\n' );\n\n\t\t\tvar lightPhysicalFragmentChunk = [\n\t\t\t\t'PhysicalMaterial material;',\n\t\t\t\t'material.diffuseColor = diffuseColor.rgb;',\n\t\t\t\t'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',\n\t\t\t\t'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',\n\t\t\t\t'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.',\n\t\t\t\t'material.specularRoughness += geometryRoughness;',\n\t\t\t\t'material.specularRoughness = min( material.specularRoughness, 1.0 );',\n\t\t\t\t'material.specularColor = specularFactor.rgb;',\n\t\t\t].join( '\\n' );\n\n\t\t\tvar uniforms = {\n\t\t\t\tspecular: { value: new THREE.Color().setHex( 0xffffff ) },\n\t\t\t\tglossiness: { value: 1 },\n\t\t\t\tspecularMap: { value: null },\n\t\t\t\tglossinessMap: { value: null }\n\t\t\t};\n\n\t\t\tthis._extraUniforms = uniforms;\n\n\t\t\t// please see #14031 or #13198 for an alternate approach\n\t\t\tthis.onBeforeCompile = function ( shader ) {\n\n\t\t\t\tfor ( var uniformName in uniforms ) {\n\n\t\t\t\t\tshader.uniforms[ uniformName ] = uniforms[ uniformName ];\n\n\t\t\t\t}\n\n\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( 'uniform float roughness;', 'uniform vec3 specular;' );\n\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( 'uniform float metalness;', 'uniform float glossiness;' );\n\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk );\n\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk );\n\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk );\n\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk );\n\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );\n\n\t\t\t};\n\n\t\t\t/*eslint-disable*/\n\t\t\tObject.defineProperties(\n\t\t\t\tthis,\n\t\t\t\t{\n\t\t\t\t\tspecular: {\n\t\t\t\t\t\tget: function () { return uniforms.specular.value; },\n\t\t\t\t\t\tset: function ( v ) { uniforms.specular.value = v; }\n\t\t\t\t\t},\n\t\t\t\t\tspecularMap: {\n\t\t\t\t\t\tget: function () { return uniforms.specularMap.value; },\n\t\t\t\t\t\tset: function ( v ) { uniforms.specularMap.value = v; }\n\t\t\t\t\t},\n\t\t\t\t\tglossiness: {\n\t\t\t\t\t\tget: function () { return uniforms.glossiness.value; },\n\t\t\t\t\t\tset: function ( v ) { uniforms.glossiness.value = v; }\n\t\t\t\t\t},\n\t\t\t\t\tglossinessMap: {\n\t\t\t\t\t\tget: function () { return uniforms.glossinessMap.value; },\n\t\t\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\t\t\tuniforms.glossinessMap.value = v;\n\t\t\t\t\t\t\t//how about something like this - @pailhead\n\t\t\t\t\t\t\tif ( v ) {\n\n\t\t\t\t\t\t\t\tthis.defines.USE_GLOSSINESSMAP = '';\n\t\t\t\t\t\t\t\t// set USE_ROUGHNESSMAP to enable vUv\n\t\t\t\t\t\t\t\tthis.defines.USE_ROUGHNESSMAP = '';\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tdelete this.defines.USE_ROUGHNESSMAP;\n\t\t\t\t\t\t\t\tdelete this.defines.USE_GLOSSINESSMAP;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t/*eslint-enable*/\n\t\t\tdelete this.metalness;\n\t\t\tdelete this.roughness;\n\t\t\tdelete this.metalnessMap;\n\t\t\tdelete this.roughnessMap;\n\n\t\t\tthis.setValues( params );\n\n\t\t}\n\n\t\tGLTFMeshStandardSGMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );\n\t\tGLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;\n\n\t\tGLTFMeshStandardSGMaterial.prototype.copy = function ( source ) {\n\n\t\t\tTHREE.MeshStandardMaterial.prototype.copy.call( this, source );\n\t\t\tthis.specularMap = source.specularMap;\n\t\t\tthis.specular.copy( source.specular );\n\t\t\tthis.glossinessMap = source.glossinessMap;\n\t\t\tthis.glossiness = source.glossiness;\n\t\t\tdelete this.metalness;\n\t\t\tdelete this.roughness;\n\t\t\tdelete this.metalnessMap;\n\t\t\tdelete this.roughnessMap;\n\t\t\treturn this;\n\n\t\t};\n\n\t\tfunction GLTFMaterialsPbrSpecularGlossinessExtension() {\n\n\t\t\treturn {\n\n\t\t\t\tname: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n\n\t\t\t\tspecularGlossinessParams: [\n\t\t\t\t\t'color',\n\t\t\t\t\t'map',\n\t\t\t\t\t'lightMap',\n\t\t\t\t\t'lightMapIntensity',\n\t\t\t\t\t'aoMap',\n\t\t\t\t\t'aoMapIntensity',\n\t\t\t\t\t'emissive',\n\t\t\t\t\t'emissiveIntensity',\n\t\t\t\t\t'emissiveMap',\n\t\t\t\t\t'bumpMap',\n\t\t\t\t\t'bumpScale',\n\t\t\t\t\t'normalMap',\n\t\t\t\t\t'normalMapType',\n\t\t\t\t\t'displacementMap',\n\t\t\t\t\t'displacementScale',\n\t\t\t\t\t'displacementBias',\n\t\t\t\t\t'specularMap',\n\t\t\t\t\t'specular',\n\t\t\t\t\t'glossinessMap',\n\t\t\t\t\t'glossiness',\n\t\t\t\t\t'alphaMap',\n\t\t\t\t\t'envMap',\n\t\t\t\t\t'envMapIntensity',\n\t\t\t\t\t'refractionRatio',\n\t\t\t\t],\n\n\t\t\t\tgetMaterialType: function () {\n\n\t\t\t\t\treturn GLTFMeshStandardSGMaterial;\n\n\t\t\t\t},\n\n\t\t\t\textendParams: function ( materialParams, materialDef, parser ) {\n\n\t\t\t\t\tvar pbrSpecularGlossiness = materialDef.extensions[ this.name ];\n\n\t\t\t\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\n\t\t\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\t\t\tvar pending = [];\n\n\t\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {\n\n\t\t\t\t\t\tvar array = pbrSpecularGlossiness.diffuseFactor;\n\n\t\t\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {\n\n\t\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterialParams.emissive = new THREE.Color( 0.0, 0.0, 0.0 );\n\t\t\t\t\tmaterialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n\t\t\t\t\tmaterialParams.specular = new THREE.Color( 1.0, 1.0, 1.0 );\n\n\t\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {\n\n\t\t\t\t\t\tmaterialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {\n\n\t\t\t\t\t\tvar specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n\t\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );\n\t\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Promise.all( pending );\n\n\t\t\t\t},\n\n\t\t\t\tcreateMaterial: function ( materialParams ) {\n\n\t\t\t\t\tvar material = new GLTFMeshStandardSGMaterial( materialParams );\n\t\t\t\t\tmaterial.fog = true;\n\n\t\t\t\t\tmaterial.color = materialParams.color;\n\n\t\t\t\t\tmaterial.map = materialParams.map === undefined ? null : materialParams.map;\n\n\t\t\t\t\tmaterial.lightMap = null;\n\t\t\t\t\tmaterial.lightMapIntensity = 1.0;\n\n\t\t\t\t\tmaterial.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\n\t\t\t\t\tmaterial.aoMapIntensity = 1.0;\n\n\t\t\t\t\tmaterial.emissive = materialParams.emissive;\n\t\t\t\t\tmaterial.emissiveIntensity = 1.0;\n\t\t\t\t\tmaterial.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\n\n\t\t\t\t\tmaterial.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n\t\t\t\t\tmaterial.bumpScale = 1;\n\n\t\t\t\t\tmaterial.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\n\t\t\t\t\tmaterial.normalMapType = THREE.TangentSpaceNormalMap;\n\n\t\t\t\t\tif ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;\n\n\t\t\t\t\tmaterial.displacementMap = null;\n\t\t\t\t\tmaterial.displacementScale = 1;\n\t\t\t\t\tmaterial.displacementBias = 0;\n\n\t\t\t\t\tmaterial.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\n\t\t\t\t\tmaterial.specular = materialParams.specular;\n\n\t\t\t\t\tmaterial.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\n\t\t\t\t\tmaterial.glossiness = materialParams.glossiness;\n\n\t\t\t\t\tmaterial.alphaMap = null;\n\n\t\t\t\t\tmaterial.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\n\t\t\t\t\tmaterial.envMapIntensity = 1.0;\n\n\t\t\t\t\tmaterial.refractionRatio = 0.98;\n\n\t\t\t\t\treturn material;\n\n\t\t\t\t},\n\n\t\t\t};\n\n\t\t}\n\n\t\t/**\n\t\t * Mesh Quantization Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n\t\t */\n\t\tfunction GLTFMeshQuantizationExtension() {\n\n\t\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t\t}\n\n\t\t/*********************************/\n\t\t/********** INTERPOLATION ********/\n\t\t/*********************************/\n\n\t\t// Spline Interpolation\n\t\t// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\t\tfunction GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\t\tTHREE.Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\t}\n\n\t\tGLTFCubicSplineInterpolant.prototype = Object.create( THREE.Interpolant.prototype );\n\t\tGLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n\t\tGLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) {\n\n\t\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tvalueSize = this.valueSize,\n\t\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\t\tfor ( var i = 0; i !== valueSize; i ++ ) {\n\n\t\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t};\n\n\t\tGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n\t\tGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n\t\tGLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer;\n\t\t\tvar values = this.sampleValues;\n\t\t\tvar stride = this.valueSize;\n\n\t\t\tvar stride2 = stride * 2;\n\t\t\tvar stride3 = stride * 3;\n\n\t\t\tvar td = t1 - t0;\n\n\t\t\tvar p = ( t - t0 ) / td;\n\t\t\tvar pp = p * p;\n\t\t\tvar ppp = pp * p;\n\n\t\t\tvar offset1 = i1 * stride3;\n\t\t\tvar offset0 = offset1 - stride3;\n\n\t\t\tvar s2 = - 2 * ppp + 3 * pp;\n\t\t\tvar s3 = ppp - pp;\n\t\t\tvar s0 = 1 - s2;\n\t\t\tvar s1 = s3 - pp + p;\n\n\t\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\t\tfor ( var i = 0; i !== stride; i ++ ) {\n\n\t\t\t\tvar p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\t\tvar m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\t\tvar p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\t\tvar m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t};\n\n\t\t/*********************************/\n\t\t/********** INTERNALS ************/\n\t\t/*********************************/\n\n\t\t/* CONSTANTS */\n\n\t\tvar WEBGL_CONSTANTS = {\n\t\t\tFLOAT: 5126,\n\t\t\t//FLOAT_MAT2: 35674,\n\t\t\tFLOAT_MAT3: 35675,\n\t\t\tFLOAT_MAT4: 35676,\n\t\t\tFLOAT_VEC2: 35664,\n\t\t\tFLOAT_VEC3: 35665,\n\t\t\tFLOAT_VEC4: 35666,\n\t\t\tLINEAR: 9729,\n\t\t\tREPEAT: 10497,\n\t\t\tSAMPLER_2D: 35678,\n\t\t\tPOINTS: 0,\n\t\t\tLINES: 1,\n\t\t\tLINE_LOOP: 2,\n\t\t\tLINE_STRIP: 3,\n\t\t\tTRIANGLES: 4,\n\t\t\tTRIANGLE_STRIP: 5,\n\t\t\tTRIANGLE_FAN: 6,\n\t\t\tUNSIGNED_BYTE: 5121,\n\t\t\tUNSIGNED_SHORT: 5123\n\t\t};\n\n\t\tvar WEBGL_COMPONENT_TYPES = {\n\t\t\t5120: Int8Array,\n\t\t\t5121: Uint8Array,\n\t\t\t5122: Int16Array,\n\t\t\t5123: Uint16Array,\n\t\t\t5125: Uint32Array,\n\t\t\t5126: Float32Array\n\t\t};\n\n\t\tvar WEBGL_FILTERS = {\n\t\t\t9728: THREE.NearestFilter,\n\t\t\t9729: THREE.LinearFilter,\n\t\t\t9984: THREE.NearestMipmapNearestFilter,\n\t\t\t9985: THREE.LinearMipmapNearestFilter,\n\t\t\t9986: THREE.NearestMipmapLinearFilter,\n\t\t\t9987: THREE.LinearMipmapLinearFilter\n\t\t};\n\n\t\tvar WEBGL_WRAPPINGS = {\n\t\t\t33071: THREE.ClampToEdgeWrapping,\n\t\t\t33648: THREE.MirroredRepeatWrapping,\n\t\t\t10497: THREE.RepeatWrapping\n\t\t};\n\n\t\tvar WEBGL_TYPE_SIZES = {\n\t\t\t'SCALAR': 1,\n\t\t\t'VEC2': 2,\n\t\t\t'VEC3': 3,\n\t\t\t'VEC4': 4,\n\t\t\t'MAT2': 4,\n\t\t\t'MAT3': 9,\n\t\t\t'MAT4': 16\n\t\t};\n\n\t\tvar ATTRIBUTES = {\n\t\t\tPOSITION: 'position',\n\t\t\tNORMAL: 'normal',\n\t\t\tTANGENT: 'tangent',\n\t\t\tTEXCOORD_0: 'uv',\n\t\t\tTEXCOORD_1: 'uv2',\n\t\t\tCOLOR_0: 'color',\n\t\t\tWEIGHTS_0: 'skinWeight',\n\t\t\tJOINTS_0: 'skinIndex',\n\t\t};\n\n\t\tvar PATH_PROPERTIES = {\n\t\t\tscale: 'scale',\n\t\t\ttranslation: 'position',\n\t\t\trotation: 'quaternion',\n\t\t\tweights: 'morphTargetInfluences'\n\t\t};\n\n\t\tvar INTERPOLATION = {\n\t\t\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\t\t\tLINEAR: THREE.InterpolateLinear,\n\t\t\tSTEP: THREE.InterpolateDiscrete\n\t\t};\n\n\t\tvar ALPHA_MODES = {\n\t\t\tOPAQUE: 'OPAQUE',\n\t\t\tMASK: 'MASK',\n\t\t\tBLEND: 'BLEND'\n\t\t};\n\n\t\tvar MIME_TYPE_FORMATS = {\n\t\t\t'image/png': THREE.RGBAFormat,\n\t\t\t'image/jpeg': THREE.RGBFormat\n\t\t};\n\n\t\t/* UTILITY FUNCTIONS */\n\n\t\tfunction resolveURL( url, path ) {\n\n\t\t\t// Invalid URL\n\t\t\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t\t\t// Host Relative URL\n\t\t\tif ( /^https?:\\/\\//i.test( path ) && /^\\//.test( url ) ) {\n\n\t\t\t\tpath = path.replace( /(^https?:\\/\\/[^\\/]+).*/i, '$1' );\n\n\t\t\t}\n\n\t\t\t// Absolute URL http://,https://,//\n\t\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t\t\t// Data URI\n\t\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t\t\t// Blob URL\n\t\t\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t\t\t// Relative URL\n\t\t\treturn path + url;\n\n\t\t}\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n\t\t */\n\t\tfunction createDefaultMaterial( cache ) {\n\n\t\t\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\t\t\tcache[ 'DefaultMaterial' ] = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tcolor: 0xFFFFFF,\n\t\t\t\t\temissive: 0x000000,\n\t\t\t\t\tmetalness: 1,\n\t\t\t\t\troughness: 1,\n\t\t\t\t\ttransparent: false,\n\t\t\t\t\tdepthTest: true,\n\t\t\t\t\tside: THREE.FrontSide\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn cache[ 'DefaultMaterial' ];\n\n\t\t}\n\n\t\tfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t\t\t// Add unknown glTF extensions to an object's userData.\n\n\t\t\tfor ( var name in objectDef.extensions ) {\n\n\t\t\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry} object\n\t\t * @param {GLTF.definition} gltfDef\n\t\t */\n\t\tfunction assignExtrasToUserData( object, gltfDef ) {\n\n\t\t\tif ( gltfDef.extras !== undefined ) {\n\n\t\t\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n\t\t *\n\t\t * @param {THREE.BufferGeometry} geometry\n\t\t * @param {Array<GLTF.Target>} targets\n\t\t * @param {GLTFParser} parser\n\t\t * @return {Promise<THREE.BufferGeometry>}\n\t\t */\n\t\tfunction addMorphTargets( geometry, targets, parser ) {\n\n\t\t\tvar hasMorphPosition = false;\n\t\t\tvar hasMorphNormal = false;\n\n\t\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\t\tvar target = targets[ i ];\n\n\t\t\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\t\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\n\t\t\t\tif ( hasMorphPosition && hasMorphNormal ) break;\n\n\t\t\t}\n\n\t\t\tif ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );\n\n\t\t\tvar pendingPositionAccessors = [];\n\t\t\tvar pendingNormalAccessors = [];\n\n\t\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\t\tvar target = targets[ i ];\n\n\t\t\t\tif ( hasMorphPosition ) {\n\n\t\t\t\t\tvar pendingAccessor = target.POSITION !== undefined\n\t\t\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t\t\t: geometry.attributes.position;\n\n\t\t\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphNormal ) {\n\n\t\t\t\t\tvar pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t\t\t: geometry.attributes.normal;\n\n\t\t\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Promise.all( [\n\t\t\t\tPromise.all( pendingPositionAccessors ),\n\t\t\t\tPromise.all( pendingNormalAccessors )\n\t\t\t] ).then( function ( accessors ) {\n\n\t\t\t\tvar morphPositions = accessors[ 0 ];\n\t\t\t\tvar morphNormals = accessors[ 1 ];\n\n\t\t\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\t\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\t\t\tgeometry.morphTargetsRelative = true;\n\n\t\t\t\treturn geometry;\n\n\t\t\t} );\n\n\t\t}\n\n\t\t/**\n\t\t * @param {THREE.Mesh} mesh\n\t\t * @param {GLTF.Mesh} meshDef\n\t\t */\n\t\tfunction updateMorphTargets( mesh, meshDef ) {\n\n\t\t\tmesh.updateMorphTargets();\n\n\t\t\tif ( meshDef.weights !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\t\t\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\t\t\tvar targetNames = meshDef.extras.targetNames;\n\n\t\t\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( var i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createPrimitiveKey( primitiveDef ) {\n\n\t\t\tvar dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\t\t\tvar geometryKey;\n\n\t\t\tif ( dracoExtension ) {\n\n\t\t\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t\t\t} else {\n\n\t\t\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t\t\t}\n\n\t\t\treturn geometryKey;\n\n\t\t}\n\n\t\tfunction createAttributesKey( attributes ) {\n\n\t\t\tvar attributesKey = '';\n\n\t\t\tvar keys = Object.keys( attributes ).sort();\n\n\t\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t\t\t}\n\n\t\t\treturn attributesKey;\n\n\t\t}\n\n\t\t/* GLTF PARSER */\n\n\t\tfunction GLTFParser( json, extensions, options ) {\n\n\t\t\tthis.json = json || {};\n\t\t\tthis.extensions = extensions || {};\n\t\t\tthis.options = options || {};\n\n\t\t\t// loader object cache\n\t\t\tthis.cache = new GLTFRegistry();\n\n\t\t\t// BufferGeometry caching\n\t\t\tthis.primitiveCache = {};\n\n\t\t\tthis.textureLoader = new THREE.TextureLoader( this.options.manager );\n\t\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\n\t\t\tthis.fileLoader = new THREE.FileLoader( this.options.manager );\n\t\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tGLTFParser.prototype.parse = function ( onLoad, onError ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar json = this.json;\n\t\t\tvar extensions = this.extensions;\n\n\t\t\t// Clear the loader cache\n\t\t\tthis.cache.removeAll();\n\n\t\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\t\tthis.markDefs();\n\n\t\t\tPromise.all( [\n\n\t\t\t\tthis.getDependencies( 'scene' ),\n\t\t\t\tthis.getDependencies( 'animation' ),\n\t\t\t\tthis.getDependencies( 'camera' ),\n\n\t\t\t] ).then( function ( dependencies ) {\n\n\t\t\t\tvar result = {\n\t\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\t\tasset: json.asset,\n\t\t\t\t\tparser: parser,\n\t\t\t\t\tuserData: {}\n\t\t\t\t};\n\n\t\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} ).catch( onError );\n\n\t\t};\n\n\t\t/**\n\t\t * Marks the special nodes/meshes in json for efficient parse.\n\t\t */\n\t\tGLTFParser.prototype.markDefs = function () {\n\n\t\t\tvar nodeDefs = this.json.nodes || [];\n\t\t\tvar skinDefs = this.json.skins || [];\n\t\t\tvar meshDefs = this.json.meshes || [];\n\n\t\t\tvar meshReferences = {};\n\t\t\tvar meshUses = {};\n\n\t\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\t\tfor ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\t\tvar joints = skinDefs[ skinIndex ].joints;\n\n\t\t\t\tfor ( var i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n\t\t\t// avoid having more than one THREE.Mesh with the same name, count\n\t\t\t// references and rename instances below.\n\t\t\t//\n\t\t\t// Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\t\tif ( meshReferences[ nodeDef.mesh ] === undefined ) {\n\n\t\t\t\t\t\tmeshReferences[ nodeDef.mesh ] = meshUses[ nodeDef.mesh ] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmeshReferences[ nodeDef.mesh ] ++;\n\n\t\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.json.meshReferences = meshReferences;\n\t\t\tthis.json.meshUses = meshUses;\n\n\t\t};\n\n\t\t/**\n\t\t * Requests the specified dependency asynchronously, with caching.\n\t\t * @param {string} type\n\t\t * @param {number} index\n\t\t * @return {Promise<THREE.Object3D|THREE.Material|THREE.Texture|THREE.AnimationClip|ArrayBuffer|Object>}\n\t\t */\n\t\tGLTFParser.prototype.getDependency = function ( type, index ) {\n\n\t\t\tvar cacheKey = type + ':' + index;\n\t\t\tvar dependency = this.cache.get( cacheKey );\n\n\t\t\tif ( ! dependency ) {\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'scene':\n\t\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'node':\n\t\t\t\t\t\tdependency = this.loadNode( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'mesh':\n\t\t\t\t\t\tdependency = this.loadMesh( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'accessor':\n\t\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bufferView':\n\t\t\t\t\t\tdependency = this.loadBufferView( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'buffer':\n\t\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'material':\n\t\t\t\t\t\tdependency = this.loadMaterial( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdependency = this.loadTexture( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'animation':\n\t\t\t\t\t\tdependency = this.loadAnimation( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'camera':\n\t\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'light':\n\t\t\t\t\t\tdependency = this.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].loadLight( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t\t}\n\n\t\t\treturn dependency;\n\n\t\t};\n\n\t\t/**\n\t\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t\t * @param {string} type\n\t\t * @return {Promise<Array<Object>>}\n\t\t */\n\t\tGLTFParser.prototype.getDependencies = function ( type ) {\n\n\t\t\tvar dependencies = this.cache.get( type );\n\n\t\t\tif ( ! dependencies ) {\n\n\t\t\t\tvar parser = this;\n\t\t\t\tvar defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t\t} ) );\n\n\t\t\t\tthis.cache.add( type, dependencies );\n\n\t\t\t}\n\n\t\t\treturn dependencies;\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t\t * @param {number} bufferIndex\n\t\t * @return {Promise<ArrayBuffer>}\n\t\t */\n\t\tGLTFParser.prototype.loadBuffer = function ( bufferIndex ) {\n\n\t\t\tvar bufferDef = this.json.buffers[ bufferIndex ];\n\t\t\tvar loader = this.fileLoader;\n\n\t\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t\t}\n\n\t\t\t// If present, GLB container is required to be the first buffer.\n\t\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t\t}\n\n\t\t\tvar options = this.options;\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tloader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t\t * @param {number} bufferViewIndex\n\t\t * @return {Promise<ArrayBuffer>}\n\t\t */\n\t\tGLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {\n\n\t\t\tvar bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\t\tvar byteLength = bufferViewDef.byteLength || 0;\n\t\t\t\tvar byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t\t * @param {number} accessorIndex\n\t\t * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}\n\t\t */\n\t\tGLTFParser.prototype.loadAccessor = function ( accessorIndex ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar json = this.json;\n\n\t\t\tvar accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\t\t// Ignore empty accessors, which may be used to declare runtime\n\t\t\t\t// information about attributes coming from another source (e.g. Draco\n\t\t\t\t// compression extension).\n\t\t\t\treturn Promise.resolve( null );\n\n\t\t\t}\n\n\t\t\tvar pendingBufferViews = [];\n\n\t\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t\t} else {\n\n\t\t\t\tpendingBufferViews.push( null );\n\n\t\t\t}\n\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\t\tvar bufferView = bufferViews[ 0 ];\n\n\t\t\t\tvar itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\t\tvar TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\t\tvar elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\t\tvar itemBytes = elementBytes * itemSize;\n\t\t\t\tvar byteOffset = accessorDef.byteOffset || 0;\n\t\t\t\tvar byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\t\tvar normalized = accessorDef.normalized === true;\n\t\t\t\tvar array, bufferAttribute;\n\n\t\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\t\tvar ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\t\tvar ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\t\tvar ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\t\tib = new THREE.InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbufferAttribute = new THREE.InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbufferAttribute = new THREE.BufferAttribute( array, itemSize, normalized );\n\n\t\t\t\t}\n\n\t\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\t\tvar itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\t\tvar TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\t\tvar byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\t\tvar byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\t\tvar sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\t\tvar sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\t\tbufferAttribute = new THREE.BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar index = sparseIndices[ i ];\n\n\t\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn bufferAttribute;\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t\t * @param {number} textureIndex\n\t\t * @return {Promise<THREE.Texture>}\n\t\t */\n\t\tGLTFParser.prototype.loadTexture = function ( textureIndex ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar json = this.json;\n\t\t\tvar options = this.options;\n\t\t\tvar textureLoader = this.textureLoader;\n\n\t\t\tvar URL = self.URL || self.webkitURL;\n\n\t\t\tvar textureDef = json.textures[ textureIndex ];\n\n\t\t\tvar textureExtensions = textureDef.extensions || {};\n\n\t\t\tvar source;\n\n\t\t\tif ( textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] ) {\n\n\t\t\t\tsource = json.images[ textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].source ];\n\n\t\t\t} else {\n\n\t\t\t\tsource = json.images[ textureDef.source ];\n\n\t\t\t}\n\n\t\t\tvar sourceURI = source.uri;\n\t\t\tvar isObjectURL = false;\n\n\t\t\tif ( source.bufferView !== undefined ) {\n\n\t\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\t\tsourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\t\tisObjectURL = true;\n\t\t\t\t\tvar blob = new Blob( [ bufferView ], { type: source.mimeType } );\n\t\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\t\treturn sourceURI;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\t\t// Load Texture resource.\n\n\t\t\t\tvar loader = options.manager.getHandler( sourceURI );\n\n\t\t\t\tif ( ! loader ) {\n\n\t\t\t\t\tloader = textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ]\n\t\t\t\t\t\t? parser.extensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].ddsLoader\n\t\t\t\t\t\t: textureLoader;\n\n\t\t\t\t}\n\n\t\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\t\tloader.load( resolveURL( sourceURI, options.path ), resolve, undefined, reject );\n\n\t\t\t\t} );\n\n\t\t\t} ).then( function ( texture ) {\n\n\t\t\t\t// Clean up resources and configure Texture.\n\n\t\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.flipY = false;\n\n\t\t\t\tif ( textureDef.name ) texture.name = textureDef.name;\n\n\t\t\t\t// Ignore unknown mime types, like DDS files.\n\t\t\t\tif ( source.mimeType in MIME_TYPE_FORMATS ) {\n\n\t\t\t\t\ttexture.format = MIME_TYPE_FORMATS[ source.mimeType ];\n\n\t\t\t\t}\n\n\t\t\t\tvar samplers = json.samplers || {};\n\t\t\t\tvar sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || THREE.LinearFilter;\n\t\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || THREE.LinearMipmapLinearFilter;\n\t\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || THREE.RepeatWrapping;\n\t\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || THREE.RepeatWrapping;\n\n\t\t\t\treturn texture;\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Asynchronously assigns a texture to the given material parameters.\n\t\t * @param {Object} materialParams\n\t\t * @param {string} mapName\n\t\t * @param {Object} mapDef\n\t\t * @return {Promise}\n\t\t */\n\t\tGLTFParser.prototype.assignTexture = function ( materialParams, mapName, mapDef ) {\n\n\t\t\tvar parser = this;\n\n\t\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\t\tif ( ! texture.isCompressedTexture ) {\n\n\t\t\t\t\tswitch ( mapName ) {\n\n\t\t\t\t\t\tcase 'aoMap':\n\t\t\t\t\t\tcase 'emissiveMap':\n\t\t\t\t\t\tcase 'metalnessMap':\n\t\t\t\t\t\tcase 'normalMap':\n\t\t\t\t\t\tcase 'roughnessMap':\n\t\t\t\t\t\t\ttexture.format = THREE.RGBFormat;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n\t\t\t\t// However, we will copy UV set 0 to UV set 1 on demand for aoMap\n\t\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\t\tvar transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\t\tif ( transform ) {\n\n\t\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t\t * already has a material (generated from the glTF material options alone)\n\t\t * but reuse of the same glTF material may require multiple threejs materials\n\t\t * to accomodate different primitive types, defines, etc. New materials will\n\t\t * be created if necessary, and reused from a cache.\n\t\t * @param  {THREE.Object3D} mesh Mesh, Line, or Points instance.\n\t\t */\n\t\tGLTFParser.prototype.assignFinalMaterial = function ( mesh ) {\n\n\t\t\tvar geometry = mesh.geometry;\n\t\t\tvar material = mesh.material;\n\n\t\t\tvar useVertexTangents = geometry.attributes.tangent !== undefined;\n\t\t\tvar useVertexColors = geometry.attributes.color !== undefined;\n\t\t\tvar useFlatShading = geometry.attributes.normal === undefined;\n\t\t\tvar useSkinning = mesh.isSkinnedMesh === true;\n\t\t\tvar useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;\n\t\t\tvar useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n\t\t\tif ( mesh.isPoints ) {\n\n\t\t\t\tvar cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\t\tvar pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\t\tpointsMaterial = new THREE.PointsMaterial();\n\t\t\t\t\tTHREE.Material.prototype.copy.call( pointsMaterial, material );\n\t\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t\t}\n\n\t\t\t\tmaterial = pointsMaterial;\n\n\t\t\t} else if ( mesh.isLine ) {\n\n\t\t\t\tvar cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\t\tvar lineMaterial = this.cache.get( cacheKey );\n\n\t\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\t\tlineMaterial = new THREE.LineBasicMaterial();\n\t\t\t\t\tTHREE.Material.prototype.copy.call( lineMaterial, material );\n\t\t\t\t\tlineMaterial.color.copy( material.color );\n\n\t\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t\t}\n\n\t\t\t\tmaterial = lineMaterial;\n\n\t\t\t}\n\n\t\t\t// Clone the material if it will be modified\n\t\t\tif ( useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {\n\n\t\t\t\tvar cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';\n\t\t\t\tif ( useSkinning ) cacheKey += 'skinning:';\n\t\t\t\tif ( useVertexTangents ) cacheKey += 'vertex-tangents:';\n\t\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\t\t\t\tif ( useMorphTargets ) cacheKey += 'morph-targets:';\n\t\t\t\tif ( useMorphNormals ) cacheKey += 'morph-normals:';\n\n\t\t\t\tvar cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\t\tif ( useSkinning ) cachedMaterial.skinning = true;\n\t\t\t\t\tif ( useVertexTangents ) cachedMaterial.vertexTangents = true;\n\t\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\t\t\t\t\tif ( useMorphTargets ) cachedMaterial.morphTargets = true;\n\t\t\t\t\tif ( useMorphNormals ) cachedMaterial.morphNormals = true;\n\n\t\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\t}\n\n\t\t\t\tmaterial = cachedMaterial;\n\n\t\t\t}\n\n\t\t\t// workarounds for mesh and geometry\n\n\t\t\tif ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {\n\n\t\t\t\tgeometry.setAttribute( 'uv2', new THREE.BufferAttribute( geometry.attributes.uv.array, 2 ) );\n\n\t\t\t}\n\n\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\tif ( material.normalScale && ! useVertexTangents ) {\n\n\t\t\t\tmaterial.normalScale.y = - material.normalScale.y;\n\n\t\t\t}\n\n\t\t\tif ( material.clearcoatNormalScale && ! useVertexTangents ) {\n\n\t\t\t\tmaterial.clearcoatNormalScale.y = - material.clearcoatNormalScale.y;\n\n\t\t\t}\n\n\t\t\tmesh.material = material;\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t\t * @param {number} materialIndex\n\t\t * @return {Promise<THREE.Material>}\n\t\t */\n\t\tGLTFParser.prototype.loadMaterial = function ( materialIndex ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar json = this.json;\n\t\t\tvar extensions = this.extensions;\n\t\t\tvar materialDef = json.materials[ materialIndex ];\n\n\t\t\tvar materialType;\n\t\t\tvar materialParams = {};\n\t\t\tvar materialExtensions = materialDef.extensions || {};\n\n\t\t\tvar pending = [];\n\n\t\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {\n\n\t\t\t\tvar sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\n\t\t\t\tmaterialType = sgExtension.getMaterialType();\n\t\t\t\tpending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t\t} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\t\tvar kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t\t} else {\n\n\t\t\t\t// Specification:\n\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\t\tmaterialType = THREE.MeshStandardMaterial;\n\n\t\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\n\t\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t\t}\n\n\t\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\t\tmaterialParams.side = THREE.DoubleSide;\n\n\t\t\t}\n\n\t\t\tvar alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\t\tmaterialParams.transparent = true;\n\n\t\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\t\tmaterialParams.depthWrite = false;\n\n\t\t\t} else {\n\n\t\t\t\tmaterialParams.transparent = false;\n\n\t\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\t\tmaterialParams.normalScale = new THREE.Vector2( 1, 1 );\n\n\t\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\t\tmaterialParams.normalScale.set( materialDef.normalTexture.scale, materialDef.normalTexture.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial ) {\n\n\t\t\t\tmaterialParams.emissive = new THREE.Color().fromArray( materialDef.emissiveFactor );\n\n\t\t\t}\n\n\t\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );\n\n\t\t\t}\n\n\t\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_CLEARCOAT ] ) {\n\n\t\t\t\tvar clearcoatExtension = extensions[ EXTENSIONS.KHR_MATERIALS_CLEARCOAT ];\n\t\t\t\tmaterialType = clearcoatExtension.getMaterialType();\n\t\t\t\tpending.push( clearcoatExtension.extendParams( materialParams, { extensions: materialExtensions }, parser ) );\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\t\tvar material;\n\n\t\t\t\tif ( materialType === GLTFMeshStandardSGMaterial ) {\n\n\t\t\t\t\tmaterial = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = new materialType( materialParams );\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\t\t// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\t\t\t\tif ( material.map ) material.map.encoding = THREE.sRGBEncoding;\n\t\t\t\tif ( material.emissiveMap ) material.emissiveMap.encoding = THREE.sRGBEncoding;\n\n\t\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\t\treturn material;\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * @param {THREE.BufferGeometry} geometry\n\t\t * @param {GLTF.Primitive} primitiveDef\n\t\t * @param {GLTFParser} parser\n\t\t */\n\t\tfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\t\t\tvar attributes = primitiveDef.attributes;\n\n\t\t\tvar box = new THREE.Box3();\n\n\t\t\tif ( attributes.POSITION !== undefined ) {\n\n\t\t\t\tvar accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\t\t\tvar min = accessor.min;\n\t\t\t\tvar max = accessor.max;\n\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\tbox.set(\n\t\t\t\t\t\tnew THREE.Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\t\t\tnew THREE.Vector3( max[ 0 ], max[ 1 ], max[ 2 ] ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar targets = primitiveDef.targets;\n\n\t\t\tif ( targets !== undefined ) {\n\n\t\t\t\tvar maxDisplacement = new THREE.Vector3();\n\t\t\t\tvar vector = new THREE.Vector3();\n\n\t\t\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar target = targets[ i ];\n\n\t\t\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\t\t\tvar accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\t\t\tvar min = accessor.min;\n\t\t\t\t\t\tvar max = accessor.max;\n\n\t\t\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\t\t\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\t\t\tbox.expandByVector( maxDisplacement );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingBox = box;\n\n\t\t\tvar sphere = new THREE.Sphere();\n\n\t\t\tbox.getCenter( sphere.center );\n\t\t\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\t\t\tgeometry.boundingSphere = sphere;\n\n\t\t}\n\n\t\t/**\n\t\t * @param {THREE.BufferGeometry} geometry\n\t\t * @param {GLTF.Primitive} primitiveDef\n\t\t * @param {GLTFParser} parser\n\t\t * @return {Promise<THREE.BufferGeometry>}\n\t\t */\n\t\tfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\t\t\tvar attributes = primitiveDef.attributes;\n\n\t\t\tvar pending = [];\n\n\t\t\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\t\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t\t\t.then( function ( accessor ) {\n\n\t\t\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfor ( var gltfAttributeName in attributes ) {\n\n\t\t\t\tvar threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\t\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\t\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t\t\t}\n\n\t\t\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\t\t\tvar accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\t\t\tgeometry.setIndex( accessor );\n\n\t\t\t\t} );\n\n\t\t\t\tpending.push( accessor );\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( geometry, primitiveDef );\n\n\t\t\tcomputeBounds( geometry, primitiveDef, parser );\n\n\t\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\t\treturn primitiveDef.targets !== undefined\n\t\t\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t\t\t: geometry;\n\n\t\t\t} );\n\n\t\t}\n\n\t\t/**\n\t\t * @param {THREE.BufferGeometry} geometry\n\t\t * @param {Number} drawMode\n\t\t * @return {THREE.BufferGeometry}\n\t\t */\n\t\tfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\t\t\tvar index = geometry.getIndex();\n\n\t\t\t// generate index if not present\n\n\t\t\tif ( index === null ) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\t\tif ( position !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\t\tindices.push( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar numberOfTriangles = index.count - 2;\n\t\t\tvar newIndices = [];\n\n\t\t\tif ( drawMode === THREE.TriangleFanDrawMode ) {\n\n\t\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\t\tfor ( var i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\t\tfor ( var i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t\t}\n\n\t\t\t// build final geometry\n\n\t\t\tvar newGeometry = geometry.clone();\n\t\t\tnewGeometry.setIndex( newIndices );\n\n\t\t\treturn newGeometry;\n\n\t\t}\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t\t *\n\t\t * Creates BufferGeometries from primitives.\n\t\t *\n\t\t * @param {Array<GLTF.Primitive>} primitives\n\t\t * @return {Promise<Array<THREE.BufferGeometry>>}\n\t\t */\n\t\tGLTFParser.prototype.loadGeometries = function ( primitives ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar extensions = this.extensions;\n\t\t\tvar cache = this.primitiveCache;\n\n\t\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tvar pending = [];\n\n\t\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\t\tvar primitive = primitives[ i ];\n\t\t\t\tvar cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t\t// See if we've already created this geometry\n\t\t\t\tvar cached = cache[ cacheKey ];\n\n\t\t\t\tif ( cached ) {\n\n\t\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\t\tpending.push( cached.promise );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar geometryPromise;\n\n\t\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new THREE.BufferGeometry(), primitive, parser );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Cache this geometry\n\t\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pending );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t\t * @param {number} meshIndex\n\t\t * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}\n\t\t */\n\t\tGLTFParser.prototype.loadMesh = function ( meshIndex ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar json = this.json;\n\n\t\t\tvar meshDef = json.meshes[ meshIndex ];\n\t\t\tvar primitives = meshDef.primitives;\n\n\t\t\tvar pending = [];\n\n\t\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\t\tvar material = primitives[ i ].material === undefined\n\t\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\t\tpending.push( material );\n\n\t\t\t}\n\n\t\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\t\tvar materials = results.slice( 0, results.length - 1 );\n\t\t\t\tvar geometries = results[ results.length - 1 ];\n\n\t\t\t\tvar meshes = [];\n\n\t\t\t\tfor ( var i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar geometry = geometries[ i ];\n\t\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\t\t// 1. create Mesh\n\n\t\t\t\t\tvar mesh;\n\n\t\t\t\t\tvar material = materials[ i ];\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See .markDefs()\n\t\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t\t? new THREE.SkinnedMesh( geometry, material )\n\t\t\t\t\t\t\t: new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\tif ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {\n\n\t\t\t\t\t\t\t// we normalize floating point skin weight array to fix malformed assets (see #15319)\n\t\t\t\t\t\t\t// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n\t\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, THREE.TriangleStripDrawMode );\n\n\t\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, THREE.TriangleFanDrawMode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\t\tmesh = new THREE.LineSegments( geometry, material );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\t\tmesh = new THREE.Line( geometry, material );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\t\tmesh = new THREE.LineLoop( geometry, material );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\t\tmesh = new THREE.Points( geometry, material );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.name = meshDef.name || ( 'mesh_' + meshIndex );\n\n\t\t\t\t\tif ( geometries.length > 1 ) mesh.name += '_' + i;\n\n\t\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tvar group = new THREE.Group();\n\n\t\t\t\tfor ( var i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn group;\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t\t * @param {number} cameraIndex\n\t\t * @return {Promise<THREE.Camera>}\n\t\t */\n\t\tGLTFParser.prototype.loadCamera = function ( cameraIndex ) {\n\n\t\t\tvar camera;\n\t\t\tvar cameraDef = this.json.cameras[ cameraIndex ];\n\t\t\tvar params = cameraDef[ cameraDef.type ];\n\n\t\t\tif ( ! params ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( THREE.MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\t\tcamera = new THREE.OrthographicCamera( params.xmag / - 2, params.xmag / 2, params.ymag / 2, params.ymag / - 2, params.znear, params.zfar );\n\n\t\t\t}\n\n\t\t\tif ( cameraDef.name ) camera.name = cameraDef.name;\n\n\t\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\t\treturn Promise.resolve( camera );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t\t * @param {number} skinIndex\n\t\t * @return {Promise<Object>}\n\t\t */\n\t\tGLTFParser.prototype.loadSkin = function ( skinIndex ) {\n\n\t\t\tvar skinDef = this.json.skins[ skinIndex ];\n\n\t\t\tvar skinEntry = { joints: skinDef.joints };\n\n\t\t\tif ( skinDef.inverseBindMatrices === undefined ) {\n\n\t\t\t\treturn Promise.resolve( skinEntry );\n\n\t\t\t}\n\n\t\t\treturn this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {\n\n\t\t\t\tskinEntry.inverseBindMatrices = accessor;\n\n\t\t\t\treturn skinEntry;\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t\t * @param {number} animationIndex\n\t\t * @return {Promise<THREE.AnimationClip>}\n\t\t */\n\t\tGLTFParser.prototype.loadAnimation = function ( animationIndex ) {\n\n\t\t\tvar json = this.json;\n\n\t\t\tvar animationDef = json.animations[ animationIndex ];\n\n\t\t\tvar pendingNodes = [];\n\t\t\tvar pendingInputAccessors = [];\n\t\t\tvar pendingOutputAccessors = [];\n\t\t\tvar pendingSamplers = [];\n\t\t\tvar pendingTargets = [];\n\n\t\t\tfor ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\t\tvar channel = animationDef.channels[ i ];\n\t\t\t\tvar sampler = animationDef.samplers[ channel.sampler ];\n\t\t\t\tvar target = channel.target;\n\t\t\t\tvar name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\t\t\tvar input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\t\tvar output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\t\tpendingSamplers.push( sampler );\n\t\t\t\tpendingTargets.push( target );\n\n\t\t\t}\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tPromise.all( pendingNodes ),\n\t\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\t\tPromise.all( pendingSamplers ),\n\t\t\t\tPromise.all( pendingTargets )\n\n\t\t\t] ).then( function ( dependencies ) {\n\n\t\t\t\tvar nodes = dependencies[ 0 ];\n\t\t\t\tvar inputAccessors = dependencies[ 1 ];\n\t\t\t\tvar outputAccessors = dependencies[ 2 ];\n\t\t\t\tvar samplers = dependencies[ 3 ];\n\t\t\t\tvar targets = dependencies[ 4 ];\n\n\t\t\t\tvar tracks = [];\n\n\t\t\t\tfor ( var i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar node = nodes[ i ];\n\t\t\t\t\tvar inputAccessor = inputAccessors[ i ];\n\t\t\t\t\tvar outputAccessor = outputAccessors[ i ];\n\t\t\t\t\tvar sampler = samplers[ i ];\n\t\t\t\t\tvar target = targets[ i ];\n\n\t\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\t\tnode.updateMatrix();\n\t\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\t\tvar TypedKeyframeTrack;\n\n\t\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\t\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.NumberKeyframeTrack;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase PATH_PROPERTIES.position:\n\t\t\t\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.VectorKeyframeTrack;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar targetName = node.name ? node.name : node.uuid;\n\n\t\t\t\t\tvar interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : THREE.InterpolateLinear;\n\n\t\t\t\t\tvar targetNames = [];\n\n\t\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\t\t\t\t// Node may be a THREE.Group (glTF mesh with several primitives) or a THREE.Mesh.\n\t\t\t\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\t\t\t\tif ( object.isMesh === true && object.morphTargetInfluences ) {\n\n\t\t\t\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetNames.push( targetName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar outputArray = outputAccessor.array;\n\n\t\t\t\t\tif ( outputAccessor.normalized ) {\n\n\t\t\t\t\t\tvar scale;\n\n\t\t\t\t\t\tif ( outputArray.constructor === Int8Array ) {\n\n\t\t\t\t\t\t\tscale = 1 / 127;\n\n\t\t\t\t\t\t} else if ( outputArray.constructor === Uint8Array ) {\n\n\t\t\t\t\t\t\tscale = 1 / 255;\n\n\t\t\t\t\t\t} else if ( outputArray.constructor == Int16Array ) {\n\n\t\t\t\t\t\t\tscale = 1 / 32767;\n\n\t\t\t\t\t\t} else if ( outputArray.constructor === Uint16Array ) {\n\n\t\t\t\t\t\t\tscale = 1 / 65535;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported output accessor component type.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar scaled = new Float32Array( outputArray.length );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toutputArray = scaled;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar track = new TypedKeyframeTrack(\n\t\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\t\t\t\tinputAccessor.array,\n\t\t\t\t\t\t\toutputArray,\n\t\t\t\t\t\t\tinterpolation\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Override interpolation with custom factory method.\n\t\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttracks.push( track );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\t\t\treturn new THREE.AnimationClip( name, undefined, tracks );\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t\t * @param {number} nodeIndex\n\t\t * @return {Promise<THREE.Object3D>}\n\t\t */\n\t\tGLTFParser.prototype.loadNode = function ( nodeIndex ) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar extensions = this.extensions;\n\t\t\tvar parser = this;\n\n\t\t\tvar meshReferences = json.meshReferences;\n\t\t\tvar meshUses = json.meshUses;\n\n\t\t\tvar nodeDef = json.nodes[ nodeIndex ];\n\n\t\t\treturn ( function () {\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\t\t\t\tvar node;\n\n\t\t\t\t\t\tif ( meshReferences[ nodeDef.mesh ] > 1 ) {\n\n\t\t\t\t\t\t\tvar instanceNum = meshUses[ nodeDef.mesh ] ++;\n\n\t\t\t\t\t\t\tnode = mesh.clone();\n\t\t\t\t\t\t\tnode.name += '_instance_' + instanceNum;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnode = mesh;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\t\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\t\t\t\tfor ( var i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn node;\n\n\t\t\t\t\t} ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.extensions\n\t\t\t\t\t&& nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ]\n\t\t\t\t\t&& nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.getDependency( 'light', nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all( pending );\n\n\t\t\t}() ).then( function ( objects ) {\n\n\t\t\t\tvar node;\n\n\t\t\t\t// .isBone isn't in glTF spec. See .markDefs\n\t\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\t\tnode = new THREE.Bone();\n\n\t\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\t\tnode = new THREE.Group();\n\n\t\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode = new THREE.Object3D();\n\n\t\t\t\t}\n\n\t\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\t\tnode.name = THREE.PropertyBinding.sanitizeNodeName( nodeDef.name );\n\n\t\t\t\t}\n\n\t\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn node;\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t\t * @param {number} sceneIndex\n\t\t * @return {Promise<THREE.Group>}\n\t\t */\n\t\tGLTFParser.prototype.loadScene = function () {\n\n\t\t\t// scene node hierachy builder\n\n\t\t\tfunction buildNodeHierachy( nodeId, parentObject, json, parser ) {\n\n\t\t\t\tvar nodeDef = json.nodes[ nodeId ];\n\n\t\t\t\treturn parser.getDependency( 'node', nodeId ).then( function ( node ) {\n\n\t\t\t\t\tif ( nodeDef.skin === undefined ) return node;\n\n\t\t\t\t\t// build skeleton here as well\n\n\t\t\t\t\tvar skinEntry;\n\n\t\t\t\t\treturn parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {\n\n\t\t\t\t\t\tskinEntry = skin;\n\n\t\t\t\t\t\tvar pendingJoints = [];\n\n\t\t\t\t\t\tfor ( var i = 0, il = skinEntry.joints.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tpendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn Promise.all( pendingJoints );\n\n\t\t\t\t\t} ).then( function ( jointNodes ) {\n\n\t\t\t\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\t\t\t\tif ( ! mesh.isMesh ) return;\n\n\t\t\t\t\t\t\tvar bones = [];\n\t\t\t\t\t\t\tvar boneInverses = [];\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = jointNodes.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar jointNode = jointNodes[ j ];\n\n\t\t\t\t\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\t\t\t\t\tvar mat = new THREE.Matrix4();\n\n\t\t\t\t\t\t\t\t\tif ( skinEntry.inverseBindMatrices !== undefined ) {\n\n\t\t\t\t\t\t\t\t\t\tmat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[ j ] );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmesh.bind( new THREE.Skeleton( bones, boneInverses ), mesh.matrixWorld );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\treturn node;\n\n\t\t\t\t\t} );\n\n\t\t\t\t} ).then( function ( node ) {\n\n\t\t\t\t\t// build node hierachy\n\n\t\t\t\t\tparentObject.add( node );\n\n\t\t\t\t\tvar pending = [];\n\n\t\t\t\t\tif ( nodeDef.children ) {\n\n\t\t\t\t\t\tvar children = nodeDef.children;\n\n\t\t\t\t\t\tfor ( var i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tvar child = children[ i ];\n\t\t\t\t\t\t\tpending.push( buildNodeHierachy( child, node, json, parser ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Promise.all( pending );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn function loadScene( sceneIndex ) {\n\n\t\t\t\tvar json = this.json;\n\t\t\t\tvar extensions = this.extensions;\n\t\t\t\tvar sceneDef = this.json.scenes[ sceneIndex ];\n\t\t\t\tvar parser = this;\n\n\t\t\t\t// Loader returns Group, not Scene.\n\t\t\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\t\t\tvar scene = new THREE.Group();\n\t\t\t\tif ( sceneDef.name ) scene.name = sceneDef.name;\n\n\t\t\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\t\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\t\t\tvar nodeIds = sceneDef.nodes || [];\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tfor ( var i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\t\t\tpending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\t\t\treturn scene;\n\n\t\t\t\t} );\n\n\t\t\t};\n\n\t\t}();\n\n\t\treturn GLTFLoader;\n\n\t} )();\n\t\n\treturn THREE.GLTFLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/MTLLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * Loads a Wavefront .mtl file specifying materials\n\t *\n\t * @author angelxuanchang\n\t */\n\n\tTHREE.MTLLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.MTLLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.MTLLoader,\n\n\t\t/**\n\t\t * Loads and parses a MTL asset from a URL.\n\t\t *\n\t\t * @param {String} url - URL to the MTL file.\n\t\t * @param {Function} [onLoad] - Callback invoked with the loaded object.\n\t\t * @param {Function} [onProgress] - Callback for download progress.\n\t\t * @param {Function} [onError] - Callback for download errors.\n\t\t *\n\t\t * @see setPath setResourcePath\n\t\t *\n\t\t * @note In order for relative texture references to resolve correctly\n\t\t * you must call setResourcePath() explicitly prior to load.\n\t\t */\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( this.path === '' ) ? THREE.LoaderUtils.extractUrlBase( url ) : this.path;\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetMaterialOptions: function ( value ) {\n\n\t\t\tthis.materialOptions = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\t/**\n\t\t * Parses a MTL file.\n\t\t *\n\t\t * @param {String} text - Content of MTL file\n\t\t * @return {THREE.MTLLoader.MaterialCreator}\n\t\t *\n\t\t * @see setPath setResourcePath\n\t\t *\n\t\t * @note In order for relative texture references to resolve correctly\n\t\t * you must call setResourcePath() explicitly prior to parse.\n\t\t */\n\t\tparse: function ( text, path ) {\n\n\t\t\tvar lines = text.split( '\\n' );\n\t\t\tvar info = {};\n\t\t\tvar delimiter_pattern = /\\s+/;\n\t\t\tvar materialsInfo = {};\n\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tvar line = lines[ i ];\n\t\t\t\tline = line.trim();\n\n\t\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\n\n\t\t\t\t\t// Blank line or comment ignore\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar pos = line.indexOf( ' ' );\n\n\t\t\t\tvar key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;\n\t\t\t\tkey = key.toLowerCase();\n\n\t\t\t\tvar value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';\n\t\t\t\tvalue = value.trim();\n\n\t\t\t\tif ( key === 'newmtl' ) {\n\n\t\t\t\t\t// New material\n\n\t\t\t\t\tinfo = { name: value };\n\t\t\t\t\tmaterialsInfo[ value ] = info;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke' ) {\n\n\t\t\t\t\t\tvar ss = value.split( delimiter_pattern, 3 );\n\t\t\t\t\t\tinfo[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tinfo[ key ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar materialCreator = new THREE.MTLLoader.MaterialCreator( this.resourcePath || path, this.materialOptions );\n\t\t\tmaterialCreator.setCrossOrigin( this.crossOrigin );\n\t\t\tmaterialCreator.setManager( this.manager );\n\t\t\tmaterialCreator.setMaterials( materialsInfo );\n\t\t\treturn materialCreator;\n\n\t\t}\n\n\t} );\n\n\n\t/**\n\t * Create a new THREE.MTLLoader.MaterialCreator\n\t * @param baseUrl - Url relative to which textures are loaded\n\t * @param options - Set of options on how to construct the materials\n\t *                  side: Which side to apply the material\n\t *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide\n\t *                  wrap: What type of wrapping to apply for textures\n\t *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n\t *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n\t *                                Default: false, assumed to be already normalized\n\t *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n\t *                                  Default: false\n\t * @constructor\n\t */\n\n\tTHREE.MTLLoader.MaterialCreator = function ( baseUrl, options ) {\n\n\t\tthis.baseUrl = baseUrl || '';\n\t\tthis.options = options;\n\t\tthis.materialsInfo = {};\n\t\tthis.materials = {};\n\t\tthis.materialsArray = [];\n\t\tthis.nameLookup = {};\n\n\t\tthis.side = ( this.options && this.options.side ) ? this.options.side : THREE.FrontSide;\n\t\tthis.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : THREE.RepeatWrapping;\n\n\t};\n\n\tTHREE.MTLLoader.MaterialCreator.prototype = {\n\n\t\tconstructor: THREE.MTLLoader.MaterialCreator,\n\n\t\tcrossOrigin: 'anonymous',\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetManager: function ( value ) {\n\n\t\t\tthis.manager = value;\n\n\t\t},\n\n\t\tsetMaterials: function ( materialsInfo ) {\n\n\t\t\tthis.materialsInfo = this.convert( materialsInfo );\n\t\t\tthis.materials = {};\n\t\t\tthis.materialsArray = [];\n\t\t\tthis.nameLookup = {};\n\n\t\t},\n\n\t\tconvert: function ( materialsInfo ) {\n\n\t\t\tif ( ! this.options ) return materialsInfo;\n\n\t\t\tvar converted = {};\n\n\t\t\tfor ( var mn in materialsInfo ) {\n\n\t\t\t\t// Convert materials info into normalized form based on options\n\n\t\t\t\tvar mat = materialsInfo[ mn ];\n\n\t\t\t\tvar covmat = {};\n\n\t\t\t\tconverted[ mn ] = covmat;\n\n\t\t\t\tfor ( var prop in mat ) {\n\n\t\t\t\t\tvar save = true;\n\t\t\t\t\tvar value = mat[ prop ];\n\t\t\t\t\tvar lprop = prop.toLowerCase();\n\n\t\t\t\t\tswitch ( lprop ) {\n\n\t\t\t\t\t\tcase 'kd':\n\t\t\t\t\t\tcase 'ka':\n\t\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\t\tif ( this.options && this.options.normalizeRGB ) {\n\n\t\t\t\t\t\t\t\tvalue = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( this.options && this.options.ignoreZeroRGBs ) {\n\n\t\t\t\t\t\t\t\tif ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {\n\n\t\t\t\t\t\t\t\t\t// ignore\n\n\t\t\t\t\t\t\t\t\tsave = false;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( save ) {\n\n\t\t\t\t\t\tcovmat[ lprop ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn converted;\n\n\t\t},\n\n\t\tpreload: function () {\n\n\t\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\t\tthis.create( mn );\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetIndex: function ( materialName ) {\n\n\t\t\treturn this.nameLookup[ materialName ];\n\n\t\t},\n\n\t\tgetAsArray: function () {\n\n\t\t\tvar index = 0;\n\n\t\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\t\tthis.materialsArray[ index ] = this.create( mn );\n\t\t\t\tthis.nameLookup[ mn ] = index;\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\treturn this.materialsArray;\n\n\t\t},\n\n\t\tcreate: function ( materialName ) {\n\n\t\t\tif ( this.materials[ materialName ] === undefined ) {\n\n\t\t\t\tthis.createMaterial_( materialName );\n\n\t\t\t}\n\n\t\t\treturn this.materials[ materialName ];\n\n\t\t},\n\n\t\tcreateMaterial_: function ( materialName ) {\n\n\t\t\t// Create material\n\n\t\t\tvar scope = this;\n\t\t\tvar mat = this.materialsInfo[ materialName ];\n\t\t\tvar params = {\n\n\t\t\t\tname: materialName,\n\t\t\t\tside: this.side\n\n\t\t\t};\n\n\t\t\tfunction resolveURL( baseUrl, url ) {\n\n\t\t\t\tif ( typeof url !== 'string' || url === '' )\n\t\t\t\t\treturn '';\n\n\t\t\t\t// Absolute URL\n\t\t\t\tif ( /^https?:\\/\\//i.test( url ) ) return url;\n\n\t\t\t\treturn baseUrl + url;\n\n\t\t\t}\n\n\t\t\tfunction setMapForType( mapType, value ) {\n\n\t\t\t\tif ( params[ mapType ] ) return; // Keep the first encountered texture\n\n\t\t\t\tvar texParams = scope.getTextureParams( value, params );\n\t\t\t\tvar map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );\n\n\t\t\t\tmap.repeat.copy( texParams.scale );\n\t\t\t\tmap.offset.copy( texParams.offset );\n\n\t\t\t\tmap.wrapS = scope.wrap;\n\t\t\t\tmap.wrapT = scope.wrap;\n\n\t\t\t\tparams[ mapType ] = map;\n\n\t\t\t}\n\n\t\t\tfor ( var prop in mat ) {\n\n\t\t\t\tvar value = mat[ prop ];\n\t\t\t\tvar n;\n\n\t\t\t\tif ( value === '' ) continue;\n\n\t\t\t\tswitch ( prop.toLowerCase() ) {\n\n\t\t\t\t\t// Ns is material specular exponent\n\n\t\t\t\t\tcase 'kd':\n\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\tparams.color = new THREE.Color().fromArray( value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\n\t\t\t\t\t\tparams.specular = new THREE.Color().fromArray( value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ke':\n\n\t\t\t\t\t\t// Emissive using RGB values\n\t\t\t\t\t\tparams.emissive = new THREE.Color().fromArray( value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'map_kd':\n\n\t\t\t\t\t\t// Diffuse texture map\n\n\t\t\t\t\t\tsetMapForType( \"map\", value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'map_ks':\n\n\t\t\t\t\t\t// Specular map\n\n\t\t\t\t\t\tsetMapForType( \"specularMap\", value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'map_ke':\n\n\t\t\t\t\t\t// Emissive map\n\n\t\t\t\t\t\tsetMapForType( \"emissiveMap\", value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'norm':\n\n\t\t\t\t\t\tsetMapForType( \"normalMap\", value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'map_bump':\n\t\t\t\t\tcase 'bump':\n\n\t\t\t\t\t\t// Bump texture map\n\n\t\t\t\t\t\tsetMapForType( \"bumpMap\", value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'map_d':\n\n\t\t\t\t\t\t// Alpha map\n\n\t\t\t\t\t\tsetMapForType( \"alphaMap\", value );\n\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ns':\n\n\t\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\n\t\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n\t\t\t\t\t\tparams.shininess = parseFloat( value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tn = parseFloat( value );\n\n\t\t\t\t\t\tif ( n < 1 ) {\n\n\t\t\t\t\t\t\tparams.opacity = n;\n\t\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'tr':\n\t\t\t\t\t\tn = parseFloat( value );\n\n\t\t\t\t\t\tif ( this.options && this.options.invertTrProperty ) n = 1 - n;\n\n\t\t\t\t\t\tif ( n > 0 ) {\n\n\t\t\t\t\t\t\tparams.opacity = 1 - n;\n\t\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.materials[ materialName ] = new THREE.MeshPhongMaterial( params );\n\t\t\treturn this.materials[ materialName ];\n\n\t\t},\n\n\t\tgetTextureParams: function ( value, matParams ) {\n\n\t\t\tvar texParams = {\n\n\t\t\t\tscale: new THREE.Vector2( 1, 1 ),\n\t\t\t\toffset: new THREE.Vector2( 0, 0 )\n\n\t\t\t };\n\n\t\t\tvar items = value.split( /\\s+/ );\n\t\t\tvar pos;\n\n\t\t\tpos = items.indexOf( '-bm' );\n\n\t\t\tif ( pos >= 0 ) {\n\n\t\t\t\tmatParams.bumpScale = parseFloat( items[ pos + 1 ] );\n\t\t\t\titems.splice( pos, 2 );\n\n\t\t\t}\n\n\t\t\tpos = items.indexOf( '-s' );\n\n\t\t\tif ( pos >= 0 ) {\n\n\t\t\t\ttexParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t\t}\n\n\t\t\tpos = items.indexOf( '-o' );\n\n\t\t\tif ( pos >= 0 ) {\n\n\t\t\t\ttexParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t\t}\n\n\t\t\ttexParams.url = items.join( ' ' ).trim();\n\t\t\treturn texParams;\n\n\t\t},\n\n\t\tloadTexture: function ( url, mapping, onLoad, onProgress, onError ) {\n\n\t\t\tvar texture;\n\t\t\tvar manager = ( this.manager !== undefined ) ? this.manager : THREE.DefaultLoadingManager;\n\t\t\tvar loader = manager.getHandler( url );\n\n\t\t\tif ( loader === null ) {\n\n\t\t\t\tloader = new THREE.TextureLoader( manager );\n\n\t\t\t}\n\n\t\t\tif ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );\n\t\t\ttexture = loader.load( url, onLoad, onProgress, onError );\n\n\t\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.MTLLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/OBJLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tTHREE.OBJLoader = ( function () {\n\n\t\t// o object_name | g group_name\n\t\tvar object_pattern = /^[og]\\s*(.+)?/;\n\t\t// mtllib file_reference\n\t\tvar material_library_pattern = /^mtllib /;\n\t\t// usemtl material_name\n\t\tvar material_use_pattern = /^usemtl /;\n\t\t// usemap map_name\n\t\tvar map_use_pattern = /^usemap /;\n\n\t\tfunction ParserState() {\n\n\t\t\tvar state = {\n\t\t\t\tobjects: [],\n\t\t\t\tobject: {},\n\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tcolors: [],\n\t\t\t\tuvs: [],\n\n\t\t\t\tmaterials: {},\n\t\t\t\tmaterialLibraries: [],\n\n\t\t\t\tstartObject: function ( name, fromDeclaration ) {\n\n\t\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\n\t\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\n\t\t\t\t\tif ( this.object && this.object.fromDeclaration === false ) {\n\n\t\t\t\t\t\tthis.object.name = name;\n\t\t\t\t\t\tthis.object.fromDeclaration = ( fromDeclaration !== false );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );\n\n\t\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\t\t\tthis.object._finalize( true );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.object = {\n\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\tfromDeclaration: ( fromDeclaration !== false ),\n\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\tvertices: [],\n\t\t\t\t\t\t\tnormals: [],\n\t\t\t\t\t\t\tcolors: [],\n\t\t\t\t\t\t\tuvs: []\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmaterials: [],\n\t\t\t\t\t\tsmooth: true,\n\n\t\t\t\t\t\tstartMaterial: function ( name, libraries ) {\n\n\t\t\t\t\t\t\tvar previous = this._finalize( false );\n\n\t\t\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\n\t\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\n\t\t\t\t\t\t\tif ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {\n\n\t\t\t\t\t\t\t\tthis.materials.splice( previous.index, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar material = {\n\t\t\t\t\t\t\t\tindex: this.materials.length,\n\t\t\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\t\t\tmtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),\n\t\t\t\t\t\t\t\tsmooth: ( previous !== undefined ? previous.smooth : this.smooth ),\n\t\t\t\t\t\t\t\tgroupStart: ( previous !== undefined ? previous.groupEnd : 0 ),\n\t\t\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\t\t\tinherited: false,\n\n\t\t\t\t\t\t\t\tclone: function ( index ) {\n\n\t\t\t\t\t\t\t\t\tvar cloned = {\n\t\t\t\t\t\t\t\t\t\tindex: ( typeof index === 'number' ? index : this.index ),\n\t\t\t\t\t\t\t\t\t\tname: this.name,\n\t\t\t\t\t\t\t\t\t\tmtllib: this.mtllib,\n\t\t\t\t\t\t\t\t\t\tsmooth: this.smooth,\n\t\t\t\t\t\t\t\t\t\tgroupStart: 0,\n\t\t\t\t\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\t\t\t\t\tinherited: false\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind( cloned );\n\t\t\t\t\t\t\t\t\treturn cloned;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tthis.materials.push( material );\n\n\t\t\t\t\t\t\treturn material;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcurrentMaterial: function () {\n\n\t\t\t\t\t\t\tif ( this.materials.length > 0 ) {\n\n\t\t\t\t\t\t\t\treturn this.materials[ this.materials.length - 1 ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn undefined;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t_finalize: function ( end ) {\n\n\t\t\t\t\t\t\tvar lastMultiMaterial = this.currentMaterial();\n\t\t\t\t\t\t\tif ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {\n\n\t\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n\t\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n\t\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\t\t\t\t\t\t\tif ( end && this.materials.length > 1 ) {\n\n\t\t\t\t\t\t\t\tfor ( var mi = this.materials.length - 1; mi >= 0; mi -- ) {\n\n\t\t\t\t\t\t\t\t\tif ( this.materials[ mi ].groupCount <= 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tthis.materials.splice( mi, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\n\t\t\t\t\t\t\tif ( end && this.materials.length === 0 ) {\n\n\t\t\t\t\t\t\t\tthis.materials.push( {\n\t\t\t\t\t\t\t\t\tname: '',\n\t\t\t\t\t\t\t\t\tsmooth: this.smooth\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn lastMultiMaterial;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Inherit previous objects material.\n\t\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\n\t\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\n\t\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\n\t\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n\t\t\t\t\tif ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {\n\n\t\t\t\t\t\tvar declared = previousMaterial.clone( 0 );\n\t\t\t\t\t\tdeclared.inherited = true;\n\t\t\t\t\t\tthis.object.materials.push( declared );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.objects.push( this.object );\n\n\t\t\t\t},\n\n\t\t\t\tfinalize: function () {\n\n\t\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\t\t\tthis.object._finalize( true );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tparseVertexIndex: function ( value, len ) {\n\n\t\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t\t\t},\n\n\t\t\t\tparseNormalIndex: function ( value, len ) {\n\n\t\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t\t\t},\n\n\t\t\t\tparseUVIndex: function ( value, len ) {\n\n\t\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 2 ) * 2;\n\n\t\t\t\t},\n\n\t\t\t\taddVertex: function ( a, b, c ) {\n\n\t\t\t\t\tvar src = this.vertices;\n\t\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t\t},\n\n\t\t\t\taddVertexPoint: function ( a ) {\n\n\t\t\t\t\tvar src = this.vertices;\n\t\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t\t\t},\n\n\t\t\t\taddVertexLine: function ( a ) {\n\n\t\t\t\t\tvar src = this.vertices;\n\t\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t\t\t},\n\n\t\t\t\taddNormal: function ( a, b, c ) {\n\n\t\t\t\t\tvar src = this.normals;\n\t\t\t\t\tvar dst = this.object.geometry.normals;\n\n\t\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t\t},\n\n\t\t\t\taddColor: function ( a, b, c ) {\n\n\t\t\t\t\tvar src = this.colors;\n\t\t\t\t\tvar dst = this.object.geometry.colors;\n\n\t\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t\t},\n\n\t\t\t\taddUV: function ( a, b, c ) {\n\n\t\t\t\t\tvar src = this.uvs;\n\t\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\t\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ] );\n\t\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ] );\n\n\t\t\t\t},\n\n\t\t\t\taddUVLine: function ( a ) {\n\n\t\t\t\t\tvar src = this.uvs;\n\t\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\n\t\t\t\t},\n\n\t\t\t\taddFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {\n\n\t\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\t\tvar ia = this.parseVertexIndex( a, vLen );\n\t\t\t\t\tvar ib = this.parseVertexIndex( b, vLen );\n\t\t\t\t\tvar ic = this.parseVertexIndex( c, vLen );\n\n\t\t\t\t\tthis.addVertex( ia, ib, ic );\n\n\t\t\t\t\tif ( this.colors.length > 0 ) {\n\n\t\t\t\t\t\tthis.addColor( ia, ib, ic );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ua !== undefined && ua !== '' ) {\n\n\t\t\t\t\t\tvar uvLen = this.uvs.length;\n\t\t\t\t\t\tia = this.parseUVIndex( ua, uvLen );\n\t\t\t\t\t\tib = this.parseUVIndex( ub, uvLen );\n\t\t\t\t\t\tic = this.parseUVIndex( uc, uvLen );\n\t\t\t\t\t\tthis.addUV( ia, ib, ic );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( na !== undefined && na !== '' ) {\n\n\t\t\t\t\t\t// Normals are many times the same. If so, skip function call and parseInt.\n\t\t\t\t\t\tvar nLen = this.normals.length;\n\t\t\t\t\t\tia = this.parseNormalIndex( na, nLen );\n\n\t\t\t\t\t\tib = na === nb ? ia : this.parseNormalIndex( nb, nLen );\n\t\t\t\t\t\tic = na === nc ? ia : this.parseNormalIndex( nc, nLen );\n\n\t\t\t\t\t\tthis.addNormal( ia, ib, ic );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\taddPointGeometry: function ( vertices ) {\n\n\t\t\t\t\tthis.object.geometry.type = 'Points';\n\n\t\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\t\t\tthis.addVertexPoint( this.parseVertexIndex( vertices[ vi ], vLen ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\taddLineGeometry: function ( vertices, uvs ) {\n\n\t\t\t\t\tthis.object.geometry.type = 'Line';\n\n\t\t\t\t\tvar vLen = this.vertices.length;\n\t\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\t\t\tthis.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {\n\n\t\t\t\t\t\tthis.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tstate.startObject( '', false );\n\n\t\t\treturn state;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction OBJLoader( manager ) {\n\n\t\t\tTHREE.Loader.call( this, manager );\n\n\t\t\tthis.materials = null;\n\n\t\t}\n\n\t\tOBJLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\t\tconstructor: OBJLoader,\n\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t},\n\n\t\t\tsetMaterials: function ( materials ) {\n\n\t\t\t\tthis.materials = materials;\n\n\t\t\t\treturn this;\n\n\t\t\t},\n\n\t\t\tparse: function ( text ) {\n\n\t\t\t\tvar state = new ParserState();\n\n\t\t\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( text.indexOf( '\\\\\\n' ) !== - 1 ) {\n\n\t\t\t\t\t// join lines separated by a line continuation character (\\)\n\t\t\t\t\ttext = text.replace( /\\\\\\n/g, '' );\n\n\t\t\t\t}\n\n\t\t\t\tvar lines = text.split( '\\n' );\n\t\t\t\tvar line = '', lineFirstChar = '';\n\t\t\t\tvar lineLength = 0;\n\t\t\t\tvar result = [];\n\n\t\t\t\t// Faster to just trim left side of the line. Use if available.\n\t\t\t\tvar trimLeft = ( typeof ''.trimLeft === 'function' );\n\n\t\t\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\t\tline = lines[ i ];\n\n\t\t\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\n\n\t\t\t\t\tlineLength = line.length;\n\n\t\t\t\t\tif ( lineLength === 0 ) continue;\n\n\t\t\t\t\tlineFirstChar = line.charAt( 0 );\n\n\t\t\t\t\t// @todo invoke passed in handler if any\n\t\t\t\t\tif ( lineFirstChar === '#' ) continue;\n\n\t\t\t\t\tif ( lineFirstChar === 'v' ) {\n\n\t\t\t\t\t\tvar data = line.split( /\\s+/ );\n\n\t\t\t\t\t\tswitch ( data[ 0 ] ) {\n\n\t\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\t\tstate.vertices.push(\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif ( data.length >= 7 ) {\n\n\t\t\t\t\t\t\t\t\tstate.colors.push(\n\t\t\t\t\t\t\t\t\t\tparseFloat( data[ 4 ] ),\n\t\t\t\t\t\t\t\t\t\tparseFloat( data[ 5 ] ),\n\t\t\t\t\t\t\t\t\t\tparseFloat( data[ 6 ] )\n\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'vn':\n\t\t\t\t\t\t\t\tstate.normals.push(\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'vt':\n\t\t\t\t\t\t\t\tstate.uvs.push(\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] )\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( lineFirstChar === 'f' ) {\n\n\t\t\t\t\t\tvar lineData = line.substr( 1 ).trim();\n\t\t\t\t\t\tvar vertexData = lineData.split( /\\s+/ );\n\t\t\t\t\t\tvar faceVertices = [];\n\n\t\t\t\t\t\t// Parse the face vertex data into an easy to work with format\n\n\t\t\t\t\t\tfor ( var j = 0, jl = vertexData.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar vertex = vertexData[ j ];\n\n\t\t\t\t\t\t\tif ( vertex.length > 0 ) {\n\n\t\t\t\t\t\t\t\tvar vertexParts = vertex.split( '/' );\n\t\t\t\t\t\t\t\tfaceVertices.push( vertexParts );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n\t\t\t\t\t\tvar v1 = faceVertices[ 0 ];\n\n\t\t\t\t\t\tfor ( var j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar v2 = faceVertices[ j ];\n\t\t\t\t\t\t\tvar v3 = faceVertices[ j + 1 ];\n\n\t\t\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\t\t\tv1[ 0 ], v2[ 0 ], v3[ 0 ],\n\t\t\t\t\t\t\t\tv1[ 1 ], v2[ 1 ], v3[ 1 ],\n\t\t\t\t\t\t\t\tv1[ 2 ], v2[ 2 ], v3[ 2 ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( lineFirstChar === 'l' ) {\n\n\t\t\t\t\t\tvar lineParts = line.substring( 1 ).trim().split( \" \" );\n\t\t\t\t\t\tvar lineVertices = [], lineUVs = [];\n\n\t\t\t\t\t\tif ( line.indexOf( \"/\" ) === - 1 ) {\n\n\t\t\t\t\t\t\tlineVertices = lineParts;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {\n\n\t\t\t\t\t\t\t\tvar parts = lineParts[ li ].split( \"/\" );\n\n\t\t\t\t\t\t\t\tif ( parts[ 0 ] !== \"\" ) lineVertices.push( parts[ 0 ] );\n\t\t\t\t\t\t\t\tif ( parts[ 1 ] !== \"\" ) lineUVs.push( parts[ 1 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate.addLineGeometry( lineVertices, lineUVs );\n\n\t\t\t\t\t} else if ( lineFirstChar === 'p' ) {\n\n\t\t\t\t\t\tvar lineData = line.substr( 1 ).trim();\n\t\t\t\t\t\tvar pointData = lineData.split( \" \" );\n\n\t\t\t\t\t\tstate.addPointGeometry( pointData );\n\n\t\t\t\t\t} else if ( ( result = object_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t// o object_name\n\t\t\t\t\t\t// or\n\t\t\t\t\t\t// g group_name\n\n\t\t\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t\t\t// var name = result[ 0 ].substr( 1 ).trim();\n\t\t\t\t\t\tvar name = ( \" \" + result[ 0 ].substr( 1 ).trim() ).substr( 1 );\n\n\t\t\t\t\t\tstate.startObject( name );\n\n\t\t\t\t\t} else if ( material_use_pattern.test( line ) ) {\n\n\t\t\t\t\t\t// material\n\n\t\t\t\t\t\tstate.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );\n\n\t\t\t\t\t} else if ( material_library_pattern.test( line ) ) {\n\n\t\t\t\t\t\t// mtl file\n\n\t\t\t\t\t\tstate.materialLibraries.push( line.substring( 7 ).trim() );\n\n\t\t\t\t\t} else if ( map_use_pattern.test( line ) ) {\n\n\t\t\t\t\t\t// the line is parsed but ignored since the loader assumes textures are defined MTL files\n\t\t\t\t\t\t// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n\n\t\t\t\t\t\tconsole.warn( 'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.' );\n\n\t\t\t\t\t} else if ( lineFirstChar === 's' ) {\n\n\t\t\t\t\t\tresult = line.split( ' ' );\n\n\t\t\t\t\t\t// smooth shading\n\n\t\t\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n\t\t\t\t\t\t// but does not define a usemtl for each face set.\n\t\t\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n\t\t\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n\t\t\t\t\t\t// where explicit usemtl defines geometry groups.\n\t\t\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * http://paulbourke.net/dataformats/obj/\n\t\t\t\t\t\t * or\n\t\t\t\t\t\t * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n\t\t\t\t\t\t * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n\t\t\t\t\t\t * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n\t\t\t\t\t\t * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n\t\t\t\t\t\t * than 0.\"\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ( result.length > 1 ) {\n\n\t\t\t\t\t\t\tvar value = result[ 1 ].trim().toLowerCase();\n\t\t\t\t\t\t\tstate.object.smooth = ( value !== '0' && value !== 'off' );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// ZBrush can produce \"s\" lines #11707\n\t\t\t\t\t\t\tstate.object.smooth = true;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar material = state.object.currentMaterial();\n\t\t\t\t\t\tif ( material ) material.smooth = state.object.smooth;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Handle null terminated files without exception\n\t\t\t\t\t\tif ( line === '\\0' ) continue;\n\n\t\t\t\t\t\tconsole.warn( 'THREE.OBJLoader: Unexpected line: \"' + line + '\"' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tstate.finalize();\n\n\t\t\t\tvar container = new THREE.Group();\n\t\t\t\tcontainer.materialLibraries = [].concat( state.materialLibraries );\n\n\t\t\t\tfor ( var i = 0, l = state.objects.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar object = state.objects[ i ];\n\t\t\t\t\tvar geometry = object.geometry;\n\t\t\t\t\tvar materials = object.materials;\n\t\t\t\t\tvar isLine = ( geometry.type === 'Line' );\n\t\t\t\t\tvar isPoints = ( geometry.type === 'Points' );\n\t\t\t\t\tvar hasVertexColors = false;\n\n\t\t\t\t\t// Skip o/g line declarations that did not follow with any faces\n\t\t\t\t\tif ( geometry.vertices.length === 0 ) continue;\n\n\t\t\t\t\tvar buffergeometry = new THREE.BufferGeometry();\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( geometry.vertices, 3 ) );\n\n\t\t\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( geometry.normals, 3 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuffergeometry.computeVertexNormals();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\t\t\t\thasVertexColors = true;\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( geometry.colors, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( geometry.uvs, 2 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create materials\n\n\t\t\t\t\tvar createdMaterials = [];\n\n\t\t\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\t\tvar sourceMaterial = materials[ mi ];\n\t\t\t\t\t\tvar materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;\n\t\t\t\t\t\tvar material = state.materials[ materialHash ];\n\n\t\t\t\t\t\tif ( this.materials !== null ) {\n\n\t\t\t\t\t\t\tmaterial = this.materials.create( sourceMaterial.name );\n\n\t\t\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\t\t\t\t\t\t\tif ( isLine && material && ! ( material instanceof THREE.LineBasicMaterial ) ) {\n\n\t\t\t\t\t\t\t\tvar materialLine = new THREE.LineBasicMaterial();\n\t\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call( materialLine, material );\n\t\t\t\t\t\t\t\tmaterialLine.color.copy( material.color );\n\t\t\t\t\t\t\t\tmaterial = materialLine;\n\n\t\t\t\t\t\t\t} else if ( isPoints && material && ! ( material instanceof THREE.PointsMaterial ) ) {\n\n\t\t\t\t\t\t\t\tvar materialPoints = new THREE.PointsMaterial( { size: 10, sizeAttenuation: false } );\n\t\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call( materialPoints, material );\n\t\t\t\t\t\t\t\tmaterialPoints.color.copy( material.color );\n\t\t\t\t\t\t\t\tmaterialPoints.map = material.map;\n\t\t\t\t\t\t\t\tmaterial = materialPoints;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( material === undefined ) {\n\n\t\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial();\n\n\t\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\t\tmaterial = new THREE.PointsMaterial( { size: 1, sizeAttenuation: false } );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaterial.name = sourceMaterial.name;\n\t\t\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;\n\t\t\t\t\t\t\tmaterial.vertexColors = hasVertexColors;\n\n\t\t\t\t\t\t\tstate.materials[ materialHash ] = material;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcreatedMaterials.push( material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create mesh\n\n\t\t\t\t\tvar mesh;\n\n\t\t\t\t\tif ( createdMaterials.length > 1 ) {\n\n\t\t\t\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\t\t\tvar sourceMaterial = materials[ mi ];\n\t\t\t\t\t\t\tbuffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\tmesh = new THREE.LineSegments( buffergeometry, createdMaterials );\n\n\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\tmesh = new THREE.Points( buffergeometry, createdMaterials );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new THREE.Mesh( buffergeometry, createdMaterials );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\tmesh = new THREE.LineSegments( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\tmesh = new THREE.Points( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new THREE.Mesh( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.name = object.name;\n\n\t\t\t\t\tcontainer.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\treturn container;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn OBJLoader;\n\n\t} )();\n\t\n\treturn THREE.OBJLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/PCDLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Filipe Caixeta / http://filipecaixeta.com.br\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Description: A THREE loader for PCD ascii and binary files.\n\t */\n\n\tTHREE.PCDLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.littleEndian = true;\n\n\t};\n\n\n\tTHREE.PCDLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.PCDLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( data ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( scope.parse( data, url ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow e;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data, url ) {\n\n\t\t\t// from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n\n\t\t\tfunction decompressLZF( inData, outLength ) {\n\n\t\t\t\tvar inLength = inData.length;\n\t\t\t\tvar outData = new Uint8Array( outLength );\n\t\t\t\tvar inPtr = 0;\n\t\t\t\tvar outPtr = 0;\n\t\t\t\tvar ctrl;\n\t\t\t\tvar len;\n\t\t\t\tvar ref;\n\t\t\t\tdo {\n\n\t\t\t\t\tctrl = inData[ inPtr ++ ];\n\t\t\t\t\tif ( ctrl < ( 1 << 5 ) ) {\n\n\t\t\t\t\t\tctrl ++;\n\t\t\t\t\t\tif ( outPtr + ctrl > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\t\tif ( inPtr + ctrl > inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\toutData[ outPtr ++ ] = inData[ inPtr ++ ];\n\n\t\t\t\t\t\t} while ( -- ctrl );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlen = ctrl >> 5;\n\t\t\t\t\t\tref = outPtr - ( ( ctrl & 0x1f ) << 8 ) - 1;\n\t\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\t\tif ( len === 7 ) {\n\n\t\t\t\t\t\t\tlen += inData[ inPtr ++ ];\n\t\t\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tref -= inData[ inPtr ++ ];\n\t\t\t\t\t\tif ( outPtr + len + 2 > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\t\tif ( ref < 0 ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\t\tif ( ref >= outPtr ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\toutData[ outPtr ++ ] = outData[ ref ++ ];\n\n\t\t\t\t\t\t} while ( -- len + 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} while ( inPtr < inLength );\n\n\t\t\t\treturn outData;\n\n\t\t\t}\n\n\t\t\tfunction parseHeader( data ) {\n\n\t\t\t\tvar PCDheader = {};\n\t\t\t\tvar result1 = data.search( /[\\r\\n]DATA\\s(\\S*)\\s/i );\n\t\t\t\tvar result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec( data.substr( result1 - 1 ) );\n\n\t\t\t\tPCDheader.data = result2[ 1 ];\n\t\t\t\tPCDheader.headerLen = result2[ 0 ].length + result1;\n\t\t\t\tPCDheader.str = data.substr( 0, PCDheader.headerLen );\n\n\t\t\t\t// remove comments\n\n\t\t\t\tPCDheader.str = PCDheader.str.replace( /\\#.*/gi, '' );\n\n\t\t\t\t// parse\n\n\t\t\t\tPCDheader.version = /VERSION (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.fields = /FIELDS (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.size = /SIZE (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.type = /TYPE (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.count = /COUNT (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.width = /WIDTH (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.height = /HEIGHT (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.viewpoint = /VIEWPOINT (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.points = /POINTS (.*)/i.exec( PCDheader.str );\n\n\t\t\t\t// evaluate\n\n\t\t\t\tif ( PCDheader.version !== null )\n\t\t\t\t\tPCDheader.version = parseFloat( PCDheader.version[ 1 ] );\n\n\t\t\t\tif ( PCDheader.fields !== null )\n\t\t\t\t\tPCDheader.fields = PCDheader.fields[ 1 ].split( ' ' );\n\n\t\t\t\tif ( PCDheader.type !== null )\n\t\t\t\t\tPCDheader.type = PCDheader.type[ 1 ].split( ' ' );\n\n\t\t\t\tif ( PCDheader.width !== null )\n\t\t\t\t\tPCDheader.width = parseInt( PCDheader.width[ 1 ] );\n\n\t\t\t\tif ( PCDheader.height !== null )\n\t\t\t\t\tPCDheader.height = parseInt( PCDheader.height[ 1 ] );\n\n\t\t\t\tif ( PCDheader.viewpoint !== null )\n\t\t\t\t\tPCDheader.viewpoint = PCDheader.viewpoint[ 1 ];\n\n\t\t\t\tif ( PCDheader.points !== null )\n\t\t\t\t\tPCDheader.points = parseInt( PCDheader.points[ 1 ], 10 );\n\n\t\t\t\tif ( PCDheader.points === null )\n\t\t\t\t\tPCDheader.points = PCDheader.width * PCDheader.height;\n\n\t\t\t\tif ( PCDheader.size !== null ) {\n\n\t\t\t\t\tPCDheader.size = PCDheader.size[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tif ( PCDheader.count !== null ) {\n\n\t\t\t\t\tPCDheader.count = PCDheader.count[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tPCDheader.count = [];\n\n\t\t\t\t\tfor ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tPCDheader.count.push( 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tPCDheader.offset = {};\n\n\t\t\t\tvar sizeSum = 0;\n\n\t\t\t\tfor ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = i;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = sizeSum;\n\t\t\t\t\t\tsizeSum += PCDheader.size[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// for binary only\n\n\t\t\t\tPCDheader.rowSize = sizeSum;\n\n\t\t\t\treturn PCDheader;\n\n\t\t\t}\n\n\t\t\tvar textData = THREE.LoaderUtils.decodeText( new Uint8Array( data ) );\n\n\t\t\t// parse header (always ascii format)\n\n\t\t\tvar PCDheader = parseHeader( textData );\n\n\t\t\t// parse data\n\n\t\t\tvar position = [];\n\t\t\tvar normal = [];\n\t\t\tvar color = [];\n\n\t\t\t// ascii\n\n\t\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\t\tvar offset = PCDheader.offset;\n\t\t\t\tvar pcdData = textData.substr( PCDheader.headerLen );\n\t\t\t\tvar lines = pcdData.split( '\\n' );\n\n\t\t\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( lines[ i ] === '' ) continue;\n\n\t\t\t\t\tvar line = lines[ i ].split( ' ' );\n\n\t\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\t\tposition.push( parseFloat( line[ offset.x ] ) );\n\t\t\t\t\t\tposition.push( parseFloat( line[ offset.y ] ) );\n\t\t\t\t\t\tposition.push( parseFloat( line[ offset.z ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\t\tvar rgb = parseFloat( line[ offset.rgb ] );\n\t\t\t\t\t\tvar r = ( rgb >> 16 ) & 0x0000ff;\n\t\t\t\t\t\tvar g = ( rgb >> 8 ) & 0x0000ff;\n\t\t\t\t\t\tvar b = ( rgb >> 0 ) & 0x0000ff;\n\t\t\t\t\t\tcolor.push( r / 255, g / 255, b / 255 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_x ] ) );\n\t\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_y ] ) );\n\t\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_z ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// binary-compressed\n\n\t\t\t// normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n\t\t\t// binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n\t\t\t// that requires a totally different parsing approach compared to non-compressed data\n\n\t\t\tif ( PCDheader.data === 'binary_compressed' ) {\n\n\t\t\t\tvar sizes = new Uint32Array( data.slice( PCDheader.headerLen, PCDheader.headerLen + 8 ) );\n\t\t\t\tvar compressedSize = sizes[ 0 ];\n\t\t\t\tvar decompressedSize = sizes[ 1 ];\n\t\t\t\tvar decompressed = decompressLZF( new Uint8Array( data, PCDheader.headerLen + 8, compressedSize ), decompressedSize );\n\t\t\t\tvar dataview = new DataView( decompressed.buffer );\n\n\t\t\t\tvar offset = PCDheader.offset;\n\n\t\t\t\tfor ( var i = 0; i < PCDheader.points; i ++ ) {\n\n\t\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.x ) + PCDheader.size[ 0 ] * i, this.littleEndian ) );\n\t\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.y ) + PCDheader.size[ 1 ] * i, this.littleEndian ) );\n\t\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.z ) + PCDheader.size[ 2 ] * i, this.littleEndian ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 0 ) / 255.0 );\n\t\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 1 ) / 255.0 );\n\t\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 2 ) / 255.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_x ) + PCDheader.size[ 4 ] * i, this.littleEndian ) );\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_y ) + PCDheader.size[ 5 ] * i, this.littleEndian ) );\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_z ) + PCDheader.size[ 6 ] * i, this.littleEndian ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// binary\n\n\t\t\tif ( PCDheader.data === 'binary' ) {\n\n\t\t\t\tvar dataview = new DataView( data, PCDheader.headerLen );\n\t\t\t\tvar offset = PCDheader.offset;\n\n\t\t\t\tfor ( var i = 0, row = 0; i < PCDheader.points; i ++, row += PCDheader.rowSize ) {\n\n\t\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.x, this.littleEndian ) );\n\t\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.y, this.littleEndian ) );\n\t\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.z, this.littleEndian ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 2 ) / 255.0 );\n\t\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 1 ) / 255.0 );\n\t\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 0 ) / 255.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_x, this.littleEndian ) );\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_y, this.littleEndian ) );\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_z, this.littleEndian ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tif ( position.length > 0 ) geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( position, 3 ) );\n\t\t\tif ( normal.length > 0 ) geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normal, 3 ) );\n\t\t\tif ( color.length > 0 ) geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( color, 3 ) );\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t// build material\n\n\t\t\tvar material = new THREE.PointsMaterial( { size: 0.005 } );\n\n\t\t\tif ( color.length > 0 ) {\n\n\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.color.setHex( Math.random() * 0xffffff );\n\n\t\t\t}\n\n\t\t\t// build point cloud\n\n\t\t\tvar mesh = new THREE.Points( geometry, material );\n\t\t\tvar name = url.split( '' ).reverse().join( '' );\n\t\t\tname = /([^\\/]*)/.exec( name );\n\t\t\tname = name[ 1 ].split( '' ).reverse().join( '' );\n\t\t\tmesh.name = name;\n\n\t\t\treturn mesh;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.PCDLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/PLYLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Wei Meng / http://about.me/menway\n\t *\n\t * Description: A THREE loader for PLY ASCII files (known as the Polygon\n\t * File Format or the Stanford Triangle Format).\n\t *\n\t * Limitations: ASCII decoding assumes file is UTF-8.\n\t *\n\t * Usage:\n\t *\tvar loader = new THREE.PLYLoader();\n\t *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n\t *\n\t *\t\tscene.add( new THREE.Mesh( geometry ) );\n\t *\n\t *\t} );\n\t *\n\t * If the PLY file uses non standard property names, they can be mapped while\n\t * loading. For example, the following maps the properties\n\t * “diffuse_(red|green|blue)” in the file to standard color names.\n\t *\n\t * loader.setPropertyNameMapping( {\n\t *\tdiffuse_red: 'red',\n\t *\tdiffuse_green: 'green',\n\t *\tdiffuse_blue: 'blue'\n\t * } );\n\t *\n\t */\n\n\n\tTHREE.PLYLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.propertyNameMapping = {};\n\n\t};\n\n\tTHREE.PLYLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.PLYLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetPropertyNameMapping: function ( mapping ) {\n\n\t\t\tthis.propertyNameMapping = mapping;\n\n\t\t},\n\n\t\tparse: function ( data ) {\n\n\t\t\tfunction parseHeader( data ) {\n\n\t\t\t\tvar patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n\t\t\t\tvar headerText = '';\n\t\t\t\tvar headerLength = 0;\n\t\t\t\tvar result = patternHeader.exec( data );\n\n\t\t\t\tif ( result !== null ) {\n\n\t\t\t\t\theaderText = result[ 1 ];\n\t\t\t\t\theaderLength = result[ 0 ].length;\n\n\t\t\t\t}\n\n\t\t\t\tvar header = {\n\t\t\t\t\tcomments: [],\n\t\t\t\t\telements: [],\n\t\t\t\t\theaderLength: headerLength\n\t\t\t\t};\n\n\t\t\t\tvar lines = headerText.split( '\\n' );\n\t\t\t\tvar currentElement;\n\t\t\t\tvar lineType, lineValues;\n\n\t\t\t\tfunction make_ply_element_property( propertValues, propertyNameMapping ) {\n\n\t\t\t\t\tvar property = { type: propertValues[ 0 ] };\n\n\t\t\t\t\tif ( property.type === 'list' ) {\n\n\t\t\t\t\t\tproperty.name = propertValues[ 3 ];\n\t\t\t\t\t\tproperty.countType = propertValues[ 1 ];\n\t\t\t\t\t\tproperty.itemType = propertValues[ 2 ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tproperty.name = propertValues[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( property.name in propertyNameMapping ) {\n\n\t\t\t\t\t\tproperty.name = propertyNameMapping[ property.name ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn property;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\t\tvar line = lines[ i ];\n\t\t\t\t\tline = line.trim();\n\n\t\t\t\t\tif ( line === '' ) continue;\n\n\t\t\t\t\tlineValues = line.split( /\\s+/ );\n\t\t\t\t\tlineType = lineValues.shift();\n\t\t\t\t\tline = lineValues.join( ' ' );\n\n\t\t\t\t\tswitch ( lineType ) {\n\n\t\t\t\t\t\tcase 'format':\n\n\t\t\t\t\t\t\theader.format = lineValues[ 0 ];\n\t\t\t\t\t\t\theader.version = lineValues[ 1 ];\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'comment':\n\n\t\t\t\t\t\t\theader.comments.push( line );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'element':\n\n\t\t\t\t\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\t\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcurrentElement = {};\n\t\t\t\t\t\t\tcurrentElement.name = lineValues[ 0 ];\n\t\t\t\t\t\t\tcurrentElement.count = parseInt( lineValues[ 1 ] );\n\t\t\t\t\t\t\tcurrentElement.properties = [];\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'property':\n\n\t\t\t\t\t\t\tcurrentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );\n\n\t\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconsole.log( 'unhandled', lineType, lineValues );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t}\n\n\t\t\tfunction parseASCIINumber( n, type ) {\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':\n\t\t\t\t\tcase 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':\n\n\t\t\t\t\t\treturn parseInt( n );\n\n\t\t\t\t\tcase 'float': case 'double': case 'float32': case 'float64':\n\n\t\t\t\t\t\treturn parseFloat( n );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseASCIIElement( properties, line ) {\n\n\t\t\t\tvar values = line.split( /\\s+/ );\n\n\t\t\t\tvar element = {};\n\n\t\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\t\tvar list = [];\n\t\t\t\t\t\tvar n = parseASCIINumber( values.shift(), properties[ i ].countType );\n\n\t\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\t\tlist.push( parseASCIINumber( values.shift(), properties[ i ].itemType ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\telement[ properties[ i ].name ] = parseASCIINumber( values.shift(), properties[ i ].type );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn element;\n\n\t\t\t}\n\n\t\t\tfunction parseASCII( data, header ) {\n\n\t\t\t\t// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n\t\t\t\tvar buffer = {\n\t\t\t\t\tindices: [],\n\t\t\t\t\tvertices: [],\n\t\t\t\t\tnormals: [],\n\t\t\t\t\tuvs: [],\n\t\t\t\t\tfaceVertexUvs: [],\n\t\t\t\t\tcolors: []\n\t\t\t\t};\n\n\t\t\t\tvar result;\n\n\t\t\t\tvar patternBody = /end_header\\s([\\s\\S]*)$/;\n\t\t\t\tvar body = '';\n\t\t\t\tif ( ( result = patternBody.exec( data ) ) !== null ) {\n\n\t\t\t\t\tbody = result[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tvar lines = body.split( '\\n' );\n\t\t\t\tvar currentElement = 0;\n\t\t\t\tvar currentElementCount = 0;\n\n\t\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\t\tvar line = lines[ i ];\n\t\t\t\t\tline = line.trim();\n\t\t\t\t\tif ( line === '' ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( currentElementCount >= header.elements[ currentElement ].count ) {\n\n\t\t\t\t\t\tcurrentElement ++;\n\t\t\t\t\t\tcurrentElementCount = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar element = parseASCIIElement( header.elements[ currentElement ].properties, line );\n\n\t\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\t\tcurrentElementCount ++;\n\n\t\t\t\t}\n\n\t\t\t\treturn postProcess( buffer );\n\n\t\t\t}\n\n\t\t\tfunction postProcess( buffer ) {\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\t// mandatory buffer data\n\n\t\t\t\tif ( buffer.indices.length > 0 ) {\n\n\t\t\t\t\tgeometry.setIndex( buffer.indices );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( buffer.vertices, 3 ) );\n\n\t\t\t\t// optional buffer data\n\n\t\t\t\tif ( buffer.normals.length > 0 ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( buffer.normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( buffer.uvs.length > 0 ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( buffer.uvs, 2 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( buffer.colors.length > 0 ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( buffer.colors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( buffer.faceVertexUvs.length > 0 ) {\n\n\t\t\t\t\tgeometry = geometry.toNonIndexed();\n\t\t\t\t\tgeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( buffer.faceVertexUvs, 2 ) );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction handleElement( buffer, elementName, element ) {\n\n\t\t\t\tif ( elementName === 'vertex' ) {\n\n\t\t\t\t\tbuffer.vertices.push( element.x, element.y, element.z );\n\n\t\t\t\t\tif ( 'nx' in element && 'ny' in element && 'nz' in element ) {\n\n\t\t\t\t\t\tbuffer.normals.push( element.nx, element.ny, element.nz );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 's' in element && 't' in element ) {\n\n\t\t\t\t\t\tbuffer.uvs.push( element.s, element.t );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'red' in element && 'green' in element && 'blue' in element ) {\n\n\t\t\t\t\t\tbuffer.colors.push( element.red / 255.0, element.green / 255.0, element.blue / 255.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( elementName === 'face' ) {\n\n\t\t\t\t\tvar vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\t\t\t\t\tvar texcoord = element.texcoord;\n\n\t\t\t\t\tif ( vertex_indices.length === 3 ) {\n\n\t\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );\n\n\t\t\t\t\t\tif ( texcoord && texcoord.length === 6 ) {\n\n\t\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 0 ], texcoord[ 1 ] );\n\t\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 2 ], texcoord[ 3 ] );\n\t\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 4 ], texcoord[ 5 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( vertex_indices.length === 4 ) {\n\n\t\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );\n\t\t\t\t\t\tbuffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction binaryRead( dataview, at, type, little_endian ) {\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t// corespondences for non-specific length types here match rply:\n\t\t\t\t\tcase 'int8':\t\tcase 'char':\t return [ dataview.getInt8( at ), 1 ];\n\t\t\t\t\tcase 'uint8':\t\tcase 'uchar':\t return [ dataview.getUint8( at ), 1 ];\n\t\t\t\t\tcase 'int16':\t\tcase 'short':\t return [ dataview.getInt16( at, little_endian ), 2 ];\n\t\t\t\t\tcase 'uint16':\tcase 'ushort': return [ dataview.getUint16( at, little_endian ), 2 ];\n\t\t\t\t\tcase 'int32':\t\tcase 'int':\t\t return [ dataview.getInt32( at, little_endian ), 4 ];\n\t\t\t\t\tcase 'uint32':\tcase 'uint':\t return [ dataview.getUint32( at, little_endian ), 4 ];\n\t\t\t\t\tcase 'float32': case 'float':\t return [ dataview.getFloat32( at, little_endian ), 4 ];\n\t\t\t\t\tcase 'float64': case 'double': return [ dataview.getFloat64( at, little_endian ), 8 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction binaryReadElement( dataview, at, properties, little_endian ) {\n\n\t\t\t\tvar element = {};\n\t\t\t\tvar result, read = 0;\n\n\t\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\t\tvar list = [];\n\n\t\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].countType, little_endian );\n\t\t\t\t\t\tvar n = result[ 0 ];\n\t\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].itemType, little_endian );\n\t\t\t\t\t\t\tlist.push( result[ 0 ] );\n\t\t\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].type, little_endian );\n\t\t\t\t\t\telement[ properties[ i ].name ] = result[ 0 ];\n\t\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn [ element, read ];\n\n\t\t\t}\n\n\t\t\tfunction parseBinary( data, header ) {\n\n\t\t\t\tvar buffer = {\n\t\t\t\t\tindices: [],\n\t\t\t\t\tvertices: [],\n\t\t\t\t\tnormals: [],\n\t\t\t\t\tuvs: [],\n\t\t\t\t\tfaceVertexUvs: [],\n\t\t\t\t\tcolors: []\n\t\t\t\t};\n\n\t\t\t\tvar little_endian = ( header.format === 'binary_little_endian' );\n\t\t\t\tvar body = new DataView( data, header.headerLength );\n\t\t\t\tvar result, loc = 0;\n\n\t\t\t\tfor ( var currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {\n\n\t\t\t\t\tfor ( var currentElementCount = 0; currentElementCount < header.elements[ currentElement ].count; currentElementCount ++ ) {\n\n\t\t\t\t\t\tresult = binaryReadElement( body, loc, header.elements[ currentElement ].properties, little_endian );\n\t\t\t\t\t\tloc += result[ 1 ];\n\t\t\t\t\t\tvar element = result[ 0 ];\n\n\t\t\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn postProcess( buffer );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar geometry;\n\t\t\tvar scope = this;\n\n\t\t\tif ( data instanceof ArrayBuffer ) {\n\n\t\t\t\tvar text = THREE.LoaderUtils.decodeText( new Uint8Array( data ) );\n\t\t\t\tvar header = parseHeader( text );\n\n\t\t\t\tgeometry = header.format === 'ascii' ? parseASCII( text, header ) : parseBinary( data, header );\n\n\t\t\t} else {\n\n\t\t\t\tgeometry = parseASCII( data, parseHeader( data ) );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.PLYLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/PRWMLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Kevin Chapelier / https://github.com/kchapelier\n\t * See https://github.com/kchapelier/PRWM for more informations about this file format\n\t */\n\n\tTHREE.PRWMLoader = ( function () {\n\n\t\tvar bigEndianPlatform = null;\n\n\t\t/**\n\t\t * Check if the endianness of the platform is big-endian (most significant bit first)\n\t\t * @returns {boolean} True if big-endian, false if little-endian\n\t\t */\n\t\tfunction isBigEndianPlatform() {\n\n\t\t\tif ( bigEndianPlatform === null ) {\n\n\t\t\t\tvar buffer = new ArrayBuffer( 2 ),\n\t\t\t\t\tuint8Array = new Uint8Array( buffer ),\n\t\t\t\t\tuint16Array = new Uint16Array( buffer );\n\n\t\t\t\tuint8Array[ 0 ] = 0xAA; // set first byte\n\t\t\t\tuint8Array[ 1 ] = 0xBB; // set second byte\n\t\t\t\tbigEndianPlatform = ( uint16Array[ 0 ] === 0xAABB );\n\n\t\t\t}\n\n\t\t\treturn bigEndianPlatform;\n\n\t\t}\n\n\t\t// match the values defined in the spec to the TypedArray types\n\t\tvar InvertedEncodingTypes = [\n\t\t\tnull,\n\t\t\tFloat32Array,\n\t\t\tnull,\n\t\t\tInt8Array,\n\t\t\tInt16Array,\n\t\t\tnull,\n\t\t\tInt32Array,\n\t\t\tUint8Array,\n\t\t\tUint16Array,\n\t\t\tnull,\n\t\t\tUint32Array\n\t\t];\n\n\t\t// define the method to use on a DataView, corresponding the TypedArray type\n\t\tvar getMethods = {\n\t\t\tUint16Array: 'getUint16',\n\t\t\tUint32Array: 'getUint32',\n\t\t\tInt16Array: 'getInt16',\n\t\t\tInt32Array: 'getInt32',\n\t\t\tFloat32Array: 'getFloat32',\n\t\t\tFloat64Array: 'getFloat64'\n\t\t};\n\n\n\t\tfunction copyFromBuffer( sourceArrayBuffer, viewType, position, length, fromBigEndian ) {\n\n\t\t\tvar bytesPerElement = viewType.BYTES_PER_ELEMENT,\n\t\t\t\tresult;\n\n\t\t\tif ( fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1 ) {\n\n\t\t\t\tresult = new viewType( sourceArrayBuffer, position, length );\n\n\t\t\t} else {\n\n\t\t\t\tvar readView = new DataView( sourceArrayBuffer, position, length * bytesPerElement ),\n\t\t\t\t\tgetMethod = getMethods[ viewType.name ],\n\t\t\t\t\tlittleEndian = ! fromBigEndian,\n\t\t\t\t\ti = 0;\n\n\t\t\t\tresult = new viewType( length );\n\n\t\t\t\tfor ( ; i < length; i ++ ) {\n\n\t\t\t\t\tresult[ i ] = readView[ getMethod ]( i * bytesPerElement, littleEndian );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\n\t\tfunction decodePrwm( buffer ) {\n\n\t\t\tvar array = new Uint8Array( buffer ),\n\t\t\t\tversion = array[ 0 ],\n\t\t\t\tflags = array[ 1 ],\n\t\t\t\tindexedGeometry = !! ( flags >> 7 & 0x01 ),\n\t\t\t\tindicesType = flags >> 6 & 0x01,\n\t\t\t\tbigEndian = ( flags >> 5 & 0x01 ) === 1,\n\t\t\t\tattributesNumber = flags & 0x1F,\n\t\t\t\tvaluesNumber = 0,\n\t\t\t\tindicesNumber = 0;\n\n\t\t\tif ( bigEndian ) {\n\n\t\t\t\tvaluesNumber = ( array[ 2 ] << 16 ) + ( array[ 3 ] << 8 ) + array[ 4 ];\n\t\t\t\tindicesNumber = ( array[ 5 ] << 16 ) + ( array[ 6 ] << 8 ) + array[ 7 ];\n\n\t\t\t} else {\n\n\t\t\t\tvaluesNumber = array[ 2 ] + ( array[ 3 ] << 8 ) + ( array[ 4 ] << 16 );\n\t\t\t\tindicesNumber = array[ 5 ] + ( array[ 6 ] << 8 ) + ( array[ 7 ] << 16 );\n\n\t\t\t}\n\n\t\t\t/** PRELIMINARY CHECKS **/\n\n\t\t\tif ( version === 0 ) {\n\n\t\t\t\tthrow new Error( 'PRWM decoder: Invalid format version: 0' );\n\n\t\t\t} else if ( version !== 1 ) {\n\n\t\t\t\tthrow new Error( 'PRWM decoder: Unsupported format version: ' + version );\n\n\t\t\t}\n\n\t\t\tif ( ! indexedGeometry ) {\n\n\t\t\t\tif ( indicesType !== 0 ) {\n\n\t\t\t\t\tthrow new Error( 'PRWM decoder: Indices type must be set to 0 for non-indexed geometries' );\n\n\t\t\t\t} else if ( indicesNumber !== 0 ) {\n\n\t\t\t\t\tthrow new Error( 'PRWM decoder: Number of indices must be set to 0 for non-indexed geometries' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/** PARSING **/\n\n\t\t\tvar pos = 8;\n\n\t\t\tvar attributes = {},\n\t\t\t\tattributeName,\n\t\t\t\tchar,\n\t\t\t\tattributeType,\n\t\t\t\tcardinality,\n\t\t\t\tencodingType,\n\t\t\t\tarrayType,\n\t\t\t\tvalues,\n\t\t\t\tindices,\n\t\t\t\ti;\n\n\t\t\tfor ( i = 0; i < attributesNumber; i ++ ) {\n\n\t\t\t\tattributeName = '';\n\n\t\t\t\twhile ( pos < array.length ) {\n\n\t\t\t\t\tchar = array[ pos ];\n\t\t\t\t\tpos ++;\n\n\t\t\t\t\tif ( char === 0 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tattributeName += String.fromCharCode( char );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tflags = array[ pos ];\n\n\t\t\t\tattributeType = flags >> 7 & 0x01;\n\t\t\t\tcardinality = ( flags >> 4 & 0x03 ) + 1;\n\t\t\t\tencodingType = flags & 0x0F;\n\t\t\t\tarrayType = InvertedEncodingTypes[ encodingType ];\n\n\t\t\t\tpos ++;\n\n\t\t\t\t// padding to next multiple of 4\n\t\t\t\tpos = Math.ceil( pos / 4 ) * 4;\n\n\t\t\t\tvalues = copyFromBuffer( buffer, arrayType, pos, cardinality * valuesNumber, bigEndian );\n\n\t\t\t\tpos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n\n\t\t\t\tattributes[ attributeName ] = {\n\t\t\t\t\ttype: attributeType,\n\t\t\t\t\tcardinality: cardinality,\n\t\t\t\t\tvalues: values\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tpos = Math.ceil( pos / 4 ) * 4;\n\n\t\t\tindices = null;\n\n\t\t\tif ( indexedGeometry ) {\n\n\t\t\t\tindices = copyFromBuffer(\n\t\t\t\t\tbuffer,\n\t\t\t\t\tindicesType === 1 ? Uint32Array : Uint16Array,\n\t\t\t\t\tpos,\n\t\t\t\t\tindicesNumber,\n\t\t\t\t\tbigEndian\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tversion: version,\n\t\t\t\tattributes: attributes,\n\t\t\t\tindices: indices\n\t\t\t};\n\n\t\t}\n\n\t\t// Define the public interface\n\n\t\tfunction PRWMLoader( manager ) {\n\n\t\t\tTHREE.Loader.call( this, manager );\n\n\t\t}\n\n\t\tPRWMLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\t\tconstructor: PRWMLoader,\n\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\t\tloader.setPath( scope.path );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\t\turl = url.replace( /\\*/g, isBigEndianPlatform() ? 'be' : 'le' );\n\n\t\t\t\tloader.load( url, function ( arrayBuffer ) {\n\n\t\t\t\t\tonLoad( scope.parse( arrayBuffer ) );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t},\n\n\t\t\tparse: function ( arrayBuffer ) {\n\n\t\t\t\tvar data = decodePrwm( arrayBuffer ),\n\t\t\t\t\tattributesKey = Object.keys( data.attributes ),\n\t\t\t\t\tbufferGeometry = new THREE.BufferGeometry(),\n\t\t\t\t\tattribute,\n\t\t\t\t\ti;\n\n\t\t\t\tfor ( i = 0; i < attributesKey.length; i ++ ) {\n\n\t\t\t\t\tattribute = data.attributes[ attributesKey[ i ] ];\n\t\t\t\t\tbufferGeometry.setAttribute( attributesKey[ i ], new THREE.BufferAttribute( attribute.values, attribute.cardinality, attribute.normalized ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.indices !== null ) {\n\n\t\t\t\t\tbufferGeometry.setIndex( new THREE.BufferAttribute( data.indices, 1 ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn bufferGeometry;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tPRWMLoader.isBigEndianPlatform = function () {\n\n\t\t\treturn isBigEndianPlatform();\n\n\t\t};\n\n\t\treturn PRWMLoader;\n\n\t} )();\n\t\n\treturn THREE.PRWMLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/STLLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author aleeper / http://adamleeper.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author gero3 / https://github.com/gero3\n\t * @author Mugen87 / https://github.com/Mugen87\n\t * @author neverhood311 / https://github.com/neverhood311\n\t *\n\t * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n\t *\n\t * Supports both binary and ASCII encoded files, with automatic detection of type.\n\t *\n\t * The loader returns a non-indexed buffer geometry.\n\t *\n\t * Limitations:\n\t *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n\t *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n\t *  ASCII decoding assumes file is UTF-8.\n\t *\n\t * Usage:\n\t *  var loader = new THREE.STLLoader();\n\t *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n\t *    scene.add( new THREE.Mesh( geometry ) );\n\t *  });\n\t *\n\t * For binary STLs geometry might contain colors for vertices. To use it:\n\t *  // use the same code to load STL as above\n\t *  if (geometry.hasColors) {\n\t *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });\n\t *  } else { .... }\n\t *  var mesh = new THREE.Mesh( geometry, material );\n\t *\n\t * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n\t * Groups can be used to assign a different color by defining an array of materials with the same length of\n\t * geometry.groups and passing it to the Mesh constructor:\n\t *\n\t * var mesh = new THREE.Mesh( geometry, material );\n\t *\n\t * For example:\n\t *\n\t *  var materials = [];\n\t *  var nGeometryGroups = geometry.groups.length;\n\t *\n\t *  var colorMap = ...; // Some logic to index colors.\n\t *\n\t *  for (var i = 0; i < nGeometryGroups; i++) {\n\t *\n\t *\t\tvar material = new THREE.MeshPhongMaterial({\n\t *\t\t\tcolor: colorMap[i],\n\t *\t\t\twireframe: false\n\t *\t\t});\n\t *\n\t *  }\n\t *\n\t *  materials.push(material);\n\t *  var mesh = new THREE.Mesh(geometry, materials);\n\t */\n\n\n\tTHREE.STLLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.STLLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.STLLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t\t} catch ( exception ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( exception );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data ) {\n\n\t\t\tfunction isBinary( data ) {\n\n\t\t\t\tvar expect, face_size, n_faces, reader;\n\t\t\t\treader = new DataView( data );\n\t\t\t\tface_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\n\t\t\t\tn_faces = reader.getUint32( 80, true );\n\t\t\t\texpect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\n\n\t\t\t\tif ( expect === reader.byteLength ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n\t\t\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n\t\t\t\t// Search for \"solid\" to start anywhere after those prefixes.\n\n\t\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\t\t\t\tvar solid = [ 115, 111, 108, 105, 100 ];\n\n\t\t\t\tfor ( var off = 0; off < 5; off ++ ) {\n\n\t\t\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n\t\t\t\t\tif ( matchDataViewAt( solid, reader, off ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tfunction matchDataViewAt( query, reader, offset ) {\n\n\t\t\t\t// Check if each byte in query matches the corresponding byte from the current offset\n\n\t\t\t\tfor ( var i = 0, il = query.length; i < il; i ++ ) {\n\n\t\t\t\t\tif ( query[ i ] !== reader.getUint8( offset + i, false ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tfunction parseBinary( data ) {\n\n\t\t\t\tvar reader = new DataView( data );\n\t\t\t\tvar faces = reader.getUint32( 80, true );\n\n\t\t\t\tvar r, g, b, hasColors = false, colors;\n\t\t\t\tvar defaultR, defaultG, defaultB, alpha;\n\n\t\t\t\t// process STL header\n\t\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\n\t\t\t\tfor ( var index = 0; index < 80 - 10; index ++ ) {\n\n\t\t\t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&\n\t\t\t\t\t\t( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&\n\t\t\t\t\t\t( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {\n\n\t\t\t\t\t\thasColors = true;\n\t\t\t\t\t\tcolors = new Float32Array( faces * 3 * 3 );\n\n\t\t\t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\n\t\t\t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\n\t\t\t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\n\t\t\t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar dataOffset = 84;\n\t\t\t\tvar faceLength = 12 * 4 + 2;\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\tvar vertices = new Float32Array( faces * 3 * 3 );\n\t\t\t\tvar normals = new Float32Array( faces * 3 * 3 );\n\n\t\t\t\tfor ( var face = 0; face < faces; face ++ ) {\n\n\t\t\t\t\tvar start = dataOffset + face * faceLength;\n\t\t\t\t\tvar normalX = reader.getFloat32( start, true );\n\t\t\t\t\tvar normalY = reader.getFloat32( start + 4, true );\n\t\t\t\t\tvar normalZ = reader.getFloat32( start + 8, true );\n\n\t\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\t\tvar packedColor = reader.getUint16( start + 48, true );\n\n\t\t\t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\n\n\t\t\t\t\t\t\t// facet has its own unique color\n\n\t\t\t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\n\t\t\t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\n\t\t\t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tr = defaultR;\n\t\t\t\t\t\t\tg = defaultG;\n\t\t\t\t\t\t\tb = defaultB;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 1; i <= 3; i ++ ) {\n\n\t\t\t\t\t\tvar vertexstart = start + i * 12;\n\t\t\t\t\t\tvar componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );\n\n\t\t\t\t\t\tvertices[ componentIdx ] = reader.getFloat32( vertexstart, true );\n\t\t\t\t\t\tvertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );\n\t\t\t\t\t\tvertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );\n\n\t\t\t\t\t\tnormals[ componentIdx ] = normalX;\n\t\t\t\t\t\tnormals[ componentIdx + 1 ] = normalY;\n\t\t\t\t\t\tnormals[ componentIdx + 2 ] = normalZ;\n\n\t\t\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\t\t\tcolors[ componentIdx ] = r;\n\t\t\t\t\t\t\tcolors[ componentIdx + 1 ] = g;\n\t\t\t\t\t\t\tcolors[ componentIdx + 2 ] = b;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\n\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\n\t\t\t\t\tgeometry.hasColors = true;\n\t\t\t\t\tgeometry.alpha = alpha;\n\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction parseASCII( data ) {\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tvar patternSolid = /solid([\\s\\S]*?)endsolid/g;\n\t\t\t\tvar patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\t\t\tvar faceCounter = 0;\n\n\t\t\t\tvar patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\t\t\tvar patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );\n\t\t\t\tvar patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );\n\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar normals = [];\n\n\t\t\t\tvar normal = new THREE.Vector3();\n\n\t\t\t\tvar result;\n\n\t\t\t\tvar groupCount = 0;\n\t\t\t\tvar startVertex = 0;\n\t\t\t\tvar endVertex = 0;\n\n\t\t\t\twhile ( ( result = patternSolid.exec( data ) ) !== null ) {\n\n\t\t\t\t\tstartVertex = endVertex;\n\n\t\t\t\t\tvar solid = result[ 0 ];\n\n\t\t\t\t\twhile ( ( result = patternFace.exec( solid ) ) !== null ) {\n\n\t\t\t\t\t\tvar vertexCountPerFace = 0;\n\t\t\t\t\t\tvar normalCountPerFace = 0;\n\n\t\t\t\t\t\tvar text = result[ 0 ];\n\n\t\t\t\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\t\tnormal.x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\tnormal.y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\tnormal.z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\tnormalCountPerFace ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\n\t\t\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\t\t\t\t\t\tvertexCountPerFace ++;\n\t\t\t\t\t\t\tendVertex ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// every face have to own ONE valid normal\n\n\t\t\t\t\t\tif ( normalCountPerFace !== 1 ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// each face have to own THREE valid vertices\n\n\t\t\t\t\t\tif ( vertexCountPerFace !== 3 ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfaceCounter ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar start = startVertex;\n\t\t\t\t\tvar count = endVertex - startVertex;\n\n\t\t\t\t\tgeometry.addGroup( start, count, groupCount );\n\t\t\t\t\tgroupCount ++;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction ensureString( buffer ) {\n\n\t\t\t\tif ( typeof buffer !== 'string' ) {\n\n\t\t\t\t\treturn THREE.LoaderUtils.decodeText( new Uint8Array( buffer ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn buffer;\n\n\t\t\t}\n\n\t\t\tfunction ensureBinary( buffer ) {\n\n\t\t\t\tif ( typeof buffer === 'string' ) {\n\n\t\t\t\t\tvar array_buffer = new Uint8Array( buffer.length );\n\t\t\t\t\tfor ( var i = 0; i < buffer.length; i ++ ) {\n\n\t\t\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn array_buffer.buffer || array_buffer;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn buffer;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tvar binData = ensureBinary( data );\n\n\t\t\treturn isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.STLLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/SVGLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author zz85 / http://joshuakoo.com/\n\t * @author yomboprime / https://yombo.org\n\t */\n\n\tTHREE.SVGLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\t// Default dots per inch\n\t\tthis.defaultDPI = 90;\n\n\t\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\t\tthis.defaultUnit = \"px\";\n\n\t};\n\n\tTHREE.SVGLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.SVGLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( text ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tfunction parseNode( node, style ) {\n\n\t\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\t\tvar transform = getNodeTransform( node );\n\n\t\t\t\tvar path = null;\n\n\t\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\t\tcase 'svg':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'g':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'path':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rect':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polygon':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polyline':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'circle':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ellipse':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'line':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( node );\n\n\t\t\t\t}\n\n\t\t\t\tif ( path ) {\n\n\t\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\t\tpaths.push( path );\n\n\t\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t\t}\n\n\t\t\t\tvar nodes = node.childNodes;\n\n\t\t\t\tfor ( var i = 0; i < nodes.length; i ++ ) {\n\n\t\t\t\t\tparseNode( nodes[ i ], style );\n\n\t\t\t\t}\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\ttransformStack.pop();\n\n\t\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parsePathNode( node ) {\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\n\t\t\t\tvar point = new THREE.Vector2();\n\t\t\t\tvar control = new THREE.Vector2();\n\n\t\t\t\tvar firstPoint = new THREE.Vector2();\n\t\t\t\tvar isFirstPoint = true;\n\t\t\t\tvar doSetFirstPoint = false;\n\n\t\t\t\tvar d = node.getAttribute( 'd' );\n\n\t\t\t\t// console.log( d );\n\n\t\t\t\tvar commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\t\tfor ( var i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar command = commands[ i ];\n\n\t\t\t\t\tvar type = command.charAt( 0 );\n\t\t\t\t\tvar data = command.substr( 1 ).trim();\n\n\t\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'M':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'H':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'V':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'C':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'S':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'T':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'm':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'h':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 's':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'q':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 't':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'a':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Z':\n\t\t\t\t\t\tcase 'z':\n\t\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t\t * From\n\t\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t\t * To\n\t\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t\t */\n\n\t\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t\t// Ensure radii are positive\n\t\t\t\trx = Math.abs( rx );\n\t\t\t\try = Math.abs( ry );\n\n\t\t\t\t// Compute (x1′, y1′)\n\t\t\t\tvar dx2 = ( start.x - end.x ) / 2.0;\n\t\t\t\tvar dy2 = ( start.y - end.y ) / 2.0;\n\t\t\t\tvar x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\t\tvar y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t\t// Compute (cx′, cy′)\n\t\t\t\tvar rxs = rx * rx;\n\t\t\t\tvar rys = ry * ry;\n\t\t\t\tvar x1ps = x1p * x1p;\n\t\t\t\tvar y1ps = y1p * y1p;\n\n\t\t\t\t// Ensure radii are large enough\n\t\t\t\tvar cr = x1ps / rxs + y1ps / rys;\n\n\t\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\t\tvar s = Math.sqrt( cr );\n\t\t\t\t\trx = s * rx;\n\t\t\t\t\try = s * ry;\n\t\t\t\t\trxs = rx * rx;\n\t\t\t\t\trys = ry * ry;\n\n\t\t\t\t}\n\n\t\t\t\tvar dq = ( rxs * y1ps + rys * x1ps );\n\t\t\t\tvar pq = ( rxs * rys - dq ) / dq;\n\t\t\t\tvar q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\t\tvar cxp = q * rx * y1p / ry;\n\t\t\t\tvar cyp = - q * ry * x1p / rx;\n\n\t\t\t\t// Step 3: Compute (cx, cy) from (cx′, cy′)\n\t\t\t\tvar cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\t\tvar cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t\t// Step 4: Compute θ1 and Δθ\n\t\t\t\tvar theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\t\tvar delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t\t}\n\n\t\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\t\tvar dot = ux * vx + uy * vy;\n\t\t\t\tvar len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\t\tvar ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\t\treturn ang;\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t\t*/\n\t\t\tfunction parseRectNode( node ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\t\t\t\tvar w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\t\tvar h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\t\t\t\tpath.moveTo( x + 2 * rx, y );\n\t\t\t\tpath.lineTo( x + w - 2 * rx, y );\n\t\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry );\n\t\t\t\tpath.lineTo( x + w, y + h - 2 * ry );\n\t\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h );\n\t\t\t\tpath.lineTo( x + 2 * rx, y + h );\n\n\t\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\t\tpath.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );\n\n\t\t\t\t}\n\n\t\t\t\tpath.lineTo( x, y + 2 * ry );\n\n\t\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\t\tpath.bezierCurveTo( x, y, x, y, x + 2 * rx, y );\n\n\t\t\t\t}\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\tfunction parsePolygonNode( node ) {\n\n\t\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\n\t\t\t\tvar index = 0;\n\n\t\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\tfunction parsePolylineNode( node ) {\n\n\t\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\n\t\t\t\tvar index = 0;\n\n\t\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\tfunction parseCircleNode( node ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\t\tvar r = parseFloatWithUnits( node.getAttribute( 'r' ) );\n\n\t\t\t\tvar subpath = new THREE.Path();\n\t\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\t\t\t\tpath.subPaths.push( subpath );\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\tfunction parseEllipseNode( node ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) );\n\t\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) );\n\n\t\t\t\tvar subpath = new THREE.Path();\n\t\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\t\t\t\tpath.subPaths.push( subpath );\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\tfunction parseLineNode( node ) {\n\n\t\t\t\tvar x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) );\n\t\t\t\tvar y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) );\n\t\t\t\tvar x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) );\n\t\t\t\tvar y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) );\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\t\t\t\tpath.moveTo( x1, y1 );\n\t\t\t\tpath.lineTo( x2, y2 );\n\t\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction parseStyle( node, style ) {\n\n\t\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\t\treturn v;\n\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t\t}\n\n\t\t\t\tfunction clamp( v ) {\n\n\t\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tfunction positive( v ) {\n\n\t\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t\t}\n\n\t\t\t\taddStyle( 'fill', 'fill' );\n\t\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\n\t\t\t\treturn style;\n\n\t\t\t}\n\n\t\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\t\tfunction getReflection( a, b ) {\n\n\t\t\t\treturn a - ( b - a );\n\n\t\t\t}\n\n\t\t\tfunction parseFloats( string ) {\n\n\t\t\t\tvar array = string.split( /[\\s,]+|(?=\\s?[+\\-])/ );\n\n\t\t\t\tfor ( var i = 0; i < array.length; i ++ ) {\n\n\t\t\t\t\tvar number = array[ i ];\n\n\t\t\t\t\t// Handle values like 48.6037.7.8\n\t\t\t\t\t// TODO Find a regex for this\n\n\t\t\t\t\tif ( number.indexOf( '.' ) !== number.lastIndexOf( '.' ) ) {\n\n\t\t\t\t\t\tvar split = number.split( '.' );\n\n\t\t\t\t\t\tfor ( var s = 2; s < split.length; s ++ ) {\n\n\t\t\t\t\t\t\tarray.splice( i + s - 1, 0, '0.' + split[ s ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tarray[ i ] = parseFloatWithUnits( number );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\n\t\t\t}\n\n\t\t\t// Units\n\n\t\t\tvar units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\t\tvar unitConversion = {\n\n\t\t\t\t\"mm\": {\n\t\t\t\t\t\"mm\": 1,\n\t\t\t\t\t\"cm\": 0.1,\n\t\t\t\t\t\"in\": 1 / 25.4,\n\t\t\t\t\t\"pt\": 72 / 25.4,\n\t\t\t\t\t\"pc\": 6 / 25.4,\n\t\t\t\t\t\"px\": - 1\n\t\t\t\t},\n\t\t\t\t\"cm\": {\n\t\t\t\t\t\"mm\": 10,\n\t\t\t\t\t\"cm\": 1,\n\t\t\t\t\t\"in\": 1 / 2.54,\n\t\t\t\t\t\"pt\": 72 / 2.54,\n\t\t\t\t\t\"pc\": 6 / 2.54,\n\t\t\t\t\t\"px\": - 1\n\t\t\t\t},\n\t\t\t\t\"in\": {\n\t\t\t\t\t\"mm\": 25.4,\n\t\t\t\t\t\"cm\": 2.54,\n\t\t\t\t\t\"in\": 1,\n\t\t\t\t\t\"pt\": 72,\n\t\t\t\t\t\"pc\": 6,\n\t\t\t\t\t\"px\": - 1\n\t\t\t\t},\n\t\t\t\t\"pt\": {\n\t\t\t\t\t\"mm\": 25.4 / 72,\n\t\t\t\t\t\"cm\": 2.54 / 72,\n\t\t\t\t\t\"in\": 1 / 72,\n\t\t\t\t\t\"pt\": 1,\n\t\t\t\t\t\"pc\": 6 / 72,\n\t\t\t\t\t\"px\": - 1\n\t\t\t\t},\n\t\t\t\t\"pc\": {\n\t\t\t\t\t\"mm\": 25.4 / 6,\n\t\t\t\t\t\"cm\": 2.54 / 6,\n\t\t\t\t\t\"in\": 1 / 6,\n\t\t\t\t\t\"pt\": 72 / 6,\n\t\t\t\t\t\"pc\": 1,\n\t\t\t\t\t\"px\": - 1\n\t\t\t\t},\n\t\t\t\t\"px\": {\n\t\t\t\t\t\"px\": 1\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\t\tvar theUnit = \"px\";\n\n\t\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\t\tfor ( var i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\t\tvar u = units[ i ];\n\n\t\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar scale = undefined;\n\n\t\t\t\tif ( theUnit === \"px\" && scope.defaultUnit !== \"px\" ) {\n\n\t\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\t\tscale = unitConversion[ \"in\" ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\t\tscale = unitConversion[ theUnit ][ \"in\" ] * scope.defaultDPI;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn scale * parseFloat( string );\n\n\t\t\t}\n\n\t\t\t// Transforms\n\n\t\t\tfunction getNodeTransform( node ) {\n\n\t\t\t\tif ( ! node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tvar transform = parseNodeTransform( node );\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tcurrentTransform.copy( transform );\n\t\t\t\ttransformStack.push( transform );\n\n\t\t\t\treturn transform;\n\n\t\t\t}\n\n\t\t\tfunction parseNodeTransform( node ) {\n\n\t\t\t\tvar transform = new THREE.Matrix3();\n\t\t\t\tvar currentTransform = tempTransform0;\n\t\t\t\tvar transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tvar transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tvar openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tvar closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tvar transformType = transformText.substr( 0, openParPos );\n\n\t\t\t\t\t\tvar array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase \"translate\":\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tvar ty = tx;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"rotate\":\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar angle = 0;\n\t\t\t\t\t\t\t\t\tvar cx = 0;\n\t\t\t\t\t\t\t\t\tvar cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"scale\":\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tvar scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"skewX\":\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"skewY\":\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"matrix\":\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t\treturn transform;\n\n\t\t\t}\n\n\t\t\tfunction transformPath( path, m ) {\n\n\t\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t\t}\n\n\t\t\t\tvar isRotated = isTransformRotated( m );\n\n\t\t\t\tvar subPaths = path.subPaths;\n\n\t\t\t\tfor ( var i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\t\tvar subPath = subPaths[ i ];\n\t\t\t\t\tvar curves = subPath.curves;\n\n\t\t\t\t\tfor ( var j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\t\tvar curve = curves[ j ];\n\n\t\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( \"SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.\" );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction isTransformRotated( m ) {\n\n\t\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t\t}\n\n\t\t\tfunction getTransformScaleX( m ) {\n\n\t\t\t\tvar te = m.elements;\n\t\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t\t}\n\n\t\t\tfunction getTransformScaleY( m ) {\n\n\t\t\t\tvar te = m.elements;\n\t\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar paths = [];\n\n\t\t\tvar transformStack = [];\n\n\t\t\tvar tempTransform0 = new THREE.Matrix3();\n\t\t\tvar tempTransform1 = new THREE.Matrix3();\n\t\t\tvar tempTransform2 = new THREE.Matrix3();\n\t\t\tvar tempTransform3 = new THREE.Matrix3();\n\t\t\tvar tempV2 = new THREE.Vector2();\n\t\t\tvar tempV3 = new THREE.Vector3();\n\n\t\t\tvar currentTransform = new THREE.Matrix3();\n\n\t\t\tvar xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\t\tparseNode( xml.documentElement, {\n\t\t\t\tfill: '#000',\n\t\t\t\tfillOpacity: 1,\n\t\t\t\tstrokeOpacity: 1,\n\t\t\t\tstrokeWidth: 1,\n\t\t\t\tstrokeLineJoin: 'miter',\n\t\t\t\tstrokeLineCap: 'butt',\n\t\t\t\tstrokeMiterLimit: 4\n\t\t\t} );\n\n\t\t\tvar data = { paths: paths, xml: xml.documentElement };\n\n\t\t\t// console.log( paths );\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\tTHREE.SVGLoader.getStrokeStyle = function ( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t\t// Param width: Stroke width\n\t\t// Param color: As returned by THREE.Color.getStyle()\n\t\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t\t// Returns style object\n\n\t\twidth = width !== undefined ? width : 1;\n\t\tcolor = color !== undefined ? color : '#000';\n\t\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\t\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\t\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\t\treturn {\n\t\t\tstrokeColor: color,\n\t\t\tstrokeWidth: width,\n\t\t\tstrokeLineJoin: lineJoin,\n\t\t\tstrokeLineCap: lineCap,\n\t\t\tstrokeMiterLimit: miterLimit\n\t\t};\n\n\t};\n\n\tTHREE.SVGLoader.pointsToStroke = function ( points, style, arcDivisions, minDistance ) {\n\n\t\t// Generates a stroke with some witdh around the given path.\n\t\t// The path can be open or closed (last point equals to first point)\n\t\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\tif ( THREE.SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n\t\tgeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );\n\n\t\treturn geometry;\n\n\t};\n\n\tTHREE.SVGLoader.pointsToStrokeWithBuffers = function () {\n\n\t\tvar tempV2_1 = new THREE.Vector2();\n\t\tvar tempV2_2 = new THREE.Vector2();\n\t\tvar tempV2_3 = new THREE.Vector2();\n\t\tvar tempV2_4 = new THREE.Vector2();\n\t\tvar tempV2_5 = new THREE.Vector2();\n\t\tvar tempV2_6 = new THREE.Vector2();\n\t\tvar tempV2_7 = new THREE.Vector2();\n\t\tvar lastPointL = new THREE.Vector2();\n\t\tvar lastPointR = new THREE.Vector2();\n\t\tvar point0L = new THREE.Vector2();\n\t\tvar point0R = new THREE.Vector2();\n\t\tvar currentPointL = new THREE.Vector2();\n\t\tvar currentPointR = new THREE.Vector2();\n\t\tvar nextPointL = new THREE.Vector2();\n\t\tvar nextPointR = new THREE.Vector2();\n\t\tvar innerPoint = new THREE.Vector2();\n\t\tvar outerPoint = new THREE.Vector2();\n\n\t\treturn function ( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t\t// This function can be called to update existing arrays or buffers.\n\t\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t\t// First ensure there are no duplicated points\n\t\t\tpoints = removeDuplicatedPoints( points );\n\n\t\t\tvar numPoints = points.length;\n\n\t\t\tif ( numPoints < 2 ) return 0;\n\n\t\t\tvar isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\t\tvar currentPoint;\n\t\t\tvar previousPoint = points[ 0 ];\n\t\t\tvar nextPoint;\n\n\t\t\tvar strokeWidth2 = style.strokeWidth / 2;\n\n\t\t\tvar deltaU = 1 / ( numPoints - 1 );\n\t\t\tvar u0 = 0;\n\n\t\t\tvar innerSideModified;\n\t\t\tvar joinIsOnLeftSide;\n\t\t\tvar isMiter;\n\t\t\tvar initialJoinIsOnLeftSide = false;\n\n\t\t\tvar numVertices = 0;\n\t\t\tvar currentCoordinate = vertexOffset * 3;\n\t\t\tvar currentCoordinateUV = vertexOffset * 2;\n\n\t\t\t// Get initial left and right stroke points\n\t\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\t\tpoint0L.copy( lastPointL );\n\t\t\tpoint0R.copy( lastPointR );\n\n\t\t\tfor ( var iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t\t// Get next point\n\t\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t\t}\n\n\t\t\t\t// Normal of previous segment in tempV2_1\n\t\t\t\tvar normal1 = tempV2_1;\n\t\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tvar u1 = u0 + deltaU;\n\n\t\t\t\tinnerSideModified = false;\n\n\t\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\t\ttempV2_3.normalize();\n\t\t\t\t\tvar dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t\t// If path is straight, don't create join\n\t\t\t\t\tif ( dot !== 0 ) {\n\n\t\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\t\tvar miterSide = strokeWidth2 / dot;\n\t\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\t\tvar miterLength2 = tempV2_5.length();\n\t\t\t\t\t\tvar segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\t\tvar segmentLengthNext = tempV2_6.length();\n\t\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tvar miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t\t// Start line endcap\n\t\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t\t}\n\n\t\t\t\t// Increment loop variables\n\n\t\t\t\tu0 = u1;\n\n\t\t\t\tpreviousPoint = currentPoint;\n\n\t\t\t\tlastPointL.copy( nextPointL );\n\t\t\t\tlastPointR.copy( nextPointR );\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed ) {\n\n\t\t\t\t// Ending line endcap\n\t\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\t\tvar lastOuter = outerPoint;\n\t\t\t\tvar lastInner = innerPoint;\n\n\t\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\t\tlastOuter = innerPoint;\n\t\t\t\t\tlastInner = outerPoint;\n\n\t\t\t\t}\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn numVertices;\n\n\t\t\t// -- End of algorithm\n\n\t\t\t// -- Functions\n\n\t\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\t\tresult.subVectors( p2, p1 );\n\t\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t\t}\n\n\t\t\tfunction addVertex( position, u, v ) {\n\n\t\t\t\tif ( vertices ) {\n\n\t\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\t\tif ( normals ) {\n\n\t\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnumVertices += 3;\n\n\t\t\t}\n\n\t\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\t\tvar angle = Math.PI;\n\t\t\t\tvar dot = tempV2_1.dot( tempV2_2 );\n\t\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\t\tangle /= arcDivisions;\n\n\t\t\t\ttempV2_3.copy( p1 );\n\n\t\t\t\tfor ( var i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t\t}\n\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( p2, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t}\n\n\t\t\tfunction makeSegmentTriangles() {\n\n\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t\t}\n\n\t\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t\t// param center: End point of the path\n\t\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'square':\n\n\t\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t\tvar vl = vertices.length;\n\n\t\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'butt':\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t// Nothing to do here\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\t\tvar dupPoints = false;\n\t\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\t\tdupPoints = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\t\tvar newPoints = [];\n\t\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\t\treturn newPoints;\n\n\t\t\t}\n\n\t\t};\n\n\t}();\n\t\n\treturn THREE.SVGLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/TDSLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * Autodesk 3DS three.js file loader, based on lib3ds.\n\t *\n\t * Loads geometry with uv and materials basic properties with texture support.\n\t *\n\t * @author @tentone\n\t * @author @timknip\n\t * @class TDSLoader\n\t * @constructor\n\t */\n\n\tTHREE.TDSLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.debug = false;\n\n\t\tthis.group = null;\n\t\tthis.position = 0;\n\n\t\tthis.materials = [];\n\t\tthis.meshes = [];\n\n\t};\n\n\tTHREE.TDSLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.TDSLoader,\n\n\t\t/**\n\t\t * Load 3ds file from url.\n\t\t *\n\t\t * @method load\n\t\t * @param {[type]} url URL for the file.\n\t\t * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n\t\t * @param {Function} onProgress onProgress callback.\n\t\t * @param {Function} onError onError callback.\n\t\t */\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( scope.path === '' ) ? THREE.LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tloader.load( url, function ( data ) {\n\n\t\t\t\tonLoad( scope.parse( data, path ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\t/**\n\t\t * Parse arraybuffer data and load 3ds file.\n\t\t *\n\t\t * @method parse\n\t\t * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n\t\t * @param {String} path Path for external resources.\n\t\t * @return {Group} Group loaded from 3ds file.\n\t\t */\n\t\tparse: function ( arraybuffer, path ) {\n\n\t\t\tthis.group = new THREE.Group();\n\t\t\tthis.position = 0;\n\t\t\tthis.materials = [];\n\t\t\tthis.meshes = [];\n\n\t\t\tthis.readFile( arraybuffer, path );\n\n\t\t\tfor ( var i = 0; i < this.meshes.length; i ++ ) {\n\n\t\t\t\tthis.group.add( this.meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this.group;\n\n\t\t},\n\n\t\t/**\n\t\t * Decode file content to read 3ds data.\n\t\t *\n\t\t * @method readFile\n\t\t * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n\t\t * @param {String} path Path for external resources.\n\t\t */\n\t\treadFile: function ( arraybuffer, path ) {\n\n\t\t\tvar data = new DataView( arraybuffer );\n\t\t\tvar chunk = this.readChunk( data );\n\n\t\t\tif ( chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC ) {\n\n\t\t\t\tvar next = this.nextChunk( data, chunk );\n\n\t\t\t\twhile ( next !== 0 ) {\n\n\t\t\t\t\tif ( next === M3D_VERSION ) {\n\n\t\t\t\t\t\tvar version = this.readDWord( data );\n\t\t\t\t\t\tthis.debugMessage( '3DS file version: ' + version );\n\n\t\t\t\t\t} else if ( next === MDATA ) {\n\n\t\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\t\tthis.readMeshData( data, path );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.debugMessage( 'Unknown main chunk: ' + next.toString( 16 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.debugMessage( 'Parsed ' + this.meshes.length + ' meshes' );\n\n\t\t},\n\n\t\t/**\n\t\t * Read mesh data chunk.\n\t\t *\n\t\t * @method readMeshData\n\t\t * @param {Dataview} data Dataview in use.\n\t\t * @param {String} path Path for external resources.\n\t\t */\n\t\treadMeshData: function ( data, path ) {\n\n\t\t\tvar chunk = this.readChunk( data );\n\t\t\tvar next = this.nextChunk( data, chunk );\n\n\t\t\twhile ( next !== 0 ) {\n\n\t\t\t\tif ( next === MESH_VERSION ) {\n\n\t\t\t\t\tvar version = + this.readDWord( data );\n\t\t\t\t\tthis.debugMessage( 'Mesh Version: ' + version );\n\n\t\t\t\t} else if ( next === MASTER_SCALE ) {\n\n\t\t\t\t\tvar scale = this.readFloat( data );\n\t\t\t\t\tthis.debugMessage( 'Master scale: ' + scale );\n\t\t\t\t\tthis.group.scale.set( scale, scale, scale );\n\n\t\t\t\t} else if ( next === NAMED_OBJECT ) {\n\n\t\t\t\t\tthis.debugMessage( 'Named Object' );\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tthis.readNamedObject( data );\n\n\t\t\t\t} else if ( next === MAT_ENTRY ) {\n\n\t\t\t\t\tthis.debugMessage( 'Material' );\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tthis.readMaterialEntry( data, path );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( 'Unknown MDATA chunk: ' + next.toString( 16 ) );\n\n\t\t\t\t}\n\n\t\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t\t}\n\n\t\t},\n\n\t\t/**\n\t\t * Read named object chunk.\n\t\t *\n\t\t * @method readNamedObject\n\t\t * @param {Dataview} data Dataview in use.\n\t\t */\n\t\treadNamedObject: function ( data ) {\n\n\t\t\tvar chunk = this.readChunk( data );\n\t\t\tvar name = this.readString( data, 64 );\n\t\t\tchunk.cur = this.position;\n\n\t\t\tvar next = this.nextChunk( data, chunk );\n\t\t\twhile ( next !== 0 ) {\n\n\t\t\t\tif ( next === N_TRI_OBJECT ) {\n\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tvar mesh = this.readMesh( data );\n\t\t\t\t\tmesh.name = name;\n\t\t\t\t\tthis.meshes.push( mesh );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( 'Unknown named object chunk: ' + next.toString( 16 ) );\n\n\t\t\t\t}\n\n\t\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t\t}\n\n\t\t\tthis.endChunk( chunk );\n\n\t\t},\n\n\t\t/**\n\t\t * Read material data chunk and add it to the material list.\n\t\t *\n\t\t * @method readMaterialEntry\n\t\t * @param {Dataview} data Dataview in use.\n\t\t * @param {String} path Path for external resources.\n\t\t */\n\t\treadMaterialEntry: function ( data, path ) {\n\n\t\t\tvar chunk = this.readChunk( data );\n\t\t\tvar next = this.nextChunk( data, chunk );\n\t\t\tvar material = new THREE.MeshPhongMaterial();\n\n\t\t\twhile ( next !== 0 ) {\n\n\t\t\t\tif ( next === MAT_NAME ) {\n\n\t\t\t\t\tmaterial.name = this.readString( data, 64 );\n\t\t\t\t\tthis.debugMessage( '   Name: ' + material.name );\n\n\t\t\t\t} else if ( next === MAT_WIRE ) {\n\n\t\t\t\t\tthis.debugMessage( '   Wireframe' );\n\t\t\t\t\tmaterial.wireframe = true;\n\n\t\t\t\t} else if ( next === MAT_WIRE_SIZE ) {\n\n\t\t\t\t\tvar value = this.readByte( data );\n\t\t\t\t\tmaterial.wireframeLinewidth = value;\n\t\t\t\t\tthis.debugMessage( '   Wireframe Thickness: ' + value );\n\n\t\t\t\t} else if ( next === MAT_TWO_SIDE ) {\n\n\t\t\t\t\tmaterial.side = THREE.DoubleSide;\n\t\t\t\t\tthis.debugMessage( '   DoubleSided' );\n\n\t\t\t\t} else if ( next === MAT_ADDITIVE ) {\n\n\t\t\t\t\tthis.debugMessage( '   Additive Blending' );\n\t\t\t\t\tmaterial.blending = THREE.AdditiveBlending;\n\n\t\t\t\t} else if ( next === MAT_DIFFUSE ) {\n\n\t\t\t\t\tthis.debugMessage( '   Diffuse Color' );\n\t\t\t\t\tmaterial.color = this.readColor( data );\n\n\t\t\t\t} else if ( next === MAT_SPECULAR ) {\n\n\t\t\t\t\tthis.debugMessage( '   Specular Color' );\n\t\t\t\t\tmaterial.specular = this.readColor( data );\n\n\t\t\t\t} else if ( next === MAT_AMBIENT ) {\n\n\t\t\t\t\tthis.debugMessage( '   Ambient color' );\n\t\t\t\t\tmaterial.color = this.readColor( data );\n\n\t\t\t\t} else if ( next === MAT_SHININESS ) {\n\n\t\t\t\t\tvar shininess = this.readWord( data );\n\t\t\t\t\tmaterial.shininess = shininess;\n\t\t\t\t\tthis.debugMessage( '   Shininess : ' + shininess );\n\n\t\t\t\t} else if ( next === MAT_TRANSPARENCY ) {\n\n\t\t\t\t\tvar opacity = this.readWord( data );\n\t\t\t\t\tmaterial.opacity = opacity * 0.01;\n\t\t\t\t\tthis.debugMessage( '  Opacity : ' + opacity );\n\t\t\t\t\tmaterial.transparent = opacity < 100 ? true : false;\n\n\t\t\t\t} else if ( next === MAT_TEXMAP ) {\n\n\t\t\t\t\tthis.debugMessage( '   ColorMap' );\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tmaterial.map = this.readMap( data, path );\n\n\t\t\t\t} else if ( next === MAT_BUMPMAP ) {\n\n\t\t\t\t\tthis.debugMessage( '   BumpMap' );\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tmaterial.bumpMap = this.readMap( data, path );\n\n\t\t\t\t} else if ( next === MAT_OPACMAP ) {\n\n\t\t\t\t\tthis.debugMessage( '   OpacityMap' );\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tmaterial.alphaMap = this.readMap( data, path );\n\n\t\t\t\t} else if ( next === MAT_SPECMAP ) {\n\n\t\t\t\t\tthis.debugMessage( '   SpecularMap' );\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tmaterial.specularMap = this.readMap( data, path );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( '   Unknown material chunk: ' + next.toString( 16 ) );\n\n\t\t\t\t}\n\n\t\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t\t}\n\n\t\t\tthis.endChunk( chunk );\n\n\t\t\tthis.materials[ material.name ] = material;\n\n\t\t},\n\n\t\t/**\n\t\t * Read mesh data chunk.\n\t\t *\n\t\t * @method readMesh\n\t\t * @param {Dataview} data Dataview in use.\n\t\t * @return {Mesh} The parsed mesh.\n\t\t */\n\t\treadMesh: function ( data ) {\n\n\t\t\tvar chunk = this.readChunk( data );\n\t\t\tvar next = this.nextChunk( data, chunk );\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\tvar uvs = [];\n\n\t\t\tvar material = new THREE.MeshPhongMaterial();\n\t\t\tvar mesh = new THREE.Mesh( geometry, material );\n\t\t\tmesh.name = 'mesh';\n\n\t\t\twhile ( next !== 0 ) {\n\n\t\t\t\tif ( next === POINT_ARRAY ) {\n\n\t\t\t\t\tvar points = this.readWord( data );\n\n\t\t\t\t\tthis.debugMessage( '   Vertex: ' + points );\n\n\t\t\t\t\t//BufferGeometry\n\n\t\t\t\t\tvar vertices = [];\n\n\t\t\t\t\tfor ( var i = 0; i < points; i ++ )\t\t{\n\n\t\t\t\t\t\tvertices.push( this.readFloat( data ) );\n\t\t\t\t\t\tvertices.push( this.readFloat( data ) );\n\t\t\t\t\t\tvertices.push( this.readFloat( data ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\t\t} else if ( next === FACE_ARRAY ) {\n\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tthis.readFaceArray( data, mesh );\n\n\t\t\t\t} else if ( next === TEX_VERTS ) {\n\n\t\t\t\t\tvar texels = this.readWord( data );\n\n\t\t\t\t\tthis.debugMessage( '   UV: ' + texels );\n\n\t\t\t\t\t//BufferGeometry\n\n\t\t\t\t\tvar uvs = [];\n\n\t\t\t\t\tfor ( var i = 0; i < texels; i ++ )\t\t{\n\n\t\t\t\t\t\tuvs.push( this.readFloat( data ) );\n\t\t\t\t\t\tuvs.push( this.readFloat( data ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t\t\t} else if ( next === MESH_MATRIX ) {\n\n\t\t\t\t\tthis.debugMessage( '   Tranformation Matrix (TODO)' );\n\n\t\t\t\t\tvar values = [];\n\t\t\t\t\tfor ( var i = 0; i < 12; i ++ ) {\n\n\t\t\t\t\t\tvalues[ i ] = this.readFloat( data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar matrix = new THREE.Matrix4();\n\n\t\t\t\t\t//X Line\n\t\t\t\t\tmatrix.elements[ 0 ] = values[ 0 ];\n\t\t\t\t\tmatrix.elements[ 1 ] = values[ 6 ];\n\t\t\t\t\tmatrix.elements[ 2 ] = values[ 3 ];\n\t\t\t\t\tmatrix.elements[ 3 ] = values[ 9 ];\n\n\t\t\t\t\t//Y Line\n\t\t\t\t\tmatrix.elements[ 4 ] = values[ 2 ];\n\t\t\t\t\tmatrix.elements[ 5 ] = values[ 8 ];\n\t\t\t\t\tmatrix.elements[ 6 ] = values[ 5 ];\n\t\t\t\t\tmatrix.elements[ 7 ] = values[ 11 ];\n\n\t\t\t\t\t//Z Line\n\t\t\t\t\tmatrix.elements[ 8 ] = values[ 1 ];\n\t\t\t\t\tmatrix.elements[ 9 ] = values[ 7 ];\n\t\t\t\t\tmatrix.elements[ 10 ] = values[ 4 ];\n\t\t\t\t\tmatrix.elements[ 11 ] = values[ 10 ];\n\n\t\t\t\t\t//W Line\n\t\t\t\t\tmatrix.elements[ 12 ] = 0;\n\t\t\t\t\tmatrix.elements[ 13 ] = 0;\n\t\t\t\t\tmatrix.elements[ 14 ] = 0;\n\t\t\t\t\tmatrix.elements[ 15 ] = 1;\n\n\t\t\t\t\tmatrix.transpose();\n\n\t\t\t\t\tvar inverse = new THREE.Matrix4();\n\t\t\t\t\tinverse.getInverse( matrix );\n\t\t\t\t\tgeometry.applyMatrix4( inverse );\n\n\t\t\t\t\tmatrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( '   Unknown mesh chunk: ' + next.toString( 16 ) );\n\n\t\t\t\t}\n\n\t\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t\t}\n\n\t\t\tthis.endChunk( chunk );\n\n\t\t\tgeometry.computeVertexNormals();\n\n\t\t\treturn mesh;\n\n\t\t},\n\n\t\t/**\n\t\t * Read face array data chunk.\n\t\t *\n\t\t * @method readFaceArray\n\t\t * @param {Dataview} data Dataview in use.\n\t\t * @param {Mesh} mesh Mesh to be filled with the data read.\n\t\t */\n\t\treadFaceArray: function ( data, mesh ) {\n\n\t\t\tvar chunk = this.readChunk( data );\n\t\t\tvar faces = this.readWord( data );\n\n\t\t\tthis.debugMessage( '   Faces: ' + faces );\n\n\t\t\tvar index = [];\n\n\t\t\tfor ( var i = 0; i < faces; ++ i ) {\n\n\t\t\t\tindex.push( this.readWord( data ), this.readWord( data ), this.readWord( data ) );\n\n\t\t\t\tthis.readWord( data ); // visibility\n\n\t\t\t}\n\n\t\t\tmesh.geometry.setIndex( index );\n\n\t\t\t//The rest of the FACE_ARRAY chunk is subchunks\n\n\t\t\twhile ( this.position < chunk.end ) {\n\n\t\t\t\tvar chunk = this.readChunk( data );\n\n\t\t\t\tif ( chunk.id === MSH_MAT_GROUP ) {\n\n\t\t\t\t\tthis.debugMessage( '      Material Group' );\n\n\t\t\t\t\tthis.resetPosition( data );\n\n\t\t\t\t\tvar group = this.readMaterialGroup( data );\n\n\t\t\t\t\tvar material = this.materials[ group.name ];\n\n\t\t\t\t\tif ( material !== undefined )\t{\n\n\t\t\t\t\t\tmesh.material = material;\n\n\t\t\t\t\t\tif ( material.name === '' )\t\t{\n\n\t\t\t\t\t\t\tmaterial.name = mesh.name;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( '      Unknown face array chunk: ' + chunk.toString( 16 ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.endChunk( chunk );\n\n\t\t\t}\n\n\t\t\tthis.endChunk( chunk );\n\n\t\t},\n\n\t\t/**\n\t\t * Read texture map data chunk.\n\t\t *\n\t\t * @method readMap\n\t\t * @param {Dataview} data Dataview in use.\n\t\t * @param {String} path Path for external resources.\n\t\t * @return {Texture} Texture read from this data chunk.\n\t\t */\n\t\treadMap: function ( data, path ) {\n\n\t\t\tvar chunk = this.readChunk( data );\n\t\t\tvar next = this.nextChunk( data, chunk );\n\t\t\tvar texture = {};\n\n\t\t\tvar loader = new THREE.TextureLoader( this.manager );\n\t\t\tloader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\twhile ( next !== 0 ) {\n\n\t\t\t\tif ( next === MAT_MAPNAME ) {\n\n\t\t\t\t\tvar name = this.readString( data, 128 );\n\t\t\t\t\ttexture = loader.load( name );\n\n\t\t\t\t\tthis.debugMessage( '      File: ' + path + name );\n\n\t\t\t\t} else if ( next === MAT_MAP_UOFFSET ) {\n\n\t\t\t\t\ttexture.offset.x = this.readFloat( data );\n\t\t\t\t\tthis.debugMessage( '      OffsetX: ' + texture.offset.x );\n\n\t\t\t\t} else if ( next === MAT_MAP_VOFFSET ) {\n\n\t\t\t\t\ttexture.offset.y = this.readFloat( data );\n\t\t\t\t\tthis.debugMessage( '      OffsetY: ' + texture.offset.y );\n\n\t\t\t\t} else if ( next === MAT_MAP_USCALE ) {\n\n\t\t\t\t\ttexture.repeat.x = this.readFloat( data );\n\t\t\t\t\tthis.debugMessage( '      RepeatX: ' + texture.repeat.x );\n\n\t\t\t\t} else if ( next === MAT_MAP_VSCALE ) {\n\n\t\t\t\t\ttexture.repeat.y = this.readFloat( data );\n\t\t\t\t\tthis.debugMessage( '      RepeatY: ' + texture.repeat.y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( '      Unknown map chunk: ' + next.toString( 16 ) );\n\n\t\t\t\t}\n\n\t\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t\t}\n\n\t\t\tthis.endChunk( chunk );\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\t/**\n\t\t * Read material group data chunk.\n\t\t *\n\t\t * @method readMaterialGroup\n\t\t * @param {Dataview} data Dataview in use.\n\t\t * @return {Object} Object with name and index of the object.\n\t\t */\n\t\treadMaterialGroup: function ( data ) {\n\n\t\t\tthis.readChunk( data );\n\t\t\tvar name = this.readString( data, 64 );\n\t\t\tvar numFaces = this.readWord( data );\n\n\t\t\tthis.debugMessage( '         Name: ' + name );\n\t\t\tthis.debugMessage( '         Faces: ' + numFaces );\n\n\t\t\tvar index = [];\n\t\t\tfor ( var i = 0; i < numFaces; ++ i ) {\n\n\t\t\t\tindex.push( this.readWord( data ) );\n\n\t\t\t}\n\n\t\t\treturn { name: name, index: index };\n\n\t\t},\n\n\t\t/**\n\t\t * Read a color value.\n\t\t *\n\t\t * @method readColor\n\t\t * @param {DataView} data Dataview.\n\t\t * @return {Color} Color value read..\n\t\t */\n\t\treadColor: function ( data ) {\n\n\t\t\tvar chunk = this.readChunk( data );\n\t\t\tvar color = new THREE.Color();\n\n\t\t\tif ( chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24 ) {\n\n\t\t\t\tvar r = this.readByte( data );\n\t\t\t\tvar g = this.readByte( data );\n\t\t\t\tvar b = this.readByte( data );\n\n\t\t\t\tcolor.setRGB( r / 255, g / 255, b / 255 );\n\n\t\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\n\n\t\t\t}\telse if ( chunk.id === COLOR_F || chunk.id === LIN_COLOR_F ) {\n\n\t\t\t\tvar r = this.readFloat( data );\n\t\t\t\tvar g = this.readFloat( data );\n\t\t\t\tvar b = this.readFloat( data );\n\n\t\t\t\tcolor.setRGB( r, g, b );\n\n\t\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\n\n\t\t\t}\telse {\n\n\t\t\t\tthis.debugMessage( '      Unknown color chunk: ' + chunk.toString( 16 ) );\n\n\t\t\t}\n\n\t\t\tthis.endChunk( chunk );\n\t\t\treturn color;\n\n\t\t},\n\n\t\t/**\n\t\t * Read next chunk of data.\n\t\t *\n\t\t * @method readChunk\n\t\t * @param {DataView} data Dataview.\n\t\t * @return {Object} Chunk of data read.\n\t\t */\n\t\treadChunk: function ( data ) {\n\n\t\t\tvar chunk = {};\n\n\t\t\tchunk.cur = this.position;\n\t\t\tchunk.id = this.readWord( data );\n\t\t\tchunk.size = this.readDWord( data );\n\t\t\tchunk.end = chunk.cur + chunk.size;\n\t\t\tchunk.cur += 6;\n\n\t\t\treturn chunk;\n\n\t\t},\n\n\t\t/**\n\t\t * Set position to the end of the current chunk of data.\n\t\t *\n\t\t * @method endChunk\n\t\t * @param {Object} chunk Data chunk.\n\t\t */\n\t\tendChunk: function ( chunk ) {\n\n\t\t\tthis.position = chunk.end;\n\n\t\t},\n\n\t\t/**\n\t\t * Move to the next data chunk.\n\t\t *\n\t\t * @method nextChunk\n\t\t * @param {DataView} data Dataview.\n\t\t * @param {Object} chunk Data chunk.\n\t\t */\n\t\tnextChunk: function ( data, chunk ) {\n\n\t\t\tif ( chunk.cur >= chunk.end ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tthis.position = chunk.cur;\n\n\t\t\ttry {\n\n\t\t\t\tvar next = this.readChunk( data );\n\t\t\t\tchunk.cur += next.size;\n\t\t\t\treturn next.id;\n\n\t\t\t}\tcatch ( e ) {\n\n\t\t\t\tthis.debugMessage( 'Unable to read chunk at ' + this.position );\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t},\n\n\t\t/**\n\t\t * Reset dataview position.\n\t\t *\n\t\t * @method resetPosition\n\t\t */\n\t\tresetPosition: function () {\n\n\t\t\tthis.position -= 6;\n\n\t\t},\n\n\t\t/**\n\t\t * Read byte value.\n\t\t *\n\t\t * @method readByte\n\t\t * @param {DataView} data Dataview to read data from.\n\t\t * @return {Number} Data read from the dataview.\n\t\t */\n\t\treadByte: function ( data ) {\n\n\t\t\tvar v = data.getUint8( this.position, true );\n\t\t\tthis.position += 1;\n\t\t\treturn v;\n\n\t\t},\n\n\t\t/**\n\t\t * Read 32 bit float value.\n\t\t *\n\t\t * @method readFloat\n\t\t * @param {DataView} data Dataview to read data from.\n\t\t * @return {Number} Data read from the dataview.\n\t\t */\n\t\treadFloat: function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tvar v = data.getFloat32( this.position, true );\n\t\t\t\tthis.position += 4;\n\t\t\t\treturn v;\n\n\t\t\t}\tcatch ( e ) {\n\n\t\t\t\tthis.debugMessage( e + ' ' + this.position + ' ' + data.byteLength );\n\n\t\t\t}\n\n\t\t},\n\n\t\t/**\n\t\t * Read 32 bit signed integer value.\n\t\t *\n\t\t * @method readInt\n\t\t * @param {DataView} data Dataview to read data from.\n\t\t * @return {Number} Data read from the dataview.\n\t\t */\n\t\treadInt: function ( data ) {\n\n\t\t\tvar v = data.getInt32( this.position, true );\n\t\t\tthis.position += 4;\n\t\t\treturn v;\n\n\t\t},\n\n\t\t/**\n\t\t * Read 16 bit signed integer value.\n\t\t *\n\t\t * @method readShort\n\t\t * @param {DataView} data Dataview to read data from.\n\t\t * @return {Number} Data read from the dataview.\n\t\t */\n\t\treadShort: function ( data ) {\n\n\t\t\tvar v = data.getInt16( this.position, true );\n\t\t\tthis.position += 2;\n\t\t\treturn v;\n\n\t\t},\n\n\t\t/**\n\t\t * Read 64 bit unsigned integer value.\n\t\t *\n\t\t * @method readDWord\n\t\t * @param {DataView} data Dataview to read data from.\n\t\t * @return {Number} Data read from the dataview.\n\t\t */\n\t\treadDWord: function ( data ) {\n\n\t\t\tvar v = data.getUint32( this.position, true );\n\t\t\tthis.position += 4;\n\t\t\treturn v;\n\n\t\t},\n\n\t\t/**\n\t\t * Read 32 bit unsigned integer value.\n\t\t *\n\t\t * @method readWord\n\t\t * @param {DataView} data Dataview to read data from.\n\t\t * @return {Number} Data read from the dataview.\n\t\t */\n\t\treadWord: function ( data ) {\n\n\t\t\tvar v = data.getUint16( this.position, true );\n\t\t\tthis.position += 2;\n\t\t\treturn v;\n\n\t\t},\n\n\t\t/**\n\t\t * Read string value.\n\t\t *\n\t\t * @method readString\n\t\t * @param {DataView} data Dataview to read data from.\n\t\t * @param {Number} maxLength Max size of the string to be read.\n\t\t * @return {String} Data read from the dataview.\n\t\t */\n\t\treadString: function ( data, maxLength ) {\n\n\t\t\tvar s = '';\n\n\t\t\tfor ( var i = 0; i < maxLength; i ++ ) {\n\n\t\t\t\tvar c = this.readByte( data );\n\t\t\t\tif ( ! c ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\ts += String.fromCharCode( c );\n\n\t\t\t}\n\n\t\t\treturn s;\n\n\t\t},\n\n\t\t/**\n\t\t * Print debug message to the console.\n\t\t *\n\t\t * Is controlled by a flag to show or hide debug messages.\n\t\t *\n\t\t * @method debugMessage\n\t\t * @param {Object} message Debug message to print to the console.\n\t\t */\n\t\tdebugMessage: function ( message ) {\n\n\t\t\tif ( this.debug ) {\n\n\t\t\t\tconsole.log( message );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t// var NULL_CHUNK = 0x0000;\n\tvar M3DMAGIC = 0x4D4D;\n\t// var SMAGIC = 0x2D2D;\n\t// var LMAGIC = 0x2D3D;\n\tvar MLIBMAGIC = 0x3DAA;\n\t// var MATMAGIC = 0x3DFF;\n\tvar CMAGIC = 0xC23D;\n\tvar M3D_VERSION = 0x0002;\n\t// var M3D_KFVERSION = 0x0005;\n\tvar COLOR_F = 0x0010;\n\tvar COLOR_24 = 0x0011;\n\tvar LIN_COLOR_24 = 0x0012;\n\tvar LIN_COLOR_F = 0x0013;\n\t// var INT_PERCENTAGE = 0x0030;\n\t// var FLOAT_PERCENTAGE = 0x0031;\n\tvar MDATA = 0x3D3D;\n\tvar MESH_VERSION = 0x3D3E;\n\tvar MASTER_SCALE = 0x0100;\n\t// var LO_SHADOW_BIAS = 0x1400;\n\t// var HI_SHADOW_BIAS = 0x1410;\n\t// var SHADOW_MAP_SIZE = 0x1420;\n\t// var SHADOW_SAMPLES = 0x1430;\n\t// var SHADOW_RANGE = 0x1440;\n\t// var SHADOW_FILTER = 0x1450;\n\t// var RAY_BIAS = 0x1460;\n\t// var O_CONSTS = 0x1500;\n\t// var AMBIENT_LIGHT = 0x2100;\n\t// var BIT_MAP = 0x1100;\n\t// var SOLID_BGND = 0x1200;\n\t// var V_GRADIENT = 0x1300;\n\t// var USE_BIT_MAP = 0x1101;\n\t// var USE_SOLID_BGND = 0x1201;\n\t// var USE_V_GRADIENT = 0x1301;\n\t// var FOG = 0x2200;\n\t// var FOG_BGND = 0x2210;\n\t// var LAYER_FOG = 0x2302;\n\t// var DISTANCE_CUE = 0x2300;\n\t// var DCUE_BGND = 0x2310;\n\t// var USE_FOG = 0x2201;\n\t// var USE_LAYER_FOG = 0x2303;\n\t// var USE_DISTANCE_CUE = 0x2301;\n\tvar MAT_ENTRY = 0xAFFF;\n\tvar MAT_NAME = 0xA000;\n\tvar MAT_AMBIENT = 0xA010;\n\tvar MAT_DIFFUSE = 0xA020;\n\tvar MAT_SPECULAR = 0xA030;\n\tvar MAT_SHININESS = 0xA040;\n\t// var MAT_SHIN2PCT = 0xA041;\n\tvar MAT_TRANSPARENCY = 0xA050;\n\t// var MAT_XPFALL = 0xA052;\n\t// var MAT_USE_XPFALL = 0xA240;\n\t// var MAT_REFBLUR = 0xA053;\n\t// var MAT_SHADING = 0xA100;\n\t// var MAT_USE_REFBLUR = 0xA250;\n\t// var MAT_SELF_ILLUM = 0xA084;\n\tvar MAT_TWO_SIDE = 0xA081;\n\t// var MAT_DECAL = 0xA082;\n\tvar MAT_ADDITIVE = 0xA083;\n\tvar MAT_WIRE = 0xA085;\n\t// var MAT_FACEMAP = 0xA088;\n\t// var MAT_TRANSFALLOFF_IN = 0xA08A;\n\t// var MAT_PHONGSOFT = 0xA08C;\n\t// var MAT_WIREABS = 0xA08E;\n\tvar MAT_WIRE_SIZE = 0xA087;\n\tvar MAT_TEXMAP = 0xA200;\n\t// var MAT_SXP_TEXT_DATA = 0xA320;\n\t// var MAT_TEXMASK = 0xA33E;\n\t// var MAT_SXP_TEXTMASK_DATA = 0xA32A;\n\t// var MAT_TEX2MAP = 0xA33A;\n\t// var MAT_SXP_TEXT2_DATA = 0xA321;\n\t// var MAT_TEX2MASK = 0xA340;\n\t// var MAT_SXP_TEXT2MASK_DATA = 0xA32C;\n\tvar MAT_OPACMAP = 0xA210;\n\t// var MAT_SXP_OPAC_DATA = 0xA322;\n\t// var MAT_OPACMASK = 0xA342;\n\t// var MAT_SXP_OPACMASK_DATA = 0xA32E;\n\tvar MAT_BUMPMAP = 0xA230;\n\t// var MAT_SXP_BUMP_DATA = 0xA324;\n\t// var MAT_BUMPMASK = 0xA344;\n\t// var MAT_SXP_BUMPMASK_DATA = 0xA330;\n\tvar MAT_SPECMAP = 0xA204;\n\t// var MAT_SXP_SPEC_DATA = 0xA325;\n\t// var MAT_SPECMASK = 0xA348;\n\t// var MAT_SXP_SPECMASK_DATA = 0xA332;\n\t// var MAT_SHINMAP = 0xA33C;\n\t// var MAT_SXP_SHIN_DATA = 0xA326;\n\t// var MAT_SHINMASK = 0xA346;\n\t// var MAT_SXP_SHINMASK_DATA = 0xA334;\n\t// var MAT_SELFIMAP = 0xA33D;\n\t// var MAT_SXP_SELFI_DATA = 0xA328;\n\t// var MAT_SELFIMASK = 0xA34A;\n\t// var MAT_SXP_SELFIMASK_DATA = 0xA336;\n\t// var MAT_REFLMAP = 0xA220;\n\t// var MAT_REFLMASK = 0xA34C;\n\t// var MAT_SXP_REFLMASK_DATA = 0xA338;\n\t// var MAT_ACUBIC = 0xA310;\n\tvar MAT_MAPNAME = 0xA300;\n\t// var MAT_MAP_TILING = 0xA351;\n\t// var MAT_MAP_TEXBLUR = 0xA353;\n\tvar MAT_MAP_USCALE = 0xA354;\n\tvar MAT_MAP_VSCALE = 0xA356;\n\tvar MAT_MAP_UOFFSET = 0xA358;\n\tvar MAT_MAP_VOFFSET = 0xA35A;\n\t// var MAT_MAP_ANG = 0xA35C;\n\t// var MAT_MAP_COL1 = 0xA360;\n\t// var MAT_MAP_COL2 = 0xA362;\n\t// var MAT_MAP_RCOL = 0xA364;\n\t// var MAT_MAP_GCOL = 0xA366;\n\t// var MAT_MAP_BCOL = 0xA368;\n\tvar NAMED_OBJECT = 0x4000;\n\t// var N_DIRECT_LIGHT = 0x4600;\n\t// var DL_OFF = 0x4620;\n\t// var DL_OUTER_RANGE = 0x465A;\n\t// var DL_INNER_RANGE = 0x4659;\n\t// var DL_MULTIPLIER = 0x465B;\n\t// var DL_EXCLUDE = 0x4654;\n\t// var DL_ATTENUATE = 0x4625;\n\t// var DL_SPOTLIGHT = 0x4610;\n\t// var DL_SPOT_ROLL = 0x4656;\n\t// var DL_SHADOWED = 0x4630;\n\t// var DL_LOCAL_SHADOW2 = 0x4641;\n\t// var DL_SEE_CONE = 0x4650;\n\t// var DL_SPOT_RECTANGULAR = 0x4651;\n\t// var DL_SPOT_ASPECT = 0x4657;\n\t// var DL_SPOT_PROJECTOR = 0x4653;\n\t// var DL_SPOT_OVERSHOOT = 0x4652;\n\t// var DL_RAY_BIAS = 0x4658;\n\t// var DL_RAYSHAD = 0x4627;\n\t// var N_CAMERA = 0x4700;\n\t// var CAM_SEE_CONE = 0x4710;\n\t// var CAM_RANGES = 0x4720;\n\t// var OBJ_HIDDEN = 0x4010;\n\t// var OBJ_VIS_LOFTER = 0x4011;\n\t// var OBJ_DOESNT_CAST = 0x4012;\n\t// var OBJ_DONT_RECVSHADOW = 0x4017;\n\t// var OBJ_MATTE = 0x4013;\n\t// var OBJ_FAST = 0x4014;\n\t// var OBJ_PROCEDURAL = 0x4015;\n\t// var OBJ_FROZEN = 0x4016;\n\tvar N_TRI_OBJECT = 0x4100;\n\tvar POINT_ARRAY = 0x4110;\n\t// var POINT_FLAG_ARRAY = 0x4111;\n\tvar FACE_ARRAY = 0x4120;\n\tvar MSH_MAT_GROUP = 0x4130;\n\t// var SMOOTH_GROUP = 0x4150;\n\t// var MSH_BOXMAP = 0x4190;\n\tvar TEX_VERTS = 0x4140;\n\tvar MESH_MATRIX = 0x4160;\n\t// var MESH_COLOR = 0x4165;\n\t// var MESH_TEXTURE_INFO = 0x4170;\n\t// var KFDATA = 0xB000;\n\t// var KFHDR = 0xB00A;\n\t// var KFSEG = 0xB008;\n\t// var KFCURTIME = 0xB009;\n\t// var AMBIENT_NODE_TAG = 0xB001;\n\t// var OBJECT_NODE_TAG = 0xB002;\n\t// var CAMERA_NODE_TAG = 0xB003;\n\t// var TARGET_NODE_TAG = 0xB004;\n\t// var LIGHT_NODE_TAG = 0xB005;\n\t// var L_TARGET_NODE_TAG = 0xB006;\n\t// var SPOTLIGHT_NODE_TAG = 0xB007;\n\t// var NODE_ID = 0xB030;\n\t// var NODE_HDR = 0xB010;\n\t// var PIVOT = 0xB013;\n\t// var INSTANCE_NAME = 0xB011;\n\t// var MORPH_SMOOTH = 0xB015;\n\t// var BOUNDBOX = 0xB014;\n\t// var POS_TRACK_TAG = 0xB020;\n\t// var COL_TRACK_TAG = 0xB025;\n\t// var ROT_TRACK_TAG = 0xB021;\n\t// var SCL_TRACK_TAG = 0xB022;\n\t// var MORPH_TRACK_TAG = 0xB026;\n\t// var FOV_TRACK_TAG = 0xB023;\n\t// var ROLL_TRACK_TAG = 0xB024;\n\t// var HOT_TRACK_TAG = 0xB027;\n\t// var FALL_TRACK_TAG = 0xB028;\n\t// var HIDE_TRACK_TAG = 0xB029;\n\t// var POLY_2D = 0x5000;\n\t// var SHAPE_OK = 0x5010;\n\t// var SHAPE_NOT_OK = 0x5011;\n\t// var SHAPE_HOOK = 0x5020;\n\t// var PATH_3D = 0x6000;\n\t// var PATH_MATRIX = 0x6005;\n\t// var SHAPE_2D = 0x6010;\n\t// var M_SCALE = 0x6020;\n\t// var M_TWIST = 0x6030;\n\t// var M_TEETER = 0x6040;\n\t// var M_FIT = 0x6050;\n\t// var M_BEVEL = 0x6060;\n\t// var XZ_CURVE = 0x6070;\n\t// var YZ_CURVE = 0x6080;\n\t// var INTERPCT = 0x6090;\n\t// var DEFORM_LIMIT = 0x60A0;\n\t// var USE_CONTOUR = 0x6100;\n\t// var USE_TWEEN = 0x6110;\n\t// var USE_SCALE = 0x6120;\n\t// var USE_TWIST = 0x6130;\n\t// var USE_TEETER = 0x6140;\n\t// var USE_FIT = 0x6150;\n\t// var USE_BEVEL = 0x6160;\n\t// var DEFAULT_VIEW = 0x3000;\n\t// var VIEW_TOP = 0x3010;\n\t// var VIEW_BOTTOM = 0x3020;\n\t// var VIEW_LEFT = 0x3030;\n\t// var VIEW_RIGHT = 0x3040;\n\t// var VIEW_FRONT = 0x3050;\n\t// var VIEW_BACK = 0x3060;\n\t// var VIEW_USER = 0x3070;\n\t// var VIEW_CAMERA = 0x3080;\n\t// var VIEW_WINDOW = 0x3090;\n\t// var VIEWPORT_LAYOUT_OLD = 0x7000;\n\t// var VIEWPORT_DATA_OLD = 0x7010;\n\t// var VIEWPORT_LAYOUT = 0x7001;\n\t// var VIEWPORT_DATA = 0x7011;\n\t// var VIEWPORT_DATA_3 = 0x7012;\n\t// var VIEWPORT_SIZE = 0x7020;\n\t// var NETWORK_VIEW = 0x7030;\n\t\n\treturn THREE.TDSLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/VTKLoader',[\n\t\"skylark-threejs\"\n],function(THREE,Zlib){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Alex Pletzer\n\t *\n\t * Updated on 22.03.2017\n\t * VTK header is now parsed and used to extract all the compressed data\n\t * @author Andrii Iudin https://github.com/andreyyudin\n\t * @author Paul Kibet Korir https://github.com/polarise\n\t * @author Sriram Somasundharam https://github.com/raamssundar\n\t */\n\n\tTHREE.VTKLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.VTKLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.VTKLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data ) {\n\n\t\t\tfunction parseASCII( data ) {\n\n\t\t\t\t// connectivity of the triangles\n\t\t\t\tvar indices = [];\n\n\t\t\t\t// triangles vertices\n\t\t\t\tvar positions = [];\n\n\t\t\t\t// red, green, blue colors in the range 0 to 1\n\t\t\t\tvar colors = [];\n\n\t\t\t\t// normal vector, one per vertex\n\t\t\t\tvar normals = [];\n\n\t\t\t\tvar result;\n\n\t\t\t\t// pattern for detecting the end of a number sequence\n\t\t\t\tvar patWord = /^[^\\d.\\s-]+/;\n\n\t\t\t\t// pattern for reading vertices, 3 floats or integers\n\t\t\t\tvar pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g;\n\n\t\t\t\t// pattern for connectivity, an integer followed by any number of ints\n\t\t\t\t// the first integer is the number of polygon nodes\n\t\t\t\tvar patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/;\n\n\t\t\t\t// indicates start of vertex data section\n\t\t\t\tvar patPOINTS = /^POINTS /;\n\n\t\t\t\t// indicates start of polygon connectivity section\n\t\t\t\tvar patPOLYGONS = /^POLYGONS /;\n\n\t\t\t\t// indicates start of triangle strips section\n\t\t\t\tvar patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;\n\n\t\t\t\t// POINT_DATA number_of_values\n\t\t\t\tvar patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/;\n\n\t\t\t\t// CELL_DATA number_of_polys\n\t\t\t\tvar patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/;\n\n\t\t\t\t// Start of color section\n\t\t\t\tvar patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/;\n\n\t\t\t\t// NORMALS Normals float\n\t\t\t\tvar patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n\n\t\t\t\tvar inPointsSection = false;\n\t\t\t\tvar inPolygonsSection = false;\n\t\t\t\tvar inTriangleStripSection = false;\n\t\t\t\tvar inPointDataSection = false;\n\t\t\t\tvar inCellDataSection = false;\n\t\t\t\tvar inColorSection = false;\n\t\t\t\tvar inNormalsSection = false;\n\n\t\t\t\tvar lines = data.split( '\\n' );\n\n\t\t\t\tfor ( var i in lines ) {\n\n\t\t\t\t\tvar line = lines[ i ].trim();\n\n\t\t\t\t\tif ( line.indexOf( 'DATASET' ) === 0 ) {\n\n\t\t\t\t\t\tvar dataset = line.split( ' ' )[ 1 ];\n\n\t\t\t\t\t\tif ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );\n\n\t\t\t\t\t} else if ( inPointsSection ) {\n\n\t\t\t\t\t\t// get the vertices\n\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\t\tvar x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\tvar y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\tvar z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\tpositions.push( x, y, z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( inPolygonsSection ) {\n\n\t\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\t\tvar numVertices = parseInt( result[ 1 ] );\n\t\t\t\t\t\t\tvar inds = result[ 2 ].split( /\\s+/ );\n\n\t\t\t\t\t\t\tif ( numVertices >= 3 ) {\n\n\t\t\t\t\t\t\t\tvar i0 = parseInt( inds[ 0 ] );\n\t\t\t\t\t\t\t\tvar i1, i2;\n\t\t\t\t\t\t\t\tvar k = 1;\n\t\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\t\tfor ( var j = 0; j < numVertices - 2; ++ j ) {\n\n\t\t\t\t\t\t\t\t\ti1 = parseInt( inds[ k ] );\n\t\t\t\t\t\t\t\t\ti2 = parseInt( inds[ k + 1 ] );\n\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\t\t\t\t\t\t\t\t\tk ++;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( inTriangleStripSection ) {\n\n\t\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\t\tvar numVertices = parseInt( result[ 1 ] );\n\t\t\t\t\t\t\tvar inds = result[ 2 ].split( /\\s+/ );\n\n\t\t\t\t\t\t\tif ( numVertices >= 3 ) {\n\n\t\t\t\t\t\t\t\tvar i0, i1, i2;\n\t\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\t\tfor ( var j = 0; j < numVertices - 2; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tif ( j % 2 === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\ti0 = parseInt( inds[ j ] );\n\t\t\t\t\t\t\t\t\t\ti1 = parseInt( inds[ j + 2 ] );\n\t\t\t\t\t\t\t\t\t\ti2 = parseInt( inds[ j + 1 ] );\n\t\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ti0 = parseInt( inds[ j ] );\n\t\t\t\t\t\t\t\t\t\ti1 = parseInt( inds[ j + 1 ] );\n\t\t\t\t\t\t\t\t\t\ti2 = parseInt( inds[ j + 2 ] );\n\t\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( inPointDataSection || inCellDataSection ) {\n\n\t\t\t\t\t\tif ( inColorSection ) {\n\n\t\t\t\t\t\t\t// Get the colors\n\n\t\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\t\t\tvar r = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\t\tvar g = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\t\tvar b = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\t\tcolors.push( r, g, b );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( inNormalsSection ) {\n\n\t\t\t\t\t\t\t// Get the normal vectors\n\n\t\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\t\t\tvar nx = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\t\tvar ny = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\t\tvar nz = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\t\tnormals.push( nx, ny, nz );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( patPOLYGONS.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinPolygonsSection = true;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t} else if ( patPOINTS.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinPointsSection = true;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t} else if ( patTRIANGLE_STRIPS.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = true;\n\n\t\t\t\t\t} else if ( patPOINT_DATA.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinPointDataSection = true;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t} else if ( patCELL_DATA.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinCellDataSection = true;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t} else if ( patCOLOR_SCALARS.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinColorSection = true;\n\t\t\t\t\t\tinNormalsSection = false;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t} else if ( patNORMALS.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinNormalsSection = true;\n\t\t\t\t\t\tinColorSection = false;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\n\t\t\t\tif ( normals.length === positions.length ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( colors.length !== indices.length ) {\n\n\t\t\t\t\t// stagger\n\n\t\t\t\t\tif ( colors.length === positions.length ) {\n\n\t\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// cell\n\n\t\t\t\t\tgeometry = geometry.toNonIndexed();\n\t\t\t\t\tvar numTriangles = geometry.attributes.position.count / 3;\n\n\t\t\t\t\tif ( colors.length === ( numTriangles * 3 ) ) {\n\n\t\t\t\t\t\tvar newColors = [];\n\n\t\t\t\t\t\tfor ( var i = 0; i < numTriangles; i ++ ) {\n\n\t\t\t\t\t\t\tvar r = colors[ 3 * i + 0 ];\n\t\t\t\t\t\t\tvar g = colors[ 3 * i + 1 ];\n\t\t\t\t\t\t\tvar b = colors[ 3 * i + 2 ];\n\n\t\t\t\t\t\t\tnewColors.push( r, g, b );\n\t\t\t\t\t\t\tnewColors.push( r, g, b );\n\t\t\t\t\t\t\tnewColors.push( r, g, b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( newColors, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction parseBinary( data ) {\n\n\t\t\t\tvar count, pointIndex, i, numberOfPoints, s;\n\t\t\t\tvar buffer = new Uint8Array( data );\n\t\t\t\tvar dataView = new DataView( data );\n\n\t\t\t\t// Points and normals, by default, are empty\n\t\t\t\tvar points = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar indices = [];\n\n\t\t\t\t// Going to make a big array of strings\n\t\t\t\tvar vtk = [];\n\t\t\t\tvar index = 0;\n\n\t\t\t\tfunction findString( buffer, start ) {\n\n\t\t\t\t\tvar index = start;\n\t\t\t\t\tvar c = buffer[ index ];\n\t\t\t\t\tvar s = [];\n\t\t\t\t\twhile ( c !== 10 ) {\n\n\t\t\t\t\t\ts.push( String.fromCharCode( c ) );\n\t\t\t\t\t\tindex ++;\n\t\t\t\t\t\tc = buffer[ index ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { start: start,\n\t\t\t\t\t\tend: index,\n\t\t\t\t\t\tnext: index + 1,\n\t\t\t\t\t\tparsedString: s.join( '' ) };\n\n\t\t\t\t}\n\n\t\t\t\tvar state, line;\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t// Get a string\n\t\t\t\t\tstate = findString( buffer, index );\n\t\t\t\t\tline = state.parsedString;\n\n\t\t\t\t\tif ( line.indexOf( 'DATASET' ) === 0 ) {\n\n\t\t\t\t\t\tvar dataset = line.split( ' ' )[ 1 ];\n\n\t\t\t\t\t\tif ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );\n\n\t\t\t\t\t} else if ( line.indexOf( 'POINTS' ) === 0 ) {\n\n\t\t\t\t\t\tvtk.push( line );\n\t\t\t\t\t\t// Add the points\n\t\t\t\t\t\tnumberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\n\n\t\t\t\t\t\t// Each point is 3 4-byte floats\n\t\t\t\t\t\tcount = numberOfPoints * 4 * 3;\n\n\t\t\t\t\t\tpoints = new Float32Array( numberOfPoints * 3 );\n\n\t\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\t\tfor ( i = 0; i < numberOfPoints; i ++ ) {\n\n\t\t\t\t\t\t\tpoints[ 3 * i ] = dataView.getFloat32( pointIndex, false );\n\t\t\t\t\t\t\tpoints[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\n\t\t\t\t\t\t\tpoints[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\n\t\t\t\t\t\t\tpointIndex = pointIndex + 12;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// increment our next pointer\n\t\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t\t} else if ( line.indexOf( 'TRIANGLE_STRIPS' ) === 0 ) {\n\n\t\t\t\t\t\tvar numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\n\t\t\t\t\t\tvar size = parseInt( line.split( ' ' )[ 2 ], 10 );\n\t\t\t\t\t\t// 4 byte integers\n\t\t\t\t\t\tcount = size * 4;\n\n\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\t\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\t\tfor ( i = 0; i < numberOfStrips; i ++ ) {\n\n\t\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\t\tvar indexCount = dataView.getInt32( pointIndex, false );\n\t\t\t\t\t\t\tvar strip = [];\n\t\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\t\tfor ( s = 0; s < indexCount; s ++ ) {\n\n\t\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\n\t\t\t\t\t\t\t\tpointIndex += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// retrieves the n-2 triangles from the triangle strip\n\t\t\t\t\t\t\tfor ( var j = 0; j < indexCount - 2; j ++ ) {\n\n\t\t\t\t\t\t\t\tif ( j % 2 ) {\n\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t\t\t} else {\n\n\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// increment our next pointer\n\t\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t\t} else if ( line.indexOf( 'POLYGONS' ) === 0 ) {\n\n\t\t\t\t\t\tvar numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\n\t\t\t\t\t\tvar size = parseInt( line.split( ' ' )[ 2 ], 10 );\n\t\t\t\t\t\t// 4 byte integers\n\t\t\t\t\t\tcount = size * 4;\n\n\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\t\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\t\tfor ( i = 0; i < numberOfStrips; i ++ ) {\n\n\t\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\t\tvar indexCount = dataView.getInt32( pointIndex, false );\n\t\t\t\t\t\t\tvar strip = [];\n\t\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\t\tfor ( s = 0; s < indexCount; s ++ ) {\n\n\t\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\n\t\t\t\t\t\t\t\tpointIndex += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// divide the polygon in n-2 triangle\n\t\t\t\t\t\t\tfor ( var j = 1; j < indexCount - 1; j ++ ) {\n\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ 0 ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// increment our next pointer\n\t\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t\t} else if ( line.indexOf( 'POINT_DATA' ) === 0 ) {\n\n\t\t\t\t\t\tnumberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\n\n\t\t\t\t\t\t// Grab the next line\n\t\t\t\t\t\tstate = findString( buffer, state.next );\n\n\t\t\t\t\t\t// Now grab the binary data\n\t\t\t\t\t\tcount = numberOfPoints * 4 * 3;\n\n\t\t\t\t\t\tnormals = new Float32Array( numberOfPoints * 3 );\n\t\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\t\tfor ( i = 0; i < numberOfPoints; i ++ ) {\n\n\t\t\t\t\t\t\tnormals[ 3 * i ] = dataView.getFloat32( pointIndex, false );\n\t\t\t\t\t\t\tnormals[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\n\t\t\t\t\t\t\tnormals[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\n\t\t\t\t\t\t\tpointIndex += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Increment past our data\n\t\t\t\t\t\tstate.next = state.next + count;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Increment index\n\t\t\t\t\tindex = state.next;\n\n\t\t\t\t\tif ( index >= buffer.byteLength ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( points, 3 ) );\n\n\t\t\t\tif ( normals.length === points.length ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction Float32Concat( first, second ) {\n\n\t\t\t    var firstLength = first.length, result = new Float32Array( firstLength + second.length );\n\n\t\t\t    result.set( first );\n\t\t\t    result.set( second, firstLength );\n\n\t\t\t    return result;\n\n\t\t\t}\n\n\t\t\tfunction Int32Concat( first, second ) {\n\n\t\t\t    var firstLength = first.length, result = new Int32Array( firstLength + second.length );\n\n\t\t\t    result.set( first );\n\t\t\t    result.set( second, firstLength );\n\n\t\t\t    return result;\n\n\t\t\t}\n\n\t\t\tfunction parseXML( stringFile ) {\n\n\t\t\t\t// Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n\n\t\t\t\tfunction xmlToJson( xml ) {\n\n\t\t\t\t\t// Create the return object\n\t\t\t\t\tvar obj = {};\n\n\t\t\t\t\tif ( xml.nodeType === 1 ) { // element\n\n\t\t\t\t\t\t// do attributes\n\n\t\t\t\t\t\tif ( xml.attributes ) {\n\n\t\t\t\t\t\t\tif ( xml.attributes.length > 0 ) {\n\n\t\t\t\t\t\t\t\tobj[ 'attributes' ] = {};\n\n\t\t\t\t\t\t\t\tfor ( var j = 0; j < xml.attributes.length; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar attribute = xml.attributes.item( j );\n\t\t\t\t\t\t\t\t\tobj[ 'attributes' ][ attribute.nodeName ] = attribute.nodeValue.trim();\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( xml.nodeType === 3 ) { // text\n\n\t\t\t\t\t\tobj = xml.nodeValue.trim();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// do children\n\t\t\t\t\tif ( xml.hasChildNodes() ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\t\t\tvar item = xml.childNodes.item( i );\n\t\t\t\t\t\t\tvar nodeName = item.nodeName;\n\n\t\t\t\t\t\t\tif ( typeof obj[ nodeName ] === 'undefined' ) {\n\n\t\t\t\t\t\t\t\tvar tmp = xmlToJson( item );\n\n\t\t\t\t\t\t\t\tif ( tmp !== '' ) obj[ nodeName ] = tmp;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tif ( typeof obj[ nodeName ].push === 'undefined' ) {\n\n\t\t\t\t\t\t\t\t\tvar old = obj[ nodeName ];\n\t\t\t\t\t\t\t\t\tobj[ nodeName ] = [ old ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar tmp = xmlToJson( item );\n\n\t\t\t\t\t\t\t\tif ( tmp !== '' ) obj[ nodeName ].push( tmp );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn obj;\n\n\t\t\t\t}\n\n\t\t\t\t// Taken from Base64-js\n\t\t\t\tfunction Base64toByteArray( b64 ) {\n\n\t\t\t\t\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar lookup = [];\n\t\t\t\t\tvar revLookup = [];\n\t\t\t\t\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\t\t\t\tvar len = code.length;\n\n\t\t\t\t\tfor ( i = 0; i < len; i ++ ) {\n\n\t\t\t\t\t\tlookup[ i ] = code[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( i = 0; i < len; ++ i ) {\n\n\t\t\t\t\t\trevLookup[ code.charCodeAt( i ) ] = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t\trevLookup[ '-'.charCodeAt( 0 ) ] = 62;\n\t\t\t\t\trevLookup[ '_'.charCodeAt( 0 ) ] = 63;\n\n\t\t\t\t\tvar j, l, tmp, placeHolders, arr;\n\t\t\t\t\tvar len = b64.length;\n\n\t\t\t\t\tif ( len % 4 > 0 ) {\n\n\t\t\t\t\t\tthrow new Error( 'Invalid string. Length must be a multiple of 4' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tplaceHolders = b64[ len - 2 ] === '=' ? 2 : b64[ len - 1 ] === '=' ? 1 : 0;\n\t\t\t\t\tarr = new Arr( len * 3 / 4 - placeHolders );\n\t\t\t\t\tl = placeHolders > 0 ? len - 4 : len;\n\n\t\t\t\t\tvar L = 0;\n\n\t\t\t\t\tfor ( i = 0, j = 0; i < l; i += 4, j += 3 ) {\n\n\t\t\t\t\t\ttmp = ( revLookup[ b64.charCodeAt( i ) ] << 18 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 12 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] << 6 ) | revLookup[ b64.charCodeAt( i + 3 ) ];\n\t\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF0000 ) >> 16;\n\t\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF00 ) >> 8;\n\t\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( placeHolders === 2 ) {\n\n\t\t\t\t\t\ttmp = ( revLookup[ b64.charCodeAt( i ) ] << 2 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] >> 4 );\n\t\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t\t} else if ( placeHolders === 1 ) {\n\n\t\t\t\t\t\ttmp = ( revLookup[ b64.charCodeAt( i ) ] << 10 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 4 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] >> 2 );\n\t\t\t\t\t\tarr[ L ++ ] = ( tmp >> 8 ) & 0xFF;\n\t\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn arr;\n\n\t\t\t\t}\n\n\t\t\t\tfunction parseDataArray( ele, compressed ) {\n\n\t\t\t\t\tvar numBytes = 0;\n\n\t\t\t\t\tif ( json.attributes.header_type === 'UInt64' ) {\n\n\t\t\t\t\t\tnumBytes = 8;\n\n\t\t\t\t\t}\telse if ( json.attributes.header_type === 'UInt32' ) {\n\n\t\t\t\t\t\tnumBytes = 4;\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// Check the format\n\t\t\t\t\tif ( ele.attributes.format === 'binary' && compressed ) {\n\n\t\t\t\t\t\tvar rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n\n\t\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\t\tvar txt = new Float32Array( );\n\n\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\t\tvar txt = new Int32Array( );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// VTP data with the header has the following structure:\n\t\t\t\t\t\t// [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n\t\t\t\t\t\t// [#blocks] = Number of blocks\n\t\t\t\t\t\t// [#u-size] = Block size before compression\n\t\t\t\t\t\t// [#p-size] = Size of last partial block (zero if it not needed)\n\t\t\t\t\t\t// [#c-size-i] = Size in bytes of block i after compression\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n\t\t\t\t\t\t// computed by summing the compressed block sizes from preceding blocks according to the header.\n\n\t\t\t\t\t\trawData = ele[ '#text' ];\n\n\t\t\t\t\t\tbyteData = Base64toByteArray( rawData );\n\n\t\t\t\t\t\tblocks = byteData[ 0 ];\n\t\t\t\t\t\tfor ( var i = 1; i < numBytes - 1; i ++ ) {\n\n\t\t\t\t\t\t\tblocks = blocks | ( byteData[ i ] << ( i * numBytes ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\theaderSize = ( blocks + 3 ) * numBytes;\n\t\t\t\t\t\tpadding = ( ( headerSize % 3 ) > 0 ) ? 3 - ( headerSize % 3 ) : 0;\n\t\t\t\t\t\theaderSize = headerSize + padding;\n\n\t\t\t\t\t\tdataOffsets = [];\n\t\t\t\t\t\tcurrentOffset = headerSize;\n\t\t\t\t\t\tdataOffsets.push( currentOffset );\n\n\t\t\t\t\t\t// Get the blocks sizes after the compression.\n\t\t\t\t\t\t// There are three blocks before c-size-i, so we skip 3*numBytes\n\t\t\t\t\t\tcSizeStart = 3 * numBytes;\n\n\t\t\t\t\t\tfor ( var i = 0; i < blocks; i ++ ) {\n\n\t\t\t\t\t\t\tvar currentBlockSize = byteData[ i * numBytes + cSizeStart ];\n\n\t\t\t\t\t\t\tfor ( var j = 1; j < numBytes - 1; j ++ ) {\n\n\t\t\t\t\t\t\t\t// Each data point consists of 8 bytes regardless of the header type\n\t\t\t\t\t\t\t\tcurrentBlockSize = currentBlockSize | ( byteData[ i * numBytes + cSizeStart + j ] << ( j * 8 ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcurrentOffset = currentOffset + currentBlockSize;\n\t\t\t\t\t\t\tdataOffsets.push( currentOffset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( var i = 0; i < dataOffsets.length - 1; i ++ ) {\n\n\t\t\t\t\t\t\tvar inflate = new Zlib.Inflate( byteData.slice( dataOffsets[ i ], dataOffsets[ i + 1 ] ), { resize: true, verify: true } ); // eslint-disable-line no-undef\n\t\t\t\t\t\t\tcontent = inflate.decompress();\n\t\t\t\t\t\t\tcontent = content.buffer;\n\n\t\t\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\t\t\tcontent = new Float32Array( content );\n\t\t\t\t\t\t\t\ttxt = Float32Concat( txt, content );\n\n\t\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\t\t\tcontent = new Int32Array( content );\n\t\t\t\t\t\t\t\ttxt = Int32Concat( txt, content );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete ele[ '#text' ];\n\n\t\t\t\t\t\tif ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\n\n\t\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\n\n\t\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) return true;\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ele.attributes.format === 'binary' && ! compressed ) {\n\n\t\t\t\t\t\t\tvar content = Base64toByteArray( ele[ '#text' ] );\n\n\t\t\t\t\t\t\t//  VTP data for the uncompressed case has the following structure:\n\t\t\t\t\t\t\t// [#bytes][DATA]\n\t\t\t\t\t\t\t// where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\t\t\t\t\t\t\tcontent = content.slice( numBytes ).buffer;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( ele[ '#text' ] ) {\n\n\t\t\t\t\t\t\t\tvar content = ele[ '#text' ].split( /\\s+/ ).filter( function ( el ) {\n\n\t\t\t\t\t\t\t\t\tif ( el !== '' ) return el;\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar content = new Int32Array( 0 ).buffer;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete ele[ '#text' ];\n\n\t\t\t\t\t\t// Get the content and optimize it\n\t\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\t\tvar txt = new Float32Array( content );\n\n\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int32' ) {\n\n\t\t\t\t\t\t\tvar txt = new Int32Array( content );\n\n\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\t\tvar txt = new Int32Array( content );\n\n\t\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\n\n\t\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\n\n\t\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) return true;\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // endif ( ele.attributes.format === 'binary' && compressed )\n\n\t\t\t\t\treturn txt;\n\n\t\t\t\t}\n\n\t\t\t\t// Main part\n\t\t\t\t// Get Dom\n\t\t\t\tvar dom = null;\n\n\t\t\t\tif ( window.DOMParser ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tdom = ( new DOMParser() ).parseFromString( stringFile, 'text/xml' );\n\n\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\tdom = null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( window.ActiveXObject ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tdom = new ActiveXObject( 'Microsoft.XMLDOM' ); // eslint-disable-line no-undef\n\t\t\t\t\t\tdom.async = false;\n\n\t\t\t\t\t\tif ( ! dom.loadXML( /* xml */ ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( dom.parseError.reason + dom.parseError.srcText );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\tdom = null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'Cannot parse xml string!' );\n\n\t\t\t\t}\n\n\t\t\t\t// Get the doc\n\t\t\t\tvar doc = dom.documentElement;\n\t\t\t\t// Convert to json\n\t\t\t\tvar json = xmlToJson( doc );\n\t\t\t\tvar points = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar indices = [];\n\n\t\t\t\tif ( json.PolyData ) {\n\n\t\t\t\t\tvar piece = json.PolyData.Piece;\n\t\t\t\t\tvar compressed = json.attributes.hasOwnProperty( 'compressor' );\n\n\t\t\t\t\t// Can be optimized\n\t\t\t\t\t// Loop through the sections\n\t\t\t\t\tvar sections = [ 'PointData', 'Points', 'Strips', 'Polys' ];// +['CellData', 'Verts', 'Lines'];\n\t\t\t\t\tvar sectionIndex = 0, numberOfSections = sections.length;\n\n\t\t\t\t\twhile ( sectionIndex < numberOfSections ) {\n\n\t\t\t\t\t\tvar section = piece[ sections[ sectionIndex ] ];\n\n\t\t\t\t\t\t// If it has a DataArray in it\n\n\t\t\t\t\t\tif ( section && section.DataArray ) {\n\n\t\t\t\t\t\t\t// Depending on the number of DataArrays\n\n\t\t\t\t\t\t\tif ( Object.prototype.toString.call( section.DataArray ) === '[object Array]' ) {\n\n\t\t\t\t\t\t\t\tvar arr = section.DataArray;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar arr = [ section.DataArray ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar dataArrayIndex = 0, numberOfDataArrays = arr.length;\n\n\t\t\t\t\t\t\twhile ( dataArrayIndex < numberOfDataArrays ) {\n\n\t\t\t\t\t\t\t\t// Parse the DataArray\n\t\t\t\t\t\t\t\tif ( ( '#text' in arr[ dataArrayIndex ] ) && ( arr[ dataArrayIndex ][ '#text' ].length > 0 ) ) {\n\n\t\t\t\t\t\t\t\t\tarr[ dataArrayIndex ].text = parseDataArray( arr[ dataArrayIndex ], compressed );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tdataArrayIndex ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tswitch ( sections[ sectionIndex ] ) {\n\n\t\t\t\t\t\t\t\t// if iti is point data\n\t\t\t\t\t\t\t\tcase 'PointData':\n\n\t\t\t\t\t\t\t\t\tvar numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\n\t\t\t\t\t\t\t\t\tvar normalsName = section.attributes.Normals;\n\n\t\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tfor ( var i = 0, len = arr.length; i < len; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( normalsName === arr[ i ].attributes.Name ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar components = arr[ i ].attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\t\t\t\tnormals = new Float32Array( numberOfPoints * components );\n\t\t\t\t\t\t\t\t\t\t\t\tnormals.set( arr[ i ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t// if it is points\n\t\t\t\t\t\t\t\tcase 'Points':\n\n\t\t\t\t\t\t\t\t\tvar numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\n\n\t\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tvar components = section.DataArray.attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\t\tpoints = new Float32Array( numberOfPoints * components );\n\t\t\t\t\t\t\t\t\t\tpoints.set( section.DataArray.text, 0 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t// if it is strips\n\t\t\t\t\t\t\t\tcase 'Strips':\n\n\t\t\t\t\t\t\t\t\tvar numberOfStrips = parseInt( piece.attributes.NumberOfStrips );\n\n\t\t\t\t\t\t\t\t\tif ( numberOfStrips > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tvar connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\n\t\t\t\t\t\t\t\t\t\tvar offset = new Int32Array( section.DataArray[ 1 ].text.length );\n\t\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\n\t\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\tvar size = numberOfStrips + connectivity.length;\n\t\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\n\t\t\t\t\t\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\t\t\t\t\t\tfor ( var i = 0, len = numberOfStrips; i < len; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar strip = [];\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( var s = 0, len1 = offset[ i ], len0 = 0; s < len1 - len0; s ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tstrip.push( connectivity[ s ] );\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) len0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( var j = 0, len1 = offset[ i ], len0 = 0; j < len1 - len0 - 2; j ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( j % 2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) len0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t// if it is polys\n\t\t\t\t\t\t\t\tcase 'Polys':\n\n\t\t\t\t\t\t\t\t\tvar numberOfPolys = parseInt( piece.attributes.NumberOfPolys );\n\n\t\t\t\t\t\t\t\t\tif ( numberOfPolys > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tvar connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\n\t\t\t\t\t\t\t\t\t\tvar offset = new Int32Array( section.DataArray[ 1 ].text.length );\n\t\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\n\t\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\tvar size = numberOfPolys + connectivity.length;\n\t\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfPolys );\n\t\t\t\t\t\t\t\t\t\tvar indicesIndex = 0, connectivityIndex = 0;\n\t\t\t\t\t\t\t\t\t\tvar i = 0, len = numberOfPolys, len0 = 0;\n\n\t\t\t\t\t\t\t\t\t\twhile ( i < len ) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar poly = [];\n\t\t\t\t\t\t\t\t\t\t\tvar s = 0, len1 = offset[ i ];\n\n\t\t\t\t\t\t\t\t\t\t\twhile ( s < len1 - len0 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpoly.push( connectivity[ connectivityIndex ++ ] );\n\t\t\t\t\t\t\t\t\t\t\t\ts ++;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tvar j = 1;\n\n\t\t\t\t\t\t\t\t\t\t\twhile ( j < len1 - len0 - 1 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ 0 ];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j + 1 ];\n\t\t\t\t\t\t\t\t\t\t\t\tj ++;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\ti ++;\n\t\t\t\t\t\t\t\t\t\t\tlen0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsectionIndex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( points, 3 ) );\n\n\t\t\t\t\tif ( normals.length === points.length ) {\n\n\t\t\t\t\t\tgeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'Unsupported DATASET type' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getStringFile( data ) {\n\n\t\t\t\tvar stringFile = '';\n\t\t\t\tvar charArray = new Uint8Array( data );\n\t\t\t\tvar i = 0;\n\t\t\t\tvar len = charArray.length;\n\n\t\t\t\twhile ( len -- ) {\n\n\t\t\t\t\tstringFile += String.fromCharCode( charArray[ i ++ ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn stringFile;\n\n\t\t\t}\n\n\t\t\t// get the 5 first lines of the files to check if there is the key word binary\n\t\t\tvar meta = THREE.LoaderUtils.decodeText( new Uint8Array( data, 0, 250 ) ).split( '\\n' );\n\n\t\t\tif ( meta[ 0 ].indexOf( 'xml' ) !== - 1 ) {\n\n\t\t\t\treturn parseXML( getStringFile( data ) );\n\n\t\t\t} else if ( meta[ 2 ].includes( 'ASCII' ) ) {\n\n\t\t\t\treturn parseASCII( getStringFile( data ) );\n\n\t\t\t} else {\n\n\t\t\t\treturn parseBinary( data );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.VTKLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/XLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author adrs2002 / https://github.com/adrs2002\n\t */\n\n\tTHREE.XLoader = ( function () {\n\n\t\tvar classCallCheck = function ( instance, Constructor ) {\n\n\t\t\tif ( ! ( instance instanceof Constructor ) ) {\n\n\t\t\t\tthrow new TypeError( \"Cannot call a class as a function\" );\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar createClass = function () {\n\n\t\t\tfunction defineProperties( target, props ) {\n\n\t\t\t\tfor ( var i = 0; i < props.length; i ++ ) {\n\n\t\t\t\t\tvar descriptor = props[ i ];\n\t\t\t\t\tdescriptor.enumerable = descriptor.enumerable || false;\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t\tif ( \"value\" in descriptor ) descriptor.writable = true;\n\t\t\t\t\tObject.defineProperty( target, descriptor.key, descriptor );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn function ( Constructor, protoProps, staticProps ) {\n\n\t\t\t\tif ( protoProps ) defineProperties( Constructor.prototype, protoProps );\n\t\t\t\tif ( staticProps ) defineProperties( Constructor, staticProps );\n\t\t\t\treturn Constructor;\n\n\t\t\t};\n\n\t\t}();\n\n\t\tvar XboneInf = function XboneInf() {\n\n\t\t\tclassCallCheck( this, XboneInf );\n\n\t\t\tthis.boneName = \"\";\n\t\t\tthis.BoneIndex = 0;\n\t\t\tthis.Indeces = [];\n\t\t\tthis.Weights = [];\n\t\t\tthis.initMatrix = null;\n\t\t\tthis.OffsetMatrix = null;\n\n\t\t};\n\n\t\tvar XAnimationInfo = function XAnimationInfo() {\n\n\t\t\tclassCallCheck( this, XAnimationInfo );\n\n\t\t\tthis.animeName = \"\";\n\t\t\tthis.boneName = \"\";\n\t\t\tthis.targetBone = null;\n\t\t\tthis.keyType = 4;\n\t\t\tthis.frameStartLv = 0;\n\t\t\tthis.keyFrames = [];\n\t\t\tthis.InverseMx = null;\n\n\t\t};\n\n\t\tvar XAnimationObj = function () {\n\n\t\t\tfunction XAnimationObj( _flags ) {\n\n\t\t\t\tclassCallCheck( this, XAnimationObj );\n\n\t\t\t\tthis.fps = 30;\n\t\t\t\tthis.name = 'xanimation';\n\t\t\t\tthis.length = 0;\n\t\t\t\tthis.hierarchy = [];\n\t\t\t\tthis.putFlags = _flags;\n\t\t\t\tif ( this.putFlags.putPos === undefined ) {\n\n\t\t\t\t\tthis.putFlags.putPos = true;\n\n\t\t\t\t}\n\t\t\t\tif ( this.putFlags.putRot === undefined ) {\n\n\t\t\t\t\tthis.putFlags.putRot = true;\n\n\t\t\t\t}\n\t\t\t\tif ( this.putFlags.putScl === undefined ) {\n\n\t\t\t\t\tthis.putFlags.putScl = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcreateClass( XAnimationObj, [ {\n\t\t\t\tkey: \"make\",\n\t\t\t\tvalue: function make( XAnimationInfoArray ) {\n\n\t\t\t\t\tfor ( var i = 0; i < XAnimationInfoArray.length; i ++ ) {\n\n\t\t\t\t\t\tthis.hierarchy.push( this.makeBonekeys( XAnimationInfoArray[ i ] ) );\n\n\t\t\t\t\t}\n\t\t\t\t\tthis.length = this.hierarchy[ 0 ].keys[ this.hierarchy[ 0 ].keys.length - 1 ].time;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: \"clone\",\n\t\t\t\tvalue: function clone() {\n\n\t\t\t\t\treturn Object.assign( {}, this );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: \"makeBonekeys\",\n\t\t\t\tvalue: function makeBonekeys( XAnimationInfo ) {\n\n\t\t\t\t\tvar refObj = {};\n\t\t\t\t\trefObj.name = XAnimationInfo.boneName;\n\t\t\t\t\trefObj.parent = \"\";\n\t\t\t\t\trefObj.keys = this.keyFrameRefactor( XAnimationInfo );\n\t\t\t\t\trefObj.copy = function () {\n\n\t\t\t\t\t\treturn Object.assign( {}, this );\n\n\t\t\t\t\t};\n\t\t\t\t\treturn refObj;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: \"keyFrameRefactor\",\n\t\t\t\tvalue: function keyFrameRefactor( XAnimationInfo ) {\n\n\t\t\t\t\tvar keys = [];\n\t\t\t\t\tfor ( var i = 0; i < XAnimationInfo.keyFrames.length; i ++ ) {\n\n\t\t\t\t\t\tvar keyframe = {};\n\t\t\t\t\t\tkeyframe.time = XAnimationInfo.keyFrames[ i ].time * this.fps;\n\t\t\t\t\t\tif ( XAnimationInfo.keyFrames[ i ].pos && this.putFlags.putPos ) {\n\n\t\t\t\t\t\t\tkeyframe.pos = XAnimationInfo.keyFrames[ i ].pos;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( XAnimationInfo.keyFrames[ i ].rot && this.putFlags.putRot ) {\n\n\t\t\t\t\t\t\tkeyframe.rot = XAnimationInfo.keyFrames[ i ].rot;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( XAnimationInfo.keyFrames[ i ].scl && this.putFlags.putScl ) {\n\n\t\t\t\t\t\t\tkeyframe.scl = XAnimationInfo.keyFrames[ i ].scl;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( XAnimationInfo.keyFrames[ i ].matrix ) {\n\n\t\t\t\t\t\t\tkeyframe.matrix = XAnimationInfo.keyFrames[ i ].matrix;\n\t\t\t\t\t\t\tif ( this.putFlags.putPos ) {\n\n\t\t\t\t\t\t\t\tkeyframe.pos = new THREE.Vector3().setFromMatrixPosition( keyframe.matrix );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( this.putFlags.putRot ) {\n\n\t\t\t\t\t\t\t\tkeyframe.rot = new THREE.Quaternion().setFromRotationMatrix( keyframe.matrix );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( this.putFlags.putScl ) {\n\n\t\t\t\t\t\t\t\tkeyframe.scl = new THREE.Vector3().setFromMatrixScale( keyframe.matrix );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkeys.push( keyframe );\n\n\t\t\t\t\t}\n\t\t\t\t\treturn keys;\n\n\t\t\t\t}\n\t\t\t} ] );\n\t\t\treturn XAnimationObj;\n\n\t\t}();\n\n\t\tvar XKeyFrameInfo = function XKeyFrameInfo() {\n\n\t\t\tclassCallCheck( this, XKeyFrameInfo );\n\n\t\t\tthis.index = 0;\n\t\t\tthis.Frame = 0;\n\t\t\tthis.time = 0.0;\n\t\t\tthis.matrix = null;\n\n\t\t};\n\n\t\tvar XLoader = function () {\n\n\t\t\tfunction XLoader( manager ) {\n\n\t\t\t\tTHREE.Loader.call( this, manager );\n\n\t\t\t\tclassCallCheck( this, XLoader );\n\n\t\t\t\tthis.debug = false;\n\t\t\t\tthis.texloader = new THREE.TextureLoader( this.manager );\n\t\t\t\tthis.url = \"\";\n\t\t\t\tthis._putMatLength = 0;\n\t\t\t\tthis._nowMat = null;\n\t\t\t\tthis._nowFrameName = \"\";\n\t\t\t\tthis.frameHierarchie = [];\n\t\t\t\tthis.Hierarchies = {};\n\t\t\t\tthis.HieStack = [];\n\t\t\t\tthis._currentObject = {};\n\t\t\t\tthis._currentFrame = {};\n\t\t\t\tthis._data = null;\n\t\t\t\tthis.onLoad = null;\n\t\t\t\tthis.IsUvYReverse = true;\n\t\t\t\tthis.Meshes = [];\n\t\t\t\tthis.animations = [];\n\t\t\t\tthis.animTicksPerSecond = 30;\n\t\t\t\tthis._currentGeo = null;\n\t\t\t\tthis._currentAnime = null;\n\t\t\t\tthis._currentAnimeFrames = null;\n\n\t\t\t}\n\n\t\t\tcreateClass( XLoader, [ {\n\t\t\t\tkey: '_setArgOption',\n\t\t\t\tvalue: function _setArgOption( _arg ) {\n\n\t\t\t\t\tvar _start = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;\n\n\t\t\t\t\tif ( ! _arg ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\t\t\t\t\tfor ( var i = _start; i < _arg.length; i ++ ) {\n\n\t\t\t\t\t\tswitch ( i ) {\n\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tthis.url = _arg[ i ];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tthis.options = _arg[ i ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( this.options === undefined ) {\n\n\t\t\t\t\t\tthis.options = {};\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'load',\n\t\t\t\tvalue: function load( _arg, onLoad, onProgress, onError ) {\n\n\t\t\t\t\tvar _this = this;\n\n\t\t\t\t\tthis._setArgOption( _arg );\n\t\t\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\t\t\tloader.setPath( this.path );\n\t\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\t\t\tloader.load( this.url, function ( response ) {\n\n\t\t\t\t\t\t_this.parse( response, onLoad );\n\n\t\t\t\t\t}, onProgress, onError );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_readLine',\n\t\t\t\tvalue: function _readLine( line ) {\n\n\t\t\t\t\tvar readed = 0;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tvar find = - 1;\n\t\t\t\t\t\tfind = line.indexOf( '//', readed );\n\t\t\t\t\t\tif ( find === - 1 ) {\n\n\t\t\t\t\t\t\tfind = line.indexOf( '#', readed );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( find > - 1 && find < 2 ) {\n\n\t\t\t\t\t\t\tvar foundNewLine = - 1;\n\t\t\t\t\t\t\tfoundNewLine = line.indexOf( \"\\r\\n\", readed );\n\t\t\t\t\t\t\tif ( foundNewLine > 0 ) {\n\n\t\t\t\t\t\t\t\treaded = foundNewLine + 2;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tfoundNewLine = line.indexOf( \"\\r\", readed );\n\t\t\t\t\t\t\t\tif ( foundNewLine > 0 ) {\n\n\t\t\t\t\t\t\t\t\treaded = foundNewLine + 1;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\treaded = line.indexOf( \"\\n\", readed ) + 1;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn line.substr( readed );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_readLine',\n\t\t\t\tvalue: function _readLine( line ) {\n\n\t\t\t\t\tvar readed = 0;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tvar find = - 1;\n\t\t\t\t\t\tfind = line.indexOf( '//', readed );\n\t\t\t\t\t\tif ( find === - 1 ) {\n\n\t\t\t\t\t\t\tfind = line.indexOf( '#', readed );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( find > - 1 && find < 2 ) {\n\n\t\t\t\t\t\t\tvar foundNewLine = - 1;\n\t\t\t\t\t\t\tfoundNewLine = line.indexOf( \"\\r\\n\", readed );\n\t\t\t\t\t\t\tif ( foundNewLine > 0 ) {\n\n\t\t\t\t\t\t\t\treaded = foundNewLine + 2;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tfoundNewLine = line.indexOf( \"\\r\", readed );\n\t\t\t\t\t\t\t\tif ( foundNewLine > 0 ) {\n\n\t\t\t\t\t\t\t\t\treaded = foundNewLine + 1;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\treaded = line.indexOf( \"\\n\", readed ) + 1;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn line.substr( readed );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_isBinary',\n\t\t\t\tvalue: function _isBinary( binData ) {\n\n\t\t\t\t\tvar reader = new DataView( binData );\n\t\t\t\t\tvar face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\n\t\t\t\t\tvar n_faces = reader.getUint32( 80, true );\n\t\t\t\t\tvar expect = 80 + 32 / 8 + n_faces * face_size;\n\t\t\t\t\tif ( expect === reader.byteLength ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\t\t\t\t\tvar fileLength = reader.byteLength;\n\t\t\t\t\tfor ( var index = 0; index < fileLength; index ++ ) {\n\n\t\t\t\t\t\tif ( reader.getUint8( index, false ) > 127 ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_ensureBinary',\n\t\t\t\tvalue: function _ensureBinary( buf ) {\n\n\t\t\t\t\tif ( typeof buf === \"string\" ) {\n\n\t\t\t\t\t\tvar array_buffer = new Uint8Array( buf.length );\n\t\t\t\t\t\tfor ( var i = 0; i < buf.length; i ++ ) {\n\n\t\t\t\t\t\t\tarray_buffer[ i ] = buf.charCodeAt( i ) & 0xff;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn array_buffer.buffer || array_buffer;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn buf;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_ensureString',\n\t\t\t\tvalue: function _ensureString( buf ) {\n\n\t\t\t\t\tif ( typeof buf !== \"string\" ) {\n\n\t\t\t\t\t\treturn THREE.LoaderUtils.decodeText( new Uint8Array( buf ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn buf;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'parse',\n\t\t\t\tvalue: function _parse( data, onLoad ) {\n\n\t\t\t\t\tvar binData = this._ensureBinary( data );\n\t\t\t\t\tthis._data = this._ensureString( data );\n\t\t\t\t\tthis.onLoad = onLoad;\n\t\t\t\t\treturn this._isBinary( binData ) ? this._parseBinary( binData ) : this._parseASCII();\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_parseBinary',\n\t\t\t\tvalue: function _parseBinary( data ) {\n\n\t\t\t\t\treturn this._parseASCII( THREE.LoaderUtils.decodeText( new Uint8Array( data ) ) );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_parseASCII',\n\t\t\t\tvalue: function _parseASCII() {\n\n\t\t\t\t\tvar path;\n\n\t\t\t\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\t\t\t\tpath = this.resourcePath;\n\n\t\t\t\t\t} else if ( this.path !== '' ) {\n\n\t\t\t\t\t\tpath = this.path;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpath = THREE.LoaderUtils.extractUrlBase( this.url );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.texloader.setPath( path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\t\t\tvar endRead = 16;\n\t\t\t\t\tthis.Hierarchies.children = [];\n\t\t\t\t\tthis._hierarchieParse( this.Hierarchies, endRead );\n\t\t\t\t\tthis._changeRoot();\n\t\t\t\t\tthis._currentObject = this.Hierarchies.children.shift();\n\t\t\t\t\tthis._mainloop();\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_hierarchieParse',\n\t\t\t\tvalue: function _hierarchieParse( _parent, _end ) {\n\n\t\t\t\t\tvar endRead = _end;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tvar find1 = this._data.indexOf( '{', endRead ) + 1;\n\t\t\t\t\t\tvar findEnd = this._data.indexOf( '}', endRead );\n\t\t\t\t\t\tvar findNext = this._data.indexOf( '{', find1 ) + 1;\n\t\t\t\t\t\tif ( find1 > 0 && findEnd > find1 ) {\n\n\t\t\t\t\t\t\tvar _currentObject = {};\n\t\t\t\t\t\t\t_currentObject.children = [];\n\t\t\t\t\t\t\tvar nameData = this._readLine( this._data.substr( endRead, find1 - endRead - 1 ) ).trim();\n\t\t\t\t\t\t\tvar word = nameData.split( / /g );\n\t\t\t\t\t\t\tif ( word.length > 0 ) {\n\n\t\t\t\t\t\t\t\t_currentObject.type = word[ 0 ];\n\t\t\t\t\t\t\t\tif ( word.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t_currentObject.name = word[ 1 ];\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t_currentObject.name = word[ 0 ] + this.Hierarchies.children.length;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t_currentObject.name = nameData;\n\t\t\t\t\t\t\t\t_currentObject.type = \"\";\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( _currentObject.type === \"Animation\" ) {\n\n\t\t\t\t\t\t\t\t_currentObject.data = this._data.substr( findNext, findEnd - findNext ).trim();\n\t\t\t\t\t\t\t\tvar refs = this._hierarchieParse( _currentObject, findEnd + 1 );\n\t\t\t\t\t\t\t\tendRead = refs.end;\n\t\t\t\t\t\t\t\t_currentObject.children = refs.parent.children;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar DataEnder = this._data.lastIndexOf( ';', findNext > 0 ? Math.min( findNext, findEnd ) : findEnd );\n\t\t\t\t\t\t\t\t_currentObject.data = this._data.substr( find1, DataEnder - find1 ).trim();\n\t\t\t\t\t\t\t\tif ( findNext <= 0 || findEnd < findNext ) {\n\n\t\t\t\t\t\t\t\t\tendRead = findEnd + 1;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tvar nextStart = Math.max( DataEnder + 1, find1 );\n\t\t\t\t\t\t\t\t\tvar _refs = this._hierarchieParse( _currentObject, nextStart );\n\t\t\t\t\t\t\t\t\tendRead = _refs.end;\n\t\t\t\t\t\t\t\t\t_currentObject.children = _refs.parent.children;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_currentObject.parent = _parent;\n\t\t\t\t\t\t\tif ( _currentObject.type != \"template\" ) {\n\n\t\t\t\t\t\t\t\t_parent.children.push( _currentObject );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tendRead = find1 === - 1 ? this._data.length : findEnd + 1;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tparent: _parent,\n\t\t\t\t\t\tend: endRead\n\t\t\t\t\t};\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_mainloop',\n\t\t\t\tvalue: function _mainloop() {\n\n\t\t\t\t\tvar _this2 = this;\n\n\t\t\t\t\tthis._mainProc();\n\t\t\t\t\tif ( this._currentObject.parent || this._currentObject.children.length > 0 || ! this._currentObject.worked ) {\n\n\t\t\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\t\t\t_this2._mainloop();\n\n\t\t\t\t\t\t}, 1 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\t\t\t_this2.onLoad( {\n\t\t\t\t\t\t\t\tmodels: _this2.Meshes,\n\t\t\t\t\t\t\t\tanimations: _this2.animations\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_mainProc',\n\t\t\t\tvalue: function _mainProc() {\n\n\t\t\t\t\tvar breakFlag = false;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tif ( ! this._currentObject.worked ) {\n\n\t\t\t\t\t\t\tswitch ( this._currentObject.type ) {\n\n\t\t\t\t\t\t\t\tcase \"template\":\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"AnimTicksPerSecond\":\n\t\t\t\t\t\t\t\t\tthis.animTicksPerSecond = parseInt( this._currentObject.data );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"Frame\":\n\t\t\t\t\t\t\t\t\tthis._setFrame();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"FrameTransformMatrix\":\n\t\t\t\t\t\t\t\t\tthis._setFrameTransformMatrix();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"Mesh\":\n\t\t\t\t\t\t\t\t\tthis._changeRoot();\n\t\t\t\t\t\t\t\t\tthis._currentGeo = {};\n\t\t\t\t\t\t\t\t\tthis._currentGeo.name = this._currentObject.name.trim();\n\t\t\t\t\t\t\t\t\tthis._currentGeo.parentName = this._getParentName( this._currentObject ).trim();\n\t\t\t\t\t\t\t\t\tthis._currentGeo.VertexSetedBoneCount = [];\n\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData = {\n\t\t\t\t\t\t\t\t\t\tvertices: [],\n\t\t\t\t\t\t\t\t\t\tnormals: [],\n\t\t\t\t\t\t\t\t\t\tuvs: [],\n\t\t\t\t\t\t\t\t\t\tskinIndices: [],\n\t\t\t\t\t\t\t\t\t\tskinWeights: [],\n\t\t\t\t\t\t\t\t\t\tindices: [],\n\t\t\t\t\t\t\t\t\t\tmaterialIndices: []\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tthis._currentGeo.Materials = [];\n\t\t\t\t\t\t\t\t\tthis._currentGeo.normalVectors = [];\n\t\t\t\t\t\t\t\t\tthis._currentGeo.BoneInfs = [];\n\t\t\t\t\t\t\t\t\tthis._currentGeo.baseFrame = this._currentFrame;\n\t\t\t\t\t\t\t\t\tthis._makeBoneFrom_CurrentFrame();\n\t\t\t\t\t\t\t\t\tthis._readVertexDatas();\n\t\t\t\t\t\t\t\t\tbreakFlag = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"MeshNormals\":\n\t\t\t\t\t\t\t\t\tthis._readVertexDatas();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"MeshTextureCoords\":\n\t\t\t\t\t\t\t\t\tthis._setMeshTextureCoords();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"VertexDuplicationIndices\":\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"MeshMaterialList\":\n\t\t\t\t\t\t\t\t\tthis._setMeshMaterialList();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"Material\":\n\t\t\t\t\t\t\t\t\tthis._setMaterial();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"SkinWeights\":\n\t\t\t\t\t\t\t\t\tthis._setSkinWeights();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"AnimationSet\":\n\t\t\t\t\t\t\t\t\tthis._changeRoot();\n\t\t\t\t\t\t\t\t\tthis._currentAnime = {};\n\t\t\t\t\t\t\t\t\tthis._currentAnime.name = this._currentObject.name.trim();\n\t\t\t\t\t\t\t\t\tthis._currentAnime.AnimeFrames = [];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"Animation\":\n\t\t\t\t\t\t\t\t\tif ( this._currentAnimeFrames ) {\n\n\t\t\t\t\t\t\t\t\t\tthis._currentAnime.AnimeFrames.push( this._currentAnimeFrames );\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tthis._currentAnimeFrames = new XAnimationInfo();\n\t\t\t\t\t\t\t\t\tthis._currentAnimeFrames.boneName = this._currentObject.data.trim();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"AnimationKey\":\n\t\t\t\t\t\t\t\t\tthis._readAnimationKey();\n\t\t\t\t\t\t\t\t\tbreakFlag = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._currentObject.worked = true;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( this._currentObject.children.length > 0 ) {\n\n\t\t\t\t\t\t\tthis._currentObject = this._currentObject.children.shift();\n\t\t\t\t\t\t\tif ( this.debug ) {\n\n\t\t\t\t\t\t\t\tconsole.log( 'processing ' + this._currentObject.name );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( breakFlag ) break;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( this._currentObject.worked ) {\n\n\t\t\t\t\t\t\t\tif ( this._currentObject.parent && ! this._currentObject.parent.parent ) {\n\n\t\t\t\t\t\t\t\t\tthis._changeRoot();\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( this._currentObject.parent ) {\n\n\t\t\t\t\t\t\t\tthis._currentObject = this._currentObject.parent;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tbreakFlag = true;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( breakFlag ) break;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_changeRoot',\n\t\t\t\tvalue: function _changeRoot() {\n\n\t\t\t\t\tif ( this._currentGeo != null && this._currentGeo.name ) {\n\n\t\t\t\t\t\tthis._makeOutputGeometry();\n\n\t\t\t\t\t}\n\t\t\t\t\tthis._currentGeo = {};\n\t\t\t\t\tif ( this._currentAnime != null && this._currentAnime.name ) {\n\n\t\t\t\t\t\tif ( this._currentAnimeFrames ) {\n\n\t\t\t\t\t\t\tthis._currentAnime.AnimeFrames.push( this._currentAnimeFrames );\n\t\t\t\t\t\t\tthis._currentAnimeFrames = null;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._makeOutputAnimation();\n\n\t\t\t\t\t}\n\t\t\t\t\tthis._currentAnime = {};\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_getParentName',\n\t\t\t\tvalue: function _getParentName( _obj ) {\n\n\t\t\t\t\tif ( _obj.parent ) {\n\n\t\t\t\t\t\tif ( _obj.parent.name ) {\n\n\t\t\t\t\t\t\treturn _obj.parent.name;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\treturn this._getParentName( _obj.parent );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn \"\";\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_setFrame',\n\t\t\t\tvalue: function _setFrame() {\n\n\t\t\t\t\tthis._nowFrameName = this._currentObject.name.trim();\n\t\t\t\t\tthis._currentFrame = {};\n\t\t\t\t\tthis._currentFrame.name = this._nowFrameName;\n\t\t\t\t\tthis._currentFrame.children = [];\n\t\t\t\t\tif ( this._currentObject.parent && this._currentObject.parent.name ) {\n\n\t\t\t\t\t\tthis._currentFrame.parentName = this._currentObject.parent.name;\n\n\t\t\t\t\t}\n\t\t\t\t\tthis.frameHierarchie.push( this._nowFrameName );\n\t\t\t\t\tthis.HieStack[ this._nowFrameName ] = this._currentFrame;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_setFrameTransformMatrix',\n\t\t\t\tvalue: function _setFrameTransformMatrix() {\n\n\t\t\t\t\tthis._currentFrame.FrameTransformMatrix = new THREE.Matrix4();\n\t\t\t\t\tvar data = this._currentObject.data.split( \",\" );\n\t\t\t\t\tthis._ParseMatrixData( this._currentFrame.FrameTransformMatrix, data );\n\t\t\t\t\tthis._makeBoneFrom_CurrentFrame();\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_makeBoneFrom_CurrentFrame',\n\t\t\t\tvalue: function _makeBoneFrom_CurrentFrame() {\n\n\t\t\t\t\tif ( ! this._currentFrame.FrameTransformMatrix ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\t\t\t\t\tvar b = new THREE.Bone();\n\t\t\t\t\tb.name = this._currentFrame.name;\n\t\t\t\t\tb.applyMatrix4( this._currentFrame.FrameTransformMatrix );\n\t\t\t\t\tb.matrixWorld = b.matrix;\n\t\t\t\t\tb.FrameTransformMatrix = this._currentFrame.FrameTransformMatrix;\n\t\t\t\t\tthis._currentFrame.putBone = b;\n\t\t\t\t\tif ( this._currentFrame.parentName ) {\n\n\t\t\t\t\t\tfor ( var frame in this.HieStack ) {\n\n\t\t\t\t\t\t\tif ( this.HieStack[ frame ].name === this._currentFrame.parentName ) {\n\n\t\t\t\t\t\t\t\tthis.HieStack[ frame ].putBone.add( this._currentFrame.putBone );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_readVertexDatas',\n\t\t\t\tvalue: function _readVertexDatas() {\n\n\t\t\t\t\tvar endRead = 0;\n\t\t\t\t\tvar mode = 0;\n\t\t\t\t\tvar mode_local = 0;\n\t\t\t\t\tvar maxLength = 0;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tvar changeMode = false;\n\t\t\t\t\t\tif ( mode_local === 0 ) {\n\n\t\t\t\t\t\t\tvar refO = this._readInt1( endRead );\n\t\t\t\t\t\t\tendRead = refO.endRead;\n\t\t\t\t\t\t\tmode_local = 1;\n\t\t\t\t\t\t\tmaxLength = this._currentObject.data.indexOf( ';;', endRead ) + 1;\n\t\t\t\t\t\t\tif ( maxLength <= 0 ) {\n\n\t\t\t\t\t\t\t\tmaxLength = this._currentObject.data.length;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar find = 0;\n\t\t\t\t\t\t\tswitch ( mode ) {\n\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tfind = this._currentObject.data.indexOf( ',', endRead ) + 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tfind = this._currentObject.data.indexOf( ';,', endRead ) + 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( find === 0 || find > maxLength ) {\n\n\t\t\t\t\t\t\t\tfind = maxLength;\n\t\t\t\t\t\t\t\tmode_local = 0;\n\t\t\t\t\t\t\t\tchangeMode = true;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tswitch ( this._currentObject.type ) {\n\n\t\t\t\t\t\t\t\tcase \"Mesh\":\n\t\t\t\t\t\t\t\t\tswitch ( mode ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\tthis._readVertex1( this._currentObject.data.substr( endRead, find - endRead ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\tthis._readFace1( this._currentObject.data.substr( endRead, find - endRead ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"MeshNormals\":\n\t\t\t\t\t\t\t\t\tswitch ( mode ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\tthis._readNormalVector1( this._currentObject.data.substr( endRead, find - endRead ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\t\t\tif ( changeMode ) {\n\n\t\t\t\t\t\t\t\tmode ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( endRead >= this._currentObject.data.length ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_readInt1',\n\t\t\t\tvalue: function _readInt1( start ) {\n\n\t\t\t\t\tvar find = this._currentObject.data.indexOf( ';', start );\n\t\t\t\t\treturn {\n\t\t\t\t\t\trefI: parseInt( this._currentObject.data.substr( start, find - start ) ),\n\t\t\t\t\t\tendRead: find + 1\n\t\t\t\t\t};\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_readVertex1',\n\t\t\t\tvalue: function _readVertex1( line ) {\n\n\t\t\t\t\tvar data = this._readLine( line.trim() ).substr( 0, line.length - 2 ).split( \";\" );\n\t\t\t\t\tthis._currentGeo.GeometryData.vertices.push( parseFloat( data[ 0 ] ), parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ) );\n\t\t\t\t\tthis._currentGeo.GeometryData.skinIndices.push( 0, 0, 0, 0 );\n\t\t\t\t\tthis._currentGeo.GeometryData.skinWeights.push( 1, 0, 0, 0 );\n\t\t\t\t\tthis._currentGeo.VertexSetedBoneCount.push( 0 );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_readFace1',\n\t\t\t\tvalue: function _readFace1( line ) {\n\n\t\t\t\t\tvar data = this._readLine( line.trim() ).substr( 2, line.length - 4 ).split( \",\" );\n\t\t\t\t\tthis._currentGeo.GeometryData.indices.push( parseInt( data[ 0 ], 10 ), parseInt( data[ 1 ], 10 ), parseInt( data[ 2 ], 10 ) );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_readNormalVector1',\n\t\t\t\tvalue: function _readNormalVector1( line ) {\n\n\t\t\t\t\tvar data = this._readLine( line.trim() ).substr( 0, line.length - 2 ).split( \";\" );\n\t\t\t\t\tthis._currentGeo.GeometryData.normals.push( parseFloat( data[ 0 ] ), parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ) );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_buildGeometry',\n\t\t\t\tvalue: function _buildGeometry() {\n\n\t\t\t\t\tvar bufferGeometry = new THREE.BufferGeometry();\n\t\t\t\t\tvar position = [];\n\t\t\t\t\tvar normals = [];\n\t\t\t\t\tvar uvs = [];\n\t\t\t\t\tvar skinIndices = [];\n\t\t\t\t\tvar skinWeights = [];\n\n\t\t\t\t\t//\n\n\t\t\t\t\tvar data = this._currentGeo.GeometryData;\n\n\t\t\t\t\tfor ( var i = 0, l = data.indices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar stride2 = data.indices[ i ] * 2;\n\t\t\t\t\t\tvar stride3 = data.indices[ i ] * 3;\n\t\t\t\t\t\tvar stride4 = data.indices[ i ] * 4;\n\n\t\t\t\t\t\tposition.push( data.vertices[ stride3 ], data.vertices[ stride3 + 1 ], data.vertices[ stride3 + 2 ] );\n\t\t\t\t\t\tnormals.push( data.normals[ stride3 ], data.normals[ stride3 + 1 ], data.normals[ stride3 + 2 ] );\n\t\t\t\t\t\tskinIndices.push( data.skinIndices[ stride4 ], data.skinIndices[ stride4 + 1 ], data.skinIndices[ stride4 + 2 ], data.skinIndices[ stride4 + 3 ] );\n\t\t\t\t\t\tskinWeights.push( data.skinWeights[ stride4 ], data.skinWeights[ stride4 + 1 ], data.skinWeights[ stride4 + 2 ], data.skinWeights[ stride4 + 3 ] );\n\t\t\t\t\t\tuvs.push( data.uvs[ stride2 ], data.uvs[ stride2 + 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\tbufferGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( position, 3 ) );\n\t\t\t\t\tbufferGeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n\t\t\t\t\tbufferGeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );\n\t\t\t\t\tbufferGeometry.setAttribute( 'skinIndex', new THREE.Uint16BufferAttribute( skinIndices, 4 ) );\n\t\t\t\t\tbufferGeometry.setAttribute( 'skinWeight', new THREE.Float32BufferAttribute( skinWeights, 4 ) );\n\n\t\t\t\t\tthis._computeGroups( bufferGeometry, data.materialIndices );\n\n\t\t\t\t\treturn bufferGeometry;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_computeGroups',\n\t\t\t\tvalue: function _computeGroups( bufferGeometry, materialIndices ) {\n\n\t\t\t\t\tvar group;\n\t\t\t\t\tvar groups = [];\n\t\t\t\t\tvar materialIndex = undefined;\n\n\t\t\t\t\tfor ( var i = 0; i < materialIndices.length; i ++ ) {\n\n\t\t\t\t\t\tvar currentMaterialIndex = materialIndices[ i ];\n\n\t\t\t\t\t\tif ( currentMaterialIndex !== materialIndex ) {\n\n\t\t\t\t\t\t\tmaterialIndex = currentMaterialIndex;\n\n\t\t\t\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgroup = {\n\t\t\t\t\t\t\t\tstart: i * 3,\n\t\t\t\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbufferGeometry.groups = groups;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_setMeshTextureCoords',\n\t\t\t\tvalue: function _setMeshTextureCoords() {\n\n\t\t\t\t\tvar endRead = 0;\n\t\t\t\t\tvar mode = 0;\n\t\t\t\t\tvar mode_local = 0;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tswitch ( mode ) {\n\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tif ( mode_local === 0 ) {\n\n\t\t\t\t\t\t\t\t\tvar refO = this._readInt1( 0 );\n\t\t\t\t\t\t\t\t\tendRead = refO.endRead;\n\t\t\t\t\t\t\t\t\tmode_local = 1;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tvar find = this._currentObject.data.indexOf( ',', endRead ) + 1;\n\t\t\t\t\t\t\t\t\tif ( find === 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tfind = this._currentObject.data.length;\n\t\t\t\t\t\t\t\t\t\tmode = 2;\n\t\t\t\t\t\t\t\t\t\tmode_local = 0;\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tvar line = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\t\t\t\t\tvar data = this._readLine( line.trim() ).split( \";\" );\n\t\t\t\t\t\t\t\t\tif ( this.IsUvYReverse ) {\n\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.uvs.push( parseFloat( data[ 0 ] ), 1 - parseFloat( data[ 1 ] ) );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.uvs.push( parseFloat( data[ 0 ] ), parseFloat( data[ 1 ] ) );\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tendRead = find + 1;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( endRead >= this._currentObject.data.length ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_setMeshMaterialList',\n\t\t\t\tvalue: function _setMeshMaterialList() {\n\n\t\t\t\t\tvar endRead = 0;\n\t\t\t\t\tvar mode = 0;\n\t\t\t\t\tvar mode_local = 0;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tif ( mode_local < 2 ) {\n\n\t\t\t\t\t\t\tvar refO = this._readInt1( endRead );\n\t\t\t\t\t\t\tendRead = refO.endRead;\n\t\t\t\t\t\t\tmode_local ++;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar find = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\t\t\tif ( find === - 1 ) {\n\n\t\t\t\t\t\t\t\tfind = this._currentObject.data.length;\n\t\t\t\t\t\t\t\tmode = 3;\n\t\t\t\t\t\t\t\tmode_local = 0;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar line = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\t\t\tvar data = this._readLine( line.trim() ).split( \",\" );\n\t\t\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.materialIndices[ i ] = parseInt( data[ i ] );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tendRead = this._currentObject.data.length;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( endRead >= this._currentObject.data.length || mode >= 3 ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_setMaterial',\n\t\t\t\tvalue: function _setMaterial() {\n\n\t\t\t\t\tvar _nowMat = new THREE.MeshPhongMaterial( {\n\t\t\t\t\t\tcolor: Math.random() * 0xffffff\n\t\t\t\t\t} );\n\t\t\t\t\t_nowMat.side = THREE.FrontSide;\n\t\t\t\t\t_nowMat.name = this._currentObject.name;\n\t\t\t\t\tvar endRead = 0;\n\t\t\t\t\tvar find = this._currentObject.data.indexOf( ';;', endRead );\n\t\t\t\t\tvar line = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tvar data = this._readLine( line.trim() ).split( \";\" );\n\t\t\t\t\t_nowMat.color.r = parseFloat( data[ 0 ] );\n\t\t\t\t\t_nowMat.color.g = parseFloat( data[ 1 ] );\n\t\t\t\t\t_nowMat.color.b = parseFloat( data[ 2 ] );\n\t\t\t\t\tendRead = find + 2;\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tline = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\t_nowMat.shininess = parseFloat( this._readLine( line ) );\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';;', endRead );\n\t\t\t\t\tline = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tvar data2 = this._readLine( line.trim() ).split( \";\" );\n\t\t\t\t\t_nowMat.specular.r = parseFloat( data2[ 0 ] );\n\t\t\t\t\t_nowMat.specular.g = parseFloat( data2[ 1 ] );\n\t\t\t\t\t_nowMat.specular.b = parseFloat( data2[ 2 ] );\n\t\t\t\t\tendRead = find + 2;\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';;', endRead );\n\t\t\t\t\tif ( find === - 1 ) {\n\n\t\t\t\t\t\tfind = this._currentObject.data.length;\n\n\t\t\t\t\t}\n\t\t\t\t\tline = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tvar data3 = this._readLine( line.trim() ).split( \";\" );\n\t\t\t\t\t_nowMat.emissive.r = parseFloat( data3[ 0 ] );\n\t\t\t\t\t_nowMat.emissive.g = parseFloat( data3[ 1 ] );\n\t\t\t\t\t_nowMat.emissive.b = parseFloat( data3[ 2 ] );\n\t\t\t\t\tvar localObject = null;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tif ( this._currentObject.children.length > 0 ) {\n\n\t\t\t\t\t\t\tlocalObject = this._currentObject.children.shift();\n\t\t\t\t\t\t\tif ( this.debug ) {\n\n\t\t\t\t\t\t\t\tconsole.log( 'processing ' + localObject.name );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar fileName = localObject.data.substr( 1, localObject.data.length - 2 );\n\t\t\t\t\t\t\tswitch ( localObject.type ) {\n\n\t\t\t\t\t\t\t\tcase \"TextureFilename\":\n\t\t\t\t\t\t\t\t\t_nowMat.map = this.texloader.load( fileName );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"BumpMapFilename\":\n\t\t\t\t\t\t\t\t\t_nowMat.bumpMap = this.texloader.load( fileName );\n\t\t\t\t\t\t\t\t\t_nowMat.bumpScale = 0.05;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"NormalMapFilename\":\n\t\t\t\t\t\t\t\t\t_nowMat.normalMap = this.texloader.load( fileName );\n\t\t\t\t\t\t\t\t\t_nowMat.normalScale = new THREE.Vector2( 2, 2 );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"EmissiveMapFilename\":\n\t\t\t\t\t\t\t\t\t_nowMat.emissiveMap = this.texloader.load( fileName );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"LightMapFilename\":\n\t\t\t\t\t\t\t\t\t_nowMat.lightMap = this.texloader.load( fileName );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tthis._currentGeo.Materials.push( _nowMat );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_setSkinWeights',\n\t\t\t\tvalue: function _setSkinWeights() {\n\n\t\t\t\t\tvar boneInf = new XboneInf();\n\t\t\t\t\tvar endRead = 0;\n\t\t\t\t\tvar find = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tvar line = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tboneInf.boneName = line.substr( 1, line.length - 2 );\n\t\t\t\t\tboneInf.BoneIndex = this._currentGeo.BoneInfs.length;\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tline = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tvar data = this._readLine( line.trim() ).split( \",\" );\n\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\tboneInf.Indeces.push( parseInt( data[ i ] ) );\n\n\t\t\t\t\t}\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tline = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tvar data2 = this._readLine( line.trim() ).split( \",\" );\n\t\t\t\t\tfor ( var _i = 0; _i < data2.length; _i ++ ) {\n\n\t\t\t\t\t\tboneInf.Weights.push( parseFloat( data2[ _i ] ) );\n\n\t\t\t\t\t}\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tif ( find <= 0 ) {\n\n\t\t\t\t\t\tfind = this._currentObject.data.length;\n\n\t\t\t\t\t}\n\t\t\t\t\tline = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tvar data3 = this._readLine( line.trim() ).split( \",\" );\n\t\t\t\t\tboneInf.OffsetMatrix = new THREE.Matrix4();\n\t\t\t\t\tthis._ParseMatrixData( boneInf.OffsetMatrix, data3 );\n\t\t\t\t\tthis._currentGeo.BoneInfs.push( boneInf );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_makePutBoneList',\n\t\t\t\tvalue: function _makePutBoneList( _RootName, _bones ) {\n\n\t\t\t\t\tvar putting = false;\n\t\t\t\t\tfor ( var frame in this.HieStack ) {\n\n\t\t\t\t\t\tif ( this.HieStack[ frame ].name === _RootName || putting ) {\n\n\t\t\t\t\t\t\tputting = true;\n\t\t\t\t\t\t\tvar b = new THREE.Bone();\n\t\t\t\t\t\t\tb.name = this.HieStack[ frame ].name;\n\t\t\t\t\t\t\tb.applyMatrix4( this.HieStack[ frame ].FrameTransformMatrix );\n\t\t\t\t\t\t\tb.matrixWorld = b.matrix;\n\t\t\t\t\t\t\tb.FrameTransformMatrix = this.HieStack[ frame ].FrameTransformMatrix;\n\t\t\t\t\t\t\tb.pos = new THREE.Vector3().setFromMatrixPosition( b.FrameTransformMatrix ).toArray();\n\t\t\t\t\t\t\tb.rotq = new THREE.Quaternion().setFromRotationMatrix( b.FrameTransformMatrix ).toArray();\n\t\t\t\t\t\t\tb.scl = new THREE.Vector3().setFromMatrixScale( b.FrameTransformMatrix ).toArray();\n\t\t\t\t\t\t\tif ( this.HieStack[ frame ].parentName && this.HieStack[ frame ].parentName.length > 0 ) {\n\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < _bones.length; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tif ( this.HieStack[ frame ].parentName === _bones[ i ].name ) {\n\n\t\t\t\t\t\t\t\t\t\t_bones[ i ].add( b );\n\t\t\t\t\t\t\t\t\t\tb.parent = i;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_bones.push( b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_makeOutputGeometry',\n\t\t\t\tvalue: function _makeOutputGeometry() {\n\n\t\t\t\t\tvar mesh = null;\n\t\t\t\t\tif ( this._currentGeo.BoneInfs.length > 0 ) {\n\n\t\t\t\t\t\tvar putBones = [];\n\t\t\t\t\t\tthis._makePutBoneList( this._currentGeo.baseFrame.parentName, putBones );\n\t\t\t\t\t\tfor ( var bi = 0; bi < this._currentGeo.BoneInfs.length; bi ++ ) {\n\n\t\t\t\t\t\t\tvar boneIndex = 0;\n\t\t\t\t\t\t\tfor ( var bb = 0; bb < putBones.length; bb ++ ) {\n\n\t\t\t\t\t\t\t\tif ( putBones[ bb ].name === this._currentGeo.BoneInfs[ bi ].boneName ) {\n\n\t\t\t\t\t\t\t\t\tboneIndex = bb;\n\t\t\t\t\t\t\t\t\tputBones[ bb ].OffsetMatrix = new THREE.Matrix4();\n\t\t\t\t\t\t\t\t\tputBones[ bb ].OffsetMatrix.copy( this._currentGeo.BoneInfs[ bi ].OffsetMatrix );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( var vi = 0; vi < this._currentGeo.BoneInfs[ bi ].Indeces.length; vi ++ ) {\n\n\t\t\t\t\t\t\t\tvar nowVertexID = this._currentGeo.BoneInfs[ bi ].Indeces[ vi ];\n\t\t\t\t\t\t\t\tvar nowVal = this._currentGeo.BoneInfs[ bi ].Weights[ vi ];\n\n\t\t\t\t\t\t\t\tvar stride = nowVertexID * 4;\n\n\t\t\t\t\t\t\t\tswitch ( this._currentGeo.VertexSetedBoneCount[ nowVertexID ] ) {\n\n\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinIndices[ stride ] = boneIndex;\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinWeights[ stride ] = nowVal;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinIndices[ stride + 1 ] = boneIndex;\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinWeights[ stride + 1 ] = nowVal;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinIndices[ stride + 2 ] = boneIndex;\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinWeights[ stride + 2 ] = nowVal;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinIndices[ stride + 3 ] = boneIndex;\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinWeights[ stride + 3 ] = nowVal;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis._currentGeo.VertexSetedBoneCount[ nowVertexID ] ++;\n\t\t\t\t\t\t\t\tif ( this._currentGeo.VertexSetedBoneCount[ nowVertexID ] > 4 ) {\n\n\t\t\t\t\t\t\t\t\tconsole.log( 'warn! over 4 bone weight! :' + nowVertexID );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( var sk = 0; sk < this._currentGeo.Materials.length; sk ++ ) {\n\n\t\t\t\t\t\t\tthis._currentGeo.Materials[ sk ].skinning = true;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar offsetList = [];\n\t\t\t\t\t\tfor ( var _bi = 0; _bi < putBones.length; _bi ++ ) {\n\n\t\t\t\t\t\t\tif ( putBones[ _bi ].OffsetMatrix ) {\n\n\t\t\t\t\t\t\t\toffsetList.push( putBones[ _bi ].OffsetMatrix );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\toffsetList.push( new THREE.Matrix4() );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar bufferGeometry = this._buildGeometry();\n\t\t\t\t\t\tmesh = new THREE.SkinnedMesh( bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[ 0 ] : this._currentGeo.Materials );\n\n\t\t\t\t\t\tthis._initSkeleton( mesh, putBones, offsetList );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar _bufferGeometry = this._buildGeometry();\n\t\t\t\t\t\tmesh = new THREE.Mesh( _bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[ 0 ] : this._currentGeo.Materials );\n\n\t\t\t\t\t}\n\t\t\t\t\tmesh.name = this._currentGeo.name;\n\t\t\t\t\tvar worldBaseMx = new THREE.Matrix4();\n\t\t\t\t\tvar currentMxFrame = this._currentGeo.baseFrame.putBone;\n\t\t\t\t\tif ( currentMxFrame && currentMxFrame.parent ) {\n\n\t\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\t\tcurrentMxFrame = currentMxFrame.parent;\n\t\t\t\t\t\t\tif ( currentMxFrame ) {\n\n\t\t\t\t\t\t\t\tworldBaseMx.multiply( currentMxFrame.FrameTransformMatrix );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmesh.applyMatrix4( worldBaseMx );\n\n\t\t\t\t\t}\n\t\t\t\t\tthis.Meshes.push( mesh );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_initSkeleton',\n\t\t\t\tvalue: function _initSkeleton( mesh, boneList, boneInverses ) {\n\n\t\t\t\t\tvar bones = [], bone, gbone;\n\t\t\t\t\tvar i, il;\n\n\t\t\t\t\tfor ( i = 0, il = boneList.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tgbone = boneList[ i ];\n\n\t\t\t\t\t\tbone = new THREE.Bone();\n\t\t\t\t\t\tbones.push( bone );\n\n\t\t\t\t\t\tbone.name = gbone.name;\n\t\t\t\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( i = 0, il = boneList.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tgbone = boneList[ i ];\n\n\t\t\t\t\t\tif ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {\n\n\t\t\t\t\t\t\tbones[ gbone.parent ].add( bones[ i ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh.add( bones[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.updateMatrixWorld( true );\n\n\t\t\t\t\tvar skeleton = new THREE.Skeleton( bones, boneInverses );\n\t\t\t\t\tmesh.bind( skeleton, mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t}, {\n\t\t\t\tkey: '_readAnimationKey',\n\t\t\t\tvalue: function _readAnimationKey() {\n\n\t\t\t\t\tvar endRead = 0;\n\t\t\t\t\tvar find = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tvar line = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tvar nowKeyType = parseInt( this._readLine( line ) );\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tline = this._currentObject.data.substr( endRead );\n\t\t\t\t\tvar data = this._readLine( line.trim() ).split( \";;,\" );\n\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\tvar data2 = data[ i ].split( \";\" );\n\t\t\t\t\t\tvar keyInfo = new XKeyFrameInfo();\n\t\t\t\t\t\tkeyInfo.type = nowKeyType;\n\t\t\t\t\t\tkeyInfo.Frame = parseInt( data2[ 0 ] );\n\t\t\t\t\t\tkeyInfo.index = this._currentAnimeFrames.keyFrames.length;\n\t\t\t\t\t\tkeyInfo.time = keyInfo.Frame;\n\t\t\t\t\t\tif ( nowKeyType != 4 ) {\n\n\t\t\t\t\t\t\tvar frameFound = false;\n\t\t\t\t\t\t\tfor ( var mm = 0; mm < this._currentAnimeFrames.keyFrames.length; mm ++ ) {\n\n\t\t\t\t\t\t\t\tif ( this._currentAnimeFrames.keyFrames[ mm ].Frame === keyInfo.Frame ) {\n\n\t\t\t\t\t\t\t\t\tkeyInfo = this._currentAnimeFrames.keyFrames[ mm ];\n\t\t\t\t\t\t\t\t\tframeFound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar frameValue = data2[ 2 ].split( \",\" );\n\t\t\t\t\t\t\tswitch ( nowKeyType ) {\n\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tkeyInfo.rot = new THREE.Quaternion( parseFloat( frameValue[ 1 ] ), parseFloat( frameValue[ 2 ] ), parseFloat( frameValue[ 3 ] ), parseFloat( frameValue[ 0 ] ) * - 1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tkeyInfo.scl = new THREE.Vector3( parseFloat( frameValue[ 0 ] ), parseFloat( frameValue[ 1 ] ), parseFloat( frameValue[ 2 ] ) );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tkeyInfo.pos = new THREE.Vector3( parseFloat( frameValue[ 0 ] ), parseFloat( frameValue[ 1 ] ), parseFloat( frameValue[ 2 ] ) );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( ! frameFound ) {\n\n\t\t\t\t\t\t\t\tthis._currentAnimeFrames.keyFrames.push( keyInfo );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tkeyInfo.matrix = new THREE.Matrix4();\n\t\t\t\t\t\t\tthis._ParseMatrixData( keyInfo.matrix, data2[ 2 ].split( \",\" ) );\n\t\t\t\t\t\t\tthis._currentAnimeFrames.keyFrames.push( keyInfo );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_makeOutputAnimation',\n\t\t\t\tvalue: function _makeOutputAnimation() {\n\n\t\t\t\t\tvar animationObj = new XAnimationObj( this.options );\n\t\t\t\t\tanimationObj.fps = this.animTicksPerSecond;\n\t\t\t\t\tanimationObj.name = this._currentAnime.name;\n\t\t\t\t\tanimationObj.make( this._currentAnime.AnimeFrames );\n\t\t\t\t\tthis.animations.push( animationObj );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'assignAnimation',\n\t\t\t\tvalue: function assignAnimation( _model, _animation ) {\n\n\t\t\t\t\tvar model = _model;\n\t\t\t\t\tvar animation = _animation;\n\t\t\t\t\tif ( ! model ) {\n\n\t\t\t\t\t\tmodel = this.Meshes[ 0 ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ! animation ) {\n\n\t\t\t\t\t\tanimation = this.animations[ 0 ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ! model || ! animation ) {\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\t\t\t\t\tvar put = {};\n\t\t\t\t\tput.fps = animation.fps;\n\t\t\t\t\tput.name = animation.name;\n\t\t\t\t\tput.length = animation.length;\n\t\t\t\t\tput.hierarchy = [];\n\t\t\t\t\tfor ( var b = 0; b < model.skeleton.bones.length; b ++ ) {\n\n\t\t\t\t\t\tvar findAnimation = false;\n\t\t\t\t\t\tfor ( var i = 0; i < animation.hierarchy.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( model.skeleton.bones[ b ].name === animation.hierarchy[ i ].name ) {\n\n\t\t\t\t\t\t\t\tfindAnimation = true;\n\t\t\t\t\t\t\t\tvar c_key = animation.hierarchy[ i ].copy();\n\t\t\t\t\t\t\t\tc_key.parent = - 1;\n\t\t\t\t\t\t\t\tif ( model.skeleton.bones[ b ].parent && model.skeleton.bones[ b ].parent.type === \"Bone\" ) {\n\n\t\t\t\t\t\t\t\t\tfor ( var bb = 0; bb < put.hierarchy.length; bb ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tif ( put.hierarchy[ bb ].name === model.skeleton.bones[ b ].parent.name ) {\n\n\t\t\t\t\t\t\t\t\t\t\tc_key.parent = bb;\n\t\t\t\t\t\t\t\t\t\t\tc_key.parentName = model.skeleton.bones[ b ].parent.name;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tput.hierarchy.push( c_key );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ! findAnimation ) {\n\n\t\t\t\t\t\t\tvar _c_key = animation.hierarchy[ 0 ].copy();\n\t\t\t\t\t\t\t_c_key.name = model.skeleton.bones[ b ].name;\n\t\t\t\t\t\t\t_c_key.parent = - 1;\n\t\t\t\t\t\t\tfor ( var k = 0; k < _c_key.keys.length; k ++ ) {\n\n\t\t\t\t\t\t\t\tif ( _c_key.keys[ k ].pos ) {\n\n\t\t\t\t\t\t\t\t\t_c_key.keys[ k ].pos.set( 0, 0, 0 );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( _c_key.keys[ k ].scl ) {\n\n\t\t\t\t\t\t\t\t\t_c_key.keys[ k ].scl.set( 1, 1, 1 );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( _c_key.keys[ k ].rot ) {\n\n\t\t\t\t\t\t\t\t\t_c_key.keys[ k ].rot.set( 0, 0, 0, 1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tput.hierarchy.push( _c_key );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ! model.geometry.animations ) {\n\n\t\t\t\t\t\tmodel.geometry.animations = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmodel.geometry.animations.push( THREE.AnimationClip.parseAnimation( put, model.skeleton.bones ) );\n\t\t\t\t\tif ( ! model.animationMixer ) {\n\n\t\t\t\t\t\tmodel.animationMixer = new THREE.AnimationMixer( model );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn put;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_ParseMatrixData',\n\t\t\t\tvalue: function _ParseMatrixData( targetMatrix, data ) {\n\n\t\t\t\t\ttargetMatrix.set( parseFloat( data[ 0 ] ), parseFloat( data[ 4 ] ), parseFloat( data[ 8 ] ), parseFloat( data[ 12 ] ), parseFloat( data[ 1 ] ), parseFloat( data[ 5 ] ), parseFloat( data[ 9 ] ), parseFloat( data[ 13 ] ), parseFloat( data[ 2 ] ), parseFloat( data[ 6 ] ), parseFloat( data[ 10 ] ), parseFloat( data[ 14 ] ), parseFloat( data[ 3 ] ), parseFloat( data[ 7 ] ), parseFloat( data[ 11 ] ), parseFloat( data[ 15 ] ) );\n\n\t\t\t\t}\n\t\t\t} ] );\n\t\t\treturn XLoader;\n\n\t\t}();\n\n\t\treturn XLoader;\n\n\t} )();\n\t\n\treturn THREE.XLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/DDSLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tTHREE.DDSLoader = function ( manager ) {\n\n\t\tTHREE.CompressedTextureLoader.call( this, manager );\n\n\t};\n\n\tTHREE.DDSLoader.prototype = Object.assign( Object.create( THREE.CompressedTextureLoader.prototype ), {\n\n\t\tconstructor: THREE.DDSLoader,\n\n\t\tparse: function ( buffer, loadMipmaps ) {\n\n\t\t\tvar dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n\n\t\t\t// Adapted from @toji's DDS utils\n\t\t\t// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n\t\t\t// All values and structures referenced from:\n\t\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n\t\t\tvar DDS_MAGIC = 0x20534444;\n\n\t\t\tvar DDSD_CAPS = 0x1,\n\t\t\t\tDDSD_HEIGHT = 0x2,\n\t\t\t\tDDSD_WIDTH = 0x4,\n\t\t\t\tDDSD_PITCH = 0x8,\n\t\t\t\tDDSD_PIXELFORMAT = 0x1000,\n\t\t\t\tDDSD_MIPMAPCOUNT = 0x20000,\n\t\t\t\tDDSD_LINEARSIZE = 0x80000,\n\t\t\t\tDDSD_DEPTH = 0x800000;\n\n\t\t\tvar DDSCAPS_COMPLEX = 0x8,\n\t\t\t\tDDSCAPS_MIPMAP = 0x400000,\n\t\t\t\tDDSCAPS_TEXTURE = 0x1000;\n\n\t\t\tvar DDSCAPS2_CUBEMAP = 0x200,\n\t\t\t\tDDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n\t\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n\t\t\t\tDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n\t\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n\t\t\t\tDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n\t\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n\t\t\t\tDDSCAPS2_VOLUME = 0x200000;\n\n\t\t\tvar DDPF_ALPHAPIXELS = 0x1,\n\t\t\t\tDDPF_ALPHA = 0x2,\n\t\t\t\tDDPF_FOURCC = 0x4,\n\t\t\t\tDDPF_RGB = 0x40,\n\t\t\t\tDDPF_YUV = 0x200,\n\t\t\t\tDDPF_LUMINANCE = 0x20000;\n\n\t\t\tfunction fourCCToInt32( value ) {\n\n\t\t\t\treturn value.charCodeAt( 0 ) +\n\t\t\t\t\t( value.charCodeAt( 1 ) << 8 ) +\n\t\t\t\t\t( value.charCodeAt( 2 ) << 16 ) +\n\t\t\t\t\t( value.charCodeAt( 3 ) << 24 );\n\n\t\t\t}\n\n\t\t\tfunction int32ToFourCC( value ) {\n\n\t\t\t\treturn String.fromCharCode(\n\t\t\t\t\tvalue & 0xff,\n\t\t\t\t\t( value >> 8 ) & 0xff,\n\t\t\t\t\t( value >> 16 ) & 0xff,\n\t\t\t\t\t( value >> 24 ) & 0xff\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tfunction loadARGBMip( buffer, dataOffset, width, height ) {\n\n\t\t\t\tvar dataLength = width * height * 4;\n\t\t\t\tvar srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\n\t\t\t\tvar byteArray = new Uint8Array( dataLength );\n\t\t\t\tvar dst = 0;\n\t\t\t\tvar src = 0;\n\t\t\t\tfor ( var y = 0; y < height; y ++ ) {\n\n\t\t\t\t\tfor ( var x = 0; x < width; x ++ ) {\n\n\t\t\t\t\t\tvar b = srcBuffer[ src ]; src ++;\n\t\t\t\t\t\tvar g = srcBuffer[ src ]; src ++;\n\t\t\t\t\t\tvar r = srcBuffer[ src ]; src ++;\n\t\t\t\t\t\tvar a = srcBuffer[ src ]; src ++;\n\t\t\t\t\t\tbyteArray[ dst ] = r; dst ++;\t//r\n\t\t\t\t\t\tbyteArray[ dst ] = g; dst ++;\t//g\n\t\t\t\t\t\tbyteArray[ dst ] = b; dst ++;\t//b\n\t\t\t\t\t\tbyteArray[ dst ] = a; dst ++;\t//a\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn byteArray;\n\n\t\t\t}\n\n\t\t\tvar FOURCC_DXT1 = fourCCToInt32( \"DXT1\" );\n\t\t\tvar FOURCC_DXT3 = fourCCToInt32( \"DXT3\" );\n\t\t\tvar FOURCC_DXT5 = fourCCToInt32( \"DXT5\" );\n\t\t\tvar FOURCC_ETC1 = fourCCToInt32( \"ETC1\" );\n\n\t\t\tvar headerLengthInt = 31; // The header length in 32 bit ints\n\n\t\t\t// Offsets into the header array\n\n\t\t\tvar off_magic = 0;\n\n\t\t\tvar off_size = 1;\n\t\t\tvar off_flags = 2;\n\t\t\tvar off_height = 3;\n\t\t\tvar off_width = 4;\n\n\t\t\tvar off_mipmapCount = 7;\n\n\t\t\tvar off_pfFlags = 20;\n\t\t\tvar off_pfFourCC = 21;\n\t\t\tvar off_RGBBitCount = 22;\n\t\t\tvar off_RBitMask = 23;\n\t\t\tvar off_GBitMask = 24;\n\t\t\tvar off_BBitMask = 25;\n\t\t\tvar off_ABitMask = 26;\n\n\t\t\tvar off_caps = 27;\n\t\t\tvar off_caps2 = 28;\n\t\t\tvar off_caps3 = 29;\n\t\t\tvar off_caps4 = 30;\n\n\t\t\t// Parse header\n\n\t\t\tvar header = new Int32Array( buffer, 0, headerLengthInt );\n\n\t\t\tif ( header[ off_magic ] !== DDS_MAGIC ) {\n\n\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' );\n\t\t\t\treturn dds;\n\n\t\t\t}\n\n\t\t\tif ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {\n\n\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.' );\n\t\t\t\treturn dds;\n\n\t\t\t}\n\n\t\t\tvar blockBytes;\n\n\t\t\tvar fourCC = header[ off_pfFourCC ];\n\n\t\t\tvar isRGBAUncompressed = false;\n\n\t\t\tswitch ( fourCC ) {\n\n\t\t\t\tcase FOURCC_DXT1:\n\n\t\t\t\t\tblockBytes = 8;\n\t\t\t\t\tdds.format = THREE.RGB_S3TC_DXT1_Format;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FOURCC_DXT3:\n\n\t\t\t\t\tblockBytes = 16;\n\t\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT3_Format;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FOURCC_DXT5:\n\n\t\t\t\t\tblockBytes = 16;\n\t\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT5_Format;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FOURCC_ETC1:\n\n\t\t\t\t\tblockBytes = 8;\n\t\t\t\t\tdds.format = THREE.RGB_ETC1_Format;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( header[ off_RGBBitCount ] === 32\n\t\t\t\t\t\t&& header[ off_RBitMask ] & 0xff0000\n\t\t\t\t\t\t&& header[ off_GBitMask ] & 0xff00\n\t\t\t\t\t\t&& header[ off_BBitMask ] & 0xff\n\t\t\t\t\t\t&& header[ off_ABitMask ] & 0xff000000 ) {\n\n\t\t\t\t\t\tisRGBAUncompressed = true;\n\t\t\t\t\t\tblockBytes = 64;\n\t\t\t\t\t\tdds.format = THREE.RGBAFormat;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );\n\t\t\t\t\t\treturn dds;\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdds.mipmapCount = 1;\n\n\t\t\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\n\n\t\t\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\n\n\t\t\t}\n\n\t\t\tvar caps2 = header[ off_caps2 ];\n\t\t\tdds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n\t\t\tif ( dds.isCubemap && (\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ||\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ||\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ||\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ||\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ||\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ )\n\t\t\t) ) {\n\n\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Incomplete cubemap faces' );\n\t\t\t\treturn dds;\n\n\t\t\t}\n\n\t\t\tdds.width = header[ off_width ];\n\t\t\tdds.height = header[ off_height ];\n\n\t\t\tvar dataOffset = header[ off_size ] + 4;\n\n\t\t\t// Extract mipmaps buffers\n\n\t\t\tvar faces = dds.isCubemap ? 6 : 1;\n\n\t\t\tfor ( var face = 0; face < faces; face ++ ) {\n\n\t\t\t\tvar width = dds.width;\n\t\t\t\tvar height = dds.height;\n\n\t\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\t\tif ( isRGBAUncompressed ) {\n\n\t\t\t\t\t\tvar byteArray = loadARGBMip( buffer, dataOffset, width, height );\n\t\t\t\t\t\tvar dataLength = byteArray.length;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\n\t\t\t\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataLength );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar mipmap = { \"data\": byteArray, \"width\": width, \"height\": height };\n\t\t\t\t\tdds.mipmaps.push( mipmap );\n\n\t\t\t\t\tdataOffset += dataLength;\n\n\t\t\t\t\twidth = Math.max( width >> 1, 1 );\n\t\t\t\t\theight = Math.max( height >> 1, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dds;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.DDSLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/PVRLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/*\n\t *\t PVRLoader\n\t *   Author: pierre lepers\n\t *   Date: 17/09/2014 11:09\n\t *\n\t *\t PVR v2 (legacy) parser\n\t *   TODO : Add Support for PVR v3 format\n\t *   TODO : implement loadMipmaps option\n\t */\n\n\tTHREE.PVRLoader = function ( manager ) {\n\n\t\tTHREE.CompressedTextureLoader.call( this, manager );\n\n\t};\n\n\tTHREE.PVRLoader.prototype = Object.assign( Object.create( THREE.CompressedTextureLoader.prototype ), {\n\n\t\tconstructor: THREE.PVRLoader,\n\n\t\tparse: function ( buffer, loadMipmaps ) {\n\n\t\t\tvar headerLengthInt = 13;\n\t\t\tvar header = new Uint32Array( buffer, 0, headerLengthInt );\n\n\t\t\tvar pvrDatas = {\n\t\t\t\tbuffer: buffer,\n\t\t\t\theader: header,\n\t\t\t\tloadMipmaps: loadMipmaps\n\t\t\t};\n\n\t\t\tif ( header[ 0 ] === 0x03525650 ) {\n\n\t\t\t\t// PVR v3\n\n\t\t\t\treturn THREE.PVRLoader._parseV3( pvrDatas );\n\n\t\t\t} else if ( header[ 11 ] === 0x21525650 ) {\n\n\t\t\t\t// PVR v2\n\n\t\t\t\treturn THREE.PVRLoader._parseV2( pvrDatas );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.PVRLoader: Unknown PVR format.' );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tTHREE.PVRLoader._parseV3 = function ( pvrDatas ) {\n\n\t\tvar header = pvrDatas.header;\n\t\tvar bpp, format;\n\n\n\t\tvar metaLen = header[ 12 ],\n\t\t\tpixelFormat = header[ 2 ],\n\t\t\theight = header[ 6 ],\n\t\t\twidth = header[ 7 ],\n\t\t\t// numSurfs = header[ 9 ],\n\t\t\tnumFaces = header[ 10 ],\n\t\t\tnumMipmaps = header[ 11 ];\n\n\t\tswitch ( pixelFormat ) {\n\n\t\t\tcase 0 : // PVRTC 2bpp RGB\n\t\t\t\tbpp = 2;\n\t\t\t\tformat = THREE.RGB_PVRTC_2BPPV1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase 1 : // PVRTC 2bpp RGBA\n\t\t\t\tbpp = 2;\n\t\t\t\tformat = THREE.RGBA_PVRTC_2BPPV1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase 2 : // PVRTC 4bpp RGB\n\t\t\t\tbpp = 4;\n\t\t\t\tformat = THREE.RGB_PVRTC_4BPPV1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase 3 : // PVRTC 4bpp RGBA\n\t\t\t\tbpp = 4;\n\t\t\t\tformat = THREE.RGBA_PVRTC_4BPPV1_Format;\n\t\t\t\tbreak;\n\n\t\t\tdefault :\n\t\t\t\tconsole.error( 'THREE.PVRLoader: Unsupported PVR format:', pixelFormat );\n\n\t\t}\n\n\t\tpvrDatas.dataPtr = 52 + metaLen;\n\t\tpvrDatas.bpp = bpp;\n\t\tpvrDatas.format = format;\n\t\tpvrDatas.width = width;\n\t\tpvrDatas.height = height;\n\t\tpvrDatas.numSurfaces = numFaces;\n\t\tpvrDatas.numMipmaps = numMipmaps;\n\t\tpvrDatas.isCubemap \t= ( numFaces === 6 );\n\n\t\treturn THREE.PVRLoader._extract( pvrDatas );\n\n\t};\n\n\tTHREE.PVRLoader._parseV2 = function ( pvrDatas ) {\n\n\t\tvar header = pvrDatas.header;\n\n\t\tvar headerLength = header[ 0 ],\n\t\t\theight = header[ 1 ],\n\t\t\twidth = header[ 2 ],\n\t\t\tnumMipmaps = header[ 3 ],\n\t\t\tflags = header[ 4 ],\n\t\t\t// dataLength = header[ 5 ],\n\t\t\t// bpp =  header[ 6 ],\n\t\t\t// bitmaskRed = header[ 7 ],\n\t\t\t// bitmaskGreen = header[ 8 ],\n\t\t\t// bitmaskBlue = header[ 9 ],\n\t\t\tbitmaskAlpha = header[ 10 ],\n\t\t\t// pvrTag = header[ 11 ],\n\t\t\tnumSurfs = header[ 12 ];\n\n\n\t\tvar TYPE_MASK = 0xff;\n\t\tvar PVRTC_2 = 24,\n\t\t\tPVRTC_4 = 25;\n\n\t\tvar formatFlags = flags & TYPE_MASK;\n\n\t\tvar bpp, format;\n\t\tvar _hasAlpha = bitmaskAlpha > 0;\n\n\t\tif ( formatFlags === PVRTC_4 ) {\n\n\t\t\tformat = _hasAlpha ? THREE.RGBA_PVRTC_4BPPV1_Format : THREE.RGB_PVRTC_4BPPV1_Format;\n\t\t\tbpp = 4;\n\n\t\t} else if ( formatFlags === PVRTC_2 ) {\n\n\t\t\tformat = _hasAlpha ? THREE.RGBA_PVRTC_2BPPV1_Format : THREE.RGB_PVRTC_2BPPV1_Format;\n\t\t\tbpp = 2;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.PVRLoader: Unknown PVR format:', formatFlags );\n\n\t\t}\n\n\t\tpvrDatas.dataPtr = headerLength;\n\t\tpvrDatas.bpp = bpp;\n\t\tpvrDatas.format = format;\n\t\tpvrDatas.width = width;\n\t\tpvrDatas.height = height;\n\t\tpvrDatas.numSurfaces = numSurfs;\n\t\tpvrDatas.numMipmaps = numMipmaps + 1;\n\n\t\t// guess cubemap type seems tricky in v2\n\t\t// it juste a pvr containing 6 surface (no explicit cubemap type)\n\t\tpvrDatas.isCubemap \t= ( numSurfs === 6 );\n\n\t\treturn THREE.PVRLoader._extract( pvrDatas );\n\n\t};\n\n\n\tTHREE.PVRLoader._extract = function ( pvrDatas ) {\n\n\t\tvar pvr = {\n\t\t\tmipmaps: [],\n\t\t\twidth: pvrDatas.width,\n\t\t\theight: pvrDatas.height,\n\t\t\tformat: pvrDatas.format,\n\t\t\tmipmapCount: pvrDatas.numMipmaps,\n\t\t\tisCubemap: pvrDatas.isCubemap\n\t\t};\n\n\t\tvar buffer = pvrDatas.buffer;\n\n\t\tvar dataOffset = pvrDatas.dataPtr,\n\t\t\tbpp = pvrDatas.bpp,\n\t\t\tnumSurfs = pvrDatas.numSurfaces,\n\t\t\tdataSize = 0,\n\t\t\tblockSize = 0,\n\t\t\tblockWidth = 0,\n\t\t\tblockHeight = 0,\n\t\t\twidthBlocks = 0,\n\t\t\theightBlocks = 0;\n\n\t\tif ( bpp === 2 ) {\n\n\t\t\tblockWidth = 8;\n\t\t\tblockHeight = 4;\n\n\t\t} else {\n\n\t\t\tblockWidth = 4;\n\t\t\tblockHeight = 4;\n\n\t\t}\n\n\t\tblockSize = ( blockWidth * blockHeight ) * bpp / 8;\n\n\t\tpvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;\n\n\t\tvar mipLevel = 0;\n\n\t\twhile ( mipLevel < pvrDatas.numMipmaps ) {\n\n\t\t\tvar sWidth = pvrDatas.width >> mipLevel,\n\t\t\t\tsHeight = pvrDatas.height >> mipLevel;\n\n\t\t\twidthBlocks = sWidth / blockWidth;\n\t\t\theightBlocks = sHeight / blockHeight;\n\n\t\t\t// Clamp to minimum number of blocks\n\t\t\tif ( widthBlocks < 2 ) widthBlocks = 2;\n\t\t\tif ( heightBlocks < 2 ) heightBlocks = 2;\n\n\t\t\tdataSize = widthBlocks * heightBlocks * blockSize;\n\n\t\t\tfor ( var surfIndex = 0; surfIndex < numSurfs; surfIndex ++ ) {\n\n\t\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataSize );\n\n\t\t\t\tvar mipmap = {\n\t\t\t\t\tdata: byteArray,\n\t\t\t\t\twidth: sWidth,\n\t\t\t\t\theight: sHeight\n\t\t\t\t};\n\n\t\t\t\tpvr.mipmaps[ surfIndex * pvrDatas.numMipmaps + mipLevel ] = mipmap;\n\n\t\t\t\tdataOffset += dataSize;\n\n\t\t\t}\n\n\t\t\tmipLevel ++;\n\n\t\t}\n\n\t\treturn pvr;\n\n\t};\n\t\n\treturn THREE.PVRLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/KTXLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author amakaseev / https://github.com/amakaseev\n\t *\n\t * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\n\t * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\n\t *\n\t * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts\n\t */\n\n\n\tTHREE.KTXLoader = function ( manager ) {\n\n\t\tTHREE.CompressedTextureLoader.call( this, manager );\n\n\t};\n\n\tTHREE.KTXLoader.prototype = Object.assign( Object.create( THREE.CompressedTextureLoader.prototype ), {\n\n\t\tconstructor: THREE.KTXLoader,\n\n\t\tparse: function ( buffer, loadMipmaps ) {\n\n\t\t\tvar ktx = new KhronosTextureContainer( buffer, 1 );\n\n\t\t\treturn {\n\t\t\t\tmipmaps: ktx.mipmaps( loadMipmaps ),\n\t\t\t\twidth: ktx.pixelWidth,\n\t\t\t\theight: ktx.pixelHeight,\n\t\t\t\tformat: ktx.glInternalFormat,\n\t\t\t\tisCubemap: ktx.numberOfFaces === 6,\n\t\t\t\tmipmapCount: ktx.numberOfMipmapLevels\n\t\t\t};\n\n\t\t}\n\n\t} );\n\n\tvar KhronosTextureContainer = ( function () {\n\n\t\t/**\n\t\t * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file\n\t\t * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or\n\t\t * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented\n\t\t * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented\n\t\t */\n\t\tfunction KhronosTextureContainer( arrayBuffer, facesExpected /*, threeDExpected, textureArrayExpected */ ) {\n\n\t\t\tthis.arrayBuffer = arrayBuffer;\n\n\t\t\t// Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:\n\t\t\t// '´', 'K', 'T', 'X', ' ', '1', '1', 'ª', '\\r', '\\n', '\\x1A', '\\n'\n\t\t\t// 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\n\t\t\tvar identifier = new Uint8Array( this.arrayBuffer, 0, 12 );\n\t\t\tif ( identifier[ 0 ] !== 0xAB ||\n\t\t\t\tidentifier[ 1 ] !== 0x4B ||\n\t\t\t\tidentifier[ 2 ] !== 0x54 ||\n\t\t\t\tidentifier[ 3 ] !== 0x58 ||\n\t\t\t\tidentifier[ 4 ] !== 0x20 ||\n\t\t\t\tidentifier[ 5 ] !== 0x31 ||\n\t\t\t\tidentifier[ 6 ] !== 0x31 ||\n\t\t\t\tidentifier[ 7 ] !== 0xBB ||\n\t\t\t\tidentifier[ 8 ] !== 0x0D ||\n\t\t\t\tidentifier[ 9 ] !== 0x0A ||\n\t\t\t\tidentifier[ 10 ] !== 0x1A ||\n\t\t\t\tidentifier[ 11 ] !== 0x0A ) {\n\n\t\t\t\tconsole.error( 'texture missing KTX identifier' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// load the reset of the header in native 32 bit uint\n\t\t\tvar dataSize = Uint32Array.BYTES_PER_ELEMENT;\n\t\t\tvar headerDataView = new DataView( this.arrayBuffer, 12, 13 * dataSize );\n\t\t\tvar endianness = headerDataView.getUint32( 0, true );\n\t\t\tvar littleEndian = endianness === 0x04030201;\n\n\t\t\tthis.glType = headerDataView.getUint32( 1 * dataSize, littleEndian ); // must be 0 for compressed textures\n\t\t\tthis.glTypeSize = headerDataView.getUint32( 2 * dataSize, littleEndian ); // must be 1 for compressed textures\n\t\t\tthis.glFormat = headerDataView.getUint32( 3 * dataSize, littleEndian ); // must be 0 for compressed textures\n\t\t\tthis.glInternalFormat = headerDataView.getUint32( 4 * dataSize, littleEndian ); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\n\t\t\tthis.glBaseInternalFormat = headerDataView.getUint32( 5 * dataSize, littleEndian ); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\n\t\t\tthis.pixelWidth = headerDataView.getUint32( 6 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\n\t\t\tthis.pixelHeight = headerDataView.getUint32( 7 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\n\t\t\tthis.pixelDepth = headerDataView.getUint32( 8 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\n\t\t\tthis.numberOfArrayElements = headerDataView.getUint32( 9 * dataSize, littleEndian ); // used for texture arrays\n\t\t\tthis.numberOfFaces = headerDataView.getUint32( 10 * dataSize, littleEndian ); // used for cubemap textures, should either be 1 or 6\n\t\t\tthis.numberOfMipmapLevels = headerDataView.getUint32( 11 * dataSize, littleEndian ); // number of levels; disregard possibility of 0 for compressed textures\n\t\t\tthis.bytesOfKeyValueData = headerDataView.getUint32( 12 * dataSize, littleEndian ); // the amount of space after the header for meta-data\n\n\t\t\t// Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\n\t\t\tif ( this.glType !== 0 ) {\n\n\t\t\t\tconsole.warn( 'only compressed formats currently supported' );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\t// value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\n\t\t\t\tthis.numberOfMipmapLevels = Math.max( 1, this.numberOfMipmapLevels );\n\n\t\t\t}\n\t\t\tif ( this.pixelHeight === 0 || this.pixelDepth !== 0 ) {\n\n\t\t\t\tconsole.warn( 'only 2D textures currently supported' );\n\t\t\t\treturn;\n\n\t\t\t}\n\t\t\tif ( this.numberOfArrayElements !== 0 ) {\n\n\t\t\t\tconsole.warn( 'texture arrays not currently supported' );\n\t\t\t\treturn;\n\n\t\t\t}\n\t\t\tif ( this.numberOfFaces !== facesExpected ) {\n\n\t\t\t\tconsole.warn( 'number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces );\n\t\t\t\treturn;\n\n\t\t\t}\n\t\t\t// we now have a completely validated file, so could use existence of loadType as success\n\t\t\t// would need to make this more elaborate & adjust checks above to support more than one load type\n\t\t\tthis.loadType = KhronosTextureContainer.COMPRESSED_2D;\n\n\t\t}\n\n\t\t// return mipmaps for THREE.js\n\t\tKhronosTextureContainer.prototype.mipmaps = function ( loadMipmaps ) {\n\n\t\t\tvar mipmaps = [];\n\n\t\t\t// initialize width & height for level 1\n\t\t\tvar dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;\n\t\t\tvar width = this.pixelWidth;\n\t\t\tvar height = this.pixelHeight;\n\t\t\tvar mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\n\n\t\t\tfor ( var level = 0; level < mipmapCount; level ++ ) {\n\n\t\t\t\tvar imageSize = new Int32Array( this.arrayBuffer, dataOffset, 1 )[ 0 ]; // size per face, since not supporting array cubemaps\n\t\t\t\tdataOffset += 4; // size of the image + 4 for the imageSize field\n\n\t\t\t\tfor ( var face = 0; face < this.numberOfFaces; face ++ ) {\n\n\t\t\t\t\tvar byteArray = new Uint8Array( this.arrayBuffer, dataOffset, imageSize );\n\n\t\t\t\t\tmipmaps.push( { \"data\": byteArray, \"width\": width, \"height\": height } );\n\n\t\t\t\t\tdataOffset += imageSize;\n\t\t\t\t\tdataOffset += 3 - ( ( imageSize + 3 ) % 4 ); // add padding for odd sized image\n\n\t\t\t\t}\n\t\t\t\twidth = Math.max( 1.0, width * 0.5 );\n\t\t\t\theight = Math.max( 1.0, height * 0.5 );\n\n\t\t\t}\n\n\t\t\treturn mipmaps;\n\n\t\t};\n\n\t\tKhronosTextureContainer.HEADER_LEN = 12 + ( 13 * 4 ); // identifier + header elements (not including key value meta-data pairs)\n\t\t// load types\n\t\tKhronosTextureContainer.COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\n\t\tKhronosTextureContainer.COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\n\t\tKhronosTextureContainer.TEX_2D = 2; // uses a gl.texImage2D()\n\t\tKhronosTextureContainer.TEX_3D = 3; // uses a gl.texImage3D()\n\n\t\treturn KhronosTextureContainer;\n\n\t}() );\n\n\t\n\treturn THREE.KTXLoader;\n});\n\ndefine('skylark-threejs-ex/modifiers/SimplifyModifier',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n\t *\n\t *\tSimplification Geometry Modifier\n\t *    - based on code and technique\n\t *\t  - by Stan Melax in 1998\n\t *\t  - Progressive Mesh type Polygon Reduction Algorithm\n\t *    - http://www.melax.com/polychop/\n\t */\n\n\tTHREE.SimplifyModifier = function () {};\n\n\t( function () {\n\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\tfunction pushIfUnique( array, object ) {\n\n\t\t\tif ( array.indexOf( object ) === - 1 ) array.push( object );\n\n\t\t}\n\n\t\tfunction removeFromArray( array, object ) {\n\n\t\t\tvar k = array.indexOf( object );\n\t\t\tif ( k > - 1 ) array.splice( k, 1 );\n\n\t\t}\n\n\t\tfunction computeEdgeCollapseCost( u, v ) {\n\n\t\t\t// if we collapse edge uv by moving u to v then how\n\t\t\t// much different will the model change, i.e. the \"error\".\n\n\t\t\tvar edgelength = v.position.distanceTo( u.position );\n\t\t\tvar curvature = 0;\n\n\t\t\tvar sideFaces = [];\n\t\t\tvar i, il = u.faces.length, face, sideFace;\n\n\t\t\t// find the \"sides\" triangles that are on the edge uv\n\t\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\t\tface = u.faces[ i ];\n\n\t\t\t\tif ( face.hasVertex( v ) ) {\n\n\t\t\t\t\tsideFaces.push( face );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// use the triangle facing most away from the sides\n\t\t\t// to determine our curvature term\n\t\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\t\tvar minCurvature = 1;\n\t\t\t\tface = u.faces[ i ];\n\n\t\t\t\tfor ( var j = 0; j < sideFaces.length; j ++ ) {\n\n\t\t\t\t\tsideFace = sideFaces[ j ];\n\t\t\t\t\t// use dot product of face normals.\n\t\t\t\t\tvar dotProd = face.normal.dot( sideFace.normal );\n\t\t\t\t\tminCurvature = Math.min( minCurvature, ( 1.001 - dotProd ) / 2 );\n\n\t\t\t\t}\n\n\t\t\t\tcurvature = Math.max( curvature, minCurvature );\n\n\t\t\t}\n\n\t\t\t// crude approach in attempt to preserve borders\n\t\t\t// though it seems not to be totally correct\n\t\t\tvar borders = 0;\n\t\t\tif ( sideFaces.length < 2 ) {\n\n\t\t\t\t// we add some arbitrary cost for borders,\n\t\t\t\t// borders += 10;\n\t\t\t\tcurvature = 1;\n\n\t\t\t}\n\n\t\t\tvar amt = edgelength * curvature + borders;\n\n\t\t\treturn amt;\n\n\t\t}\n\n\t\tfunction computeEdgeCostAtVertex( v ) {\n\n\t\t\t// compute the edge collapse cost for all edges that start\n\t\t\t// from vertex v.  Since we are only interested in reducing\n\t\t\t// the object by selecting the min cost edge at each step, we\n\t\t\t// only cache the cost of the least cost edge at this vertex\n\t\t\t// (in member variable collapse) as well as the value of the\n\t\t\t// cost (in member variable collapseCost).\n\n\t\t\tif ( v.neighbors.length === 0 ) {\n\n\t\t\t\t// collapse if no neighbors.\n\t\t\t\tv.collapseNeighbor = null;\n\t\t\t\tv.collapseCost = - 0.01;\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tv.collapseCost = 100000;\n\t\t\tv.collapseNeighbor = null;\n\n\t\t\t// search all neighboring edges for \"least cost\" edge\n\t\t\tfor ( var i = 0; i < v.neighbors.length; i ++ ) {\n\n\t\t\t\tvar collapseCost = computeEdgeCollapseCost( v, v.neighbors[ i ] );\n\n\t\t\t\tif ( ! v.collapseNeighbor ) {\n\n\t\t\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\t\t\tv.collapseCost = collapseCost;\n\t\t\t\t\tv.minCost = collapseCost;\n\t\t\t\t\tv.totalCost = 0;\n\t\t\t\t\tv.costCount = 0;\n\n\t\t\t\t}\n\n\t\t\t\tv.costCount ++;\n\t\t\t\tv.totalCost += collapseCost;\n\n\t\t\t\tif ( collapseCost < v.minCost ) {\n\n\t\t\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\t\t\tv.minCost = collapseCost;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// we average the cost of collapsing at this vertex\n\t\t\tv.collapseCost = v.totalCost / v.costCount;\n\t\t\t// v.collapseCost = v.minCost;\n\n\t\t}\n\n\t\tfunction removeVertex( v, vertices ) {\n\n\t\t\tconsole.assert( v.faces.length === 0 );\n\n\t\t\twhile ( v.neighbors.length ) {\n\n\t\t\t\tvar n = v.neighbors.pop();\n\t\t\t\tremoveFromArray( n.neighbors, v );\n\n\t\t\t}\n\n\t\t\tremoveFromArray( vertices, v );\n\n\t\t}\n\n\t\tfunction removeFace( f, faces ) {\n\n\t\t\tremoveFromArray( faces, f );\n\n\t\t\tif ( f.v1 ) removeFromArray( f.v1.faces, f );\n\t\t\tif ( f.v2 ) removeFromArray( f.v2.faces, f );\n\t\t\tif ( f.v3 ) removeFromArray( f.v3.faces, f );\n\n\t\t\t// TODO optimize this!\n\t\t\tvar vs = [ f.v1, f.v2, f.v3 ];\n\t\t\tvar v1, v2;\n\n\t\t\tfor ( var i = 0; i < 3; i ++ ) {\n\n\t\t\t\tv1 = vs[ i ];\n\t\t\t\tv2 = vs[ ( i + 1 ) % 3 ];\n\n\t\t\t\tif ( ! v1 || ! v2 ) continue;\n\n\t\t\t\tv1.removeIfNonNeighbor( v2 );\n\t\t\t\tv2.removeIfNonNeighbor( v1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction collapse( vertices, faces, u, v ) { // u and v are pointers to vertices of an edge\n\n\t\t\t// Collapse the edge uv by moving vertex u onto v\n\n\t\t\tif ( ! v ) {\n\n\t\t\t\t// u is a vertex all by itself so just delete it..\n\t\t\t\tremoveVertex( u, vertices );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar i;\n\t\t\tvar tmpVertices = [];\n\n\t\t\tfor ( i = 0; i < u.neighbors.length; i ++ ) {\n\n\t\t\t\ttmpVertices.push( u.neighbors[ i ] );\n\n\t\t\t}\n\n\n\t\t\t// delete triangles on edge uv:\n\t\t\tfor ( i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tif ( u.faces[ i ].hasVertex( v ) ) {\n\n\t\t\t\t\tremoveFace( u.faces[ i ], faces );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update remaining triangles to have v instead of u\n\t\t\tfor ( i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tu.faces[ i ].replaceVertex( u, v );\n\n\t\t\t}\n\n\n\t\t\tremoveVertex( u, vertices );\n\n\t\t\t// recompute the edge collapse costs in neighborhood\n\t\t\tfor ( i = 0; i < tmpVertices.length; i ++ ) {\n\n\t\t\t\tcomputeEdgeCostAtVertex( tmpVertices[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\n\n\t\tfunction minimumCostEdge( vertices ) {\n\n\t\t\t// O(n * n) approach. TODO optimize this\n\n\t\t\tvar least = vertices[ 0 ];\n\n\t\t\tfor ( var i = 0; i < vertices.length; i ++ ) {\n\n\t\t\t\tif ( vertices[ i ].collapseCost < least.collapseCost ) {\n\n\t\t\t\t\tleast = vertices[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn least;\n\n\t\t}\n\n\t\t// we use a triangle class to represent structure of face slightly differently\n\n\t\tfunction Triangle( v1, v2, v3, a, b, c ) {\n\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\n\t\t\tthis.normal = new THREE.Vector3();\n\n\t\t\tthis.computeNormal();\n\n\t\t\tv1.faces.push( this );\n\t\t\tv1.addUniqueNeighbor( v2 );\n\t\t\tv1.addUniqueNeighbor( v3 );\n\n\t\t\tv2.faces.push( this );\n\t\t\tv2.addUniqueNeighbor( v1 );\n\t\t\tv2.addUniqueNeighbor( v3 );\n\n\n\t\t\tv3.faces.push( this );\n\t\t\tv3.addUniqueNeighbor( v1 );\n\t\t\tv3.addUniqueNeighbor( v2 );\n\n\t\t}\n\n\t\tTriangle.prototype.computeNormal = function () {\n\n\t\t\tvar vA = this.v1.position;\n\t\t\tvar vB = this.v2.position;\n\t\t\tvar vC = this.v3.position;\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab ).normalize();\n\n\t\t\tthis.normal.copy( cb );\n\n\t\t};\n\n\t\tTriangle.prototype.hasVertex = function ( v ) {\n\n\t\t\treturn v === this.v1 || v === this.v2 || v === this.v3;\n\n\t\t};\n\n\t\tTriangle.prototype.replaceVertex = function ( oldv, newv ) {\n\n\t\t\tif ( oldv === this.v1 ) this.v1 = newv;\n\t\t\telse if ( oldv === this.v2 ) this.v2 = newv;\n\t\t\telse if ( oldv === this.v3 ) this.v3 = newv;\n\n\t\t\tremoveFromArray( oldv.faces, this );\n\t\t\tnewv.faces.push( this );\n\n\n\t\t\toldv.removeIfNonNeighbor( this.v1 );\n\t\t\tthis.v1.removeIfNonNeighbor( oldv );\n\n\t\t\toldv.removeIfNonNeighbor( this.v2 );\n\t\t\tthis.v2.removeIfNonNeighbor( oldv );\n\n\t\t\toldv.removeIfNonNeighbor( this.v3 );\n\t\t\tthis.v3.removeIfNonNeighbor( oldv );\n\n\t\t\tthis.v1.addUniqueNeighbor( this.v2 );\n\t\t\tthis.v1.addUniqueNeighbor( this.v3 );\n\n\t\t\tthis.v2.addUniqueNeighbor( this.v1 );\n\t\t\tthis.v2.addUniqueNeighbor( this.v3 );\n\n\t\t\tthis.v3.addUniqueNeighbor( this.v1 );\n\t\t\tthis.v3.addUniqueNeighbor( this.v2 );\n\n\t\t\tthis.computeNormal();\n\n\t\t};\n\n\t\tfunction Vertex( v, id ) {\n\n\t\t\tthis.position = v;\n\n\t\t\tthis.id = id; // old index id\n\n\t\t\tthis.faces = []; // faces vertex is connected\n\t\t\tthis.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n\n\t\t\t// these will be computed in computeEdgeCostAtVertex()\n\t\t\tthis.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\t\t\tthis.collapseNeighbor = null; // best candinate for collapsing\n\n\t\t}\n\n\t\tVertex.prototype.addUniqueNeighbor = function ( vertex ) {\n\n\t\t\tpushIfUnique( this.neighbors, vertex );\n\n\t\t};\n\n\t\tVertex.prototype.removeIfNonNeighbor = function ( n ) {\n\n\t\t\tvar neighbors = this.neighbors;\n\t\t\tvar faces = this.faces;\n\n\t\t\tvar offset = neighbors.indexOf( n );\n\t\t\tif ( offset === - 1 ) return;\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tif ( faces[ i ].hasVertex( n ) ) return;\n\n\t\t\t}\n\n\t\t\tneighbors.splice( offset, 1 );\n\n\t\t};\n\n\t\tTHREE.SimplifyModifier.prototype.modify = function ( geometry, count ) {\n\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry( geometry );\n\n\t\t\t}\n\n\t\t\tgeometry.mergeVertices();\n\n\t\t\tvar oldVertices = geometry.vertices; // Three Position\n\t\t\tvar oldFaces = geometry.faces; // Three Face\n\n\t\t\t// conversion\n\t\t\tvar vertices = [];\n\t\t\tvar faces = [];\n\n\t\t\tvar i, il;\n\n\t\t\t//\n\t\t\t// put data of original geometry in different data structures\n\t\t\t//\n\n\t\t\t// add vertices\n\n\t\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\n\n\t\t\t\tvar vertex = new Vertex( oldVertices[ i ], i );\n\t\t\t\tvertices.push( vertex );\n\n\t\t\t}\n\n\t\t\t// add faces\n\n\t\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = oldFaces[ i ];\n\n\t\t\t\tvar a = face.a;\n\t\t\t\tvar b = face.b;\n\t\t\t\tvar c = face.c;\n\n\t\t\t\tvar triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\n\t\t\t\tfaces.push( triangle );\n\n\t\t\t}\n\n\t\t\t// compute all edge collapse costs\n\n\t\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tcomputeEdgeCostAtVertex( vertices[ i ] );\n\n\t\t\t}\n\n\t\t\tvar nextVertex;\n\n\t\t\tvar z = count;\n\n\t\t\twhile ( z -- ) {\n\n\t\t\t\tnextVertex = minimumCostEdge( vertices );\n\n\t\t\t\tif ( ! nextVertex ) {\n\n\t\t\t\t\tconsole.log( 'THREE.SimplifyModifier: No next vertex' );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcollapse( vertices, faces, nextVertex, nextVertex.collapseNeighbor );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar simplifiedGeometry = new THREE.BufferGeometry();\n\t\t\tvar position = [];\n\t\t\tvar index = [];\n\n\t\t\t//\n\n\t\t\tfor ( i = 0; i < vertices.length; i ++ ) {\n\n\t\t\t\tvar vertex = vertices[ i ].position;\n\t\t\t\tposition.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfor ( i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tvar a = vertices.indexOf( face.v1 );\n\t\t\t\tvar b = vertices.indexOf( face.v2 );\n\t\t\t\tvar c = vertices.indexOf( face.v3 );\n\n\t\t\t\tindex.push( a, b, c );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tsimplifiedGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( position, 3 ) );\n\t\t\tsimplifiedGeometry.setIndex( index );\n\n\t\t\treturn simplifiedGeometry;\n\n\t\t};\n\n\t} )();\n\t\n\treturn THREE.SimplifyModifier;\n});\n\ndefine('skylark-threejs-ex/modifiers/SubdivisionModifier',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n\t *\t@author centerionware / http://www.centerionware.com\n\t *\n\t *\tSubdivision Geometry Modifier\n\t *\t\tusing Loop Subdivision Scheme\n\t *\n\t *\tReferences:\n\t *\t\thttp://graphics.stanford.edu/~mdfisher/subdivision.html\n\t *\t\thttp://www.holmes3d.net/graphics/subdivision/\n\t *\t\thttp://www.cs.rutgers.edu/~decarlo/readings/subdiv-sg00c.pdf\n\t *\n\t *\tKnown Issues:\n\t *\t\t- currently doesn't handle \"Sharp Edges\"\n\t */\n\n\tTHREE.SubdivisionModifier = function ( subdivisions ) {\n\n\t\tthis.subdivisions = ( subdivisions === undefined ) ? 1 : subdivisions;\n\n\t};\n\n\t// Applies the \"modify\" pattern\n\tTHREE.SubdivisionModifier.prototype.modify = function ( geometry ) {\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry( geometry );\n\n\t\t} else {\n\n\t\t\tgeometry = geometry.clone();\n\n\t\t}\n\n\t\tgeometry.mergeVertices();\n\n\t\tvar repeats = this.subdivisions;\n\n\t\twhile ( repeats -- > 0 ) {\n\n\t\t\tthis.smooth( geometry );\n\n\t\t}\n\n\t\tgeometry.computeFaceNormals();\n\t\tgeometry.computeVertexNormals();\n\n\t\treturn geometry;\n\n\t};\n\n\t( function () {\n\n\t\t// Some constants\n\t\tvar ABC = [ 'a', 'b', 'c' ];\n\n\n\t\tfunction getEdge( a, b, map ) {\n\n\t\t\tvar vertexIndexA = Math.min( a, b );\n\t\t\tvar vertexIndexB = Math.max( a, b );\n\n\t\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\n\n\t\t\treturn map[ key ];\n\n\t\t}\n\n\n\t\tfunction processEdge( a, b, vertices, map, face, metaVertices ) {\n\n\t\t\tvar vertexIndexA = Math.min( a, b );\n\t\t\tvar vertexIndexB = Math.max( a, b );\n\n\t\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\n\n\t\t\tvar edge;\n\n\t\t\tif ( key in map ) {\n\n\t\t\t\tedge = map[ key ];\n\n\t\t\t} else {\n\n\t\t\t\tvar vertexA = vertices[ vertexIndexA ];\n\t\t\t\tvar vertexB = vertices[ vertexIndexB ];\n\n\t\t\t\tedge = {\n\n\t\t\t\t\ta: vertexA, // pointer reference\n\t\t\t\t\tb: vertexB,\n\t\t\t\t\tnewEdge: null,\n\t\t\t\t\t// aIndex: a, // numbered reference\n\t\t\t\t\t// bIndex: b,\n\t\t\t\t\tfaces: [] // pointers to face\n\n\t\t\t\t};\n\n\t\t\t\tmap[ key ] = edge;\n\n\t\t\t}\n\n\t\t\tedge.faces.push( face );\n\n\t\t\tmetaVertices[ a ].edges.push( edge );\n\t\t\tmetaVertices[ b ].edges.push( edge );\n\n\n\t\t}\n\n\t\tfunction generateLookups( vertices, faces, metaVertices, edges ) {\n\n\t\t\tvar i, il, face;\n\n\t\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tmetaVertices[ i ] = { edges: [] };\n\n\t\t\t}\n\n\t\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\n\t\t\t\tprocessEdge( face.a, face.b, vertices, edges, face, metaVertices );\n\t\t\t\tprocessEdge( face.b, face.c, vertices, edges, face, metaVertices );\n\t\t\t\tprocessEdge( face.c, face.a, vertices, edges, face, metaVertices );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction newFace( newFaces, a, b, c, materialIndex ) {\n\n\t\t\tnewFaces.push( new THREE.Face3( a, b, c, undefined, undefined, materialIndex ) );\n\n\t\t}\n\n\t\tfunction midpoint( a, b ) {\n\n\t\t\treturn ( Math.abs( b - a ) / 2 ) + Math.min( a, b );\n\n\t\t}\n\n\t\tfunction newUv( newUvs, a, b, c ) {\n\n\t\t\tnewUvs.push( [ a.clone(), b.clone(), c.clone() ] );\n\n\t\t}\n\n\t\t/////////////////////////////\n\n\t\t// Performs one iteration of Subdivision\n\t\tTHREE.SubdivisionModifier.prototype.smooth = function ( geometry ) {\n\n\t\t\tvar tmp = new THREE.Vector3();\n\n\t\t\tvar oldVertices, oldFaces, oldUvs;\n\t\t\tvar newVertices, newFaces, newUVs = [];\n\n\t\t\tvar n, i, il, j, k;\n\t\t\tvar metaVertices, sourceEdges;\n\n\t\t\t// new stuff.\n\t\t\tvar sourceEdges, newEdgeVertices, newSourceVertices;\n\n\t\t\toldVertices = geometry.vertices; // { x, y, z}\n\t\t\toldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }\n\t\t\toldUvs = geometry.faceVertexUvs;\n\n\t\t\tvar hasUvs = oldUvs[ 0 ] !== undefined && oldUvs[ 0 ].length > 0;\n\n\t\t\tif ( hasUvs ) {\n\n\t\t\t\tfor ( var j = 0; j < oldUvs.length; j ++ ) {\n\n\t\t\t\t\tnewUVs.push( [] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/******************************************************\n\t\t\t *\n\t\t\t * Step 0: Preprocess Geometry to Generate edges Lookup\n\t\t\t *\n\t\t\t *******************************************************/\n\n\t\t\tmetaVertices = new Array( oldVertices.length );\n\t\t\tsourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }\n\n\t\t\tgenerateLookups( oldVertices, oldFaces, metaVertices, sourceEdges );\n\n\n\t\t\t/******************************************************\n\t\t\t *\n\t\t\t *\tStep 1.\n\t\t\t *\tFor each edge, create a new Edge Vertex,\n\t\t\t *\tthen position it.\n\t\t\t *\n\t\t\t *******************************************************/\n\n\t\t\tnewEdgeVertices = [];\n\t\t\tvar other, currentEdge, newEdge, face;\n\t\t\tvar edgeVertexWeight, adjacentVertexWeight, connectedFaces;\n\n\t\t\tfor ( i in sourceEdges ) {\n\n\t\t\t\tcurrentEdge = sourceEdges[ i ];\n\t\t\t\tnewEdge = new THREE.Vector3();\n\n\t\t\t\tedgeVertexWeight = 3 / 8;\n\t\t\t\tadjacentVertexWeight = 1 / 8;\n\n\t\t\t\tconnectedFaces = currentEdge.faces.length;\n\n\t\t\t\t// check how many linked faces. 2 should be correct.\n\t\t\t\tif ( connectedFaces != 2 ) {\n\n\t\t\t\t\t// if length is not 2, handle condition\n\t\t\t\t\tedgeVertexWeight = 0.5;\n\t\t\t\t\tadjacentVertexWeight = 0;\n\n\t\t\t\t\tif ( connectedFaces != 1 ) {\n\n\t\t\t\t\t\t// console.warn( 'Subdivision Modifier: Number of connected faces != 2, is: ', connectedFaces, currentEdge );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnewEdge.addVectors( currentEdge.a, currentEdge.b ).multiplyScalar( edgeVertexWeight );\n\n\t\t\t\ttmp.set( 0, 0, 0 );\n\n\t\t\t\tfor ( j = 0; j < connectedFaces; j ++ ) {\n\n\t\t\t\t\tface = currentEdge.faces[ j ];\n\n\t\t\t\t\tfor ( k = 0; k < 3; k ++ ) {\n\n\t\t\t\t\t\tother = oldVertices[ face[ ABC[ k ] ] ];\n\t\t\t\t\t\tif ( other !== currentEdge.a && other !== currentEdge.b ) break;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttmp.add( other );\n\n\t\t\t\t}\n\n\t\t\t\ttmp.multiplyScalar( adjacentVertexWeight );\n\t\t\t\tnewEdge.add( tmp );\n\n\t\t\t\tcurrentEdge.newEdge = newEdgeVertices.length;\n\t\t\t\tnewEdgeVertices.push( newEdge );\n\n\t\t\t\t// console.log(currentEdge, newEdge);\n\n\t\t\t}\n\n\t\t\t/******************************************************\n\t\t\t *\n\t\t\t *\tStep 2.\n\t\t\t *\tReposition each source vertices.\n\t\t\t *\n\t\t\t *******************************************************/\n\n\t\t\tvar beta, sourceVertexWeight, connectingVertexWeight;\n\t\t\tvar connectingEdge, connectingEdges, oldVertex, newSourceVertex;\n\t\t\tnewSourceVertices = [];\n\n\t\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\n\n\t\t\t\toldVertex = oldVertices[ i ];\n\n\t\t\t\t// find all connecting edges (using lookupTable)\n\t\t\t\tconnectingEdges = metaVertices[ i ].edges;\n\t\t\t\tn = connectingEdges.length;\n\n\t\t\t\tif ( n == 3 ) {\n\n\t\t\t\t\tbeta = 3 / 16;\n\n\t\t\t\t} else if ( n > 3 ) {\n\n\t\t\t\t\tbeta = 3 / ( 8 * n ); // Warren's modified formula\n\n\t\t\t\t}\n\n\t\t\t\t// Loop's original beta formula\n\t\t\t\t// beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );\n\n\t\t\t\tsourceVertexWeight = 1 - n * beta;\n\t\t\t\tconnectingVertexWeight = beta;\n\n\t\t\t\tif ( n <= 2 ) {\n\n\t\t\t\t\t// crease and boundary rules\n\t\t\t\t\t// console.warn('crease and boundary rules');\n\n\t\t\t\t\tif ( n == 2 ) {\n\n\t\t\t\t\t\t// console.warn( '2 connecting edges', connectingEdges );\n\t\t\t\t\t\tsourceVertexWeight = 3 / 4;\n\t\t\t\t\t\tconnectingVertexWeight = 1 / 8;\n\n\t\t\t\t\t\t// sourceVertexWeight = 1;\n\t\t\t\t\t\t// connectingVertexWeight = 0;\n\n\t\t\t\t\t} else if ( n == 1 ) {\n\n\t\t\t\t\t\t// console.warn( 'only 1 connecting edge' );\n\n\t\t\t\t\t} else if ( n == 0 ) {\n\n\t\t\t\t\t\t// console.warn( '0 connecting edges' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnewSourceVertex = oldVertex.clone().multiplyScalar( sourceVertexWeight );\n\n\t\t\t\ttmp.set( 0, 0, 0 );\n\n\t\t\t\tfor ( j = 0; j < n; j ++ ) {\n\n\t\t\t\t\tconnectingEdge = connectingEdges[ j ];\n\t\t\t\t\tother = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\n\t\t\t\t\ttmp.add( other );\n\n\t\t\t\t}\n\n\t\t\t\ttmp.multiplyScalar( connectingVertexWeight );\n\t\t\t\tnewSourceVertex.add( tmp );\n\n\t\t\t\tnewSourceVertices.push( newSourceVertex );\n\n\t\t\t}\n\n\n\t\t\t/******************************************************\n\t\t\t *\n\t\t\t *\tStep 3.\n\t\t\t *\tGenerate Faces between source vertices\n\t\t\t *\tand edge vertices.\n\t\t\t *\n\t\t\t *******************************************************/\n\n\t\t\tnewVertices = newSourceVertices.concat( newEdgeVertices );\n\t\t\tvar sl = newSourceVertices.length, edge1, edge2, edge3;\n\t\t\tnewFaces = [];\n\n\t\t\tvar uv, x0, x1, x2;\n\t\t\tvar x3 = new THREE.Vector2();\n\t\t\tvar x4 = new THREE.Vector2();\n\t\t\tvar x5 = new THREE.Vector2();\n\n\t\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\n\n\t\t\t\tface = oldFaces[ i ];\n\n\t\t\t\t// find the 3 new edges vertex of each old face\n\n\t\t\t\tedge1 = getEdge( face.a, face.b, sourceEdges ).newEdge + sl;\n\t\t\t\tedge2 = getEdge( face.b, face.c, sourceEdges ).newEdge + sl;\n\t\t\t\tedge3 = getEdge( face.c, face.a, sourceEdges ).newEdge + sl;\n\n\t\t\t\t// create 4 faces.\n\n\t\t\t\tnewFace( newFaces, edge1, edge2, edge3, face.materialIndex );\n\t\t\t\tnewFace( newFaces, face.a, edge1, edge3, face.materialIndex );\n\t\t\t\tnewFace( newFaces, face.b, edge2, edge1, face.materialIndex );\n\t\t\t\tnewFace( newFaces, face.c, edge3, edge2, face.materialIndex );\n\n\t\t\t\t// create 4 new uv's\n\n\t\t\t\tif ( hasUvs ) {\n\n\t\t\t\t\tfor ( var j = 0; j < oldUvs.length; j ++ ) {\n\n\t\t\t\t\t\tuv = oldUvs[ j ][ i ];\n\n\t\t\t\t\t\tx0 = uv[ 0 ];\n\t\t\t\t\t\tx1 = uv[ 1 ];\n\t\t\t\t\t\tx2 = uv[ 2 ];\n\n\t\t\t\t\t\tx3.set( midpoint( x0.x, x1.x ), midpoint( x0.y, x1.y ) );\n\t\t\t\t\t\tx4.set( midpoint( x1.x, x2.x ), midpoint( x1.y, x2.y ) );\n\t\t\t\t\t\tx5.set( midpoint( x0.x, x2.x ), midpoint( x0.y, x2.y ) );\n\n\t\t\t\t\t\tnewUv( newUVs[ j ], x3, x4, x5 );\n\t\t\t\t\t\tnewUv( newUVs[ j ], x0, x3, x5 );\n\n\t\t\t\t\t\tnewUv( newUVs[ j ], x1, x4, x3 );\n\t\t\t\t\t\tnewUv( newUVs[ j ], x2, x5, x4 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Overwrite old arrays\n\t\t\tgeometry.vertices = newVertices;\n\t\t\tgeometry.faces = newFaces;\n\t\t\tif ( hasUvs ) geometry.faceVertexUvs = newUVs;\n\n\t\t\t// console.log('done');\n\n\t\t};\n\n\t} )();\n\t\n\treturn THREE.SubdivisionModifier;\n});\n\ndefine('skylark-threejs-ex/exporters/DRACOExporter',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * Export draco compressed files from threejs geometry objects.\n\t *\n\t * Draco files are compressed and usually are smaller than conventional 3D file formats.\n\t *\n\t * The exporter receives a options object containing\n\t *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\n\t *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\n\t *  - encoderMethod\n\t *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\n\t *  - exportUvs\n\t *  - exportNormals\n\t *\n\t * @class DRACOExporter\n\t * @author tentone\n\t */\n\n\t/* global DracoEncoderModule */\n\n\tTHREE.DRACOExporter = function () {};\n\n\tTHREE.DRACOExporter.prototype = {\n\n\t\tconstructor: THREE.DRACOExporter,\n\n\t\tparse: function ( geometry, options ) {\n\n\n\t\t\tif ( DracoEncoderModule === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.DRACOExporter: required the draco_decoder to work.' );\n\n\t\t\t}\n\n\t\t\tif ( options === undefined ) {\n\n\t\t\t\toptions = {\n\n\t\t\t\t\tdecodeSpeed: 5,\n\t\t\t\t\tencodeSpeed: 5,\n\t\t\t\t\tencoderMethod: THREE.DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n\t\t\t\t\tquantization: [ 16, 8, 8, 8, 8 ],\n\t\t\t\t\texportUvs: true,\n\t\t\t\t\texportNormals: true,\n\t\t\t\t\texportColor: false,\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar dracoEncoder = DracoEncoderModule();\n\t\t\tvar encoder = new dracoEncoder.Encoder();\n\t\t\tvar builder = new dracoEncoder.MeshBuilder();\n\t\t\tvar mesh = new dracoEncoder.Mesh();\n\n\t\t\tif ( geometry.isGeometry === true ) {\n\n\t\t\t\tvar bufferGeometry = new THREE.BufferGeometry();\n\t\t\t\tbufferGeometry.fromGeometry( geometry );\n\t\t\t\tgeometry = bufferGeometry;\n\n\t\t\t}\n\n\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.Geometry or THREE.BufferGeometry instance.' );\n\n\t\t\t}\n\n\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\t\t\tbuilder.AddFloatAttributeToMesh( mesh, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array );\n\n\t\t\tvar faces = geometry.getIndex();\n\n\t\t\tif ( faces !== null ) {\n\n\t\t\t\tbuilder.AddFacesToMesh( mesh, faces.count, faces.array );\n\n\t\t\t} else {\n\n\t\t\t\tvar faces = new ( vertices.count > 65535 ? Uint32Array : Uint16Array )( vertices.count );\n\n\t\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\t\tfaces[ i ] = i;\n\n\t\t\t\t}\n\n\t\t\t\tbuilder.AddFacesToMesh( mesh, vertices.count, faces );\n\n\t\t\t}\n\n\t\t\tif ( options.exportNormals === true ) {\n\n\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\n\n\t\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\t\tbuilder.AddFloatAttributeToMesh( mesh, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.exportUvs === true ) {\n\n\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\tbuilder.AddFloatAttributeToMesh( mesh, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.exportColor === true ) {\n\n\t\t\t\tvar colors = geometry.getAttribute( 'color' );\n\n\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\tbuilder.AddFloatAttributeToMesh( mesh, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//Compress using draco encoder\n\n\t\t\tvar encodedData = new dracoEncoder.DracoInt8Array();\n\n\t\t\t//Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n\t\t\tencoder.SetSpeedOptions( options.encodeSpeed || 5, options.decodeSpeed || 5 );\n\n\t\t\t// Sets the desired encoding method for a given geometry.\n\n\t\t\tif ( options.encoderMethod !== undefined ) {\n\n\t\t\t\tencoder.SetEncodingMethod( options.encoderMethod );\n\n\t\t\t}\n\n\t\t\t// Sets the quantization (number of bits used to represent) compression options for a named attribute.\n\t\t\t// The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n\t\t\tif ( options.quantization !== undefined ) {\n\n\t\t\t\tfor ( var i = 0; i < 5; i ++ ) {\n\n\t\t\t\t\tif ( options.quantization[ i ] !== undefined ) {\n\n\t\t\t\t\t\tencoder.SetAttributeQuantization( i, options.quantization[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar length = encoder.EncodeMeshToDracoBuffer( mesh, encodedData );\n\t\t\tdracoEncoder.destroy( mesh );\n\n\t\t\tif ( length === 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.DRACOExporter: Draco encoding failed.' );\n\n\t\t\t}\n\n\t\t\t//Copy encoded data to buffer.\n\t\t\tvar outputData = new Int8Array( new ArrayBuffer( length ) );\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\toutputData[ i ] = encodedData.GetValue( i );\n\n\t\t\t}\n\n\t\t\tdracoEncoder.destroy( encodedData );\n\t\t\tdracoEncoder.destroy( encoder );\n\t\t\tdracoEncoder.destroy( builder );\n\n\t\t\treturn outputData;\n\n\t\t}\n\n\t};\n\n\t// Encoder methods\n\n\tTHREE.DRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;\n\tTHREE.DRACOExporter.MESH_SEQUENTIAL_ENCODING = 0;\n\n\t// Geometry type\n\n\tTHREE.DRACOExporter.POINT_CLOUD = 0;\n\tTHREE.DRACOExporter.TRIANGULAR_MESH = 1;\n\n\t// Attribute type\n\n\tTHREE.DRACOExporter.INVALID = - 1;\n\tTHREE.DRACOExporter.POSITION = 0;\n\tTHREE.DRACOExporter.NORMAL = 1;\n\tTHREE.DRACOExporter.COLOR = 2;\n\tTHREE.DRACOExporter.TEX_COORD = 3;\n\tTHREE.DRACOExporter.GENERIC = 4;\n\t\n\treturn THREE.DRACOExporter;\n});\n\ndefine('skylark-threejs-ex/exporters/OBJExporter',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tTHREE.OBJExporter = function () {};\n\n\tTHREE.OBJExporter.prototype = {\n\n\t\tconstructor: THREE.OBJExporter,\n\n\t\tparse: function ( object ) {\n\n\t\t\tvar output = '';\n\n\t\t\tvar indexVertex = 0;\n\t\t\tvar indexVertexUvs = 0;\n\t\t\tvar indexNormals = 0;\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvar normal = new THREE.Vector3();\n\t\t\tvar uv = new THREE.Vector2();\n\n\t\t\tvar i, j, k, l, m, face = [];\n\n\t\t\tvar parseMesh = function ( mesh ) {\n\n\t\t\t\tvar nbVertex = 0;\n\t\t\t\tvar nbNormals = 0;\n\t\t\t\tvar nbVertexUvs = 0;\n\n\t\t\t\tvar geometry = mesh.geometry;\n\n\t\t\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\n\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\tgeometry = new THREE.BufferGeometry().setFromObject( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t// shortcuts\n\t\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\t\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\n\t\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\n\t\t\t\t\tvar indices = geometry.getIndex();\n\n\t\t\t\t\t// name of the mesh object\n\t\t\t\t\toutput += 'o ' + mesh.name + '\\n';\n\n\t\t\t\t\t// name of the mesh material\n\t\t\t\t\tif ( mesh.material && mesh.material.name ) {\n\n\t\t\t\t\t\toutput += 'usemtl ' + mesh.material.name + '\\n';\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// vertices\n\n\t\t\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\t\t\tfor ( i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\t\t\t// transfrom the vertex to world space\n\t\t\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\t\tfor ( i = 0, l = uvs.count; i < l; i ++, nbVertexUvs ++ ) {\n\n\t\t\t\t\t\t\tuv.x = uvs.getX( i );\n\t\t\t\t\t\t\tuv.y = uvs.getY( i );\n\n\t\t\t\t\t\t\t// transform the uv to export format\n\t\t\t\t\t\t\toutput += 'vt ' + uv.x + ' ' + uv.y + '\\n';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// normals\n\n\t\t\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\t\t\tfor ( i = 0, l = normals.count; i < l; i ++, nbNormals ++ ) {\n\n\t\t\t\t\t\t\tnormal.x = normals.getX( i );\n\t\t\t\t\t\t\tnormal.y = normals.getY( i );\n\t\t\t\t\t\t\tnormal.z = normals.getZ( i );\n\n\t\t\t\t\t\t\t// transfrom the normal to world space\n\t\t\t\t\t\t\tnormal.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\t// transform the normal to export format\n\t\t\t\t\t\t\toutput += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\tfor ( i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tfor ( m = 0; m < 3; m ++ ) {\n\n\t\t\t\t\t\t\t\tj = indices.getX( i + m ) + 1;\n\n\t\t\t\t\t\t\t\tface[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// transform the face to export format\n\t\t\t\t\t\t\toutput += 'f ' + face.join( ' ' ) + \"\\n\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tfor ( m = 0; m < 3; m ++ ) {\n\n\t\t\t\t\t\t\t\tj = i + m + 1;\n\n\t\t\t\t\t\t\t\tface[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// transform the face to export format\n\t\t\t\t\t\t\toutput += 'f ' + face.join( ' ' ) + \"\\n\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.OBJExporter.parseMesh(): geometry type unsupported', geometry );\n\n\t\t\t\t}\n\n\t\t\t\t// update index\n\t\t\t\tindexVertex += nbVertex;\n\t\t\t\tindexVertexUvs += nbVertexUvs;\n\t\t\t\tindexNormals += nbNormals;\n\n\t\t\t};\n\n\t\t\tvar parseLine = function ( line ) {\n\n\t\t\t\tvar nbVertex = 0;\n\n\t\t\t\tvar geometry = line.geometry;\n\t\t\t\tvar type = line.type;\n\n\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\tgeometry = new THREE.BufferGeometry().setFromObject( line );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t// shortcuts\n\t\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\n\t\t\t\t\t// name of the line object\n\t\t\t\t\toutput += 'o ' + line.name + '\\n';\n\n\t\t\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\t\t\tfor ( i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\t\t\t// transfrom the vertex to world space\n\t\t\t\t\t\t\tvertex.applyMatrix4( line.matrixWorld );\n\n\t\t\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( type === 'Line' ) {\n\n\t\t\t\t\t\toutput += 'l ';\n\n\t\t\t\t\t\tfor ( j = 1, l = vertices.count; j <= l; j ++ ) {\n\n\t\t\t\t\t\t\toutput += ( indexVertex + j ) + ' ';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toutput += '\\n';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( type === 'LineSegments' ) {\n\n\t\t\t\t\t\tfor ( j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1 ) {\n\n\t\t\t\t\t\t\toutput += 'l ' + ( indexVertex + j ) + ' ' + ( indexVertex + k ) + '\\n';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.OBJExporter.parseLine(): geometry type unsupported', geometry );\n\n\t\t\t\t}\n\n\t\t\t\t// update index\n\t\t\t\tindexVertex += nbVertex;\n\n\t\t\t};\n\n\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\tif ( child instanceof THREE.Mesh ) {\n\n\t\t\t\t\tparseMesh( child );\n\n\t\t\t\t}\n\n\t\t\t\tif ( child instanceof THREE.Line ) {\n\n\t\t\t\t\tparseLine( child );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn output;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.OBJExporter;\n});\n\ndefine('skylark-threejs-ex/exporters/STLExporter',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author kovacsv / http://kovacsv.hu/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mudcube / http://mudcu.be/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Usage:\n\t *  var exporter = new THREE.STLExporter();\n\t *\n\t *  // second argument is a list of options\n\t *  var data = exporter.parse( mesh, { binary: true } );\n\t *\n\t */\n\n\tTHREE.STLExporter = function () {};\n\n\tTHREE.STLExporter.prototype = {\n\n\t\tconstructor: THREE.STLExporter,\n\n\t\tparse: ( function () {\n\n\t\t\tvar vector = new THREE.Vector3();\n\t\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\n\t\t\treturn function parse( scene, options ) {\n\n\t\t\t\tif ( options === undefined ) options = {};\n\n\t\t\t\tvar binary = options.binary !== undefined ? options.binary : false;\n\n\t\t\t\t//\n\n\t\t\t\tvar objects = [];\n\t\t\t\tvar triangles = 0;\t\n\n\t\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.isMesh ) {\n\n\t\t\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry( geometry );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\t\t\t\ttriangles += geometry.faces.length;\n\n\t\t\t\t\t\t\tobjects.push( {\n\n\t\t\t\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\t\t\t\tmatrixWorld: object.matrixWorld\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tif ( binary ) {\n\n\t\t\t\t\tvar offset = 80; // skip header\n\t\t\t\t\tvar bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n\t\t\t\t\tvar arrayBuffer = new ArrayBuffer( bufferLength );\n\t\t\t\t\tvar output = new DataView( arrayBuffer );\n\t\t\t\t\toutput.setUint32( offset, triangles, true ); offset += 4;\n\n\t\t\t\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar object = objects[ i ];\n\n\t\t\t\t\t\tvar vertices = object.geometry.vertices;\n\t\t\t\t\t\tvar faces = object.geometry.faces;\n\t\t\t\t\t\tvar matrixWorld = object.matrixWorld;\n\n\t\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( matrixWorld );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = faces.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar face = faces[ j ];\n\n\t\t\t\t\t\t\tvector.copy( face.normal ).applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\toutput.setFloat32( offset, vector.x, true ); offset += 4; // normal\n\t\t\t\t\t\t\toutput.setFloat32( offset, vector.y, true ); offset += 4;\n\t\t\t\t\t\t\toutput.setFloat32( offset, vector.z, true ); offset += 4;\n\n\t\t\t\t\t\t\tvar indices = [ face.a, face.b, face.c ];\n\n\t\t\t\t\t\t\tfor ( var k = 0; k < 3; k ++ ) {\n\n\t\t\t\t\t\t\t\tvector.copy( vertices[ indices[ k ] ] ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\t\t\toutput.setFloat32( offset, vector.x, true ); offset += 4; // vertices\n\t\t\t\t\t\t\t\toutput.setFloat32( offset, vector.y, true ); offset += 4;\n\t\t\t\t\t\t\t\toutput.setFloat32( offset, vector.z, true ); offset += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutput.setUint16( offset, 0, true ); offset += 2; // attribute byte count\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn output;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar output = '';\n\n\t\t\t\t\toutput += 'solid exported\\n';\n\n\t\t\t\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar object = objects[ i ];\n\n\t\t\t\t\t\tvar vertices = object.geometry.vertices;\n\t\t\t\t\t\tvar faces = object.geometry.faces;\n\t\t\t\t\t\tvar matrixWorld = object.matrixWorld;\n\n\t\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( matrixWorld );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = faces.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar face = faces[ j ];\n\n\t\t\t\t\t\t\tvector.copy( face.normal ).applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\toutput += '\\tfacet normal ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\\n';\n\t\t\t\t\t\t\toutput += '\\t\\touter loop\\n';\n\n\t\t\t\t\t\t\tvar indices = [ face.a, face.b, face.c ];\n\n\t\t\t\t\t\t\tfor ( var k = 0; k < 3; k ++ ) {\n\n\t\t\t\t\t\t\t\tvector.copy( vertices[ indices[ k ] ] ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\t\t\toutput += '\\t\\t\\tvertex ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\\n';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutput += '\\t\\tendloop\\n';\n\t\t\t\t\t\t\toutput += '\\tendfacet\\n';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutput += 'endsolid exported\\n';\n\n\t\t\t\t\treturn output;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() )\n\n\t};\n\t\n\treturn THREE.STLExporter;\n});\n\ndefine('skylark-threejs-ex/exporters/GLTFExporter',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author fernandojsg / http://fernandojsg.com\n\t * @author Don McCurdy / https://www.donmccurdy.com\n\t * @author Takahiro / https://github.com/takahirox\n\t */\n\n\t//------------------------------------------------------------------------------\n\t// Constants\n\t//------------------------------------------------------------------------------\n\tvar WEBGL_CONSTANTS = {\n\t\tPOINTS: 0x0000,\n\t\tLINES: 0x0001,\n\t\tLINE_LOOP: 0x0002,\n\t\tLINE_STRIP: 0x0003,\n\t\tTRIANGLES: 0x0004,\n\t\tTRIANGLE_STRIP: 0x0005,\n\t\tTRIANGLE_FAN: 0x0006,\n\n\t\tUNSIGNED_BYTE: 0x1401,\n\t\tUNSIGNED_SHORT: 0x1403,\n\t\tFLOAT: 0x1406,\n\t\tUNSIGNED_INT: 0x1405,\n\t\tARRAY_BUFFER: 0x8892,\n\t\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\t\tNEAREST: 0x2600,\n\t\tLINEAR: 0x2601,\n\t\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\t\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\t\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\t\tLINEAR_MIPMAP_LINEAR: 0x2703,\n\n\t\tCLAMP_TO_EDGE: 33071,\n\t\tMIRRORED_REPEAT: 33648,\n\t\tREPEAT: 10497\n\t};\n\n\tvar THREE_TO_WEBGL = {};\n\n\tTHREE_TO_WEBGL[ THREE.NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\n\tTHREE_TO_WEBGL[ THREE.NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\n\tTHREE_TO_WEBGL[ THREE.NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\n\tTHREE_TO_WEBGL[ THREE.LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\n\tTHREE_TO_WEBGL[ THREE.LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\n\tTHREE_TO_WEBGL[ THREE.LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\n\tTHREE_TO_WEBGL[ THREE.ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\n\tTHREE_TO_WEBGL[ THREE.RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\n\tTHREE_TO_WEBGL[ THREE.MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\n\tvar PATH_PROPERTIES = {\n\t\tscale: 'scale',\n\t\tposition: 'translation',\n\t\tquaternion: 'rotation',\n\t\tmorphTargetInfluences: 'weights'\n\t};\n\n\t//------------------------------------------------------------------------------\n\t// GLTF Exporter\n\t//------------------------------------------------------------------------------\n\tTHREE.GLTFExporter = function () {};\n\n\tTHREE.GLTFExporter.prototype = {\n\n\t\tconstructor: THREE.GLTFExporter,\n\n\t\t/**\n\t\t * Parse scenes and generate GLTF output\n\t\t * @param  {THREE.Scene or [THREE.Scenes]} input   THREE.Scene or Array of THREE.Scenes\n\t\t * @param  {Function} onDone  Callback on completed\n\t\t * @param  {Object} options options\n\t\t */\n\t\tparse: function ( input, onDone, options ) {\n\n\t\t\tvar DEFAULT_OPTIONS = {\n\t\t\t\tbinary: false,\n\t\t\t\ttrs: false,\n\t\t\t\tonlyVisible: true,\n\t\t\t\ttruncateDrawRange: true,\n\t\t\t\tembedImages: true,\n\t\t\t\tmaxTextureSize: Infinity,\n\t\t\t\tanimations: [],\n\t\t\t\tforceIndices: false,\n\t\t\t\tforcePowerOfTwoTextures: false,\n\t\t\t\tincludeCustomExtensions: false\n\t\t\t};\n\n\t\t\toptions = Object.assign( {}, DEFAULT_OPTIONS, options );\n\n\t\t\tif ( options.animations.length > 0 ) {\n\n\t\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\t\toptions.trs = true;\n\n\t\t\t}\n\n\t\t\tvar outputJSON = {\n\n\t\t\t\tasset: {\n\n\t\t\t\t\tversion: \"2.0\",\n\t\t\t\t\tgenerator: \"THREE.GLTFExporter\"\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tvar byteOffset = 0;\n\t\t\tvar buffers = [];\n\t\t\tvar pending = [];\n\t\t\tvar nodeMap = new Map();\n\t\t\tvar skins = [];\n\t\t\tvar extensionsUsed = {};\n\t\t\tvar cachedData = {\n\n\t\t\t\tmeshes: new Map(),\n\t\t\t\tattributes: new Map(),\n\t\t\t\tattributesNormalized: new Map(),\n\t\t\t\tmaterials: new Map(),\n\t\t\t\ttextures: new Map(),\n\t\t\t\timages: new Map()\n\n\t\t\t};\n\n\t\t\tvar cachedCanvas;\n\n\t\t\tvar uids = new Map();\n\t\t\tvar uid = 0;\n\n\t\t\t/**\n\t\t\t * Assign and return a temporal unique id for an object\n\t\t\t * especially which doesn't have .uuid\n\t\t\t * @param  {Object} object\n\t\t\t * @return {Integer}\n\t\t\t */\n\t\t\tfunction getUID( object ) {\n\n\t\t\t\tif ( ! uids.has( object ) ) uids.set( object, uid ++ );\n\n\t\t\t\treturn uids.get( object );\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Compare two arrays\n\t\t\t * @param  {Array} array1 Array 1 to compare\n\t\t\t * @param  {Array} array2 Array 2 to compare\n\t\t\t * @return {Boolean}        Returns true if both arrays are equal\n\t\t\t */\n\t\t\tfunction equalArray( array1, array2 ) {\n\n\t\t\t\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\t\t\t\treturn element === array2[ index ];\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Converts a string to an ArrayBuffer.\n\t\t\t * @param  {string} text\n\t\t\t * @return {ArrayBuffer}\n\t\t\t */\n\t\t\tfunction stringToArrayBuffer( text ) {\n\n\t\t\t\tif ( window.TextEncoder !== undefined ) {\n\n\t\t\t\t\treturn new TextEncoder().encode( text ).buffer;\n\n\t\t\t\t}\n\n\t\t\t\tvar array = new Uint8Array( new ArrayBuffer( text.length ) );\n\n\t\t\t\tfor ( var i = 0, il = text.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar value = text.charCodeAt( i );\n\n\t\t\t\t\t// Replacing multi-byte character with space(0x20).\n\t\t\t\t\tarray[ i ] = value > 0xFF ? 0x20 : value;\n\n\t\t\t\t}\n\n\t\t\t\treturn array.buffer;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Get the min and max vectors from the given attribute\n\t\t\t * @param  {THREE.BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n\t\t\t * @param  {Integer} start\n\t\t\t * @param  {Integer} count\n\t\t\t * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n\t\t\t */\n\t\t\tfunction getMinMax( attribute, start, count ) {\n\n\t\t\t\tvar output = {\n\n\t\t\t\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\t\t\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = start; i < start + count; i ++ ) {\n\n\t\t\t\t\tfor ( var a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\t\tvar value = attribute.array[ i * attribute.itemSize + a ];\n\t\t\t\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\t\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn output;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Checks if image size is POT.\n\t\t\t *\n\t\t\t * @param {Image} image The image to be checked.\n\t\t\t * @returns {Boolean} Returns true if image size is POT.\n\t\t\t *\n\t\t\t */\n\t\t\tfunction isPowerOfTwo( image ) {\n\n\t\t\t\treturn THREE.MathUtils.isPowerOfTwo( image.width ) && THREE.MathUtils.isPowerOfTwo( image.height );\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Checks if normal attribute values are normalized.\n\t\t\t *\n\t\t\t * @param {THREE.BufferAttribute} normal\n\t\t\t * @returns {Boolean}\n\t\t\t *\n\t\t\t */\n\t\t\tfunction isNormalizedNormalAttribute( normal ) {\n\n\t\t\t\tif ( cachedData.attributesNormalized.has( normal ) ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tvar v = new THREE.Vector3();\n\n\t\t\t\tfor ( var i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t\t\t// 0.0005 is from glTF-validator\n\t\t\t\t\tif ( Math.abs( v.fromArray( normal.array, i * 3 ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Creates normalized normal buffer attribute.\n\t\t\t *\n\t\t\t * @param {THREE.BufferAttribute} normal\n\t\t\t * @returns {THREE.BufferAttribute}\n\t\t\t *\n\t\t\t */\n\t\t\tfunction createNormalizedNormalAttribute( normal ) {\n\n\t\t\t\tif ( cachedData.attributesNormalized.has( normal ) ) {\n\n\t\t\t\t\treturn cachedData.attributesNormalized.get( normal );\n\n\t\t\t\t}\n\n\t\t\t\tvar attribute = normal.clone();\n\n\t\t\t\tvar v = new THREE.Vector3();\n\n\t\t\t\tfor ( var i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tv.fromArray( attribute.array, i * 3 );\n\n\t\t\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\t\t\tv.setX( 1.0 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv.normalize();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tv.toArray( attribute.array, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tcachedData.attributesNormalized.set( normal, attribute );\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n\t\t\t * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n\t\t\t *\n\t\t\t * @param {Integer} bufferSize The size the original buffer.\n\t\t\t * @returns {Integer} new buffer size with required padding.\n\t\t\t *\n\t\t\t */\n\t\t\tfunction getPaddedBufferSize( bufferSize ) {\n\n\t\t\t\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Returns a buffer aligned to 4-byte boundary.\n\t\t\t *\n\t\t\t * @param {ArrayBuffer} arrayBuffer Buffer to pad\n\t\t\t * @param {Integer} paddingByte (Optional)\n\t\t\t * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n\t\t\t */\n\t\t\tfunction getPaddedArrayBuffer( arrayBuffer, paddingByte ) {\n\n\t\t\t\tpaddingByte = paddingByte || 0;\n\n\t\t\t\tvar paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\t\t\t\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\t\t\t\tvar array = new Uint8Array( paddedLength );\n\t\t\t\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\t\t\t\tif ( paddingByte !== 0 ) {\n\n\t\t\t\t\t\tfor ( var i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn array.buffer;\n\n\t\t\t\t}\n\n\t\t\t\treturn arrayBuffer;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Serializes a userData.\n\t\t\t *\n\t\t\t * @param {THREE.Object3D|THREE.Material} object\n\t\t\t * @param {Object} gltfProperty\n\t\t\t */\n\t\t\tfunction serializeUserData( object, gltfProperty ) {\n\n\t\t\t\tif ( Object.keys( object.userData ).length === 0 ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar json = JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\n\n\t\t\t\t\t\tif ( gltfProperty.extensions === undefined ) {\n\n\t\t\t\t\t\t\tgltfProperty.extensions = {};\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( var extensionName in json.gltfExtensions ) {\n\n\t\t\t\t\t\t\tgltfProperty.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\n\t\t\t\t\t\t\textensionsUsed[ extensionName ] = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete json.gltfExtensions;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Object.keys( json ).length > 0 ) {\n\n\t\t\t\t\t\tgltfProperty.extras = json;\n\n\t\t\t\t\t}\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Applies a texture transform, if present, to the map definition. Requires\n\t\t\t * the KHR_texture_transform extension.\n\t\t\t */\n\t\t\tfunction applyTextureTransform( mapDef, texture ) {\n\n\t\t\t\tvar didTransform = false;\n\t\t\t\tvar transformDef = {};\n\n\t\t\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\n\n\t\t\t\t\ttransformDef.offset = texture.offset.toArray();\n\t\t\t\t\tdidTransform = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.rotation !== 0 ) {\n\n\t\t\t\t\ttransformDef.rotation = texture.rotation;\n\t\t\t\t\tdidTransform = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\n\n\t\t\t\t\ttransformDef.scale = texture.repeat.toArray();\n\t\t\t\t\tdidTransform = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( didTransform ) {\n\n\t\t\t\t\tmapDef.extensions = mapDef.extensions || {};\n\t\t\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\n\t\t\t\t\textensionsUsed[ 'KHR_texture_transform' ] = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process a buffer to append to the default one.\n\t\t\t * @param  {ArrayBuffer} buffer\n\t\t\t * @return {Integer}\n\t\t\t */\n\t\t\tfunction processBuffer( buffer ) {\n\n\t\t\t\tif ( ! outputJSON.buffers ) {\n\n\t\t\t\t\toutputJSON.buffers = [ { byteLength: 0 } ];\n\n\t\t\t\t}\n\n\t\t\t\t// All buffers are merged before export.\n\t\t\t\tbuffers.push( buffer );\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process and generate a BufferView\n\t\t\t * @param  {THREE.BufferAttribute} attribute\n\t\t\t * @param  {number} componentType\n\t\t\t * @param  {number} start\n\t\t\t * @param  {number} count\n\t\t\t * @param  {number} target (Optional) Target usage of the BufferView\n\t\t\t * @return {Object}\n\t\t\t */\n\t\t\tfunction processBufferView( attribute, componentType, start, count, target ) {\n\n\t\t\t\tif ( ! outputJSON.bufferViews ) {\n\n\t\t\t\t\toutputJSON.bufferViews = [];\n\n\t\t\t\t}\n\n\t\t\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\t\t\tvar componentSize;\n\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\tcomponentSize = 1;\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\tcomponentSize = 2;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcomponentSize = 4;\n\n\t\t\t\t}\n\n\t\t\t\tvar byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );\n\t\t\t\tvar dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\t\t\tvar offset = 0;\n\n\t\t\t\tfor ( var i = start; i < start + count; i ++ ) {\n\n\t\t\t\t\tfor ( var a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\t\t// @TODO Fails on InterleavedBufferAttribute, and could probably be\n\t\t\t\t\t\t// optimized for normal BufferAttribute.\n\t\t\t\t\t\tvar value = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toffset += componentSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfBufferView = {\n\n\t\t\t\t\tbuffer: processBuffer( dataView.buffer ),\n\t\t\t\t\tbyteOffset: byteOffset,\n\t\t\t\t\tbyteLength: byteLength\n\n\t\t\t\t};\n\n\t\t\t\tif ( target !== undefined ) gltfBufferView.target = target;\n\n\t\t\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t\t\t// Only define byteStride for vertex attributes.\n\t\t\t\t\tgltfBufferView.byteStride = attribute.itemSize * componentSize;\n\n\t\t\t\t}\n\n\t\t\t\tbyteOffset += byteLength;\n\n\t\t\t\toutputJSON.bufferViews.push( gltfBufferView );\n\n\t\t\t\t// @TODO Merge bufferViews where possible.\n\t\t\t\tvar output = {\n\n\t\t\t\t\tid: outputJSON.bufferViews.length - 1,\n\t\t\t\t\tbyteLength: 0\n\n\t\t\t\t};\n\n\t\t\t\treturn output;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process and generate a BufferView from an image Blob.\n\t\t\t * @param {Blob} blob\n\t\t\t * @return {Promise<Integer>}\n\t\t\t */\n\t\t\tfunction processBufferViewImage( blob ) {\n\n\t\t\t\tif ( ! outputJSON.bufferViews ) {\n\n\t\t\t\t\toutputJSON.bufferViews = [];\n\n\t\t\t\t}\n\n\t\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\t\tvar reader = new window.FileReader();\n\t\t\t\t\treader.readAsArrayBuffer( blob );\n\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\tvar buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\t\t\tvar bufferView = {\n\t\t\t\t\t\t\tbuffer: processBuffer( buffer ),\n\t\t\t\t\t\t\tbyteOffset: byteOffset,\n\t\t\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t\t\t\t\toutputJSON.bufferViews.push( bufferView );\n\n\t\t\t\t\t\tresolve( outputJSON.bufferViews.length - 1 );\n\n\t\t\t\t\t};\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process attribute to generate an accessor\n\t\t\t * @param  {THREE.BufferAttribute} attribute Attribute to process\n\t\t\t * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n\t\t\t * @param  {Integer} start (Optional)\n\t\t\t * @param  {Integer} count (Optional)\n\t\t\t * @return {Integer}           Index of the processed accessor on the \"accessors\" array\n\t\t\t */\n\t\t\tfunction processAccessor( attribute, geometry, start, count ) {\n\n\t\t\t\tvar types = {\n\n\t\t\t\t\t1: 'SCALAR',\n\t\t\t\t\t2: 'VEC2',\n\t\t\t\t\t3: 'VEC3',\n\t\t\t\t\t4: 'VEC4',\n\t\t\t\t\t16: 'MAT4'\n\n\t\t\t\t};\n\n\t\t\t\tvar componentType;\n\n\t\t\t\t// Detect the component type of the attribute array (float, uint or ushort)\n\t\t\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( start === undefined ) start = 0;\n\t\t\t\tif ( count === undefined ) count = attribute.count;\n\n\t\t\t\t// @TODO Indexed buffer geometry with drawRange not supported yet\n\t\t\t\tif ( options.truncateDrawRange && geometry !== undefined && geometry.index === null ) {\n\n\t\t\t\t\tvar end = start + count;\n\t\t\t\t\tvar end2 = geometry.drawRange.count === Infinity\n\t\t\t\t\t\t? attribute.count\n\t\t\t\t\t\t: geometry.drawRange.start + geometry.drawRange.count;\n\n\t\t\t\t\tstart = Math.max( start, geometry.drawRange.start );\n\t\t\t\t\tcount = Math.min( end, end2 ) - start;\n\n\t\t\t\t\tif ( count < 0 ) count = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\t\t\tif ( count === 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tvar minMax = getMinMax( attribute, start, count );\n\n\t\t\t\tvar bufferViewTarget;\n\n\t\t\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t\t\t// animation samplers, target must not be set.\n\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t\t\t}\n\n\t\t\t\tvar bufferView = processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\t\t\tvar gltfAccessor = {\n\n\t\t\t\t\tbufferView: bufferView.id,\n\t\t\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\t\t\tcomponentType: componentType,\n\t\t\t\t\tcount: count,\n\t\t\t\t\tmax: minMax.max,\n\t\t\t\t\tmin: minMax.min,\n\t\t\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t\t\t};\n\n\t\t\t\tif ( ! outputJSON.accessors ) {\n\n\t\t\t\t\toutputJSON.accessors = [];\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.accessors.push( gltfAccessor );\n\n\t\t\t\treturn outputJSON.accessors.length - 1;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process image\n\t\t\t * @param  {Image} image to process\n\t\t\t * @param  {Integer} format of the image (e.g. THREE.RGBFormat, THREE.RGBAFormat etc)\n\t\t\t * @param  {Boolean} flipY before writing out the image\n\t\t\t * @return {Integer}     Index of the processed texture in the \"images\" array\n\t\t\t */\n\t\t\tfunction processImage( image, format, flipY ) {\n\n\t\t\t\tif ( ! cachedData.images.has( image ) ) {\n\n\t\t\t\t\tcachedData.images.set( image, {} );\n\n\t\t\t\t}\n\n\t\t\t\tvar cachedImages = cachedData.images.get( image );\n\t\t\t\tvar mimeType = format === THREE.RGBAFormat ? 'image/png' : 'image/jpeg';\n\t\t\t\tvar key = mimeType + \":flipY/\" + flipY.toString();\n\n\t\t\t\tif ( cachedImages[ key ] !== undefined ) {\n\n\t\t\t\t\treturn cachedImages[ key ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! outputJSON.images ) {\n\n\t\t\t\t\toutputJSON.images = [];\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfImage = { mimeType: mimeType };\n\n\t\t\t\tif ( options.embedImages ) {\n\n\t\t\t\t\tvar canvas = cachedCanvas = cachedCanvas || document.createElement( 'canvas' );\n\n\t\t\t\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\n\t\t\t\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\n\n\t\t\t\t\tif ( options.forcePowerOfTwoTextures && ! isPowerOfTwo( canvas ) ) {\n\n\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Resized non-power-of-two image.', image );\n\n\t\t\t\t\t\tcanvas.width = THREE.MathUtils.floorPowerOfTwo( canvas.width );\n\t\t\t\t\t\tcanvas.height = THREE.MathUtils.floorPowerOfTwo( canvas.height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar ctx = canvas.getContext( '2d' );\n\n\t\t\t\t\tif ( flipY === true ) {\n\n\t\t\t\t\t\tctx.translate( 0, canvas.height );\n\t\t\t\t\t\tctx.scale( 1, - 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\t\tif ( options.binary === true ) {\n\n\t\t\t\t\t\tpending.push( new Promise( function ( resolve ) {\n\n\t\t\t\t\t\t\tcanvas.toBlob( function ( blob ) {\n\n\t\t\t\t\t\t\t\tprocessBufferViewImage( blob ).then( function ( bufferViewIndex ) {\n\n\t\t\t\t\t\t\t\t\tgltfImage.bufferView = bufferViewIndex;\n\n\t\t\t\t\t\t\t\t\tresolve();\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}, mimeType );\n\n\t\t\t\t\t\t} ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgltfImage.uri = canvas.toDataURL( mimeType );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgltfImage.uri = image.src;\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.images.push( gltfImage );\n\n\t\t\t\tvar index = outputJSON.images.length - 1;\n\t\t\t\tcachedImages[ key ] = index;\n\n\t\t\t\treturn index;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process sampler\n\t\t\t * @param  {Texture} map Texture to process\n\t\t\t * @return {Integer}     Index of the processed texture in the \"samplers\" array\n\t\t\t */\n\t\t\tfunction processSampler( map ) {\n\n\t\t\t\tif ( ! outputJSON.samplers ) {\n\n\t\t\t\t\toutputJSON.samplers = [];\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfSampler = {\n\n\t\t\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\n\t\t\t\t};\n\n\t\t\t\toutputJSON.samplers.push( gltfSampler );\n\n\t\t\t\treturn outputJSON.samplers.length - 1;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process texture\n\t\t\t * @param  {Texture} map Map to process\n\t\t\t * @return {Integer}     Index of the processed texture in the \"textures\" array\n\t\t\t */\n\t\t\tfunction processTexture( map ) {\n\n\t\t\t\tif ( cachedData.textures.has( map ) ) {\n\n\t\t\t\t\treturn cachedData.textures.get( map );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! outputJSON.textures ) {\n\n\t\t\t\t\toutputJSON.textures = [];\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfTexture = {\n\n\t\t\t\t\tsampler: processSampler( map ),\n\t\t\t\t\tsource: processImage( map.image, map.format, map.flipY )\n\n\t\t\t\t};\n\n\t\t\t\tif ( map.name ) {\n\n\t\t\t\t\tgltfTexture.name = map.name;\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.textures.push( gltfTexture );\n\n\t\t\t\tvar index = outputJSON.textures.length - 1;\n\t\t\t\tcachedData.textures.set( map, index );\n\n\t\t\t\treturn index;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process material\n\t\t\t * @param  {THREE.Material} material Material to process\n\t\t\t * @return {Integer}      Index of the processed material in the \"materials\" array\n\t\t\t */\n\t\t\tfunction processMaterial( material ) {\n\n\t\t\t\tif ( cachedData.materials.has( material ) ) {\n\n\t\t\t\t\treturn cachedData.materials.get( material );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isShaderMaterial ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! outputJSON.materials ) {\n\n\t\t\t\t\toutputJSON.materials = [];\n\n\t\t\t\t}\n\n\t\t\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\t\t\tvar gltfMaterial = {\n\n\t\t\t\t\tpbrMetallicRoughness: {}\n\n\t\t\t\t};\n\n\t\t\t\tif ( material.isMeshBasicMaterial ) {\n\n\t\t\t\t\tgltfMaterial.extensions = { KHR_materials_unlit: {} };\n\n\t\t\t\t\textensionsUsed[ 'KHR_materials_unlit' ] = true;\n\n\t\t\t\t} else if ( material.isGLTFSpecularGlossinessMaterial ) {\n\n\t\t\t\t\tgltfMaterial.extensions = { KHR_materials_pbrSpecularGlossiness: {} };\n\n\t\t\t\t\textensionsUsed[ 'KHR_materials_pbrSpecularGlossiness' ] = true;\n\n\t\t\t\t} else if ( ! material.isMeshStandardMaterial ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t\t\t}\n\n\t\t\t\t// pbrMetallicRoughness.baseColorFactor\n\t\t\t\tvar color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\t\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t\t\t} else if ( material.isMeshBasicMaterial ) {\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = 0.5;\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.5;\n\n\t\t\t\t}\n\n\t\t\t\t// pbrSpecularGlossiness diffuse, specular and glossiness factor\n\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) {\n\n\t\t\t\t\tif ( gltfMaterial.pbrMetallicRoughness.baseColorFactor ) {\n\n\t\t\t\t\t\tgltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor = gltfMaterial.pbrMetallicRoughness.baseColorFactor;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar specularFactor = [ 1, 1, 1 ];\n\t\t\t\t\tmaterial.specular.toArray( specularFactor, 0 );\n\t\t\t\t\tgltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor = specularFactor;\n\n\t\t\t\t\tgltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor = material.glossiness;\n\n\t\t\t\t}\n\n\t\t\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\t\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\t\t\tif ( material.metalnessMap === material.roughnessMap ) {\n\n\t\t\t\t\t\tvar metalRoughMapDef = { index: processTexture( material.metalnessMap ) };\n\t\t\t\t\t\tapplyTextureTransform( metalRoughMapDef, material.metalnessMap );\n\t\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\tvar baseColorMapDef = { index: processTexture( material.map ) };\n\t\t\t\t\tapplyTextureTransform( baseColorMapDef, material.map );\n\n\t\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) {\n\n\t\t\t\t\t\tgltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.diffuseTexture = baseColorMapDef;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n\n\t\t\t\t}\n\n\t\t\t\t// pbrSpecularGlossiness specular map\n\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial && material.specularMap ) {\n\n\t\t\t\t\tvar specularMapDef = { index: processTexture( material.specularMap ) };\n\t\t\t\t\tapplyTextureTransform( specularMapDef, material.specularMap );\n\t\t\t\t\tgltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.specularGlossinessTexture = specularMapDef;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.emissive ) {\n\n\t\t\t\t\t// emissiveFactor\n\t\t\t\t\tvar emissive = material.emissive.clone().multiplyScalar( material.emissiveIntensity ).toArray();\n\n\t\t\t\t\tif ( ! equalArray( emissive, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\t\t\tgltfMaterial.emissiveFactor = emissive;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// emissiveTexture\n\t\t\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\t\t\tvar emissiveMapDef = { index: processTexture( material.emissiveMap ) };\n\t\t\t\t\t\tapplyTextureTransform( emissiveMapDef, material.emissiveMap );\n\t\t\t\t\t\tgltfMaterial.emissiveTexture = emissiveMapDef;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// normalTexture\n\t\t\t\tif ( material.normalMap ) {\n\n\t\t\t\t\tvar normalMapDef = { index: processTexture( material.normalMap ) };\n\n\t\t\t\t\tif ( material.normalScale && material.normalScale.x !== - 1 ) {\n\n\t\t\t\t\t\tif ( material.normalScale.x !== material.normalScale.y ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormalMapDef.scale = material.normalScale.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tapplyTextureTransform( normalMapDef, material.normalMap );\n\n\t\t\t\t\tgltfMaterial.normalTexture = normalMapDef;\n\n\t\t\t\t}\n\n\t\t\t\t// occlusionTexture\n\t\t\t\tif ( material.aoMap ) {\n\n\t\t\t\t\tvar occlusionMapDef = {\n\t\t\t\t\t\tindex: processTexture( material.aoMap ),\n\t\t\t\t\t\ttexCoord: 1\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tapplyTextureTransform( occlusionMapDef, material.aoMap );\n\n\t\t\t\t\tgltfMaterial.occlusionTexture = occlusionMapDef;\n\n\t\t\t\t}\n\n\t\t\t\t// alphaMode\n\t\t\t\tif ( material.transparent ) {\n\n\t\t\t\t\tgltfMaterial.alphaMode = 'BLEND';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( material.alphaTest > 0.0 ) {\n\n\t\t\t\t\t\tgltfMaterial.alphaMode = 'MASK';\n\t\t\t\t\t\tgltfMaterial.alphaCutoff = material.alphaTest;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// doubleSided\n\t\t\t\tif ( material.side === THREE.DoubleSide ) {\n\n\t\t\t\t\tgltfMaterial.doubleSided = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.name !== '' ) {\n\n\t\t\t\t\tgltfMaterial.name = material.name;\n\n\t\t\t\t}\n\n\t\t\t\tserializeUserData( material, gltfMaterial );\n\n\t\t\t\toutputJSON.materials.push( gltfMaterial );\n\n\t\t\t\tvar index = outputJSON.materials.length - 1;\n\t\t\t\tcachedData.materials.set( material, index );\n\n\t\t\t\treturn index;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process mesh\n\t\t\t * @param  {THREE.Mesh} mesh Mesh to process\n\t\t\t * @return {Integer}      Index of the processed mesh in the \"meshes\" array\n\t\t\t */\n\t\t\tfunction processMesh( mesh ) {\n\n\t\t\t\tvar meshCacheKeyParts = [ mesh.geometry.uuid ];\n\t\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\t\tfor ( var i = 0, l = mesh.material.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tvar meshCacheKey = meshCacheKeyParts.join( ':' );\n\t\t\t\tif ( cachedData.meshes.has( meshCacheKey ) ) {\n\n\t\t\t\t\treturn cachedData.meshes.get( meshCacheKey );\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = mesh.geometry;\n\n\t\t\t\tvar mode;\n\n\t\t\t\t// Use the correct mode\n\t\t\t\tif ( mesh.isLineSegments ) {\n\n\t\t\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t\t\t} else if ( mesh.isLine ) {\n\n\t\t\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t\t\t} else if ( mesh.isPoints ) {\n\n\t\t\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Exporting THREE.Geometry will increase file size. Use THREE.BufferGeometry instead.' );\n\t\t\t\t\tgeometry = new THREE.BufferGeometry().setFromObject( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfMesh = {};\n\n\t\t\t\tvar attributes = {};\n\t\t\t\tvar primitives = [];\n\t\t\t\tvar targets = [];\n\n\t\t\t\t// Conversion between attributes names in threejs and gltf spec\n\t\t\t\tvar nameConversion = {\n\n\t\t\t\t\tuv: 'TEXCOORD_0',\n\t\t\t\t\tuv2: 'TEXCOORD_1',\n\t\t\t\t\tcolor: 'COLOR_0',\n\t\t\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\t\t\tskinIndex: 'JOINTS_0'\n\n\t\t\t\t};\n\n\t\t\t\tvar originalNormal = geometry.getAttribute( 'normal' );\n\n\t\t\t\tif ( originalNormal !== undefined && ! isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t\t\t}\n\n\t\t\t\t// @QUESTION Detect if .vertexColors = true?\n\t\t\t\t// For every attribute create an accessor\n\t\t\t\tvar modifiedAttribute = null;\n\t\t\t\tfor ( var attributeName in geometry.attributes ) {\n\n\t\t\t\t\t// Ignore morph target attributes, which are exported later.\n\t\t\t\t\tif ( attributeName.substr( 0, 5 ) === 'morph' ) continue;\n\n\t\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t\t\t// Prefix all geometry attributes except the ones specifically\n\t\t\t\t\t// listed in the spec; non-spec attributes are considered custom.\n\t\t\t\t\tvar validVertexAttributes =\n\t\t\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\t\t\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) {\n\n\t\t\t\t\t\tattributeName = '_' + attributeName;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cachedData.attributes.has( getUID( attribute ) ) ) {\n\n\t\t\t\t\t\tattributes[ attributeName ] = cachedData.attributes.get( getUID( attribute ) );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\t\t\t\t\tmodifiedAttribute = null;\n\t\t\t\t\tvar array = attribute.array;\n\t\t\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\t\t\tmodifiedAttribute = new THREE.BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar accessor = processAccessor( modifiedAttribute || attribute, geometry );\n\t\t\t\t\tif ( accessor !== null ) {\n\n\t\t\t\t\t\tattributes[ attributeName ] = accessor;\n\t\t\t\t\t\tcachedData.attributes.set( getUID( attribute ), accessor );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\n\n\t\t\t\t// Skip if no exportable attributes found\n\t\t\t\tif ( Object.keys( attributes ).length === 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// Morph targets\n\t\t\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\t\t\tvar weights = [];\n\t\t\t\t\tvar targetNames = [];\n\t\t\t\t\tvar reverseDictionary = {};\n\n\t\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\t\t\tfor ( var key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\t\t\tvar target = {};\n\n\t\t\t\t\t\tvar warned = false;\n\n\t\t\t\t\t\tfor ( var attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar attribute = geometry.morphAttributes[ attributeName ][ i ];\n\t\t\t\t\t\t\tvar gltfAttributeName = attributeName.toUpperCase();\n\n\t\t\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\t\t\tvar baseAttribute = geometry.attributes[ attributeName ];\n\n\t\t\t\t\t\t\tif ( cachedData.attributes.has( getUID( attribute ) ) ) {\n\n\t\t\t\t\t\t\t\ttarget[ gltfAttributeName ] = cachedData.attributes.get( getUID( attribute ) );\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\t\t\tvar relativeAttribute = attribute.clone();\n\n\t\t\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t\tfor ( var j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\t\trelativeAttribute.setXYZ(\n\t\t\t\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\t\t\t\tattribute.getX( j ) - baseAttribute.getX( j ),\n\t\t\t\t\t\t\t\t\t\tattribute.getY( j ) - baseAttribute.getY( j ),\n\t\t\t\t\t\t\t\t\t\tattribute.getZ( j ) - baseAttribute.getZ( j )\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttarget[ gltfAttributeName ] = processAccessor( relativeAttribute, geometry );\n\t\t\t\t\t\t\tcachedData.attributes.set( getUID( baseAttribute ), target[ gltfAttributeName ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargets.push( target );\n\n\t\t\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\t\t\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgltfMesh.weights = weights;\n\n\t\t\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\t\t\tgltfMesh.extras = {};\n\t\t\t\t\t\tgltfMesh.extras.targetNames = targetNames;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar forceIndices = options.forceIndices;\n\t\t\t\tvar isMultiMaterial = Array.isArray( mesh.material );\n\n\t\t\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\t\t\tif ( ! forceIndices && geometry.index === null && isMultiMaterial ) {\n\n\t\t\t\t\t// temporal workaround.\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating index for non-indexed multi-material mesh.' );\n\t\t\t\t\tforceIndices = true;\n\n\t\t\t\t}\n\n\t\t\t\tvar didForceIndices = false;\n\n\t\t\t\tif ( geometry.index === null && forceIndices ) {\n\n\t\t\t\t\tvar indices = [];\n\n\t\t\t\t\tfor ( var i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {\n\n\t\t\t\t\t\tindices[ i ] = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setIndex( indices );\n\n\t\t\t\t\tdidForceIndices = true;\n\n\t\t\t\t}\n\n\t\t\t\tvar materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\t\t\tvar groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\t\t\tfor ( var i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar primitive = {\n\t\t\t\t\t\tmode: mode,\n\t\t\t\t\t\tattributes: attributes,\n\t\t\t\t\t};\n\n\t\t\t\t\tserializeUserData( geometry, primitive );\n\n\t\t\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t\t\tvar cacheKey = getUID( geometry.index );\n\n\t\t\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\n\n\t\t\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( cachedData.attributes.has( cacheKey ) ) {\n\n\t\t\t\t\t\t\tprimitive.indices = cachedData.attributes.get( cacheKey );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tprimitive.indices = processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\t\t\t\t\t\t\tcachedData.attributes.set( cacheKey, primitive.indices );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar material = processMaterial( materials[ groups[ i ].materialIndex ] );\n\n\t\t\t\t\tif ( material !== null ) {\n\n\t\t\t\t\t\tprimitive.material = material;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tprimitives.push( primitive );\n\n\t\t\t\t}\n\n\t\t\t\tif ( didForceIndices ) {\n\n\t\t\t\t\tgeometry.setIndex( null );\n\n\t\t\t\t}\n\n\t\t\t\tgltfMesh.primitives = primitives;\n\n\t\t\t\tif ( ! outputJSON.meshes ) {\n\n\t\t\t\t\toutputJSON.meshes = [];\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.meshes.push( gltfMesh );\n\n\t\t\t\tvar index = outputJSON.meshes.length - 1;\n\t\t\t\tcachedData.meshes.set( meshCacheKey, index );\n\n\t\t\t\treturn index;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process camera\n\t\t\t * @param  {THREE.Camera} camera Camera to process\n\t\t\t * @return {Integer}      Index of the processed mesh in the \"camera\" array\n\t\t\t */\n\t\t\tfunction processCamera( camera ) {\n\n\t\t\t\tif ( ! outputJSON.cameras ) {\n\n\t\t\t\t\toutputJSON.cameras = [];\n\n\t\t\t\t}\n\n\t\t\t\tvar isOrtho = camera.isOrthographicCamera;\n\n\t\t\t\tvar gltfCamera = {\n\n\t\t\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\n\t\t\t\t};\n\n\t\t\t\tif ( isOrtho ) {\n\n\t\t\t\t\tgltfCamera.orthographic = {\n\n\t\t\t\t\t\txmag: camera.right * 2,\n\t\t\t\t\t\tymag: camera.top * 2,\n\t\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgltfCamera.perspective = {\n\n\t\t\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\t\t\tyfov: THREE.MathUtils.degToRad( camera.fov ),\n\t\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tif ( camera.name !== '' ) {\n\n\t\t\t\t\tgltfCamera.name = camera.type;\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.cameras.push( gltfCamera );\n\n\t\t\t\treturn outputJSON.cameras.length - 1;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Creates glTF animation entry from AnimationClip object.\n\t\t\t *\n\t\t\t * Status:\n\t\t\t * - Only properties listed in PATH_PROPERTIES may be animated.\n\t\t\t *\n\t\t\t * @param {THREE.AnimationClip} clip\n\t\t\t * @param {THREE.Object3D} root\n\t\t\t * @return {number}\n\t\t\t */\n\t\t\tfunction processAnimation( clip, root ) {\n\n\t\t\t\tif ( ! outputJSON.animations ) {\n\n\t\t\t\t\toutputJSON.animations = [];\n\n\t\t\t\t}\n\n\t\t\t\tclip = THREE.GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\n\n\t\t\t\tvar tracks = clip.tracks;\n\t\t\t\tvar channels = [];\n\t\t\t\tvar samplers = [];\n\n\t\t\t\tfor ( var i = 0; i < tracks.length; ++ i ) {\n\n\t\t\t\t\tvar track = tracks[ i ];\n\t\t\t\t\tvar trackBinding = THREE.PropertyBinding.parseTrackName( track.name );\n\t\t\t\t\tvar trackNode = THREE.PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\t\t\tvar trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar inputItemSize = 1;\n\t\t\t\t\tvar outputItemSize = track.values.length / track.times.length;\n\n\t\t\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar interpolation;\n\n\t\t\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t\t\t// valid value from .getInterpolation().\n\t\t\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\t\t\toutputItemSize /= 3;\n\n\t\t\t\t\t} else if ( track.getInterpolation() === THREE.InterpolateDiscrete ) {\n\n\t\t\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsamplers.push( {\n\n\t\t\t\t\t\tinput: processAccessor( new THREE.BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\t\t\toutput: processAccessor( new THREE.BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\t\t\tinterpolation: interpolation\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tchannels.push( {\n\n\t\t\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\t\t\ttarget: {\n\t\t\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\t\t\tpath: trackProperty\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.animations.push( {\n\n\t\t\t\t\tname: clip.name || 'clip_' + outputJSON.animations.length,\n\t\t\t\t\tsamplers: samplers,\n\t\t\t\t\tchannels: channels\n\n\t\t\t\t} );\n\n\t\t\t\treturn outputJSON.animations.length - 1;\n\n\t\t\t}\n\n\t\t\tfunction processSkin( object ) {\n\n\t\t\t\tvar node = outputJSON.nodes[ nodeMap.get( object ) ];\n\n\t\t\t\tvar skeleton = object.skeleton;\n\n\t\t\t\tif ( skeleton === undefined ) return null;\n\n\t\t\t\tvar rootJoint = object.skeleton.bones[ 0 ];\n\n\t\t\t\tif ( rootJoint === undefined ) return null;\n\n\t\t\t\tvar joints = [];\n\t\t\t\tvar inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\n\t\t\t\tfor ( var i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\n\t\t\t\t\tskeleton.boneInverses[ i ].toArray( inverseBindMatrices, i * 16 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( outputJSON.skins === undefined ) {\n\n\t\t\t\t\toutputJSON.skins = [];\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.skins.push( {\n\n\t\t\t\t\tinverseBindMatrices: processAccessor( new THREE.BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\t\t\tjoints: joints,\n\t\t\t\t\tskeleton: nodeMap.get( rootJoint )\n\n\t\t\t\t} );\n\n\t\t\t\tvar skinIndex = node.skin = outputJSON.skins.length - 1;\n\n\t\t\t\treturn skinIndex;\n\n\t\t\t}\n\n\t\t\tfunction processLight( light ) {\n\n\t\t\t\tvar lightDef = {};\n\n\t\t\t\tif ( light.name ) lightDef.name = light.name;\n\n\t\t\t\tlightDef.color = light.color.toArray();\n\n\t\t\t\tlightDef.intensity = light.intensity;\n\n\t\t\t\tif ( light.isDirectionalLight ) {\n\n\t\t\t\t\tlightDef.type = 'directional';\n\n\t\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\t\tlightDef.type = 'point';\n\t\t\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\t\tlightDef.type = 'spot';\n\t\t\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\t\t\t\t\tlightDef.spot = {};\n\t\t\t\t\tlightDef.spot.innerConeAngle = ( light.penumbra - 1.0 ) * light.angle * - 1.0;\n\t\t\t\t\tlightDef.spot.outerConeAngle = light.angle;\n\n\t\t\t\t}\n\n\t\t\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\n\t\t\t\t\t\t+ 'and expects light.decay=2.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( light.target\n\t\t\t\t\t\t&& ( light.target.parent !== light\n\t\t\t\t\t\t || light.target.position.x !== 0\n\t\t\t\t\t\t || light.target.position.y !== 0\n\t\t\t\t\t\t || light.target.position.z !== - 1 ) ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\n\t\t\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\n\n\t\t\t\t}\n\n\t\t\t\tvar lights = outputJSON.extensions[ 'KHR_lights_punctual' ].lights;\n\t\t\t\tlights.push( lightDef );\n\t\t\t\treturn lights.length - 1;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process Object3D node\n\t\t\t * @param  {THREE.Object3D} node Object3D to processNode\n\t\t\t * @return {Integer}      Index of the node in the nodes list\n\t\t\t */\n\t\t\tfunction processNode( object ) {\n\n\t\t\t\tif ( ! outputJSON.nodes ) {\n\n\t\t\t\t\toutputJSON.nodes = [];\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfNode = {};\n\n\t\t\t\tif ( options.trs ) {\n\n\t\t\t\t\tvar rotation = object.quaternion.toArray();\n\t\t\t\t\tvar position = object.position.toArray();\n\t\t\t\t\tvar scale = object.scale.toArray();\n\n\t\t\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\t\t\tgltfNode.rotation = rotation;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\t\t\tgltfNode.translation = position;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\t\t\tgltfNode.scale = scale;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\t\t\tobject.updateMatrix();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! equalArray( object.matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\t\t\tgltfNode.matrix = object.matrix.elements;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\t\t\tif ( object.name !== '' ) {\n\n\t\t\t\t\tgltfNode.name = String( object.name );\n\n\t\t\t\t}\n\n\t\t\t\tserializeUserData( object, gltfNode );\n\n\t\t\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\t\tvar mesh = processMesh( object );\n\n\t\t\t\t\tif ( mesh !== null ) {\n\n\t\t\t\t\t\tgltfNode.mesh = mesh;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isCamera ) {\n\n\t\t\t\t\tgltfNode.camera = processCamera( object );\n\n\t\t\t\t} else if ( object.isDirectionalLight || object.isPointLight || object.isSpotLight ) {\n\n\t\t\t\t\tif ( ! extensionsUsed[ 'KHR_lights_punctual' ] ) {\n\n\t\t\t\t\t\toutputJSON.extensions = outputJSON.extensions || {};\n\t\t\t\t\t\toutputJSON.extensions[ 'KHR_lights_punctual' ] = { lights: [] };\n\t\t\t\t\t\textensionsUsed[ 'KHR_lights_punctual' ] = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgltfNode.extensions = gltfNode.extensions || {};\n\t\t\t\t\tgltfNode.extensions[ 'KHR_lights_punctual' ] = { light: processLight( object ) };\n\n\t\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', object );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\tskins.push( object );\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.children.length > 0 ) {\n\n\t\t\t\t\tvar children = [];\n\n\t\t\t\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar child = object.children[ i ];\n\n\t\t\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\t\t\tvar node = processNode( child );\n\n\t\t\t\t\t\t\tif ( node !== null ) {\n\n\t\t\t\t\t\t\t\tchildren.push( node );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( children.length > 0 ) {\n\n\t\t\t\t\t\tgltfNode.children = children;\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.nodes.push( gltfNode );\n\n\t\t\t\tvar nodeIndex = outputJSON.nodes.length - 1;\n\t\t\t\tnodeMap.set( object, nodeIndex );\n\n\t\t\t\treturn nodeIndex;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process Scene\n\t\t\t * @param  {THREE.Scene} node Scene to process\n\t\t\t */\n\t\t\tfunction processScene( scene ) {\n\n\t\t\t\tif ( ! outputJSON.scenes ) {\n\n\t\t\t\t\toutputJSON.scenes = [];\n\t\t\t\t\toutputJSON.scene = 0;\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfScene = {};\n\n\t\t\t\tif ( scene.name !== '' ) {\n\n\t\t\t\t\tgltfScene.name = scene.name;\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.scenes.push( gltfScene );\n\n\t\t\t\tvar nodes = [];\n\n\t\t\t\tfor ( var i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = scene.children[ i ];\n\n\t\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\t\tvar node = processNode( child );\n\n\t\t\t\t\t\tif ( node !== null ) {\n\n\t\t\t\t\t\t\tnodes.push( node );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodes.length > 0 ) {\n\n\t\t\t\t\tgltfScene.nodes = nodes;\n\n\t\t\t\t}\n\n\t\t\t\tserializeUserData( scene, gltfScene );\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Creates a THREE.Scene to hold a list of objects and parse it\n\t\t\t * @param  {Array} objects List of objects to process\n\t\t\t */\n\t\t\tfunction processObjects( objects ) {\n\n\t\t\t\tvar scene = new THREE.Scene();\n\t\t\t\tscene.name = 'AuxScene';\n\n\t\t\t\tfor ( var i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\t\t\tscene.children.push( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tprocessScene( scene );\n\n\t\t\t}\n\n\t\t\tfunction processInput( input ) {\n\n\t\t\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\t\t\tvar objectsWithoutScene = [];\n\n\t\t\t\tfor ( var i = 0; i < input.length; i ++ ) {\n\n\t\t\t\t\tif ( input[ i ] instanceof THREE.Scene ) {\n\n\t\t\t\t\t\tprocessScene( input[ i ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( objectsWithoutScene.length > 0 ) {\n\n\t\t\t\t\tprocessObjects( objectsWithoutScene );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < skins.length; ++ i ) {\n\n\t\t\t\t\tprocessSkin( skins[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\t\t\tprocessAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprocessInput( input );\n\n\t\t\tPromise.all( pending ).then( function () {\n\n\t\t\t\t// Merge buffers.\n\t\t\t\tvar blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t\t\t// Declare extensions.\n\t\t\t\tvar extensionsUsedList = Object.keys( extensionsUsed );\n\t\t\t\tif ( extensionsUsedList.length > 0 ) outputJSON.extensionsUsed = extensionsUsedList;\n\n\t\t\t\t// Update bytelength of the single buffer.\n\t\t\t\tif ( outputJSON.buffers && outputJSON.buffers.length > 0 ) outputJSON.buffers[ 0 ].byteLength = blob.size;\n\n\t\t\t\tif ( options.binary === true ) {\n\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\t\t\tvar GLB_HEADER_BYTES = 12;\n\t\t\t\t\tvar GLB_HEADER_MAGIC = 0x46546C67;\n\t\t\t\t\tvar GLB_VERSION = 2;\n\n\t\t\t\t\tvar GLB_CHUNK_PREFIX_BYTES = 8;\n\t\t\t\t\tvar GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\n\t\t\t\t\tvar GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n\t\t\t\t\tvar reader = new window.FileReader();\n\t\t\t\t\treader.readAsArrayBuffer( blob );\n\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\t// Binary chunk.\n\t\t\t\t\t\tvar binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\t\t\tvar binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t\t\t// JSON chunk.\n\t\t\t\t\t\tvar jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( outputJSON ) ), 0x20 );\n\t\t\t\t\t\tvar jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t\t\t// GLB header.\n\t\t\t\t\t\tvar header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\t\t\tvar headerView = new DataView( header );\n\t\t\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\t\t\tvar totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\t\t\tvar glbBlob = new Blob( [\n\t\t\t\t\t\t\theader,\n\t\t\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\t\t\tjsonChunk,\n\t\t\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\t\t\tbinaryChunk\n\t\t\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\t\t\tvar glbReader = new window.FileReader();\n\t\t\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( outputJSON.buffers && outputJSON.buffers.length > 0 ) {\n\n\t\t\t\t\t\tvar reader = new window.FileReader();\n\t\t\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\t\tvar base64data = reader.result;\n\t\t\t\t\t\t\toutputJSON.buffers[ 0 ].uri = base64data;\n\t\t\t\t\t\t\tonDone( outputJSON );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tonDone( outputJSON );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t};\n\n\tTHREE.GLTFExporter.Utils = {\n\n\t\tinsertKeyframe: function ( track, time ) {\n\n\t\t\tvar tolerance = 0.001; // 1ms\n\t\t\tvar valueSize = track.getValueSize();\n\n\t\t\tvar times = new track.TimeBufferType( track.times.length + 1 );\n\t\t\tvar values = new track.ValueBufferType( track.values.length + valueSize );\n\t\t\tvar interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\n\n\t\t\tvar index;\n\n\t\t\tif ( track.times.length === 0 ) {\n\n\t\t\t\ttimes[ 0 ] = time;\n\n\t\t\t\tfor ( var i = 0; i < valueSize; i ++ ) {\n\n\t\t\t\t\tvalues[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tindex = 0;\n\n\t\t\t} else if ( time < track.times[ 0 ] ) {\n\n\t\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\n\n\t\t\t\ttimes[ 0 ] = time;\n\t\t\t\ttimes.set( track.times, 1 );\n\n\t\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\n\t\t\t\tvalues.set( track.values, valueSize );\n\n\t\t\t\tindex = 0;\n\n\t\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\n\n\t\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\n\n\t\t\t\t\treturn track.times.length - 1;\n\n\t\t\t\t}\n\n\t\t\t\ttimes[ times.length - 1 ] = time;\n\t\t\t\ttimes.set( track.times, 0 );\n\n\t\t\t\tvalues.set( track.values, 0 );\n\t\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\n\n\t\t\t\tindex = times.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < track.times.length; i ++ ) {\n\n\t\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\n\n\t\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\n\n\t\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\n\t\t\t\t\t\ttimes[ i + 1 ] = time;\n\t\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\n\n\t\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\n\t\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\n\t\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\n\n\t\t\t\t\t\tindex = i + 1;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttrack.times = times;\n\t\t\ttrack.values = values;\n\n\t\t\treturn index;\n\n\t\t},\n\n\t\tmergeMorphTargetTracks: function ( clip, root ) {\n\n\t\t\tvar tracks = [];\n\t\t\tvar mergedTracks = {};\n\t\t\tvar sourceTracks = clip.tracks;\n\n\t\t\tfor ( var i = 0; i < sourceTracks.length; ++ i ) {\n\n\t\t\t\tvar sourceTrack = sourceTracks[ i ];\n\t\t\t\tvar sourceTrackBinding = THREE.PropertyBinding.parseTrackName( sourceTrack.name );\n\t\t\t\tvar sourceTrackNode = THREE.PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\n\n\t\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\n\n\t\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n\t\t\t\t\ttracks.push( sourceTrack );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\n\t\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\n\n\t\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\t\t\t// This should never happen, because glTF morph target animations\n\t\t\t\t\t\t// affect all targets already.\n\t\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\n\n\t\t\t\t\tsourceTrack = sourceTrack.clone();\n\t\t\t\t\tsourceTrack.setInterpolation( THREE.InterpolateLinear );\n\n\t\t\t\t}\n\n\t\t\t\tvar targetCount = sourceTrackNode.morphTargetInfluences.length;\n\t\t\t\tvar targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\n\n\t\t\t\tif ( targetIndex === undefined ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\n\n\t\t\t\t}\n\n\t\t\t\tvar mergedTrack;\n\n\t\t\t\t// If this is the first time we've seen this object, create a new\n\t\t\t\t// track to store merged keyframe data for each morph target.\n\t\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\n\n\t\t\t\t\tmergedTrack = sourceTrack.clone();\n\n\t\t\t\t\tvar values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\n\n\t\t\t\t\tfor ( var j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmergedTrack.name = '.morphTargetInfluences';\n\t\t\t\t\tmergedTrack.values = values;\n\n\t\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\n\t\t\t\t\ttracks.push( mergedTrack );\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\n\n\t\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\n\n\t\t\t\t// For every existing keyframe of the merged track, write a (possibly\n\t\t\t\t// interpolated) value from the source track.\n\t\t\t\tfor ( var j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\n\n\t\t\t\t}\n\n\t\t\t\t// For every existing keyframe of the source track, write a (possibly\n\t\t\t\t// new) keyframe to the merged track. Values from the previous loop may\n\t\t\t\t// be written again, but keyframes are de-duplicated.\n\t\t\t\tfor ( var j = 0; j < sourceTrack.times.length; j ++ ) {\n\n\t\t\t\t\tvar keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\n\t\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tclip.tracks = tracks;\n\n\t\t\treturn clip;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.GLTFExporter;\n});\n\ndefine('skylark-threejs-ex/exporters/ColladaExporter',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Garrett Johnson / http://gkjohnson.github.io/\n\t * https://github.com/gkjohnson/collada-exporter-js\n\t *\n\t * Usage:\n\t *  var exporter = new THREE.ColladaExporter();\n\t *\n\t *  var data = exporter.parse(mesh);\n\t *\n\t * Format Definition:\n\t *  https://www.khronos.org/collada/\n\t */\n\n\tTHREE.ColladaExporter = function () {};\n\n\tTHREE.ColladaExporter.prototype = {\n\n\t\tconstructor: THREE.ColladaExporter,\n\n\t\tparse: function ( object, onDone, options ) {\n\n\t\t\toptions = options || {};\n\n\t\t\toptions = Object.assign( {\n\t\t\t\tversion: '1.4.1',\n\t\t\t\tauthor: null,\n\t\t\t\ttextureDirectory: '',\n\t\t\t}, options );\n\n\t\t\tif ( options.textureDirectory !== '' ) {\n\n\t\t\t\toptions.textureDirectory = `${ options.textureDirectory }/`\n\t\t\t\t\t.replace( /\\\\/g, '/' )\n\t\t\t\t\t.replace( /\\/+/g, '/' );\n\n\t\t\t}\n\n\t\t\tvar version = options.version;\n\t\t\tif ( version !== '1.4.1' && version !== '1.5.0' ) {\n\n\t\t\t\tconsole.warn( `ColladaExporter : Version ${ version } not supported for export. Only 1.4.1 and 1.5.0.` );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Convert the urdf xml into a well-formatted, indented format\n\t\t\tfunction format( urdf ) {\n\n\t\t\t\tvar IS_END_TAG = /^<\\//;\n\t\t\t\tvar IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n\t\t\t\tvar HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n\n\t\t\t\tvar pad = ( ch, num ) => ( num > 0 ? ch + pad( ch, num - 1 ) : '' );\n\n\t\t\t\tvar tagnum = 0;\n\t\t\t\treturn urdf\n\t\t\t\t\t.match( /(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g )\n\t\t\t\t\t.map( tag => {\n\n\t\t\t\t\t\tif ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && IS_END_TAG.test( tag ) ) {\n\n\t\t\t\t\t\t\ttagnum --;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar res = `${ pad( '  ', tagnum ) }${ tag }`;\n\n\t\t\t\t\t\tif ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && ! IS_END_TAG.test( tag ) ) {\n\n\t\t\t\t\t\t\ttagnum ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn res;\n\n\t\t\t\t\t} )\n\t\t\t\t\t.join( '\\n' );\n\n\t\t\t}\n\n\t\t\t// Convert an image into a png format for saving\n\t\t\tfunction base64ToBuffer( str ) {\n\n\t\t\t\tvar b = atob( str );\n\t\t\t\tvar buf = new Uint8Array( b.length );\n\n\t\t\t\tfor ( var i = 0, l = buf.length; i < l; i ++ ) {\n\n\t\t\t\t\tbuf[ i ] = b.charCodeAt( i );\n\n\t\t\t\t}\n\n\t\t\t\treturn buf;\n\n\t\t\t}\n\n\t\t\tvar canvas, ctx;\n\t\t\tfunction imageToData( image, ext ) {\n\n\t\t\t\tcanvas = canvas || document.createElement( 'canvas' );\n\t\t\t\tctx = ctx || canvas.getContext( '2d' );\n\n\t\t\t\tcanvas.width = image.naturalWidth;\n\t\t\t\tcanvas.height = image.naturalHeight;\n\n\t\t\t\tctx.drawImage( image, 0, 0 );\n\n\t\t\t\t// Get the base64 encoded data\n\t\t\t\tvar base64data = canvas\n\t\t\t\t\t.toDataURL( `image/${ ext }`, 1 )\n\t\t\t\t\t.replace( /^data:image\\/(png|jpg);base64,/, '' );\n\n\t\t\t\t// Convert to a uint8 array\n\t\t\t\treturn base64ToBuffer( base64data );\n\n\t\t\t}\n\n\t\t\t// gets the attribute array. Generate a new array if the attribute is interleaved\n\t\t\tvar getFuncs = [ 'getX', 'getY', 'getZ', 'getW' ];\n\t\t\tfunction attrBufferToArray( attr ) {\n\n\t\t\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t// use the typed array constructor to save on memory\n\t\t\t\t\tvar arr = new attr.array.constructor( attr.count * attr.itemSize );\n\t\t\t\t\tvar size = attr.itemSize;\n\t\t\t\t\tfor ( var i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tfor ( var j = 0; j < size; j ++ ) {\n\n\t\t\t\t\t\t\tarr[ i * size + j ] = attr[ getFuncs[ j ] ]( i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn arr;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn attr.array;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Returns an array of the same type starting at the `st` index,\n\t\t\t// and `ct` length\n\t\t\tfunction subArray( arr, st, ct ) {\n\n\t\t\t\tif ( Array.isArray( arr ) ) return arr.slice( st, st + ct );\n\t\t\t\telse return new arr.constructor( arr.buffer, st * arr.BYTES_PER_ELEMENT, ct );\n\n\t\t\t}\n\n\t\t\t// Returns the string for a geometry's attribute\n\t\t\tfunction getAttribute( attr, name, params, type ) {\n\n\t\t\t\tvar array = attrBufferToArray( attr );\n\t\t\t\tvar res =\n\t\t\t\t\t\t`<source id=\"${ name }\">` +\n\n\t\t\t\t\t\t`<float_array id=\"${ name }-array\" count=\"${ array.length }\">` +\n\t\t\t\t\t\tarray.join( ' ' ) +\n\t\t\t\t\t\t'</float_array>' +\n\n\t\t\t\t\t\t'<technique_common>' +\n\t\t\t\t\t\t`<accessor source=\"#${ name }-array\" count=\"${ Math.floor( array.length / attr.itemSize ) }\" stride=\"${ attr.itemSize }\">` +\n\n\t\t\t\t\t\tparams.map( n => `<param name=\"${ n }\" type=\"${ type }\" />` ).join( '' ) +\n\n\t\t\t\t\t\t'</accessor>' +\n\t\t\t\t\t\t'</technique_common>' +\n\t\t\t\t\t\t'</source>';\n\n\t\t\t\treturn res;\n\n\t\t\t}\n\n\t\t\t// Returns the string for a node's transform information\n\t\t\tvar transMat;\n\t\t\tfunction getTransform( o ) {\n\n\t\t\t\t// ensure the object's matrix is up to date\n\t\t\t\t// before saving the transform\n\t\t\t\to.updateMatrix();\n\n\t\t\t\ttransMat = transMat || new THREE.Matrix4();\n\t\t\t\ttransMat.copy( o.matrix );\n\t\t\t\ttransMat.transpose();\n\t\t\t\treturn `<matrix>${ transMat.toArray().join( ' ' ) }</matrix>`;\n\n\t\t\t}\n\n\t\t\t// Process the given piece of geometry into the geometry library\n\t\t\t// Returns the mesh id\n\t\t\tfunction processGeometry( g ) {\n\n\t\t\t\tvar info = geometryInfo.get( g );\n\n\t\t\t\tif ( ! info ) {\n\n\t\t\t\t\t// convert the geometry to bufferGeometry if it isn't already\n\t\t\t\t\tvar bufferGeometry = g;\n\t\t\t\t\tif ( bufferGeometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\t\tbufferGeometry = ( new THREE.BufferGeometry() ).fromGeometry( bufferGeometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meshid = `Mesh${ libraryGeometries.length + 1 }`;\n\n\t\t\t\t\tvar indexCount =\n\t\t\t\t\t\tbufferGeometry.index ?\n\t\t\t\t\t\t\tbufferGeometry.index.count * bufferGeometry.index.itemSize :\n\t\t\t\t\t\t\tbufferGeometry.attributes.position.count;\n\n\t\t\t\t\tvar groups =\n\t\t\t\t\t\tbufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ?\n\t\t\t\t\t\t\tbufferGeometry.groups :\n\t\t\t\t\t\t\t[ { start: 0, count: indexCount, materialIndex: 0 } ];\n\n\n\t\t\t\t\tvar gname = g.name ? ` name=\"${ g.name }\"` : '';\n\t\t\t\t\tvar gnode = `<geometry id=\"${ meshid }\"${ gname }><mesh>`;\n\n\t\t\t\t\t// define the geometry node and the vertices for the geometry\n\t\t\t\t\tvar posName = `${ meshid }-position`;\n\t\t\t\t\tvar vertName = `${ meshid }-vertices`;\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.position, posName, [ 'X', 'Y', 'Z' ], 'float' );\n\t\t\t\t\tgnode += `<vertices id=\"${ vertName }\"><input semantic=\"POSITION\" source=\"#${ posName }\" /></vertices>`;\n\n\t\t\t\t\t// NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n\t\t\t\t\t// can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n\t\t\t\t\t// models with attributes that share an offset.\n\t\t\t\t\t// MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n\n\t\t\t\t\t// serialize normals\n\t\t\t\t\tvar triangleInputs = `<input semantic=\"VERTEX\" source=\"#${ vertName }\" offset=\"0\" />`;\n\t\t\t\t\tif ( 'normal' in bufferGeometry.attributes ) {\n\n\t\t\t\t\t\tvar normName = `${ meshid }-normal`;\n\t\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.normal, normName, [ 'X', 'Y', 'Z' ], 'float' );\n\t\t\t\t\t\ttriangleInputs += `<input semantic=\"NORMAL\" source=\"#${ normName }\" offset=\"0\" />`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// serialize uvs\n\t\t\t\t\tif ( 'uv' in bufferGeometry.attributes ) {\n\n\t\t\t\t\t\tvar uvName = `${ meshid }-texcoord`;\n\t\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.uv, uvName, [ 'S', 'T' ], 'float' );\n\t\t\t\t\t\ttriangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${ uvName }\" offset=\"0\" set=\"0\" />`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// serialize colors\n\t\t\t\t\tif ( 'color' in bufferGeometry.attributes ) {\n\n\t\t\t\t\t\tvar colName = `${ meshid }-color`;\n\t\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.color, colName, [ 'X', 'Y', 'Z' ], 'uint8' );\n\t\t\t\t\t\ttriangleInputs += `<input semantic=\"COLOR\" source=\"#${ colName }\" offset=\"0\" />`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar indexArray = null;\n\t\t\t\t\tif ( bufferGeometry.index ) {\n\n\t\t\t\t\t\tindexArray = attrBufferToArray( bufferGeometry.index );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tindexArray = new Array( indexCount );\n\t\t\t\t\t\tfor ( var i = 0, l = indexArray.length; i < l; i ++ ) indexArray[ i ] = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\tvar subarr = subArray( indexArray, group.start, group.count );\n\t\t\t\t\t\tvar polycount = subarr.length / 3;\n\t\t\t\t\t\tgnode += `<triangles material=\"MESH_MATERIAL_${ group.materialIndex }\" count=\"${ polycount }\">`;\n\t\t\t\t\t\tgnode += triangleInputs;\n\n\t\t\t\t\t\tgnode += `<p>${ subarr.join( ' ' ) }</p>`;\n\t\t\t\t\t\tgnode += '</triangles>';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgnode += `</mesh></geometry>`;\n\n\t\t\t\t\tlibraryGeometries.push( gnode );\n\n\t\t\t\t\tinfo = { meshid: meshid, bufferGeometry: bufferGeometry };\n\t\t\t\t\tgeometryInfo.set( g, info );\n\n\t\t\t\t}\n\n\t\t\t\treturn info;\n\n\t\t\t}\n\n\t\t\t// Process the given texture into the image library\n\t\t\t// Returns the image library\n\t\t\tfunction processTexture( tex ) {\n\n\t\t\t\tvar texid = imageMap.get( tex );\n\t\t\t\tif ( texid == null ) {\n\n\t\t\t\t\ttexid = `image-${ libraryImages.length + 1 }`;\n\n\t\t\t\t\tvar ext = 'png';\n\t\t\t\t\tvar name = tex.name || texid;\n\t\t\t\t\tvar imageNode = `<image id=\"${ texid }\" name=\"${ name }\">`;\n\n\t\t\t\t\tif ( version === '1.5.0' ) {\n\n\t\t\t\t\t\timageNode += `<init_from><ref>${ options.textureDirectory }${ name }.${ ext }</ref></init_from>`;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// version image node 1.4.1\n\t\t\t\t\t\timageNode += `<init_from>${ options.textureDirectory }${ name }.${ ext }</init_from>`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\timageNode += '</image>';\n\n\t\t\t\t\tlibraryImages.push( imageNode );\n\t\t\t\t\timageMap.set( tex, texid );\n\t\t\t\t\ttextures.push( {\n\t\t\t\t\t\tdirectory: options.textureDirectory,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\text,\n\t\t\t\t\t\tdata: imageToData( tex.image, ext ),\n\t\t\t\t\t\toriginal: tex\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\treturn texid;\n\n\t\t\t}\n\n\t\t\t// Process the given material into the material and effect libraries\n\t\t\t// Returns the material id\n\t\t\tfunction processMaterial( m ) {\n\n\t\t\t\tvar matid = materialMap.get( m );\n\n\t\t\t\tif ( matid == null ) {\n\n\t\t\t\t\tmatid = `Mat${ libraryEffects.length + 1 }`;\n\n\t\t\t\t\tvar type = 'phong';\n\n\t\t\t\t\tif ( m instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\t\t\t\ttype = 'lambert';\n\n\t\t\t\t\t} else if ( m instanceof THREE.MeshBasicMaterial ) {\n\n\t\t\t\t\t\ttype = 'constant';\n\n\t\t\t\t\t\tif ( m.map !== null ) {\n\n\t\t\t\t\t\t\t// The Collada spec does not support diffuse texture maps with the\n\t\t\t\t\t\t\t// constant shader type.\n\t\t\t\t\t\t\t// mrdoob/three.js#15469\n\t\t\t\t\t\t\tconsole.warn( 'ColladaExporter: Texture maps not supported with MeshBasicMaterial.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar emissive = m.emissive ? m.emissive : new THREE.Color( 0, 0, 0 );\n\t\t\t\t\tvar diffuse = m.color ? m.color : new THREE.Color( 0, 0, 0 );\n\t\t\t\t\tvar specular = m.specular ? m.specular : new THREE.Color( 1, 1, 1 );\n\t\t\t\t\tvar shininess = m.shininess || 0;\n\t\t\t\t\tvar reflectivity = m.reflectivity || 0;\n\n\t\t\t\t\t// Do not export and alpha map for the reasons mentioned in issue (#13792)\n\t\t\t\t\t// in three.js alpha maps are black and white, but collada expects the alpha\n\t\t\t\t\t// channel to specify the transparency\n\t\t\t\t\tvar transparencyNode = '';\n\t\t\t\t\tif ( m.transparent === true ) {\n\n\t\t\t\t\t\ttransparencyNode +=\n\t\t\t\t\t\t\t`<transparent>` +\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t\t\t`<texture texture=\"diffuse-sampler\"></texture>` :\n\t\t\t\t\t\t\t\t\t'<float>1</float>'\n\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t'</transparent>';\n\n\t\t\t\t\t\tif ( m.opacity < 1 ) {\n\n\t\t\t\t\t\t\ttransparencyNode += `<transparency><float>${ m.opacity }</float></transparency>`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar techniqueNode = `<technique sid=\"common\"><${ type }>` +\n\n\t\t\t\t\t\t'<emission>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.emissiveMap ?\n\t\t\t\t\t\t\t\t'<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t\t`<color sid=\"emission\">${ emissive.r } ${ emissive.g } ${ emissive.b } 1</color>`\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t'</emission>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\ttype !== 'constant' ?\n\t\t\t\t\t\t\t\t'<diffuse>' +\n\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t\t\t'<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t\t\t`<color sid=\"diffuse\">${ diffuse.r } ${ diffuse.g } ${ diffuse.b } 1</color>`\n\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t'</diffuse>'\n\t\t\t\t\t\t\t\t: ''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\ttype !== 'constant' ?\n\t\t\t\t\t\t\t\t'<bump>' +\n\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tm.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''\n\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t'</bump>'\n\t\t\t\t\t\t\t\t: ''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\ttype === 'phong' ?\n\t\t\t\t\t\t\t\t`<specular><color sid=\"specular\">${ specular.r } ${ specular.g } ${ specular.b } 1</color></specular>` +\n\n\t\t\t\t\t\t\t'<shininess>' +\n\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tm.specularMap ?\n\t\t\t\t\t\t\t\t\t'<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t\t\t`<float sid=\"shininess\">${ shininess }</float>`\n\t\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t\t'</shininess>'\n\t\t\t\t\t\t\t\t: ''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t`<reflective><color>${ diffuse.r } ${ diffuse.g } ${ diffuse.b } 1</color></reflective>` +\n\n\t\t\t\t\t\t`<reflectivity><float>${ reflectivity }</float></reflectivity>` +\n\n\t\t\t\t\t\ttransparencyNode +\n\n\t\t\t\t\t\t`</${ type }></technique>`;\n\n\t\t\t\t\tvar effectnode =\n\t\t\t\t\t\t`<effect id=\"${ matid }-effect\">` +\n\t\t\t\t\t\t'<profile_COMMON>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t\t'<newparam sid=\"diffuse-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t\t`<init_from>${ processTexture( m.map ) }</init_from>` +\n\t\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t\t'<newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.specularMap ?\n\t\t\t\t\t\t\t\t'<newparam sid=\"specular-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t\t`<init_from>${ processTexture( m.specularMap ) }</init_from>` +\n\t\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t\t'<newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.emissiveMap ?\n\t\t\t\t\t\t\t\t'<newparam sid=\"emissive-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t\t`<init_from>${ processTexture( m.emissiveMap ) }</init_from>` +\n\t\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t\t'<newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.normalMap ?\n\t\t\t\t\t\t\t\t'<newparam sid=\"bump-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t\t`<init_from>${ processTexture( m.normalMap ) }</init_from>` +\n\t\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t\t'<newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\ttechniqueNode +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.side === THREE.DoubleSide ?\n\t\t\t\t\t\t\t\t`<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>` :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t'</profile_COMMON>' +\n\n\t\t\t\t\t\t'</effect>';\n\n\t\t\t\t\tvar materialName = m.name ? ` name=\"${ m.name }\"` : '';\n\t\t\t\t\tvar materialNode = `<material id=\"${ matid }\"${ materialName }><instance_effect url=\"#${ matid }-effect\" /></material>`;\n\n\t\t\t\t\tlibraryMaterials.push( materialNode );\n\t\t\t\t\tlibraryEffects.push( effectnode );\n\t\t\t\t\tmaterialMap.set( m, matid );\n\n\t\t\t\t}\n\n\t\t\t\treturn matid;\n\n\t\t\t}\n\n\t\t\t// Recursively process the object into a scene\n\t\t\tfunction processObject( o ) {\n\n\t\t\t\tvar node = `<node name=\"${ o.name }\">`;\n\n\t\t\t\tnode += getTransform( o );\n\n\t\t\t\tif ( o instanceof THREE.Mesh && o.geometry != null ) {\n\n\t\t\t\t\t// function returns the id associated with the mesh and a \"BufferGeometry\" version\n\t\t\t\t\t// of the geometry in case it's not a geometry.\n\t\t\t\t\tvar geomInfo = processGeometry( o.geometry );\n\t\t\t\t\tvar meshid = geomInfo.meshid;\n\t\t\t\t\tvar geometry = geomInfo.bufferGeometry;\n\n\t\t\t\t\t// ids of the materials to bind to the geometry\n\t\t\t\t\tvar matids = null;\n\t\t\t\t\tvar matidsArray = [];\n\n\t\t\t\t\t// get a list of materials to bind to the sub groups of the geometry.\n\t\t\t\t\t// If the amount of subgroups is greater than the materials, than reuse\n\t\t\t\t\t// the materials.\n\t\t\t\t\tvar mat = o.material || new THREE.MeshBasicMaterial();\n\t\t\t\t\tvar materials = Array.isArray( mat ) ? mat : [ mat ];\n\n\t\t\t\t\tif ( geometry.groups.length > materials.length ) {\n\n\t\t\t\t\t\tmatidsArray = new Array( geometry.groups.length );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmatidsArray = new Array( materials.length );\n\n\t\t\t\t\t}\n\t\t\t\t\tmatids = matidsArray.fill()\n\t\t\t\t\t\t.map( ( v, i ) => processMaterial( materials[ i % materials.length ] ) );\n\n\t\t\t\t\tnode +=\n\t\t\t\t\t\t`<instance_geometry url=\"#${ meshid }\">` +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tmatids != null ?\n\t\t\t\t\t\t\t\t'<bind_material><technique_common>' +\n\t\t\t\t\t\t\t\tmatids.map( ( id, i ) =>\n\n\t\t\t\t\t\t\t\t\t`<instance_material symbol=\"MESH_MATERIAL_${ i }\" target=\"#${ id }\" >` +\n\n\t\t\t\t\t\t\t\t\t'<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" />' +\n\n\t\t\t\t\t\t\t\t\t'</instance_material>'\n\t\t\t\t\t\t\t\t).join( '' ) +\n\t\t\t\t\t\t\t\t'</technique_common></bind_material>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t'</instance_geometry>';\n\n\t\t\t\t}\n\n\t\t\t\to.children.forEach( c => node += processObject( c ) );\n\n\t\t\t\tnode += '</node>';\n\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t\tvar geometryInfo = new WeakMap();\n\t\t\tvar materialMap = new WeakMap();\n\t\t\tvar imageMap = new WeakMap();\n\t\t\tvar textures = [];\n\n\t\t\tvar libraryImages = [];\n\t\t\tvar libraryGeometries = [];\n\t\t\tvar libraryEffects = [];\n\t\t\tvar libraryMaterials = [];\n\t\t\tvar libraryVisualScenes = processObject( object );\n\n\t\t\tvar specLink = version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n\t\t\tvar dae =\n\t\t\t\t'<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>' +\n\t\t\t\t`<COLLADA xmlns=\"${ specLink }\" version=\"${ version }\">` +\n\t\t\t\t'<asset>' +\n\t\t\t\t(\n\t\t\t\t\t'<contributor>' +\n\t\t\t\t\t'<authoring_tool>three.js Collada Exporter</authoring_tool>' +\n\t\t\t\t\t( options.author !== null ? `<author>${ options.author }</author>` : '' ) +\n\t\t\t\t\t'</contributor>' +\n\t\t\t\t\t`<created>${ ( new Date() ).toISOString() }</created>` +\n\t\t\t\t\t`<modified>${ ( new Date() ).toISOString() }</modified>` +\n\t\t\t\t\t'<up_axis>Y_UP</up_axis>'\n\t\t\t\t) +\n\t\t\t\t'</asset>';\n\n\t\t\tdae += `<library_images>${ libraryImages.join( '' ) }</library_images>`;\n\n\t\t\tdae += `<library_effects>${ libraryEffects.join( '' ) }</library_effects>`;\n\n\t\t\tdae += `<library_materials>${ libraryMaterials.join( '' ) }</library_materials>`;\n\n\t\t\tdae += `<library_geometries>${ libraryGeometries.join( '' ) }</library_geometries>`;\n\n\t\t\tdae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${ libraryVisualScenes }</visual_scene></library_visual_scenes>`;\n\n\t\t\tdae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n\n\t\t\tdae += '</COLLADA>';\n\n\t\t\tvar res = {\n\t\t\t\tdata: format( dae ),\n\t\t\t\ttextures\n\t\t\t};\n\n\t\t\tif ( typeof onDone === 'function' ) {\n\n\t\t\t\trequestAnimationFrame( () => onDone( res ) );\n\n\t\t\t}\n\n\t\t\treturn res;\n\n\t\t}\n\n\t};\n\n\treturn THREE.ColladaExporter;\n});\n\ndefine('skylark-threejs-ex/exporters/PLYExporter',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Garrett Johnson / http://gkjohnson.github.io/\n\t * https://github.com/gkjohnson/ply-exporter-js\n\t *\n\t * Usage:\n\t *  var exporter = new THREE.PLYExporter();\n\t *\n\t *  // second argument is a list of options\n\t *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\n\t *\n\t * Format Definition:\n\t * http://paulbourke.net/dataformats/ply/\n\t */\n\n\tTHREE.PLYExporter = function () {};\n\n\tTHREE.PLYExporter.prototype = {\n\n\t\tconstructor: THREE.PLYExporter,\n\n\t\tparse: function ( object, onDone, options ) {\n\n\t\t\tif ( onDone && typeof onDone === 'object' ) {\n\n\t\t\t\tconsole.warn( 'THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.' );\n\t\t\t\toptions = onDone;\n\t\t\t\tonDone = undefined;\n\n\t\t\t}\n\n\t\t\t// Iterate over the valid meshes in the object\n\t\t\tfunction traverseMeshes( cb ) {\n\n\t\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\t\t\tvar mesh = child;\n\t\t\t\t\t\tvar geometry = mesh.geometry;\n\n\t\t\t\t\t\tif ( geometry.isGeometry === true ) {\n\n\t\t\t\t\t\t\tgeometry = geomToBufferGeom.get( geometry );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( geometry.isBufferGeometry === true ) {\n\n\t\t\t\t\t\t\tif ( geometry.getAttribute( 'position' ) !== undefined ) {\n\n\t\t\t\t\t\t\t\tcb( mesh, geometry );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// Default options\n\t\t\tvar defaultOptions = {\n\t\t\t\tbinary: false,\n\t\t\t\texcludeAttributes: [], // normal, uv, color, index\n\t\t\t\tlittleEndian: false\n\t\t\t};\n\n\t\t\toptions = Object.assign( defaultOptions, options );\n\n\t\t\tvar excludeAttributes = options.excludeAttributes;\n\t\t\tvar geomToBufferGeom = new WeakMap();\n\t\t\tvar includeNormals = false;\n\t\t\tvar includeColors = false;\n\t\t\tvar includeUVs = false;\n\n\t\t\t// count the vertices, check which properties are used,\n\t\t\t// and cache the BufferGeometry\n\t\t\tvar vertexCount = 0;\n\t\t\tvar faceCount = 0;\n\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\t\tvar mesh = child;\n\t\t\t\t\tvar geometry = mesh.geometry;\n\n\t\t\t\t\tif ( geometry.isGeometry === true ) {\n\n\t\t\t\t\t\tvar bufferGeometry = geomToBufferGeom.get( geometry ) || new THREE.BufferGeometry().setFromObject( mesh );\n\t\t\t\t\t\tgeomToBufferGeom.set( geometry, bufferGeometry );\n\t\t\t\t\t\tgeometry = bufferGeometry;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.isBufferGeometry === true ) {\n\n\t\t\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\t\t\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\n\t\t\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\n\t\t\t\t\t\tvar colors = geometry.getAttribute( 'color' );\n\t\t\t\t\t\tvar indices = geometry.getIndex();\n\n\t\t\t\t\t\tif ( vertices === undefined ) {\n\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvertexCount += vertices.count;\n\t\t\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\n\t\t\t\t\t\tif ( normals !== undefined ) includeNormals = true;\n\n\t\t\t\t\t\tif ( uvs !== undefined ) includeUVs = true;\n\n\t\t\t\t\t\tif ( colors !== undefined ) includeColors = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tvar includeIndices = excludeAttributes.indexOf( 'index' ) === - 1;\n\t\t\tincludeNormals = includeNormals && excludeAttributes.indexOf( 'normal' ) === - 1;\n\t\t\tincludeColors = includeColors && excludeAttributes.indexOf( 'color' ) === - 1;\n\t\t\tincludeUVs = includeUVs && excludeAttributes.indexOf( 'uv' ) === - 1;\n\n\n\t\t\tif ( includeIndices && faceCount !== Math.floor( faceCount ) ) {\n\n\t\t\t\t// point cloud meshes will not have an index array and may not have a\n\t\t\t\t// number of vertices that is divisble by 3 (and therefore representable\n\t\t\t\t// as triangles)\n\t\t\t\tconsole.error(\n\n\t\t\t\t\t'PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' +\n\t\t\t\t\t'number of indices is not divisible by 3.'\n\n\t\t\t\t);\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar indexByteCount = 4;\n\n\t\t\tvar header =\n\t\t\t\t'ply\\n' +\n\t\t\t\t`format ${ options.binary ? ( options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' ) : 'ascii' } 1.0\\n` +\n\t\t\t\t`element vertex ${vertexCount}\\n` +\n\n\t\t\t\t// position\n\t\t\t\t'property float x\\n' +\n\t\t\t\t'property float y\\n' +\n\t\t\t\t'property float z\\n';\n\n\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t// normal\n\t\t\t\theader +=\n\t\t\t\t\t'property float nx\\n' +\n\t\t\t\t\t'property float ny\\n' +\n\t\t\t\t\t'property float nz\\n';\n\n\t\t\t}\n\n\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t// uvs\n\t\t\t\theader +=\n\t\t\t\t\t'property float s\\n' +\n\t\t\t\t\t'property float t\\n';\n\n\t\t\t}\n\n\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t// colors\n\t\t\t\theader +=\n\t\t\t\t\t'property uchar red\\n' +\n\t\t\t\t\t'property uchar green\\n' +\n\t\t\t\t\t'property uchar blue\\n';\n\n\t\t\t}\n\n\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t// faces\n\t\t\t\theader +=\n\t\t\t\t\t`element face ${faceCount}\\n` +\n\t\t\t\t\t`property list uchar int vertex_index\\n`;\n\n\t\t\t}\n\n\t\t\theader += 'end_header\\n';\n\n\n\t\t\t// Generate attribute data\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\t\t\tvar result = null;\n\n\t\t\tif ( options.binary === true ) {\n\n\t\t\t\t// Binary File Generation\n\t\t\t\tvar headerBin = new TextEncoder().encode( header );\n\n\t\t\t\t// 3 position values at 4 bytes\n\t\t\t\t// 3 normal values at 4 bytes\n\t\t\t\t// 3 color channels with 1 byte\n\t\t\t\t// 2 uv values at 4 bytes\n\t\t\t\tvar vertexListLength = vertexCount * ( 4 * 3 + ( includeNormals ? 4 * 3 : 0 ) + ( includeColors ? 3 : 0 ) + ( includeUVs ? 4 * 2 : 0 ) );\n\n\t\t\t\t// 1 byte shape desciptor\n\t\t\t\t// 3 vertex indices at ${indexByteCount} bytes\n\t\t\t\tvar faceListLength = includeIndices ? faceCount * ( indexByteCount * 3 + 1 ) : 0;\n\t\t\t\tvar output = new DataView( new ArrayBuffer( headerBin.length + vertexListLength + faceListLength ) );\n\t\t\t\tnew Uint8Array( output.buffer ).set( headerBin, 0 );\n\n\n\t\t\t\tvar vOffset = headerBin.length;\n\t\t\t\tvar fOffset = headerBin.length + vertexListLength;\n\t\t\t\tvar writtenVertices = 0;\n\t\t\t\ttraverseMeshes( function ( mesh, geometry ) {\n\n\t\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\t\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\n\t\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\n\t\t\t\t\tvar colors = geometry.getAttribute( 'color' );\n\t\t\t\t\tvar indices = geometry.getIndex();\n\n\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\n\t\t\t\t\t\t// Position information\n\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.x, options.littleEndian );\n\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.y, options.littleEndian );\n\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.z, options.littleEndian );\n\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t// Normal information\n\t\t\t\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t\t\t\tif ( normals != null ) {\n\n\t\t\t\t\t\t\t\tvertex.x = normals.getX( i );\n\t\t\t\t\t\t\t\tvertex.y = normals.getY( i );\n\t\t\t\t\t\t\t\tvertex.z = normals.getZ( i );\n\n\t\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.x, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.y, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.z, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// UV information\n\t\t\t\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t\t\t\tif ( uvs != null ) {\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getX( i ), options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getY( i ), options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t} else if ( includeUVs !== false ) {\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Color information\n\t\t\t\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t\t\t\tif ( colors != null ) {\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getX( i ) * 255 ) );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getY( i ) * 255 ) );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getZ( i ) * 255 ) );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t\t\t// Create the face list\n\n\t\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\n\t\t\t\t\t\t\t\tfOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 0 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 1 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 2 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\n\t\t\t\t\t\t\t\tfOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i + 1, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i + 2, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// Save the amount of verts we've already written so we can offset\n\t\t\t\t\t// the face index on the next mesh\n\t\t\t\t\twrittenVertices += vertices.count;\n\n\t\t\t\t} );\n\n\t\t\t\tresult = output.buffer;\n\n\t\t\t} else {\n\n\t\t\t\t// Ascii File Generation\n\t\t\t\t// count the number of vertices\n\t\t\t\tvar writtenVertices = 0;\n\t\t\t\tvar vertexList = '';\n\t\t\t\tvar faceList = '';\n\n\t\t\t\ttraverseMeshes( function ( mesh, geometry ) {\n\n\t\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\t\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\n\t\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\n\t\t\t\t\tvar colors = geometry.getAttribute( 'color' );\n\t\t\t\t\tvar indices = geometry.getIndex();\n\n\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\t\t// form each line\n\t\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\n\t\t\t\t\t\t// Position information\n\t\t\t\t\t\tvar line =\n\t\t\t\t\t\t\tvertex.x + ' ' +\n\t\t\t\t\t\t\tvertex.y + ' ' +\n\t\t\t\t\t\t\tvertex.z;\n\n\t\t\t\t\t\t// Normal information\n\t\t\t\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t\t\t\tif ( normals != null ) {\n\n\t\t\t\t\t\t\t\tvertex.x = normals.getX( i );\n\t\t\t\t\t\t\t\tvertex.y = normals.getY( i );\n\t\t\t\t\t\t\t\tvertex.z = normals.getZ( i );\n\n\t\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\t\tvertex.x + ' ' +\n\t\t\t\t\t\t\t\t\tvertex.y + ' ' +\n\t\t\t\t\t\t\t\t\tvertex.z;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tline += ' 0 0 0';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// UV information\n\t\t\t\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t\t\t\tif ( uvs != null ) {\n\n\t\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\t\tuvs.getX( i ) + ' ' +\n\t\t\t\t\t\t\t\t\tuvs.getY( i );\n\n\t\t\t\t\t\t\t} else if ( includeUVs !== false ) {\n\n\t\t\t\t\t\t\t\tline += ' 0 0';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Color information\n\t\t\t\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t\t\t\tif ( colors != null ) {\n\n\t\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\t\tMath.floor( colors.getX( i ) * 255 ) + ' ' +\n\t\t\t\t\t\t\t\t\tMath.floor( colors.getY( i ) * 255 ) + ' ' +\n\t\t\t\t\t\t\t\t\tMath.floor( colors.getZ( i ) * 255 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tline += ' 255 255 255';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvertexList += line + '\\n';\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create the face list\n\t\t\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\tfaceList += `3 ${ indices.getX( i + 0 ) + writtenVertices }`;\n\t\t\t\t\t\t\t\tfaceList += ` ${ indices.getX( i + 1 ) + writtenVertices }`;\n\t\t\t\t\t\t\t\tfaceList += ` ${ indices.getX( i + 2 ) + writtenVertices }\\n`;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\tfaceList += `3 ${ writtenVertices + i } ${ writtenVertices + i + 1 } ${ writtenVertices + i + 2 }\\n`;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\twrittenVertices += vertices.count;\n\n\t\t\t\t} );\n\n\t\t\t\tresult = `${ header }${vertexList}${ includeIndices ? `${faceList}\\n` : '\\n' }`;\n\n\t\t\t}\n\n\t\t\tif ( typeof onDone === 'function' ) requestAnimationFrame( () => onDone( result ) );\n\t\t\treturn result;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.PLYExporter;\n});\n\ndefine('skylark-threejs-ex/main',[\r\n\t\"skylark-threejs\",\r\n\r\n\t\"./shaders/CopyShader\",\r\n\t\"./shaders/BokehShader\",\r\n\t\"./shaders/SAOShader\",\r\n\t\"./shaders/DepthLimitedBlurShader\",\r\n\t\"./shaders/UnpackDepthRGBAShader\",\r\n\t\"./shaders/ConvolutionShader\",\r\n\t\"./shaders/LuminosityHighPassShader\",\r\n\t\"./shaders/FXAAShader\",\r\n\t\"./shaders/SSAOShader\",\r\n\t\"./shaders/FilmShader\",\r\n\t\"./shaders/DotScreenShader\",\r\n\t\"./shaders/LuminosityShader\",\r\n\t\"./shaders/SobelOperatorShader\",\r\n\t\"./shaders/ColorifyShader\",\r\n\t\"./shaders/ToneMapShader\",\r\n\t\"./shaders/TechnicolorShader\",\r\n\t\"./shaders/HueSaturationShader\",\r\n\r\n\t\"./postprocessing/EffectComposer\",\r\n\t\"./postprocessing/RenderPass\",\r\n\t\"./postprocessing/ShaderPass\",\r\n\t\"./postprocessing/MaskPass\",\r\n\r\n\t\"./curves/NURBSCurve\",\r\n\t\"./curves/NURBSSurface\",\r\n\t\"./curves/NURBSUtils\",\r\n\r\n\t\"./objects/Lensflare\",\r\n\t\"./objects/Reflector\",\r\n\t\"./objects/Refractor\",\r\n\r\n\t\"./loaders/TTFLoader\",\r\n//\t\"./loaders/LoaderSupport\",\r\n\t\"./loaders/3MFLoader\",\r\n\t\"./loaders/AMFLoader\",\r\n//\t\"./loaders/AssimpJSONLoader\",\r\n\t\"./loaders/AssimpLoader\",\r\n//\t\"./loaders/AWDLoader\",\r\n//\t\"./loaders/BabylonLoader\",\r\n\t\"./loaders/ColladaLoader\",\r\n\t\"./loaders/DRACOLoader\",\r\n\t\"./loaders/FBXLoader\",\r\n\t\"./loaders/GCodeLoader\",\r\n\t\"./loaders/GLTFLoader\",\r\n\t\"./loaders/MTLLoader\",\r\n\t\"./loaders/OBJLoader\",\r\n//\t\"./loaders/OBJLoader2\",\r\n\t\"./loaders/PCDLoader\",\r\n\t\"./loaders/PLYLoader\",\r\n\t\"./loaders/PRWMLoader\",\r\n\t\"./loaders/STLLoader\",\r\n\t\"./loaders/SVGLoader\",\r\n\t\"./loaders/TDSLoader\",\r\n//\t\"./loaders/VRMLLoader\",\r\n\t\"./loaders/VTKLoader\",\r\n\t\"./loaders/XLoader\",\r\n\t\"./loaders/DDSLoader\",\r\n\t\"./loaders/PVRLoader\",\r\n\t\"./loaders/TGALoader\",\r\n\t\"./loaders/KTXLoader\",\r\n\r\n\t\"./modifiers/SimplifyModifier\",\r\n\t\"./modifiers/SubdivisionModifier\",\r\n\r\n\t\"./exporters/DRACOExporter\",\r\n\t\"./exporters/OBJExporter\",\r\n\t\"./exporters/STLExporter\",\r\n\t\"./exporters/GLTFExporter\",\r\n\t\"./exporters/ColladaExporter\",\r\n\t\"./exporters/PLYExporter\"\r\n\r\n],function(THREE){\r\n\treturn THREE;\r\n});\ndefine('skylark-threejs-ex', ['skylark-threejs-ex/main'], function (main) { return main; });\n\n"]}