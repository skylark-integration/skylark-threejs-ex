{"version":3,"sources":["skylark-threejs-ex.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-threejs-ex.js","sourcesContent":["define('skylark-threejs-ex/shaders/CopyShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Full-screen textured quad shader\n\t */\n\n\tTHREE.CopyShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"opacity\": { value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 texel = texture2D( tDiffuse, vUv );\",\n\t\t\t\"\tgl_FragColor = opacity * texel;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.CopyShader;\n});\n\ndefine('skylark-threejs-ex/shaders/BokehShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Depth-of-field shader with bokeh\n\t * ported from GLSL shader by Martins Upitis\n\t * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html\n\t */\n\n\tTHREE.BokehShader = {\n\n\t\tdefines: {\n\t\t\t\"DEPTH_PACKING\": 1,\n\t\t\t\"PERSPECTIVE_CAMERA\": 1,\n\t\t},\n\n\t\tuniforms: {\n\n\t\t\t\"tColor\": { value: null },\n\t\t\t\"tDepth\": { value: null },\n\t\t\t\"focus\": { value: 1.0 },\n\t\t\t\"aspect\": { value: 1.0 },\n\t\t\t\"aperture\": { value: 0.025 },\n\t\t\t\"maxblur\": { value: 1.0 },\n\t\t\t\"nearClip\": { value: 1.0 },\n\t\t\t\"farClip\": { value: 1000.0 },\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\t\t\t\"#include <common>\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform sampler2D tColor;\",\n\t\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\t\"uniform float maxblur;\", // max blur amount\n\t\t\t\"uniform float aperture;\", // aperture - bigger values for shallower depth of field\n\n\t\t\t\"uniform float nearClip;\",\n\t\t\t\"uniform float farClip;\",\n\n\t\t\t\"uniform float focus;\",\n\t\t\t\"uniform float aspect;\",\n\n\t\t\t\"#include <packing>\",\n\n\t\t\t\"float getDepth( const in vec2 screenPosition ) {\",\n\t\t\t\"\t#if DEPTH_PACKING == 1\",\n\t\t\t\"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"float getViewZ( const in float depth ) {\",\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\t\t\t\"\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn orthographicDepthToViewZ( depth, nearClip, farClip );\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec2 aspectcorrect = vec2( 1.0, aspect );\",\n\n\t\t\t\"\tfloat viewZ = getViewZ( getDepth( vUv ) );\",\n\n\t\t\t\"\tfloat factor = ( focus + viewZ );\", // viewZ is <= 0, so this is a difference equation\n\n\t\t\t\"\tvec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\",\n\n\t\t\t\"\tvec2 dofblur9 = dofblur * 0.9;\",\n\t\t\t\"\tvec2 dofblur7 = dofblur * 0.7;\",\n\t\t\t\"\tvec2 dofblur4 = dofblur * 0.4;\",\n\n\t\t\t\"\tvec4 col = vec4( 0.0 );\",\n\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\",\n\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\",\n\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\",\n\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\",\n\n\t\t\t\"\tgl_FragColor = col / 41.0;\",\n\t\t\t\"\tgl_FragColor.a = 1.0;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.BokehShader;\n});\n\ndefine('skylark-threejs-ex/shaders/SAOShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * TODO\n\t */\n\n\tTHREE.SAOShader = {\n\t\tdefines: {\n\t\t\t\"NUM_SAMPLES\": 7,\n\t\t\t\"NUM_RINGS\": 4,\n\t\t\t\"NORMAL_TEXTURE\": 0,\n\t\t\t\"DIFFUSE_TEXTURE\": 0,\n\t\t\t\"DEPTH_PACKING\": 1,\n\t\t\t\"PERSPECTIVE_CAMERA\": 1\n\t\t},\n\t\tuniforms: {\n\n\t\t\t\"tDepth\": { value: null },\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"tNormal\": { value: null },\n\t\t\t\"size\": { value: new THREE.Vector2( 512, 512 ) },\n\n\t\t\t\"cameraNear\": { value: 1 },\n\t\t\t\"cameraFar\": { value: 100 },\n\t\t\t\"cameraProjectionMatrix\": { value: new THREE.Matrix4() },\n\t\t\t\"cameraInverseProjectionMatrix\": { value: new THREE.Matrix4() },\n\n\t\t\t\"scale\": { value: 1.0 },\n\t\t\t\"intensity\": { value: 0.1 },\n\t\t\t\"bias\": { value: 0.5 },\n\n\t\t\t\"minResolution\": { value: 0.0 },\n\t\t\t\"kernelRadius\": { value: 100.0 },\n\t\t\t\"randomSeed\": { value: 0.0 }\n\t\t},\n\t\tvertexShader: [\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\t\tfragmentShader: [\n\t\t\t\"#include <common>\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"#if DIFFUSE_TEXTURE == 1\",\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"#endif\",\n\n\t\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\t\"#if NORMAL_TEXTURE == 1\",\n\t\t\t\"uniform sampler2D tNormal;\",\n\t\t\t\"#endif\",\n\n\t\t\t\"uniform float cameraNear;\",\n\t\t\t\"uniform float cameraFar;\",\n\t\t\t\"uniform mat4 cameraProjectionMatrix;\",\n\t\t\t\"uniform mat4 cameraInverseProjectionMatrix;\",\n\n\t\t\t\"uniform float scale;\",\n\t\t\t\"uniform float intensity;\",\n\t\t\t\"uniform float bias;\",\n\t\t\t\"uniform float kernelRadius;\",\n\t\t\t\"uniform float minResolution;\",\n\t\t\t\"uniform vec2 size;\",\n\t\t\t\"uniform float randomSeed;\",\n\n\t\t\t\"// RGBA depth\",\n\n\t\t\t\"#include <packing>\",\n\n\t\t\t\"vec4 getDefaultColor( const in vec2 screenPosition ) {\",\n\t\t\t\"\t#if DIFFUSE_TEXTURE == 1\",\n\t\t\t\"\treturn texture2D( tDiffuse, vUv );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn vec4( 1.0 );\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"float getDepth( const in vec2 screenPosition ) {\",\n\t\t\t\"\t#if DEPTH_PACKING == 1\",\n\t\t\t\"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"float getViewZ( const in float depth ) {\",\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\t\t\t\"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\",\n\t\t\t\"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\",\n\t\t\t\"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\",\n\t\t\t\"\tclipPosition *= clipW; // unprojection.\",\n\n\t\t\t\"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\",\n\t\t\t\"}\",\n\n\t\t\t\"vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {\",\n\t\t\t\"\t#if NORMAL_TEXTURE == 1\",\n\t\t\t\"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"float scaleDividedByCameraFar;\",\n\t\t\t\"float minResolutionMultipliedByCameraFar;\",\n\n\t\t\t\"float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\",\n\t\t\t\"\tvec3 viewDelta = sampleViewPosition - centerViewPosition;\",\n\t\t\t\"\tfloat viewDistance = length( viewDelta );\",\n\t\t\t\"\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\",\n\n\t\t\t\"\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );\",\n\t\t\t\"}\",\n\n\t\t\t\"// moving costly divides into consts\",\n\t\t\t\"const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\",\n\t\t\t\"const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\",\n\n\t\t\t\"float getAmbientOcclusion( const in vec3 centerViewPosition ) {\",\n\t\t\t\"\t// precompute some variables require in getOcclusion.\",\n\t\t\t\"\tscaleDividedByCameraFar = scale / cameraFar;\",\n\t\t\t\"\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;\",\n\t\t\t\"\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );\",\n\n\t\t\t\"\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\",\n\t\t\t\"\tfloat angle = rand( vUv + randomSeed ) * PI2;\",\n\t\t\t\"\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;\",\n\t\t\t\"\tvec2 radiusStep = radius;\",\n\n\t\t\t\"\tfloat occlusionSum = 0.0;\",\n\t\t\t\"\tfloat weightSum = 0.0;\",\n\n\t\t\t\"\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\",\n\t\t\t\"\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;\",\n\t\t\t\"\t\tradius += radiusStep;\",\n\t\t\t\"\t\tangle += ANGLE_STEP;\",\n\n\t\t\t\"\t\tfloat sampleDepth = getDepth( sampleUv );\",\n\t\t\t\"\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\",\n\t\t\t\"\t\t\tcontinue;\",\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t\tfloat sampleViewZ = getViewZ( sampleDepth );\",\n\t\t\t\"\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );\",\n\t\t\t\"\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\",\n\t\t\t\"\t\tweightSum += 1.0;\",\n\t\t\t\"\t}\",\n\n\t\t\t\"\tif( weightSum == 0.0 ) discard;\",\n\n\t\t\t\"\treturn occlusionSum * ( intensity / weightSum );\",\n\t\t\t\"}\",\n\n\n\t\t\t\"void main() {\",\n\t\t\t\"\tfloat centerDepth = getDepth( vUv );\",\n\t\t\t\"\tif( centerDepth >= ( 1.0 - EPSILON ) ) {\",\n\t\t\t\"\t\tdiscard;\",\n\t\t\t\"\t}\",\n\n\t\t\t\"\tfloat centerViewZ = getViewZ( centerDepth );\",\n\t\t\t\"\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\",\n\n\t\t\t\"\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\",\n\n\t\t\t\"\tgl_FragColor = getDefaultColor( vUv );\",\n\t\t\t\"\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\t};\n\t\n\treturn THREE.SAOShader;\n});\n\ndefine('skylark-threejs-ex/shaders/DepthLimitedBlurShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * TODO\n\t */\n\n\tTHREE.DepthLimitedBlurShader = {\n\t\tdefines: {\n\t\t\t\"KERNEL_RADIUS\": 4,\n\t\t\t\"DEPTH_PACKING\": 1,\n\t\t\t\"PERSPECTIVE_CAMERA\": 1\n\t\t},\n\t\tuniforms: {\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"size\": { value: new THREE.Vector2( 512, 512 ) },\n\t\t\t\"sampleUvOffsets\": { value: [ new THREE.Vector2( 0, 0 ) ] },\n\t\t\t\"sampleWeights\": { value: [ 1.0 ] },\n\t\t\t\"tDepth\": { value: null },\n\t\t\t\"cameraNear\": { value: 10 },\n\t\t\t\"cameraFar\": { value: 1000 },\n\t\t\t\"depthCutoff\": { value: 10 },\n\t\t},\n\t\tvertexShader: [\n\t\t\t\"#include <common>\",\n\n\t\t\t\"uniform vec2 size;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"varying vec2 vInvSize;\",\n\n\t\t\t\"void main() {\",\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tvInvSize = 1.0 / size;\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\t\tfragmentShader: [\n\t\t\t\"#include <common>\",\n\t\t\t\"#include <packing>\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\t\"uniform float cameraNear;\",\n\t\t\t\"uniform float cameraFar;\",\n\t\t\t\"uniform float depthCutoff;\",\n\n\t\t\t\"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\",\n\t\t\t\"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\",\n\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"varying vec2 vInvSize;\",\n\n\t\t\t\"float getDepth( const in vec2 screenPosition ) {\",\n\t\t\t\"\t#if DEPTH_PACKING == 1\",\n\t\t\t\"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"float getViewZ( const in float depth ) {\",\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\t\t\t\"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\t\t\t\"\tfloat depth = getDepth( vUv );\",\n\t\t\t\"\tif( depth >= ( 1.0 - EPSILON ) ) {\",\n\t\t\t\"\t\tdiscard;\",\n\t\t\t\"\t}\",\n\n\t\t\t\"\tfloat centerViewZ = -getViewZ( depth );\",\n\t\t\t\"\tbool rBreak = false, lBreak = false;\",\n\n\t\t\t\"\tfloat weightSum = sampleWeights[0];\",\n\t\t\t\"\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\",\n\n\t\t\t\"\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\",\n\n\t\t\t\"\t\tfloat sampleWeight = sampleWeights[i];\",\n\t\t\t\"\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\",\n\n\t\t\t\"\t\tvec2 sampleUv = vUv + sampleUvOffset;\",\n\t\t\t\"\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\",\n\n\t\t\t\"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\",\n\n\t\t\t\"\t\tif( ! rBreak ) {\",\n\t\t\t\"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\",\n\t\t\t\"\t\t\tweightSum += sampleWeight;\",\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t\tsampleUv = vUv - sampleUvOffset;\",\n\t\t\t\"\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\",\n\n\t\t\t\"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\",\n\n\t\t\t\"\t\tif( ! lBreak ) {\",\n\t\t\t\"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\",\n\t\t\t\"\t\t\tweightSum += sampleWeight;\",\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\tgl_FragColor = diffuseSum / weightSum;\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\t};\n\n\tTHREE.BlurShaderUtils = {\n\n\t\tcreateSampleWeights: function ( kernelRadius, stdDev ) {\n\n\t\t\tvar gaussian = function ( x, stdDev ) {\n\n\t\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * ( stdDev * stdDev ) ) ) / ( Math.sqrt( 2.0 * Math.PI ) * stdDev );\n\n\t\t\t};\n\n\t\t\tvar weights = [];\n\n\t\t\tfor ( var i = 0; i <= kernelRadius; i ++ ) {\n\n\t\t\t\tweights.push( gaussian( i, stdDev ) );\n\n\t\t\t}\n\n\t\t\treturn weights;\n\n\t\t},\n\n\t\tcreateSampleOffsets: function ( kernelRadius, uvIncrement ) {\n\n\t\t\tvar offsets = [];\n\n\t\t\tfor ( var i = 0; i <= kernelRadius; i ++ ) {\n\n\t\t\t\toffsets.push( uvIncrement.clone().multiplyScalar( i ) );\n\n\t\t\t}\n\n\t\t\treturn offsets;\n\n\t\t},\n\n\t\tconfigure: function ( material, kernelRadius, stdDev, uvIncrement ) {\n\n\t\t\tmaterial.defines[ \"KERNEL_RADIUS\" ] = kernelRadius;\n\t\t\tmaterial.uniforms[ \"sampleUvOffsets\" ].value = THREE.BlurShaderUtils.createSampleOffsets( kernelRadius, uvIncrement );\n\t\t\tmaterial.uniforms[ \"sampleWeights\" ].value = THREE.BlurShaderUtils.createSampleWeights( kernelRadius, stdDev );\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.DepthLimitedBlurShader;\n});\n\ndefine('skylark-threejs-ex/shaders/UnpackDepthRGBAShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Unpack RGBA depth shader\n\t * - show RGBA encoded depth as monochrome color\n\t */\n\n\tTHREE.UnpackDepthRGBAShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"opacity\": { value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"#include <packing>\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tfloat depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );\",\n\t\t\t\"\tgl_FragColor = vec4( vec3( depth ), opacity );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.UnpackDepthRGBAShader;\n});\n\ndefine('skylark-threejs-ex/shaders/ConvolutionShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Convolution shader\n\t * ported from o3d sample to WebGL / GLSL\n\t * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n\t */\n\n\tTHREE.ConvolutionShader = {\n\n\t\tdefines: {\n\n\t\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\n\t\t\t\"KERNEL_SIZE_INT\": \"25\"\n\n\t\t},\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"uImageIncrement\": { value: new THREE.Vector2( 0.001953125, 0.0 ) },\n\t\t\t\"cKernel\": { value: [] }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float cKernel[ KERNEL_SIZE_INT ];\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec2 imageCoord = vUv;\",\n\t\t\t\"\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\n\n\t\t\t\"\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\",\n\n\t\t\t\"\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\n\t\t\t\"\t\timageCoord += uImageIncrement;\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\tgl_FragColor = sum;\",\n\n\t\t\t\"}\"\n\n\n\t\t].join( \"\\n\" ),\n\n\t\tbuildKernel: function ( sigma ) {\n\n\t\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n\t\t\tfunction gauss( x, sigma ) {\n\n\t\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\n\n\t\t\t}\n\n\t\t\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\n\n\t\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\n\t\t\thalfWidth = ( kernelSize - 1 ) * 0.5;\n\n\t\t\tvalues = new Array( kernelSize );\n\t\t\tsum = 0.0;\n\t\t\tfor ( i = 0; i < kernelSize; ++ i ) {\n\n\t\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\n\t\t\t\tsum += values[ i ];\n\n\t\t\t}\n\n\t\t\t// normalize the kernel\n\n\t\t\tfor ( i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;\n\n\t\t\treturn values;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.ConvolutionShader;\n});\ndefine('skylark-threejs-ex/shaders/LuminosityHighPassShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author bhouston / http://clara.io/\n\t *\n\t * Luminosity\n\t * http://en.wikipedia.org/wiki/Luminosity\n\t */\n\n\tTHREE.LuminosityHighPassShader = {\n\n\t\tshaderID: \"luminosityHighPass\",\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"luminosityThreshold\": { value: 1.0 },\n\t\t\t\"smoothWidth\": { value: 1.0 },\n\t\t\t\"defaultColor\": { value: new THREE.Color( 0x000000 ) },\n\t\t\t\"defaultOpacity\": { value: 0.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform vec3 defaultColor;\",\n\t\t\t\"uniform float defaultOpacity;\",\n\t\t\t\"uniform float luminosityThreshold;\",\n\t\t\t\"uniform float smoothWidth;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 texel = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\",\n\n\t\t\t\"\tfloat v = dot( texel.xyz, luma );\",\n\n\t\t\t\"\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\",\n\n\t\t\t\"\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\",\n\n\t\t\t\"\tgl_FragColor = mix( outputColor, texel, alpha );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.LuminosityHighPassShader;\n});\n\ndefine('skylark-threejs-ex/shaders/FXAAShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author davidedc / http://www.sketchpatch.net/\n\t *\n\t * NVIDIA FXAA by Timothy Lottes\n\t * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\n\t * - WebGL port by @supereggbert\n\t * http://www.glge.org/demos/fxaa/\n\t */\n\n\tTHREE.FXAAShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"resolution\": { value: new THREE.Vector2( 1 / 1024, 1 / 512 ) }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\t\t\t\"precision highp float;\",\n\t\t\t\"\",\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"\",\n\t\t\t\"uniform vec2 resolution;\",\n\t\t\t\"\",\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"\",\n\t\t\t\"// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\",\n\t\t\t\"\",\n\t\t\t\"//----------------------------------------------------------------------------------\",\n\t\t\t\"// File:        es3-kepler\\FXAA\\assets\\shaders/FXAA_DefaultES.frag\",\n\t\t\t\"// SDK Version: v3.00\",\n\t\t\t\"// Email:       gameworks@nvidia.com\",\n\t\t\t\"// Site:        http://developer.nvidia.com/\",\n\t\t\t\"//\",\n\t\t\t\"// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\",\n\t\t\t\"//\",\n\t\t\t\"// Redistribution and use in source and binary forms, with or without\",\n\t\t\t\"// modification, are permitted provided that the following conditions\",\n\t\t\t\"// are met:\",\n\t\t\t\"//  * Redistributions of source code must retain the above copyright\",\n\t\t\t\"//    notice, this list of conditions and the following disclaimer.\",\n\t\t\t\"//  * Redistributions in binary form must reproduce the above copyright\",\n\t\t\t\"//    notice, this list of conditions and the following disclaimer in the\",\n\t\t\t\"//    documentation and/or other materials provided with the distribution.\",\n\t\t\t\"//  * Neither the name of NVIDIA CORPORATION nor the names of its\",\n\t\t\t\"//    contributors may be used to endorse or promote products derived\",\n\t\t\t\"//    from this software without specific prior written permission.\",\n\t\t\t\"//\",\n\t\t\t\"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\",\n\t\t\t\"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\",\n\t\t\t\"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\",\n\t\t\t\"// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\",\n\t\t\t\"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\",\n\t\t\t\"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\",\n\t\t\t\"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\",\n\t\t\t\"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\",\n\t\t\t\"// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\",\n\t\t\t\"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\",\n\t\t\t\"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\",\n\t\t\t\"//\",\n\t\t\t\"//----------------------------------------------------------------------------------\",\n\t\t\t\"\",\n\t\t\t\"#define FXAA_PC 1\",\n\t\t\t\"#define FXAA_GLSL_100 1\",\n\t\t\t\"#define FXAA_QUALITY_PRESET 12\",\n\t\t\t\"\",\n\t\t\t\"#define FXAA_GREEN_AS_LUMA 1\",\n\t\t\t\"\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_PC_CONSOLE\",\n\t\t\t\"    //\",\n\t\t\t\"    // The console algorithm for PC is included\",\n\t\t\t\"    // for developers targeting really low spec machines.\",\n\t\t\t\"    // Likely better to just run FXAA_PC, and use a really low preset.\",\n\t\t\t\"    //\",\n\t\t\t\"    #define FXAA_PC_CONSOLE 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_GLSL_120\",\n\t\t\t\"    #define FXAA_GLSL_120 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_GLSL_130\",\n\t\t\t\"    #define FXAA_GLSL_130 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_HLSL_3\",\n\t\t\t\"    #define FXAA_HLSL_3 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_HLSL_4\",\n\t\t\t\"    #define FXAA_HLSL_4 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_HLSL_5\",\n\t\t\t\"    #define FXAA_HLSL_5 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*==========================================================================*/\",\n\t\t\t\"#ifndef FXAA_GREEN_AS_LUMA\",\n\t\t\t\"    //\",\n\t\t\t\"    // For those using non-linear color,\",\n\t\t\t\"    // and either not able to get luma in alpha, or not wanting to,\",\n\t\t\t\"    // this enables FXAA to run using green as a proxy for luma.\",\n\t\t\t\"    // So with this enabled, no need to pack luma in alpha.\",\n\t\t\t\"    //\",\n\t\t\t\"    // This will turn off AA on anything which lacks some amount of green.\",\n\t\t\t\"    // Pure red and blue or combination of only R and B, will get no AA.\",\n\t\t\t\"    //\",\n\t\t\t\"    // Might want to lower the settings for both,\",\n\t\t\t\"    //    fxaaConsoleEdgeThresholdMin\",\n\t\t\t\"    //    fxaaQualityEdgeThresholdMin\",\n\t\t\t\"    // In order to insure AA does not get turned off on colors\",\n\t\t\t\"    // which contain a minor amount of green.\",\n\t\t\t\"    //\",\n\t\t\t\"    // 1 = On.\",\n\t\t\t\"    // 0 = Off.\",\n\t\t\t\"    //\",\n\t\t\t\"    #define FXAA_GREEN_AS_LUMA 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_EARLY_EXIT\",\n\t\t\t\"    //\",\n\t\t\t\"    // Controls algorithm's early exit path.\",\n\t\t\t\"    // On PS3 turning this ON adds 2 cycles to the shader.\",\n\t\t\t\"    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\",\n\t\t\t\"    // Turning this off on console will result in a more blurry image.\",\n\t\t\t\"    // So this defaults to on.\",\n\t\t\t\"    //\",\n\t\t\t\"    // 1 = On.\",\n\t\t\t\"    // 0 = Off.\",\n\t\t\t\"    //\",\n\t\t\t\"    #define FXAA_EARLY_EXIT 1\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_DISCARD\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only valid for PC OpenGL currently.\",\n\t\t\t\"    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\",\n\t\t\t\"    //\",\n\t\t\t\"    // 1 = Use discard on pixels which don't need AA.\",\n\t\t\t\"    //     For APIs which enable concurrent TEX+ROP from same surface.\",\n\t\t\t\"    // 0 = Return unchanged color on pixels which don't need AA.\",\n\t\t\t\"    //\",\n\t\t\t\"    #define FXAA_DISCARD 0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_FAST_PIXEL_OFFSET\",\n\t\t\t\"    //\",\n\t\t\t\"    // Used for GLSL 120 only.\",\n\t\t\t\"    //\",\n\t\t\t\"    // 1 = GL API supports fast pixel offsets\",\n\t\t\t\"    // 0 = do not use fast pixel offsets\",\n\t\t\t\"    //\",\n\t\t\t\"    #ifdef GL_EXT_gpu_shader4\",\n\t\t\t\"        #define FXAA_FAST_PIXEL_OFFSET 1\",\n\t\t\t\"    #endif\",\n\t\t\t\"    #ifdef GL_NV_gpu_shader5\",\n\t\t\t\"        #define FXAA_FAST_PIXEL_OFFSET 1\",\n\t\t\t\"    #endif\",\n\t\t\t\"    #ifdef GL_ARB_gpu_shader5\",\n\t\t\t\"        #define FXAA_FAST_PIXEL_OFFSET 1\",\n\t\t\t\"    #endif\",\n\t\t\t\"    #ifndef FXAA_FAST_PIXEL_OFFSET\",\n\t\t\t\"        #define FXAA_FAST_PIXEL_OFFSET 0\",\n\t\t\t\"    #endif\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#ifndef FXAA_GATHER4_ALPHA\",\n\t\t\t\"    //\",\n\t\t\t\"    // 1 = API supports gather4 on alpha channel.\",\n\t\t\t\"    // 0 = API does not support gather4 on alpha channel.\",\n\t\t\t\"    //\",\n\t\t\t\"    #if (FXAA_HLSL_5 == 1)\",\n\t\t\t\"        #define FXAA_GATHER4_ALPHA 1\",\n\t\t\t\"    #endif\",\n\t\t\t\"    #ifdef GL_ARB_gpu_shader5\",\n\t\t\t\"        #define FXAA_GATHER4_ALPHA 1\",\n\t\t\t\"    #endif\",\n\t\t\t\"    #ifdef GL_NV_gpu_shader5\",\n\t\t\t\"        #define FXAA_GATHER4_ALPHA 1\",\n\t\t\t\"    #endif\",\n\t\t\t\"    #ifndef FXAA_GATHER4_ALPHA\",\n\t\t\t\"        #define FXAA_GATHER4_ALPHA 0\",\n\t\t\t\"    #endif\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"                        FXAA QUALITY - TUNING KNOBS\",\n\t\t\t\"------------------------------------------------------------------------------\",\n\t\t\t\"NOTE the other tuning knobs are now in the shader function inputs!\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"#ifndef FXAA_QUALITY_PRESET\",\n\t\t\t\"    //\",\n\t\t\t\"    // Choose the quality preset.\",\n\t\t\t\"    // This needs to be compiled into the shader as it effects code.\",\n\t\t\t\"    // Best option to include multiple presets is to\",\n\t\t\t\"    // in each shader define the preset, then include this file.\",\n\t\t\t\"    //\",\n\t\t\t\"    // OPTIONS\",\n\t\t\t\"    // -----------------------------------------------------------------------\",\n\t\t\t\"    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\",\n\t\t\t\"    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\",\n\t\t\t\"    // 39       - no dither, very expensive\",\n\t\t\t\"    //\",\n\t\t\t\"    // NOTES\",\n\t\t\t\"    // -----------------------------------------------------------------------\",\n\t\t\t\"    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\",\n\t\t\t\"    // 13 = about same speed as FXAA 3.9 and better than 12\",\n\t\t\t\"    // 23 = closest to FXAA 3.9 visually and performance wise\",\n\t\t\t\"    //  _ = the lowest digit is directly related to performance\",\n\t\t\t\"    // _  = the highest digit is directly related to style\",\n\t\t\t\"    //\",\n\t\t\t\"    #define FXAA_QUALITY_PRESET 12\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"\",\n\t\t\t\"                           FXAA QUALITY - PRESETS\",\n\t\t\t\"\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"                     FXAA QUALITY - MEDIUM DITHER PRESETS\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 10)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 3\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P1 3.0\",\n\t\t\t\"    #define FXAA_QUALITY_P2 12.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 11)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 4\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 3.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 12.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 12)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 5\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 12.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 13)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 6\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 12.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 14)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 7\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 12.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 15)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 8\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P7 12.0\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"                     FXAA QUALITY - LOW DITHER PRESETS\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 20)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 3\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P1 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P2 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 21)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 4\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 22)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 5\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 23)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 6\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 24)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 7\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 3.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 25)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 8\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P7 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 26)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 9\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P7 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P8 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 27)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 10\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P7 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P8 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P9 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 28)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 11\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P7 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P8 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P9 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P10 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 29)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 12\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P6 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P7 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P8 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P9 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P10 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P11 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"                     FXAA QUALITY - EXTREME QUALITY\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"#if (FXAA_QUALITY_PRESET == 39)\",\n\t\t\t\"    #define FXAA_QUALITY_PS 12\",\n\t\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P1 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P2 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P3 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P4 1.0\",\n\t\t\t\"    #define FXAA_QUALITY_P5 1.5\",\n\t\t\t\"    #define FXAA_QUALITY_P6 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P7 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P8 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P9 2.0\",\n\t\t\t\"    #define FXAA_QUALITY_P10 4.0\",\n\t\t\t\"    #define FXAA_QUALITY_P11 8.0\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"\",\n\t\t\t\"                                API PORTING\",\n\t\t\t\"\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\",\n\t\t\t\"    #define FxaaBool bool\",\n\t\t\t\"    #define FxaaDiscard discard\",\n\t\t\t\"    #define FxaaFloat float\",\n\t\t\t\"    #define FxaaFloat2 vec2\",\n\t\t\t\"    #define FxaaFloat3 vec3\",\n\t\t\t\"    #define FxaaFloat4 vec4\",\n\t\t\t\"    #define FxaaHalf float\",\n\t\t\t\"    #define FxaaHalf2 vec2\",\n\t\t\t\"    #define FxaaHalf3 vec3\",\n\t\t\t\"    #define FxaaHalf4 vec4\",\n\t\t\t\"    #define FxaaInt2 ivec2\",\n\t\t\t\"    #define FxaaSat(x) clamp(x, 0.0, 1.0)\",\n\t\t\t\"    #define FxaaTex sampler2D\",\n\t\t\t\"#else\",\n\t\t\t\"    #define FxaaBool bool\",\n\t\t\t\"    #define FxaaDiscard clip(-1)\",\n\t\t\t\"    #define FxaaFloat float\",\n\t\t\t\"    #define FxaaFloat2 float2\",\n\t\t\t\"    #define FxaaFloat3 float3\",\n\t\t\t\"    #define FxaaFloat4 float4\",\n\t\t\t\"    #define FxaaHalf half\",\n\t\t\t\"    #define FxaaHalf2 half2\",\n\t\t\t\"    #define FxaaHalf3 half3\",\n\t\t\t\"    #define FxaaHalf4 half4\",\n\t\t\t\"    #define FxaaSat(x) saturate(x)\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_GLSL_100 == 1)\",\n\t\t\t\"  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\",\n\t\t\t\"  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_GLSL_120 == 1)\",\n\t\t\t\"    // Requires,\",\n\t\t\t\"    //  #version 120\",\n\t\t\t\"    // And at least,\",\n\t\t\t\"    //  #extension GL_EXT_gpu_shader4 : enable\",\n\t\t\t\"    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\",\n\t\t\t\"    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\",\n\t\t\t\"    #if (FXAA_FAST_PIXEL_OFFSET == 1)\",\n\t\t\t\"        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\",\n\t\t\t\"    #else\",\n\t\t\t\"        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\",\n\t\t\t\"    #endif\",\n\t\t\t\"    #if (FXAA_GATHER4_ALPHA == 1)\",\n\t\t\t\"        // use #extension GL_ARB_gpu_shader5 : enable\",\n\t\t\t\"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\",\n\t\t\t\"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\",\n\t\t\t\"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\",\n\t\t\t\"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\",\n\t\t\t\"    #endif\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_GLSL_130 == 1)\",\n\t\t\t\"    // Requires \\\"#version 130\\\" or better\",\n\t\t\t\"    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\",\n\t\t\t\"    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\",\n\t\t\t\"    #if (FXAA_GATHER4_ALPHA == 1)\",\n\t\t\t\"        // use #extension GL_ARB_gpu_shader5 : enable\",\n\t\t\t\"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\",\n\t\t\t\"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\",\n\t\t\t\"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\",\n\t\t\t\"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\",\n\t\t\t\"    #endif\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_HLSL_3 == 1)\",\n\t\t\t\"    #define FxaaInt2 float2\",\n\t\t\t\"    #define FxaaTex sampler2D\",\n\t\t\t\"    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\",\n\t\t\t\"    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_HLSL_4 == 1)\",\n\t\t\t\"    #define FxaaInt2 int2\",\n\t\t\t\"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\",\n\t\t\t\"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\",\n\t\t\t\"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\",\n\t\t\t\"#endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"#if (FXAA_HLSL_5 == 1)\",\n\t\t\t\"    #define FxaaInt2 int2\",\n\t\t\t\"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\",\n\t\t\t\"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\",\n\t\t\t\"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\",\n\t\t\t\"    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\",\n\t\t\t\"    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\",\n\t\t\t\"    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\",\n\t\t\t\"    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"                   GREEN AS LUMA OPTION SUPPORT FUNCTION\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"#if (FXAA_GREEN_AS_LUMA == 0)\",\n\t\t\t\"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\",\n\t\t\t\"#else\",\n\t\t\t\"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t\t\"/*============================================================================\",\n\t\t\t\"\",\n\t\t\t\"                             FXAA3 QUALITY - PC\",\n\t\t\t\"\",\n\t\t\t\"============================================================================*/\",\n\t\t\t\"#if (FXAA_PC == 1)\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"FxaaFloat4 FxaaPixelShader(\",\n\t\t\t\"    //\",\n\t\t\t\"    // Use noperspective interpolation here (turn off perspective interpolation).\",\n\t\t\t\"    // {xy} = center of pixel\",\n\t\t\t\"    FxaaFloat2 pos,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Used only for FXAA Console, and not used on the 360 version.\",\n\t\t\t\"    // Use noperspective interpolation here (turn off perspective interpolation).\",\n\t\t\t\"    // {xy_} = upper left of pixel\",\n\t\t\t\"    // {_zw} = lower right of pixel\",\n\t\t\t\"    FxaaFloat4 fxaaConsolePosPos,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Input color texture.\",\n\t\t\t\"    // {rgb_} = color in linear or perceptual color space\",\n\t\t\t\"    // if (FXAA_GREEN_AS_LUMA == 0)\",\n\t\t\t\"    //     {__a} = luma in perceptual color space (not linear)\",\n\t\t\t\"    FxaaTex tex,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on the optimized 360 version of FXAA Console.\",\n\t\t\t\"    // For everything but 360, just use the same input here as for \\\"tex\\\".\",\n\t\t\t\"    // For 360, same texture, just alias with a 2nd sampler.\",\n\t\t\t\"    // This sampler needs to have an exponent bias of -1.\",\n\t\t\t\"    FxaaTex fxaaConsole360TexExpBiasNegOne,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on the optimized 360 version of FXAA Console.\",\n\t\t\t\"    // For everything but 360, just use the same input here as for \\\"tex\\\".\",\n\t\t\t\"    // For 360, same texture, just alias with a 3nd sampler.\",\n\t\t\t\"    // This sampler needs to have an exponent bias of -2.\",\n\t\t\t\"    FxaaTex fxaaConsole360TexExpBiasNegTwo,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Quality.\",\n\t\t\t\"    // This must be from a constant/uniform.\",\n\t\t\t\"    // {x_} = 1.0/screenWidthInPixels\",\n\t\t\t\"    // {_y} = 1.0/screenHeightInPixels\",\n\t\t\t\"    FxaaFloat2 fxaaQualityRcpFrame,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Console.\",\n\t\t\t\"    // This must be from a constant/uniform.\",\n\t\t\t\"    // This effects sub-pixel AA quality and inversely sharpness.\",\n\t\t\t\"    //   Where N ranges between,\",\n\t\t\t\"    //     N = 0.50 (default)\",\n\t\t\t\"    //     N = 0.33 (sharper)\",\n\t\t\t\"    // {x__} = -N/screenWidthInPixels\",\n\t\t\t\"    // {_y_} = -N/screenHeightInPixels\",\n\t\t\t\"    // {_z_} =  N/screenWidthInPixels\",\n\t\t\t\"    // {__w} =  N/screenHeightInPixels\",\n\t\t\t\"    FxaaFloat4 fxaaConsoleRcpFrameOpt,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Console.\",\n\t\t\t\"    // Not used on 360, but used on PS3 and PC.\",\n\t\t\t\"    // This must be from a constant/uniform.\",\n\t\t\t\"    // {x__} = -2.0/screenWidthInPixels\",\n\t\t\t\"    // {_y_} = -2.0/screenHeightInPixels\",\n\t\t\t\"    // {_z_} =  2.0/screenWidthInPixels\",\n\t\t\t\"    // {__w} =  2.0/screenHeightInPixels\",\n\t\t\t\"    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Console.\",\n\t\t\t\"    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\",\n\t\t\t\"    // This must be from a constant/uniform.\",\n\t\t\t\"    // {x__} =  8.0/screenWidthInPixels\",\n\t\t\t\"    // {_y_} =  8.0/screenHeightInPixels\",\n\t\t\t\"    // {_z_} = -4.0/screenWidthInPixels\",\n\t\t\t\"    // {__w} = -4.0/screenHeightInPixels\",\n\t\t\t\"    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Quality.\",\n\t\t\t\"    // This used to be the FXAA_QUALITY_SUBPIX define.\",\n\t\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\t\"    // Choose the amount of sub-pixel aliasing removal.\",\n\t\t\t\"    // This can effect sharpness.\",\n\t\t\t\"    //   1.00 - upper limit (softer)\",\n\t\t\t\"    //   0.75 - default amount of filtering\",\n\t\t\t\"    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\",\n\t\t\t\"    //   0.25 - almost off\",\n\t\t\t\"    //   0.00 - completely off\",\n\t\t\t\"    FxaaFloat fxaaQualitySubpix,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Quality.\",\n\t\t\t\"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\",\n\t\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\t\"    // The minimum amount of local contrast required to apply algorithm.\",\n\t\t\t\"    //   0.333 - too little (faster)\",\n\t\t\t\"    //   0.250 - low quality\",\n\t\t\t\"    //   0.166 - default\",\n\t\t\t\"    //   0.125 - high quality\",\n\t\t\t\"    //   0.063 - overkill (slower)\",\n\t\t\t\"    FxaaFloat fxaaQualityEdgeThreshold,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Quality.\",\n\t\t\t\"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\",\n\t\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\t\"    // Trims the algorithm from processing darks.\",\n\t\t\t\"    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\",\n\t\t\t\"    //   0.0625 - high quality (faster)\",\n\t\t\t\"    //   0.0312 - visible limit (slower)\",\n\t\t\t\"    // Special notes when using FXAA_GREEN_AS_LUMA,\",\n\t\t\t\"    //   Likely want to set this to zero.\",\n\t\t\t\"    //   As colors that are mostly not-green\",\n\t\t\t\"    //   will appear very dark in the green channel!\",\n\t\t\t\"    //   Tune by looking at mostly non-green content,\",\n\t\t\t\"    //   then start at zero and increase until aliasing is a problem.\",\n\t\t\t\"    FxaaFloat fxaaQualityEdgeThresholdMin,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Console.\",\n\t\t\t\"    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\",\n\t\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\t\"    // This does not effect PS3, as this needs to be compiled in.\",\n\t\t\t\"    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\",\n\t\t\t\"    //   Due to the PS3 being ALU bound,\",\n\t\t\t\"    //   there are only three safe values here: 2 and 4 and 8.\",\n\t\t\t\"    //   These options use the shaders ability to a free *|/ by 2|4|8.\",\n\t\t\t\"    // For all other platforms can be a non-power of two.\",\n\t\t\t\"    //   8.0 is sharper (default!!!)\",\n\t\t\t\"    //   4.0 is softer\",\n\t\t\t\"    //   2.0 is really soft (good only for vector graphics inputs)\",\n\t\t\t\"    FxaaFloat fxaaConsoleEdgeSharpness,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Console.\",\n\t\t\t\"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\",\n\t\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\t\"    // This does not effect PS3, as this needs to be compiled in.\",\n\t\t\t\"    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\",\n\t\t\t\"    //   Due to the PS3 being ALU bound,\",\n\t\t\t\"    //   there are only two safe values here: 1/4 and 1/8.\",\n\t\t\t\"    //   These options use the shaders ability to a free *|/ by 2|4|8.\",\n\t\t\t\"    // The console setting has a different mapping than the quality setting.\",\n\t\t\t\"    // Other platforms can use other values.\",\n\t\t\t\"    //   0.125 leaves less aliasing, but is softer (default!!!)\",\n\t\t\t\"    //   0.25 leaves more aliasing, and is sharper\",\n\t\t\t\"    FxaaFloat fxaaConsoleEdgeThreshold,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Only used on FXAA Console.\",\n\t\t\t\"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\",\n\t\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\t\"    // Trims the algorithm from processing darks.\",\n\t\t\t\"    // The console setting has a different mapping than the quality setting.\",\n\t\t\t\"    // This only applies when FXAA_EARLY_EXIT is 1.\",\n\t\t\t\"    // This does not apply to PS3,\",\n\t\t\t\"    // PS3 was simplified to avoid more shader instructions.\",\n\t\t\t\"    //   0.06 - faster but more aliasing in darks\",\n\t\t\t\"    //   0.05 - default\",\n\t\t\t\"    //   0.04 - slower and less aliasing in darks\",\n\t\t\t\"    // Special notes when using FXAA_GREEN_AS_LUMA,\",\n\t\t\t\"    //   Likely want to set this to zero.\",\n\t\t\t\"    //   As colors that are mostly not-green\",\n\t\t\t\"    //   will appear very dark in the green channel!\",\n\t\t\t\"    //   Tune by looking at mostly non-green content,\",\n\t\t\t\"    //   then start at zero and increase until aliasing is a problem.\",\n\t\t\t\"    FxaaFloat fxaaConsoleEdgeThresholdMin,\",\n\t\t\t\"    //\",\n\t\t\t\"    // Extra constants for 360 FXAA Console only.\",\n\t\t\t\"    // Use zeros or anything else for other platforms.\",\n\t\t\t\"    // These must be in physical constant registers and NOT immediates.\",\n\t\t\t\"    // Immediates will result in compiler un-optimizing.\",\n\t\t\t\"    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\",\n\t\t\t\"    FxaaFloat4 fxaaConsole360ConstDir\",\n\t\t\t\") {\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat2 posM;\",\n\t\t\t\"    posM.x = pos.x;\",\n\t\t\t\"    posM.y = pos.y;\",\n\t\t\t\"    #if (FXAA_GATHER4_ALPHA == 1)\",\n\t\t\t\"        #if (FXAA_DISCARD == 0)\",\n\t\t\t\"            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\",\n\t\t\t\"            #if (FXAA_GREEN_AS_LUMA == 0)\",\n\t\t\t\"                #define lumaM rgbyM.w\",\n\t\t\t\"            #else\",\n\t\t\t\"                #define lumaM rgbyM.y\",\n\t\t\t\"            #endif\",\n\t\t\t\"        #endif\",\n\t\t\t\"        #if (FXAA_GREEN_AS_LUMA == 0)\",\n\t\t\t\"            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\",\n\t\t\t\"            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\",\n\t\t\t\"        #else\",\n\t\t\t\"            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\",\n\t\t\t\"            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\",\n\t\t\t\"        #endif\",\n\t\t\t\"        #if (FXAA_DISCARD == 1)\",\n\t\t\t\"            #define lumaM luma4A.w\",\n\t\t\t\"        #endif\",\n\t\t\t\"        #define lumaE luma4A.z\",\n\t\t\t\"        #define lumaS luma4A.x\",\n\t\t\t\"        #define lumaSE luma4A.y\",\n\t\t\t\"        #define lumaNW luma4B.w\",\n\t\t\t\"        #define lumaN luma4B.z\",\n\t\t\t\"        #define lumaW luma4B.x\",\n\t\t\t\"    #else\",\n\t\t\t\"        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\",\n\t\t\t\"        #if (FXAA_GREEN_AS_LUMA == 0)\",\n\t\t\t\"            #define lumaM rgbyM.w\",\n\t\t\t\"        #else\",\n\t\t\t\"            #define lumaM rgbyM.y\",\n\t\t\t\"        #endif\",\n\t\t\t\"        #if (FXAA_GLSL_100 == 1)\",\n\t\t\t\"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"        #else\",\n\t\t\t\"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"        #endif\",\n\t\t\t\"    #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat maxSM = max(lumaS, lumaM);\",\n\t\t\t\"    FxaaFloat minSM = min(lumaS, lumaM);\",\n\t\t\t\"    FxaaFloat maxESM = max(lumaE, maxSM);\",\n\t\t\t\"    FxaaFloat minESM = min(lumaE, minSM);\",\n\t\t\t\"    FxaaFloat maxWN = max(lumaN, lumaW);\",\n\t\t\t\"    FxaaFloat minWN = min(lumaN, lumaW);\",\n\t\t\t\"    FxaaFloat rangeMax = max(maxWN, maxESM);\",\n\t\t\t\"    FxaaFloat rangeMin = min(minWN, minESM);\",\n\t\t\t\"    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\",\n\t\t\t\"    FxaaFloat range = rangeMax - rangeMin;\",\n\t\t\t\"    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\",\n\t\t\t\"    FxaaBool earlyExit = range < rangeMaxClamped;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    if(earlyExit)\",\n\t\t\t\"        #if (FXAA_DISCARD == 1)\",\n\t\t\t\"            FxaaDiscard;\",\n\t\t\t\"        #else\",\n\t\t\t\"            return rgbyM;\",\n\t\t\t\"        #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    #if (FXAA_GATHER4_ALPHA == 0)\",\n\t\t\t\"        #if (FXAA_GLSL_100 == 1)\",\n\t\t\t\"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"        #else\",\n\t\t\t\"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"        #endif\",\n\t\t\t\"    #else\",\n\t\t\t\"        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\",\n\t\t\t\"    #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat lumaNS = lumaN + lumaS;\",\n\t\t\t\"    FxaaFloat lumaWE = lumaW + lumaE;\",\n\t\t\t\"    FxaaFloat subpixRcpRange = 1.0/range;\",\n\t\t\t\"    FxaaFloat subpixNSWE = lumaNS + lumaWE;\",\n\t\t\t\"    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\",\n\t\t\t\"    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat lumaNESE = lumaNE + lumaSE;\",\n\t\t\t\"    FxaaFloat lumaNWNE = lumaNW + lumaNE;\",\n\t\t\t\"    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\",\n\t\t\t\"    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat lumaNWSW = lumaNW + lumaSW;\",\n\t\t\t\"    FxaaFloat lumaSWSE = lumaSW + lumaSE;\",\n\t\t\t\"    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\",\n\t\t\t\"    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\",\n\t\t\t\"    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\",\n\t\t\t\"    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\",\n\t\t\t\"    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\",\n\t\t\t\"    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\",\n\t\t\t\"    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\",\n\t\t\t\"    FxaaBool horzSpan = edgeHorz >= edgeVert;\",\n\t\t\t\"    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    if(!horzSpan) lumaN = lumaW;\",\n\t\t\t\"    if(!horzSpan) lumaS = lumaE;\",\n\t\t\t\"    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\",\n\t\t\t\"    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat gradientN = lumaN - lumaM;\",\n\t\t\t\"    FxaaFloat gradientS = lumaS - lumaM;\",\n\t\t\t\"    FxaaFloat lumaNN = lumaN + lumaM;\",\n\t\t\t\"    FxaaFloat lumaSS = lumaS + lumaM;\",\n\t\t\t\"    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\",\n\t\t\t\"    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\",\n\t\t\t\"    if(pairN) lengthSign = -lengthSign;\",\n\t\t\t\"    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat2 posB;\",\n\t\t\t\"    posB.x = posM.x;\",\n\t\t\t\"    posB.y = posM.y;\",\n\t\t\t\"    FxaaFloat2 offNP;\",\n\t\t\t\"    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\",\n\t\t\t\"    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\",\n\t\t\t\"    if(!horzSpan) posB.x += lengthSign * 0.5;\",\n\t\t\t\"    if( horzSpan) posB.y += lengthSign * 0.5;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat2 posN;\",\n\t\t\t\"    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\",\n\t\t\t\"    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\",\n\t\t\t\"    FxaaFloat2 posP;\",\n\t\t\t\"    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\",\n\t\t\t\"    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\",\n\t\t\t\"    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\",\n\t\t\t\"    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\",\n\t\t\t\"    FxaaFloat subpixE = subpixC * subpixC;\",\n\t\t\t\"    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    if(!pairN) lumaNN = lumaSS;\",\n\t\t\t\"    FxaaFloat gradientScaled = gradient * 1.0/4.0;\",\n\t\t\t\"    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\",\n\t\t\t\"    FxaaFloat subpixF = subpixD * subpixE;\",\n\t\t\t\"    FxaaBool lumaMLTZero = lumaMM < 0.0;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    lumaEndN -= lumaNN * 0.5;\",\n\t\t\t\"    lumaEndP -= lumaNN * 0.5;\",\n\t\t\t\"    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\",\n\t\t\t\"    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\",\n\t\t\t\"    FxaaBool doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\",\n\t\t\t\"    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    if(doneNP) {\",\n\t\t\t\"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"        doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"        doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\",\n\t\t\t\"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\",\n\t\t\t\"        doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\",\n\t\t\t\"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"        #if (FXAA_QUALITY_PS > 3)\",\n\t\t\t\"        if(doneNP) {\",\n\t\t\t\"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"            doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"            doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\",\n\t\t\t\"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\",\n\t\t\t\"            doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\",\n\t\t\t\"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"            #if (FXAA_QUALITY_PS > 4)\",\n\t\t\t\"            if(doneNP) {\",\n\t\t\t\"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"                doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"                doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\",\n\t\t\t\"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\",\n\t\t\t\"                doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\",\n\t\t\t\"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                #if (FXAA_QUALITY_PS > 5)\",\n\t\t\t\"                if(doneNP) {\",\n\t\t\t\"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"                    doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"                    doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\",\n\t\t\t\"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\",\n\t\t\t\"                    doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\",\n\t\t\t\"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                    #if (FXAA_QUALITY_PS > 6)\",\n\t\t\t\"                    if(doneNP) {\",\n\t\t\t\"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"                        doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"                        doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\",\n\t\t\t\"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\",\n\t\t\t\"                        doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\",\n\t\t\t\"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                        #if (FXAA_QUALITY_PS > 7)\",\n\t\t\t\"                        if(doneNP) {\",\n\t\t\t\"                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"                            doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"                            doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\",\n\t\t\t\"                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\",\n\t\t\t\"                            doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\",\n\t\t\t\"                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    #if (FXAA_QUALITY_PS > 8)\",\n\t\t\t\"    if(doneNP) {\",\n\t\t\t\"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"        doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"        doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\",\n\t\t\t\"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\",\n\t\t\t\"        doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\",\n\t\t\t\"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"        #if (FXAA_QUALITY_PS > 9)\",\n\t\t\t\"        if(doneNP) {\",\n\t\t\t\"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"            doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"            doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\",\n\t\t\t\"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\",\n\t\t\t\"            doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\",\n\t\t\t\"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"            #if (FXAA_QUALITY_PS > 10)\",\n\t\t\t\"            if(doneNP) {\",\n\t\t\t\"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"                doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"                doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\",\n\t\t\t\"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\",\n\t\t\t\"                doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\",\n\t\t\t\"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                #if (FXAA_QUALITY_PS > 11)\",\n\t\t\t\"                if(doneNP) {\",\n\t\t\t\"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"                    doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"                    doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\",\n\t\t\t\"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\",\n\t\t\t\"                    doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\",\n\t\t\t\"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                    #if (FXAA_QUALITY_PS > 12)\",\n\t\t\t\"                    if(doneNP) {\",\n\t\t\t\"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\t\"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\t\"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\t\"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\t\"                        doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\t\"                        doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\t\"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\",\n\t\t\t\"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\",\n\t\t\t\"                        doneNP = (!doneN) || (!doneP);\",\n\t\t\t\"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\",\n\t\t\t\"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                    }\",\n\t\t\t\"                    #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                }\",\n\t\t\t\"                #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"            }\",\n\t\t\t\"            #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"        }\",\n\t\t\t\"        #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    }\",\n\t\t\t\"    #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                        }\",\n\t\t\t\"                        #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                    }\",\n\t\t\t\"                    #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"                }\",\n\t\t\t\"                #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"            }\",\n\t\t\t\"            #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"        }\",\n\t\t\t\"        #endif\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    }\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat dstN = posM.x - posN.x;\",\n\t\t\t\"    FxaaFloat dstP = posP.x - posM.x;\",\n\t\t\t\"    if(!horzSpan) dstN = posM.y - posN.y;\",\n\t\t\t\"    if(!horzSpan) dstP = posP.y - posM.y;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\",\n\t\t\t\"    FxaaFloat spanLength = (dstP + dstN);\",\n\t\t\t\"    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\",\n\t\t\t\"    FxaaFloat spanLengthRcp = 1.0/spanLength;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaBool directionN = dstN < dstP;\",\n\t\t\t\"    FxaaFloat dst = min(dstN, dstP);\",\n\t\t\t\"    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\",\n\t\t\t\"    FxaaFloat subpixG = subpixF * subpixF;\",\n\t\t\t\"    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\",\n\t\t\t\"    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\",\n\t\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\t\"    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\",\n\t\t\t\"    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\",\n\t\t\t\"    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\",\n\t\t\t\"    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\",\n\t\t\t\"    #if (FXAA_DISCARD == 1)\",\n\t\t\t\"        return FxaaTexTop(tex, posM);\",\n\t\t\t\"    #else\",\n\t\t\t\"        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\",\n\t\t\t\"    #endif\",\n\t\t\t\"}\",\n\t\t\t\"/*==========================================================================*/\",\n\t\t\t\"#endif\",\n\t\t\t\"\",\n\t\t\t\"void main() {\",\n\t\t\t\"  gl_FragColor = FxaaPixelShader(\",\n\t\t\t\"    vUv,\",\n\t\t\t\"    vec4(0.0),\",\n\t\t\t\"    tDiffuse,\",\n\t\t\t\"    tDiffuse,\",\n\t\t\t\"    tDiffuse,\",\n\t\t\t\"    resolution,\",\n\t\t\t\"    vec4(0.0),\",\n\t\t\t\"    vec4(0.0),\",\n\t\t\t\"    vec4(0.0),\",\n\t\t\t\"    0.75,\",\n\t\t\t\"    0.166,\",\n\t\t\t\"    0.0833,\",\n\t\t\t\"    0.0,\",\n\t\t\t\"    0.0,\",\n\t\t\t\"    0.0,\",\n\t\t\t\"    vec4(0.0)\",\n\t\t\t\"  );\",\n\t\t\t\"\",\n\t\t\t\"  // TODO avoid querying texture twice for same texel\",\n\t\t\t\"  gl_FragColor.a = texture2D(tDiffuse, vUv).a;\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.FXAAShader;\n});\n\ndefine('skylark-threejs-ex/shaders/SSAOShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * References:\n\t * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n\t * https://learnopengl.com/Advanced-Lighting/SSAO\n\t * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n\t */\n\n\tTHREE.SSAOShader = {\n\n\t\tdefines: {\n\t\t\t\"PERSPECTIVE_CAMERA\": 1,\n\t\t\t\"KERNEL_SIZE\": 32\n\t\t},\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"tNormal\": { value: null },\n\t\t\t\"tDepth\": { value: null },\n\t\t\t\"tNoise\": { value: null },\n\t\t\t\"kernel\": { value: null },\n\t\t\t\"cameraNear\": { value: null },\n\t\t\t\"cameraFar\": { value: null },\n\t\t\t\"resolution\": { value: new THREE.Vector2() },\n\t\t\t\"cameraProjectionMatrix\": { value: new THREE.Matrix4() },\n\t\t\t\"cameraInverseProjectionMatrix\": { value: new THREE.Matrix4() },\n\t\t\t\"kernelRadius\": { value: 8 },\n\t\t\t\"minDistance\": { value: 0.005 },\n\t\t\t\"maxDistance\": { value: 0.05 },\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform sampler2D tNormal;\",\n\t\t\t\"uniform sampler2D tDepth;\",\n\t\t\t\"uniform sampler2D tNoise;\",\n\n\t\t\t\"uniform vec3 kernel[ KERNEL_SIZE ];\",\n\n\t\t\t\"uniform vec2 resolution;\",\n\n\t\t\t\"uniform float cameraNear;\",\n\t\t\t\"uniform float cameraFar;\",\n\t\t\t\"uniform mat4 cameraProjectionMatrix;\",\n\t\t\t\"uniform mat4 cameraInverseProjectionMatrix;\",\n\n\t\t\t\"uniform float kernelRadius;\",\n\t\t\t\"uniform float minDistance;\", // avoid artifacts caused by neighbour fragments with minimal depth difference\n\t\t\t\"uniform float maxDistance;\", // avoid the influence of fragments which are too far away\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"#include <packing>\",\n\n\t\t\t\"float getDepth( const in vec2 screenPosition ) {\",\n\n\t\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"float getLinearDepth( const in vec2 screenPosition ) {\",\n\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\n\t\t\t\"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\",\n\t\t\t\"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\",\n\t\t\t\"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\",\n\n\t\t\t\"\t#else\",\n\n\t\t\t\"\t\treturn texture2D( depthSampler, coord ).x;\",\n\n\t\t\t\"\t#endif\",\n\n\t\t\t\"}\",\n\n\t\t\t\"float getViewZ( const in float depth ) {\",\n\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\n\t\t\t\"\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n\n\t\t\t\"\t#else\",\n\n\t\t\t\"\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n\n\t\t\t\"\t#endif\",\n\n\t\t\t\"}\",\n\n\t\t\t\"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\",\n\n\t\t\t\"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\",\n\n\t\t\t\"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\",\n\n\t\t\t\"\tclipPosition *= clipW; // unprojection.\",\n\n\t\t\t\"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"vec3 getViewNormal( const in vec2 screenPosition ) {\",\n\n\t\t\t\"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tfloat depth = getDepth( vUv );\",\n\t\t\t\"\tfloat viewZ = getViewZ( depth );\",\n\n\t\t\t\"\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\",\n\t\t\t\"\tvec3 viewNormal = getViewNormal( vUv );\",\n\n\t\t\t\" vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\",\n\t\t\t\"\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\",\n\n\t\t\t// compute matrix used to reorient a kernel vector\n\n\t\t\t\"\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\",\n\t\t\t\"\tvec3 bitangent = cross( viewNormal, tangent );\",\n\t\t\t\"\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\",\n\n\t\t\t\" float occlusion = 0.0;\",\n\n\t\t\t\" for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\",\n\n\t\t\t\"\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];\", // reorient sample vector in view space\n\t\t\t\"\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );\", // calculate sample point\n\n\t\t\t\"\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\", // project point and calculate NDC\n\t\t\t\"\t\tsamplePointNDC /= samplePointNDC.w;\",\n\n\t\t\t\"\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\", // compute uv coordinates\n\n\t\t\t\"\t\tfloat realDepth = getLinearDepth( samplePointUv );\", // get linear depth from depth texture\n\t\t\t\"\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\", // compute linear depth of the sample view Z value\n\t\t\t\"\t\tfloat delta = sampleDepth - realDepth;\",\n\n\t\t\t\"\t\tif ( delta > minDistance && delta < maxDistance ) {\", // if fragment is before sample point, increase occlusion\n\n\t\t\t\"\t\t\tocclusion += 1.0;\",\n\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\",\n\n\t\t\t\"\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n\tTHREE.SSAODepthShader = {\n\n\t\tdefines: {\n\t\t\t\"PERSPECTIVE_CAMERA\": 1\n\t\t},\n\n\t\tuniforms: {\n\n\t\t\t\"tDepth\": { value: null },\n\t\t\t\"cameraNear\": { value: null },\n\t\t\t\"cameraFar\": { value: null },\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\t\"uniform float cameraNear;\",\n\t\t\t\"uniform float cameraFar;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"#include <packing>\",\n\n\t\t\t\"float getLinearDepth( const in vec2 screenPosition ) {\",\n\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\n\t\t\t\"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\",\n\t\t\t\"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\",\n\t\t\t\"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\",\n\n\t\t\t\"\t#else\",\n\n\t\t\t\"\t\treturn texture2D( depthSampler, coord ).x;\",\n\n\t\t\t\"\t#endif\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tfloat depth = getLinearDepth( vUv );\",\n\t\t\t\"\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n\tTHREE.SSAOBlurShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"resolution\": { value: new THREE.Vector2() }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"uniform vec2 resolution;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec2 texelSize = ( 1.0 / resolution );\",\n\t\t\t\"\tfloat result = 0.0;\",\n\n\t\t\t\"\tfor ( int i = - 2; i <= 2; i ++ ) {\",\n\n\t\t\t\"\t\tfor ( int j = - 2; j <= 2; j ++ ) {\",\n\n\t\t\t\"\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\",\n\t\t\t\"\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\",\n\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.SSAOShader;\n});\n\ndefine('skylark-threejs-ex/shaders/FilmShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Film grain & scanlines shader\n\t *\n\t * - ported from HLSL to WebGL / GLSL\n\t * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n\t *\n\t * Screen Space Static Postprocessor\n\t *\n\t * Produces an analogue noise overlay similar to a film grain / TV static\n\t *\n\t * Original implementation and noise algorithm\n\t * Pat 'Hawthorne' Shearon\n\t *\n\t * Optimized scanlines + noise version with intensity scaling\n\t * Georg 'Leviathan' Steinrohder\n\t *\n\t * This version is provided under a Creative Commons Attribution 3.0 License\n\t * http://creativecommons.org/licenses/by/3.0/\n\t */\n\n\tTHREE.FilmShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"time\": { value: 0.0 },\n\t\t\t\"nIntensity\": { value: 0.5 },\n\t\t\t\"sIntensity\": { value: 0.05 },\n\t\t\t\"sCount\": { value: 4096 },\n\t\t\t\"grayscale\": { value: 1 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"#include <common>\",\n\n\t\t\t// control parameter\n\t\t\t\"uniform float time;\",\n\n\t\t\t\"uniform bool grayscale;\",\n\n\t\t\t// noise effect intensity value (0 = no effect, 1 = full effect)\n\t\t\t\"uniform float nIntensity;\",\n\n\t\t\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\n\t\t\t\"uniform float sIntensity;\",\n\n\t\t\t// scanlines effect count value (0 = no effect, 4096 = full effect)\n\t\t\t\"uniform float sCount;\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t// sample the source\n\t\t\t\"\tvec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\n\n\t\t\t// make some noise\n\t\t\t\"\tfloat dx = rand( vUv + time );\",\n\n\t\t\t// add noise\n\t\t\t\"\tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\",\n\n\t\t\t// get us a sine and cosine\n\t\t\t\"\tvec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\",\n\n\t\t\t// add scanlines\n\t\t\t\"\tcResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\",\n\n\t\t\t// interpolate between source and result by intensity\n\t\t\t\"\tcResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\",\n\n\t\t\t// convert to grayscale if desired\n\t\t\t\"\tif( grayscale ) {\",\n\n\t\t\t\"\t\tcResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\tgl_FragColor =  vec4( cResult, cTextureScreen.a );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.FilmShader;\n});\n\ndefine('skylark-threejs-ex/shaders/DotScreenShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Dot screen shader\n\t * based on glfx.js sepia shader\n\t * https://github.com/evanw/glfx.js\n\t */\n\n\tTHREE.DotScreenShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"tSize\": { value: new THREE.Vector2( 256, 256 ) },\n\t\t\t\"center\": { value: new THREE.Vector2( 0.5, 0.5 ) },\n\t\t\t\"angle\": { value: 1.57 },\n\t\t\t\"scale\": { value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec2 center;\",\n\t\t\t\"uniform float angle;\",\n\t\t\t\"uniform float scale;\",\n\t\t\t\"uniform vec2 tSize;\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"float pattern() {\",\n\n\t\t\t\"\tfloat s = sin( angle ), c = cos( angle );\",\n\n\t\t\t\"\tvec2 tex = vUv * tSize - center;\",\n\t\t\t\"\tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\",\n\n\t\t\t\"\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 color = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"\tfloat average = ( color.r + color.g + color.b ) / 3.0;\",\n\n\t\t\t\"\tgl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.DotScreenShader;\n});\n\ndefine('skylark-threejs-ex/shaders/LuminosityShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Luminosity\n\t * http://en.wikipedia.org/wiki/Luminosity\n\t */\n\n\tTHREE.LuminosityShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"#include <common>\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 texel = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"\tfloat l = linearToRelativeLuminance( texel.rgb );\",\n\n\t\t\t\"\tgl_FragColor = vec4( l, l, l, texel.w );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.LuminosityShader;\n});\ndefine('skylark-threejs-ex/shaders/SobelOperatorShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\n\t *\n\t * As mentioned in the video the Sobel operator expects a grayscale image as input.\n\t *\n\t */\n\n\tTHREE.SobelOperatorShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"resolution\": { value: new THREE.Vector2() }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform vec2 resolution;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );\",\n\n\t\t\t// kernel definition (in glsl matrices are filled in column-major order)\n\n\t\t\t\"\tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );\", // x direction kernel\n\t\t\t\"\tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );\", // y direction kernel\n\n\t\t\t// fetch the 3x3 neighbourhood of a fragment\n\n\t\t\t// first column\n\n\t\t\t\"\tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;\",\n\t\t\t\"\tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;\",\n\t\t\t\"\tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;\",\n\n\t\t\t// second column\n\n\t\t\t\"\tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;\",\n\t\t\t\"\tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;\",\n\t\t\t\"\tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;\",\n\n\t\t\t// third column\n\n\t\t\t\"\tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;\",\n\t\t\t\"\tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;\",\n\t\t\t\"\tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;\",\n\n\t\t\t// gradient value in x direction\n\n\t\t\t\"\tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + \",\n\t\t\t\"\t\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + \",\n\t\t\t\"\t\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; \",\n\n\t\t\t// gradient value in y direction\n\n\t\t\t\"\tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + \",\n\t\t\t\"\t\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + \",\n\t\t\t\"\t\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; \",\n\n\t\t\t// magnitute of the total gradient\n\n\t\t\t\"\tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );\",\n\n\t\t\t\"\tgl_FragColor = vec4( vec3( G ), 1 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.SobelOperatorShader;\n});\n\ndefine('skylark-threejs-ex/shaders/ColorifyShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Colorify shader\n\t */\n\n\tTHREE.ColorifyShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"color\": { value: new THREE.Color( 0xffffff ) }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 color;\",\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 texel = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\",\n\t\t\t\"\tfloat v = dot( texel.xyz, luma );\",\n\n\t\t\t\"\tgl_FragColor = vec4( v * color, texel.w );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.ColorifyShader;\n});\n\ndefine('skylark-threejs-ex/shaders/ToneMapShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author miibond\n\t *\n\t * Full-screen tone-mapping shader based on http://www.cis.rit.edu/people/faculty/ferwerda/publications/sig02_paper.pdf\n\t */\n\n\tTHREE.ToneMapShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"averageLuminance\": { value: 1.0 },\n\t\t\t\"luminanceMap\": { value: null },\n\t\t\t\"maxLuminance\": { value: 16.0 },\n\t\t\t\"minLuminance\": { value: 0.01 },\n\t\t\t\"middleGrey\": { value: 0.6 }\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"#include <common>\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform float middleGrey;\",\n\t\t\t\"uniform float minLuminance;\",\n\t\t\t\"uniform float maxLuminance;\",\n\t\t\t\"#ifdef ADAPTED_LUMINANCE\",\n\t\t\t\"\tuniform sampler2D luminanceMap;\",\n\t\t\t\"#else\",\n\t\t\t\"\tuniform float averageLuminance;\",\n\t\t\t\"#endif\",\n\n\t\t\t\"vec3 ToneMap( vec3 vColor ) {\",\n\t\t\t\"\t#ifdef ADAPTED_LUMINANCE\",\n\t\t\t// Get the calculated average luminance\n\t\t\t\"\t\tfloat fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;\",\n\t\t\t\"\t#else\",\n\t\t\t\"\t\tfloat fLumAvg = averageLuminance;\",\n\t\t\t\"\t#endif\",\n\n\t\t\t// Calculate the luminance of the current pixel\n\t\t\t\"\tfloat fLumPixel = linearToRelativeLuminance( vColor );\",\n\n\t\t\t// Apply the modified operator (Eq. 4)\n\t\t\t\"\tfloat fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );\",\n\n\t\t\t\"\tfloat fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);\",\n\t\t\t\"\treturn fLumCompressed * vColor;\",\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 texel = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"\tgl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.ToneMapShader;\n});\n\ndefine('skylark-threejs-ex/shaders/TechnicolorShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author flimshaw / http://charliehoey.com\n\t *\n\t * Technicolor Shader\n\t * Simulates the look of the two-strip technicolor process popular in early 20th century films.\n\t * More historical info here: http://www.widescreenmuseum.com/oldcolor/technicolor1.htm\n\t * Demo here: http://charliehoey.com/technicolor_shader/shader_test.html\n\t */\n\n\tTHREE.TechnicolorShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );\",\n\t\t\t\"\tvec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);\",\n\n\t\t\t\"\tgl_FragColor = newTex;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.TechnicolorShader;\n});\n\ndefine('skylark-threejs-ex/shaders/HueSaturationShader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author tapio / http://tapio.github.com/\n\t *\n\t * Hue and saturation adjustment\n\t * https://github.com/evanw/glfx.js\n\t * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.\n\t * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n\t */\n\n\tTHREE.HueSaturationShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"hue\": { value: 0 },\n\t\t\t\"saturation\": { value: 0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform float hue;\",\n\t\t\t\"uniform float saturation;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tgl_FragColor = texture2D( tDiffuse, vUv );\",\n\n\t\t\t// hue\n\t\t\t\"\tfloat angle = hue * 3.14159265;\",\n\t\t\t\"\tfloat s = sin(angle), c = cos(angle);\",\n\t\t\t\"\tvec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\",\n\t\t\t\"\tfloat len = length(gl_FragColor.rgb);\",\n\t\t\t\"\tgl_FragColor.rgb = vec3(\",\n\t\t\t\"\t\tdot(gl_FragColor.rgb, weights.xyz),\",\n\t\t\t\"\t\tdot(gl_FragColor.rgb, weights.zxy),\",\n\t\t\t\"\t\tdot(gl_FragColor.rgb, weights.yzx)\",\n\t\t\t\"\t);\",\n\n\t\t\t// saturation\n\t\t\t\"\tfloat average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\",\n\t\t\t\"\tif (saturation > 0.0) {\",\n\t\t\t\"\t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));\",\n\t\t\t\"\t} else {\",\n\t\t\t\"\t\tgl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);\",\n\t\t\t\"\t}\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.HueSaturationShader;\n});\n\ndefine('skylark-threejs-ex/postprocessing/Pass',[\r\n\t\"skylark-threejs\"\r\n],function(THREE){\r\n\tTHREE.Pass = function () {\r\n\r\n\t\t// if set to true, the pass is processed by the composer\r\n\t\tthis.enabled = true;\r\n\r\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\r\n\t\tthis.needsSwap = true;\r\n\r\n\t\t// if set to true, the pass clears its buffer before rendering\r\n\t\tthis.clear = false;\r\n\r\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\r\n\t\tthis.renderToScreen = false;\r\n\r\n\t};\r\n\r\n\tObject.assign( THREE.Pass.prototype, {\r\n\r\n\t\tsetSize: function ( /* width, height */ ) {},\r\n\r\n\t\trender: function ( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\t// Helper for passes that need to fill the viewport with a single quad.\r\n\tTHREE.Pass.FullScreenQuad = ( function () {\r\n\r\n\t\tvar camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\r\n\t\tvar geometry = new THREE.PlaneBufferGeometry( 2, 2 );\r\n\r\n\t\tvar FullScreenQuad = function ( material ) {\r\n\r\n\t\t\tthis._mesh = new THREE.Mesh( geometry, material );\r\n\r\n\t\t};\r\n\r\n\t\tObject.defineProperty( FullScreenQuad.prototype, 'material', {\r\n\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\treturn this._mesh.material;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\tthis._mesh.material = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tObject.assign( FullScreenQuad.prototype, {\r\n\r\n\t\t\tdispose: function () {\r\n\r\n\t\t\t\tthis._mesh.geometry.dispose();\r\n\r\n\t\t\t},\r\n\r\n\t\t\trender: function ( renderer ) {\r\n\r\n\t\t\t\trenderer.render( this._mesh, camera );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn FullScreenQuad;\r\n\r\n\t} )();\r\n\r\n\treturn THREE.Pass;\r\n});\ndefine('skylark-threejs-ex/postprocessing/ShaderPass',[\n\t\"skylark-threejs\",\n\t\"./Pass\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tTHREE.ShaderPass = function ( shader, textureID ) {\n\n\t\tTHREE.Pass.call( this );\n\n\t\tthis.textureID = ( textureID !== undefined ) ? textureID : \"tDiffuse\";\n\n\t\tif ( shader instanceof THREE.ShaderMaterial ) {\n\n\t\t\tthis.uniforms = shader.uniforms;\n\n\t\t\tthis.material = shader;\n\n\t\t} else if ( shader ) {\n\n\t\t\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\t\tthis.material = new THREE.ShaderMaterial( {\n\n\t\t\t\tdefines: Object.assign( {}, shader.defines ),\n\t\t\t\tuniforms: this.uniforms,\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t\t} );\n\n\t\t}\n\n\t\tthis.fsQuad = new THREE.Pass.FullScreenQuad( this.material );\n\n\t};\n\n\tTHREE.ShaderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\n\t\tconstructor: THREE.ShaderPass,\n\n\t\trender: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\n\n\t\t\t}\n\n\t\t\tthis.fsQuad.material = this.material;\n\n\t\t\tif ( this.renderToScreen ) {\n\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.ShaderPass;\n});\n\ndefine('skylark-threejs-ex/postprocessing/MaskPass',[\n\t\"skylark-threejs\",\n\t\"./Pass\"\n],function(THREE,Pass){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tTHREE.MaskPass = function ( scene, camera ) {\n\n\t\tTHREE.Pass.call( this );\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.clear = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis.inverse = false;\n\n\t};\n\n\tTHREE.MaskPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\n\t\tconstructor: THREE.MaskPass,\n\n\t\trender: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\t\tvar context = renderer.getContext();\n\t\t\tvar state = renderer.state;\n\n\t\t\t// don't update color or depth\n\n\t\t\tstate.buffers.color.setMask( false );\n\t\t\tstate.buffers.depth.setMask( false );\n\n\t\t\t// lock buffers\n\n\t\t\tstate.buffers.color.setLocked( true );\n\t\t\tstate.buffers.depth.setLocked( true );\n\n\t\t\t// set up stencil\n\n\t\t\tvar writeValue, clearValue;\n\n\t\t\tif ( this.inverse ) {\n\n\t\t\t\twriteValue = 0;\n\t\t\t\tclearValue = 1;\n\n\t\t\t} else {\n\n\t\t\t\twriteValue = 1;\n\t\t\t\tclearValue = 0;\n\n\t\t\t}\n\n\t\t\tstate.buffers.stencil.setTest( true );\n\t\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\n\t\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\n\t\t\tstate.buffers.stencil.setClear( clearValue );\n\t\t\tstate.buffers.stencil.setLocked( true );\n\n\t\t\t// draw into the stencil buffer\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tif ( this.clear ) renderer.clear();\n\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\tif ( this.clear ) renderer.clear();\n\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\t// unlock color and depth buffer for subsequent rendering\n\n\t\t\tstate.buffers.color.setLocked( false );\n\t\t\tstate.buffers.depth.setLocked( false );\n\n\t\t\t// only render where stencil is set to 1\n\n\t\t\tstate.buffers.stencil.setLocked( false );\n\t\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1\n\t\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\n\t\t\tstate.buffers.stencil.setLocked( true );\n\n\t\t}\n\n\t} );\n\n\n\tTHREE.ClearMaskPass = function () {\n\n\t\tTHREE.Pass.call( this );\n\n\t\tthis.needsSwap = false;\n\n\t};\n\n\tTHREE.ClearMaskPass.prototype = Object.create( THREE.Pass.prototype );\n\n\tObject.assign( THREE.ClearMaskPass.prototype, {\n\n\t\trender: function ( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\t\trenderer.state.buffers.stencil.setLocked( false );\n\t\t\trenderer.state.buffers.stencil.setTest( false );\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.MaskPass;\n});\n\ndefine('skylark-threejs-ex/postprocessing/EffectComposer',[\n\t\"skylark-threejs\",\n\t\"../shaders/CopyShader\",\n\t\"./ShaderPass\",\n\t\"./MaskPass\"\n],function(THREE){\n\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tTHREE.EffectComposer = function ( renderer, renderTarget ) {\n\n\t\tthis.renderer = renderer;\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\tvar parameters = {\n\t\t\t\tminFilter: THREE.LinearFilter,\n\t\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\t\tformat: THREE.RGBAFormat,\n\t\t\t\tstencilBuffer: false\n\t\t\t};\n\n\t\t\tvar size = renderer.getSize( new THREE.Vector2() );\n\t\t\tthis._pixelRatio = renderer.getPixelRatio();\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = new THREE.WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, parameters );\n\t\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\n\t\t} else {\n\n\t\t\tthis._pixelRatio = 1;\n\t\t\tthis._width = renderTarget.width;\n\t\t\tthis._height = renderTarget.height;\n\n\t\t}\n\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\t\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t\tthis.renderToScreen = true;\n\n\t\tthis.passes = [];\n\n\t\t// dependencies\n\n\t\tif ( THREE.CopyShader === undefined ) {\n\n\t\t\tconsole.error( 'THREE.EffectComposer relies on THREE.CopyShader' );\n\n\t\t}\n\n\t\tif ( THREE.ShaderPass === undefined ) {\n\n\t\t\tconsole.error( 'THREE.EffectComposer relies on THREE.ShaderPass' );\n\n\t\t}\n\n\t\tthis.copyPass = new THREE.ShaderPass( THREE.CopyShader );\n\n\t\tthis.clock = new THREE.Clock();\n\n\t};\n\n\tObject.assign( THREE.EffectComposer.prototype, {\n\n\t\tswapBuffers: function () {\n\n\t\t\tvar tmp = this.readBuffer;\n\t\t\tthis.readBuffer = this.writeBuffer;\n\t\t\tthis.writeBuffer = tmp;\n\n\t\t},\n\n\t\taddPass: function ( pass ) {\n\n\t\t\tthis.passes.push( pass );\n\t\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t\t},\n\n\t\tinsertPass: function ( pass, index ) {\n\n\t\t\tthis.passes.splice( index, 0, pass );\n\n\t\t},\n\n\t\tisLastEnabledPass: function ( passIndex ) {\n\n\t\t\tfor ( var i = passIndex + 1; i < this.passes.length; i ++ ) {\n\n\t\t\t\tif ( this.passes[ i ].enabled ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\trender: function ( deltaTime ) {\n\n\t\t\t// deltaTime value is in seconds\n\n\t\t\tif ( deltaTime === undefined ) {\n\n\t\t\t\tdeltaTime = this.clock.getDelta();\n\n\t\t\t}\n\n\t\t\tvar currentRenderTarget = this.renderer.getRenderTarget();\n\n\t\t\tvar maskActive = false;\n\n\t\t\tvar pass, i, il = this.passes.length;\n\n\t\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\t\tpass = this.passes[ i ];\n\n\t\t\t\tif ( pass.enabled === false ) continue;\n\n\t\t\t\tpass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );\n\t\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );\n\n\t\t\t\tif ( pass.needsSwap ) {\n\n\t\t\t\t\tif ( maskActive ) {\n\n\t\t\t\t\t\tvar context = this.renderer.getContext();\n\t\t\t\t\t\tvar stencil = this.renderer.state.buffers.stencil;\n\n\t\t\t\t\t\t//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n\t\t\t\t\t\tstencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );\n\n\t\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );\n\n\t\t\t\t\t\t//context.stencilFunc( context.EQUAL, 1, 0xffffffff );\n\t\t\t\t\t\tstencil.setFunc( context.EQUAL, 1, 0xffffffff );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.swapBuffers();\n\n\t\t\t\t}\n\n\t\t\t\tif ( THREE.MaskPass !== undefined ) {\n\n\t\t\t\t\tif ( pass instanceof THREE.MaskPass ) {\n\n\t\t\t\t\t\tmaskActive = true;\n\n\t\t\t\t\t} else if ( pass instanceof THREE.ClearMaskPass ) {\n\n\t\t\t\t\t\tmaskActive = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.renderer.setRenderTarget( currentRenderTarget );\n\n\t\t},\n\n\t\treset: function ( renderTarget ) {\n\n\t\t\tif ( renderTarget === undefined ) {\n\n\t\t\t\tvar size = this.renderer.getSize( new THREE.Vector2() );\n\t\t\t\tthis._pixelRatio = this.renderer.getPixelRatio();\n\t\t\t\tthis._width = size.width;\n\t\t\t\tthis._height = size.height;\n\n\t\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\t\trenderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t\t\t}\n\n\t\t\tthis.renderTarget1.dispose();\n\t\t\tthis.renderTarget2.dispose();\n\t\t\tthis.renderTarget1 = renderTarget;\n\t\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\t\tthis.writeBuffer = this.renderTarget1;\n\t\t\tthis.readBuffer = this.renderTarget2;\n\n\t\t},\n\n\t\tsetSize: function ( width, height ) {\n\n\t\t\tthis._width = width;\n\t\t\tthis._height = height;\n\n\t\t\tvar effectiveWidth = this._width * this._pixelRatio;\n\t\t\tvar effectiveHeight = this._height * this._pixelRatio;\n\n\t\t\tthis.renderTarget1.setSize( effectiveWidth, effectiveHeight );\n\t\t\tthis.renderTarget2.setSize( effectiveWidth, effectiveHeight );\n\n\t\t\tfor ( var i = 0; i < this.passes.length; i ++ ) {\n\n\t\t\t\tthis.passes[ i ].setSize( effectiveWidth, effectiveHeight );\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetPixelRatio: function ( pixelRatio ) {\n\n\t\t\tthis._pixelRatio = pixelRatio;\n\n\t\t\tthis.setSize( this._width, this._height );\n\n\t\t}\n\n\t} );\n\n\n\t\n\treturn THREE.EffectComposer;\n});\n\ndefine('skylark-threejs-ex/postprocessing/RenderPass',[\n\t\"skylark-threejs\",\n\t\"./Pass\"\n],function(THREE,Pass){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tTHREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {\n\n\t\tTHREE.Pass.call( this );\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.overrideMaterial = overrideMaterial;\n\n\t\tthis.clearColor = clearColor;\n\t\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\n\n\t\tthis.clear = true;\n\t\tthis.clearDepth = false;\n\t\tthis.needsSwap = false;\n\n\t};\n\n\tTHREE.RenderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\n\t\tconstructor: THREE.RenderPass,\n\n\t\trender: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\t\tvar oldAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\n\t\t\tvar oldClearColor, oldClearAlpha, oldOverrideMaterial;\n\n\t\t\tif ( this.overrideMaterial !== undefined ) {\n\n\t\t\t\toldOverrideMaterial = this.scene.overrideMaterial;\n\n\t\t\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\t\t}\n\n\t\t\tif ( this.clearColor ) {\n\n\t\t\t\toldClearColor = renderer.getClearColor().getHex();\n\t\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\n\n\t\t\t}\n\n\t\t\tif ( this.clearDepth ) {\n\n\t\t\t\trenderer.clearDepth();\n\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget( this.renderToScreen ? null : readBuffer );\n\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\tif ( this.clearColor ) {\n\n\t\t\t\trenderer.setClearColor( oldClearColor, oldClearAlpha );\n\n\t\t\t}\n\n\t\t\tif ( this.overrideMaterial !== undefined ) {\n\n\t\t\t\tthis.scene.overrideMaterial = oldOverrideMaterial;\n\n\t\t\t}\n\n\t\t\trenderer.autoClear = oldAutoClear;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.RenderPass;\n});\n\ndefine('skylark-threejs-ex/curves/NURBSUtils',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author renej\n\t * NURBS utils\n\t *\n\t * See NURBSCurve and NURBSSurface.\n\t *\n\t **/\n\n\n\t/**************************************************************\n\t *\tNURBS Utils\n\t **************************************************************/\n\n\tTHREE.NURBSUtils = {\n\n\t\t/*\n\t\tFinds knot vector span.\n\n\t\tp : degree\n\t\tu : parametric value\n\t\tU : knot vector\n\n\t\treturns the span\n\t\t*/\n\t\tfindSpan: function ( p, u, U ) {\n\n\t\t\tvar n = U.length - p - 1;\n\n\t\t\tif ( u >= U[ n ] ) {\n\n\t\t\t\treturn n - 1;\n\n\t\t\t}\n\n\t\t\tif ( u <= U[ p ] ) {\n\n\t\t\t\treturn p;\n\n\t\t\t}\n\n\t\t\tvar low = p;\n\t\t\tvar high = n;\n\t\t\tvar mid = Math.floor( ( low + high ) / 2 );\n\n\t\t\twhile ( u < U[ mid ] || u >= U[ mid + 1 ] ) {\n\n\t\t\t\tif ( u < U[ mid ] ) {\n\n\t\t\t\t\thigh = mid;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlow = mid;\n\n\t\t\t\t}\n\n\t\t\t\tmid = Math.floor( ( low + high ) / 2 );\n\n\t\t\t}\n\n\t\t\treturn mid;\n\n\t\t},\n\n\n\t\t/*\n\t\tCalculate basis functions. See The NURBS Book, page 70, algorithm A2.2\n\n\t\tspan : span in which u lies\n\t\tu    : parametric point\n\t\tp    : degree\n\t\tU    : knot vector\n\n\t\treturns array[p+1] with basis functions values.\n\t\t*/\n\t\tcalcBasisFunctions: function ( span, u, p, U ) {\n\n\t\t\tvar N = [];\n\t\t\tvar left = [];\n\t\t\tvar right = [];\n\t\t\tN[ 0 ] = 1.0;\n\n\t\t\tfor ( var j = 1; j <= p; ++ j ) {\n\n\t\t\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\t\t\tright[ j ] = U[ span + j ] - u;\n\n\t\t\t\tvar saved = 0.0;\n\n\t\t\t\tfor ( var r = 0; r < j; ++ r ) {\n\n\t\t\t\t\tvar rv = right[ r + 1 ];\n\t\t\t\t\tvar lv = left[ j - r ];\n\t\t\t\t\tvar temp = N[ r ] / ( rv + lv );\n\t\t\t\t\tN[ r ] = saved + rv * temp;\n\t\t\t\t\tsaved = lv * temp;\n\n\t\t\t\t }\n\n\t\t\t\t N[ j ] = saved;\n\n\t\t\t }\n\n\t\t\t return N;\n\n\t\t},\n\n\n\t\t/*\n\t\tCalculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\n\n\t\tp : degree of B-Spline\n\t\tU : knot vector\n\t\tP : control points (x, y, z, w)\n\t\tu : parametric point\n\n\t\treturns point for given u\n\t\t*/\n\t\tcalcBSplinePoint: function ( p, U, P, u ) {\n\n\t\t\tvar span = this.findSpan( p, u, U );\n\t\t\tvar N = this.calcBasisFunctions( span, u, p, U );\n\t\t\tvar C = new THREE.Vector4( 0, 0, 0, 0 );\n\n\t\t\tfor ( var j = 0; j <= p; ++ j ) {\n\n\t\t\t\tvar point = P[ span - p + j ];\n\t\t\t\tvar Nj = N[ j ];\n\t\t\t\tvar wNj = point.w * Nj;\n\t\t\t\tC.x += point.x * wNj;\n\t\t\t\tC.y += point.y * wNj;\n\t\t\t\tC.z += point.z * wNj;\n\t\t\t\tC.w += point.w * Nj;\n\n\t\t\t}\n\n\t\t\treturn C;\n\n\t\t},\n\n\n\t\t/*\n\t\tCalculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\n\n\t\tspan : span in which u lies\n\t\tu    : parametric point\n\t\tp    : degree\n\t\tn    : number of derivatives to calculate\n\t\tU    : knot vector\n\n\t\treturns array[n+1][p+1] with basis functions derivatives\n\t\t*/\n\t\tcalcBasisFunctionDerivatives: function ( span, u, p, n, U ) {\n\n\t\t\tvar zeroArr = [];\n\t\t\tfor ( var i = 0; i <= p; ++ i )\n\t\t\t\tzeroArr[ i ] = 0.0;\n\n\t\t\tvar ders = [];\n\t\t\tfor ( var i = 0; i <= n; ++ i )\n\t\t\t\tders[ i ] = zeroArr.slice( 0 );\n\n\t\t\tvar ndu = [];\n\t\t\tfor ( var i = 0; i <= p; ++ i )\n\t\t\t\tndu[ i ] = zeroArr.slice( 0 );\n\n\t\t\tndu[ 0 ][ 0 ] = 1.0;\n\n\t\t\tvar left = zeroArr.slice( 0 );\n\t\t\tvar right = zeroArr.slice( 0 );\n\n\t\t\tfor ( var j = 1; j <= p; ++ j ) {\n\n\t\t\t\tleft[ j ] = u - U[ span + 1 - j ];\n\t\t\t\tright[ j ] = U[ span + j ] - u;\n\n\t\t\t\tvar saved = 0.0;\n\n\t\t\t\tfor ( var r = 0; r < j; ++ r ) {\n\n\t\t\t\t\tvar rv = right[ r + 1 ];\n\t\t\t\t\tvar lv = left[ j - r ];\n\t\t\t\t\tndu[ j ][ r ] = rv + lv;\n\n\t\t\t\t\tvar temp = ndu[ r ][ j - 1 ] / ndu[ j ][ r ];\n\t\t\t\t\tndu[ r ][ j ] = saved + rv * temp;\n\t\t\t\t\tsaved = lv * temp;\n\n\t\t\t\t}\n\n\t\t\t\tndu[ j ][ j ] = saved;\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0; j <= p; ++ j ) {\n\n\t\t\t\tders[ 0 ][ j ] = ndu[ j ][ p ];\n\n\t\t\t}\n\n\t\t\tfor ( var r = 0; r <= p; ++ r ) {\n\n\t\t\t\tvar s1 = 0;\n\t\t\t\tvar s2 = 1;\n\n\t\t\t\tvar a = [];\n\t\t\t\tfor ( var i = 0; i <= p; ++ i ) {\n\n\t\t\t\t\ta[ i ] = zeroArr.slice( 0 );\n\n\t\t\t\t}\n\t\t\t\ta[ 0 ][ 0 ] = 1.0;\n\n\t\t\t\tfor ( var k = 1; k <= n; ++ k ) {\n\n\t\t\t\t\tvar d = 0.0;\n\t\t\t\t\tvar rk = r - k;\n\t\t\t\t\tvar pk = p - k;\n\n\t\t\t\t\tif ( r >= k ) {\n\n\t\t\t\t\t\ta[ s2 ][ 0 ] = a[ s1 ][ 0 ] / ndu[ pk + 1 ][ rk ];\n\t\t\t\t\t\td = a[ s2 ][ 0 ] * ndu[ rk ][ pk ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar j1 = ( rk >= - 1 ) ? 1 : - rk;\n\t\t\t\t\tvar j2 = ( r - 1 <= pk ) ? k - 1 : p - r;\n\n\t\t\t\t\tfor ( var j = j1; j <= j2; ++ j ) {\n\n\t\t\t\t\t\ta[ s2 ][ j ] = ( a[ s1 ][ j ] - a[ s1 ][ j - 1 ] ) / ndu[ pk + 1 ][ rk + j ];\n\t\t\t\t\t\td += a[ s2 ][ j ] * ndu[ rk + j ][ pk ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( r <= pk ) {\n\n\t\t\t\t\t\ta[ s2 ][ k ] = - a[ s1 ][ k - 1 ] / ndu[ pk + 1 ][ r ];\n\t\t\t\t\t\td += a[ s2 ][ k ] * ndu[ r ][ pk ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tders[ k ][ r ] = d;\n\n\t\t\t\t\tvar j = s1;\n\t\t\t\t\ts1 = s2;\n\t\t\t\t\ts2 = j;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar r = p;\n\n\t\t\tfor ( var k = 1; k <= n; ++ k ) {\n\n\t\t\t\tfor ( var j = 0; j <= p; ++ j ) {\n\n\t\t\t\t\tders[ k ][ j ] *= r;\n\n\t\t\t\t}\n\t\t\t\tr *= p - k;\n\n\t\t\t}\n\n\t\t\treturn ders;\n\n\t\t},\n\n\n\t\t/*\n\t\t\tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\n\n\t\t\tp  : degree\n\t\t\tU  : knot vector\n\t\t\tP  : control points\n\t\t\tu  : Parametric points\n\t\t\tnd : number of derivatives\n\n\t\t\treturns array[d+1] with derivatives\n\t\t\t*/\n\t\tcalcBSplineDerivatives: function ( p, U, P, u, nd ) {\n\n\t\t\tvar du = nd < p ? nd : p;\n\t\t\tvar CK = [];\n\t\t\tvar span = this.findSpan( p, u, U );\n\t\t\tvar nders = this.calcBasisFunctionDerivatives( span, u, p, du, U );\n\t\t\tvar Pw = [];\n\n\t\t\tfor ( var i = 0; i < P.length; ++ i ) {\n\n\t\t\t\tvar point = P[ i ].clone();\n\t\t\t\tvar w = point.w;\n\n\t\t\t\tpoint.x *= w;\n\t\t\t\tpoint.y *= w;\n\t\t\t\tpoint.z *= w;\n\n\t\t\t\tPw[ i ] = point;\n\n\t\t\t}\n\t\t\tfor ( var k = 0; k <= du; ++ k ) {\n\n\t\t\t\tvar point = Pw[ span - p ].clone().multiplyScalar( nders[ k ][ 0 ] );\n\n\t\t\t\tfor ( var j = 1; j <= p; ++ j ) {\n\n\t\t\t\t\tpoint.add( Pw[ span - p + j ].clone().multiplyScalar( nders[ k ][ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tCK[ k ] = point;\n\n\t\t\t}\n\n\t\t\tfor ( var k = du + 1; k <= nd + 1; ++ k ) {\n\n\t\t\t\tCK[ k ] = new THREE.Vector4( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn CK;\n\n\t\t},\n\n\n\t\t/*\n\t\tCalculate \"K over I\"\n\n\t\treturns k!/(i!(k-i)!)\n\t\t*/\n\t\tcalcKoverI: function ( k, i ) {\n\n\t\t\tvar nom = 1;\n\n\t\t\tfor ( var j = 2; j <= k; ++ j ) {\n\n\t\t\t\tnom *= j;\n\n\t\t\t}\n\n\t\t\tvar denom = 1;\n\n\t\t\tfor ( var j = 2; j <= i; ++ j ) {\n\n\t\t\t\tdenom *= j;\n\n\t\t\t}\n\n\t\t\tfor ( var j = 2; j <= k - i; ++ j ) {\n\n\t\t\t\tdenom *= j;\n\n\t\t\t}\n\n\t\t\treturn nom / denom;\n\n\t\t},\n\n\n\t\t/*\n\t\tCalculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\n\n\t\tPders : result of function calcBSplineDerivatives\n\n\t\treturns array with derivatives for rational curve.\n\t\t*/\n\t\tcalcRationalCurveDerivatives: function ( Pders ) {\n\n\t\t\tvar nd = Pders.length;\n\t\t\tvar Aders = [];\n\t\t\tvar wders = [];\n\n\t\t\tfor ( var i = 0; i < nd; ++ i ) {\n\n\t\t\t\tvar point = Pders[ i ];\n\t\t\t\tAders[ i ] = new THREE.Vector3( point.x, point.y, point.z );\n\t\t\t\twders[ i ] = point.w;\n\n\t\t\t}\n\n\t\t\tvar CK = [];\n\n\t\t\tfor ( var k = 0; k < nd; ++ k ) {\n\n\t\t\t\tvar v = Aders[ k ].clone();\n\n\t\t\t\tfor ( var i = 1; i <= k; ++ i ) {\n\n\t\t\t\t\tv.sub( CK[ k - i ].clone().multiplyScalar( this.calcKoverI( k, i ) * wders[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tCK[ k ] = v.divideScalar( wders[ 0 ] );\n\n\t\t\t}\n\n\t\t\treturn CK;\n\n\t\t},\n\n\n\t\t/*\n\t\tCalculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\n\n\t\tp  : degree\n\t\tU  : knot vector\n\t\tP  : control points in homogeneous space\n\t\tu  : parametric points\n\t\tnd : number of derivatives\n\n\t\treturns array with derivatives.\n\t\t*/\n\t\tcalcNURBSDerivatives: function ( p, U, P, u, nd ) {\n\n\t\t\tvar Pders = this.calcBSplineDerivatives( p, U, P, u, nd );\n\t\t\treturn this.calcRationalCurveDerivatives( Pders );\n\n\t\t},\n\n\n\t\t/*\n\t\tCalculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n\n\t\tp1, p2 : degrees of B-Spline surface\n\t\tU1, U2 : knot vectors\n\t\tP      : control points (x, y, z, w)\n\t\tu, v   : parametric values\n\n\t\treturns point for given (u, v)\n\t\t*/\n\t\tcalcSurfacePoint: function ( p, q, U, V, P, u, v, target ) {\n\n\t\t\tvar uspan = this.findSpan( p, u, U );\n\t\t\tvar vspan = this.findSpan( q, v, V );\n\t\t\tvar Nu = this.calcBasisFunctions( uspan, u, p, U );\n\t\t\tvar Nv = this.calcBasisFunctions( vspan, v, q, V );\n\t\t\tvar temp = [];\n\n\t\t\tfor ( var l = 0; l <= q; ++ l ) {\n\n\t\t\t\ttemp[ l ] = new THREE.Vector4( 0, 0, 0, 0 );\n\t\t\t\tfor ( var k = 0; k <= p; ++ k ) {\n\n\t\t\t\t\tvar point = P[ uspan - p + k ][ vspan - q + l ].clone();\n\t\t\t\t\tvar w = point.w;\n\t\t\t\t\tpoint.x *= w;\n\t\t\t\t\tpoint.y *= w;\n\t\t\t\t\tpoint.z *= w;\n\t\t\t\t\ttemp[ l ].add( point.multiplyScalar( Nu[ k ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar Sw = new THREE.Vector4( 0, 0, 0, 0 );\n\t\t\tfor ( var l = 0; l <= q; ++ l ) {\n\n\t\t\t\tSw.add( temp[ l ].multiplyScalar( Nv[ l ] ) );\n\n\t\t\t}\n\n\t\t\tSw.divideScalar( Sw.w );\n\t\t\ttarget.set( Sw.x, Sw.y, Sw.z );\n\n\t\t}\n\n\t};\n\treturn THREE.NURBSUtils;\n});\n\ndefine('skylark-threejs-ex/curves/NURBSCurve',[\n\t\"skylark-threejs\",\n\t\"./NURBSUtils\"\n],function(THREE){\n\t/**\n\t * @author renej\n\t * NURBS curve object\n\t *\n\t * Derives from Curve, overriding getPoint and getTangent.\n\t *\n\t * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n\t *\n\t **/\n\n\n\t/**************************************************************\n\t *\tNURBS curve\n\t **************************************************************/\n\n\tTHREE.NURBSCurve = function ( degree, knots /* array of reals */, controlPoints /* array of Vector(2|3|4) */, startKnot /* index in knots */, endKnot /* index in knots */ ) {\n\n\t\tTHREE.Curve.call( this );\n\n\t\tthis.degree = degree;\n\t\tthis.knots = knots;\n\t\tthis.controlPoints = [];\n\t\t// Used by periodic NURBS to remove hidden spans\n\t\tthis.startKnot = startKnot || 0;\n\t\tthis.endKnot = endKnot || ( this.knots.length - 1 );\n\t\tfor ( var i = 0; i < controlPoints.length; ++ i ) {\n\n\t\t\t// ensure Vector4 for control points\n\t\t\tvar point = controlPoints[ i ];\n\t\t\tthis.controlPoints[ i ] = new THREE.Vector4( point.x, point.y, point.z, point.w );\n\n\t\t}\n\n\t};\n\n\n\tTHREE.NURBSCurve.prototype = Object.create( THREE.Curve.prototype );\n\tTHREE.NURBSCurve.prototype.constructor = THREE.NURBSCurve;\n\n\n\tTHREE.NURBSCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u\n\n\t\t// following results in (wx, wy, wz, w) homogeneous point\n\t\tvar hpoint = THREE.NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );\n\n\t\tif ( hpoint.w != 1.0 ) {\n\n\t\t\t// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n\t\t\thpoint.divideScalar( hpoint.w );\n\n\t\t}\n\n\t\treturn new THREE.Vector3( hpoint.x, hpoint.y, hpoint.z );\n\n\t};\n\n\n\tTHREE.NURBSCurve.prototype.getTangent = function ( t ) {\n\n\t\tvar u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );\n\t\tvar ders = THREE.NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );\n\t\tvar tangent = ders[ 1 ].clone();\n\t\ttangent.normalize();\n\n\t\treturn tangent;\n\n\t};\n\treturn THREE.NURBSCurve;\n});\n\ndefine('skylark-threejs-ex/curves/NURBSSurface',[\n\t\"skylark-threejs\",\n\t\"./NURBSUtils\"\n],function(THREE){\n\t/**\n\t * @author renej\n\t * NURBS surface object\n\t *\n\t * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n\t *\n\t **/\n\n\n\t/**************************************************************\n\t *\tNURBS surface\n\t **************************************************************/\n\n\tTHREE.NURBSSurface = function ( degree1, degree2, knots1, knots2 /* arrays of reals */, controlPoints /* array^2 of Vector(2|3|4) */ ) {\n\n\t\tthis.degree1 = degree1;\n\t\tthis.degree2 = degree2;\n\t\tthis.knots1 = knots1;\n\t\tthis.knots2 = knots2;\n\t\tthis.controlPoints = [];\n\n\t\tvar len1 = knots1.length - degree1 - 1;\n\t\tvar len2 = knots2.length - degree2 - 1;\n\n\t\t// ensure Vector4 for control points\n\t\tfor ( var i = 0; i < len1; ++ i ) {\n\n\t\t\tthis.controlPoints[ i ] = [];\n\t\t\tfor ( var j = 0; j < len2; ++ j ) {\n\n\t\t\t\tvar point = controlPoints[ i ][ j ];\n\t\t\t\tthis.controlPoints[ i ][ j ] = new THREE.Vector4( point.x, point.y, point.z, point.w );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\tTHREE.NURBSSurface.prototype = {\n\n\t\tconstructor: THREE.NURBSSurface,\n\n\t\tgetPoint: function ( t1, t2, target ) {\n\n\t\t\tvar u = this.knots1[ 0 ] + t1 * ( this.knots1[ this.knots1.length - 1 ] - this.knots1[ 0 ] ); // linear mapping t1->u\n\t\t\tvar v = this.knots2[ 0 ] + t2 * ( this.knots2[ this.knots2.length - 1 ] - this.knots2[ 0 ] ); // linear mapping t2->u\n\n\t\t\tTHREE.NURBSUtils.calcSurfacePoint( this.degree1, this.degree2, this.knots1, this.knots2, this.controlPoints, u, v, target );\n\n\t\t}\n\t};\n\treturn THREE.NURBSSurface;\n});\n\ndefine('skylark-threejs-ex/objects/Lensflare',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tTHREE.Lensflare = function () {\n\n\t\tTHREE.Mesh.call( this, THREE.Lensflare.Geometry, new THREE.MeshBasicMaterial( { opacity: 0, transparent: true } ) );\n\n\t\tthis.type = 'Lensflare';\n\t\tthis.frustumCulled = false;\n\t\tthis.renderOrder = Infinity;\n\n\t\t//\n\n\t\tvar positionScreen = new THREE.Vector3();\n\t\tvar positionView = new THREE.Vector3();\n\n\t\t// textures\n\n\t\tvar tempMap = new THREE.DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, THREE.RGBFormat );\n\t\ttempMap.minFilter = THREE.NearestFilter;\n\t\ttempMap.magFilter = THREE.NearestFilter;\n\t\ttempMap.wrapS = THREE.ClampToEdgeWrapping;\n\t\ttempMap.wrapT = THREE.ClampToEdgeWrapping;\n\n\t\tvar occlusionMap = new THREE.DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, THREE.RGBFormat );\n\t\tocclusionMap.minFilter = THREE.NearestFilter;\n\t\tocclusionMap.magFilter = THREE.NearestFilter;\n\t\tocclusionMap.wrapS = THREE.ClampToEdgeWrapping;\n\t\tocclusionMap.wrapT = THREE.ClampToEdgeWrapping;\n\n\t\t// material\n\n\t\tvar geometry = THREE.Lensflare.Geometry;\n\n\t\tvar material1a = new THREE.RawShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\t'scale': { value: null },\n\t\t\t\t'screenPosition': { value: null }\n\t\t\t},\n\t\t\tvertexShader: [\n\n\t\t\t\t'precision highp float;',\n\n\t\t\t\t'uniform vec3 screenPosition;',\n\t\t\t\t'uniform vec2 scale;',\n\n\t\t\t\t'attribute vec3 position;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ),\n\t\t\tfragmentShader: [\n\n\t\t\t\t'precision highp float;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ),\n\t\t\tdepthTest: true,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: false\n\t\t} );\n\n\t\tvar material1b = new THREE.RawShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\t'map': { value: tempMap },\n\t\t\t\t'scale': { value: null },\n\t\t\t\t'screenPosition': { value: null }\n\t\t\t},\n\t\t\tvertexShader: [\n\n\t\t\t\t'precision highp float;',\n\n\t\t\t\t'uniform vec3 screenPosition;',\n\t\t\t\t'uniform vec2 scale;',\n\n\t\t\t\t'attribute vec3 position;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tvUV = uv;',\n\n\t\t\t\t'\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ),\n\t\t\tfragmentShader: [\n\n\t\t\t\t'precision highp float;',\n\n\t\t\t\t'uniform sampler2D map;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tgl_FragColor = texture2D( map, vUV );',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ),\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: false\n\t\t} );\n\n\t\t// the following object is used for occlusionMap generation\n\n\t\tvar mesh1 = new THREE.Mesh( geometry, material1a );\n\n\t\t//\n\n\t\tvar elements = [];\n\n\t\tvar shader = THREE.LensflareElement.Shader;\n\n\t\tvar material2 = new THREE.RawShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\t'map': { value: null },\n\t\t\t\t'occlusionMap': { value: occlusionMap },\n\t\t\t\t'color': { value: new THREE.Color( 0xffffff ) },\n\t\t\t\t'scale': { value: new THREE.Vector2() },\n\t\t\t\t'screenPosition': { value: new THREE.Vector3() }\n\t\t\t},\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tblending: THREE.AdditiveBlending,\n\t\t\ttransparent: true,\n\t\t\tdepthWrite: false\n\t\t} );\n\n\t\tvar mesh2 = new THREE.Mesh( geometry, material2 );\n\n\t\tthis.addElement = function ( element ) {\n\n\t\t\telements.push( element );\n\n\t\t};\n\n\t\t//\n\n\t\tvar scale = new THREE.Vector2();\n\t\tvar screenPositionPixels = new THREE.Vector2();\n\t\tvar validArea = new THREE.Box2();\n\t\tvar viewport = new THREE.Vector4();\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\trenderer.getCurrentViewport( viewport );\n\n\t\t\tvar invAspect = viewport.w / viewport.z;\n\t\t\tvar halfViewportWidth = viewport.z / 2.0;\n\t\t\tvar halfViewportHeight = viewport.w / 2.0;\n\n\t\t\tvar size = 16 / viewport.w;\n\t\t\tscale.set( size * invAspect, size );\n\n\t\t\tvalidArea.min.set( viewport.x, viewport.y );\n\t\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\n\n\t\t\t// calculate position in screen space\n\n\t\t\tpositionView.setFromMatrixPosition( this.matrixWorld );\n\t\t\tpositionView.applyMatrix4( camera.matrixWorldInverse );\n\n\t\t\tif ( positionView.z > 0 ) return; // lensflare is behind the camera\n\n\t\t\tpositionScreen.copy( positionView ).applyMatrix4( camera.projectionMatrix );\n\n\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\tscreenPositionPixels.x = viewport.x + ( positionScreen.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\tscreenPositionPixels.y = viewport.y + ( positionScreen.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t// screen cull\n\n\t\t\tif ( validArea.containsPoint( screenPositionPixels ) ) {\n\n\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\trenderer.copyFramebufferToTexture( screenPositionPixels, tempMap );\n\n\t\t\t\t// render pink quad\n\n\t\t\t\tvar uniforms = material1a.uniforms;\n\t\t\t\tuniforms[ \"scale\" ].value = scale;\n\t\t\t\tuniforms[ \"screenPosition\" ].value = positionScreen;\n\n\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1a, mesh1, null );\n\n\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\trenderer.copyFramebufferToTexture( screenPositionPixels, occlusionMap );\n\n\t\t\t\t// restore graphics\n\n\t\t\t\tvar uniforms = material1b.uniforms;\n\t\t\t\tuniforms[ \"scale\" ].value = scale;\n\t\t\t\tuniforms[ \"screenPosition\" ].value = positionScreen;\n\n\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1b, mesh1, null );\n\n\t\t\t\t// render elements\n\n\t\t\t\tvar vecX = - positionScreen.x * 2;\n\t\t\t\tvar vecY = - positionScreen.y * 2;\n\n\t\t\t\tfor ( var i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar element = elements[ i ];\n\n\t\t\t\t\tvar uniforms = material2.uniforms;\n\n\t\t\t\t\tuniforms[ \"color\" ].value.copy( element.color );\n\t\t\t\t\tuniforms[ \"map\" ].value = element.texture;\n\t\t\t\t\tuniforms[ \"screenPosition\" ].value.x = positionScreen.x + vecX * element.distance;\n\t\t\t\t\tuniforms[ \"screenPosition\" ].value.y = positionScreen.y + vecY * element.distance;\n\n\t\t\t\t\tvar size = element.size / viewport.w;\n\t\t\t\t\tvar invAspect = viewport.w / viewport.z;\n\n\t\t\t\t\tuniforms[ \"scale\" ].value.set( size * invAspect, size );\n\n\t\t\t\t\tmaterial2.uniformsNeedUpdate = true;\n\n\t\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material2, mesh2, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.dispose = function () {\n\n\t\t\tmaterial1a.dispose();\n\t\t\tmaterial1b.dispose();\n\t\t\tmaterial2.dispose();\n\n\t\t\ttempMap.dispose();\n\t\t\tocclusionMap.dispose();\n\n\t\t\tfor ( var i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\t\telements[ i ].texture.dispose();\n\n\t\t\t}\n\n\t\t};\n\n\t};\n\n\tTHREE.Lensflare.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.Lensflare.prototype.constructor = THREE.Lensflare;\n\tTHREE.Lensflare.prototype.isLensflare = true;\n\n\t//\n\n\tTHREE.LensflareElement = function ( texture, size, distance, color ) {\n\n\t\tthis.texture = texture;\n\t\tthis.size = size || 1;\n\t\tthis.distance = distance || 0;\n\t\tthis.color = color || new THREE.Color( 0xffffff );\n\n\t};\n\n\tTHREE.LensflareElement.Shader = {\n\n\t\tuniforms: {\n\n\t\t\t'map': { value: null },\n\t\t\t'occlusionMap': { value: null },\n\t\t\t'color': { value: null },\n\t\t\t'scale': { value: null },\n\t\t\t'screenPosition': { value: null }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t'precision highp float;',\n\n\t\t\t'uniform vec3 screenPosition;',\n\t\t\t'uniform vec2 scale;',\n\n\t\t\t'uniform sampler2D occlusionMap;',\n\n\t\t\t'attribute vec3 position;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'varying vec2 vUV;',\n\t\t\t'varying float vVisibility;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvUV = uv;',\n\n\t\t\t'\tvec2 pos = position.xy;',\n\n\t\t\t'\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',\n\n\t\t\t'\tvVisibility =        visibility.r / 9.0;',\n\t\t\t'\tvVisibility *= 1.0 - visibility.g / 9.0;',\n\t\t\t'\tvVisibility *=       visibility.b / 9.0;',\n\n\t\t\t'\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\n\t\t\t'precision highp float;',\n\n\t\t\t'uniform sampler2D map;',\n\t\t\t'uniform vec3 color;',\n\n\t\t\t'varying vec2 vUV;',\n\t\t\t'varying float vVisibility;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvec4 texture = texture2D( map, vUV );',\n\t\t\t'\ttexture.a *= vVisibility;',\n\t\t\t'\tgl_FragColor = texture;',\n\t\t\t'\tgl_FragColor.rgb *= color;',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' )\n\n\t};\n\n\tTHREE.Lensflare.Geometry = ( function () {\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\tvar float32Array = new Float32Array( [\n\t\t\t- 1, - 1, 0, 0, 0,\n\t\t\t1, - 1, 0, 1, 0,\n\t\t\t1, 1, 0, 1, 1,\n\t\t\t- 1, 1, 0, 0, 1\n\t\t] );\n\n\t\tvar interleavedBuffer = new THREE.InterleavedBuffer( float32Array, 5 );\n\n\t\tgeometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\t\tgeometry.setAttribute( 'position', new THREE.InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\t\tgeometry.setAttribute( 'uv', new THREE.InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\t\treturn geometry;\n\n\t} )();\n\t\n\treturn THREE.Lensflare;\n});\n\ndefine('skylark-threejs-ex/objects/Reflector',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Slayvin / http://slayvin.net\n\t */\n\n\tTHREE.Reflector = function ( geometry, options ) {\n\n\t\tTHREE.Mesh.call( this, geometry );\n\n\t\tthis.type = 'Reflector';\n\n\t\tvar scope = this;\n\n\t\toptions = options || {};\n\n\t\tvar color = ( options.color !== undefined ) ? new THREE.Color( options.color ) : new THREE.Color( 0x7F7F7F );\n\t\tvar textureWidth = options.textureWidth || 512;\n\t\tvar textureHeight = options.textureHeight || 512;\n\t\tvar clipBias = options.clipBias || 0;\n\t\tvar shader = options.shader || THREE.Reflector.ReflectorShader;\n\t\tvar recursion = options.recursion !== undefined ? options.recursion : 0;\n\t\tvar encoding = options.encoding !== undefined ? options.encoding : THREE.LinearEncoding;\n\n\t\t//\n\n\t\tvar reflectorPlane = new THREE.Plane();\n\t\tvar normal = new THREE.Vector3();\n\t\tvar reflectorWorldPosition = new THREE.Vector3();\n\t\tvar cameraWorldPosition = new THREE.Vector3();\n\t\tvar rotationMatrix = new THREE.Matrix4();\n\t\tvar lookAtPosition = new THREE.Vector3( 0, 0, - 1 );\n\t\tvar clipPlane = new THREE.Vector4();\n\n\t\tvar view = new THREE.Vector3();\n\t\tvar target = new THREE.Vector3();\n\t\tvar q = new THREE.Vector4();\n\n\t\tvar textureMatrix = new THREE.Matrix4();\n\t\tvar virtualCamera = new THREE.PerspectiveCamera();\n\n\t\tvar parameters = {\n\t\t\tminFilter: THREE.LinearFilter,\n\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\tformat: THREE.RGBFormat,\n\t\t\tstencilBuffer: false,\n\t\t\tencoding: encoding\n\t\t};\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\t\tif ( ! THREE.MathUtils.isPowerOfTwo( textureWidth ) || ! THREE.MathUtils.isPowerOfTwo( textureHeight ) ) {\n\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\t}\n\n\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader\n\t\t} );\n\n\t\tmaterial.uniforms[ \"tDiffuse\" ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ \"color\" ].value = color;\n\t\tmaterial.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\n\t\tthis.material = material;\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\tif ( 'recursion' in camera.userData ) {\n\n\t\t\t\tif ( camera.userData.recursion === recursion ) return;\n\n\t\t\t\tcamera.userData.recursion ++;\n\n\t\t\t}\n\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when reflector is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( reflectorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( reflectorWorldPosition );\n\n\t\t\tvirtualCamera.position.copy( view );\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tvirtualCamera.up.reflect( normal );\n\t\t\tvirtualCamera.lookAt( target );\n\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\tvirtualCamera.userData.recursion = 0;\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// Calculate the scaled plane vector\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t\t// Replacing the third row of the projection matrix\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t\t// Render\n\n\t\t\tscope.visible = false;\n\n\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tvar currentXrEnabled = renderer.xr.enabled;\n\t\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification and recursion\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tvar viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t};\n\n\tTHREE.Reflector.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.Reflector.prototype.constructor = THREE.Reflector;\n\n\tTHREE.Reflector.ReflectorShader = {\n\n\t\tuniforms: {\n\n\t\t\t'color': {\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'tDiffuse': {\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'textureMatrix': {\n\t\t\t\tvalue: null\n\t\t\t}\n\n\t\t},\n\n\t\tvertexShader: [\n\t\t\t'uniform mat4 textureMatrix;',\n\t\t\t'varying vec4 vUv;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvUv = textureMatrix * vec4( position, 1.0 );',\n\n\t\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t\t'}'\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\t\t\t'uniform vec3 color;',\n\t\t\t'uniform sampler2D tDiffuse;',\n\t\t\t'varying vec4 vUv;',\n\n\t\t\t'float blendOverlay( float base, float blend ) {',\n\n\t\t\t'\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\n\n\t\t\t'}',\n\n\t\t\t'vec3 blendOverlay( vec3 base, vec3 blend ) {',\n\n\t\t\t'\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\n\n\t\t\t'}',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvec4 base = texture2DProj( tDiffuse, vUv );',\n\t\t\t'\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\n\n\t\t\t'}'\n\t\t].join( '\\n' )\n\t};\n\t\n\treturn THREE.Reflector;\n});\n\ndefine('skylark-threejs-ex/objects/Refractor',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t */\n\n\tTHREE.Refractor = function ( geometry, options ) {\n\n\t\tTHREE.Mesh.call( this, geometry );\n\n\t\tthis.type = 'Refractor';\n\n\t\tvar scope = this;\n\n\t\toptions = options || {};\n\n\t\tvar color = ( options.color !== undefined ) ? new THREE.Color( options.color ) : new THREE.Color( 0x7F7F7F );\n\t\tvar textureWidth = options.textureWidth || 512;\n\t\tvar textureHeight = options.textureHeight || 512;\n\t\tvar clipBias = options.clipBias || 0;\n\t\tvar shader = options.shader || THREE.Refractor.RefractorShader;\n\t\tvar encoding = options.encoding !== undefined ? options.encoding : THREE.LinearEncoding;\n\n\t\t//\n\n\t\tvar virtualCamera = new THREE.PerspectiveCamera();\n\t\tvirtualCamera.matrixAutoUpdate = false;\n\t\tvirtualCamera.userData.refractor = true;\n\n\t\t//\n\n\t\tvar refractorPlane = new THREE.Plane();\n\t\tvar textureMatrix = new THREE.Matrix4();\n\n\t\t// render target\n\n\t\tvar parameters = {\n\t\t\tminFilter: THREE.LinearFilter,\n\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\tformat: THREE.RGBFormat,\n\t\t\tstencilBuffer: false,\n\t\t\tencoding: encoding\n\t\t};\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\t\tif ( ! THREE.MathUtils.isPowerOfTwo( textureWidth ) || ! THREE.MathUtils.isPowerOfTwo( textureHeight ) ) {\n\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\t}\n\n\t\t// material\n\n\t\tthis.material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\ttransparent: true // ensures, refractors are drawn from farthest to closest\n\t\t} );\n\n\t\tthis.material.uniforms[ \"color\" ].value = color;\n\t\tthis.material.uniforms[ \"tDiffuse\" ].value = renderTarget.texture;\n\t\tthis.material.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\n\t\t// functions\n\n\t\tvar visible = ( function () {\n\n\t\t\tvar refractorWorldPosition = new THREE.Vector3();\n\t\t\tvar cameraWorldPosition = new THREE.Vector3();\n\t\t\tvar rotationMatrix = new THREE.Matrix4();\n\n\t\t\tvar view = new THREE.Vector3();\n\t\t\tvar normal = new THREE.Vector3();\n\n\t\t\treturn function visible( camera ) {\n\n\t\t\t\trefractorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\t\tview.subVectors( refractorWorldPosition, cameraWorldPosition );\n\n\t\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\t\tnormal.set( 0, 0, 1 );\n\t\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\t\treturn view.dot( normal ) < 0;\n\n\t\t\t};\n\n\t\t} )();\n\n\t\tvar updateRefractorPlane = ( function () {\n\n\t\t\tvar normal = new THREE.Vector3();\n\t\t\tvar position = new THREE.Vector3();\n\t\t\tvar quaternion = new THREE.Quaternion();\n\t\t\tvar scale = new THREE.Vector3();\n\n\t\t\treturn function updateRefractorPlane() {\n\n\t\t\t\tscope.matrixWorld.decompose( position, quaternion, scale );\n\t\t\t\tnormal.set( 0, 0, 1 ).applyQuaternion( quaternion ).normalize();\n\n\t\t\t\t// flip the normal because we want to cull everything above the plane\n\n\t\t\t\tnormal.negate();\n\n\t\t\t\trefractorPlane.setFromNormalAndCoplanarPoint( normal, position );\n\n\t\t\t};\n\n\t\t} )();\n\n\t\tvar updateVirtualCamera = ( function () {\n\n\t\t\tvar clipPlane = new THREE.Plane();\n\t\t\tvar clipVector = new THREE.Vector4();\n\t\t\tvar q = new THREE.Vector4();\n\n\t\t\treturn function updateVirtualCamera( camera ) {\n\n\t\t\t\tvirtualCamera.matrixWorld.copy( camera.matrixWorld );\n\t\t\t\tvirtualCamera.matrixWorldInverse.getInverse( virtualCamera.matrixWorld );\n\t\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\t\t\t\tvirtualCamera.far = camera.far; // used in WebGLBackground\n\n\t\t\t\t// The following code creates an oblique view frustum for clipping.\n\t\t\t\t// see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n\t\t\t\t// Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n\t\t\t\tclipPlane.copy( refractorPlane );\n\t\t\t\tclipPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\t\tclipVector.set( clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant );\n\n\t\t\t\t// calculate the clip-space corner point opposite the clipping plane and\n\t\t\t\t// transform it into camera space by multiplying it by the inverse of the projection matrix\n\n\t\t\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\t\tq.x = ( Math.sign( clipVector.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\t\tq.y = ( Math.sign( clipVector.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\t\tq.z = - 1.0;\n\t\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t\t// calculate the scaled plane vector\n\n\t\t\t\tclipVector.multiplyScalar( 2.0 / clipVector.dot( q ) );\n\n\t\t\t\t// replacing the third row of the projection matrix\n\n\t\t\t\tprojectionMatrix.elements[ 2 ] = clipVector.x;\n\t\t\t\tprojectionMatrix.elements[ 6 ] = clipVector.y;\n\t\t\t\tprojectionMatrix.elements[ 10 ] = clipVector.z + 1.0 - clipBias;\n\t\t\t\tprojectionMatrix.elements[ 14 ] = clipVector.w;\n\n\t\t\t};\n\n\t\t} )();\n\n\t\t// This will update the texture matrix that is used for projective texture mapping in the shader.\n\t\t// see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\t\tfunction updateTextureMatrix( camera ) {\n\n\t\t\t// this matrix does range mapping to [ 0, 1 ]\n\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\n\t\t\t// we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n\t\t\t// (matrix above) with the projection and view matrix of the virtual camera\n\t\t\t// and the model matrix of the refractor\n\n\t\t\ttextureMatrix.multiply( camera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction render( renderer, scene, camera ) {\n\n\t\t\tscope.visible = false;\n\n\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\t\t\tvar currentXrEnabled = renderer.xr.enabled;\n\t\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// restore viewport\n\n\t\t\tvar viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t}\n\n\t\t//\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t// ensure refractors are rendered only once per frame\n\n\t\t\tif ( camera.userData.refractor === true ) return;\n\n\t\t\t// avoid rendering when the refractor is viewed from behind\n\n\t\t\tif ( ! visible( camera ) === true ) return;\n\n\t\t\t// update\n\n\t\t\tupdateRefractorPlane();\n\n\t\t\tupdateTextureMatrix( camera );\n\n\t\t\tupdateVirtualCamera( camera );\n\n\t\t\trender( renderer, scene, camera );\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t};\n\n\tTHREE.Refractor.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.Refractor.prototype.constructor = THREE.Refractor;\n\n\tTHREE.Refractor.RefractorShader = {\n\n\t\tuniforms: {\n\n\t\t\t'color': {\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'tDiffuse': {\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'textureMatrix': {\n\t\t\t\tvalue: null\n\t\t\t}\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t'uniform mat4 textureMatrix;',\n\n\t\t\t'varying vec4 vUv;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvUv = textureMatrix * vec4( position, 1.0 );',\n\n\t\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\n\t\t\t'uniform vec3 color;',\n\t\t\t'uniform sampler2D tDiffuse;',\n\n\t\t\t'varying vec4 vUv;',\n\n\t\t\t'float blendOverlay( float base, float blend ) {',\n\n\t\t\t'\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\n\n\t\t\t'}',\n\n\t\t\t'vec3 blendOverlay( vec3 base, vec3 blend ) {',\n\n\t\t\t'\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\n\n\t\t\t'}',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvec4 base = texture2DProj( tDiffuse, vUv );',\n\n\t\t\t'\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' )\n\t};\n\t\n\treturn THREE.Refractor;\n});\n\ndefine('skylark-threejs-ex/loaders/TTFLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author gero3 / https://github.com/gero3\n\t * @author tentone / https://github.com/tentone\n\t * @author troy351 / https://github.com/troy351\n\t *\n\t * Requires opentype.js to be included in the project.\n\t * Loads TTF files and converts them into typeface JSON that can be used directly\n\t * to create THREE.Font objects.\n\t */\n\n\tTHREE.TTFLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.reversed = false;\n\n\t};\n\n\n\tTHREE.TTFLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.TTFLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tonLoad( scope.parse( buffer ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( arraybuffer ) {\n\n\t\t\tfunction convert( font, reversed ) {\n\n\t\t\t\tvar round = Math.round;\n\n\t\t\t\tvar glyphs = {};\n\t\t\t\tvar scale = ( 100000 ) / ( ( font.unitsPerEm || 2048 ) * 72 );\n\n\t\t\t\tvar glyphIndexMap = font.encoding.cmap.glyphIndexMap;\n\t\t\t\tvar unicodes = Object.keys( glyphIndexMap );\n\n\t\t\t\tfor ( var i = 0; i < unicodes.length; i ++ ) {\n\n\t\t\t\t\tvar unicode = unicodes[ i ];\n\t\t\t\t\tvar glyph = font.glyphs.glyphs[ glyphIndexMap[ unicode ] ];\n\n\t\t\t\t\tif ( unicode !== undefined ) {\n\n\t\t\t\t\t\tvar token = {\n\t\t\t\t\t\t\tha: round( glyph.advanceWidth * scale ),\n\t\t\t\t\t\t\tx_min: round( glyph.xMin * scale ),\n\t\t\t\t\t\t\tx_max: round( glyph.xMax * scale ),\n\t\t\t\t\t\t\to: ''\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif ( reversed ) {\n\n\t\t\t\t\t\t\tglyph.path.commands = reverseCommands( glyph.path.commands );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tglyph.path.commands.forEach( function ( command ) {\n\n\t\t\t\t\t\t\tif ( command.type.toLowerCase() === 'c' ) {\n\n\t\t\t\t\t\t\t\tcommand.type = 'b';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttoken.o += command.type.toLowerCase() + ' ';\n\n\t\t\t\t\t\t\tif ( command.x !== undefined && command.y !== undefined ) {\n\n\t\t\t\t\t\t\t\ttoken.o += round( command.x * scale ) + ' ' + round( command.y * scale ) + ' ';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( command.x1 !== undefined && command.y1 !== undefined ) {\n\n\t\t\t\t\t\t\t\ttoken.o += round( command.x1 * scale ) + ' ' + round( command.y1 * scale ) + ' ';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( command.x2 !== undefined && command.y2 !== undefined ) {\n\n\t\t\t\t\t\t\t\ttoken.o += round( command.x2 * scale ) + ' ' + round( command.y2 * scale ) + ' ';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tglyphs[ String.fromCodePoint( glyph.unicode ) ] = token;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tglyphs: glyphs,\n\t\t\t\t\tfamilyName: font.getEnglishName( 'fullName' ),\n\t\t\t\t\tascender: round( font.ascender * scale ),\n\t\t\t\t\tdescender: round( font.descender * scale ),\n\t\t\t\t\tunderlinePosition: font.tables.post.underlinePosition,\n\t\t\t\t\tunderlineThickness: font.tables.post.underlineThickness,\n\t\t\t\t\tboundingBox: {\n\t\t\t\t\t\txMin: font.tables.head.xMin,\n\t\t\t\t\t\txMax: font.tables.head.xMax,\n\t\t\t\t\t\tyMin: font.tables.head.yMin,\n\t\t\t\t\t\tyMax: font.tables.head.yMax\n\t\t\t\t\t},\n\t\t\t\t\tresolution: 1000,\n\t\t\t\t\toriginal_font_information: font.tables.name\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction reverseCommands( commands ) {\n\n\t\t\t\tvar paths = [];\n\t\t\t\tvar path;\n\n\t\t\t\tcommands.forEach( function ( c ) {\n\n\t\t\t\t\tif ( c.type.toLowerCase() === 'm' ) {\n\n\t\t\t\t\t\tpath = [ c ];\n\t\t\t\t\t\tpaths.push( path );\n\n\t\t\t\t\t} else if ( c.type.toLowerCase() !== 'z' ) {\n\n\t\t\t\t\t\tpath.push( c );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tvar reversed = [];\n\n\t\t\t\tpaths.forEach( function ( p ) {\n\n\t\t\t\t\tvar result = {\n\t\t\t\t\t\ttype: 'm',\n\t\t\t\t\t\tx: p[ p.length - 1 ].x,\n\t\t\t\t\t\ty: p[ p.length - 1 ].y\n\t\t\t\t\t};\n\n\t\t\t\t\treversed.push( result );\n\n\t\t\t\t\tfor ( var i = p.length - 1; i > 0; i -- ) {\n\n\t\t\t\t\t\tvar command = p[ i ];\n\t\t\t\t\t\tvar result = { type: command.type };\n\n\t\t\t\t\t\tif ( command.x2 !== undefined && command.y2 !== undefined ) {\n\n\t\t\t\t\t\t\tresult.x1 = command.x2;\n\t\t\t\t\t\t\tresult.y1 = command.y2;\n\t\t\t\t\t\t\tresult.x2 = command.x1;\n\t\t\t\t\t\t\tresult.y2 = command.y1;\n\n\t\t\t\t\t\t} else if ( command.x1 !== undefined && command.y1 !== undefined ) {\n\n\t\t\t\t\t\t\tresult.x1 = command.x1;\n\t\t\t\t\t\t\tresult.y1 = command.y1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult.x = p[ i - 1 ].x;\n\t\t\t\t\t\tresult.y = p[ i - 1 ].y;\n\t\t\t\t\t\treversed.push( result );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn reversed;\n\n\t\t\t}\n\n\t\t\tif ( typeof opentype === 'undefined' ) {\n\n\t\t\t\tconsole.warn( 'THREE.TTFLoader: The loader requires opentype.js. Make sure it\\'s included before using the loader.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\treturn convert( opentype.parse( arraybuffer ), this.reversed );\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.TTFLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/3MFLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author technohippy / https://github.com/technohippy\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * 3D Manufacturing Format (3MF) specification: https://3mf.io/specification/\n\t *\n\t * The following features from the core specification are supported:\n\t *\n\t * - 3D Models\n\t * - Object Resources (Meshes and Components)\n\t * - Material Resources (Base Materials)\n\t *\n\t * 3MF Materials and Properties Extension are only partially supported.\n\t *\n\t * - Texture 2D\n\t * - Texture 2D Groups\n\t * - Color Groups (Vertex Colors)\n\t * - Metallic Display Properties (PBR)\n\t */\n\n\tTHREE.ThreeMFLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.availableExtensions = [];\n\n\t};\n\n\tTHREE.ThreeMFLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.ThreeMFLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tonLoad( scope.parse( buffer ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data ) {\n\n\t\t\tvar scope = this;\n\t\t\tvar textureLoader = new THREE.TextureLoader( this.manager );\n\n\t\t\tfunction loadDocument( data ) {\n\n\t\t\t\tvar zip = null;\n\t\t\t\tvar file = null;\n\n\t\t\t\tvar relsName;\n\t\t\t\tvar modelRelsName;\n\t\t\t\tvar modelPartNames = [];\n\t\t\t\tvar printTicketPartNames = [];\n\t\t\t\tvar texturesPartNames = [];\n\t\t\t\tvar otherPartNames = [];\n\n\t\t\t\tvar rels;\n\t\t\t\tvar modelRels;\n\t\t\t\tvar modelParts = {};\n\t\t\t\tvar printTicketParts = {};\n\t\t\t\tvar texturesParts = {};\n\t\t\t\tvar otherParts = {};\n\n\t\t\t\ttry {\n\n\t\t\t\t\tzip = new JSZip( data ); // eslint-disable-line no-undef\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( e instanceof ReferenceError ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.3MFLoader: jszip missing and file is compressed.' );\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( file in zip.files ) {\n\n\t\t\t\t\tif ( file.match( /\\_rels\\/.rels$/ ) ) {\n\n\t\t\t\t\t\trelsName = file;\n\n\t\t\t\t\t} else if ( file.match( /3D\\/_rels\\/.*\\.model\\.rels$/ ) ) {\n\n\t\t\t\t\t\tmodelRelsName = file;\n\n\t\t\t\t\t} else if ( file.match( /^3D\\/.*\\.model$/ ) ) {\n\n\t\t\t\t\t\tmodelPartNames.push( file );\n\n\t\t\t\t\t} else if ( file.match( /^3D\\/Metadata\\/.*\\.xml$/ ) ) {\n\n\t\t\t\t\t\tprintTicketPartNames.push( file );\n\n\t\t\t\t\t} else if ( file.match( /^3D\\/Textures?\\/.*/ ) ) {\n\n\t\t\t\t\t\ttexturesPartNames.push( file );\n\n\t\t\t\t\t} else if ( file.match( /^3D\\/Other\\/.*/ ) ) {\n\n\t\t\t\t\t\totherPartNames.push( file );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar relsView = new Uint8Array( zip.file( relsName ).asArrayBuffer() );\n\t\t\t\tvar relsFileText = THREE.LoaderUtils.decodeText( relsView );\n\t\t\t\trels = parseRelsXml( relsFileText );\n\n\t\t\t\t//\n\n\t\t\t\tif ( modelRelsName ) {\n\n\t\t\t\t\tvar relsView = new Uint8Array( zip.file( modelRelsName ).asArrayBuffer() );\n\t\t\t\t\tvar relsFileText = THREE.LoaderUtils.decodeText( relsView );\n\t\t\t\t\tmodelRels = parseRelsXml( relsFileText );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tfor ( var i = 0; i < modelPartNames.length; i ++ ) {\n\n\t\t\t\t\tvar modelPart = modelPartNames[ i ];\n\t\t\t\t\tvar view = new Uint8Array( zip.file( modelPart ).asArrayBuffer() );\n\n\t\t\t\t\tvar fileText = THREE.LoaderUtils.decodeText( view );\n\t\t\t\t\tvar xmlData = new DOMParser().parseFromString( fileText, 'application/xml' );\n\n\t\t\t\t\tif ( xmlData.documentElement.nodeName.toLowerCase() !== 'model' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.3MFLoader: Error loading 3MF - no 3MF document found: ', modelPart );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar modelNode = xmlData.querySelector( 'model' );\n\t\t\t\t\tvar extensions = {};\n\n\t\t\t\t\tfor ( var i = 0; i < modelNode.attributes.length; i ++ ) {\n\n\t\t\t\t\t\tvar attr = modelNode.attributes[ i ];\n\t\t\t\t\t\tif ( attr.name.match( /^xmlns:(.+)$/ ) ) {\n\n\t\t\t\t\t\t\textensions[ attr.value ] = RegExp.$1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar modelData = parseModelNode( modelNode );\n\t\t\t\t\tmodelData[ 'xml' ] = modelNode;\n\n\t\t\t\t\tif ( 0 < Object.keys( extensions ).length ) {\n\n\t\t\t\t\t\tmodelData[ 'extensions' ] = extensions;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmodelParts[ modelPart ] = modelData;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tfor ( var i = 0; i < texturesPartNames.length; i ++ ) {\n\n\t\t\t\t\tvar texturesPartName = texturesPartNames[ i ];\n\t\t\t\t\ttexturesParts[ texturesPartName ] = zip.file( texturesPartName ).asArrayBuffer();\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\trels: rels,\n\t\t\t\t\tmodelRels: modelRels,\n\t\t\t\t\tmodel: modelParts,\n\t\t\t\t\tprintTicket: printTicketParts,\n\t\t\t\t\ttexture: texturesParts,\n\t\t\t\t\tother: otherParts\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction parseRelsXml( relsFileText ) {\n\n\t\t\t\tvar relationships = [];\n\n\t\t\t\tvar relsXmlData = new DOMParser().parseFromString( relsFileText, 'application/xml' );\n\n\t\t\t\tvar relsNodes = relsXmlData.querySelectorAll( 'Relationship' );\n\n\t\t\t\tfor ( var i = 0; i < relsNodes.length; i ++ ) {\n\n\t\t\t\t\tvar relsNode = relsNodes[ i ];\n\n\t\t\t\t\tvar relationship = {\n\t\t\t\t\t\ttarget: relsNode.getAttribute( 'Target' ), //required\n\t\t\t\t\t\tid: relsNode.getAttribute( 'Id' ), //required\n\t\t\t\t\t\ttype: relsNode.getAttribute( 'Type' ) //required\n\t\t\t\t\t};\n\n\t\t\t\t\trelationships.push( relationship );\n\n\t\t\t\t}\n\n\t\t\t\treturn relationships;\n\n\t\t\t}\n\n\t\t\tfunction parseMetadataNodes( metadataNodes ) {\n\n\t\t\t\tvar metadataData = {};\n\n\t\t\t\tfor ( var i = 0; i < metadataNodes.length; i ++ ) {\n\n\t\t\t\t\tvar metadataNode = metadataNodes[ i ];\n\t\t\t\t\tvar name = metadataNode.getAttribute( 'name' );\n\t\t\t\t\tvar validNames = [\n\t\t\t\t\t\t'Title',\n\t\t\t\t\t\t'Designer',\n\t\t\t\t\t\t'Description',\n\t\t\t\t\t\t'Copyright',\n\t\t\t\t\t\t'LicenseTerms',\n\t\t\t\t\t\t'Rating',\n\t\t\t\t\t\t'CreationDate',\n\t\t\t\t\t\t'ModificationDate'\n\t\t\t\t\t];\n\n\t\t\t\t\tif ( 0 <= validNames.indexOf( name ) ) {\n\n\t\t\t\t\t\tmetadataData[ name ] = metadataNode.textContent;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn metadataData;\n\n\t\t\t}\n\n\t\t\tfunction parseBasematerialsNode( basematerialsNode ) {\n\n\t\t\t\tvar basematerialsData = {\n\t\t\t\t\tid: basematerialsNode.getAttribute( 'id' ), // required\n\t\t\t\t\tbasematerials: []\n\t\t\t\t};\n\n\t\t\t\tvar basematerialNodes = basematerialsNode.querySelectorAll( 'base' );\n\n\t\t\t\tfor ( var i = 0; i < basematerialNodes.length; i ++ ) {\n\n\t\t\t\t\tvar basematerialNode = basematerialNodes[ i ];\n\t\t\t\t\tvar basematerialData = parseBasematerialNode( basematerialNode );\n\t\t\t\t\tbasematerialData.index = i; // the order and count of the material nodes form an implicit 0-based index\n\t\t\t\t\tbasematerialsData.basematerials.push( basematerialData );\n\n\t\t\t\t}\n\n\t\t\t\treturn basematerialsData;\n\n\t\t\t}\n\n\t\t\tfunction parseTexture2DNode( texture2DNode ) {\n\n\t\t\t\tvar texture2dData = {\n\t\t\t\t\tid: texture2DNode.getAttribute( 'id' ), // required\n\t\t\t\t\tpath: texture2DNode.getAttribute( 'path' ), // required\n\t\t\t\t\tcontenttype: texture2DNode.getAttribute( 'contenttype' ), // required\n\t\t\t\t\ttilestyleu: texture2DNode.getAttribute( 'tilestyleu' ),\n\t\t\t\t\ttilestylev: texture2DNode.getAttribute( 'tilestylev' ),\n\t\t\t\t\tfilter: texture2DNode.getAttribute( 'filter' ),\n\t\t\t\t};\n\n\t\t\t\treturn texture2dData;\n\n\t\t\t}\n\n\t\t\tfunction parseTextures2DGroupNode( texture2DGroupNode ) {\n\n\t\t\t\tvar texture2DGroupData = {\n\t\t\t\t\tid: texture2DGroupNode.getAttribute( 'id' ), // required\n\t\t\t\t\ttexid: texture2DGroupNode.getAttribute( 'texid' ), // required\n\t\t\t\t\tdisplaypropertiesid: texture2DGroupNode.getAttribute( 'displaypropertiesid' )\n\t\t\t\t};\n\n\t\t\t\tvar tex2coordNodes = texture2DGroupNode.querySelectorAll( 'tex2coord' );\n\n\t\t\t\tvar uvs = [];\n\n\t\t\t\tfor ( var i = 0; i < tex2coordNodes.length; i ++ ) {\n\n\t\t\t\t\tvar tex2coordNode = tex2coordNodes[ i ];\n\t\t\t\t\tvar u = tex2coordNode.getAttribute( 'u' );\n\t\t\t\t\tvar v = tex2coordNode.getAttribute( 'v' );\n\n\t\t\t\t\tuvs.push( parseFloat( u ), parseFloat( v ) );\n\n\t\t\t\t}\n\n\t\t\t\ttexture2DGroupData[ 'uvs' ] = new Float32Array( uvs );\n\n\t\t\t\treturn texture2DGroupData;\n\n\t\t\t}\n\n\t\t\tfunction parseColorGroupNode( colorGroupNode ) {\n\n\t\t\t\tvar colorGroupData = {\n\t\t\t\t\tid: colorGroupNode.getAttribute( 'id' ), // required\n\t\t\t\t\tdisplaypropertiesid: colorGroupNode.getAttribute( 'displaypropertiesid' )\n\t\t\t\t};\n\n\t\t\t\tvar colorNodes = colorGroupNode.querySelectorAll( 'color' );\n\n\t\t\t\tvar colors = [];\n\t\t\t\tvar colorObject = new THREE.Color();\n\n\t\t\t\tfor ( var i = 0; i < colorNodes.length; i ++ ) {\n\n\t\t\t\t\tvar colorNode = colorNodes[ i ];\n\t\t\t\t\tvar color = colorNode.getAttribute( 'color' );\n\n\t\t\t\t\tcolorObject.setStyle( color.substring( 0, 7 ) );\n\t\t\t\t\tcolorObject.convertSRGBToLinear(); // color is in sRGB\n\n\t\t\t\t\tcolors.push( colorObject.r, colorObject.g, colorObject.b );\n\n\t\t\t\t}\n\n\t\t\t\tcolorGroupData[ 'colors' ] = new Float32Array( colors );\n\n\t\t\t\treturn colorGroupData;\n\n\t\t\t}\n\n\t\t\tfunction parseMetallicDisplaypropertiesNode( metallicDisplaypropetiesNode ) {\n\n\t\t\t\tvar metallicDisplaypropertiesData = {\n\t\t\t\t\tid: metallicDisplaypropetiesNode.getAttribute( 'id' ) // required\n\t\t\t\t};\n\n\t\t\t\tvar metallicNodes = metallicDisplaypropetiesNode.querySelectorAll( 'pbmetallic' );\n\n\t\t\t\tvar metallicData = [];\n\n\t\t\t\tfor ( var i = 0; i < metallicNodes.length; i ++ ) {\n\n\t\t\t\t\tvar metallicNode = metallicNodes[ i ];\n\n\t\t\t\t\tmetallicData.push( {\n\t\t\t\t\t\tname: metallicNode.getAttribute( 'name' ), // required\n\t\t\t\t\t\tmetallicness: parseFloat( metallicNode.getAttribute( 'metallicness' ) ), // required\n\t\t\t\t\t\troughness: parseFloat( metallicNode.getAttribute( 'roughness' ) ) // required\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tmetallicDisplaypropertiesData.data = metallicData;\n\n\t\t\t\treturn metallicDisplaypropertiesData;\n\n\t\t\t}\n\n\t\t\tfunction parseBasematerialNode( basematerialNode ) {\n\n\t\t\t\tvar basematerialData = {};\n\n\t\t\t\tbasematerialData[ 'name' ] = basematerialNode.getAttribute( 'name' ); // required\n\t\t\t\tbasematerialData[ 'displaycolor' ] = basematerialNode.getAttribute( 'displaycolor' ); // required\n\t\t\t\tbasematerialData[ 'displaypropertiesid' ] = basematerialNode.getAttribute( 'displaypropertiesid' );\n\n\t\t\t\treturn basematerialData;\n\n\t\t\t}\n\n\t\t\tfunction parseMeshNode( meshNode ) {\n\n\t\t\t\tvar meshData = {};\n\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar vertexNodes = meshNode.querySelectorAll( 'vertices vertex' );\n\n\t\t\t\tfor ( var i = 0; i < vertexNodes.length; i ++ ) {\n\n\t\t\t\t\tvar vertexNode = vertexNodes[ i ];\n\t\t\t\t\tvar x = vertexNode.getAttribute( 'x' );\n\t\t\t\t\tvar y = vertexNode.getAttribute( 'y' );\n\t\t\t\t\tvar z = vertexNode.getAttribute( 'z' );\n\n\t\t\t\t\tvertices.push( parseFloat( x ), parseFloat( y ), parseFloat( z ) );\n\n\t\t\t\t}\n\n\t\t\t\tmeshData[ 'vertices' ] = new Float32Array( vertices );\n\n\t\t\t\tvar triangleProperties = [];\n\t\t\t\tvar triangles = [];\n\t\t\t\tvar triangleNodes = meshNode.querySelectorAll( 'triangles triangle' );\n\n\t\t\t\tfor ( var i = 0; i < triangleNodes.length; i ++ ) {\n\n\t\t\t\t\tvar triangleNode = triangleNodes[ i ];\n\t\t\t\t\tvar v1 = triangleNode.getAttribute( 'v1' );\n\t\t\t\t\tvar v2 = triangleNode.getAttribute( 'v2' );\n\t\t\t\t\tvar v3 = triangleNode.getAttribute( 'v3' );\n\t\t\t\t\tvar p1 = triangleNode.getAttribute( 'p1' );\n\t\t\t\t\tvar p2 = triangleNode.getAttribute( 'p2' );\n\t\t\t\t\tvar p3 = triangleNode.getAttribute( 'p3' );\n\t\t\t\t\tvar pid = triangleNode.getAttribute( 'pid' );\n\n\t\t\t\t\tvar triangleProperty = {};\n\n\t\t\t\t\ttriangleProperty[ 'v1' ] = parseInt( v1, 10 );\n\t\t\t\t\ttriangleProperty[ 'v2' ] = parseInt( v2, 10 );\n\t\t\t\t\ttriangleProperty[ 'v3' ] = parseInt( v3, 10 );\n\n\t\t\t\t\ttriangles.push( triangleProperty[ 'v1' ], triangleProperty[ 'v2' ], triangleProperty[ 'v3' ] );\n\n\t\t\t\t\t// optional\n\n\t\t\t\t\tif ( p1 ) {\n\n\t\t\t\t\t\ttriangleProperty[ 'p1' ] = parseInt( p1, 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( p2 ) {\n\n\t\t\t\t\t\ttriangleProperty[ 'p2' ] = parseInt( p2, 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( p3 ) {\n\n\t\t\t\t\t\ttriangleProperty[ 'p3' ] = parseInt( p3, 10 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( pid ) {\n\n\t\t\t\t\t\ttriangleProperty[ 'pid' ] = pid;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 0 < Object.keys( triangleProperty ).length ) {\n\n\t\t\t\t\t\ttriangleProperties.push( triangleProperty );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmeshData[ 'triangleProperties' ] = triangleProperties;\n\t\t\t\tmeshData[ 'triangles' ] = new Uint32Array( triangles );\n\n\t\t\t\treturn meshData;\n\n\t\t\t}\n\n\t\t\tfunction parseComponentsNode( componentsNode ) {\n\n\t\t\t\tvar components = [];\n\n\t\t\t\tvar componentNodes = componentsNode.querySelectorAll( 'component' );\n\n\t\t\t\tfor ( var i = 0; i < componentNodes.length; i ++ ) {\n\n\t\t\t\t\tvar componentNode = componentNodes[ i ];\n\t\t\t\t\tvar componentData = parseComponentNode( componentNode );\n\t\t\t\t\tcomponents.push( componentData );\n\n\t\t\t\t}\n\n\t\t\t\treturn components;\n\n\t\t\t}\n\n\t\t\tfunction parseComponentNode( componentNode ) {\n\n\t\t\t\tvar componentData = {};\n\n\t\t\t\tcomponentData[ 'objectId' ] = componentNode.getAttribute( 'objectid' ); // required\n\n\t\t\t\tvar transform = componentNode.getAttribute( 'transform' );\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tcomponentData[ 'transform' ] = parseTransform( transform );\n\n\t\t\t\t}\n\n\t\t\t\treturn componentData;\n\n\t\t\t}\n\n\t\t\tfunction parseTransform( transform ) {\n\n\t\t\t\tvar t = [];\n\t\t\t\ttransform.split( ' ' ).forEach( function ( s ) {\n\n\t\t\t\t\tt.push( parseFloat( s ) );\n\n\t\t\t\t} );\n\n\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\tmatrix.set(\n\t\t\t\t\tt[ 0 ], t[ 3 ], t[ 6 ], t[ 9 ],\n\t\t\t\t\tt[ 1 ], t[ 4 ], t[ 7 ], t[ 10 ],\n\t\t\t\t\tt[ 2 ], t[ 5 ], t[ 8 ], t[ 11 ],\n\t\t\t\t\t 0.0, 0.0, 0.0, 1.0\n\t\t\t\t);\n\n\t\t\t\treturn matrix;\n\n\t\t\t}\n\n\t\t\tfunction parseObjectNode( objectNode ) {\n\n\t\t\t\tvar objectData = {\n\t\t\t\t\ttype: objectNode.getAttribute( 'type' )\n\t\t\t\t};\n\n\t\t\t\tvar id = objectNode.getAttribute( 'id' );\n\n\t\t\t\tif ( id ) {\n\n\t\t\t\t\tobjectData[ 'id' ] = id;\n\n\t\t\t\t}\n\n\t\t\t\tvar pid = objectNode.getAttribute( 'pid' );\n\n\t\t\t\tif ( pid ) {\n\n\t\t\t\t\tobjectData[ 'pid' ] = pid;\n\n\t\t\t\t}\n\n\t\t\t\tvar pindex = objectNode.getAttribute( 'pindex' );\n\n\t\t\t\tif ( pindex ) {\n\n\t\t\t\t\tobjectData[ 'pindex' ] = pindex;\n\n\t\t\t\t}\n\n\t\t\t\tvar thumbnail = objectNode.getAttribute( 'thumbnail' );\n\n\t\t\t\tif ( thumbnail ) {\n\n\t\t\t\t\tobjectData[ 'thumbnail' ] = thumbnail;\n\n\t\t\t\t}\n\n\t\t\t\tvar partnumber = objectNode.getAttribute( 'partnumber' );\n\n\t\t\t\tif ( partnumber ) {\n\n\t\t\t\t\tobjectData[ 'partnumber' ] = partnumber;\n\n\t\t\t\t}\n\n\t\t\t\tvar name = objectNode.getAttribute( 'name' );\n\n\t\t\t\tif ( name ) {\n\n\t\t\t\t\tobjectData[ 'name' ] = name;\n\n\t\t\t\t}\n\n\t\t\t\tvar meshNode = objectNode.querySelector( 'mesh' );\n\n\t\t\t\tif ( meshNode ) {\n\n\t\t\t\t\tobjectData[ 'mesh' ] = parseMeshNode( meshNode );\n\n\t\t\t\t}\n\n\t\t\t\tvar componentsNode = objectNode.querySelector( 'components' );\n\n\t\t\t\tif ( componentsNode ) {\n\n\t\t\t\t\tobjectData[ 'components' ] = parseComponentsNode( componentsNode );\n\n\t\t\t\t}\n\n\t\t\t\treturn objectData;\n\n\t\t\t}\n\n\t\t\tfunction parseResourcesNode( resourcesNode ) {\n\n\t\t\t\tvar resourcesData = {};\n\n\t\t\t\tresourcesData[ 'basematerials' ] = {};\n\t\t\t\tvar basematerialsNodes = resourcesNode.querySelectorAll( 'basematerials' );\n\n\t\t\t\tfor ( var i = 0; i < basematerialsNodes.length; i ++ ) {\n\n\t\t\t\t\tvar basematerialsNode = basematerialsNodes[ i ];\n\t\t\t\t\tvar basematerialsData = parseBasematerialsNode( basematerialsNode );\n\t\t\t\t\tresourcesData[ 'basematerials' ][ basematerialsData[ 'id' ] ] = basematerialsData;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tresourcesData[ 'texture2d' ] = {};\n\t\t\t\tvar textures2DNodes = resourcesNode.querySelectorAll( 'texture2d' );\n\n\t\t\t\tfor ( var i = 0; i < textures2DNodes.length; i ++ ) {\n\n\t\t\t\t\tvar textures2DNode = textures2DNodes[ i ];\n\t\t\t\t\tvar texture2DData = parseTexture2DNode( textures2DNode );\n\t\t\t\t\tresourcesData[ 'texture2d' ][ texture2DData[ 'id' ] ] = texture2DData;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tresourcesData[ 'colorgroup' ] = {};\n\t\t\t\tvar colorGroupNodes = resourcesNode.querySelectorAll( 'colorgroup' );\n\n\t\t\t\tfor ( var i = 0; i < colorGroupNodes.length; i ++ ) {\n\n\t\t\t\t\tvar colorGroupNode = colorGroupNodes[ i ];\n\t\t\t\t\tvar colorGroupData = parseColorGroupNode( colorGroupNode );\n\t\t\t\t\tresourcesData[ 'colorgroup' ][ colorGroupData[ 'id' ] ] = colorGroupData;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tresourcesData[ 'pbmetallicdisplayproperties' ] = {};\n\t\t\t\tvar pbmetallicdisplaypropertiesNodes = resourcesNode.querySelectorAll( 'pbmetallicdisplayproperties' );\n\n\t\t\t\tfor ( var i = 0; i < pbmetallicdisplaypropertiesNodes.length; i ++ ) {\n\n\t\t\t\t\tvar pbmetallicdisplaypropertiesNode = pbmetallicdisplaypropertiesNodes[ i ];\n\t\t\t\t\tvar pbmetallicdisplaypropertiesData = parseMetallicDisplaypropertiesNode( pbmetallicdisplaypropertiesNode );\n\t\t\t\t\tresourcesData[ 'pbmetallicdisplayproperties' ][ pbmetallicdisplaypropertiesData[ 'id' ] ] = pbmetallicdisplaypropertiesData;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tresourcesData[ 'texture2dgroup' ] = {};\n\t\t\t\tvar textures2DGroupNodes = resourcesNode.querySelectorAll( 'texture2dgroup' );\n\n\t\t\t\tfor ( var i = 0; i < textures2DGroupNodes.length; i ++ ) {\n\n\t\t\t\t\tvar textures2DGroupNode = textures2DGroupNodes[ i ];\n\t\t\t\t\tvar textures2DGroupData = parseTextures2DGroupNode( textures2DGroupNode );\n\t\t\t\t\tresourcesData[ 'texture2dgroup' ][ textures2DGroupData[ 'id' ] ] = textures2DGroupData;\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tresourcesData[ 'object' ] = {};\n\t\t\t\tvar objectNodes = resourcesNode.querySelectorAll( 'object' );\n\n\t\t\t\tfor ( var i = 0; i < objectNodes.length; i ++ ) {\n\n\t\t\t\t\tvar objectNode = objectNodes[ i ];\n\t\t\t\t\tvar objectData = parseObjectNode( objectNode );\n\t\t\t\t\tresourcesData[ 'object' ][ objectData[ 'id' ] ] = objectData;\n\n\t\t\t\t}\n\n\t\t\t\treturn resourcesData;\n\n\t\t\t}\n\n\t\t\tfunction parseBuildNode( buildNode ) {\n\n\t\t\t\tvar buildData = [];\n\t\t\t\tvar itemNodes = buildNode.querySelectorAll( 'item' );\n\n\t\t\t\tfor ( var i = 0; i < itemNodes.length; i ++ ) {\n\n\t\t\t\t\tvar itemNode = itemNodes[ i ];\n\t\t\t\t\tvar buildItem = {\n\t\t\t\t\t\tobjectId: itemNode.getAttribute( 'objectid' )\n\t\t\t\t\t};\n\t\t\t\t\tvar transform = itemNode.getAttribute( 'transform' );\n\n\t\t\t\t\tif ( transform ) {\n\n\t\t\t\t\t\tbuildItem[ 'transform' ] = parseTransform( transform );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbuildData.push( buildItem );\n\n\t\t\t\t}\n\n\t\t\t\treturn buildData;\n\n\t\t\t}\n\n\t\t\tfunction parseModelNode( modelNode ) {\n\n\t\t\t\tvar modelData = { unit: modelNode.getAttribute( 'unit' ) || 'millimeter' };\n\t\t\t\tvar metadataNodes = modelNode.querySelectorAll( 'metadata' );\n\n\t\t\t\tif ( metadataNodes ) {\n\n\t\t\t\t\tmodelData[ 'metadata' ] = parseMetadataNodes( metadataNodes );\n\n\t\t\t\t}\n\n\t\t\t\tvar resourcesNode = modelNode.querySelector( 'resources' );\n\n\t\t\t\tif ( resourcesNode ) {\n\n\t\t\t\t\tmodelData[ 'resources' ] = parseResourcesNode( resourcesNode );\n\n\t\t\t\t}\n\n\t\t\t\tvar buildNode = modelNode.querySelector( 'build' );\n\n\t\t\t\tif ( buildNode ) {\n\n\t\t\t\t\tmodelData[ 'build' ] = parseBuildNode( buildNode );\n\n\t\t\t\t}\n\n\t\t\t\treturn modelData;\n\n\t\t\t}\n\n\t\t\tfunction buildTexture( texture2dgroup, objects, modelData, textureData ) {\n\n\t\t\t\tvar texid = texture2dgroup.texid;\n\t\t\t\tvar texture2ds = modelData.resources.texture2d;\n\t\t\t\tvar texture2d = texture2ds[ texid ];\n\n\t\t\t\tif ( texture2d ) {\n\n\t\t\t\t\tvar data = textureData[ texture2d.path ];\n\t\t\t\t\tvar type = texture2d.contenttype;\n\n\t\t\t\t\tvar blob = new Blob( [ data ], { type: type } );\n\t\t\t\t\tvar sourceURI = URL.createObjectURL( blob );\n\n\t\t\t\t\tvar texture = textureLoader.load( sourceURI, function () {\n\n\t\t\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\ttexture.encoding = THREE.sRGBEncoding;\n\n\t\t\t\t\t// texture parameters\n\n\t\t\t\t\tswitch ( texture2d.tilestyleu ) {\n\n\t\t\t\t\t\tcase 'wrap':\n\t\t\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'mirror':\n\t\t\t\t\t\t\ttexture.wrapS = THREE.MirroredRepeatWrapping;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'none':\n\t\t\t\t\t\tcase 'clamp':\n\t\t\t\t\t\t\ttexture.wrapS = THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( texture2d.tilestylev ) {\n\n\t\t\t\t\t\tcase 'wrap':\n\t\t\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'mirror':\n\t\t\t\t\t\t\ttexture.wrapT = THREE.MirroredRepeatWrapping;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'none':\n\t\t\t\t\t\tcase 'clamp':\n\t\t\t\t\t\t\ttexture.wrapT = THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( texture2d.filter ) {\n\n\t\t\t\t\t\tcase 'auto':\n\t\t\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\t\t\ttexture.minFilter = THREE.LinearMipmapLinearFilter;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'linear':\n\t\t\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'nearest':\n\t\t\t\t\t\t\ttexture.magFilter = THREE.NearestFilter;\n\t\t\t\t\t\t\ttexture.minFilter = THREE.NearestFilter;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\t\t\ttexture.minFilter = THREE.LinearMipmapLinearFilter;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn texture;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction buildBasematerialsMeshes( basematerials, triangleProperties, modelData, meshData, textureData, objectData ) {\n\n\t\t\t\tvar objectPindex = objectData.pindex;\n\n\t\t\t\tvar materialMap = {};\n\n\t\t\t\tfor ( var i = 0, l = triangleProperties.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar triangleProperty = triangleProperties[ i ];\n\t\t\t\t\tvar pindex = ( triangleProperty.p1 !== undefined ) ? triangleProperty.p1 : objectPindex;\n\n\t\t\t\t\tif ( materialMap[ pindex ] === undefined ) materialMap[ pindex ] = [];\n\n\t\t\t\t\tmaterialMap[ pindex ].push( triangleProperty );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar keys = Object.keys( materialMap );\n\t\t\t\tvar meshes = [];\n\n\t\t\t\tfor ( var i = 0, l = keys.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar materialIndex = keys[ i ];\n\t\t\t\t\tvar trianglePropertiesProps = materialMap[ materialIndex ];\n\t\t\t\t\tvar basematerialData = basematerials.basematerials[ materialIndex ];\n\t\t\t\t\tvar material = getBuild( basematerialData, objects, modelData, textureData, objectData, buildBasematerial );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\t\tvar positionData = [];\n\n\t\t\t\t\tvar vertices = meshData.vertices;\n\n\t\t\t\t\tfor ( var j = 0, jl = trianglePropertiesProps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar triangleProperty = trianglePropertiesProps[ j ];\n\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 0 ] );\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 1 ] );\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 2 ] );\n\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 0 ] );\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 1 ] );\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 2 ] );\n\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 0 ] );\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 1 ] );\n\t\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 2 ] );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positionData, 3 ) );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tvar mesh = new THREE.Mesh( geometry, material );\n\t\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\t}\n\n\t\t\t\treturn meshes;\n\n\t\t\t}\n\n\t\t\tfunction buildTexturedMesh( texture2dgroup, triangleProperties, modelData, meshData, textureData, objectData ) {\n\n\t\t\t\t// geometry\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\tvar positionData = [];\n\t\t\t\tvar uvData = [];\n\n\t\t\t\tvar vertices = meshData.vertices;\n\t\t\t\tvar uvs = texture2dgroup.uvs;\n\n\t\t\t\tfor ( var i = 0, l = triangleProperties.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar triangleProperty = triangleProperties[ i ];\n\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 0 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 1 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v1 * 3 ) + 2 ] );\n\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 0 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 1 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v2 * 3 ) + 2 ] );\n\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 0 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 1 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( triangleProperty.v3 * 3 ) + 2 ] );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tuvData.push( uvs[ ( triangleProperty.p1 * 2 ) + 0 ] );\n\t\t\t\t\tuvData.push( uvs[ ( triangleProperty.p1 * 2 ) + 1 ] );\n\n\t\t\t\t\tuvData.push( uvs[ ( triangleProperty.p2 * 2 ) + 0 ] );\n\t\t\t\t\tuvData.push( uvs[ ( triangleProperty.p2 * 2 ) + 1 ] );\n\n\t\t\t\t\tuvData.push( uvs[ ( triangleProperty.p3 * 2 ) + 0 ] );\n\t\t\t\t\tuvData.push( uvs[ ( triangleProperty.p3 * 2 ) + 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positionData, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvData, 2 ) );\n\n\t\t\t\t// material\n\n\t\t\t\tvar texture = getBuild( texture2dgroup, objects, modelData, textureData, objectData, buildTexture );\n\n\t\t\t\tvar material = new THREE.MeshPhongMaterial( { map: texture, flatShading: true } );\n\n\t\t\t\t// mesh\n\n\t\t\t\tvar mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\treturn mesh;\n\n\t\t\t}\n\n\t\t\tfunction buildVertexColorMesh( colorgroup, triangleProperties, modelData, meshData ) {\n\n\t\t\t\t// geometry\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\tvar positionData = [];\n\t\t\t\tvar colorData = [];\n\n\t\t\t\tvar vertices = meshData.vertices;\n\t\t\t\tvar colors = colorgroup.colors;\n\n\t\t\t\tfor ( var i = 0, l = triangleProperties.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar triangleProperty = triangleProperties[ i ];\n\n\t\t\t\t\tvar v1 = triangleProperty.v1;\n\t\t\t\t\tvar v2 = triangleProperty.v2;\n\t\t\t\t\tvar v3 = triangleProperty.v3;\n\n\t\t\t\t\tpositionData.push( vertices[ ( v1 * 3 ) + 0 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( v1 * 3 ) + 1 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( v1 * 3 ) + 2 ] );\n\n\t\t\t\t\tpositionData.push( vertices[ ( v2 * 3 ) + 0 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( v2 * 3 ) + 1 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( v2 * 3 ) + 2 ] );\n\n\t\t\t\t\tpositionData.push( vertices[ ( v3 * 3 ) + 0 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( v3 * 3 ) + 1 ] );\n\t\t\t\t\tpositionData.push( vertices[ ( v3 * 3 ) + 2 ] );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tvar p1 = triangleProperty.p1;\n\t\t\t\t\tvar p2 = triangleProperty.p2;\n\t\t\t\t\tvar p3 = triangleProperty.p3;\n\n\t\t\t\t\tcolorData.push( colors[ ( p1 * 3 ) + 0 ] );\n\t\t\t\t\tcolorData.push( colors[ ( p1 * 3 ) + 1 ] );\n\t\t\t\t\tcolorData.push( colors[ ( p1 * 3 ) + 2 ] );\n\n\t\t\t\t\tcolorData.push( colors[ ( ( p2 || p1 ) * 3 ) + 0 ] );\n\t\t\t\t\tcolorData.push( colors[ ( ( p2 || p1 ) * 3 ) + 1 ] );\n\t\t\t\t\tcolorData.push( colors[ ( ( p2 || p1 ) * 3 ) + 2 ] );\n\n\t\t\t\t\tcolorData.push( colors[ ( ( p3 || p1 ) * 3 ) + 0 ] );\n\t\t\t\t\tcolorData.push( colors[ ( ( p3 || p1 ) * 3 ) + 1 ] );\n\t\t\t\t\tcolorData.push( colors[ ( ( p3 || p1 ) * 3 ) + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positionData, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colorData, 3 ) );\n\n\t\t\t\t// material\n\n\t\t\t\tvar material = new THREE.MeshPhongMaterial( { vertexColors: true, flatShading: true } );\n\n\t\t\t\t// mesh\n\n\t\t\t\tvar mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\treturn mesh;\n\n\t\t\t}\n\n\t\t\tfunction buildDefaultMesh( meshData ) {\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( meshData[ 'triangles' ], 1 ) );\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( meshData[ 'vertices' ], 3 ) );\n\n\t\t\t\tvar material = new THREE.MeshPhongMaterial( { color: 0xaaaaff, flatShading: true } );\n\n\t\t\t\tvar mesh = new THREE.Mesh( geometry, material );\n\n\t\t\t\treturn mesh;\n\n\t\t\t}\n\n\t\t\tfunction buildMeshes( resourceMap, modelData, meshData, textureData, objectData ) {\n\n\t\t\t\tvar keys = Object.keys( resourceMap );\n\t\t\t\tvar meshes = [];\n\n\t\t\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar resourceId = keys[ i ];\n\t\t\t\t\tvar triangleProperties = resourceMap[ resourceId ];\n\t\t\t\t\tvar resourceType = getResourceType( resourceId, modelData );\n\n\t\t\t\t\tswitch ( resourceType ) {\n\n\t\t\t\t\t\tcase 'material':\n\t\t\t\t\t\t\tvar basematerials = modelData.resources.basematerials[ resourceId ];\n\t\t\t\t\t\t\tvar newMeshes = buildBasematerialsMeshes( basematerials, triangleProperties, modelData, meshData, textureData, objectData );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = newMeshes.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tmeshes.push( newMeshes[ j ] );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\t\tvar texture2dgroup = modelData.resources.texture2dgroup[ resourceId ];\n\t\t\t\t\t\t\tmeshes.push( buildTexturedMesh( texture2dgroup, triangleProperties, modelData, meshData, textureData, objectData ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\t\tvar colorgroup = modelData.resources.colorgroup[ resourceId ];\n\t\t\t\t\t\t\tmeshes.push( buildVertexColorMesh( colorgroup, triangleProperties, modelData, meshData ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'default':\n\t\t\t\t\t\t\tmeshes.push( buildDefaultMesh( meshData ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.3MFLoader: Unsupported resource type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn meshes;\n\n\t\t\t}\n\n\t\t\tfunction getResourceType( pid, modelData ) {\n\n\t\t\t\tif ( modelData.resources.texture2dgroup[ pid ] !== undefined ) {\n\n\t\t\t\t\treturn 'texture';\n\n\t\t\t\t} else if ( modelData.resources.basematerials[ pid ] !== undefined ) {\n\n\t\t\t\t\treturn 'material';\n\n\t\t\t\t} else if ( modelData.resources.colorgroup[ pid ] !== undefined ) {\n\n\t\t\t\t\treturn 'vertexColors';\n\n\t\t\t\t} else if ( pid === 'default' ) {\n\n\t\t\t\t\treturn 'default';\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn undefined;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction analyzeObject( modelData, meshData, objectData ) {\n\n\t\t\t\tvar resourceMap = {};\n\n\t\t\t\tvar triangleProperties = meshData[ 'triangleProperties' ];\n\n\t\t\t\tvar objectPid = objectData.pid;\n\n\t\t\t\tfor ( var i = 0, l = triangleProperties.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar triangleProperty = triangleProperties[ i ];\n\t\t\t\t\tvar pid = ( triangleProperty.pid !== undefined ) ? triangleProperty.pid : objectPid;\n\n\t\t\t\t\tif ( pid === undefined ) pid = 'default';\n\n\t\t\t\t\tif ( resourceMap[ pid ] === undefined ) resourceMap[ pid ] = [];\n\n\t\t\t\t\tresourceMap[ pid ].push( triangleProperty );\n\n\t\t\t\t}\n\n\t\t\t\treturn resourceMap;\n\n\t\t\t}\n\n\t\t\tfunction buildGroup( meshData, objects, modelData, textureData, objectData ) {\n\n\t\t\t\tvar group = new THREE.Group();\n\n\t\t\t\tvar resourceMap = analyzeObject( modelData, meshData, objectData );\n\t\t\t\tvar meshes = buildMeshes( resourceMap, modelData, meshData, textureData, objectData );\n\n\t\t\t\tfor ( var i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn group;\n\n\t\t\t}\n\n\t\t\tfunction applyExtensions( extensions, meshData, modelXml ) {\n\n\t\t\t\tif ( ! extensions ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvar availableExtensions = [];\n\t\t\t\tvar keys = Object.keys( extensions );\n\n\t\t\t\tfor ( var i = 0; i < keys.length; i ++ ) {\n\n\t\t\t\t\tvar ns = keys[ i ];\n\n\t\t\t\t\tfor ( var j = 0; j < scope.availableExtensions.length; j ++ ) {\n\n\t\t\t\t\t\tvar extension = scope.availableExtensions[ j ];\n\n\t\t\t\t\t\tif ( extension.ns === ns ) {\n\n\t\t\t\t\t\t\tavailableExtensions.push( extension );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < availableExtensions.length; i ++ ) {\n\n\t\t\t\t\tvar extension = availableExtensions[ i ];\n\t\t\t\t\textension.apply( modelXml, extensions[ extension[ 'ns' ] ], meshData );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getBuild( data, objects, modelData, textureData, objectData, builder ) {\n\n\t\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\t\tdata.build = builder( data, objects, modelData, textureData, objectData );\n\n\t\t\t\treturn data.build;\n\n\t\t\t}\n\n\t\t\tfunction buildBasematerial( materialData, objects, modelData ) {\n\n\t\t\t\tvar material;\n\n\t\t\t\tvar displaypropertiesid = materialData.displaypropertiesid;\n\t\t\t\tvar pbmetallicdisplayproperties = modelData.resources.pbmetallicdisplayproperties;\n\n\t\t\t\tif ( displaypropertiesid !== null && pbmetallicdisplayproperties[ displaypropertiesid ] !== undefined ) {\n\n\t\t\t\t\t// metallic display property, use StandardMaterial\n\n\t\t\t\t\tvar pbmetallicdisplayproperty = pbmetallicdisplayproperties[ displaypropertiesid ];\n\t\t\t\t\tvar metallicData = pbmetallicdisplayproperty.data[ materialData.index ];\n\n\t\t\t\t\tmaterial = new THREE.MeshStandardMaterial( { flatShading: true, roughness: metallicData.roughness, metalness: metallicData.metallicness } );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// otherwise use PhongMaterial\n\n\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial( { flatShading: true } );\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.name = materialData.name;\n\n\t\t\t\t// displaycolor MUST be specified with a value of a 6 or 8 digit hexadecimal number, e.g. \"#RRGGBB\" or \"#RRGGBBAA\"\n\n\t\t\t\tvar displaycolor = materialData.displaycolor;\n\n\t\t\t\tvar color = displaycolor.substring( 0, 7 );\n\t\t\t\tmaterial.color.setStyle( color );\n\t\t\t\tmaterial.color.convertSRGBToLinear(); // displaycolor is in sRGB\n\n\t\t\t\t// process alpha if set\n\n\t\t\t\tif ( displaycolor.length === 9 ) {\n\n\t\t\t\t\tmaterial.opacity = parseInt( displaycolor.charAt( 7 ) + displaycolor.charAt( 8 ), 16 ) / 255;\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t\tfunction buildComposite( compositeData, objects, modelData, textureData ) {\n\n\t\t\t\tvar composite = new THREE.Group();\n\n\t\t\t\tfor ( var j = 0; j < compositeData.length; j ++ ) {\n\n\t\t\t\t\tvar component = compositeData[ j ];\n\t\t\t\t\tvar build = objects[ component.objectId ];\n\n\t\t\t\t\tif ( build === undefined ) {\n\n\t\t\t\t\t\tbuildObject( component.objectId, objects, modelData, textureData );\n\t\t\t\t\t\tbuild = objects[ component.objectId ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar object3D = build.clone();\n\n\t\t\t\t\t// apply component transfrom\n\n\t\t\t\t\tvar transform = component.transform;\n\n\t\t\t\t\tif ( transform ) {\n\n\t\t\t\t\t\tobject3D.applyMatrix4( transform );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcomposite.add( object3D );\n\n\t\t\t\t}\n\n\t\t\t\treturn composite;\n\n\t\t\t}\n\n\t\t\tfunction buildObject( objectId, objects, modelData, textureData ) {\n\n\t\t\t\tvar objectData = modelData[ 'resources' ][ 'object' ][ objectId ];\n\n\t\t\t\tif ( objectData[ 'mesh' ] ) {\n\n\t\t\t\t\tvar meshData = objectData[ 'mesh' ];\n\n\t\t\t\t\tvar extensions = modelData[ 'extensions' ];\n\t\t\t\t\tvar modelXml = modelData[ 'xml' ];\n\n\t\t\t\t\tapplyExtensions( extensions, meshData, modelXml );\n\n\t\t\t\t\tobjects[ objectData.id ] = getBuild( meshData, objects, modelData, textureData, objectData, buildGroup );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar compositeData = objectData[ 'components' ];\n\n\t\t\t\t\tobjects[ objectData.id ] = getBuild( compositeData, objects, modelData, textureData, objectData, buildComposite );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction buildObjects( data3mf ) {\n\n\t\t\t\tvar modelsData = data3mf.model;\n\t\t\t\tvar modelRels = data3mf.modelRels;\n\t\t\t\tvar objects = {};\n\t\t\t\tvar modelsKeys = Object.keys( modelsData );\n\t\t\t\tvar textureData = {};\n\n\t\t\t\t// evaluate model relationships to textures\n\n\t\t\t\tif ( modelRels ) {\n\n\t\t\t\t\tfor ( var i = 0, l = modelRels.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar modelRel = modelRels[ i ];\n\t\t\t\t\t\tvar textureKey = modelRel.target.substring( 1 );\n\n\t\t\t\t\t\tif ( data3mf.texture[ textureKey ] ) {\n\n\t\t\t\t\t\t\ttextureData[ modelRel.target ] = data3mf.texture[ textureKey ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// start build\n\n\t\t\t\tfor ( var i = 0; i < modelsKeys.length; i ++ ) {\n\n\t\t\t\t\tvar modelsKey = modelsKeys[ i ];\n\t\t\t\t\tvar modelData = modelsData[ modelsKey ];\n\n\t\t\t\t\tvar objectIds = Object.keys( modelData[ 'resources' ][ 'object' ] );\n\n\t\t\t\t\tfor ( var j = 0; j < objectIds.length; j ++ ) {\n\n\t\t\t\t\t\tvar objectId = objectIds[ j ];\n\n\t\t\t\t\t\tbuildObject( objectId, objects, modelData, textureData );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn objects;\n\n\t\t\t}\n\n\t\t\tfunction build( objects, data3mf ) {\n\n\t\t\t\tvar group = new THREE.Group();\n\n\t\t\t\tvar relationship = data3mf[ 'rels' ][ 0 ];\n\t\t\t\tvar buildData = data3mf.model[ relationship[ 'target' ].substring( 1 ) ][ 'build' ];\n\n\t\t\t\tfor ( var i = 0; i < buildData.length; i ++ ) {\n\n\t\t\t\t\tvar buildItem = buildData[ i ];\n\t\t\t\t\tvar object3D = objects[ buildItem[ 'objectId' ] ];\n\n\t\t\t\t\t// apply transform\n\n\t\t\t\t\tvar transform = buildItem[ 'transform' ];\n\n\t\t\t\t\tif ( transform ) {\n\n\t\t\t\t\t\tobject3D.applyMatrix4( transform );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgroup.add( object3D );\n\n\t\t\t\t}\n\n\t\t\t\treturn group;\n\n\t\t\t}\n\n\t\t\tvar data3mf = loadDocument( data );\n\t\t\tvar objects = buildObjects( data3mf );\n\n\t\t\treturn build( objects, data3mf );\n\n\t\t},\n\n\t\taddExtension: function ( extension ) {\n\n\t\t\tthis.availableExtensions.push( extension );\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.ThreeMFLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/AMFLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author tamarintech / https://tamarintech.com\n\t *\n\t * Description: Early release of an AMF Loader following the pattern of the\n\t * example loaders in the three.js project.\n\t *\n\t * More information about the AMF format: http://amf.wikispaces.com\n\t *\n\t * Usage:\n\t *\tvar loader = new AMFLoader();\n\t *\tloader.load('/path/to/project.amf', function(objecttree) {\n\t *\t\tscene.add(objecttree);\n\t *\t});\n\t *\n\t * Materials now supported, material colors supported\n\t * Zip support, requires jszip\n\t * No constellation support (yet)!\n\t *\n\t */\n\n\tTHREE.AMFLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.AMFLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.AMFLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data ) {\n\n\t\t\tfunction loadDocument( data ) {\n\n\t\t\t\tvar view = new DataView( data );\n\t\t\t\tvar magic = String.fromCharCode( view.getUint8( 0 ), view.getUint8( 1 ) );\n\n\t\t\t\tif ( magic === 'PK' ) {\n\n\t\t\t\t\tvar zip = null;\n\t\t\t\t\tvar file = null;\n\n\t\t\t\t\tconsole.log( 'THREE.AMFLoader: Loading Zip' );\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tzip = new JSZip( data ); // eslint-disable-line no-undef\n\n\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\tif ( e instanceof ReferenceError ) {\n\n\t\t\t\t\t\t\tconsole.log( 'THREE.AMFLoader: jszip missing and file is compressed.' );\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( file in zip.files ) {\n\n\t\t\t\t\t\tif ( file.toLowerCase().substr( - 4 ) === '.amf' ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.log( 'THREE.AMFLoader: Trying to load file asset: ' + file );\n\t\t\t\t\tview = new DataView( zip.file( file ).asArrayBuffer() );\n\n\t\t\t\t}\n\n\t\t\t\tvar fileText = THREE.LoaderUtils.decodeText( view );\n\t\t\t\tvar xmlData = new DOMParser().parseFromString( fileText, 'application/xml' );\n\n\t\t\t\tif ( xmlData.documentElement.nodeName.toLowerCase() !== 'amf' ) {\n\n\t\t\t\t\tconsole.log( 'THREE.AMFLoader: Error loading AMF - no AMF document found.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\treturn xmlData;\n\n\t\t\t}\n\n\t\t\tfunction loadDocumentScale( node ) {\n\n\t\t\t\tvar scale = 1.0;\n\t\t\t\tvar unit = 'millimeter';\n\n\t\t\t\tif ( node.documentElement.attributes.unit !== undefined ) {\n\n\t\t\t\t\tunit = node.documentElement.attributes.unit.value.toLowerCase();\n\n\t\t\t\t}\n\n\t\t\t\tvar scaleUnits = {\n\t\t\t\t\tmillimeter: 1.0,\n\t\t\t\t\tinch: 25.4,\n\t\t\t\t\tfeet: 304.8,\n\t\t\t\t\tmeter: 1000.0,\n\t\t\t\t\tmicron: 0.001\n\t\t\t\t};\n\n\t\t\t\tif ( scaleUnits[ unit ] !== undefined ) {\n\n\t\t\t\t\tscale = scaleUnits[ unit ];\n\n\t\t\t\t}\n\n\t\t\t\tconsole.log( 'THREE.AMFLoader: Unit scale: ' + scale );\n\t\t\t\treturn scale;\n\n\t\t\t}\n\n\t\t\tfunction loadMaterials( node ) {\n\n\t\t\t\tvar matName = 'AMF Material';\n\t\t\t\tvar matId = node.attributes.id.textContent;\n\t\t\t\tvar color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\n\n\t\t\t\tvar loadedMaterial = null;\n\n\t\t\t\tfor ( var i = 0; i < node.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar matChildEl = node.childNodes[ i ];\n\n\t\t\t\t\tif ( matChildEl.nodeName === 'metadata' && matChildEl.attributes.type !== undefined ) {\n\n\t\t\t\t\t\tif ( matChildEl.attributes.type.value === 'name' ) {\n\n\t\t\t\t\t\t\tmatName = matChildEl.textContent;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( matChildEl.nodeName === 'color' ) {\n\n\t\t\t\t\t\tcolor = loadColor( matChildEl );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tloadedMaterial = new THREE.MeshPhongMaterial( {\n\t\t\t\t\tflatShading: true,\n\t\t\t\t\tcolor: new THREE.Color( color.r, color.g, color.b ),\n\t\t\t\t\tname: matName\n\t\t\t\t} );\n\n\t\t\t\tif ( color.a !== 1.0 ) {\n\n\t\t\t\t\tloadedMaterial.transparent = true;\n\t\t\t\t\tloadedMaterial.opacity = color.a;\n\n\t\t\t\t}\n\n\t\t\t\treturn { id: matId, material: loadedMaterial };\n\n\t\t\t}\n\n\t\t\tfunction loadColor( node ) {\n\n\t\t\t\tvar color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\n\n\t\t\t\tfor ( var i = 0; i < node.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar matColor = node.childNodes[ i ];\n\n\t\t\t\t\tif ( matColor.nodeName === 'r' ) {\n\n\t\t\t\t\t\tcolor.r = matColor.textContent;\n\n\t\t\t\t\t} else if ( matColor.nodeName === 'g' ) {\n\n\t\t\t\t\t\tcolor.g = matColor.textContent;\n\n\t\t\t\t\t} else if ( matColor.nodeName === 'b' ) {\n\n\t\t\t\t\t\tcolor.b = matColor.textContent;\n\n\t\t\t\t\t} else if ( matColor.nodeName === 'a' ) {\n\n\t\t\t\t\t\tcolor.a = matColor.textContent;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn color;\n\n\t\t\t}\n\n\t\t\tfunction loadMeshVolume( node ) {\n\n\t\t\t\tvar volume = { name: '', triangles: [], materialid: null };\n\n\t\t\t\tvar currVolumeNode = node.firstElementChild;\n\n\t\t\t\tif ( node.attributes.materialid !== undefined ) {\n\n\t\t\t\t\tvolume.materialId = node.attributes.materialid.nodeValue;\n\n\t\t\t\t}\n\n\t\t\t\twhile ( currVolumeNode ) {\n\n\t\t\t\t\tif ( currVolumeNode.nodeName === 'metadata' ) {\n\n\t\t\t\t\t\tif ( currVolumeNode.attributes.type !== undefined ) {\n\n\t\t\t\t\t\t\tif ( currVolumeNode.attributes.type.value === 'name' ) {\n\n\t\t\t\t\t\t\t\tvolume.name = currVolumeNode.textContent;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( currVolumeNode.nodeName === 'triangle' ) {\n\n\t\t\t\t\t\tvar v1 = currVolumeNode.getElementsByTagName( 'v1' )[ 0 ].textContent;\n\t\t\t\t\t\tvar v2 = currVolumeNode.getElementsByTagName( 'v2' )[ 0 ].textContent;\n\t\t\t\t\t\tvar v3 = currVolumeNode.getElementsByTagName( 'v3' )[ 0 ].textContent;\n\n\t\t\t\t\t\tvolume.triangles.push( v1, v2, v3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrVolumeNode = currVolumeNode.nextElementSibling;\n\n\t\t\t\t}\n\n\t\t\t\treturn volume;\n\n\t\t\t}\n\n\t\t\tfunction loadMeshVertices( node ) {\n\n\t\t\t\tvar vertArray = [];\n\t\t\t\tvar normalArray = [];\n\t\t\t\tvar currVerticesNode = node.firstElementChild;\n\n\t\t\t\twhile ( currVerticesNode ) {\n\n\t\t\t\t\tif ( currVerticesNode.nodeName === 'vertex' ) {\n\n\t\t\t\t\t\tvar vNode = currVerticesNode.firstElementChild;\n\n\t\t\t\t\t\twhile ( vNode ) {\n\n\t\t\t\t\t\t\tif ( vNode.nodeName === 'coordinates' ) {\n\n\t\t\t\t\t\t\t\tvar x = vNode.getElementsByTagName( 'x' )[ 0 ].textContent;\n\t\t\t\t\t\t\t\tvar y = vNode.getElementsByTagName( 'y' )[ 0 ].textContent;\n\t\t\t\t\t\t\t\tvar z = vNode.getElementsByTagName( 'z' )[ 0 ].textContent;\n\n\t\t\t\t\t\t\t\tvertArray.push( x, y, z );\n\n\t\t\t\t\t\t\t} else if ( vNode.nodeName === 'normal' ) {\n\n\t\t\t\t\t\t\t\tvar nx = vNode.getElementsByTagName( 'nx' )[ 0 ].textContent;\n\t\t\t\t\t\t\t\tvar ny = vNode.getElementsByTagName( 'ny' )[ 0 ].textContent;\n\t\t\t\t\t\t\t\tvar nz = vNode.getElementsByTagName( 'nz' )[ 0 ].textContent;\n\n\t\t\t\t\t\t\t\tnormalArray.push( nx, ny, nz );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvNode = vNode.nextElementSibling;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tcurrVerticesNode = currVerticesNode.nextElementSibling;\n\n\t\t\t\t}\n\n\t\t\t\treturn { 'vertices': vertArray, 'normals': normalArray };\n\n\t\t\t}\n\n\t\t\tfunction loadObject( node ) {\n\n\t\t\t\tvar objId = node.attributes.id.textContent;\n\t\t\t\tvar loadedObject = { name: 'amfobject', meshes: [] };\n\t\t\t\tvar currColor = null;\n\t\t\t\tvar currObjNode = node.firstElementChild;\n\n\t\t\t\twhile ( currObjNode ) {\n\n\t\t\t\t\tif ( currObjNode.nodeName === 'metadata' ) {\n\n\t\t\t\t\t\tif ( currObjNode.attributes.type !== undefined ) {\n\n\t\t\t\t\t\t\tif ( currObjNode.attributes.type.value === 'name' ) {\n\n\t\t\t\t\t\t\t\tloadedObject.name = currObjNode.textContent;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( currObjNode.nodeName === 'color' ) {\n\n\t\t\t\t\t\tcurrColor = loadColor( currObjNode );\n\n\t\t\t\t\t} else if ( currObjNode.nodeName === 'mesh' ) {\n\n\t\t\t\t\t\tvar currMeshNode = currObjNode.firstElementChild;\n\t\t\t\t\t\tvar mesh = { vertices: [], normals: [], volumes: [], color: currColor };\n\n\t\t\t\t\t\twhile ( currMeshNode ) {\n\n\t\t\t\t\t\t\tif ( currMeshNode.nodeName === 'vertices' ) {\n\n\t\t\t\t\t\t\t\tvar loadedVertices = loadMeshVertices( currMeshNode );\n\n\t\t\t\t\t\t\t\tmesh.normals = mesh.normals.concat( loadedVertices.normals );\n\t\t\t\t\t\t\t\tmesh.vertices = mesh.vertices.concat( loadedVertices.vertices );\n\n\t\t\t\t\t\t\t} else if ( currMeshNode.nodeName === 'volume' ) {\n\n\t\t\t\t\t\t\t\tmesh.volumes.push( loadMeshVolume( currMeshNode ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcurrMeshNode = currMeshNode.nextElementSibling;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tloadedObject.meshes.push( mesh );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrObjNode = currObjNode.nextElementSibling;\n\n\t\t\t\t}\n\n\t\t\t\treturn { 'id': objId, 'obj': loadedObject };\n\n\t\t\t}\n\n\t\t\tvar xmlData = loadDocument( data );\n\t\t\tvar amfName = '';\n\t\t\tvar amfAuthor = '';\n\t\t\tvar amfScale = loadDocumentScale( xmlData );\n\t\t\tvar amfMaterials = {};\n\t\t\tvar amfObjects = {};\n\t\t\tvar childNodes = xmlData.documentElement.childNodes;\n\n\t\t\tvar i, j;\n\n\t\t\tfor ( i = 0; i < childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = childNodes[ i ];\n\n\t\t\t\tif ( child.nodeName === 'metadata' ) {\n\n\t\t\t\t\tif ( child.attributes.type !== undefined ) {\n\n\t\t\t\t\t\tif ( child.attributes.type.value === 'name' ) {\n\n\t\t\t\t\t\t\tamfName = child.textContent;\n\n\t\t\t\t\t\t} else if ( child.attributes.type.value === 'author' ) {\n\n\t\t\t\t\t\t\tamfAuthor = child.textContent;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( child.nodeName === 'material' ) {\n\n\t\t\t\t\tvar loadedMaterial = loadMaterials( child );\n\n\t\t\t\t\tamfMaterials[ loadedMaterial.id ] = loadedMaterial.material;\n\n\t\t\t\t} else if ( child.nodeName === 'object' ) {\n\n\t\t\t\t\tvar loadedObject = loadObject( child );\n\n\t\t\t\t\tamfObjects[ loadedObject.id ] = loadedObject.obj;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar sceneObject = new THREE.Group();\n\t\t\tvar defaultMaterial = new THREE.MeshPhongMaterial( { color: 0xaaaaff, flatShading: true } );\n\n\t\t\tsceneObject.name = amfName;\n\t\t\tsceneObject.userData.author = amfAuthor;\n\t\t\tsceneObject.userData.loader = 'AMF';\n\n\t\t\tfor ( var id in amfObjects ) {\n\n\t\t\t\tvar part = amfObjects[ id ];\n\t\t\t\tvar meshes = part.meshes;\n\t\t\t\tvar newObject = new THREE.Group();\n\t\t\t\tnewObject.name = part.name || '';\n\n\t\t\t\tfor ( i = 0; i < meshes.length; i ++ ) {\n\n\t\t\t\t\tvar objDefaultMaterial = defaultMaterial;\n\t\t\t\t\tvar mesh = meshes[ i ];\n\t\t\t\t\tvar vertices = new THREE.Float32BufferAttribute( mesh.vertices, 3 );\n\t\t\t\t\tvar normals = null;\n\n\t\t\t\t\tif ( mesh.normals.length ) {\n\n\t\t\t\t\t\tnormals = new THREE.Float32BufferAttribute( mesh.normals, 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( mesh.color ) {\n\n\t\t\t\t\t\tvar color = mesh.color;\n\n\t\t\t\t\t\tobjDefaultMaterial = defaultMaterial.clone();\n\t\t\t\t\t\tobjDefaultMaterial.color = new THREE.Color( color.r, color.g, color.b );\n\n\t\t\t\t\t\tif ( color.a !== 1.0 ) {\n\n\t\t\t\t\t\t\tobjDefaultMaterial.transparent = true;\n\t\t\t\t\t\t\tobjDefaultMaterial.opacity = color.a;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar volumes = mesh.volumes;\n\n\t\t\t\t\tfor ( j = 0; j < volumes.length; j ++ ) {\n\n\t\t\t\t\t\tvar volume = volumes[ j ];\n\t\t\t\t\t\tvar newGeometry = new THREE.BufferGeometry();\n\t\t\t\t\t\tvar material = objDefaultMaterial;\n\n\t\t\t\t\t\tnewGeometry.setIndex( volume.triangles );\n\t\t\t\t\t\tnewGeometry.setAttribute( 'position', vertices.clone() );\n\n\t\t\t\t\t\tif ( normals ) {\n\n\t\t\t\t\t\t\tnewGeometry.setAttribute( 'normal', normals.clone() );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( amfMaterials[ volume.materialId ] !== undefined ) {\n\n\t\t\t\t\t\t\tmaterial = amfMaterials[ volume.materialId ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnewGeometry.scale( amfScale, amfScale, amfScale );\n\t\t\t\t\t\tnewObject.add( new THREE.Mesh( newGeometry, material.clone() ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tsceneObject.add( newObject );\n\n\t\t\t}\n\n\t\t\treturn sceneObject;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.AMFLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/AssimpLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Virtulous / https://virtulo.us/\n\t */\n\n\tTHREE.AssimpLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.AssimpLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.AssimpLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( scope.path === '' ) ? THREE.LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tonLoad( scope.parse( buffer, path ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( buffer, path ) {\n\n\t\t\tvar textureLoader = new THREE.TextureLoader( this.manager );\n\t\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar Virtulous = {};\n\n\t\t\tVirtulous.KeyFrame = function ( time, matrix ) {\n\n\t\t\t\tthis.time = time;\n\t\t\t\tthis.matrix = matrix.clone();\n\t\t\t\tthis.position = new THREE.Vector3();\n\t\t\t\tthis.quaternion = new THREE.Quaternion();\n\t\t\t\tthis.scale = new THREE.Vector3( 1, 1, 1 );\n\t\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\t\t\t\tthis.clone = function () {\n\n\t\t\t\t\tvar n = new Virtulous.KeyFrame( this.time, this.matrix );\n\t\t\t\t\treturn n;\n\n\t\t\t\t};\n\t\t\t\tthis.lerp = function ( nextKey, time ) {\n\n\t\t\t\t\ttime -= this.time;\n\t\t\t\t\tvar dist = ( nextKey.time - this.time );\n\t\t\t\t\tvar l = time / dist;\n\t\t\t\t\tvar l2 = 1 - l;\n\t\t\t\t\tvar keypos = this.position;\n\t\t\t\t\tvar keyrot = this.quaternion;\n\t\t\t\t\t//      var keyscl =  key.parentspaceScl || key.scl;\n\t\t\t\t\tvar key2pos = nextKey.position;\n\t\t\t\t\tvar key2rot = nextKey.quaternion;\n\t\t\t\t\t//  var key2scl =  key2.parentspaceScl || key2.scl;\n\t\t\t\t\tVirtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n\t\t\t\t\tVirtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n\t\t\t\t\tVirtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;\n\t\t\t\t\t//     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\n\t\t\t\t\t//     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\n\t\t\t\t\t//     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\n\t\t\t\t\tVirtulous.KeyFrame.tempAniQuat.set( keyrot.x, keyrot.y, keyrot.z, keyrot.w );\n\t\t\t\t\tVirtulous.KeyFrame.tempAniQuat.slerp( key2rot, l );\n\t\t\t\t\treturn Virtulous.KeyFrame.tempAniMatrix.compose( Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale );\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t\tVirtulous.KeyFrame.tempAniPos = new THREE.Vector3();\n\t\t\tVirtulous.KeyFrame.tempAniQuat = new THREE.Quaternion();\n\t\t\tVirtulous.KeyFrame.tempAniScale = new THREE.Vector3( 1, 1, 1 );\n\t\t\tVirtulous.KeyFrame.tempAniMatrix = new THREE.Matrix4();\n\t\t\tVirtulous.KeyFrameTrack = function () {\n\n\t\t\t\tthis.keys = [];\n\t\t\t\tthis.target = null;\n\t\t\t\tthis.time = 0;\n\t\t\t\tthis.length = 0;\n\t\t\t\tthis._accelTable = {};\n\t\t\t\tthis.fps = 20;\n\t\t\t\tthis.addKey = function ( key ) {\n\n\t\t\t\t\tthis.keys.push( key );\n\n\t\t\t\t};\n\t\t\t\tthis.init = function () {\n\n\t\t\t\t\tthis.sortKeys();\n\n\t\t\t\t\tif ( this.keys.length > 0 )\n\t\t\t\t\t\tthis.length = this.keys[ this.keys.length - 1 ].time;\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.length = 0;\n\n\t\t\t\t\tif ( ! this.fps ) return;\n\n\t\t\t\t\tfor ( var j = 0; j < this.length * this.fps; j ++ ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < this.keys.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( this.keys[ i ].time == j ) {\n\n\t\t\t\t\t\t\t\tthis._accelTable[ j ] = i;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t} else if ( this.keys[ i ].time < j / this.fps && this.keys[ i + 1 ] && this.keys[ i + 1 ].time >= j / this.fps ) {\n\n\t\t\t\t\t\t\t\tthis._accelTable[ j ] = i;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tthis.parseFromThree = function ( data ) {\n\n\t\t\t\t\tvar fps = data.fps;\n\t\t\t\t\tthis.target = data.node;\n\t\t\t\t\tvar track = data.hierarchy[ 0 ].keys;\n\t\t\t\t\tfor ( var i = 0; i < track.length; i ++ ) {\n\n\t\t\t\t\t\tthis.addKey( new Virtulous.KeyFrame( i / fps || track[ i ].time, track[ i ].targets[ 0 ].data ) );\n\n\t\t\t\t\t}\n\t\t\t\t\tthis.init();\n\n\t\t\t\t};\n\n\t\t\t\tthis.parseFromCollada = function ( data ) {\n\n\t\t\t\t\tvar track = data.keys;\n\t\t\t\t\tvar fps = this.fps;\n\n\t\t\t\t\tfor ( var i = 0; i < track.length; i ++ ) {\n\n\t\t\t\t\t\tthis.addKey( new Virtulous.KeyFrame( i / fps || track[ i ].time, track[ i ].matrix ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.init();\n\n\t\t\t\t};\n\n\t\t\t\tthis.sortKeys = function () {\n\n\t\t\t\t\tthis.keys.sort( this.keySortFunc );\n\n\t\t\t\t};\n\n\t\t\t\tthis.keySortFunc = function ( a, b ) {\n\n\t\t\t\t\treturn a.time - b.time;\n\n\t\t\t\t};\n\n\t\t\t\tthis.clone = function () {\n\n\t\t\t\t\tvar t = new Virtulous.KeyFrameTrack();\n\t\t\t\t\tt.target = this.target;\n\t\t\t\t\tt.time = this.time;\n\t\t\t\t\tt.length = this.length;\n\n\t\t\t\t\tfor ( var i = 0; i < this.keys.length; i ++ ) {\n\n\t\t\t\t\t\tt.addKey( this.keys[ i ].clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tt.init();\n\t\t\t\t\treturn t;\n\n\t\t\t\t};\n\n\t\t\t\tthis.reTarget = function ( root, compareitor ) {\n\n\t\t\t\t\tif ( ! compareitor ) compareitor = Virtulous.TrackTargetNodeNameCompare;\n\t\t\t\t\tthis.target = compareitor( root, this.target );\n\n\t\t\t\t};\n\n\t\t\t\tthis.keySearchAccel = function ( time ) {\n\n\t\t\t\t\ttime *= this.fps;\n\t\t\t\t\ttime = Math.floor( time );\n\t\t\t\t\treturn this._accelTable[ time ] || 0;\n\n\t\t\t\t};\n\n\t\t\t\tthis.setTime = function ( time ) {\n\n\t\t\t\t\ttime = Math.abs( time );\n\t\t\t\t\tif ( this.length )\n\t\t\t\t\t\ttime = time % this.length + .05;\n\t\t\t\t\tvar key0 = null;\n\t\t\t\t\tvar key1 = null;\n\n\t\t\t\t\tfor ( var i = this.keySearchAccel( time ); i < this.keys.length; i ++ ) {\n\n\t\t\t\t\t\tif ( this.keys[ i ].time == time ) {\n\n\t\t\t\t\t\t\tkey0 = this.keys[ i ];\n\t\t\t\t\t\t\tkey1 = this.keys[ i ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if ( this.keys[ i ].time < time && this.keys[ i + 1 ] && this.keys[ i + 1 ].time > time ) {\n\n\t\t\t\t\t\t\tkey0 = this.keys[ i ];\n\t\t\t\t\t\t\tkey1 = this.keys[ i + 1 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if ( this.keys[ i ].time < time && i == this.keys.length - 1 ) {\n\n\t\t\t\t\t\t\tkey0 = this.keys[ i ];\n\t\t\t\t\t\t\tkey1 = this.keys[ 0 ].clone();\n\t\t\t\t\t\t\tkey1.time += this.length + .05;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( key0 && key1 && key0 !== key1 ) {\n\n\t\t\t\t\t\tthis.target.matrixAutoUpdate = false;\n\t\t\t\t\t\tthis.target.matrix.copy( key0.lerp( key1, time ) );\n\t\t\t\t\t\tthis.target.matrixWorldNeedsUpdate = true;\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( key0 && key1 && key0 == key1 ) {\n\n\t\t\t\t\t\tthis.target.matrixAutoUpdate = false;\n\t\t\t\t\t\tthis.target.matrix.copy( key0.matrix );\n\t\t\t\t\t\tthis.target.matrixWorldNeedsUpdate = true;\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t\tVirtulous.TrackTargetNodeNameCompare = function ( root, target ) {\n\n\t\t\t\tfunction find( node, name ) {\n\n\t\t\t\t\tif ( node.name == name )\n\t\t\t\t\t\treturn node;\n\n\t\t\t\t\tfor ( var i = 0; i < node.children.length; i ++ ) {\n\n\t\t\t\t\t\tvar r = find( node.children[ i ], name );\n\t\t\t\t\t\tif ( r ) return r;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\treturn find( root, target.name );\n\n\t\t\t};\n\n\t\t\tVirtulous.Animation = function () {\n\n\t\t\t\tthis.tracks = [];\n\t\t\t\tthis.length = 0;\n\n\t\t\t\tthis.addTrack = function ( track ) {\n\n\t\t\t\t\tthis.tracks.push( track );\n\t\t\t\t\tthis.length = Math.max( track.length, this.length );\n\n\t\t\t\t};\n\n\t\t\t\tthis.setTime = function ( time ) {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ )\n\t\t\t\t\t\tthis.tracks[ i ].setTime( time );\n\n\t\t\t\t};\n\n\t\t\t\tthis.clone = function ( target, compareitor ) {\n\n\t\t\t\t\tif ( ! compareitor ) compareitor = Virtulous.TrackTargetNodeNameCompare;\n\t\t\t\t\tvar n = new Virtulous.Animation();\n\t\t\t\t\tn.target = target;\n\t\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\t\t\t\tvar track = this.tracks[ i ].clone();\n\t\t\t\t\t\ttrack.reTarget( target, compareitor );\n\t\t\t\t\t\tn.addTrack( track );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn n;\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t\tvar ASSBIN_CHUNK_AICAMERA = 0x1234;\n\t\t\tvar ASSBIN_CHUNK_AILIGHT = 0x1235;\n\t\t\tvar ASSBIN_CHUNK_AITEXTURE = 0x1236;\n\t\t\tvar ASSBIN_CHUNK_AIMESH = 0x1237;\n\t\t\tvar ASSBIN_CHUNK_AINODEANIM = 0x1238;\n\t\t\tvar ASSBIN_CHUNK_AISCENE = 0x1239;\n\t\t\tvar ASSBIN_CHUNK_AIBONE = 0x123a;\n\t\t\tvar ASSBIN_CHUNK_AIANIMATION = 0x123b;\n\t\t\tvar ASSBIN_CHUNK_AINODE = 0x123c;\n\t\t\tvar ASSBIN_CHUNK_AIMATERIAL = 0x123d;\n\t\t\tvar ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;\n\t\t\tvar ASSBIN_MESH_HAS_POSITIONS = 0x1;\n\t\t\tvar ASSBIN_MESH_HAS_NORMALS = 0x2;\n\t\t\tvar ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;\n\t\t\tvar ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;\n\t\t\tvar ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;\n\t\t\tvar AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n\t\t\tvar AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;\n\t\t\t//var aiLightSource_UNDEFINED = 0x0;\n\t\t\t//! A directional light source has a well-defined direction\n\t\t\t//! but is infinitely far away. That's quite a good\n\t\t\t//! approximation for sun light.\n\t\t\tvar aiLightSource_DIRECTIONAL = 0x1;\n\t\t\t//! A point light source has a well-defined position\n\t\t\t//! in space but no direction - it emits light in all\n\t\t\t//! directions. A normal bulb is a point light.\n\t\t\t//var aiLightSource_POINT = 0x2;\n\t\t\t//! A spot light source emits light in a specific\n\t\t\t//! angle. It has a position and a direction it is pointing to.\n\t\t\t//! A good example for a spot light is a light spot in\n\t\t\t//! sport arenas.\n\t\t\tvar aiLightSource_SPOT = 0x3;\n\t\t\t//! The generic light level of the world, including the bounces\n\t\t\t//! of all other lightsources.\n\t\t\t//! Typically, there's at most one ambient light in a scene.\n\t\t\t//! This light type doesn't have a valid position, direction, or\n\t\t\t//! other properties, just a color.\n\t\t\t//var aiLightSource_AMBIENT = 0x4;\n\t\t\t/** Flat shading. Shading is done on per-face base,\n\t\t\t *  diffuse only. Also known as 'faceted shading'.\n\t\t\t */\n\t\t\t//var aiShadingMode_Flat = 0x1;\n\t\t\t/** Simple Gouraud shading.\n\t\t\t */\n\t\t\t//var aiShadingMode_Gouraud = 0x2;\n\t\t\t/** Phong-Shading -\n\t\t\t */\n\t\t\t//var aiShadingMode_Phong = 0x3;\n\t\t\t/** Phong-Blinn-Shading\n\t\t\t */\n\t\t\t//var aiShadingMode_Blinn = 0x4;\n\t\t\t/** Toon-Shading per pixel\n\t\t\t *\n\t\t\t *  Also known as 'comic' shader.\n\t\t\t */\n\t\t\t//var aiShadingMode_Toon = 0x5;\n\t\t\t/** OrenNayar-Shading per pixel\n\t\t\t *\n\t\t\t *  Extension to standard Lambertian shading, taking the\n\t\t\t *  roughness of the material into account\n\t\t\t */\n\t\t\t//var aiShadingMode_OrenNayar = 0x6;\n\t\t\t/** Minnaert-Shading per pixel\n\t\t\t *\n\t\t\t *  Extension to standard Lambertian shading, taking the\n\t\t\t *  \"darkness\" of the material into account\n\t\t\t */\n\t\t\t//var aiShadingMode_Minnaert = 0x7;\n\t\t\t/** CookTorrance-Shading per pixel\n\t\t\t *\n\t\t\t *  Special shader for metallic surfaces.\n\t\t\t */\n\t\t\t//var aiShadingMode_CookTorrance = 0x8;\n\t\t\t/** No shading at all. Constant light influence of 1.0.\n\t\t\t */\n\t\t\t//var aiShadingMode_NoShading = 0x9;\n\t\t\t/** Fresnel shading\n\t\t\t */\n\t\t\t//var aiShadingMode_Fresnel = 0xa;\n\t\t\t//var aiTextureType_NONE = 0x0;\n\t\t\t/** The texture is combined with the result of the diffuse\n\t\t\t *  lighting equation.\n\t\t\t */\n\t\t\tvar aiTextureType_DIFFUSE = 0x1;\n\t\t\t/** The texture is combined with the result of the specular\n\t\t\t *  lighting equation.\n\t\t\t */\n\t\t\t//var aiTextureType_SPECULAR = 0x2;\n\t\t\t/** The texture is combined with the result of the ambient\n\t\t\t *  lighting equation.\n\t\t\t */\n\t\t\t//var aiTextureType_AMBIENT = 0x3;\n\t\t\t/** The texture is added to the result of the lighting\n\t\t\t *  calculation. It isn't influenced by incoming light.\n\t\t\t */\n\t\t\t//var aiTextureType_EMISSIVE = 0x4;\n\t\t\t/** The texture is a height map.\n\t\t\t *\n\t\t\t *  By convention, higher gray-scale values stand for\n\t\t\t *  higher elevations from the base height.\n\t\t\t */\n\t\t\t//var aiTextureType_HEIGHT = 0x5;\n\t\t\t/** The texture is a (tangent space) normal-map.\n\t\t\t *\n\t\t\t *  Again, there are several conventions for tangent-space\n\t\t\t *  normal maps. Assimp does (intentionally) not\n\t\t\t *  distinguish here.\n\t\t\t */\n\t\t\tvar aiTextureType_NORMALS = 0x6;\n\t\t\t/** The texture defines the glossiness of the material.\n\t\t\t *\n\t\t\t *  The glossiness is in fact the exponent of the specular\n\t\t\t *  (phong) lighting equation. Usually there is a conversion\n\t\t\t *  function defined to map the linear color values in the\n\t\t\t *  texture to a suitable exponent. Have fun.\n\t\t\t */\n\t\t\t//var aiTextureType_SHININESS = 0x7;\n\t\t\t/** The texture defines per-pixel opacity.\n\t\t\t *\n\t\t\t *  Usually 'white' means opaque and 'black' means\n\t\t\t *  'transparency'. Or quite the opposite. Have fun.\n\t\t\t */\n\t\t\tvar aiTextureType_OPACITY = 0x8;\n\t\t\t/** Displacement texture\n\t\t\t *\n\t\t\t *  The exact purpose and format is application-dependent.\n\t\t\t *  Higher color values stand for higher vertex displacements.\n\t\t\t */\n\t\t\t//var aiTextureType_DISPLACEMENT = 0x9;\n\t\t\t/** Lightmap texture (aka Ambient Occlusion)\n\t\t\t *\n\t\t\t *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n\t\t\t *  covered by this material property. The texture contains a\n\t\t\t *  scaling value for the final color value of a pixel. Its\n\t\t\t *  intensity is not affected by incoming light.\n\t\t\t */\n\t\t\tvar aiTextureType_LIGHTMAP = 0xA;\n\t\t\t/** Reflection texture\n\t\t\t *\n\t\t\t * Contains the color of a perfect mirror reflection.\n\t\t\t * Rarely used, almost never for real-time applications.\n\t\t\t */\n\t\t\t//var aiTextureType_REFLECTION = 0xB;\n\t\t\t/** Unknown texture\n\t\t\t *\n\t\t\t *  A texture reference that does not match any of the definitions\n\t\t\t *  above is considered to be 'unknown'. It is still imported,\n\t\t\t *  but is excluded from any further postprocessing.\n\t\t\t */\n\t\t\t//var aiTextureType_UNKNOWN = 0xC;\n\t\t\tvar BONESPERVERT = 4;\n\n\t\t\tfunction ASSBIN_MESH_HAS_TEXCOORD( n ) {\n\n\t\t\t\treturn ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n\n\t\t\t}\n\n\t\t\tfunction ASSBIN_MESH_HAS_COLOR( n ) {\n\n\t\t\t\treturn ASSBIN_MESH_HAS_COLOR_BASE << n;\n\n\t\t\t}\n\n\t\t\tfunction markBones( scene ) {\n\n\t\t\t\tfor ( var i in scene.mMeshes ) {\n\n\t\t\t\t\tvar mesh = scene.mMeshes[ i ];\n\t\t\t\t\tfor ( var k in mesh.mBones ) {\n\n\t\t\t\t\t\tvar boneNode = scene.findNode( mesh.mBones[ k ].mName );\n\t\t\t\t\t\tif ( boneNode )\n\t\t\t\t\t\t\tboneNode.isBone = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfunction cloneTreeToBones( root, scene ) {\n\n\t\t\t\tvar rootBone = new THREE.Bone();\n\t\t\t\trootBone.matrix.copy( root.matrix );\n\t\t\t\trootBone.matrixWorld.copy( root.matrixWorld );\n\t\t\t\trootBone.position.copy( root.position );\n\t\t\t\trootBone.quaternion.copy( root.quaternion );\n\t\t\t\trootBone.scale.copy( root.scale );\n\t\t\t\tscene.nodeCount ++;\n\t\t\t\trootBone.name = \"bone_\" + root.name + scene.nodeCount.toString();\n\n\t\t\t\tif ( ! scene.nodeToBoneMap[ root.name ] )\n\t\t\t\t\tscene.nodeToBoneMap[ root.name ] = [];\n\t\t\t\tscene.nodeToBoneMap[ root.name ].push( rootBone );\n\t\t\t\tfor ( var i in root.children ) {\n\n\t\t\t\t\tvar child = cloneTreeToBones( root.children[ i ], scene );\n\t\t\t\t\trootBone.add( child );\n\n\t\t\t\t}\n\n\t\t\t\treturn rootBone;\n\n\t\t\t}\n\n\t\t\tfunction sortWeights( indexes, weights ) {\n\n\t\t\t\tvar pairs = [];\n\n\t\t\t\tfor ( var i = 0; i < indexes.length; i ++ ) {\n\n\t\t\t\t\tpairs.push( {\n\t\t\t\t\t\ti: indexes[ i ],\n\t\t\t\t\t\tw: weights[ i ]\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tpairs.sort( function ( a, b ) {\n\n\t\t\t\t\treturn b.w - a.w;\n\n\t\t\t\t } );\n\n\t\t\t\twhile ( pairs.length < 4 ) {\n\n\t\t\t\t\tpairs.push( {\n\t\t\t\t\t\ti: 0,\n\t\t\t\t\t\tw: 0\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tif ( pairs.length > 4 )\n\t\t\t\t\tpairs.length = 4;\n\t\t\t\tvar sum = 0;\n\n\t\t\t\tfor ( var i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tsum += pairs[ i ].w * pairs[ i ].w;\n\n\t\t\t\t}\n\n\t\t\t\tsum = Math.sqrt( sum );\n\n\t\t\t\tfor ( var i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tpairs[ i ].w = pairs[ i ].w / sum;\n\t\t\t\t\tindexes[ i ] = pairs[ i ].i;\n\t\t\t\t\tweights[ i ] = pairs[ i ].w;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction findMatchingBone( root, name ) {\n\n\t\t\t\tif ( root.name.indexOf( \"bone_\" + name ) == 0 )\n\t\t\t\t\treturn root;\n\n\t\t\t\tfor ( var i in root.children ) {\n\n\t\t\t\t\tvar ret = findMatchingBone( root.children[ i ], name );\n\n\t\t\t\t\tif ( ret )\n\t\t\t\t\t\treturn ret;\n\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\tfunction aiMesh() {\n\n\t\t\t\tthis.mPrimitiveTypes = 0;\n\t\t\t\tthis.mNumVertices = 0;\n\t\t\t\tthis.mNumFaces = 0;\n\t\t\t\tthis.mNumBones = 0;\n\t\t\t\tthis.mMaterialIndex = 0;\n\t\t\t\tthis.mVertices = [];\n\t\t\t\tthis.mNormals = [];\n\t\t\t\tthis.mTangents = [];\n\t\t\t\tthis.mBitangents = [];\n\t\t\t\tthis.mColors = [\n\t\t\t\t\t[]\n\t\t\t\t];\n\t\t\t\tthis.mTextureCoords = [\n\t\t\t\t\t[]\n\t\t\t\t];\n\t\t\t\tthis.mFaces = [];\n\t\t\t\tthis.mBones = [];\n\t\t\t\tthis.hookupSkeletons = function ( scene ) {\n\n\t\t\t\t\tif ( this.mBones.length == 0 ) return;\n\n\t\t\t\t\tvar allBones = [];\n\t\t\t\t\tvar offsetMatrix = [];\n\t\t\t\t\tvar skeletonRoot = scene.findNode( this.mBones[ 0 ].mName );\n\n\t\t\t\t\twhile ( skeletonRoot.mParent && skeletonRoot.mParent.isBone ) {\n\n\t\t\t\t\t\tskeletonRoot = skeletonRoot.mParent;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar threeSkeletonRoot = skeletonRoot.toTHREE( scene );\n\t\t\t\t\tvar threeSkeletonRootBone = cloneTreeToBones( threeSkeletonRoot, scene );\n\t\t\t\t\tthis.threeNode.add( threeSkeletonRootBone );\n\n\t\t\t\t\tfor ( var i = 0; i < this.mBones.length; i ++ ) {\n\n\t\t\t\t\t\tvar bone = findMatchingBone( threeSkeletonRootBone, this.mBones[ i ].mName );\n\n\t\t\t\t\t\tif ( bone ) {\n\n\t\t\t\t\t\t\tvar tbone = bone;\n\t\t\t\t\t\t\tallBones.push( tbone );\n\t\t\t\t\t\t\t//tbone.matrixAutoUpdate = false;\n\t\t\t\t\t\t\toffsetMatrix.push( this.mBones[ i ].mOffsetMatrix.toTHREE() );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar skeletonRoot = scene.findNode( this.mBones[ i ].mName );\n\t\t\t\t\t\t\tif ( ! skeletonRoot ) return;\n\t\t\t\t\t\t\tvar threeSkeletonRoot = skeletonRoot.toTHREE( scene );\n\t\t\t\t\t\t\tvar threeSkeletonRootBone = cloneTreeToBones( threeSkeletonRoot, scene );\n\t\t\t\t\t\t\tthis.threeNode.add( threeSkeletonRootBone );\n\t\t\t\t\t\t\tvar bone = findMatchingBone( threeSkeletonRootBone, this.mBones[ i ].mName );\n\t\t\t\t\t\t\tvar tbone = bone;\n\t\t\t\t\t\t\tallBones.push( tbone );\n\t\t\t\t\t\t\t//tbone.matrixAutoUpdate = false;\n\t\t\t\t\t\t\toffsetMatrix.push( this.mBones[ i ].mOffsetMatrix.toTHREE() );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tvar skeleton = new THREE.Skeleton( allBones, offsetMatrix );\n\n\t\t\t\t\tthis.threeNode.bind( skeleton, new THREE.Matrix4() );\n\t\t\t\t\tthis.threeNode.material.skinning = true;\n\n\t\t\t\t};\n\n\t\t\t\tthis.toTHREE = function ( scene ) {\n\n\t\t\t\t\tif ( this.threeNode ) return this.threeNode;\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\t\tvar mat;\n\t\t\t\t\tif ( scene.mMaterials[ this.mMaterialIndex ] )\n\t\t\t\t\t\tmat = scene.mMaterials[ this.mMaterialIndex ].toTHREE( scene );\n\t\t\t\t\telse\n\t\t\t\t\t\tmat = new THREE.MeshLambertMaterial();\n\t\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( new Uint32Array( this.mIndexArray ), 1 ) );\n\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( this.mVertexBuffer, 3 ) );\n\t\t\t\t\tif ( this.mNormalBuffer && this.mNormalBuffer.length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'normal', new THREE.BufferAttribute( this.mNormalBuffer, 3 ) );\n\t\t\t\t\tif ( this.mColorBuffer && this.mColorBuffer.length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.BufferAttribute( this.mColorBuffer, 4 ) );\n\t\t\t\t\tif ( this.mTexCoordsBuffers[ 0 ] && this.mTexCoordsBuffers[ 0 ].length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( this.mTexCoordsBuffers[ 0 ] ), 2 ) );\n\t\t\t\t\tif ( this.mTexCoordsBuffers[ 1 ] && this.mTexCoordsBuffers[ 1 ].length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'uv1', new THREE.BufferAttribute( new Float32Array( this.mTexCoordsBuffers[ 1 ] ), 2 ) );\n\t\t\t\t\tif ( this.mTangentBuffer && this.mTangentBuffer.length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'tangents', new THREE.BufferAttribute( this.mTangentBuffer, 3 ) );\n\t\t\t\t\tif ( this.mBitangentBuffer && this.mBitangentBuffer.length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'bitangents', new THREE.BufferAttribute( this.mBitangentBuffer, 3 ) );\n\t\t\t\t\tif ( this.mBones.length > 0 ) {\n\n\t\t\t\t\t\tvar weights = [];\n\t\t\t\t\t\tvar bones = [];\n\n\t\t\t\t\t\tfor ( var i = 0; i < this.mBones.length; i ++ ) {\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < this.mBones[ i ].mWeights.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar weight = this.mBones[ i ].mWeights[ j ];\n\t\t\t\t\t\t\t\tif ( weight ) {\n\n\t\t\t\t\t\t\t\t\tif ( ! weights[ weight.mVertexId ] ) weights[ weight.mVertexId ] = [];\n\t\t\t\t\t\t\t\t\tif ( ! bones[ weight.mVertexId ] ) bones[ weight.mVertexId ] = [];\n\t\t\t\t\t\t\t\t\tweights[ weight.mVertexId ].push( weight.mWeight );\n\t\t\t\t\t\t\t\t\tbones[ weight.mVertexId ].push( parseInt( i ) );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( var i in bones ) {\n\n\t\t\t\t\t\t\tsortWeights( bones[ i ], weights[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar _weights = [];\n\t\t\t\t\t\tvar _bones = [];\n\n\t\t\t\t\t\tfor ( var i = 0; i < weights.length; i ++ ) {\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\tif ( weights[ i ] && bones[ i ] ) {\n\n\t\t\t\t\t\t\t\t\t_weights.push( weights[ i ][ j ] );\n\t\t\t\t\t\t\t\t\t_bones.push( bones[ i ][ j ] );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t_weights.push( 0 );\n\t\t\t\t\t\t\t\t\t_bones.push( 0 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.setAttribute( 'skinWeight', new THREE.BufferAttribute( new Float32Array( _weights ), BONESPERVERT ) );\n\t\t\t\t\t\tgeometry.setAttribute( 'skinIndex', new THREE.BufferAttribute( new Float32Array( _bones ), BONESPERVERT ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar mesh;\n\n\t\t\t\t\tif ( this.mBones.length == 0 )\n\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, mat );\n\n\t\t\t\t\tif ( this.mBones.length > 0 ) {\n\n\t\t\t\t\t\tmesh = new THREE.SkinnedMesh( geometry, mat );\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.threeNode = mesh;\n\t\t\t\t\t//mesh.matrixAutoUpdate = false;\n\t\t\t\t\treturn mesh;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiFace() {\n\n\t\t\t\tthis.mNumIndices = 0;\n\t\t\t\tthis.mIndices = [];\n\n\t\t\t}\n\n\t\t\tfunction aiVector3D() {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\treturn new THREE.Vector3( this.x, this.y, this.z );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiColor3D() {\n\n\t\t\t\tthis.r = 0;\n\t\t\t\tthis.g = 0;\n\t\t\t\tthis.b = 0;\n\t\t\t\tthis.a = 0;\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\treturn new THREE.Color( this.r, this.g, this.b );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiQuaternion() {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\t\t\tthis.w = 0;\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\treturn new THREE.Quaternion( this.x, this.y, this.z, this.w );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiVertexWeight() {\n\n\t\t\t\tthis.mVertexId = 0;\n\t\t\t\tthis.mWeight = 0;\n\n\t\t\t}\n\n\t\t\tfunction aiString() {\n\n\t\t\t\tthis.data = [];\n\t\t\t\tthis.toString = function () {\n\n\t\t\t\t\tvar str = '';\n\t\t\t\t\tthis.data.forEach( function ( i ) {\n\n\t\t\t\t\t\tstr += ( String.fromCharCode( i ) );\n\n\t\t\t\t\t} );\n\t\t\t\t\treturn str.replace( /[^\\x20-\\x7E]+/g, '' );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiVectorKey() {\n\n\t\t\t\tthis.mTime = 0;\n\t\t\t\tthis.mValue = null;\n\n\t\t\t}\n\n\t\t\tfunction aiQuatKey() {\n\n\t\t\t\tthis.mTime = 0;\n\t\t\t\tthis.mValue = null;\n\n\t\t\t}\n\n\t\t\tfunction aiNode() {\n\n\t\t\t\tthis.mName = '';\n\t\t\t\tthis.mTransformation = [];\n\t\t\t\tthis.mNumChildren = 0;\n\t\t\t\tthis.mNumMeshes = 0;\n\t\t\t\tthis.mMeshes = [];\n\t\t\t\tthis.mChildren = [];\n\t\t\t\tthis.toTHREE = function ( scene ) {\n\n\t\t\t\t\tif ( this.threeNode ) return this.threeNode;\n\t\t\t\t\tvar o = new THREE.Object3D();\n\t\t\t\t\to.name = this.mName;\n\t\t\t\t\to.matrix = this.mTransformation.toTHREE();\n\n\t\t\t\t\tfor ( var i = 0; i < this.mChildren.length; i ++ ) {\n\n\t\t\t\t\t\to.add( this.mChildren[ i ].toTHREE( scene ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < this.mMeshes.length; i ++ ) {\n\n\t\t\t\t\t\to.add( scene.mMeshes[ this.mMeshes[ i ] ].toTHREE( scene ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.threeNode = o;\n\t\t\t\t\t//o.matrixAutoUpdate = false;\n\t\t\t\t\to.matrix.decompose( o.position, o.quaternion, o.scale );\n\t\t\t\t\treturn o;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiBone() {\n\n\t\t\t\tthis.mName = '';\n\t\t\t\tthis.mNumWeights = 0;\n\t\t\t\tthis.mOffsetMatrix = 0;\n\n\t\t\t}\n\n\t\t\tfunction aiMaterialProperty() {\n\n\t\t\t\tthis.mKey = \"\";\n\t\t\t\tthis.mSemantic = 0;\n\t\t\t\tthis.mIndex = 0;\n\t\t\t\tthis.mData = [];\n\t\t\t\tthis.mDataLength = 0;\n\t\t\t\tthis.mType = 0;\n\t\t\t\tthis.dataAsColor = function () {\n\n\t\t\t\t\tvar array = ( new Uint8Array( this.mData ) ).buffer;\n\t\t\t\t\tvar reader = new DataView( array );\n\t\t\t\t\tvar r = reader.getFloat32( 0, true );\n\t\t\t\t\tvar g = reader.getFloat32( 4, true );\n\t\t\t\t\tvar b = reader.getFloat32( 8, true );\n\t\t\t\t\t//var a = reader.getFloat32(12, true);\n\t\t\t\t\treturn new THREE.Color( r, g, b );\n\n\t\t\t\t};\n\n\t\t\t\tthis.dataAsFloat = function () {\n\n\t\t\t\t\tvar array = ( new Uint8Array( this.mData ) ).buffer;\n\t\t\t\t\tvar reader = new DataView( array );\n\t\t\t\t\tvar r = reader.getFloat32( 0, true );\n\t\t\t\t\treturn r;\n\n\t\t\t\t};\n\n\t\t\t\tthis.dataAsBool = function () {\n\n\t\t\t\t\tvar array = ( new Uint8Array( this.mData ) ).buffer;\n\t\t\t\t\tvar reader = new DataView( array );\n\t\t\t\t\tvar r = reader.getFloat32( 0, true );\n\t\t\t\t\treturn !! r;\n\n\t\t\t\t};\n\n\t\t\t\tthis.dataAsString = function () {\n\n\t\t\t\t\tvar s = new aiString();\n\t\t\t\t\ts.data = this.mData;\n\t\t\t\t\treturn s.toString();\n\n\t\t\t\t};\n\n\t\t\t\tthis.dataAsMap = function () {\n\n\t\t\t\t\tvar s = new aiString();\n\t\t\t\t\ts.data = this.mData;\n\t\t\t\t\tvar path = s.toString();\n\t\t\t\t\tpath = path.replace( /\\\\/g, '/' );\n\n\t\t\t\t\tif ( path.indexOf( '/' ) != - 1 ) {\n\n\t\t\t\t\t\tpath = path.substr( path.lastIndexOf( '/' ) + 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn textureLoader.load( path );\n\n\t\t\t\t};\n\n\t\t\t}\n\t\t\tvar namePropMapping = {\n\n\t\t\t\t\"?mat.name\": \"name\",\n\t\t\t\t\"$mat.shadingm\": \"shading\",\n\t\t\t\t\"$mat.twosided\": \"twoSided\",\n\t\t\t\t\"$mat.wireframe\": \"wireframe\",\n\t\t\t\t\"$clr.ambient\": \"ambient\",\n\t\t\t\t\"$clr.diffuse\": \"color\",\n\t\t\t\t\"$clr.specular\": \"specular\",\n\t\t\t\t\"$clr.emissive\": \"emissive\",\n\t\t\t\t\"$clr.transparent\": \"transparent\",\n\t\t\t\t\"$clr.reflective\": \"reflect\",\n\t\t\t\t\"$mat.shininess\": \"shininess\",\n\t\t\t\t\"$mat.reflectivity\": \"reflectivity\",\n\t\t\t\t\"$mat.refracti\": \"refraction\",\n\t\t\t\t\"$tex.file\": \"map\"\n\n\t\t\t};\n\n\t\t\tvar nameTypeMapping = {\n\n\t\t\t\t\"?mat.name\": \"string\",\n\t\t\t\t\"$mat.shadingm\": \"bool\",\n\t\t\t\t\"$mat.twosided\": \"bool\",\n\t\t\t\t\"$mat.wireframe\": \"bool\",\n\t\t\t\t\"$clr.ambient\": \"color\",\n\t\t\t\t\"$clr.diffuse\": \"color\",\n\t\t\t\t\"$clr.specular\": \"color\",\n\t\t\t\t\"$clr.emissive\": \"color\",\n\t\t\t\t\"$clr.transparent\": \"color\",\n\t\t\t\t\"$clr.reflective\": \"color\",\n\t\t\t\t\"$mat.shininess\": \"float\",\n\t\t\t\t\"$mat.reflectivity\": \"float\",\n\t\t\t\t\"$mat.refracti\": \"float\",\n\t\t\t\t\"$tex.file\": \"map\"\n\n\t\t\t};\n\n\t\t\tfunction aiMaterial() {\n\n\t\t\t\tthis.mNumAllocated = 0;\n\t\t\t\tthis.mNumProperties = 0;\n\t\t\t\tthis.mProperties = [];\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\tvar mat = new THREE.MeshPhongMaterial();\n\n\t\t\t\t\tfor ( var i = 0; i < this.mProperties.length; i ++ ) {\n\n\t\t\t\t\t\tif ( nameTypeMapping[ this.mProperties[ i ].mKey ] == 'float' )\n\t\t\t\t\t\t\tmat[ namePropMapping[ this.mProperties[ i ].mKey ] ] = this.mProperties[ i ].dataAsFloat();\n\t\t\t\t\t\tif ( nameTypeMapping[ this.mProperties[ i ].mKey ] == 'color' )\n\t\t\t\t\t\t\tmat[ namePropMapping[ this.mProperties[ i ].mKey ] ] = this.mProperties[ i ].dataAsColor();\n\t\t\t\t\t\tif ( nameTypeMapping[ this.mProperties[ i ].mKey ] == 'bool' )\n\t\t\t\t\t\t\tmat[ namePropMapping[ this.mProperties[ i ].mKey ] ] = this.mProperties[ i ].dataAsBool();\n\t\t\t\t\t\tif ( nameTypeMapping[ this.mProperties[ i ].mKey ] == 'string' )\n\t\t\t\t\t\t\tmat[ namePropMapping[ this.mProperties[ i ].mKey ] ] = this.mProperties[ i ].dataAsString();\n\t\t\t\t\t\tif ( nameTypeMapping[ this.mProperties[ i ].mKey ] == 'map' ) {\n\n\t\t\t\t\t\t\tvar prop = this.mProperties[ i ];\n\t\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_DIFFUSE )\n\t\t\t\t\t\t\t\tmat.map = this.mProperties[ i ].dataAsMap();\n\t\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_NORMALS )\n\t\t\t\t\t\t\t\tmat.normalMap = this.mProperties[ i ].dataAsMap();\n\t\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_LIGHTMAP )\n\t\t\t\t\t\t\t\tmat.lightMap = this.mProperties[ i ].dataAsMap();\n\t\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_OPACITY )\n\t\t\t\t\t\t\t\tmat.alphaMap = this.mProperties[ i ].dataAsMap();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmat.ambient.r = .53;\n\t\t\t\t\tmat.ambient.g = .53;\n\t\t\t\t\tmat.ambient.b = .53;\n\t\t\t\t\tmat.color.r = 1;\n\t\t\t\t\tmat.color.g = 1;\n\t\t\t\t\tmat.color.b = 1;\n\t\t\t\t\treturn mat;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\n\t\t\tfunction veclerp( v1, v2, l ) {\n\n\t\t\t\tvar v = new THREE.Vector3();\n\t\t\t\tvar lm1 = 1 - l;\n\t\t\t\tv.x = v1.x * l + v2.x * lm1;\n\t\t\t\tv.y = v1.y * l + v2.y * lm1;\n\t\t\t\tv.z = v1.z * l + v2.z * lm1;\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction quatlerp( q1, q2, l ) {\n\n\t\t\t\treturn q1.clone().slerp( q2, 1 - l );\n\n\t\t\t}\n\n\t\t\tfunction sampleTrack( keys, time, lne, lerp ) {\n\n\t\t\t\tif ( keys.length == 1 ) return keys[ 0 ].mValue.toTHREE();\n\n\t\t\t\tvar dist = Infinity;\n\t\t\t\tvar key = null;\n\t\t\t\tvar nextKey = null;\n\n\t\t\t\tfor ( var i = 0; i < keys.length; i ++ ) {\n\n\t\t\t\t\tvar timeDist = Math.abs( keys[ i ].mTime - time );\n\n\t\t\t\t\tif ( timeDist < dist && keys[ i ].mTime <= time ) {\n\n\t\t\t\t\t\tdist = timeDist;\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tnextKey = keys[ i + 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! key ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t} else if ( nextKey ) {\n\n\t\t\t\t\tvar dT = nextKey.mTime - key.mTime;\n\t\t\t\t\tvar T = key.mTime - time;\n\t\t\t\t\tvar l = T / dT;\n\n\t\t\t\t\treturn lerp( key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnextKey = keys[ 0 ].clone();\n\t\t\t\t\tnextKey.mTime += lne;\n\n\t\t\t\t\tvar dT = nextKey.mTime - key.mTime;\n\t\t\t\t\tvar T = key.mTime - time;\n\t\t\t\t\tvar l = T / dT;\n\n\t\t\t\t\treturn lerp( key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction aiNodeAnim() {\n\n\t\t\t\tthis.mNodeName = \"\";\n\t\t\t\tthis.mNumPositionKeys = 0;\n\t\t\t\tthis.mNumRotationKeys = 0;\n\t\t\t\tthis.mNumScalingKeys = 0;\n\t\t\t\tthis.mPositionKeys = [];\n\t\t\t\tthis.mRotationKeys = [];\n\t\t\t\tthis.mScalingKeys = [];\n\t\t\t\tthis.mPreState = \"\";\n\t\t\t\tthis.mPostState = \"\";\n\t\t\t\tthis.init = function ( tps ) {\n\n\t\t\t\t\tif ( ! tps ) tps = 1;\n\n\t\t\t\t\tfunction t( t ) {\n\n\t\t\t\t\t\tt.mTime /= tps;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.mPositionKeys.forEach( t );\n\t\t\t\t\tthis.mRotationKeys.forEach( t );\n\t\t\t\t\tthis.mScalingKeys.forEach( t );\n\n\t\t\t\t};\n\n\t\t\t\tthis.sortKeys = function () {\n\n\t\t\t\t\tfunction comp( a, b ) {\n\n\t\t\t\t\t\treturn a.mTime - b.mTime;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.mPositionKeys.sort( comp );\n\t\t\t\t\tthis.mRotationKeys.sort( comp );\n\t\t\t\t\tthis.mScalingKeys.sort( comp );\n\n\t\t\t\t};\n\n\t\t\t\tthis.getLength = function () {\n\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\tMath.max.apply( null, this.mPositionKeys.map( function ( a ) {\n\n\t\t\t\t\t\t\treturn a.mTime;\n\n\t\t\t\t\t\t} ) ),\n\t\t\t\t\t\tMath.max.apply( null, this.mRotationKeys.map( function ( a ) {\n\n\t\t\t\t\t\t\treturn a.mTime;\n\n\t\t\t\t\t\t} ) ),\n\t\t\t\t\t\tMath.max.apply( null, this.mScalingKeys.map( function ( a ) {\n\n\t\t\t\t\t\t\treturn a.mTime;\n\n\t\t\t\t\t } ) )\n\t\t\t\t\t);\n\n\t\t\t\t};\n\n\t\t\t\tthis.toTHREE = function ( o ) {\n\n\t\t\t\t\tthis.sortKeys();\n\t\t\t\t\tvar length = this.getLength();\n\t\t\t\t\tvar track = new Virtulous.KeyFrameTrack();\n\n\t\t\t\t\tfor ( var i = 0; i < length; i += .05 ) {\n\n\t\t\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\t\t\tvar time = i;\n\t\t\t\t\t\tvar pos = sampleTrack( this.mPositionKeys, time, length, veclerp );\n\t\t\t\t\t\tvar scale = sampleTrack( this.mScalingKeys, time, length, veclerp );\n\t\t\t\t\t\tvar rotation = sampleTrack( this.mRotationKeys, time, length, quatlerp );\n\t\t\t\t\t\tmatrix.compose( pos, rotation, scale );\n\n\t\t\t\t\t\tvar key = new Virtulous.KeyFrame( time, matrix );\n\t\t\t\t\t\ttrack.addKey( key );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttrack.target = o.findNode( this.mNodeName ).toTHREE();\n\n\t\t\t\t\tvar tracks = [ track ];\n\n\t\t\t\t\tif ( o.nodeToBoneMap[ this.mNodeName ] ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < o.nodeToBoneMap[ this.mNodeName ].length; i ++ ) {\n\n\t\t\t\t\t\t\tvar t2 = track.clone();\n\t\t\t\t\t\t\tt2.target = o.nodeToBoneMap[ this.mNodeName ][ i ];\n\t\t\t\t\t\t\ttracks.push( t2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tracks;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiAnimation() {\n\n\t\t\t\tthis.mName = \"\";\n\t\t\t\tthis.mDuration = 0;\n\t\t\t\tthis.mTicksPerSecond = 0;\n\t\t\t\tthis.mNumChannels = 0;\n\t\t\t\tthis.mChannels = [];\n\t\t\t\tthis.toTHREE = function ( root ) {\n\n\t\t\t\t\tvar animationHandle = new Virtulous.Animation();\n\n\t\t\t\t\tfor ( var i in this.mChannels ) {\n\n\t\t\t\t\t\tthis.mChannels[ i ].init( this.mTicksPerSecond );\n\n\t\t\t\t\t\tvar tracks = this.mChannels[ i ].toTHREE( root );\n\n\t\t\t\t\t\tfor ( var j in tracks ) {\n\n\t\t\t\t\t\t\ttracks[ j ].init();\n\t\t\t\t\t\t\tanimationHandle.addTrack( tracks[ j ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationHandle.length = Math.max.apply( null, animationHandle.tracks.map( function ( e ) {\n\n\t\t\t\t\t\treturn e.length;\n\n\t\t\t\t\t} ) );\n\t\t\t\t\treturn animationHandle;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiTexture() {\n\n\t\t\t\tthis.mWidth = 0;\n\t\t\t\tthis.mHeight = 0;\n\t\t\t\tthis.texAchFormatHint = [];\n\t\t\t\tthis.pcData = [];\n\n\t\t\t}\n\n\t\t\tfunction aiLight() {\n\n\t\t\t\tthis.mName = '';\n\t\t\t\tthis.mType = 0;\n\t\t\t\tthis.mAttenuationConstant = 0;\n\t\t\t\tthis.mAttenuationLinear = 0;\n\t\t\t\tthis.mAttenuationQuadratic = 0;\n\t\t\t\tthis.mAngleInnerCone = 0;\n\t\t\t\tthis.mAngleOuterCone = 0;\n\t\t\t\tthis.mColorDiffuse = null;\n\t\t\t\tthis.mColorSpecular = null;\n\t\t\t\tthis.mColorAmbient = null;\n\n\t\t\t}\n\n\t\t\tfunction aiCamera() {\n\n\t\t\t\tthis.mName = '';\n\t\t\t\tthis.mPosition = null;\n\t\t\t\tthis.mLookAt = null;\n\t\t\t\tthis.mUp = null;\n\t\t\t\tthis.mHorizontalFOV = 0;\n\t\t\t\tthis.mClipPlaneNear = 0;\n\t\t\t\tthis.mClipPlaneFar = 0;\n\t\t\t\tthis.mAspect = 0;\n\n\t\t\t}\n\n\t\t\tfunction aiScene() {\n\n\t\t\t\tthis.versionMajor = 0;\n\t\t\t\tthis.versionMinor = 0;\n\t\t\t\tthis.versionRevision = 0;\n\t\t\t\tthis.compileFlags = 0;\n\t\t\t\tthis.mFlags = 0;\n\t\t\t\tthis.mNumMeshes = 0;\n\t\t\t\tthis.mNumMaterials = 0;\n\t\t\t\tthis.mNumAnimations = 0;\n\t\t\t\tthis.mNumTextures = 0;\n\t\t\t\tthis.mNumLights = 0;\n\t\t\t\tthis.mNumCameras = 0;\n\t\t\t\tthis.mRootNode = null;\n\t\t\t\tthis.mMeshes = [];\n\t\t\t\tthis.mMaterials = [];\n\t\t\t\tthis.mAnimations = [];\n\t\t\t\tthis.mLights = [];\n\t\t\t\tthis.mCameras = [];\n\t\t\t\tthis.nodeToBoneMap = {};\n\t\t\t\tthis.findNode = function ( name, root ) {\n\n\t\t\t\t\tif ( ! root ) {\n\n\t\t\t\t\t\troot = this.mRootNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( root.mName == name ) {\n\n\t\t\t\t\t\treturn root;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < root.mChildren.length; i ++ ) {\n\n\t\t\t\t\t\tvar ret = this.findNode( name, root.mChildren[ i ] );\n\t\t\t\t\t\tif ( ret ) return ret;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t};\n\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\tthis.nodeCount = 0;\n\n\t\t\t\t\tmarkBones( this );\n\n\t\t\t\t\tvar o = this.mRootNode.toTHREE( this );\n\n\t\t\t\t\tfor ( var i in this.mMeshes )\n\t\t\t\t\t\tthis.mMeshes[ i ].hookupSkeletons( this );\n\n\t\t\t\t\tif ( this.mAnimations.length > 0 ) {\n\n\t\t\t\t\t\tvar a = this.mAnimations[ 0 ].toTHREE( this );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { object: o, animation: a };\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiMatrix4() {\n\n\t\t\t\tthis.elements = [\n\t\t\t\t\t[],\n\t\t\t\t\t[],\n\t\t\t\t\t[],\n\t\t\t\t\t[]\n\t\t\t\t];\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\tvar m = new THREE.Matrix4();\n\n\t\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\t\tfor ( var i2 = 0; i2 < 4; ++ i2 ) {\n\n\t\t\t\t\t\t\tm.elements[ i * 4 + i2 ] = this.elements[ i2 ][ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn m;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar littleEndian = true;\n\n\t\t\tfunction readFloat( dataview ) {\n\n\t\t\t\tvar val = dataview.getFloat32( dataview.readOffset, littleEndian );\n\t\t\t\tdataview.readOffset += 4;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_double( dataview ) {\n\n\t\t\t\tvar val = dataview.getFloat64( dataview.readOffset, littleEndian );\n\t\t\t\tdataview.readOffset += 8;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_uint8_t( dataview ) {\n\n\t\t\t\tvar val = dataview.getUint8( dataview.readOffset );\n\t\t\t\tdataview.readOffset += 1;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_uint16_t( dataview ) {\n\n\t\t\t\tvar val = dataview.getUint16( dataview.readOffset, littleEndian );\n\t\t\t\tdataview.readOffset += 2;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_unsigned_int( dataview ) {\n\n\t\t\t\tvar val = dataview.getUint32( dataview.readOffset, littleEndian );\n\t\t\t\tdataview.readOffset += 4;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_uint32_t( dataview ) {\n\n\t\t\t\tvar val = dataview.getUint32( dataview.readOffset, littleEndian );\n\t\t\t\tdataview.readOffset += 4;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiVector3D( stream ) {\n\n\t\t\t\tvar v = new aiVector3D();\n\t\t\t\tv.x = readFloat( stream );\n\t\t\t\tv.y = readFloat( stream );\n\t\t\t\tv.z = readFloat( stream );\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiColor3D( stream ) {\n\n\t\t\t\tvar c = new aiColor3D();\n\t\t\t\tc.r = readFloat( stream );\n\t\t\t\tc.g = readFloat( stream );\n\t\t\t\tc.b = readFloat( stream );\n\t\t\t\treturn c;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiQuaternion( stream ) {\n\n\t\t\t\tvar v = new aiQuaternion();\n\t\t\t\tv.w = readFloat( stream );\n\t\t\t\tv.x = readFloat( stream );\n\t\t\t\tv.y = readFloat( stream );\n\t\t\t\tv.z = readFloat( stream );\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiString( stream ) {\n\n\t\t\t\tvar s = new aiString();\n\t\t\t\tvar stringlengthbytes = Read_unsigned_int( stream );\n\t\t\t\tstream.ReadBytes( s.data, 1, stringlengthbytes );\n\t\t\t\treturn s.toString();\n\n\t\t\t}\n\n\t\t\tfunction Read_aiVertexWeight( stream ) {\n\n\t\t\t\tvar w = new aiVertexWeight();\n\t\t\t\tw.mVertexId = Read_unsigned_int( stream );\n\t\t\t\tw.mWeight = readFloat( stream );\n\t\t\t\treturn w;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiMatrix4x4( stream ) {\n\n\t\t\t\tvar m = new aiMatrix4();\n\n\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\tfor ( var i2 = 0; i2 < 4; ++ i2 ) {\n\n\t\t\t\t\t\tm.elements[ i ][ i2 ] = readFloat( stream );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn m;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiVectorKey( stream ) {\n\n\t\t\t\tvar v = new aiVectorKey();\n\t\t\t\tv.mTime = Read_double( stream );\n\t\t\t\tv.mValue = Read_aiVector3D( stream );\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiQuatKey( stream ) {\n\n\t\t\t\tvar v = new aiQuatKey();\n\t\t\t\tv.mTime = Read_double( stream );\n\t\t\t\tv.mValue = Read_aiQuaternion( stream );\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction ReadArray_aiVertexWeight( stream, data, size ) {\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) data[ i ] = Read_aiVertexWeight( stream );\n\n\t\t\t}\n\n\t\t\tfunction ReadArray_aiVectorKey( stream, data, size ) {\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) data[ i ] = Read_aiVectorKey( stream );\n\n\t\t\t}\n\n\t\t\tfunction ReadArray_aiQuatKey( stream, data, size ) {\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) data[ i ] = Read_aiQuatKey( stream );\n\n\t\t\t}\n\n\t\t\tfunction ReadBounds( stream, T /*p*/, n ) {\n\n\t\t\t\t// not sure what to do here, the data isn't really useful.\n\t\t\t\treturn stream.Seek( sizeof( T ) * n, aiOrigin_CUR );\n\n\t\t\t}\n\n\t\t\tfunction ai_assert( bool ) {\n\n\t\t\t\tif ( ! bool )\n\t\t\t\t\tthrow ( \"asset failed\" );\n\n\t\t\t}\n\n\t\t\tfunction ReadBinaryNode( stream, parent, depth ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AINODE );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tvar node = new aiNode();\n\t\t\t\tnode.mParent = parent;\n\t\t\t\tnode.mDepth = depth;\n\t\t\t\tnode.mName = Read_aiString( stream );\n\t\t\t\tnode.mTransformation = Read_aiMatrix4x4( stream );\n\t\t\t\tnode.mNumChildren = Read_unsigned_int( stream );\n\t\t\t\tnode.mNumMeshes = Read_unsigned_int( stream );\n\n\t\t\t\tif ( node.mNumMeshes ) {\n\n\t\t\t\t\tnode.mMeshes = [];\n\n\t\t\t\t\tfor ( var i = 0; i < node.mNumMeshes; ++ i ) {\n\n\t\t\t\t\t\tnode.mMeshes[ i ] = Read_unsigned_int( stream );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( node.mNumChildren ) {\n\n\t\t\t\t\tnode.mChildren = [];\n\n\t\t\t\t\tfor ( var i = 0; i < node.mNumChildren; ++ i ) {\n\n\t\t\t\t\t\tvar node2 = ReadBinaryNode( stream, node, depth ++ );\n\t\t\t\t\t\tnode.mChildren[ i ] = node2;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t\t// -----------------------------------------------------------------------------------\n\n\t\t\tfunction ReadBinaryBone( stream, b ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIBONE );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tb.mName = Read_aiString( stream );\n\t\t\t\tb.mNumWeights = Read_unsigned_int( stream );\n\t\t\t\tb.mOffsetMatrix = Read_aiMatrix4x4( stream );\n\t\t\t\t// for the moment we write dumb min/max values for the bones, too.\n\t\t\t\t// maybe I'll add a better, hash-like solution later\n\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\tReadBounds( stream, b.mWeights, b.mNumWeights );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tb.mWeights = [];\n\t\t\t\t\tReadArray_aiVertexWeight( stream, b.mWeights, b.mNumWeights );\n\n\t\t\t\t}\n\n\t\t\t\treturn b;\n\n\t\t\t}\n\n\t\t\tfunction ReadBinaryMesh( stream, mesh ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIMESH );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tmesh.mPrimitiveTypes = Read_unsigned_int( stream );\n\t\t\t\tmesh.mNumVertices = Read_unsigned_int( stream );\n\t\t\t\tmesh.mNumFaces = Read_unsigned_int( stream );\n\t\t\t\tmesh.mNumBones = Read_unsigned_int( stream );\n\t\t\t\tmesh.mMaterialIndex = Read_unsigned_int( stream );\n\t\t\t\tmesh.mNumUVComponents = [];\n\t\t\t\t// first of all, write bits for all existent vertex components\n\t\t\t\tvar c = Read_unsigned_int( stream );\n\n\t\t\t\tif ( c & ASSBIN_MESH_HAS_POSITIONS ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, mesh.mVertices, mesh.mNumVertices );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tmesh.mVertices = [];\n\t\t\t\t\t\tmesh.mVertexBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\n\t\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( c & ASSBIN_MESH_HAS_NORMALS ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, mesh.mNormals, mesh.mNumVertices );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tmesh.mNormals = [];\n\t\t\t\t\t\tmesh.mNormalBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\n\t\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, mesh.mTangents, mesh.mNumVertices );\n\t\t\t\t\t\tReadBounds( stream, mesh.mBitangents, mesh.mNumVertices );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tmesh.mTangents = [];\n\t\t\t\t\t\tmesh.mTangentBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\n\t\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\n\t\t\t\t\t\tmesh.mBitangents = [];\n\t\t\t\t\t\tmesh.mBitangentBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\n\t\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++ n ) {\n\n\t\t\t\t\tif ( ! ( c & ASSBIN_MESH_HAS_COLOR( n ) ) ) break;\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, mesh.mColors[ n ], mesh.mNumVertices );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tmesh.mColors[ n ] = [];\n\t\t\t\t\t\tmesh.mColorBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4 );\n\t\t\t\t\t\tstream.Seek( mesh.mNumVertices * 4 * 4, aiOrigin_CUR );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmesh.mTexCoordsBuffers = [];\n\n\t\t\t\tfor ( var n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++ n ) {\n\n\t\t\t\t\tif ( ! ( c & ASSBIN_MESH_HAS_TEXCOORD( n ) ) ) break;\n\n\t\t\t\t\t// write number of UV components\n\t\t\t\t\tmesh.mNumUVComponents[ n ] = Read_unsigned_int( stream );\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, mesh.mTextureCoords[ n ], mesh.mNumVertices );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tmesh.mTextureCoords[ n ] = [];\n\t\t\t\t\t\t//note that assbin always writes 3d texcoords\n\t\t\t\t\t\tmesh.mTexCoordsBuffers[ n ] = [];\n\n\t\t\t\t\t\tfor ( var uv = 0; uv < mesh.mNumVertices; uv ++ ) {\n\n\t\t\t\t\t\t\tmesh.mTexCoordsBuffers[ n ].push( readFloat( stream ) );\n\t\t\t\t\t\t\tmesh.mTexCoordsBuffers[ n ].push( readFloat( stream ) );\n\t\t\t\t\t\t\treadFloat( stream );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// write faces. There are no floating-point calculations involved\n\t\t\t\t// in these, so we can write a simple hash over the face data\n\t\t\t\t// to the dump file. We generate a single 32 Bit hash for 512 faces\n\t\t\t\t// using Assimp's standard hashing function.\n\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\tRead_unsigned_int( stream );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t// if there are less than 2^16 vertices, we can simply use 16 bit integers ...\n\t\t\t\t\tmesh.mFaces = [];\n\t\t\t\t\tmesh.mIndexArray = [];\n\n\t\t\t\t\tfor ( var i = 0; i < mesh.mNumFaces; ++ i ) {\n\n\t\t\t\t\t\tvar f = mesh.mFaces[ i ] = new aiFace();\n\t\t\t\t\t\t// BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\n\t\t\t\t\t\tf.mNumIndices = Read_uint16_t( stream );\n\t\t\t\t\t\tf.mIndices = [];\n\n\t\t\t\t\t\tfor ( var a = 0; a < f.mNumIndices; ++ a ) {\n\n\t\t\t\t\t\t\tif ( mesh.mNumVertices < ( 1 << 16 ) ) {\n\n\t\t\t\t\t\t\t\tf.mIndices[ a ] = Read_uint16_t( stream );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tf.mIndices[ a ] = Read_unsigned_int( stream );\n\n\t\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( f.mNumIndices === 3 ) {\n\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 0 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 1 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 2 ] );\n\n\t\t\t\t\t\t} else if ( f.mNumIndices === 4 ) {\n\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 0 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 1 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 2 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 2 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 3 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 0 ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthrow ( new Error( \"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\" ) );\n\n\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// write bones\n\t\t\t\tif ( mesh.mNumBones ) {\n\n\t\t\t\t\tmesh.mBones = [];\n\n\t\t\t\t\tfor ( var a = 0; a < mesh.mNumBones; ++ a ) {\n\n\t\t\t\t\t\tmesh.mBones[ a ] = new aiBone();\n\t\t\t\t\t\tReadBinaryBone( stream, mesh.mBones[ a ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction ReadBinaryMaterialProperty( stream, prop ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tprop.mKey = Read_aiString( stream );\n\t\t\t\tprop.mSemantic = Read_unsigned_int( stream );\n\t\t\t\tprop.mIndex = Read_unsigned_int( stream );\n\t\t\t\tprop.mDataLength = Read_unsigned_int( stream );\n\t\t\t\tprop.mType = Read_unsigned_int( stream );\n\t\t\t\tprop.mData = [];\n\t\t\t\tstream.ReadBytes( prop.mData, 1, prop.mDataLength );\n\n\t\t\t}\n\n\t\t\t// -----------------------------------------------------------------------------------\n\n\t\t\tfunction ReadBinaryMaterial( stream, mat ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIMATERIAL );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tmat.mNumAllocated = mat.mNumProperties = Read_unsigned_int( stream );\n\n\t\t\t\tif ( mat.mNumProperties ) {\n\n\t\t\t\t\tif ( mat.mProperties ) {\n\n\t\t\t\t\t\tdelete mat.mProperties;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmat.mProperties = [];\n\n\t\t\t\t\tfor ( var i = 0; i < mat.mNumProperties; ++ i ) {\n\n\t\t\t\t\t\tmat.mProperties[ i ] = new aiMaterialProperty();\n\t\t\t\t\t\tReadBinaryMaterialProperty( stream, mat.mProperties[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// -----------------------------------------------------------------------------------\n\t\t\tfunction ReadBinaryNodeAnim( stream, nd ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AINODEANIM );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tnd.mNodeName = Read_aiString( stream );\n\t\t\t\tnd.mNumPositionKeys = Read_unsigned_int( stream );\n\t\t\t\tnd.mNumRotationKeys = Read_unsigned_int( stream );\n\t\t\t\tnd.mNumScalingKeys = Read_unsigned_int( stream );\n\t\t\t\tnd.mPreState = Read_unsigned_int( stream );\n\t\t\t\tnd.mPostState = Read_unsigned_int( stream );\n\n\t\t\t\tif ( nd.mNumPositionKeys ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, nd.mPositionKeys, nd.mNumPositionKeys );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tnd.mPositionKeys = [];\n\t\t\t\t\t\tReadArray_aiVectorKey( stream, nd.mPositionKeys, nd.mNumPositionKeys );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( nd.mNumRotationKeys ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, nd.mRotationKeys, nd.mNumRotationKeys );\n\n\t\t\t\t\t} else {\n\n\t\t\t \t\t\t// else write as usual\n\n\t\t\t\t\t\tnd.mRotationKeys = [];\n\t\t\t\t\t\tReadArray_aiQuatKey( stream, nd.mRotationKeys, nd.mNumRotationKeys );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( nd.mNumScalingKeys ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, nd.mScalingKeys, nd.mNumScalingKeys );\n\n\t\t\t\t\t} else {\n\n\t\t \t\t\t\t// else write as usual\n\n\t\t\t\t\t\tnd.mScalingKeys = [];\n\t\t\t\t\t\tReadArray_aiVectorKey( stream, nd.mScalingKeys, nd.mNumScalingKeys );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// -----------------------------------------------------------------------------------\n\t\t\tfunction ReadBinaryAnim( stream, anim ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIANIMATION );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tanim.mName = Read_aiString( stream );\n\t\t\t\tanim.mDuration = Read_double( stream );\n\t\t\t\tanim.mTicksPerSecond = Read_double( stream );\n\t\t\t\tanim.mNumChannels = Read_unsigned_int( stream );\n\n\t\t\t\tif ( anim.mNumChannels ) {\n\n\t\t\t\t\tanim.mChannels = [];\n\n\t\t\t\t\tfor ( var a = 0; a < anim.mNumChannels; ++ a ) {\n\n\t\t\t\t\t\tanim.mChannels[ a ] = new aiNodeAnim();\n\t\t\t\t\t\tReadBinaryNodeAnim( stream, anim.mChannels[ a ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction ReadBinaryTexture( stream, tex ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AITEXTURE );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\ttex.mWidth = Read_unsigned_int( stream );\n\t\t\t\ttex.mHeight = Read_unsigned_int( stream );\n\t\t\t\tstream.ReadBytes( tex.achFormatHint, 1, 4 );\n\n\t\t\t\tif ( ! shortened ) {\n\n\t\t\t\t\tif ( ! tex.mHeight ) {\n\n\t\t\t\t\t\ttex.pcData = [];\n\t\t\t\t\t\tstream.ReadBytes( tex.pcData, 1, tex.mWidth );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttex.pcData = [];\n\t\t\t\t\t\tstream.ReadBytes( tex.pcData, 1, tex.mWidth * tex.mHeight * 4 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// -----------------------------------------------------------------------------------\n\t\t\tfunction ReadBinaryLight( stream, l ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AILIGHT );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tl.mName = Read_aiString( stream );\n\t\t\t\tl.mType = Read_unsigned_int( stream );\n\n\t\t\t\tif ( l.mType != aiLightSource_DIRECTIONAL ) {\n\n\t\t\t\t\tl.mAttenuationConstant = readFloat( stream );\n\t\t\t\t\tl.mAttenuationLinear = readFloat( stream );\n\t\t\t\t\tl.mAttenuationQuadratic = readFloat( stream );\n\n\t\t\t\t}\n\n\t\t\t\tl.mColorDiffuse = Read_aiColor3D( stream );\n\t\t\t\tl.mColorSpecular = Read_aiColor3D( stream );\n\t\t\t\tl.mColorAmbient = Read_aiColor3D( stream );\n\n\t\t\t\tif ( l.mType == aiLightSource_SPOT ) {\n\n\t\t\t\t\tl.mAngleInnerCone = readFloat( stream );\n\t\t\t\t\tl.mAngleOuterCone = readFloat( stream );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// -----------------------------------------------------------------------------------\n\t\t\tfunction ReadBinaryCamera( stream, cam ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AICAMERA );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tcam.mName = Read_aiString( stream );\n\t\t\t\tcam.mPosition = Read_aiVector3D( stream );\n\t\t\t\tcam.mLookAt = Read_aiVector3D( stream );\n\t\t\t\tcam.mUp = Read_aiVector3D( stream );\n\t\t\t\tcam.mHorizontalFOV = readFloat( stream );\n\t\t\t\tcam.mClipPlaneNear = readFloat( stream );\n\t\t\t\tcam.mClipPlaneFar = readFloat( stream );\n\t\t\t\tcam.mAspect = readFloat( stream );\n\n\t\t\t}\n\n\t\t\tfunction ReadBinaryScene( stream, scene ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AISCENE );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tscene.mFlags = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumMeshes = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumMaterials = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumAnimations = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumTextures = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumLights = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumCameras = Read_unsigned_int( stream );\n\t\t\t\t// Read node graph\n\t\t\t\tscene.mRootNode = new aiNode();\n\t\t\t\tscene.mRootNode = ReadBinaryNode( stream, null, 0 );\n\t\t\t\t// Read all meshes\n\t\t\t\tif ( scene.mNumMeshes ) {\n\n\t\t\t\t\tscene.mMeshes = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumMeshes; ++ i ) {\n\n\t\t\t\t\t\tscene.mMeshes[ i ] = new aiMesh();\n\t\t\t\t\t\tReadBinaryMesh( stream, scene.mMeshes[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// Read materials\n\t\t\t\tif ( scene.mNumMaterials ) {\n\n\t\t\t\t\tscene.mMaterials = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumMaterials; ++ i ) {\n\n\t\t\t\t\t\tscene.mMaterials[ i ] = new aiMaterial();\n\t\t\t\t\t\tReadBinaryMaterial( stream, scene.mMaterials[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// Read all animations\n\t\t\t\tif ( scene.mNumAnimations ) {\n\n\t\t\t\t\tscene.mAnimations = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumAnimations; ++ i ) {\n\n\t\t\t\t\t\tscene.mAnimations[ i ] = new aiAnimation();\n\t\t\t\t\t\tReadBinaryAnim( stream, scene.mAnimations[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// Read all textures\n\t\t\t\tif ( scene.mNumTextures ) {\n\n\t\t\t\t\tscene.mTextures = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumTextures; ++ i ) {\n\n\t\t\t\t\t\tscene.mTextures[ i ] = new aiTexture();\n\t\t\t\t\t\tReadBinaryTexture( stream, scene.mTextures[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// Read lights\n\t\t\t\tif ( scene.mNumLights ) {\n\n\t\t\t\t\tscene.mLights = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumLights; ++ i ) {\n\n\t\t\t\t\t\tscene.mLights[ i ] = new aiLight();\n\t\t\t\t\t\tReadBinaryLight( stream, scene.mLights[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// Read cameras\n\t\t\t\tif ( scene.mNumCameras ) {\n\n\t\t\t\t\tscene.mCameras = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumCameras; ++ i ) {\n\n\t\t\t\t\t\tscene.mCameras[ i ] = new aiCamera();\n\t\t\t\t\t\tReadBinaryCamera( stream, scene.mCameras[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tvar aiOrigin_CUR = 0;\n\t\t\tvar aiOrigin_BEG = 1;\n\n\t\t\tfunction extendStream( stream ) {\n\n\t\t\t\tstream.readOffset = 0;\n\t\t\t\tstream.Seek = function ( off, ori ) {\n\n\t\t\t\t\tif ( ori == aiOrigin_CUR ) {\n\n\t\t\t\t\t\tstream.readOffset += off;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ori == aiOrigin_BEG ) {\n\n\t\t\t\t\t\tstream.readOffset = off;\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tstream.ReadBytes = function ( buff, size, n ) {\n\n\t\t\t\t\tvar bytes = size * n;\n\t\t\t\t\tfor ( var i = 0; i < bytes; i ++ )\n\t\t\t\t\t\tbuff[ i ] = Read_uint8_t( this );\n\n\t\t\t\t};\n\n\t\t\t\tstream.subArray32 = function ( start, end ) {\n\n\t\t\t\t\tvar buff = this.buffer;\n\t\t\t\t\tvar newbuff = buff.slice( start, end );\n\t\t\t\t\treturn new Float32Array( newbuff );\n\n\t\t\t\t};\n\n\t\t\t\tstream.subArrayUint16 = function ( start, end ) {\n\n\t\t\t\t\tvar buff = this.buffer;\n\t\t\t\t\tvar newbuff = buff.slice( start, end );\n\t\t\t\t\treturn new Uint16Array( newbuff );\n\n\t\t\t\t};\n\n\t\t\t\tstream.subArrayUint8 = function ( start, end ) {\n\n\t\t\t\t\tvar buff = this.buffer;\n\t\t\t\t\tvar newbuff = buff.slice( start, end );\n\t\t\t\t\treturn new Uint8Array( newbuff );\n\n\t\t\t\t};\n\n\t\t\t\tstream.subArrayUint32 = function ( start, end ) {\n\n\t\t\t\t\tvar buff = this.buffer;\n\t\t\t\t\tvar newbuff = buff.slice( start, end );\n\t\t\t\t\treturn new Uint32Array( newbuff );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar shortened, compressed;\n\n\t\t\tfunction InternReadFile( pFiledata ) {\n\n\t\t\t\tvar pScene = new aiScene();\n\t\t\t\tvar stream = new DataView( pFiledata );\n\t\t\t\textendStream( stream );\n\t\t\t\tstream.Seek( 44, aiOrigin_CUR ); // signature\n\t\t\t\t/*unsigned int versionMajor =*/\n\t\t\t\tpScene.versionMajor = Read_unsigned_int( stream );\n\t\t\t\t/*unsigned int versionMinor =*/\n\t\t\t\tpScene.versionMinor = Read_unsigned_int( stream );\n\t\t\t\t/*unsigned int versionRevision =*/\n\t\t\t\tpScene.versionRevision = Read_unsigned_int( stream );\n\t\t\t\t/*unsigned int compileFlags =*/\n\t\t\t\tpScene.compileFlags = Read_unsigned_int( stream );\n\t\t\t\tshortened = Read_uint16_t( stream ) > 0;\n\t\t\t\tcompressed = Read_uint16_t( stream ) > 0;\n\t\t\t\tif ( shortened )\n\t\t\t\t\tthrow \"Shortened binaries are not supported!\";\n\t\t\t\tstream.Seek( 256, aiOrigin_CUR ); // original filename\n\t\t\t\tstream.Seek( 128, aiOrigin_CUR ); // options\n\t\t\t\tstream.Seek( 64, aiOrigin_CUR ); // padding\n\t\t\t\tif ( compressed ) {\n\n\t\t\t\t\tvar uncompressedSize = Read_uint32_t( stream );\n\t\t\t\t\tvar compressedSize = stream.FileSize() - stream.Tell();\n\t\t\t\t\tvar compressedData = [];\n\t\t\t\t\tstream.Read( compressedData, 1, compressedSize );\n\t\t\t\t\tvar uncompressedData = [];\n\t\t\t\t\tuncompress( uncompressedData, uncompressedSize, compressedData, compressedSize );\n\t\t\t\t\tvar buff = new ArrayBuffer( uncompressedData );\n\t\t\t\t\tReadBinaryScene( buff, pScene );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tReadBinaryScene( stream, pScene );\n\n\t\t\t\t}\n\n\t\t\t\treturn pScene.toTHREE();\n\n\t\t\t}\n\n\t\t\treturn InternReadFile( buffer );\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.AssimpLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/TGALoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Daosheng Mu / https://github.com/DaoshengMu/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author takahirox / https://github.com/takahirox/\n\t */\n\n\tTHREE.TGALoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.TGALoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.TGALoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texture = new THREE.Texture();\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.setPath( this.path );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\ttexture.image = scope.parse( buffer );\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\t\tonLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tparse: function ( buffer ) {\n\n\t\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n\t\t\tfunction tgaCheckHeader( header ) {\n\n\t\t\t\tswitch ( header.image_type ) {\n\n\t\t\t\t\t// check indexed type\n\n\t\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\t\tif ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// check colormap type\n\n\t\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\t\tif ( header.colormap_type ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// What the need of a file without data ?\n\n\t\t\t\t\tcase TGA_TYPE_NO_DATA:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t\t\t\t\t// Invalid type ?\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type \"%s\".', header.image_type );\n\n\t\t\t\t}\n\n\t\t\t\t// check image width and height\n\n\t\t\t\tif ( header.width <= 0 || header.height <= 0 ) {\n\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid image size.' );\n\n\t\t\t\t}\n\n\t\t\t\t// check image pixel size\n\n\t\t\t\tif ( header.pixel_size !== 8 && header.pixel_size !== 16 &&\n\t\t\t\t\theader.pixel_size !== 24 && header.pixel_size !== 32 ) {\n\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// parse tga image buffer\n\n\t\t\tfunction tgaParse( use_rle, use_pal, header, offset, data ) {\n\n\t\t\t\tvar pixel_data,\n\t\t\t\t\tpixel_size,\n\t\t\t\t\tpixel_total,\n\t\t\t\t\tpalettes;\n\n\t\t\t\tpixel_size = header.pixel_size >> 3;\n\t\t\t\tpixel_total = header.width * header.height * pixel_size;\n\n\t\t\t\t // read palettes\n\n\t\t\t\t if ( use_pal ) {\n\n\t\t\t\t\t palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );\n\n\t\t\t\t }\n\n\t\t\t\t // read RLE\n\n\t\t\t\t if ( use_rle ) {\n\n\t\t\t\t\t pixel_data = new Uint8Array( pixel_total );\n\n\t\t\t\t\tvar c, count, i;\n\t\t\t\t\tvar shift = 0;\n\t\t\t\t\tvar pixels = new Uint8Array( pixel_size );\n\n\t\t\t\t\twhile ( shift < pixel_total ) {\n\n\t\t\t\t\t\tc = data[ offset ++ ];\n\t\t\t\t\t\tcount = ( c & 0x7f ) + 1;\n\n\t\t\t\t\t\t// RLE pixels\n\n\t\t\t\t\t\tif ( c & 0x80 ) {\n\n\t\t\t\t\t\t\t// bind pixel tmp array\n\n\t\t\t\t\t\t\tfor ( i = 0; i < pixel_size; ++ i ) {\n\n\t\t\t\t\t\t\t\tpixels[ i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// copy pixel array\n\n\t\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\t\tpixel_data.set( pixels, shift + i * pixel_size );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tshift += pixel_size * count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\t\tcount *= pixel_size;\n\t\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\t\tpixel_data[ shift + i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tshift += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t } else {\n\n\t\t\t\t\t// raw pixels\n\n\t\t\t\t\tpixel_data = data.subarray(\n\t\t\t\t\t\t offset, offset += ( use_pal ? header.width * header.height : pixel_total )\n\t\t\t\t\t);\n\n\t\t\t\t }\n\n\t\t\t\t return {\n\t\t\t\t\tpixel_data: pixel_data,\n\t\t\t\t\tpalettes: palettes\n\t\t\t\t };\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {\n\n\t\t\t\tvar colormap = palettes;\n\t\t\t\tvar color, i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\t\tvar color, i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\t\tcolor = image[ i + 0 ] + ( image[ i + 1 ] << 8 ); // Inversed ?\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) >> 3;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\t\tvar i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 3 ) {\n\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\t\tvar i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 4 ) {\n\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\t\tvar color, i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = color;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = color;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = color;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\t\tvar i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction getTgaRGBA( data, width, height, image, palette ) {\n\n\t\t\t\tvar x_start,\n\t\t\t\t\ty_start,\n\t\t\t\t\tx_step,\n\t\t\t\t\ty_step,\n\t\t\t\t\tx_end,\n\t\t\t\t\ty_end;\n\n\t\t\t\tswitch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {\n\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase TGA_ORIGIN_UL:\n\t\t\t\t\t\tx_start = 0;\n\t\t\t\t\t\tx_step = 1;\n\t\t\t\t\t\tx_end = width;\n\t\t\t\t\t\ty_start = 0;\n\t\t\t\t\t\ty_step = 1;\n\t\t\t\t\t\ty_end = height;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TGA_ORIGIN_BL:\n\t\t\t\t\t\tx_start = 0;\n\t\t\t\t\t\tx_step = 1;\n\t\t\t\t\t\tx_end = width;\n\t\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\t\ty_step = - 1;\n\t\t\t\t\t\ty_end = - 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TGA_ORIGIN_UR:\n\t\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\t\tx_step = - 1;\n\t\t\t\t\t\tx_end = - 1;\n\t\t\t\t\t\ty_start = 0;\n\t\t\t\t\t\ty_step = 1;\n\t\t\t\t\t\ty_end = height;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TGA_ORIGIN_BR:\n\t\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\t\tx_step = - 1;\n\t\t\t\t\t\tx_end = - 1;\n\t\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\t\ty_step = - 1;\n\t\t\t\t\t\ty_end = - 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( use_grey ) {\n\n\t\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\ttgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 16:\n\t\t\t\t\t\t\ttgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\ttgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 16:\n\t\t\t\t\t\t\ttgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 24:\n\t\t\t\t\t\t\ttgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 32:\n\t\t\t\t\t\t\ttgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Load image data according to specific method\n\t\t\t\t// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n\t\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\t// TGA constants\n\n\t\t\tvar TGA_TYPE_NO_DATA = 0,\n\t\t\t\tTGA_TYPE_INDEXED = 1,\n\t\t\t\tTGA_TYPE_RGB = 2,\n\t\t\t\tTGA_TYPE_GREY = 3,\n\t\t\t\tTGA_TYPE_RLE_INDEXED = 9,\n\t\t\t\tTGA_TYPE_RLE_RGB = 10,\n\t\t\t\tTGA_TYPE_RLE_GREY = 11,\n\n\t\t\t\tTGA_ORIGIN_MASK = 0x30,\n\t\t\t\tTGA_ORIGIN_SHIFT = 0x04,\n\t\t\t\tTGA_ORIGIN_BL = 0x00,\n\t\t\t\tTGA_ORIGIN_BR = 0x01,\n\t\t\t\tTGA_ORIGIN_UL = 0x02,\n\t\t\t\tTGA_ORIGIN_UR = 0x03;\n\n\t\t\tif ( buffer.length < 19 ) console.error( 'THREE.TGALoader: Not enough data to contain header.' );\n\n\t\t\tvar content = new Uint8Array( buffer ),\n\t\t\t\toffset = 0,\n\t\t\t\theader = {\n\t\t\t\t\tid_length: content[ offset ++ ],\n\t\t\t\t\tcolormap_type: content[ offset ++ ],\n\t\t\t\t\timage_type: content[ offset ++ ],\n\t\t\t\t\tcolormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tcolormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tcolormap_size: content[ offset ++ ],\n\t\t\t\t\torigin: [\n\t\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8\n\t\t\t\t\t],\n\t\t\t\t\twidth: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\theight: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tpixel_size: content[ offset ++ ],\n\t\t\t\t\tflags: content[ offset ++ ]\n\t\t\t\t};\n\n\t\t\t// check tga if it is valid format\n\n\t\t\ttgaCheckHeader( header );\n\n\t\t\tif ( header.id_length + offset > buffer.length ) {\n\n\t\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t\t}\n\n\t\t\t// skip the needn't data\n\n\t\t\toffset += header.id_length;\n\n\t\t\t// get targa information about RLE compression and palette\n\n\t\t\tvar use_rle = false,\n\t\t\t\tuse_pal = false,\n\t\t\t\tuse_grey = false;\n\n\t\t\tswitch ( header.image_type ) {\n\n\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\tuse_rle = true;\n\t\t\t\t\tuse_pal = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\t\tuse_pal = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\t\tuse_rle = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\tuse_rle = true;\n\t\t\t\t\tuse_grey = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\t\tuse_grey = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar useOffscreen = typeof OffscreenCanvas !== 'undefined';\n\n\t\t\tvar canvas = useOffscreen ? new OffscreenCanvas( header.width, header.height ) : document.createElement( 'canvas' );\n\t\t\tcanvas.width = header.width;\n\t\t\tcanvas.height = header.height;\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tvar imageData = context.createImageData( header.width, header.height );\n\n\t\t\tvar result = tgaParse( use_rle, use_pal, header, offset, content );\n\t\t\tvar rgbaData = getTgaRGBA( imageData.data, header.width, header.height, result.pixel_data, result.palettes );\n\n\t\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\t\treturn useOffscreen ? canvas.transferToImageBitmap() : canvas;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.TGALoader;\n});\n\ndefine('skylark-threejs-ex/loaders/ColladaLoader',[\n\t\"skylark-threejs\",\n\t\"./TGALoader\"\n],function(THREE,TGALoader){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\tTHREE.ColladaLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.ColladaLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.ColladaLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( scope.path === '' ) ? THREE.LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\toptions: {\n\n\t\t\tset convertUpAxis( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.' );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparse: function ( text, path ) {\n\n\t\t\tfunction getElementsByTagName( xml, name ) {\n\n\t\t\t\t// Non recursive xml.getElementsByTagName() ...\n\n\t\t\t\tvar array = [];\n\t\t\t\tvar childNodes = xml.childNodes;\n\n\t\t\t\tfor ( var i = 0, l = childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeName === name ) {\n\n\t\t\t\t\t\tarray.push( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tfunction parseStrings( text ) {\n\n\t\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\t\tvar parts = text.trim().split( /\\s+/ );\n\t\t\t\tvar array = new Array( parts.length );\n\n\t\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = parts[ i ];\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tfunction parseFloats( text ) {\n\n\t\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\t\tvar parts = text.trim().split( /\\s+/ );\n\t\t\t\tvar array = new Array( parts.length );\n\n\t\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = parseFloat( parts[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tfunction parseInts( text ) {\n\n\t\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\t\tvar parts = text.trim().split( /\\s+/ );\n\t\t\t\tvar array = new Array( parts.length );\n\n\t\t\t\tfor ( var i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = parseInt( parts[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tfunction parseId( text ) {\n\n\t\t\t\treturn text.substring( 1 );\n\n\t\t\t}\n\n\t\t\tfunction generateId() {\n\n\t\t\t\treturn 'three_default_' + ( count ++ );\n\n\t\t\t}\n\n\t\t\tfunction isEmpty( object ) {\n\n\t\t\t\treturn Object.keys( object ).length === 0;\n\n\t\t\t}\n\n\t\t\t// asset\n\n\t\t\tfunction parseAsset( xml ) {\n\n\t\t\t\treturn {\n\t\t\t\t\tunit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),\n\t\t\t\t\tupAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction parseAssetUnit( xml ) {\n\n\t\t\t\tif ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {\n\n\t\t\t\t\treturn parseFloat( xml.getAttribute( 'meter' ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn 1; // default 1 meter\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseAssetUpAxis( xml ) {\n\n\t\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\n\n\t\t\t}\n\n\t\t\t// library\n\n\t\t\tfunction parseLibrary( xml, libraryName, nodeName, parser ) {\n\n\t\t\t\tvar library = getElementsByTagName( xml, libraryName )[ 0 ];\n\n\t\t\t\tif ( library !== undefined ) {\n\n\t\t\t\t\tvar elements = getElementsByTagName( library, nodeName );\n\n\t\t\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\t\tparser( elements[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction buildLibrary( data, builder ) {\n\n\t\t\t\tfor ( var name in data ) {\n\n\t\t\t\t\tvar object = data[ name ];\n\t\t\t\t\tobject.build = builder( data[ name ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// get\n\n\t\t\tfunction getBuild( data, builder ) {\n\n\t\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\t\tdata.build = builder( data );\n\n\t\t\t\treturn data.build;\n\n\t\t\t}\n\n\t\t\t// animation\n\n\t\t\tfunction parseAnimation( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tsources: {},\n\t\t\t\t\tsamplers: {},\n\t\t\t\t\tchannels: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tvar id;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'source':\n\t\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'sampler':\n\t\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\t\tdata.samplers[ id ] = parseAnimationSampler( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'channel':\n\t\t\t\t\t\t\tid = child.getAttribute( 'target' );\n\t\t\t\t\t\t\tdata.channels[ id ] = parseAnimationChannel( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.animations[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parseAnimationSampler( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tinputs: {},\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'input':\n\t\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseAnimationChannel( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tvar target = xml.getAttribute( 'target' );\n\n\t\t\t\t// parsing SID Addressing Syntax\n\n\t\t\t\tvar parts = target.split( '/' );\n\n\t\t\t\tvar id = parts.shift();\n\t\t\t\tvar sid = parts.shift();\n\n\t\t\t\t// check selection syntax\n\n\t\t\t\tvar arraySyntax = ( sid.indexOf( '(' ) !== - 1 );\n\t\t\t\tvar memberSyntax = ( sid.indexOf( '.' ) !== - 1 );\n\n\t\t\t\tif ( memberSyntax ) {\n\n\t\t\t\t\t//  member selection access\n\n\t\t\t\t\tparts = sid.split( '.' );\n\t\t\t\t\tsid = parts.shift();\n\t\t\t\t\tdata.member = parts.shift();\n\n\t\t\t\t} else if ( arraySyntax ) {\n\n\t\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n\t\t\t\t\tvar indices = sid.split( '(' );\n\t\t\t\t\tsid = indices.shift();\n\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\t\tindices[ i ] = parseInt( indices[ i ].replace( /\\)/, '' ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.indices = indices;\n\n\t\t\t\t}\n\n\t\t\t\tdata.id = id;\n\t\t\t\tdata.sid = sid;\n\n\t\t\t\tdata.arraySyntax = arraySyntax;\n\t\t\t\tdata.memberSyntax = memberSyntax;\n\n\t\t\t\tdata.sampler = parseId( xml.getAttribute( 'source' ) );\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction buildAnimation( data ) {\n\n\t\t\t\tvar tracks = [];\n\n\t\t\t\tvar channels = data.channels;\n\t\t\t\tvar samplers = data.samplers;\n\t\t\t\tvar sources = data.sources;\n\n\t\t\t\tfor ( var target in channels ) {\n\n\t\t\t\t\tif ( channels.hasOwnProperty( target ) ) {\n\n\t\t\t\t\t\tvar channel = channels[ target ];\n\t\t\t\t\t\tvar sampler = samplers[ channel.sampler ];\n\n\t\t\t\t\t\tvar inputId = sampler.inputs.INPUT;\n\t\t\t\t\t\tvar outputId = sampler.inputs.OUTPUT;\n\n\t\t\t\t\t\tvar inputSource = sources[ inputId ];\n\t\t\t\t\t\tvar outputSource = sources[ outputId ];\n\n\t\t\t\t\t\tvar animation = buildAnimationChannel( channel, inputSource, outputSource );\n\n\t\t\t\t\t\tcreateKeyframeTracks( animation, tracks );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn tracks;\n\n\t\t\t}\n\n\t\t\tfunction getAnimation( id ) {\n\n\t\t\t\treturn getBuild( library.animations[ id ], buildAnimation );\n\n\t\t\t}\n\n\t\t\tfunction buildAnimationChannel( channel, inputSource, outputSource ) {\n\n\t\t\t\tvar node = library.nodes[ channel.id ];\n\t\t\t\tvar object3D = getNode( node.id );\n\n\t\t\t\tvar transform = node.transforms[ channel.sid ];\n\t\t\t\tvar defaultMatrix = node.matrix.clone().transpose();\n\n\t\t\t\tvar time, stride;\n\t\t\t\tvar i, il, j, jl;\n\n\t\t\t\tvar data = {};\n\n\t\t\t\t// the collada spec allows the animation of data in various ways.\n\t\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n\t\t\t\tswitch ( transform ) {\n\n\t\t\t\t\tcase 'matrix':\n\n\t\t\t\t\t\tfor ( i = 0, il = inputSource.array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\ttime = inputSource.array[ i ];\n\t\t\t\t\t\t\tstride = i * outputSource.stride;\n\n\t\t\t\t\t\t\tif ( data[ time ] === undefined ) data[ time ] = {};\n\n\t\t\t\t\t\t\tif ( channel.arraySyntax === true ) {\n\n\t\t\t\t\t\t\t\tvar value = outputSource.array[ stride ];\n\t\t\t\t\t\t\t\tvar index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];\n\n\t\t\t\t\t\t\t\tdata[ time ][ index ] = value;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tfor ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tdata[ time ][ j ] = outputSource.array[ stride + j ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tvar keyframes = prepareAnimationData( data, defaultMatrix );\n\n\t\t\t\tvar animation = {\n\t\t\t\t\tname: object3D.uuid,\n\t\t\t\t\tkeyframes: keyframes\n\t\t\t\t};\n\n\t\t\t\treturn animation;\n\n\t\t\t}\n\n\t\t\tfunction prepareAnimationData( data, defaultMatrix ) {\n\n\t\t\t\tvar keyframes = [];\n\n\t\t\t\t// transfer data into a sortable array\n\n\t\t\t\tfor ( var time in data ) {\n\n\t\t\t\t\tkeyframes.push( { time: parseFloat( time ), value: data[ time ] } );\n\n\t\t\t\t}\n\n\t\t\t\t// ensure keyframes are sorted by time\n\n\t\t\t\tkeyframes.sort( ascending );\n\n\t\t\t\t// now we clean up all animation data, so we can use them for keyframe tracks\n\n\t\t\t\tfor ( var i = 0; i < 16; i ++ ) {\n\n\t\t\t\t\ttransformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn keyframes;\n\n\t\t\t\t// array sort function\n\n\t\t\t\tfunction ascending( a, b ) {\n\n\t\t\t\t\treturn a.time - b.time;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar position = new THREE.Vector3();\n\t\t\tvar scale = new THREE.Vector3();\n\t\t\tvar quaternion = new THREE.Quaternion();\n\n\t\t\tfunction createKeyframeTracks( animation, tracks ) {\n\n\t\t\t\tvar keyframes = animation.keyframes;\n\t\t\t\tvar name = animation.name;\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar positionData = [];\n\t\t\t\tvar quaternionData = [];\n\t\t\t\tvar scaleData = [];\n\n\t\t\t\tfor ( var i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\t\tvar time = keyframe.time;\n\t\t\t\t\tvar value = keyframe.value;\n\n\t\t\t\t\tmatrix.fromArray( value ).transpose();\n\t\t\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\t\t\ttimes.push( time );\n\t\t\t\t\tpositionData.push( position.x, position.y, position.z );\n\t\t\t\t\tquaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );\n\t\t\t\t\tscaleData.push( scale.x, scale.y, scale.z );\n\n\t\t\t\t}\n\n\t\t\t\tif ( positionData.length > 0 ) tracks.push( new THREE.VectorKeyframeTrack( name + '.position', times, positionData ) );\n\t\t\t\tif ( quaternionData.length > 0 ) tracks.push( new THREE.QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) );\n\t\t\t\tif ( scaleData.length > 0 ) tracks.push( new THREE.VectorKeyframeTrack( name + '.scale', times, scaleData ) );\n\n\t\t\t\treturn tracks;\n\n\t\t\t}\n\n\t\t\tfunction transformAnimationData( keyframes, property, defaultValue ) {\n\n\t\t\t\tvar keyframe;\n\n\t\t\t\tvar empty = true;\n\t\t\t\tvar i, l;\n\n\t\t\t\t// check, if values of a property are missing in our keyframes\n\n\t\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\t\tif ( keyframe.value[ property ] === undefined ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = null; // mark as missing\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tempty = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( empty === true ) {\n\n\t\t\t\t\t// no values at all, so we set a default value\n\n\t\t\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\t\t\tkeyframe.value[ property ] = defaultValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// filling gaps\n\n\t\t\t\t\tcreateMissingKeyframes( keyframes, property );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction createMissingKeyframes( keyframes, property ) {\n\n\t\t\t\tvar prev, next;\n\n\t\t\t\tfor ( var i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\t\tif ( keyframe.value[ property ] === null ) {\n\n\t\t\t\t\t\tprev = getPrev( keyframes, i, property );\n\t\t\t\t\t\tnext = getNext( keyframes, i, property );\n\n\t\t\t\t\t\tif ( prev === null ) {\n\n\t\t\t\t\t\t\tkeyframe.value[ property ] = next.value[ property ];\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( next === null ) {\n\n\t\t\t\t\t\t\tkeyframe.value[ property ] = prev.value[ property ];\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinterpolate( keyframe, prev, next, property );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getPrev( keyframes, i, property ) {\n\n\t\t\t\twhile ( i >= 0 ) {\n\n\t\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\t\ti --;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tfunction getNext( keyframes, i, property ) {\n\n\t\t\t\twhile ( i < keyframes.length ) {\n\n\t\t\t\t\tvar keyframe = keyframes[ i ];\n\n\t\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\t\ti ++;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tfunction interpolate( key, prev, next, property ) {\n\n\t\t\t\tif ( ( next.time - prev.time ) === 0 ) {\n\n\t\t\t\t\tkey.value[ property ] = prev.value[ property ];\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tkey.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];\n\n\t\t\t}\n\n\t\t\t// animation clips\n\n\t\t\tfunction parseAnimationClip( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'id' ) || 'default',\n\t\t\t\t\tstart: parseFloat( xml.getAttribute( 'start' ) || 0 ),\n\t\t\t\t\tend: parseFloat( xml.getAttribute( 'end' ) || 0 ),\n\t\t\t\t\tanimations: []\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'instance_animation':\n\t\t\t\t\t\t\tdata.animations.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.clips[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction buildAnimationClip( data ) {\n\n\t\t\t\tvar tracks = [];\n\n\t\t\t\tvar name = data.name;\n\t\t\t\tvar duration = ( data.end - data.start ) || - 1;\n\t\t\t\tvar animations = data.animations;\n\n\t\t\t\tfor ( var i = 0, il = animations.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar animationTracks = getAnimation( animations[ i ] );\n\n\t\t\t\t\tfor ( var j = 0, jl = animationTracks.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\ttracks.push( animationTracks[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new THREE.AnimationClip( name, duration, tracks );\n\n\t\t\t}\n\n\t\t\tfunction getAnimationClip( id ) {\n\n\t\t\t\treturn getBuild( library.clips[ id ], buildAnimationClip );\n\n\t\t\t}\n\n\t\t\t// controller\n\n\t\t\tfunction parseController( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\t\t// there is exactly one skin per controller\n\t\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\t\tdata.skin = parseSkin( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'morph':\n\t\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.controllers[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parseSkin( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tsources: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'bind_shape_matrix':\n\t\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'source':\n\t\t\t\t\t\t\tvar id = child.getAttribute( 'id' );\n\t\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'joints':\n\t\t\t\t\t\t\tdata.joints = parseJoints( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'vertex_weights':\n\t\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseJoints( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tinputs: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'input':\n\t\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseVertexWeights( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tinputs: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'input':\n\t\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\t\tvar offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\t\tdata.inputs[ semantic ] = { id: id, offset: offset };\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\t\tdata.vcount = parseInts( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tdata.v = parseInts( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction buildController( data ) {\n\n\t\t\t\tvar build = {\n\t\t\t\t\tid: data.id\n\t\t\t\t};\n\n\t\t\t\tvar geometry = library.geometries[ build.id ];\n\n\t\t\t\tif ( data.skin !== undefined ) {\n\n\t\t\t\t\tbuild.skin = buildSkin( data.skin );\n\n\t\t\t\t\t// we enhance the 'sources' property of the corresponding geometry with our skin data\n\n\t\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\n\t\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\n\n\t\t\t\t}\n\n\t\t\t\treturn build;\n\n\t\t\t}\n\n\t\t\tfunction buildSkin( data ) {\n\n\t\t\t\tvar BONE_LIMIT = 4;\n\n\t\t\t\tvar build = {\n\t\t\t\t\tjoints: [], // this must be an array to preserve the joint order\n\t\t\t\t\tindices: {\n\t\t\t\t\t\tarray: [],\n\t\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t\t},\n\t\t\t\t\tweights: {\n\t\t\t\t\t\tarray: [],\n\t\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tvar sources = data.sources;\n\t\t\t\tvar vertexWeights = data.vertexWeights;\n\n\t\t\t\tvar vcount = vertexWeights.vcount;\n\t\t\t\tvar v = vertexWeights.v;\n\t\t\t\tvar jointOffset = vertexWeights.inputs.JOINT.offset;\n\t\t\t\tvar weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\n\t\t\t\tvar jointSource = data.sources[ data.joints.inputs.JOINT ];\n\t\t\t\tvar inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];\n\n\t\t\t\tvar weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;\n\t\t\t\tvar stride = 0;\n\n\t\t\t\tvar i, j, l;\n\n\t\t\t\t// procces skin data for each vertex\n\n\t\t\t\tfor ( i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex\n\t\t\t\t\tvar vertexSkinData = [];\n\n\t\t\t\t\tfor ( j = 0; j < jointCount; j ++ ) {\n\n\t\t\t\t\t\tvar skinIndex = v[ stride + jointOffset ];\n\t\t\t\t\t\tvar weightId = v[ stride + weightOffset ];\n\t\t\t\t\t\tvar skinWeight = weights[ weightId ];\n\n\t\t\t\t\t\tvertexSkinData.push( { index: skinIndex, weight: skinWeight } );\n\n\t\t\t\t\t\tstride += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// we sort the joints in descending order based on the weights.\n\t\t\t\t\t// this ensures, we only procced the most important joints of the vertex\n\n\t\t\t\t\tvertexSkinData.sort( descending );\n\n\t\t\t\t\t// now we provide for each vertex a set of four index and weight values.\n\t\t\t\t\t// the order of the skin data matches the order of vertices\n\n\t\t\t\t\tfor ( j = 0; j < BONE_LIMIT; j ++ ) {\n\n\t\t\t\t\t\tvar d = vertexSkinData[ j ];\n\n\t\t\t\t\t\tif ( d !== undefined ) {\n\n\t\t\t\t\t\t\tbuild.indices.array.push( d.index );\n\t\t\t\t\t\t\tbuild.weights.array.push( d.weight );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbuild.indices.array.push( 0 );\n\t\t\t\t\t\t\tbuild.weights.array.push( 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// setup bind matrix\n\n\t\t\t\tif ( data.bindShapeMatrix ) {\n\n\t\t\t\t\tbuild.bindMatrix = new THREE.Matrix4().fromArray( data.bindShapeMatrix ).transpose();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbuild.bindMatrix = new THREE.Matrix4().identity();\n\n\t\t\t\t}\n\n\t\t\t\t// process bones and inverse bind matrix data\n\n\t\t\t\tfor ( i = 0, l = jointSource.array.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar name = jointSource.array[ i ];\n\t\t\t\t\tvar boneInverse = new THREE.Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();\n\n\t\t\t\t\tbuild.joints.push( { name: name, boneInverse: boneInverse } );\n\n\t\t\t\t}\n\n\t\t\t\treturn build;\n\n\t\t\t\t// array sort function\n\n\t\t\t\tfunction descending( a, b ) {\n\n\t\t\t\t\treturn b.weight - a.weight;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getController( id ) {\n\n\t\t\t\treturn getBuild( library.controllers[ id ], buildController );\n\n\t\t\t}\n\n\t\t\t// image\n\n\t\t\tfunction parseImage( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tinit_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent\n\t\t\t\t};\n\n\t\t\t\tlibrary.images[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction buildImage( data ) {\n\n\t\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\t\treturn data.init_from;\n\n\t\t\t}\n\n\t\t\tfunction getImage( id ) {\n\n\t\t\t\tvar data = library.images[ id ];\n\n\t\t\t\tif ( data !== undefined ) {\n\n\t\t\t\t\treturn getBuild( data, buildImage );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find image with ID:', id );\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// effect\n\n\t\t\tfunction parseEffect( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'profile_COMMON':\n\t\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.effects[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectProfileCOMMON( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tsurfaces: {},\n\t\t\t\t\tsamplers: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'newparam':\n\t\t\t\t\t\t\tparseEffectNewparam( child, data );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\t\tdata.technique = parseEffectTechnique( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectNewparam( xml, data ) {\n\n\t\t\t\tvar sid = xml.getAttribute( 'sid' );\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'surface':\n\t\t\t\t\t\t\tdata.surfaces[ sid ] = parseEffectSurface( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'sampler2D':\n\t\t\t\t\t\t\tdata.samplers[ sid ] = parseEffectSampler( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseEffectSurface( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'init_from':\n\t\t\t\t\t\t\tdata.init_from = child.textContent;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectSampler( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'source':\n\t\t\t\t\t\t\tdata.source = child.textContent;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectTechnique( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'constant':\n\t\t\t\t\t\tcase 'lambert':\n\t\t\t\t\t\tcase 'blinn':\n\t\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\t\tdata.type = child.nodeName;\n\t\t\t\t\t\t\tdata.parameters = parseEffectParameters( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectParameters( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tcase 'ambient':\n\t\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectParameter( child );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\t\tdata[ child.nodeName ] = {\n\t\t\t\t\t\t\t\topaque: child.getAttribute( 'opaque' ),\n\t\t\t\t\t\t\t\tdata: parseEffectParameter( child )\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectParameter( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tdata[ child.nodeName ] = parseFloats( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'float':\n\t\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectParameterTexture( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\ttechnique: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\t\tparseEffectParameterTextureExtra( child, data );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectParameterTextureExtra( xml, data ) {\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique( child, data );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseEffectParameterTextureExtraTechnique( xml, data ) {\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'repeatU':\n\t\t\t\t\t\tcase 'repeatV':\n\t\t\t\t\t\tcase 'offsetU':\n\t\t\t\t\t\tcase 'offsetV':\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'wrapU':\n\t\t\t\t\t\tcase 'wrapV':\n\n\t\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\n\n\t\t\t\t\t\t\tif ( child.textContent.toUpperCase() === 'TRUE' ) {\n\n\t\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 1;\n\n\t\t\t\t\t\t\t} else if ( child.textContent.toUpperCase() === 'FALSE' ) {\n\n\t\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 0;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseInt( child.textContent );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseEffectExtra( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseEffectExtraTechnique( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\t\tdata[ child.nodeName ] = parseInt( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction buildEffect( data ) {\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction getEffect( id ) {\n\n\t\t\t\treturn getBuild( library.effects[ id ], buildEffect );\n\n\t\t\t}\n\n\t\t\t// material\n\n\t\t\tfunction parseMaterial( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'instance_effect':\n\t\t\t\t\t\t\tdata.url = parseId( child.getAttribute( 'url' ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.materials[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction getTextureLoader( image ) {\n\n\t\t\t\tvar loader;\n\n\t\t\t\tvar extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/\n\t\t\t\textension = extension.toLowerCase();\n\n\t\t\t\tswitch ( extension ) {\n\n\t\t\t\t\tcase 'tga':\n\t\t\t\t\t\tloader = tgaLoader;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tloader = textureLoader;\n\n\t\t\t\t}\n\n\t\t\t\treturn loader;\n\n\t\t\t}\n\n\t\t\tfunction buildMaterial( data ) {\n\n\t\t\t\tvar effect = getEffect( data.url );\n\t\t\t\tvar technique = effect.profile.technique;\n\t\t\t\tvar extra = effect.profile.extra;\n\n\t\t\t\tvar material;\n\n\t\t\t\tswitch ( technique.type ) {\n\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\tcase 'blinn':\n\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmaterial = new THREE.MeshBasicMaterial();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.name = data.name || '';\n\n\t\t\t\tfunction getTexture( textureObject ) {\n\n\t\t\t\t\tvar sampler = effect.profile.samplers[ textureObject.id ];\n\t\t\t\t\tvar image = null;\n\n\t\t\t\t\t// get image\n\n\t\t\t\t\tif ( sampler !== undefined ) {\n\n\t\t\t\t\t\tvar surface = effect.profile.surfaces[ sampler.source ];\n\t\t\t\t\t\timage = getImage( surface.init_from );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );\n\t\t\t\t\t\timage = getImage( textureObject.id );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// create texture if image is avaiable\n\n\t\t\t\t\tif ( image !== null ) {\n\n\t\t\t\t\t\tvar loader = getTextureLoader( image );\n\n\t\t\t\t\t\tif ( loader !== undefined ) {\n\n\t\t\t\t\t\t\tvar texture = loader.load( image );\n\n\t\t\t\t\t\t\tvar extra = textureObject.extra;\n\n\t\t\t\t\t\t\tif ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {\n\n\t\t\t\t\t\t\t\tvar technique = extra.technique;\n\n\t\t\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n\t\t\t\t\t\t\t\ttexture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );\n\t\t\t\t\t\t\t\ttexture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn texture;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image );\n\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id );\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar parameters = technique.parameters;\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tvar parameter = parameters[ key ];\n\n\t\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\t\tif ( parameter.color ) material.color.fromArray( parameter.color );\n\t\t\t\t\t\t\tif ( parameter.texture ) material.map = getTexture( parameter.texture );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\t\tif ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );\n\t\t\t\t\t\t\tif ( parameter.texture ) material.specularMap = getTexture( parameter.texture );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\t\tif ( parameter.texture ) material.normalMap = getTexture( parameter.texture );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'ambient':\n\t\t\t\t\t\t\tif ( parameter.texture ) material.lightMap = getTexture( parameter.texture );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\t\tif ( parameter.float && material.shininess ) material.shininess = parameter.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\t\tif ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color );\n\t\t\t\t\t\t\tif ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar transparent = parameters[ 'transparent' ];\n\t\t\t\tvar transparency = parameters[ 'transparency' ];\n\n\t\t\t\t// <transparency> does not exist but <transparent>\n\n\t\t\t\tif ( transparency === undefined && transparent ) {\n\n\t\t\t\t\ttransparency = {\n\t\t\t\t\t\tfloat: 1\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\t// <transparent> does not exist but <transparency>\n\n\t\t\t\tif ( transparent === undefined && transparency ) {\n\n\t\t\t\t\ttransparent = {\n\t\t\t\t\t\topaque: 'A_ONE',\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\tcolor: [ 1, 1, 1, 1 ]\n\t\t\t\t\t\t} };\n\n\t\t\t\t}\n\n\t\t\t\tif ( transparent && transparency ) {\n\n\t\t\t\t\t// handle case if a texture exists but no color\n\n\t\t\t\t\tif ( transparent.data.texture ) {\n\n\t\t\t\t\t\t// we do not set an alpha map (see #13792)\n\n\t\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar color = transparent.data.color;\n\n\t\t\t\t\t\tswitch ( transparent.opaque ) {\n\n\t\t\t\t\t\t\tcase 'A_ONE':\n\t\t\t\t\t\t\t\tmaterial.opacity = color[ 3 ] * transparency.float;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'RGB_ZERO':\n\t\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 0 ] * transparency.float );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'A_ZERO':\n\t\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 3 ] * transparency.float );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'RGB_ONE':\n\t\t\t\t\t\t\t\tmaterial.opacity = color[ 0 ] * transparency.float;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( material.opacity < 1 ) material.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tif ( extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1 ) {\n\n\t\t\t\t\tmaterial.side = THREE.DoubleSide;\n\n\t\t\t\t}\n\n\t\t\t\treturn material;\n\n\t\t\t}\n\n\t\t\tfunction getMaterial( id ) {\n\n\t\t\t\treturn getBuild( library.materials[ id ], buildMaterial );\n\n\t\t\t}\n\n\t\t\t// camera\n\n\t\t\tfunction parseCamera( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'optics':\n\t\t\t\t\t\t\tdata.optics = parseCameraOptics( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.cameras[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parseCameraOptics( xml ) {\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\t\treturn parseCameraTechnique( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn {};\n\n\t\t\t}\n\n\t\t\tfunction parseCameraTechnique( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'perspective':\n\t\t\t\t\t\tcase 'orthographic':\n\n\t\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\t\tdata.parameters = parseCameraParameters( child );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseCameraParameters( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'xfov':\n\t\t\t\t\t\tcase 'yfov':\n\t\t\t\t\t\tcase 'xmag':\n\t\t\t\t\t\tcase 'ymag':\n\t\t\t\t\t\tcase 'znear':\n\t\t\t\t\t\tcase 'zfar':\n\t\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction buildCamera( data ) {\n\n\t\t\t\tvar camera;\n\n\t\t\t\tswitch ( data.optics.technique ) {\n\n\t\t\t\t\tcase 'perspective':\n\t\t\t\t\t\tcamera = new THREE.PerspectiveCamera(\n\t\t\t\t\t\t\tdata.optics.parameters.yfov,\n\t\t\t\t\t\t\tdata.optics.parameters.aspect_ratio,\n\t\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'orthographic':\n\t\t\t\t\t\tvar ymag = data.optics.parameters.ymag;\n\t\t\t\t\t\tvar xmag = data.optics.parameters.xmag;\n\t\t\t\t\t\tvar aspectRatio = data.optics.parameters.aspect_ratio;\n\n\t\t\t\t\t\txmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;\n\t\t\t\t\t\tymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;\n\n\t\t\t\t\t\txmag *= 0.5;\n\t\t\t\t\t\tymag *= 0.5;\n\n\t\t\t\t\t\tcamera = new THREE.OrthographicCamera(\n\t\t\t\t\t\t\t- xmag, xmag, ymag, - ymag, // left, right, top, bottom\n\t\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcamera = new THREE.PerspectiveCamera();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcamera.name = data.name || '';\n\n\t\t\t\treturn camera;\n\n\t\t\t}\n\n\t\t\tfunction getCamera( id ) {\n\n\t\t\t\tvar data = library.cameras[ id ];\n\n\t\t\t\tif ( data !== undefined ) {\n\n\t\t\t\t\treturn getBuild( data, buildCamera );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find camera with ID:', id );\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// light\n\n\t\t\tfunction parseLight( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\t\tdata = parseLightTechnique( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.lights[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parseLightTechnique( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'directional':\n\t\t\t\t\t\tcase 'point':\n\t\t\t\t\t\tcase 'spot':\n\t\t\t\t\t\tcase 'ambient':\n\n\t\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\t\tdata.parameters = parseLightParameters( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseLightParameters( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tdata.color = new THREE.Color().fromArray( array );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'falloff_angle':\n\t\t\t\t\t\t\tdata.falloffAngle = parseFloat( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'quadratic_attenuation':\n\t\t\t\t\t\t\tvar f = parseFloat( child.textContent );\n\t\t\t\t\t\t\tdata.distance = f ? Math.sqrt( 1 / f ) : 0;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction buildLight( data ) {\n\n\t\t\t\tvar light;\n\n\t\t\t\tswitch ( data.technique ) {\n\n\t\t\t\t\tcase 'directional':\n\t\t\t\t\t\tlight = new THREE.DirectionalLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'point':\n\t\t\t\t\t\tlight = new THREE.PointLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'spot':\n\t\t\t\t\t\tlight = new THREE.SpotLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\t\tlight = new THREE.AmbientLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.parameters.color ) light.color.copy( data.parameters.color );\n\t\t\t\tif ( data.parameters.distance ) light.distance = data.parameters.distance;\n\n\t\t\t\treturn light;\n\n\t\t\t}\n\n\t\t\tfunction getLight( id ) {\n\n\t\t\t\tvar data = library.lights[ id ];\n\n\t\t\t\tif ( data !== undefined ) {\n\n\t\t\t\t\treturn getBuild( data, buildLight );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find light with ID:', id );\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// geometry\n\n\t\t\tfunction parseGeometry( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\t\tsources: {},\n\t\t\t\t\tvertices: {},\n\t\t\t\t\tprimitives: []\n\t\t\t\t};\n\n\t\t\t\tvar mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];\n\n\t\t\t\t// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\t\t\t\tif ( mesh === undefined ) return;\n\n\t\t\t\tfor ( var i = 0; i < mesh.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = mesh.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tvar id = child.getAttribute( 'id' );\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'source':\n\t\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'vertices':\n\t\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n\t\t\t\t\t\t\tdata.vertices = parseGeometryVertices( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'polygons':\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\t\tdata.primitives.push( parseGeometryPrimitive( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.geometries[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parseSource( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: 3\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'float_array':\n\t\t\t\t\t\t\tdata.array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Name_array':\n\t\t\t\t\t\t\tdata.array = parseStrings( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\t\tvar accessor = getElementsByTagName( child, 'accessor' )[ 0 ];\n\n\t\t\t\t\t\t\tif ( accessor !== undefined ) {\n\n\t\t\t\t\t\t\t\tdata.stride = parseInt( accessor.getAttribute( 'stride' ) );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseGeometryVertices( xml ) {\n\n\t\t\t\tvar data = {};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tdata[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseGeometryPrimitive( xml ) {\n\n\t\t\t\tvar primitive = {\n\t\t\t\t\ttype: xml.nodeName,\n\t\t\t\t\tmaterial: xml.getAttribute( 'material' ),\n\t\t\t\t\tcount: parseInt( xml.getAttribute( 'count' ) ),\n\t\t\t\t\tinputs: {},\n\t\t\t\t\tstride: 0,\n\t\t\t\t\thasUV: false\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'input':\n\t\t\t\t\t\t\tvar id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\t\tvar semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\t\tvar offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\t\tvar set = parseInt( child.getAttribute( 'set' ) );\n\t\t\t\t\t\t\tvar inputname = ( set > 0 ? semantic + set : semantic );\n\t\t\t\t\t\t\tprimitive.inputs[ inputname ] = { id: id, offset: offset };\n\t\t\t\t\t\t\tprimitive.stride = Math.max( primitive.stride, offset + 1 );\n\t\t\t\t\t\t\tif ( semantic === 'TEXCOORD' ) primitive.hasUV = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\t\tprimitive.vcount = parseInts( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'p':\n\t\t\t\t\t\t\tprimitive.p = parseInts( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn primitive;\n\n\t\t\t}\n\n\t\t\tfunction groupPrimitives( primitives ) {\n\n\t\t\t\tvar build = {};\n\n\t\t\t\tfor ( var i = 0; i < primitives.length; i ++ ) {\n\n\t\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\t\tif ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];\n\n\t\t\t\t\tbuild[ primitive.type ].push( primitive );\n\n\t\t\t\t}\n\n\t\t\t\treturn build;\n\n\t\t\t}\n\n\t\t\tfunction checkUVCoordinates( primitives ) {\n\n\t\t\t\tvar count = 0;\n\n\t\t\t\tfor ( var i = 0, l = primitives.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\t\tif ( primitive.hasUV === true ) {\n\n\t\t\t\t\t\tcount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( count > 0 && count < primitives.length ) {\n\n\t\t\t\t\tprimitives.uvsNeedsFix = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction buildGeometry( data ) {\n\n\t\t\t\tvar build = {};\n\n\t\t\t\tvar sources = data.sources;\n\t\t\t\tvar vertices = data.vertices;\n\t\t\t\tvar primitives = data.primitives;\n\n\t\t\t\tif ( primitives.length === 0 ) return {};\n\n\t\t\t\t// our goal is to create one buffer geometry for a single type of primitives\n\t\t\t\t// first, we group all primitives by their type\n\n\t\t\t\tvar groupedPrimitives = groupPrimitives( primitives );\n\n\t\t\t\tfor ( var type in groupedPrimitives ) {\n\n\t\t\t\t\tvar primitiveType = groupedPrimitives[ type ];\n\n\t\t\t\t\t// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n\t\t\t\t\tcheckUVCoordinates( primitiveType );\n\n\t\t\t\t\t// third, create a buffer geometry for each type of primitives\n\n\t\t\t\t\tbuild[ type ] = buildGeometryType( primitiveType, sources, vertices );\n\n\t\t\t\t}\n\n\t\t\t\treturn build;\n\n\t\t\t}\n\n\t\t\tfunction buildGeometryType( primitives, sources, vertices ) {\n\n\t\t\t\tvar build = {};\n\n\t\t\t\tvar position = { array: [], stride: 0 };\n\t\t\t\tvar normal = { array: [], stride: 0 };\n\t\t\t\tvar uv = { array: [], stride: 0 };\n\t\t\t\tvar uv2 = { array: [], stride: 0 };\n\t\t\t\tvar color = { array: [], stride: 0 };\n\n\t\t\t\tvar skinIndex = { array: [], stride: 4 };\n\t\t\t\tvar skinWeight = { array: [], stride: 4 };\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\tvar materialKeys = [];\n\n\t\t\t\tvar start = 0;\n\n\t\t\t\tfor ( var p = 0; p < primitives.length; p ++ ) {\n\n\t\t\t\t\tvar primitive = primitives[ p ];\n\t\t\t\t\tvar inputs = primitive.inputs;\n\n\t\t\t\t\t// groups\n\n\t\t\t\t\tvar count = 0;\n\n\t\t\t\t\tswitch ( primitive.type ) {\n\n\t\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\t\tcount = primitive.count * 2;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\t\tcount = primitive.count * 3;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'polylist':\n\n\t\t\t\t\t\t\tfor ( var g = 0; g < primitive.count; g ++ ) {\n\n\t\t\t\t\t\t\t\tvar vc = primitive.vcount[ g ];\n\n\t\t\t\t\t\t\t\tswitch ( vc ) {\n\n\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\tcount += 3; // single triangle\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\t\tcount += 6; // quad, subdivided into two triangles\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tcount += ( vc - 2 ) * 3; // polylist with more than four vertices\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknow primitive type:', primitive.type );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.addGroup( start, count, p );\n\t\t\t\t\tstart += count;\n\n\t\t\t\t\t// material\n\n\t\t\t\t\tif ( primitive.material ) {\n\n\t\t\t\t\t\tmaterialKeys.push( primitive.material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// geometry data\n\n\t\t\t\t\tfor ( var name in inputs ) {\n\n\t\t\t\t\t\tvar input = inputs[ name ];\n\n\t\t\t\t\t\tswitch ( name )\t{\n\n\t\t\t\t\t\t\tcase 'VERTEX':\n\t\t\t\t\t\t\t\tfor ( var key in vertices ) {\n\n\t\t\t\t\t\t\t\t\tvar id = vertices[ key ];\n\n\t\t\t\t\t\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'POSITION':\n\t\t\t\t\t\t\t\t\t\t\tvar prevLength = position.array.length;\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, position.array );\n\t\t\t\t\t\t\t\t\t\t\tposition.stride = sources[ id ].stride;\n\n\t\t\t\t\t\t\t\t\t\t\tif ( sources.skinWeights && sources.skinIndices ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );\n\t\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// see #3803\n\n\t\t\t\t\t\t\t\t\t\t\tif ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar count = ( position.array.length - prevLength ) / position.stride;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// fill missing uv coordinates\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tuv.array.push( 0, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, normal.array );\n\t\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, color.array );\n\t\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv.array );\n\t\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv2.array );\n\t\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );\n\t\t\t\t\t\t\t\tnormal.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, color.array );\n\t\t\t\t\t\t\t\tcolor.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );\n\t\t\t\t\t\t\t\tuv.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv2.array );\n\t\t\t\t\t\t\t\tuv2.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// build geometry\n\n\t\t\t\tif ( position.array.length > 0 ) geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( position.array, position.stride ) );\n\t\t\t\tif ( normal.array.length > 0 ) geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normal.array, normal.stride ) );\n\t\t\t\tif ( color.array.length > 0 ) geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( color.array, color.stride ) );\n\t\t\t\tif ( uv.array.length > 0 ) geometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uv.array, uv.stride ) );\n\t\t\t\tif ( uv2.array.length > 0 ) geometry.setAttribute( 'uv2', new THREE.Float32BufferAttribute( uv2.array, uv2.stride ) );\n\n\t\t\t\tif ( skinIndex.array.length > 0 ) geometry.setAttribute( 'skinIndex', new THREE.Float32BufferAttribute( skinIndex.array, skinIndex.stride ) );\n\t\t\t\tif ( skinWeight.array.length > 0 ) geometry.setAttribute( 'skinWeight', new THREE.Float32BufferAttribute( skinWeight.array, skinWeight.stride ) );\n\n\t\t\t\tbuild.data = geometry;\n\t\t\t\tbuild.type = primitives[ 0 ].type;\n\t\t\t\tbuild.materialKeys = materialKeys;\n\n\t\t\t\treturn build;\n\n\t\t\t}\n\n\t\t\tfunction buildGeometryData( primitive, source, offset, array ) {\n\n\t\t\t\tvar indices = primitive.p;\n\t\t\t\tvar stride = primitive.stride;\n\t\t\t\tvar vcount = primitive.vcount;\n\n\t\t\t\tfunction pushVector( i ) {\n\n\t\t\t\t\tvar index = indices[ i + offset ] * sourceStride;\n\t\t\t\t\tvar length = index + sourceStride;\n\n\t\t\t\t\tfor ( ; index < length; index ++ ) {\n\n\t\t\t\t\t\tarray.push( sourceArray[ index ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar sourceArray = source.array;\n\t\t\t\tvar sourceStride = source.stride;\n\n\t\t\t\tif ( primitive.vcount !== undefined ) {\n\n\t\t\t\t\tvar index = 0;\n\n\t\t\t\t\tfor ( var i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar count = vcount[ i ];\n\n\t\t\t\t\t\tif ( count === 4 ) {\n\n\t\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\t\tvar c = index + stride * 2;\n\t\t\t\t\t\t\tvar d = index + stride * 3;\n\n\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( d );\n\t\t\t\t\t\t\tpushVector( b ); pushVector( c ); pushVector( d );\n\n\t\t\t\t\t\t} else if ( count === 3 ) {\n\n\t\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\t\tvar c = index + stride * 2;\n\n\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t\t} else if ( count > 4 ) {\n\n\t\t\t\t\t\t\tfor ( var k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {\n\n\t\t\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\t\t\tvar b = index + stride * k;\n\t\t\t\t\t\t\t\tvar c = index + stride * ( k + 1 );\n\n\t\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tindex += stride * count;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += stride ) {\n\n\t\t\t\t\t\tpushVector( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getGeometry( id ) {\n\n\t\t\t\treturn getBuild( library.geometries[ id ], buildGeometry );\n\n\t\t\t}\n\n\t\t\t// kinematics\n\n\t\t\tfunction parseKinematicsModel( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\t\tjoints: {},\n\t\t\t\t\tlinks: []\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\t\tparseKinematicsTechniqueCommon( child, data );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction buildKinematicsModel( data ) {\n\n\t\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction getKinematicsModel( id ) {\n\n\t\t\t\treturn getBuild( library.kinematicsModels[ id ], buildKinematicsModel );\n\n\t\t\t}\n\n\t\t\tfunction parseKinematicsTechniqueCommon( xml, data ) {\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'joint':\n\t\t\t\t\t\t\tdata.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'link':\n\t\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseKinematicsJoint( xml ) {\n\n\t\t\t\tvar data;\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\tdata = parseKinematicsJointParameter( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseKinematicsJointParameter( xml, data ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\t\taxis: new THREE.Vector3(),\n\t\t\t\t\tlimits: {\n\t\t\t\t\t\tmin: 0,\n\t\t\t\t\t\tmax: 0\n\t\t\t\t\t},\n\t\t\t\t\ttype: xml.nodeName,\n\t\t\t\t\tstatic: false,\n\t\t\t\t\tzeroPosition: 0,\n\t\t\t\t\tmiddlePosition: 0\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tdata.axis.fromArray( array );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'limits':\n\t\t\t\t\t\t\tvar max = child.getElementsByTagName( 'max' )[ 0 ];\n\t\t\t\t\t\t\tvar min = child.getElementsByTagName( 'min' )[ 0 ];\n\n\t\t\t\t\t\t\tdata.limits.max = parseFloat( max.textContent );\n\t\t\t\t\t\t\tdata.limits.min = parseFloat( min.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// if min is equal to or greater than max, consider the joint static\n\n\t\t\t\tif ( data.limits.min >= data.limits.max ) {\n\n\t\t\t\t\tdata.static = true;\n\n\t\t\t\t}\n\n\t\t\t\t// calculate middle position\n\n\t\t\t\tdata.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseKinematicsLink( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\t\tattachments: [],\n\t\t\t\t\ttransforms: []\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'attachment_full':\n\t\t\t\t\t\t\tdata.attachments.push( parseKinematicsAttachment( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseKinematicsAttachment( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tjoint: xml.getAttribute( 'joint' ).split( '/' ).pop(),\n\t\t\t\t\ttransforms: [],\n\t\t\t\t\tlinks: []\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'link':\n\t\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseKinematicsTransform( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\ttype: xml.nodeName\n\t\t\t\t};\n\n\t\t\t\tvar array = parseFloats( xml.textContent );\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tdata.obj = new THREE.Matrix4();\n\t\t\t\t\t\tdata.obj.fromArray( array ).transpose();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tdata.obj = new THREE.Vector3();\n\t\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.obj = new THREE.Vector3();\n\t\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\t\tdata.angle = THREE.MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\t// physics\n\n\t\t\tfunction parsePhysicsModel( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\t\trigidBodies: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'rigid_body':\n\t\t\t\t\t\t\tdata.rigidBodies[ child.getAttribute( 'name' ) ] = {};\n\t\t\t\t\t\t\tparsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.physicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parsePhysicsRigidBody( xml, data ) {\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\t\tparsePhysicsTechniqueCommon( child, data );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parsePhysicsTechniqueCommon( xml, data ) {\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'inertia':\n\t\t\t\t\t\t\tdata.inertia = parseFloats( child.textContent );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'mass':\n\t\t\t\t\t\t\tdata.mass = parseFloats( child.textContent )[ 0 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// scene\n\n\t\t\tfunction parseKinematicsScene( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tbindJointAxis: []\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'bind_joint_axis':\n\t\t\t\t\t\t\tdata.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction parseKinematicsBindJointAxis( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\ttarget: xml.getAttribute( 'target' ).split( '/' ).pop()\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\t\tvar param = child.getElementsByTagName( 'param' )[ 0 ];\n\t\t\t\t\t\t\tdata.axis = param.textContent;\n\t\t\t\t\t\t\tvar tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];\n\t\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substr( 0, tmpJointIndex.length - 1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction buildKinematicsScene( data ) {\n\n\t\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction getKinematicsScene( id ) {\n\n\t\t\t\treturn getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );\n\n\t\t\t}\n\n\t\t\tfunction setupKinematics() {\n\n\t\t\t\tvar kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];\n\t\t\t\tvar kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];\n\t\t\t\tvar visualSceneId = Object.keys( library.visualScenes )[ 0 ];\n\n\t\t\t\tif ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;\n\n\t\t\t\tvar kinematicsModel = getKinematicsModel( kinematicsModelId );\n\t\t\t\tvar kinematicsScene = getKinematicsScene( kinematicsSceneId );\n\t\t\t\tvar visualScene = getVisualScene( visualSceneId );\n\n\t\t\t\tvar bindJointAxis = kinematicsScene.bindJointAxis;\n\t\t\t\tvar jointMap = {};\n\n\t\t\t\tfor ( var i = 0, l = bindJointAxis.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar axis = bindJointAxis[ i ];\n\n\t\t\t\t\t// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n\t\t\t\t\tvar targetElement = collada.querySelector( '[sid=\"' + axis.target + '\"]' );\n\n\t\t\t\t\tif ( targetElement ) {\n\n\t\t\t\t\t\t// get the parent of the transfrom element\n\n\t\t\t\t\t\tvar parentVisualElement = targetElement.parentElement;\n\n\t\t\t\t\t\t// connect the joint of the kinematics model with the element in the visual scene\n\n\t\t\t\t\t\tconnect( axis.jointIndex, parentVisualElement );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfunction connect( jointIndex, visualElement ) {\n\n\t\t\t\t\tvar visualElementName = visualElement.getAttribute( 'name' );\n\t\t\t\t\tvar joint = kinematicsModel.joints[ jointIndex ];\n\n\t\t\t\t\tvisualScene.traverse( function ( object ) {\n\n\t\t\t\t\t\tif ( object.name === visualElementName ) {\n\n\t\t\t\t\t\t\tjointMap[ jointIndex ] = {\n\t\t\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\t\t\ttransforms: buildTransformList( visualElement ),\n\t\t\t\t\t\t\t\tjoint: joint,\n\t\t\t\t\t\t\t\tposition: joint.zeroPosition\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tvar m0 = new THREE.Matrix4();\n\n\t\t\t\tkinematics = {\n\n\t\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\n\n\t\t\t\t\tgetJointValue: function ( jointIndex ) {\n\n\t\t\t\t\t\tvar jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\t\treturn jointData.position;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t},\n\n\t\t\t\t\tsetJointValue: function ( jointIndex, value ) {\n\n\t\t\t\t\t\tvar jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\t\tvar joint = jointData.joint;\n\n\t\t\t\t\t\t\tif ( value > joint.limits.max || value < joint.limits.min ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );\n\n\t\t\t\t\t\t\t} else if ( joint.static ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar object = jointData.object;\n\t\t\t\t\t\t\t\tvar axis = joint.axis;\n\t\t\t\t\t\t\t\tvar transforms = jointData.transforms;\n\n\t\t\t\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t\t\t\t\t// each update, we have to apply all transforms in the correct order\n\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < transforms.length; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar transform = transforms[ i ];\n\n\t\t\t\t\t\t\t\t\t// if there is a connection of the transform node with a joint, apply the joint value\n\n\t\t\t\t\t\t\t\t\tif ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {\n\n\t\t\t\t\t\t\t\t\t\tswitch ( joint.type ) {\n\n\t\t\t\t\t\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( axis, THREE.MathUtils.degToRad( value ) ) );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tswitch ( transform.type ) {\n\n\t\t\t\t\t\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.scale( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tobject.matrix.copy( matrix );\n\t\t\t\t\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t\t\t\t\tjointMap[ jointIndex ].position = value;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction buildTransformList( node ) {\n\n\t\t\t\tvar transforms = [];\n\n\t\t\t\tvar xml = collada.querySelector( '[id=\"' + node.id + '\"]' );\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tvar matrix = new THREE.Matrix4().fromArray( array ).transpose();\n\t\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\t\tobj: matrix\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tvar vector = new THREE.Vector3().fromArray( array );\n\t\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\t\tobj: vector\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tvar vector = new THREE.Vector3().fromArray( array );\n\t\t\t\t\t\t\tvar angle = THREE.MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\t\tobj: vector,\n\t\t\t\t\t\t\t\tangle: angle\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn transforms;\n\n\t\t\t}\n\n\t\t\t// nodes\n\n\t\t\tfunction prepareNodes( xml ) {\n\n\t\t\t\tvar elements = xml.getElementsByTagName( 'node' );\n\n\t\t\t\t// ensure all node elements have id attributes\n\n\t\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\tvar element = elements[ i ];\n\n\t\t\t\t\tif ( element.hasAttribute( 'id' ) === false ) {\n\n\t\t\t\t\t\telement.setAttribute( 'id', generateId() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\tvar vector = new THREE.Vector3();\n\n\t\t\tfunction parseNode( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\t\ttype: xml.getAttribute( 'type' ),\n\t\t\t\t\tid: xml.getAttribute( 'id' ),\n\t\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\t\tmatrix: new THREE.Matrix4(),\n\t\t\t\t\tnodes: [],\n\t\t\t\t\tinstanceCameras: [],\n\t\t\t\t\tinstanceControllers: [],\n\t\t\t\t\tinstanceLights: [],\n\t\t\t\t\tinstanceGeometries: [],\n\t\t\t\t\tinstanceNodes: [],\n\t\t\t\t\ttransforms: {}\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'node':\n\t\t\t\t\t\t\tdata.nodes.push( child.getAttribute( 'id' ) );\n\t\t\t\t\t\t\tparseNode( child );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'instance_camera':\n\t\t\t\t\t\t\tdata.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'instance_controller':\n\t\t\t\t\t\t\tdata.instanceControllers.push( parseNodeInstance( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'instance_light':\n\t\t\t\t\t\t\tdata.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'instance_geometry':\n\t\t\t\t\t\t\tdata.instanceGeometries.push( parseNodeInstance( child ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'instance_node':\n\t\t\t\t\t\t\tdata.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tdata.matrix.multiply( matrix.fromArray( array ).transpose() );\n\t\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tvector.fromArray( array );\n\t\t\t\t\t\t\tdata.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );\n\t\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tvar angle = THREE.MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\t\tdata.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );\n\t\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\tvar array = parseFloats( child.textContent );\n\t\t\t\t\t\t\tdata.matrix.scale( vector.fromArray( array ) );\n\t\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasNode( data.id ) ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlibrary.nodes[ data.id ] = data;\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction parseNodeInstance( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tid: parseId( xml.getAttribute( 'url' ) ),\n\t\t\t\t\tmaterials: {},\n\t\t\t\t\tskeletons: []\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\tvar child = xml.childNodes[ i ];\n\n\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\tcase 'bind_material':\n\t\t\t\t\t\t\tvar instances = child.getElementsByTagName( 'instance_material' );\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < instances.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar instance = instances[ j ];\n\t\t\t\t\t\t\t\tvar symbol = instance.getAttribute( 'symbol' );\n\t\t\t\t\t\t\t\tvar target = instance.getAttribute( 'target' );\n\n\t\t\t\t\t\t\t\tdata.materials[ symbol ] = parseId( target );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'skeleton':\n\t\t\t\t\t\t\tdata.skeletons.push( parseId( child.textContent ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\tfunction buildSkeleton( skeletons, joints ) {\n\n\t\t\t\tvar boneData = [];\n\t\t\t\tvar sortedBoneData = [];\n\n\t\t\t\tvar i, j, data;\n\n\t\t\t\t// a skeleton can have multiple root bones. collada expresses this\n\t\t\t\t// situtation with multiple \"skeleton\" tags per controller instance\n\n\t\t\t\tfor ( i = 0; i < skeletons.length; i ++ ) {\n\n\t\t\t\t\tvar skeleton = skeletons[ i ];\n\n\t\t\t\t\tvar root;\n\n\t\t\t\t\tif ( hasNode( skeleton ) ) {\n\n\t\t\t\t\t\troot = getNode( skeleton );\n\t\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t\t} else if ( hasVisualScene( skeleton ) ) {\n\n\t\t\t\t\t\t// handle case where the skeleton refers to the visual scene (#13335)\n\n\t\t\t\t\t\tvar visualScene = library.visualScenes[ skeleton ];\n\t\t\t\t\t\tvar children = visualScene.children;\n\n\t\t\t\t\t\tfor ( var j = 0; j < children.length; j ++ ) {\n\n\t\t\t\t\t\t\tvar child = children[ j ];\n\n\t\t\t\t\t\t\tif ( child.type === 'JOINT' ) {\n\n\t\t\t\t\t\t\t\tvar root = getNode( child.id );\n\t\t\t\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// sort bone data (the order is defined in the corresponding controller)\n\n\t\t\t\tfor ( i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\t\tfor ( j = 0; j < boneData.length; j ++ ) {\n\n\t\t\t\t\t\tdata = boneData[ j ];\n\n\t\t\t\t\t\tif ( data.bone.name === joints[ i ].name ) {\n\n\t\t\t\t\t\t\tsortedBoneData[ i ] = data;\n\t\t\t\t\t\t\tdata.processed = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// add unprocessed bone data at the end of the list\n\n\t\t\t\tfor ( i = 0; i < boneData.length; i ++ ) {\n\n\t\t\t\t\tdata = boneData[ i ];\n\n\t\t\t\t\tif ( data.processed === false ) {\n\n\t\t\t\t\t\tsortedBoneData.push( data );\n\t\t\t\t\t\tdata.processed = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// setup arrays for skeleton creation\n\n\t\t\t\tvar bones = [];\n\t\t\t\tvar boneInverses = [];\n\n\t\t\t\tfor ( i = 0; i < sortedBoneData.length; i ++ ) {\n\n\t\t\t\t\tdata = sortedBoneData[ i ];\n\n\t\t\t\t\tbones.push( data.bone );\n\t\t\t\t\tboneInverses.push( data.boneInverse );\n\n\t\t\t\t}\n\n\t\t\t\treturn new THREE.Skeleton( bones, boneInverses );\n\n\t\t\t}\n\n\t\t\tfunction buildBoneHierarchy( root, joints, boneData ) {\n\n\t\t\t\t// setup bone data from visual scene\n\n\t\t\t\troot.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.isBone === true ) {\n\n\t\t\t\t\t\tvar boneInverse;\n\n\t\t\t\t\t\t// retrieve the boneInverse from the controller data\n\n\t\t\t\t\t\tfor ( var i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\t\t\t\tvar joint = joints[ i ];\n\n\t\t\t\t\t\t\tif ( joint.name === object.name ) {\n\n\t\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( boneInverse === undefined ) {\n\n\t\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\n\t\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\n\t\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\n\t\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n\t\t\t\t\t\t\t// ensure a correct animation of the model.\n\n\t\t\t\t\t\t\tboneInverse = new THREE.Matrix4();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tboneData.push( { bone: object, boneInverse: boneInverse, processed: false } );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfunction buildNode( data ) {\n\n\t\t\t\tvar objects = [];\n\n\t\t\t\tvar matrix = data.matrix;\n\t\t\t\tvar nodes = data.nodes;\n\t\t\t\tvar type = data.type;\n\t\t\t\tvar instanceCameras = data.instanceCameras;\n\t\t\t\tvar instanceControllers = data.instanceControllers;\n\t\t\t\tvar instanceLights = data.instanceLights;\n\t\t\t\tvar instanceGeometries = data.instanceGeometries;\n\t\t\t\tvar instanceNodes = data.instanceNodes;\n\n\t\t\t\t// nodes\n\n\t\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tobjects.push( getNode( nodes[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\t// instance cameras\n\n\t\t\t\tfor ( var i = 0, l = instanceCameras.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar instanceCamera = getCamera( instanceCameras[ i ] );\n\n\t\t\t\t\tif ( instanceCamera !== null ) {\n\n\t\t\t\t\t\tobjects.push( instanceCamera.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// instance controllers\n\n\t\t\t\tfor ( var i = 0, l = instanceControllers.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar instance = instanceControllers[ i ];\n\t\t\t\t\tvar controller = getController( instance.id );\n\t\t\t\t\tvar geometries = getGeometry( controller.id );\n\t\t\t\t\tvar newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\t\tvar skeletons = instance.skeletons;\n\t\t\t\t\tvar joints = controller.skin.joints;\n\n\t\t\t\t\tvar skeleton = buildSkeleton( skeletons, joints );\n\n\t\t\t\t\tfor ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar object = newObjects[ j ];\n\n\t\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\t\tobject.bind( skeleton, controller.skin.bindMatrix );\n\t\t\t\t\t\t\tobject.normalizeSkinWeights();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// instance lights\n\n\t\t\t\tfor ( var i = 0, l = instanceLights.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar instanceLight = getLight( instanceLights[ i ] );\n\n\t\t\t\t\tif ( instanceLight !== null ) {\n\n\t\t\t\t\t\tobjects.push( instanceLight.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// instance geometries\n\n\t\t\t\tfor ( var i = 0, l = instanceGeometries.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar instance = instanceGeometries[ i ];\n\n\t\t\t\t\t// a single geometry instance in collada can lead to multiple object3Ds.\n\t\t\t\t\t// this is the case when primitives are combined like triangles and lines\n\n\t\t\t\t\tvar geometries = getGeometry( instance.id );\n\t\t\t\t\tvar newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\t\tfor ( var j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tobjects.push( newObjects[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// instance nodes\n\n\t\t\t\tfor ( var i = 0, l = instanceNodes.length; i < l; i ++ ) {\n\n\t\t\t\t\tobjects.push( getNode( instanceNodes[ i ] ).clone() );\n\n\t\t\t\t}\n\n\t\t\t\tvar object;\n\n\t\t\t\tif ( nodes.length === 0 && objects.length === 1 ) {\n\n\t\t\t\t\tobject = objects[ 0 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject = ( type === 'JOINT' ) ? new THREE.Bone() : new THREE.Group();\n\n\t\t\t\t\tfor ( var i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\t\tobject.add( objects[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.name === '' ) {\n\n\t\t\t\t\tobject.name = ( type === 'JOINT' ) ? data.sid : data.name;\n\n\t\t\t\t}\n\n\t\t\t\tobject.matrix.copy( matrix );\n\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t\tvar fallbackMaterial = new THREE.MeshBasicMaterial( { color: 0xff00ff } );\n\n\t\t\tfunction resolveMaterialBinding( keys, instanceMaterials ) {\n\n\t\t\t\tvar materials = [];\n\n\t\t\t\tfor ( var i = 0, l = keys.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar id = instanceMaterials[ keys[ i ] ];\n\n\t\t\t\t\tif ( id === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );\n\t\t\t\t\t\tmaterials.push( fallbackMaterial );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( getMaterial( id ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn materials;\n\n\t\t\t}\n\n\t\t\tfunction buildObjects( geometries, instanceMaterials ) {\n\n\t\t\t\tvar objects = [];\n\n\t\t\t\tfor ( var type in geometries ) {\n\n\t\t\t\t\tvar geometry = geometries[ type ];\n\n\t\t\t\t\tvar materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );\n\n\t\t\t\t\t// handle case if no materials are defined\n\n\t\t\t\t\tif ( materials.length === 0 ) {\n\n\t\t\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\n\n\t\t\t\t\t\t\tmaterials.push( new THREE.LineBasicMaterial() );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmaterials.push( new THREE.MeshPhongMaterial() );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// regard skinning\n\n\t\t\t\t\tvar skinning = ( geometry.data.attributes.skinIndex !== undefined );\n\n\t\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tmaterials[ i ].skinning = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// choose between a single or multi materials (material array)\n\n\t\t\t\t\tvar material = ( materials.length === 1 ) ? materials[ 0 ] : materials;\n\n\t\t\t\t\t// now create a specific 3D object\n\n\t\t\t\t\tvar object;\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\t\tobject = new THREE.LineSegments( geometry.data, material );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\t\tobject = new THREE.Line( geometry.data, material );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry.data, material );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry.data, material );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t}\n\n\t\t\t\treturn objects;\n\n\t\t\t}\n\n\t\t\tfunction hasNode( id ) {\n\n\t\t\t\treturn library.nodes[ id ] !== undefined;\n\n\t\t\t}\n\n\t\t\tfunction getNode( id ) {\n\n\t\t\t\treturn getBuild( library.nodes[ id ], buildNode );\n\n\t\t\t}\n\n\t\t\t// visual scenes\n\n\t\t\tfunction parseVisualScene( xml ) {\n\n\t\t\t\tvar data = {\n\t\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\t\tchildren: []\n\t\t\t\t};\n\n\t\t\t\tprepareNodes( xml );\n\n\t\t\t\tvar elements = getElementsByTagName( xml, 'node' );\n\n\t\t\t\tfor ( var i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\tdata.children.push( parseNode( elements[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tlibrary.visualScenes[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t\t}\n\n\t\t\tfunction buildVisualScene( data ) {\n\n\t\t\t\tvar group = new THREE.Group();\n\t\t\t\tgroup.name = data.name;\n\n\t\t\t\tvar children = data.children;\n\n\t\t\t\tfor ( var i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tvar child = children[ i ];\n\n\t\t\t\t\tgroup.add( getNode( child.id ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn group;\n\n\t\t\t}\n\n\t\t\tfunction hasVisualScene( id ) {\n\n\t\t\t\treturn library.visualScenes[ id ] !== undefined;\n\n\t\t\t}\n\n\t\t\tfunction getVisualScene( id ) {\n\n\t\t\t\treturn getBuild( library.visualScenes[ id ], buildVisualScene );\n\n\t\t\t}\n\n\t\t\t// scenes\n\n\t\t\tfunction parseScene( xml ) {\n\n\t\t\t\tvar instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];\n\t\t\t\treturn getVisualScene( parseId( instance.getAttribute( 'url' ) ) );\n\n\t\t\t}\n\n\t\t\tfunction setupAnimations() {\n\n\t\t\t\tvar clips = library.clips;\n\n\t\t\t\tif ( isEmpty( clips ) === true ) {\n\n\t\t\t\t\tif ( isEmpty( library.animations ) === false ) {\n\n\t\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\n\n\t\t\t\t\t\tvar tracks = [];\n\n\t\t\t\t\t\tfor ( var id in library.animations ) {\n\n\t\t\t\t\t\t\tvar animationTracks = getAnimation( id );\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = animationTracks.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\ttracks.push( animationTracks[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tanimations.push( new THREE.AnimationClip( 'default', - 1, tracks ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var id in clips ) {\n\n\t\t\t\t\t\tanimations.push( getAnimationClip( id ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// convert the parser error element into text with each child elements text\n\t\t\t// separated by new lines.\n\n\t\t\tfunction parserErrorToText( parserError ) {\n\n\t\t\t\tvar result = '';\n\t\t\t\tvar stack = [ parserError ];\n\n\t\t\t\twhile ( stack.length ) {\n\n\t\t\t\t\tvar node = stack.shift();\n\n\t\t\t\t\tif ( node.nodeType === Node.TEXT_NODE ) {\n\n\t\t\t\t\t\tresult += node.textContent;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tresult += '\\n';\n\t\t\t\t\t\tstack.push.apply( stack, node.childNodes );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn result.trim();\n\n\t\t\t}\n\n\t\t\tif ( text.length === 0 ) {\n\n\t\t\t\treturn { scene: new THREE.Scene() };\n\n\t\t\t}\n\n\t\t\tvar xml = new DOMParser().parseFromString( text, 'application/xml' );\n\n\t\t\tvar collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];\n\n\t\t\tvar parserError = xml.getElementsByTagName( 'parsererror' )[ 0 ];\n\t\t\tif ( parserError !== undefined ) {\n\n\t\t\t\t// Chrome will return parser error with a div in it\n\n\t\t\t\tvar errorElement = getElementsByTagName( parserError, 'div' )[ 0 ];\n\t\t\t\tvar errorText;\n\n\t\t\t\tif ( errorElement ) {\n\n\t\t\t\t\terrorText = errorElement.textContent;\n\n\t\t\t\t} else {\n\n\t\t\t\t\terrorText = parserErrorToText( parserError );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.error( 'THREE.ColladaLoader: Failed to parse collada file.\\n', errorText );\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// metadata\n\n\t\t\tvar version = collada.getAttribute( 'version' );\n\t\t\tconsole.log( 'THREE.ColladaLoader: File version', version );\n\n\t\t\tvar asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );\n\t\t\tvar textureLoader = new THREE.TextureLoader( this.manager );\n\t\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar tgaLoader;\n\n\t\t\tif ( THREE.TGALoader ) {\n\n\t\t\t\ttgaLoader = new THREE.TGALoader( this.manager );\n\t\t\t\ttgaLoader.setPath( this.resourcePath || path );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar animations = [];\n\t\t\tvar kinematics = {};\n\t\t\tvar count = 0;\n\n\t\t\t//\n\n\t\t\tvar library = {\n\t\t\t\tanimations: {},\n\t\t\t\tclips: {},\n\t\t\t\tcontrollers: {},\n\t\t\t\timages: {},\n\t\t\t\teffects: {},\n\t\t\t\tmaterials: {},\n\t\t\t\tcameras: {},\n\t\t\t\tlights: {},\n\t\t\t\tgeometries: {},\n\t\t\t\tnodes: {},\n\t\t\t\tvisualScenes: {},\n\t\t\t\tkinematicsModels: {},\n\t\t\t\tphysicsModels: {},\n\t\t\t\tkinematicsScenes: {}\n\t\t\t};\n\n\t\t\tparseLibrary( collada, 'library_animations', 'animation', parseAnimation );\n\t\t\tparseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );\n\t\t\tparseLibrary( collada, 'library_controllers', 'controller', parseController );\n\t\t\tparseLibrary( collada, 'library_images', 'image', parseImage );\n\t\t\tparseLibrary( collada, 'library_effects', 'effect', parseEffect );\n\t\t\tparseLibrary( collada, 'library_materials', 'material', parseMaterial );\n\t\t\tparseLibrary( collada, 'library_cameras', 'camera', parseCamera );\n\t\t\tparseLibrary( collada, 'library_lights', 'light', parseLight );\n\t\t\tparseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );\n\t\t\tparseLibrary( collada, 'library_nodes', 'node', parseNode );\n\t\t\tparseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );\n\t\t\tparseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );\n\t\t\tparseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );\n\t\t\tparseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );\n\n\t\t\tbuildLibrary( library.animations, buildAnimation );\n\t\t\tbuildLibrary( library.clips, buildAnimationClip );\n\t\t\tbuildLibrary( library.controllers, buildController );\n\t\t\tbuildLibrary( library.images, buildImage );\n\t\t\tbuildLibrary( library.effects, buildEffect );\n\t\t\tbuildLibrary( library.materials, buildMaterial );\n\t\t\tbuildLibrary( library.cameras, buildCamera );\n\t\t\tbuildLibrary( library.lights, buildLight );\n\t\t\tbuildLibrary( library.geometries, buildGeometry );\n\t\t\tbuildLibrary( library.visualScenes, buildVisualScene );\n\n\t\t\tsetupAnimations();\n\t\t\tsetupKinematics();\n\n\t\t\tvar scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );\n\n\t\t\tif ( asset.upAxis === 'Z_UP' ) {\n\n\t\t\t\tscene.quaternion.setFromEuler( new THREE.Euler( - Math.PI / 2, 0, 0 ) );\n\n\t\t\t}\n\n\t\t\tscene.scale.multiplyScalar( asset.unit );\n\n\t\t\treturn {\n\t\t\t\tanimations: animations,\n\t\t\t\tkinematics: kinematics,\n\t\t\t\tlibrary: library,\n\t\t\t\tscene: scene\n\t\t\t};\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.ColladaLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/DRACOLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Don McCurdy / https://www.donmccurdy.com\n\t */\n\n\tTHREE.DRACOLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.decoderPath = '';\n\t\tthis.decoderConfig = {};\n\t\tthis.decoderBinary = null;\n\t\tthis.decoderPending = null;\n\n\t\tthis.workerLimit = 4;\n\t\tthis.workerPool = [];\n\t\tthis.workerNextTaskID = 1;\n\t\tthis.workerSourceURL = '';\n\n\t\tthis.defaultAttributeIDs = {\n\t\t\tposition: 'POSITION',\n\t\t\tnormal: 'NORMAL',\n\t\t\tcolor: 'COLOR',\n\t\t\tuv: 'TEX_COORD'\n\t\t};\n\t\tthis.defaultAttributeTypes = {\n\t\t\tposition: 'Float32Array',\n\t\t\tnormal: 'Float32Array',\n\t\t\tcolor: 'Float32Array',\n\t\t\tuv: 'Float32Array'\n\t\t};\n\n\t};\n\n\tTHREE.DRACOLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.DRACOLoader,\n\n\t\tsetDecoderPath: function ( path ) {\n\n\t\t\tthis.decoderPath = path;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetDecoderConfig: function ( config ) {\n\n\t\t\tthis.decoderConfig = config;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetWorkerLimit: function ( workerLimit ) {\n\n\t\t\tthis.workerLimit = workerLimit;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t/** @deprecated */\n\t\tsetVerbosity: function () {\n\n\t\t\tconsole.warn( 'THREE.DRACOLoader: The .setVerbosity() method has been removed.' );\n\n\t\t},\n\n\t\t/** @deprecated */\n\t\tsetDrawMode: function () {\n\n\t\t\tconsole.warn( 'THREE.DRACOLoader: The .setDrawMode() method has been removed.' );\n\n\t\t},\n\n\t\t/** @deprecated */\n\t\tsetSkipDequantization: function () {\n\n\t\t\tconsole.warn( 'THREE.DRACOLoader: The .setSkipDequantization() method has been removed.' );\n\n\t\t},\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tif ( this.crossOrigin === 'use-credentials' ) {\n\n\t\t\t\tloader.setWithCredentials( true );\n\n\t\t\t}\n\n\t\t\tloader.load( url, ( buffer ) => {\n\n\t\t\t\tvar taskConfig = {\n\t\t\t\t\tattributeIDs: this.defaultAttributeIDs,\n\t\t\t\t\tattributeTypes: this.defaultAttributeTypes,\n\t\t\t\t\tuseUniqueIDs: false\n\t\t\t\t};\n\n\t\t\t\tthis.decodeGeometry( buffer, taskConfig )\n\t\t\t\t\t.then( onLoad )\n\t\t\t\t\t.catch( onError );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\t/** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n\t\tdecodeDracoFile: function ( buffer, callback, attributeIDs, attributeTypes ) {\n\n\t\t\tvar taskConfig = {\n\t\t\t\tattributeIDs: attributeIDs || this.defaultAttributeIDs,\n\t\t\t\tattributeTypes: attributeTypes || this.defaultAttributeTypes,\n\t\t\t\tuseUniqueIDs: !! attributeIDs\n\t\t\t};\n\n\t\t\tthis.decodeGeometry( buffer, taskConfig ).then( callback );\n\n\t\t},\n\n\t\tdecodeGeometry: function ( buffer, taskConfig ) {\n\n\t\t\t// TODO: For backward-compatibility, support 'attributeTypes' objects containing\n\t\t\t// references (rather than names) to typed array constructors. These must be\n\t\t\t// serialized before sending them to the worker.\n\t\t\tfor ( var attribute in taskConfig.attributeTypes ) {\n\n\t\t\t\tvar type = taskConfig.attributeTypes[ attribute ];\n\n\t\t\t\tif ( type.BYTES_PER_ELEMENT !== undefined ) {\n\n\t\t\t\t\ttaskConfig.attributeTypes[ attribute ] = type.name;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar taskKey = JSON.stringify( taskConfig );\n\n\t\t\t// Check for an existing task using this buffer. A transferred buffer cannot be transferred\n\t\t\t// again from this thread.\n\t\t\tif ( THREE.DRACOLoader.taskCache.has( buffer ) ) {\n\n\t\t\t\tvar cachedTask = THREE.DRACOLoader.taskCache.get( buffer );\n\n\t\t\t\tif ( cachedTask.key === taskKey ) {\n\n\t\t\t\t\treturn cachedTask.promise;\n\n\t\t\t\t} else if ( buffer.byteLength === 0 ) {\n\n\t\t\t\t\t// Technically, it would be possible to wait for the previous task to complete,\n\t\t\t\t\t// transfer the buffer back, and decode again with the second configuration. That\n\t\t\t\t\t// is complex, and I don't know of any reason to decode a Draco buffer twice in\n\t\t\t\t\t// different ways, so this is left unimplemented.\n\t\t\t\t\tthrow new Error(\n\n\t\t\t\t\t\t'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n\t\t\t\t\t\t'settings. Buffer has already been transferred.'\n\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar worker;\n\t\t\tvar taskID = this.workerNextTaskID ++;\n\t\t\tvar taskCost = buffer.byteLength;\n\n\t\t\t// Obtain a worker and assign a task, and construct a geometry instance\n\t\t\t// when the task completes.\n\t\t\tvar geometryPending = this._getWorker( taskID, taskCost )\n\t\t\t\t.then( ( _worker ) => {\n\n\t\t\t\t\tworker = _worker;\n\n\t\t\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\t\t\tworker._callbacks[ taskID ] = { resolve, reject };\n\n\t\t\t\t\t\tworker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );\n\n\t\t\t\t\t\t// this.debug();\n\n\t\t\t\t\t} );\n\n\t\t\t\t} )\n\t\t\t\t.then( ( message ) => this._createGeometry( message.geometry ) );\n\n\t\t\t// Remove task from the task list.\n\t\t\tgeometryPending\n\t\t\t\t.finally( () => {\n\n\t\t\t\t\tif ( worker && taskID ) {\n\n\t\t\t\t\t\tthis._releaseTask( worker, taskID );\n\n\t\t\t\t\t\t// this.debug();\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t// Cache the task result.\n\t\t\tTHREE.DRACOLoader.taskCache.set( buffer, {\n\n\t\t\t\tkey: taskKey,\n\t\t\t\tpromise: geometryPending\n\n\t\t\t} );\n\n\t\t\treturn geometryPending;\n\n\t\t},\n\n\t\t_createGeometry: function ( geometryData ) {\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tif ( geometryData.index ) {\n\n\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( geometryData.index.array, 1 ) );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < geometryData.attributes.length; i ++ ) {\n\n\t\t\t\tvar attribute = geometryData.attributes[ i ];\n\t\t\t\tvar name = attribute.name;\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tgeometry.setAttribute( name, new THREE.BufferAttribute( array, itemSize ) );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t},\n\n\t\t_loadLibrary: function ( url, responseType ) {\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setPath( this.decoderPath );\n\t\t\tloader.setResponseType( responseType );\n\n\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\tloader.load( url, resolve, undefined, reject );\n\n\t\t\t} );\n\n\t\t},\n\n\t\tpreload: function () {\n\n\t\t\tthis._initDecoder();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t_initDecoder: function () {\n\n\t\t\tif ( this.decoderPending ) return this.decoderPending;\n\n\t\t\tvar useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n\t\t\tvar librariesPending = [];\n\n\t\t\tif ( useJS ) {\n\n\t\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );\n\n\t\t\t} else {\n\n\t\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );\n\t\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );\n\n\t\t\t}\n\n\t\t\tthis.decoderPending = Promise.all( librariesPending )\n\t\t\t\t.then( ( libraries ) => {\n\n\t\t\t\t\tvar jsContent = libraries[ 0 ];\n\n\t\t\t\t\tif ( ! useJS ) {\n\n\t\t\t\t\t\tthis.decoderConfig.wasmBinary = libraries[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar fn = THREE.DRACOLoader.DRACOWorker.toString();\n\n\t\t\t\t\tvar body = [\n\t\t\t\t\t\t'/* draco decoder */',\n\t\t\t\t\t\tjsContent,\n\t\t\t\t\t\t'',\n\t\t\t\t\t\t'/* worker */',\n\t\t\t\t\t\tfn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )\n\t\t\t\t\t].join( '\\n' );\n\n\t\t\t\t\tthis.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );\n\n\t\t\t\t} );\n\n\t\t\treturn this.decoderPending;\n\n\t\t},\n\n\t\t_getWorker: function ( taskID, taskCost ) {\n\n\t\t\treturn this._initDecoder().then( () => {\n\n\t\t\t\tif ( this.workerPool.length < this.workerLimit ) {\n\n\t\t\t\t\tvar worker = new Worker( this.workerSourceURL );\n\n\t\t\t\t\tworker._callbacks = {};\n\t\t\t\t\tworker._taskCosts = {};\n\t\t\t\t\tworker._taskLoad = 0;\n\n\t\t\t\t\tworker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );\n\n\t\t\t\t\tworker.onmessage = function ( e ) {\n\n\t\t\t\t\t\tvar message = e.data;\n\n\t\t\t\t\t\tswitch ( message.type ) {\n\n\t\t\t\t\t\t\tcase 'decode':\n\t\t\t\t\t\t\t\tworker._callbacks[ message.id ].resolve( message );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'error':\n\t\t\t\t\t\t\t\tworker._callbacks[ message.id ].reject( message );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\n\t\t\t\t\tthis.workerPool.push( worker );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.workerPool.sort( function ( a, b ) {\n\n\t\t\t\t\t\treturn a._taskLoad > b._taskLoad ? - 1 : 1;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tvar worker = this.workerPool[ this.workerPool.length - 1 ];\n\t\t\t\tworker._taskCosts[ taskID ] = taskCost;\n\t\t\t\tworker._taskLoad += taskCost;\n\t\t\t\treturn worker;\n\n\t\t\t} );\n\n\t\t},\n\n\t\t_releaseTask: function ( worker, taskID ) {\n\n\t\t\tworker._taskLoad -= worker._taskCosts[ taskID ];\n\t\t\tdelete worker._callbacks[ taskID ];\n\t\t\tdelete worker._taskCosts[ taskID ];\n\n\t\t},\n\n\t\tdebug: function () {\n\n\t\t\tconsole.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tfor ( var i = 0; i < this.workerPool.length; ++ i ) {\n\n\t\t\t\tthis.workerPool[ i ].terminate();\n\n\t\t\t}\n\n\t\t\tthis.workerPool.length = 0;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t/* WEB WORKER */\n\n\tTHREE.DRACOLoader.DRACOWorker = function () {\n\n\t\tvar decoderConfig;\n\t\tvar decoderPending;\n\n\t\tonmessage = function ( e ) {\n\n\t\t\tvar message = e.data;\n\n\t\t\tswitch ( message.type ) {\n\n\t\t\t\tcase 'init':\n\t\t\t\t\tdecoderConfig = message.decoderConfig;\n\t\t\t\t\tdecoderPending = new Promise( function ( resolve/*, reject*/ ) {\n\n\t\t\t\t\t\tdecoderConfig.onModuleLoaded = function ( draco ) {\n\n\t\t\t\t\t\t\t// Module is Promise-like. Wrap before resolving to avoid loop.\n\t\t\t\t\t\t\tresolve( { draco: draco } );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tDracoDecoderModule( decoderConfig );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'decode':\n\t\t\t\t\tvar buffer = message.buffer;\n\t\t\t\t\tvar taskConfig = message.taskConfig;\n\t\t\t\t\tdecoderPending.then( ( module ) => {\n\n\t\t\t\t\t\tvar draco = module.draco;\n\t\t\t\t\t\tvar decoder = new draco.Decoder();\n\t\t\t\t\t\tvar decoderBuffer = new draco.DecoderBuffer();\n\t\t\t\t\t\tdecoderBuffer.Init( new Int8Array( buffer ), buffer.byteLength );\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\tvar geometry = decodeGeometry( draco, decoder, decoderBuffer, taskConfig );\n\n\t\t\t\t\t\t\tvar buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );\n\n\t\t\t\t\t\t\tif ( geometry.index ) buffers.push( geometry.index.array.buffer );\n\n\t\t\t\t\t\t\tself.postMessage( { type: 'decode', id: message.id, geometry }, buffers );\n\n\t\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\t\t\tself.postMessage( { type: 'error', id: message.id, error: error.message } );\n\n\t\t\t\t\t\t} finally {\n\n\t\t\t\t\t\t\tdraco.destroy( decoderBuffer );\n\t\t\t\t\t\t\tdraco.destroy( decoder );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction decodeGeometry( draco, decoder, decoderBuffer, taskConfig ) {\n\n\t\t\tvar attributeIDs = taskConfig.attributeIDs;\n\t\t\tvar attributeTypes = taskConfig.attributeTypes;\n\n\t\t\tvar dracoGeometry;\n\t\t\tvar decodingStatus;\n\n\t\t\tvar geometryType = decoder.GetEncodedGeometryType( decoderBuffer );\n\n\t\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\t\tdracoGeometry = new draco.Mesh();\n\t\t\t\tdecodingStatus = decoder.DecodeBufferToMesh( decoderBuffer, dracoGeometry );\n\n\t\t\t} else if ( geometryType === draco.POINT_CLOUD ) {\n\n\t\t\t\tdracoGeometry = new draco.PointCloud();\n\t\t\t\tdecodingStatus = decoder.DecodeBufferToPointCloud( decoderBuffer, dracoGeometry );\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );\n\n\t\t\t}\n\n\t\t\tif ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );\n\n\t\t\t}\n\n\t\t\tvar geometry = { index: null, attributes: [] };\n\n\t\t\t// Gather all vertex attributes.\n\t\t\tfor ( var attributeName in attributeIDs ) {\n\n\t\t\t\tvar attributeType = self[ attributeTypes[ attributeName ] ];\n\n\t\t\t\tvar attribute;\n\t\t\t\tvar attributeID;\n\n\t\t\t\t// A Draco file may be created with default vertex attributes, whose attribute IDs\n\t\t\t\t// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n\t\t\t\t// a Draco file may contain a custom set of attributes, identified by known unique\n\t\t\t\t// IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\t\t\t\tif ( taskConfig.useUniqueIDs ) {\n\n\t\t\t\t\tattributeID = attributeIDs[ attributeName ];\n\t\t\t\t\tattribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tattributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );\n\n\t\t\t\t\tif ( attributeID === - 1 ) continue;\n\n\t\t\t\t\tattribute = decoder.GetAttribute( dracoGeometry, attributeID );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.attributes.push( decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) );\n\n\t\t\t}\n\n\t\t\t// Add index.\n\t\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\t\t// Generate mesh faces.\n\t\t\t\tvar numFaces = dracoGeometry.num_faces();\n\t\t\t\tvar numIndices = numFaces * 3;\n\t\t\t\tvar index = new Uint32Array( numIndices );\n\t\t\t\tvar indexArray = new draco.DracoInt32Array();\n\n\t\t\t\tfor ( var i = 0; i < numFaces; ++ i ) {\n\n\t\t\t\t\tdecoder.GetFaceFromMesh( dracoGeometry, i, indexArray );\n\n\t\t\t\t\tfor ( var j = 0; j < 3; ++ j ) {\n\n\t\t\t\t\t\tindex[ i * 3 + j ] = indexArray.GetValue( j );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.index = { array: index, itemSize: 1 };\n\n\t\t\t\tdraco.destroy( indexArray );\n\n\t\t\t}\n\n\t\t\tdraco.destroy( dracoGeometry );\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {\n\n\t\t\tvar numComponents = attribute.num_components();\n\t\t\tvar numPoints = dracoGeometry.num_points();\n\t\t\tvar numValues = numPoints * numComponents;\n\t\t\tvar dracoArray;\n\n\t\t\tvar array;\n\n\t\t\tswitch ( attributeType ) {\n\n\t\t\t\tcase Float32Array:\n\t\t\t\t\tdracoArray = new draco.DracoFloat32Array();\n\t\t\t\t\tdecoder.GetAttributeFloatForAllPoints( dracoGeometry, attribute, dracoArray );\n\t\t\t\t\tarray = new Float32Array( numValues );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int8Array:\n\t\t\t\t\tdracoArray = new draco.DracoInt8Array();\n\t\t\t\t\tdecoder.GetAttributeInt8ForAllPoints( dracoGeometry, attribute, dracoArray );\n\t\t\t\t\tarray = new Int8Array( numValues );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int16Array:\n\t\t\t\t\tdracoArray = new draco.DracoInt16Array();\n\t\t\t\t\tdecoder.GetAttributeInt16ForAllPoints( dracoGeometry, attribute, dracoArray );\n\t\t\t\t\tarray = new Int16Array( numValues );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int32Array:\n\t\t\t\t\tdracoArray = new draco.DracoInt32Array();\n\t\t\t\t\tdecoder.GetAttributeInt32ForAllPoints( dracoGeometry, attribute, dracoArray );\n\t\t\t\t\tarray = new Int32Array( numValues );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint8Array:\n\t\t\t\t\tdracoArray = new draco.DracoUInt8Array();\n\t\t\t\t\tdecoder.GetAttributeUInt8ForAllPoints( dracoGeometry, attribute, dracoArray );\n\t\t\t\t\tarray = new Uint8Array( numValues );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint16Array:\n\t\t\t\t\tdracoArray = new draco.DracoUInt16Array();\n\t\t\t\t\tdecoder.GetAttributeUInt16ForAllPoints( dracoGeometry, attribute, dracoArray );\n\t\t\t\t\tarray = new Uint16Array( numValues );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint32Array:\n\t\t\t\t\tdracoArray = new draco.DracoUInt32Array();\n\t\t\t\t\tdecoder.GetAttributeUInt32ForAllPoints( dracoGeometry, attribute, dracoArray );\n\t\t\t\t\tarray = new Uint32Array( numValues );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'THREE.DRACOLoader: Unexpected attribute type.' );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < numValues; i ++ ) {\n\n\t\t\t\tarray[ i ] = dracoArray.GetValue( i );\n\n\t\t\t}\n\n\t\t\tdraco.destroy( dracoArray );\n\n\t\t\treturn {\n\t\t\t\tname: attributeName,\n\t\t\t\tarray: array,\n\t\t\t\titemSize: numComponents\n\t\t\t};\n\n\t\t}\n\n\t};\n\n\tTHREE.DRACOLoader.taskCache = new WeakMap();\n\n\t/** Deprecated static methods */\n\n\t/** @deprecated */\n\tTHREE.DRACOLoader.setDecoderPath = function () {\n\n\t\tconsole.warn( 'THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.' );\n\n\t};\n\n\t/** @deprecated */\n\tTHREE.DRACOLoader.setDecoderConfig = function () {\n\n\t\tconsole.warn( 'THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.' );\n\n\t};\n\n\t/** @deprecated */\n\tTHREE.DRACOLoader.releaseDecoderModule = function () {\n\n\t\tconsole.warn( 'THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.' );\n\n\t};\n\n\t/** @deprecated */\n\tTHREE.DRACOLoader.getDecoderModule = function () {\n\n\t\tconsole.warn( 'THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.' );\n\n\t};\n\t\n\treturn THREE.DRACOLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/FBXLoader',[\n\t\"skylark-threejs\",\n\t\"../curves/NURBSCurve\"\n],function(THREE,NURBSCurve,Zlib){\n\t/**\n\t * @author Kyle-Larson https://github.com/Kyle-Larson\n\t * @author Takahiro https://github.com/takahirox\n\t * @author Lewy Blue https://github.com/looeee\n\t *\n\t * Loader loads FBX file and generates Group representing FBX scene.\n\t * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n\t * Versions lower than this may load but will probably have errors\n\t *\n\t * Needs Support:\n\t *  Morph normals / blend shape normals\n\t *\n\t * FBX format references:\n\t * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\n\t * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n\t *\n\t * \tBinary format specification:\n\t *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n\t */\n\n\n\tTHREE.FBXLoader = ( function () {\n\n\t\tvar fbxTree;\n\t\tvar connections;\n\t\tvar sceneGraph;\n\n\t\tfunction FBXLoader( manager ) {\n\n\t\t\tTHREE.Loader.call( this, manager );\n\n\t\t}\n\n\t\tFBXLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\t\tconstructor: FBXLoader,\n\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar self = this;\n\n\t\t\t\tvar path = ( self.path === '' ) ? THREE.LoaderUtils.extractUrlBase( url ) : self.path;\n\n\t\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\t\tloader.setPath( self.path );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tonLoad( self.parse( buffer, path ) );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\t\t\tif ( onError ) onError( error );\n\n\t\t\t\t\t\t\tself.manager.itemError( url );\n\n\t\t\t\t\t\t}, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t},\n\n\t\t\tparse: function ( FBXBuffer, path ) {\n\n\t\t\t\tif ( isFbxFormatBinary( FBXBuffer ) ) {\n\n\t\t\t\t\tfbxTree = new BinaryParser().parse( FBXBuffer );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar FBXText = convertArrayBufferToString( FBXBuffer );\n\n\t\t\t\t\tif ( ! isFbxFormatASCII( FBXText ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown format.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( getFbxVersion( FBXText ) < 7000 ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfbxTree = new TextParser().parse( FBXText );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( fbxTree );\n\n\t\t\t\tvar textureLoader = new THREE.TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\t\treturn new FBXTreeParser( textureLoader, this.manager ).parse( fbxTree );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Parse the FBXTree object returned by the BinaryParser or TextParser and return a THREE.Group\n\t\tfunction FBXTreeParser( textureLoader, manager ) {\n\n\t\t\tthis.textureLoader = textureLoader;\n\t\t\tthis.manager = manager;\n\n\t\t}\n\n\t\tFBXTreeParser.prototype = {\n\n\t\t\tconstructor: FBXTreeParser,\n\n\t\t\tparse: function () {\n\n\t\t\t\tconnections = this.parseConnections();\n\n\t\t\t\tvar images = this.parseImages();\n\t\t\t\tvar textures = this.parseTextures( images );\n\t\t\t\tvar materials = this.parseMaterials( textures );\n\t\t\t\tvar deformers = this.parseDeformers();\n\t\t\t\tvar geometryMap = new GeometryParser().parse( deformers );\n\n\t\t\t\tthis.parseScene( deformers, geometryMap, materials );\n\n\t\t\t\treturn sceneGraph;\n\n\t\t\t},\n\n\t\t\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n\t\t\t// and details the connection type\n\t\t\tparseConnections: function () {\n\n\t\t\t\tvar connectionMap = new Map();\n\n\t\t\t\tif ( 'Connections' in fbxTree ) {\n\n\t\t\t\t\tvar rawConnections = fbxTree.Connections.connections;\n\n\t\t\t\t\trawConnections.forEach( function ( rawConnection ) {\n\n\t\t\t\t\t\tvar fromID = rawConnection[ 0 ];\n\t\t\t\t\t\tvar toID = rawConnection[ 1 ];\n\t\t\t\t\t\tvar relationship = rawConnection[ 2 ];\n\n\t\t\t\t\t\tif ( ! connectionMap.has( fromID ) ) {\n\n\t\t\t\t\t\t\tconnectionMap.set( fromID, {\n\t\t\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\t\t\tchildren: []\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar parentRelationship = { ID: toID, relationship: relationship };\n\t\t\t\t\t\tconnectionMap.get( fromID ).parents.push( parentRelationship );\n\n\t\t\t\t\t\tif ( ! connectionMap.has( toID ) ) {\n\n\t\t\t\t\t\t\tconnectionMap.set( toID, {\n\t\t\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\t\t\tchildren: []\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar childRelationship = { ID: fromID, relationship: relationship };\n\t\t\t\t\t\tconnectionMap.get( toID ).children.push( childRelationship );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\treturn connectionMap;\n\n\t\t\t},\n\n\t\t\t// Parse FBXTree.Objects.Video for embedded image data\n\t\t\t// These images are connected to textures in FBXTree.Objects.Textures\n\t\t\t// via FBXTree.Connections.\n\t\t\tparseImages: function () {\n\n\t\t\t\tvar images = {};\n\t\t\t\tvar blobs = {};\n\n\t\t\t\tif ( 'Video' in fbxTree.Objects ) {\n\n\t\t\t\t\tvar videoNodes = fbxTree.Objects.Video;\n\n\t\t\t\t\tfor ( var nodeID in videoNodes ) {\n\n\t\t\t\t\t\tvar videoNode = videoNodes[ nodeID ];\n\n\t\t\t\t\t\tvar id = parseInt( nodeID );\n\n\t\t\t\t\t\timages[ id ] = videoNode.RelativeFilename || videoNode.Filename;\n\n\t\t\t\t\t\t// raw image data is in videoNode.Content\n\t\t\t\t\t\tif ( 'Content' in videoNode ) {\n\n\t\t\t\t\t\t\tvar arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );\n\t\t\t\t\t\t\tvar base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );\n\n\t\t\t\t\t\t\tif ( arrayBufferContent || base64Content ) {\n\n\t\t\t\t\t\t\t\tvar image = this.parseImage( videoNodes[ nodeID ] );\n\n\t\t\t\t\t\t\t\tblobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var id in images ) {\n\n\t\t\t\t\tvar filename = images[ id ];\n\n\t\t\t\t\tif ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];\n\t\t\t\t\telse images[ id ] = images[ id ].split( '\\\\' ).pop();\n\n\t\t\t\t}\n\n\t\t\t\treturn images;\n\n\t\t\t},\n\n\t\t\t// Parse embedded image data in FBXTree.Video.Content\n\t\t\tparseImage: function ( videoNode ) {\n\n\t\t\t\tvar content = videoNode.Content;\n\t\t\t\tvar fileName = videoNode.RelativeFilename || videoNode.Filename;\n\t\t\t\tvar extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();\n\n\t\t\t\tvar type;\n\n\t\t\t\tswitch ( extension ) {\n\n\t\t\t\t\tcase 'bmp':\n\n\t\t\t\t\t\ttype = 'image/bmp';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'jpg':\n\t\t\t\t\tcase 'jpeg':\n\n\t\t\t\t\t\ttype = 'image/jpeg';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'png':\n\n\t\t\t\t\t\ttype = 'image/png';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'tif':\n\n\t\t\t\t\t\ttype = 'image/tiff';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'tga':\n\n\t\t\t\t\t\tif ( this.manager.getHandler( '.tga' ) === null ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'FBXLoader: TGA loader not found, skipping ', fileName );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttype = 'image/tga';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.warn( 'FBXLoader: Image type \"' + extension + '\" is not supported.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( typeof content === 'string' ) { // ASCII format\n\n\t\t\t\t\treturn 'data:' + type + ';base64,' + content;\n\n\t\t\t\t} else { // Binary Format\n\n\t\t\t\t\tvar array = new Uint8Array( content );\n\t\t\t\t\treturn window.URL.createObjectURL( new Blob( [ array ], { type: type } ) );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t// Parse nodes in FBXTree.Objects.Texture\n\t\t\t// These contain details such as UV scaling, cropping, rotation etc and are connected\n\t\t\t// to images in FBXTree.Objects.Video\n\t\t\tparseTextures: function ( images ) {\n\n\t\t\t\tvar textureMap = new Map();\n\n\t\t\t\tif ( 'Texture' in fbxTree.Objects ) {\n\n\t\t\t\t\tvar textureNodes = fbxTree.Objects.Texture;\n\t\t\t\t\tfor ( var nodeID in textureNodes ) {\n\n\t\t\t\t\t\tvar texture = this.parseTexture( textureNodes[ nodeID ], images );\n\t\t\t\t\t\ttextureMap.set( parseInt( nodeID ), texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn textureMap;\n\n\t\t\t},\n\n\t\t\t// Parse individual node in FBXTree.Objects.Texture\n\t\t\tparseTexture: function ( textureNode, images ) {\n\n\t\t\t\tvar texture = this.loadTexture( textureNode, images );\n\n\t\t\t\ttexture.ID = textureNode.id;\n\n\t\t\t\ttexture.name = textureNode.attrName;\n\n\t\t\t\tvar wrapModeU = textureNode.WrapModeU;\n\t\t\t\tvar wrapModeV = textureNode.WrapModeV;\n\n\t\t\t\tvar valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n\t\t\t\tvar valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n\t\t\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n\t\t\t\t// 0: repeat(default), 1: clamp\n\n\t\t\t\ttexture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n\t\t\t\tif ( 'Scaling' in textureNode ) {\n\n\t\t\t\t\tvar values = textureNode.Scaling.value;\n\n\t\t\t\t\ttexture.repeat.x = values[ 0 ];\n\t\t\t\t\ttexture.repeat.y = values[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\treturn texture;\n\n\t\t\t},\n\n\t\t\t// load a texture specified as a blob or data URI, or via an external URL using THREE.TextureLoader\n\t\t\tloadTexture: function ( textureNode, images ) {\n\n\t\t\t\tvar fileName;\n\n\t\t\t\tvar currentPath = this.textureLoader.path;\n\n\t\t\t\tvar children = connections.get( textureNode.id ).children;\n\n\t\t\t\tif ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {\n\n\t\t\t\t\tfileName = images[ children[ 0 ].ID ];\n\n\t\t\t\t\tif ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {\n\n\t\t\t\t\t\tthis.textureLoader.setPath( undefined );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar texture;\n\n\t\t\t\tvar extension = textureNode.FileName.slice( - 3 ).toLowerCase();\n\n\t\t\t\tif ( extension === 'tga' ) {\n\n\t\t\t\t\tvar loader = this.manager.getHandler( '.tga' );\n\n\t\t\t\t\tif ( loader === null ) {\n\n\t\t\t\t\t\tconsole.warn( 'FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename );\n\t\t\t\t\t\ttexture = new THREE.Texture();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture = loader.load( fileName );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( extension === 'psd' ) {\n\n\t\t\t\t\tconsole.warn( 'FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename );\n\t\t\t\t\ttexture = new THREE.Texture();\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture = this.textureLoader.load( fileName );\n\n\t\t\t\t}\n\n\t\t\t\tthis.textureLoader.setPath( currentPath );\n\n\t\t\t\treturn texture;\n\n\t\t\t},\n\n\t\t\t// Parse nodes in FBXTree.Objects.Material\n\t\t\tparseMaterials: function ( textureMap ) {\n\n\t\t\t\tvar materialMap = new Map();\n\n\t\t\t\tif ( 'Material' in fbxTree.Objects ) {\n\n\t\t\t\t\tvar materialNodes = fbxTree.Objects.Material;\n\n\t\t\t\t\tfor ( var nodeID in materialNodes ) {\n\n\t\t\t\t\t\tvar material = this.parseMaterial( materialNodes[ nodeID ], textureMap );\n\n\t\t\t\t\t\tif ( material !== null ) materialMap.set( parseInt( nodeID ), material );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn materialMap;\n\n\t\t\t},\n\n\t\t\t// Parse single node in FBXTree.Objects.Material\n\t\t\t// Materials are connected to texture maps in FBXTree.Objects.Textures\n\t\t\t// FBX format currently only supports Lambert and Phong shading models\n\t\t\tparseMaterial: function ( materialNode, textureMap ) {\n\n\t\t\t\tvar ID = materialNode.id;\n\t\t\t\tvar name = materialNode.attrName;\n\t\t\t\tvar type = materialNode.ShadingModel;\n\n\t\t\t\t// Case where FBX wraps shading model in property object.\n\t\t\t\tif ( typeof type === 'object' ) {\n\n\t\t\t\t\ttype = type.value;\n\n\t\t\t\t}\n\n\t\t\t\t// Ignore unused materials which don't have any connections.\n\t\t\t\tif ( ! connections.has( ID ) ) return null;\n\n\t\t\t\tvar parameters = this.parseParameters( materialNode, textureMap, ID );\n\n\t\t\t\tvar material;\n\n\t\t\t\tswitch ( type.toLowerCase() ) {\n\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type );\n\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.setValues( parameters );\n\t\t\t\tmaterial.name = name;\n\n\t\t\t\treturn material;\n\n\t\t\t},\n\n\t\t\t// Parse FBX material and return parameters suitable for a three.js material\n\t\t\t// Also parse the texture map and return any textures associated with the material\n\t\t\tparseParameters: function ( materialNode, textureMap, ID ) {\n\n\t\t\t\tvar parameters = {};\n\n\t\t\t\tif ( materialNode.BumpFactor ) {\n\n\t\t\t\t\tparameters.bumpScale = materialNode.BumpFactor.value;\n\n\t\t\t\t}\n\t\t\t\tif ( materialNode.Diffuse ) {\n\n\t\t\t\t\tparameters.color = new THREE.Color().fromArray( materialNode.Diffuse.value );\n\n\t\t\t\t} else if ( materialNode.DiffuseColor && materialNode.DiffuseColor.type === 'Color' ) {\n\n\t\t\t\t\t// The blender exporter exports diffuse here instead of in materialNode.Diffuse\n\t\t\t\t\tparameters.color = new THREE.Color().fromArray( materialNode.DiffuseColor.value );\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialNode.DisplacementFactor ) {\n\n\t\t\t\t\tparameters.displacementScale = materialNode.DisplacementFactor.value;\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialNode.Emissive ) {\n\n\t\t\t\t\tparameters.emissive = new THREE.Color().fromArray( materialNode.Emissive.value );\n\n\t\t\t\t} else if ( materialNode.EmissiveColor && materialNode.EmissiveColor.type === 'Color' ) {\n\n\t\t\t\t\t// The blender exporter exports emissive color here instead of in materialNode.Emissive\n\t\t\t\t\tparameters.emissive = new THREE.Color().fromArray( materialNode.EmissiveColor.value );\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialNode.EmissiveFactor ) {\n\n\t\t\t\t\tparameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value );\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialNode.Opacity ) {\n\n\t\t\t\t\tparameters.opacity = parseFloat( materialNode.Opacity.value );\n\n\t\t\t\t}\n\n\t\t\t\tif ( parameters.opacity < 1.0 ) {\n\n\t\t\t\t\tparameters.transparent = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialNode.ReflectionFactor ) {\n\n\t\t\t\t\tparameters.reflectivity = materialNode.ReflectionFactor.value;\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialNode.Shininess ) {\n\n\t\t\t\t\tparameters.shininess = materialNode.Shininess.value;\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialNode.Specular ) {\n\n\t\t\t\t\tparameters.specular = new THREE.Color().fromArray( materialNode.Specular.value );\n\n\t\t\t\t} else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {\n\n\t\t\t\t\t// The blender exporter exports specular color here instead of in materialNode.Specular\n\t\t\t\t\tparameters.specular = new THREE.Color().fromArray( materialNode.SpecularColor.value );\n\n\t\t\t\t}\n\n\t\t\t\tvar self = this;\n\t\t\t\tconnections.get( ID ).children.forEach( function ( child ) {\n\n\t\t\t\t\tvar type = child.relationship;\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'Bump':\n\t\t\t\t\t\t\tparameters.bumpMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Maya|TEX_ao_map':\n\t\t\t\t\t\t\tparameters.aoMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'DiffuseColor':\n\t\t\t\t\t\tcase 'Maya|TEX_color_map':\n\t\t\t\t\t\t\tparameters.map = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tparameters.map.encoding = THREE.sRGBEncoding;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'DisplacementColor':\n\t\t\t\t\t\t\tparameters.displacementMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'EmissiveColor':\n\t\t\t\t\t\t\tparameters.emissiveMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tparameters.emissiveMap.encoding = THREE.sRGBEncoding;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'NormalMap':\n\t\t\t\t\t\tcase 'Maya|TEX_normal_map':\n\t\t\t\t\t\t\tparameters.normalMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ReflectionColor':\n\t\t\t\t\t\t\tparameters.envMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tparameters.envMap.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\t\t\tparameters.envMap.encoding = THREE.sRGBEncoding;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'SpecularColor':\n\t\t\t\t\t\t\tparameters.specularMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tparameters.specularMap.encoding = THREE.sRGBEncoding;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TransparentColor':\n\t\t\t\t\t\t\tparameters.alphaMap = self.getTexture( textureMap, child.ID );\n\t\t\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'AmbientColor':\n\t\t\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\n\t\t\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\n\t\t\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn parameters;\n\n\t\t\t},\n\n\t\t\t// get a texture from the textureMap for use by a material.\n\t\t\tgetTexture: function ( textureMap, id ) {\n\n\t\t\t\t// if the texture is a layered texture, just use the first layer and issue a warning\n\t\t\t\tif ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );\n\t\t\t\t\tid = connections.get( id ).children[ 0 ].ID;\n\n\t\t\t\t}\n\n\t\t\t\treturn textureMap.get( id );\n\n\t\t\t},\n\n\t\t\t// Parse nodes in FBXTree.Objects.Deformer\n\t\t\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n\t\t\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\t\t\tparseDeformers: function () {\n\n\t\t\t\tvar skeletons = {};\n\t\t\t\tvar morphTargets = {};\n\n\t\t\t\tif ( 'Deformer' in fbxTree.Objects ) {\n\n\t\t\t\t\tvar DeformerNodes = fbxTree.Objects.Deformer;\n\n\t\t\t\t\tfor ( var nodeID in DeformerNodes ) {\n\n\t\t\t\t\t\tvar deformerNode = DeformerNodes[ nodeID ];\n\n\t\t\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\n\t\t\t\t\t\tif ( deformerNode.attrType === 'Skin' ) {\n\n\t\t\t\t\t\t\tvar skeleton = this.parseSkeleton( relationships, DeformerNodes );\n\t\t\t\t\t\t\tskeleton.ID = nodeID;\n\n\t\t\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );\n\t\t\t\t\t\t\tskeleton.geometryID = relationships.parents[ 0 ].ID;\n\n\t\t\t\t\t\t\tskeletons[ nodeID ] = skeleton;\n\n\t\t\t\t\t\t} else if ( deformerNode.attrType === 'BlendShape' ) {\n\n\t\t\t\t\t\t\tvar morphTarget = {\n\t\t\t\t\t\t\t\tid: nodeID,\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tmorphTarget.rawTargets = this.parseMorphTargets( relationships, DeformerNodes );\n\t\t\t\t\t\t\tmorphTarget.id = nodeID;\n\n\t\t\t\t\t\t\tif ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );\n\n\t\t\t\t\t\t\tmorphTargets[ nodeID ] = morphTarget;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\n\t\t\t\t\tskeletons: skeletons,\n\t\t\t\t\tmorphTargets: morphTargets,\n\n\t\t\t\t};\n\n\t\t\t},\n\n\t\t\t// Parse single nodes in FBXTree.Objects.Deformer\n\t\t\t// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n\t\t\t// Each skin node represents a skeleton and each cluster node represents a bone\n\t\t\tparseSkeleton: function ( relationships, deformerNodes ) {\n\n\t\t\t\tvar rawBones = [];\n\n\t\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\t\tvar boneNode = deformerNodes[ child.ID ];\n\n\t\t\t\t\tif ( boneNode.attrType !== 'Cluster' ) return;\n\n\t\t\t\t\tvar rawBone = {\n\n\t\t\t\t\t\tID: child.ID,\n\t\t\t\t\t\tindices: [],\n\t\t\t\t\t\tweights: [],\n\t\t\t\t\t\ttransformLink: new THREE.Matrix4().fromArray( boneNode.TransformLink.a ),\n\t\t\t\t\t\t// transform: new THREE.Matrix4().fromArray( boneNode.Transform.a ),\n\t\t\t\t\t\t// linkMode: boneNode.Mode,\n\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( 'Indexes' in boneNode ) {\n\n\t\t\t\t\t\trawBone.indices = boneNode.Indexes.a;\n\t\t\t\t\t\trawBone.weights = boneNode.Weights.a;\n\n\t\t\t\t\t}\n\n\t\t\t\t\trawBones.push( rawBone );\n\n\t\t\t\t} );\n\n\t\t\t\treturn {\n\n\t\t\t\t\trawBones: rawBones,\n\t\t\t\t\tbones: []\n\n\t\t\t\t};\n\n\t\t\t},\n\n\t\t\t// The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\t\t\tparseMorphTargets: function ( relationships, deformerNodes ) {\n\n\t\t\t\tvar rawMorphTargets = [];\n\n\t\t\t\tfor ( var i = 0; i < relationships.children.length; i ++ ) {\n\n\t\t\t\t\tvar child = relationships.children[ i ];\n\n\t\t\t\t\tvar morphTargetNode = deformerNodes[ child.ID ];\n\n\t\t\t\t\tvar rawMorphTarget = {\n\n\t\t\t\t\t\tname: morphTargetNode.attrName,\n\t\t\t\t\t\tinitialWeight: morphTargetNode.DeformPercent,\n\t\t\t\t\t\tid: morphTargetNode.id,\n\t\t\t\t\t\tfullWeights: morphTargetNode.FullWeights.a\n\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return;\n\n\t\t\t\t\trawMorphTarget.geoID = connections.get( parseInt( child.ID ) ).children.filter( function ( child ) {\n\n\t\t\t\t\t\treturn child.relationship === undefined;\n\n\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\trawMorphTargets.push( rawMorphTarget );\n\n\t\t\t\t}\n\n\t\t\t\treturn rawMorphTargets;\n\n\t\t\t},\n\n\t\t\t// create the main THREE.Group() to be returned by the loader\n\t\t\tparseScene: function ( deformers, geometryMap, materialMap ) {\n\n\t\t\t\tsceneGraph = new THREE.Group();\n\n\t\t\t\tvar modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap );\n\n\t\t\t\tvar modelNodes = fbxTree.Objects.Model;\n\n\t\t\t\tvar self = this;\n\t\t\t\tmodelMap.forEach( function ( model ) {\n\n\t\t\t\t\tvar modelNode = modelNodes[ model.ID ];\n\t\t\t\t\tself.setLookAtProperties( model, modelNode );\n\n\t\t\t\t\tvar parentConnections = connections.get( model.ID ).parents;\n\n\t\t\t\t\tparentConnections.forEach( function ( connection ) {\n\n\t\t\t\t\t\tvar parent = modelMap.get( connection.ID );\n\t\t\t\t\t\tif ( parent !== undefined ) parent.add( model );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( model.parent === null ) {\n\n\t\t\t\t\t\tsceneGraph.add( model );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} );\n\n\t\t\t\tthis.bindSkeleton( deformers.skeletons, geometryMap, modelMap );\n\n\t\t\t\tthis.createAmbientLight();\n\n\t\t\t\tthis.setupMorphMaterials();\n\n\t\t\t\tsceneGraph.traverse( function ( node ) {\n\n\t\t\t\t\tif ( node.userData.transformData ) {\n\n\t\t\t\t\t\tif ( node.parent ) node.userData.transformData.parentMatrixWorld = node.parent.matrix;\n\n\t\t\t\t\t\tvar transform = generateTransform( node.userData.transformData );\n\n\t\t\t\t\t\tnode.applyMatrix4( transform );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tvar animations = new AnimationParser().parse();\n\n\t\t\t\t// if all the models where already combined in a single group, just return that\n\t\t\t\tif ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) {\n\n\t\t\t\t\tsceneGraph.children[ 0 ].animations = animations;\n\t\t\t\t\tsceneGraph = sceneGraph.children[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tsceneGraph.animations = animations;\n\n\t\t\t},\n\n\t\t\t// parse nodes in FBXTree.Objects.Model\n\t\t\tparseModels: function ( skeletons, geometryMap, materialMap ) {\n\n\t\t\t\tvar modelMap = new Map();\n\t\t\t\tvar modelNodes = fbxTree.Objects.Model;\n\n\t\t\t\tfor ( var nodeID in modelNodes ) {\n\n\t\t\t\t\tvar id = parseInt( nodeID );\n\t\t\t\t\tvar node = modelNodes[ nodeID ];\n\t\t\t\t\tvar relationships = connections.get( id );\n\n\t\t\t\t\tvar model = this.buildSkeleton( relationships, skeletons, id, node.attrName );\n\n\t\t\t\t\tif ( ! model ) {\n\n\t\t\t\t\t\tswitch ( node.attrType ) {\n\n\t\t\t\t\t\t\tcase 'Camera':\n\t\t\t\t\t\t\t\tmodel = this.createCamera( relationships );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'Light':\n\t\t\t\t\t\t\t\tmodel = this.createLight( relationships );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\t\t\tmodel = this.createMesh( relationships, geometryMap, materialMap );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\t\t\tmodel = this.createCurve( relationships, geometryMap );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'LimbNode':\n\t\t\t\t\t\t\tcase 'Root':\n\t\t\t\t\t\t\t\tmodel = new THREE.Bone();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'Null':\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tmodel = new THREE.Group();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmodel.name = node.attrName ? THREE.PropertyBinding.sanitizeNodeName( node.attrName ) : '';\n\n\t\t\t\t\t\tmodel.ID = id;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.getTransformData( model, node );\n\t\t\t\t\tmodelMap.set( id, model );\n\n\t\t\t\t}\n\n\t\t\t\treturn modelMap;\n\n\t\t\t},\n\n\t\t\tbuildSkeleton: function ( relationships, skeletons, id, name ) {\n\n\t\t\t\tvar bone = null;\n\n\t\t\t\trelationships.parents.forEach( function ( parent ) {\n\n\t\t\t\t\tfor ( var ID in skeletons ) {\n\n\t\t\t\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\t\t\tif ( rawBone.ID === parent.ID ) {\n\n\t\t\t\t\t\t\t\tvar subBone = bone;\n\t\t\t\t\t\t\t\tbone = new THREE.Bone();\n\n\t\t\t\t\t\t\t\tbone.matrixWorld.copy( rawBone.transformLink );\n\n\t\t\t\t\t\t\t\t// set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n\t\t\t\t\t\t\t\tbone.name = name ? THREE.PropertyBinding.sanitizeNodeName( name ) : '';\n\t\t\t\t\t\t\t\tbone.ID = id;\n\n\t\t\t\t\t\t\t\tskeleton.bones[ i ] = bone;\n\n\t\t\t\t\t\t\t\t// In cases where a bone is shared between multiple meshes\n\t\t\t\t\t\t\t\t// duplicate the bone here and and it as a child of the first bone\n\t\t\t\t\t\t\t\tif ( subBone !== null ) {\n\n\t\t\t\t\t\t\t\t\tbone.add( subBone );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn bone;\n\n\t\t\t},\n\n\t\t\t// create a THREE.PerspectiveCamera or THREE.OrthographicCamera\n\t\t\tcreateCamera: function ( relationships ) {\n\n\t\t\t\tvar model;\n\t\t\t\tvar cameraAttribute;\n\n\t\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\t\tvar attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\t\t\tcameraAttribute = attr;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tif ( cameraAttribute === undefined ) {\n\n\t\t\t\t\tmodel = new THREE.Object3D();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar type = 0;\n\t\t\t\t\tif ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {\n\n\t\t\t\t\t\ttype = 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar nearClippingPlane = 1;\n\t\t\t\t\tif ( cameraAttribute.NearPlane !== undefined ) {\n\n\t\t\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar farClippingPlane = 1000;\n\t\t\t\t\tif ( cameraAttribute.FarPlane !== undefined ) {\n\n\t\t\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tvar width = window.innerWidth;\n\t\t\t\t\tvar height = window.innerHeight;\n\n\t\t\t\t\tif ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {\n\n\t\t\t\t\t\twidth = cameraAttribute.AspectWidth.value;\n\t\t\t\t\t\theight = cameraAttribute.AspectHeight.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar aspect = width / height;\n\n\t\t\t\t\tvar fov = 45;\n\t\t\t\t\tif ( cameraAttribute.FieldOfView !== undefined ) {\n\n\t\t\t\t\t\tfov = cameraAttribute.FieldOfView.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 0: // Perspective\n\t\t\t\t\t\t\tmodel = new THREE.PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );\n\t\t\t\t\t\t\tif ( focalLength !== null ) model.setFocalLength( focalLength );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 1: // Orthographic\n\t\t\t\t\t\t\tmodel = new THREE.OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, nearClippingPlane, farClippingPlane );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );\n\t\t\t\t\t\t\tmodel = new THREE.Object3D();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn model;\n\n\t\t\t},\n\n\t\t\t// Create a THREE.DirectionalLight, THREE.PointLight or THREE.SpotLight\n\t\t\tcreateLight: function ( relationships ) {\n\n\t\t\t\tvar model;\n\t\t\t\tvar lightAttribute;\n\n\t\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\t\tvar attr = fbxTree.Objects.NodeAttribute[ child.ID ];\n\n\t\t\t\t\tif ( attr !== undefined ) {\n\n\t\t\t\t\t\tlightAttribute = attr;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tif ( lightAttribute === undefined ) {\n\n\t\t\t\t\tmodel = new THREE.Object3D();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar type;\n\n\t\t\t\t\t// LightType can be undefined for Point lights\n\t\t\t\t\tif ( lightAttribute.LightType === undefined ) {\n\n\t\t\t\t\t\ttype = 0;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttype = lightAttribute.LightType.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar color = 0xffffff;\n\n\t\t\t\t\tif ( lightAttribute.Color !== undefined ) {\n\n\t\t\t\t\t\tcolor = new THREE.Color().fromArray( lightAttribute.Color.value );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;\n\n\t\t\t\t\t// light disabled\n\t\t\t\t\tif ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {\n\n\t\t\t\t\t\tintensity = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar distance = 0;\n\t\t\t\t\tif ( lightAttribute.FarAttenuationEnd !== undefined ) {\n\n\t\t\t\t\t\tif ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {\n\n\t\t\t\t\t\t\tdistance = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\t\t\t\t\tvar decay = 1;\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 0: // Point\n\t\t\t\t\t\t\tmodel = new THREE.PointLight( color, intensity, distance, decay );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 1: // Directional\n\t\t\t\t\t\t\tmodel = new THREE.DirectionalLight( color, intensity );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2: // Spot\n\t\t\t\t\t\t\tvar angle = Math.PI / 3;\n\n\t\t\t\t\t\t\tif ( lightAttribute.InnerAngle !== undefined ) {\n\n\t\t\t\t\t\t\t\tangle = THREE.MathUtils.degToRad( lightAttribute.InnerAngle.value );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar penumbra = 0;\n\t\t\t\t\t\t\tif ( lightAttribute.OuterAngle !== undefined ) {\n\n\t\t\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\n\t\t\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n\t\t\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n\t\t\t\t\t\t\t\tpenumbra = THREE.MathUtils.degToRad( lightAttribute.OuterAngle.value );\n\t\t\t\t\t\t\t\tpenumbra = Math.max( penumbra, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmodel = new THREE.SpotLight( color, intensity, distance, angle, penumbra, decay );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a THREE.PointLight.' );\n\t\t\t\t\t\t\tmodel = new THREE.PointLight( color, intensity );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {\n\n\t\t\t\t\t\tmodel.castShadow = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn model;\n\n\t\t\t},\n\n\t\t\tcreateMesh: function ( relationships, geometryMap, materialMap ) {\n\n\t\t\t\tvar model;\n\t\t\t\tvar geometry = null;\n\t\t\t\tvar material = null;\n\t\t\t\tvar materials = [];\n\n\t\t\t\t// get geometry and materials(s) from connections\n\t\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\t\tif ( geometryMap.has( child.ID ) ) {\n\n\t\t\t\t\t\tgeometry = geometryMap.get( child.ID );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( materialMap.has( child.ID ) ) {\n\n\t\t\t\t\t\tmaterials.push( materialMap.get( child.ID ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tif ( materials.length > 1 ) {\n\n\t\t\t\t\tmaterial = materials;\n\n\t\t\t\t} else if ( materials.length > 0 ) {\n\n\t\t\t\t\tmaterial = materials[ 0 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial( { color: 0xcccccc } );\n\t\t\t\t\tmaterials.push( material );\n\n\t\t\t\t}\n\n\t\t\t\tif ( 'color' in geometry.attributes ) {\n\n\t\t\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.FBX_Deformer ) {\n\n\t\t\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\t\t\tmaterial.skinning = true;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tmodel = new THREE.SkinnedMesh( geometry, material );\n\t\t\t\t\tmodel.normalizeSkinWeights();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmodel = new THREE.Mesh( geometry, material );\n\n\t\t\t\t}\n\n\t\t\t\treturn model;\n\n\t\t\t},\n\n\t\t\tcreateCurve: function ( relationships, geometryMap ) {\n\n\t\t\t\tvar geometry = relationships.children.reduce( function ( geo, child ) {\n\n\t\t\t\t\tif ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );\n\n\t\t\t\t\treturn geo;\n\n\t\t\t\t}, null );\n\n\t\t\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\t\t\t\tvar material = new THREE.LineBasicMaterial( { color: 0x3300ff, linewidth: 1 } );\n\t\t\t\treturn new THREE.Line( geometry, material );\n\n\t\t\t},\n\n\t\t\t// parse the model node for transform data\n\t\t\tgetTransformData: function ( model, modelNode ) {\n\n\t\t\t\tvar transformData = {};\n\n\t\t\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\t\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\t\t\telse transformData.eulerOrder = 'ZYX';\n\n\t\t\t\tif ( 'Lcl_Translation' in modelNode ) transformData.translation = modelNode.Lcl_Translation.value;\n\n\t\t\t\tif ( 'PreRotation' in modelNode ) transformData.preRotation = modelNode.PreRotation.value;\n\t\t\t\tif ( 'Lcl_Rotation' in modelNode ) transformData.rotation = modelNode.Lcl_Rotation.value;\n\t\t\t\tif ( 'PostRotation' in modelNode ) transformData.postRotation = modelNode.PostRotation.value;\n\n\t\t\t\tif ( 'Lcl_Scaling' in modelNode ) transformData.scale = modelNode.Lcl_Scaling.value;\n\n\t\t\t\tif ( 'ScalingOffset' in modelNode ) transformData.scalingOffset = modelNode.ScalingOffset.value;\n\t\t\t\tif ( 'ScalingPivot' in modelNode ) transformData.scalingPivot = modelNode.ScalingPivot.value;\n\n\t\t\t\tif ( 'RotationOffset' in modelNode ) transformData.rotationOffset = modelNode.RotationOffset.value;\n\t\t\t\tif ( 'RotationPivot' in modelNode ) transformData.rotationPivot = modelNode.RotationPivot.value;\n\n\t\t\t\tmodel.userData.transformData = transformData;\n\n\t\t\t},\n\n\t\t\tsetLookAtProperties: function ( model, modelNode ) {\n\n\t\t\t\tif ( 'LookAtProperty' in modelNode ) {\n\n\t\t\t\t\tvar children = connections.get( model.ID ).children;\n\n\t\t\t\t\tchildren.forEach( function ( child ) {\n\n\t\t\t\t\t\tif ( child.relationship === 'LookAtProperty' ) {\n\n\t\t\t\t\t\t\tvar lookAtTarget = fbxTree.Objects.Model[ child.ID ];\n\n\t\t\t\t\t\t\tif ( 'Lcl_Translation' in lookAtTarget ) {\n\n\t\t\t\t\t\t\t\tvar pos = lookAtTarget.Lcl_Translation.value;\n\n\t\t\t\t\t\t\t\t// DirectionalLight, SpotLight\n\t\t\t\t\t\t\t\tif ( model.target !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tmodel.target.position.fromArray( pos );\n\t\t\t\t\t\t\t\t\tsceneGraph.add( model.target );\n\n\t\t\t\t\t\t\t\t} else { // Cameras and other Object3Ds\n\n\t\t\t\t\t\t\t\t\tmodel.lookAt( new THREE.Vector3().fromArray( pos ) );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tbindSkeleton: function ( skeletons, geometryMap, modelMap ) {\n\n\t\t\t\tvar bindMatrices = this.parsePoseNodes();\n\n\t\t\t\tfor ( var ID in skeletons ) {\n\n\t\t\t\t\tvar skeleton = skeletons[ ID ];\n\n\t\t\t\t\tvar parents = connections.get( parseInt( skeleton.ID ) ).parents;\n\n\t\t\t\t\tparents.forEach( function ( parent ) {\n\n\t\t\t\t\t\tif ( geometryMap.has( parent.ID ) ) {\n\n\t\t\t\t\t\t\tvar geoID = parent.ID;\n\t\t\t\t\t\t\tvar geoRelationships = connections.get( geoID );\n\n\t\t\t\t\t\t\tgeoRelationships.parents.forEach( function ( geoConnParent ) {\n\n\t\t\t\t\t\t\t\tif ( modelMap.has( geoConnParent.ID ) ) {\n\n\t\t\t\t\t\t\t\t\tvar model = modelMap.get( geoConnParent.ID );\n\n\t\t\t\t\t\t\t\t\tmodel.bind( new THREE.Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tparsePoseNodes: function () {\n\n\t\t\t\tvar bindMatrices = {};\n\n\t\t\t\tif ( 'Pose' in fbxTree.Objects ) {\n\n\t\t\t\t\tvar BindPoseNode = fbxTree.Objects.Pose;\n\n\t\t\t\t\tfor ( var nodeID in BindPoseNode ) {\n\n\t\t\t\t\t\tif ( BindPoseNode[ nodeID ].attrType === 'BindPose' ) {\n\n\t\t\t\t\t\t\tvar poseNodes = BindPoseNode[ nodeID ].PoseNode;\n\n\t\t\t\t\t\t\tif ( Array.isArray( poseNodes ) ) {\n\n\t\t\t\t\t\t\t\tposeNodes.forEach( function ( poseNode ) {\n\n\t\t\t\t\t\t\t\t\tbindMatrices[ poseNode.Node ] = new THREE.Matrix4().fromArray( poseNode.Matrix.a );\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tbindMatrices[ poseNodes.Node ] = new THREE.Matrix4().fromArray( poseNodes.Matrix.a );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn bindMatrices;\n\n\t\t\t},\n\n\t\t\t// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\t\t\tcreateAmbientLight: function () {\n\n\t\t\t\tif ( 'GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings ) {\n\n\t\t\t\t\tvar ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\n\t\t\t\t\tvar r = ambientColor[ 0 ];\n\t\t\t\t\tvar g = ambientColor[ 1 ];\n\t\t\t\t\tvar b = ambientColor[ 2 ];\n\n\t\t\t\t\tif ( r !== 0 || g !== 0 || b !== 0 ) {\n\n\t\t\t\t\t\tvar color = new THREE.Color( r, g, b );\n\t\t\t\t\t\tsceneGraph.add( new THREE.AmbientLight( color, 1 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetupMorphMaterials: function () {\n\n\t\t\t\tvar self = this;\n\t\t\t\tsceneGraph.traverse( function ( child ) {\n\n\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\tif ( child.geometry.morphAttributes.position && child.geometry.morphAttributes.position.length ) {\n\n\t\t\t\t\t\t\tif ( Array.isArray( child.material ) ) {\n\n\t\t\t\t\t\t\t\tchild.material.forEach( function ( material, i ) {\n\n\t\t\t\t\t\t\t\t\tself.setupMorphMaterial( child, material, i );\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tself.setupMorphMaterial( child, child.material );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t},\n\n\t\t\tsetupMorphMaterial: function ( child, material, index ) {\n\n\t\t\t\tvar uuid = child.uuid;\n\t\t\t\tvar matUuid = material.uuid;\n\n\t\t\t\t// if a geometry has morph targets, it cannot share the material with other geometries\n\t\t\t\tvar sharedMat = false;\n\n\t\t\t\tsceneGraph.traverse( function ( node ) {\n\n\t\t\t\t\tif ( node.isMesh ) {\n\n\t\t\t\t\t\tif ( Array.isArray( node.material ) ) {\n\n\t\t\t\t\t\t\tnode.material.forEach( function ( mat ) {\n\n\t\t\t\t\t\t\t\tif ( mat.uuid === matUuid && node.uuid !== uuid ) sharedMat = true;\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} else if ( node.material.uuid === matUuid && node.uuid !== uuid ) sharedMat = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tif ( sharedMat === true ) {\n\n\t\t\t\t\tvar clonedMat = material.clone();\n\t\t\t\t\tclonedMat.morphTargets = true;\n\n\t\t\t\t\tif ( index === undefined ) child.material = clonedMat;\n\t\t\t\t\telse child.material[ index ] = clonedMat;\n\n\t\t\t\t} else material.morphTargets = true;\n\n\t\t\t}\n\n\t\t};\n\n\t\t// parse Geometry data from FBXTree and return map of BufferGeometries\n\t\tfunction GeometryParser() {}\n\n\t\tGeometryParser.prototype = {\n\n\t\t\tconstructor: GeometryParser,\n\n\t\t\t// Parse nodes in FBXTree.Objects.Geometry\n\t\t\tparse: function ( deformers ) {\n\n\t\t\t\tvar geometryMap = new Map();\n\n\t\t\t\tif ( 'Geometry' in fbxTree.Objects ) {\n\n\t\t\t\t\tvar geoNodes = fbxTree.Objects.Geometry;\n\n\t\t\t\t\tfor ( var nodeID in geoNodes ) {\n\n\t\t\t\t\t\tvar relationships = connections.get( parseInt( nodeID ) );\n\t\t\t\t\t\tvar geo = this.parseGeometry( relationships, geoNodes[ nodeID ], deformers );\n\n\t\t\t\t\t\tgeometryMap.set( parseInt( nodeID ), geo );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn geometryMap;\n\n\t\t\t},\n\n\t\t\t// Parse single node in FBXTree.Objects.Geometry\n\t\t\tparseGeometry: function ( relationships, geoNode, deformers ) {\n\n\t\t\t\tswitch ( geoNode.attrType ) {\n\n\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\treturn this.parseMeshGeometry( relationships, geoNode, deformers );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\treturn this.parseNurbsGeometry( geoNode );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\n\t\t\t// Parse single node mesh geometry in FBXTree.Objects.Geometry\n\t\t\tparseMeshGeometry: function ( relationships, geoNode, deformers ) {\n\n\t\t\t\tvar skeletons = deformers.skeletons;\n\t\t\t\tvar morphTargets = [];\n\n\t\t\t\tvar modelNodes = relationships.parents.map( function ( parent ) {\n\n\t\t\t\t\treturn fbxTree.Objects.Model[ parent.ID ];\n\n\t\t\t\t} );\n\n\t\t\t\t// don't create geometry if it is not associated with any models\n\t\t\t\tif ( modelNodes.length === 0 ) return;\n\n\t\t\t\tvar skeleton = relationships.children.reduce( function ( skeleton, child ) {\n\n\t\t\t\t\tif ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];\n\n\t\t\t\t\treturn skeleton;\n\n\t\t\t\t}, null );\n\n\t\t\t\trelationships.children.forEach( function ( child ) {\n\n\t\t\t\t\tif ( deformers.morphTargets[ child.ID ] !== undefined ) {\n\n\t\t\t\t\t\tmorphTargets.push( deformers.morphTargets[ child.ID ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\t// Assume one model and get the preRotation from that\n\t\t\t\t// if there is more than one model associated with the geometry this may cause problems\n\t\t\t\tvar modelNode = modelNodes[ 0 ];\n\n\t\t\t\tvar transformData = {};\n\n\t\t\t\tif ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );\n\t\t\t\tif ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );\n\n\t\t\t\tif ( 'GeometricTranslation' in modelNode ) transformData.translation = modelNode.GeometricTranslation.value;\n\t\t\t\tif ( 'GeometricRotation' in modelNode ) transformData.rotation = modelNode.GeometricRotation.value;\n\t\t\t\tif ( 'GeometricScaling' in modelNode ) transformData.scale = modelNode.GeometricScaling.value;\n\n\t\t\t\tvar transform = generateTransform( transformData );\n\n\t\t\t\treturn this.genGeometry( geoNode, skeleton, morphTargets, transform );\n\n\t\t\t},\n\n\t\t\t// Generate a THREE.BufferGeometry from a node in FBXTree.Objects.Geometry\n\t\t\tgenGeometry: function ( geoNode, skeleton, morphTargets, preTransform ) {\n\n\t\t\t\tvar geo = new THREE.BufferGeometry();\n\t\t\t\tif ( geoNode.attrName ) geo.name = geoNode.attrName;\n\n\t\t\t\tvar geoInfo = this.parseGeoNode( geoNode, skeleton );\n\t\t\t\tvar buffers = this.genBuffers( geoInfo );\n\n\t\t\t\tvar positionAttribute = new THREE.Float32BufferAttribute( buffers.vertex, 3 );\n\n\t\t\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\t\t\tgeo.setAttribute( 'position', positionAttribute );\n\n\t\t\t\tif ( buffers.colors.length > 0 ) {\n\n\t\t\t\t\tgeo.setAttribute( 'color', new THREE.Float32BufferAttribute( buffers.colors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( skeleton ) {\n\n\t\t\t\t\tgeo.setAttribute( 'skinIndex', new THREE.Uint16BufferAttribute( buffers.weightsIndices, 4 ) );\n\n\t\t\t\t\tgeo.setAttribute( 'skinWeight', new THREE.Float32BufferAttribute( buffers.vertexWeights, 4 ) );\n\n\t\t\t\t\t// used later to bind the skeleton to the model\n\t\t\t\t\tgeo.FBX_Deformer = skeleton;\n\n\t\t\t\t}\n\n\t\t\t\tif ( buffers.normal.length > 0 ) {\n\n\t\t\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( preTransform );\n\n\t\t\t\t\tvar normalAttribute = new THREE.Float32BufferAttribute( buffers.normal, 3 );\n\t\t\t\t\tnormalAttribute.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t\tgeo.setAttribute( 'normal', normalAttribute );\n\n\t\t\t\t}\n\n\t\t\t\tbuffers.uvs.forEach( function ( uvBuffer, i ) {\n\n\t\t\t\t\t// subsequent uv buffers are called 'uv1', 'uv2', ...\n\t\t\t\t\tvar name = 'uv' + ( i + 1 ).toString();\n\n\t\t\t\t\t// the first uv buffer is just called 'uv'\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tname = 'uv';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeo.setAttribute( name, new THREE.Float32BufferAttribute( buffers.uvs[ i ], 2 ) );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\n\t\t\t\t\tvar prevMaterialIndex = buffers.materialIndex[ 0 ];\n\t\t\t\t\tvar startIndex = 0;\n\n\t\t\t\t\tbuffers.materialIndex.forEach( function ( currentIndex, i ) {\n\n\t\t\t\t\t\tif ( currentIndex !== prevMaterialIndex ) {\n\n\t\t\t\t\t\t\tgeo.addGroup( startIndex, i - startIndex, prevMaterialIndex );\n\n\t\t\t\t\t\t\tprevMaterialIndex = currentIndex;\n\t\t\t\t\t\t\tstartIndex = i;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\t\t\tif ( geo.groups.length > 0 ) {\n\n\t\t\t\t\t\tvar lastGroup = geo.groups[ geo.groups.length - 1 ];\n\t\t\t\t\t\tvar lastIndex = lastGroup.start + lastGroup.count;\n\n\t\t\t\t\t\tif ( lastIndex !== buffers.materialIndex.length ) {\n\n\t\t\t\t\t\t\tgeo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// case where there are multiple materials but the whole geometry is only\n\t\t\t\t\t// using one of them\n\t\t\t\t\tif ( geo.groups.length === 0 ) {\n\n\t\t\t\t\t\tgeo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.addMorphTargets( geo, geoNode, morphTargets, preTransform );\n\n\t\t\t\treturn geo;\n\n\t\t\t},\n\n\t\t\tparseGeoNode: function ( geoNode, skeleton ) {\n\n\t\t\t\tvar geoInfo = {};\n\n\t\t\t\tgeoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];\n\t\t\t\tgeoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];\n\n\t\t\t\tif ( geoNode.LayerElementColor ) {\n\n\t\t\t\t\tgeoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoNode.LayerElementMaterial ) {\n\n\t\t\t\t\tgeoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoNode.LayerElementNormal ) {\n\n\t\t\t\t\tgeoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geoNode.LayerElementUV ) {\n\n\t\t\t\t\tgeoInfo.uv = [];\n\n\t\t\t\t\tvar i = 0;\n\t\t\t\t\twhile ( geoNode.LayerElementUV[ i ] ) {\n\n\t\t\t\t\t\tgeoInfo.uv.push( this.parseUVs( geoNode.LayerElementUV[ i ] ) );\n\t\t\t\t\t\ti ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeoInfo.weightTable = {};\n\n\t\t\t\tif ( skeleton !== null ) {\n\n\t\t\t\t\tgeoInfo.skeleton = skeleton;\n\n\t\t\t\t\tskeleton.rawBones.forEach( function ( rawBone, i ) {\n\n\t\t\t\t\t\t// loop over the bone's vertex indices and weights\n\t\t\t\t\t\trawBone.indices.forEach( function ( index, j ) {\n\n\t\t\t\t\t\t\tif ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];\n\n\t\t\t\t\t\t\tgeoInfo.weightTable[ index ].push( {\n\n\t\t\t\t\t\t\t\tid: i,\n\t\t\t\t\t\t\t\tweight: rawBone.weights[ j ],\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\treturn geoInfo;\n\n\t\t\t},\n\n\t\t\tgenBuffers: function ( geoInfo ) {\n\n\t\t\t\tvar buffers = {\n\t\t\t\t\tvertex: [],\n\t\t\t\t\tnormal: [],\n\t\t\t\t\tcolors: [],\n\t\t\t\t\tuvs: [],\n\t\t\t\t\tmaterialIndex: [],\n\t\t\t\t\tvertexWeights: [],\n\t\t\t\t\tweightsIndices: [],\n\t\t\t\t};\n\n\t\t\t\tvar polygonIndex = 0;\n\t\t\t\tvar faceLength = 0;\n\t\t\t\tvar displayedWeightsWarning = false;\n\n\t\t\t\t// these will hold data for a single face\n\t\t\t\tvar facePositionIndexes = [];\n\t\t\t\tvar faceNormals = [];\n\t\t\t\tvar faceColors = [];\n\t\t\t\tvar faceUVs = [];\n\t\t\t\tvar faceWeights = [];\n\t\t\t\tvar faceWeightIndices = [];\n\n\t\t\t\tvar self = this;\n\t\t\t\tgeoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {\n\n\t\t\t\t\tvar endOfFace = false;\n\n\t\t\t\t\t// Face index and vertex index arrays are combined in a single array\n\t\t\t\t\t// A cube with quad faces looks like this:\n\t\t\t\t\t// PolygonVertexIndex: *24 {\n\t\t\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n\t\t\t\t\t//  }\n\t\t\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n\t\t\t\t\t// to find index of last vertex bit shift the index: ^ - 1\n\t\t\t\t\tif ( vertexIndex < 0 ) {\n\n\t\t\t\t\t\tvertexIndex = vertexIndex ^ - 1; // equivalent to ( x * -1 ) - 1\n\t\t\t\t\t\tendOfFace = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar weightIndices = [];\n\t\t\t\t\tvar weights = [];\n\n\t\t\t\t\tfacePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );\n\n\t\t\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );\n\n\t\t\t\t\t\tfaceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\t\t\tif ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {\n\n\t\t\t\t\t\t\tgeoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {\n\n\t\t\t\t\t\t\t\tweights.push( wt.weight );\n\t\t\t\t\t\t\t\tweightIndices.push( wt.id );\n\n\t\t\t\t\t\t\t} );\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( weights.length > 4 ) {\n\n\t\t\t\t\t\t\tif ( ! displayedWeightsWarning ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );\n\t\t\t\t\t\t\t\tdisplayedWeightsWarning = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar wIndex = [ 0, 0, 0, 0 ];\n\t\t\t\t\t\t\tvar Weight = [ 0, 0, 0, 0 ];\n\n\t\t\t\t\t\t\tweights.forEach( function ( weight, weightIndex ) {\n\n\t\t\t\t\t\t\t\tvar currentWeight = weight;\n\t\t\t\t\t\t\t\tvar currentIndex = weightIndices[ weightIndex ];\n\n\t\t\t\t\t\t\t\tWeight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {\n\n\t\t\t\t\t\t\t\t\tif ( currentWeight > comparedWeight ) {\n\n\t\t\t\t\t\t\t\t\t\tcomparedWeightArray[ comparedWeightIndex ] = currentWeight;\n\t\t\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\n\n\t\t\t\t\t\t\t\t\t\tvar tmp = wIndex[ comparedWeightIndex ];\n\t\t\t\t\t\t\t\t\t\twIndex[ comparedWeightIndex ] = currentIndex;\n\t\t\t\t\t\t\t\t\t\tcurrentIndex = tmp;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\tweightIndices = wIndex;\n\t\t\t\t\t\t\tweights = Weight;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if the weight array is shorter than 4 pad with 0s\n\t\t\t\t\t\twhile ( weights.length < 4 ) {\n\n\t\t\t\t\t\t\tweights.push( 0 );\n\t\t\t\t\t\t\tweightIndices.push( 0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\t\t\tfaceWeights.push( weights[ i ] );\n\t\t\t\t\t\t\tfaceWeightIndices.push( weightIndices[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );\n\n\t\t\t\t\t\tfaceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\t\t\tvar materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\t\t\tgeoInfo.uv.forEach( function ( uv, i ) {\n\n\t\t\t\t\t\t\tvar data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );\n\n\t\t\t\t\t\t\tif ( faceUVs[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\tfaceUVs[ i ] = [];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfaceUVs[ i ].push( data[ 0 ] );\n\t\t\t\t\t\t\tfaceUVs[ i ].push( data[ 1 ] );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceLength ++;\n\n\t\t\t\t\tif ( endOfFace ) {\n\n\t\t\t\t\t\tself.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );\n\n\t\t\t\t\t\tpolygonIndex ++;\n\t\t\t\t\t\tfaceLength = 0;\n\n\t\t\t\t\t\t// reset arrays for the next face\n\t\t\t\t\t\tfacePositionIndexes = [];\n\t\t\t\t\t\tfaceNormals = [];\n\t\t\t\t\t\tfaceColors = [];\n\t\t\t\t\t\tfaceUVs = [];\n\t\t\t\t\t\tfaceWeights = [];\n\t\t\t\t\t\tfaceWeightIndices = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn buffers;\n\n\t\t\t},\n\n\t\t\t// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\t\t\tgenFace: function ( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {\n\n\t\t\t\tfor ( var i = 2; i < faceLength; i ++ ) {\n\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] );\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] );\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] );\n\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] );\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] );\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] );\n\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] );\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] );\n\t\t\t\t\tbuffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] );\n\n\t\t\t\t\tif ( geoInfo.skeleton ) {\n\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 0 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 1 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 2 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ 3 ] );\n\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] );\n\t\t\t\t\t\tbuffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] );\n\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 0 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 1 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 2 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ 3 ] );\n\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] );\n\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] );\n\t\t\t\t\t\tbuffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.color ) {\n\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ 0 ] );\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ 1 ] );\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ 2 ] );\n\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 ] );\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 ] );\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 1 ] );\n\t\t\t\t\t\tbuffers.colors.push( faceColors[ i * 3 + 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {\n\n\t\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\t\t\t\t\t\tbuffers.materialIndex.push( materialIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.normal ) {\n\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ 0 ] );\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ 1 ] );\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ 2 ] );\n\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] );\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] );\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] );\n\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 ] );\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 1 ] );\n\t\t\t\t\t\tbuffers.normal.push( faceNormals[ i * 3 + 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geoInfo.uv ) {\n\n\t\t\t\t\t\tgeoInfo.uv.forEach( function ( uv, j ) {\n\n\t\t\t\t\t\t\tif ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];\n\n\t\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 0 ] );\n\t\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ 1 ] );\n\n\t\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] );\n\t\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] );\n\n\t\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] );\n\t\t\t\t\t\t\tbuffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\taddMorphTargets: function ( parentGeo, parentGeoNode, morphTargets, preTransform ) {\n\n\t\t\t\tif ( morphTargets.length === 0 ) return;\n\n\t\t\t\tparentGeo.morphTargetsRelative = true;\n\n\t\t\t\tparentGeo.morphAttributes.position = [];\n\t\t\t\t// parentGeo.morphAttributes.normal = []; // not implemented\n\n\t\t\t\tvar self = this;\n\t\t\t\tmorphTargets.forEach( function ( morphTarget ) {\n\n\t\t\t\t\tmorphTarget.rawTargets.forEach( function ( rawTarget ) {\n\n\t\t\t\t\t\tvar morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ];\n\n\t\t\t\t\t\tif ( morphGeoNode !== undefined ) {\n\n\t\t\t\t\t\t\tself.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t} );\n\n\t\t\t},\n\n\t\t\t// a morph geometry node is similar to a standard  node, and the node is also contained\n\t\t\t// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n\t\t\t// and a special attribute Index defining which vertices of the original geometry are affected\n\t\t\t// Normal and position attributes only have data for the vertices that are affected by the morph\n\t\t\tgenMorphGeometry: function ( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) {\n\n\t\t\t\tvar vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : [];\n\n\t\t\t\tvar morphPositionsSparse = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : [];\n\t\t\t\tvar indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : [];\n\n\t\t\t\tvar length = parentGeo.attributes.position.count * 3;\n\t\t\t\tvar morphPositions = new Float32Array( length );\n\n\t\t\t\tfor ( var i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\tvar morphIndex = indices[ i ] * 3;\n\n\t\t\t\t\tmorphPositions[ morphIndex ] = morphPositionsSparse[ i * 3 ];\n\t\t\t\t\tmorphPositions[ morphIndex + 1 ] = morphPositionsSparse[ i * 3 + 1 ];\n\t\t\t\t\tmorphPositions[ morphIndex + 2 ] = morphPositionsSparse[ i * 3 + 2 ];\n\n\t\t\t\t}\n\n\t\t\t\t// TODO: add morph normal support\n\t\t\t\tvar morphGeoInfo = {\n\t\t\t\t\tvertexIndices: vertexIndices,\n\t\t\t\t\tvertexPositions: morphPositions,\n\n\t\t\t\t};\n\n\t\t\t\tvar morphBuffers = this.genBuffers( morphGeoInfo );\n\n\t\t\t\tvar positionAttribute = new THREE.Float32BufferAttribute( morphBuffers.vertex, 3 );\n\t\t\t\tpositionAttribute.name = name || morphGeoNode.attrName;\n\n\t\t\t\tpositionAttribute.applyMatrix4( preTransform );\n\n\t\t\t\tparentGeo.morphAttributes.position.push( positionAttribute );\n\n\t\t\t},\n\n\t\t\t// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\t\t\tparseNormals: function ( NormalNode ) {\n\n\t\t\t\tvar mappingType = NormalNode.MappingInformationType;\n\t\t\t\tvar referenceType = NormalNode.ReferenceInformationType;\n\t\t\t\tvar buffer = NormalNode.Normals.a;\n\t\t\t\tvar indexBuffer = [];\n\t\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\t\tif ( 'NormalIndex' in NormalNode ) {\n\n\t\t\t\t\t\tindexBuffer = NormalNode.NormalIndex.a;\n\n\t\t\t\t\t} else if ( 'NormalsIndex' in NormalNode ) {\n\n\t\t\t\t\t\tindexBuffer = NormalNode.NormalsIndex.a;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdataSize: 3,\n\t\t\t\t\tbuffer: buffer,\n\t\t\t\t\tindices: indexBuffer,\n\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\treferenceType: referenceType\n\t\t\t\t};\n\n\t\t\t},\n\n\t\t\t// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\t\t\tparseUVs: function ( UVNode ) {\n\n\t\t\t\tvar mappingType = UVNode.MappingInformationType;\n\t\t\t\tvar referenceType = UVNode.ReferenceInformationType;\n\t\t\t\tvar buffer = UVNode.UV.a;\n\t\t\t\tvar indexBuffer = [];\n\t\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\t\tindexBuffer = UVNode.UVIndex.a;\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdataSize: 2,\n\t\t\t\t\tbuffer: buffer,\n\t\t\t\t\tindices: indexBuffer,\n\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\treferenceType: referenceType\n\t\t\t\t};\n\n\t\t\t},\n\n\t\t\t// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\t\t\tparseVertexColors: function ( ColorNode ) {\n\n\t\t\t\tvar mappingType = ColorNode.MappingInformationType;\n\t\t\t\tvar referenceType = ColorNode.ReferenceInformationType;\n\t\t\t\tvar buffer = ColorNode.Colors.a;\n\t\t\t\tvar indexBuffer = [];\n\t\t\t\tif ( referenceType === 'IndexToDirect' ) {\n\n\t\t\t\t\tindexBuffer = ColorNode.ColorIndex.a;\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdataSize: 4,\n\t\t\t\t\tbuffer: buffer,\n\t\t\t\t\tindices: indexBuffer,\n\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\treferenceType: referenceType\n\t\t\t\t};\n\n\t\t\t},\n\n\t\t\t// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\t\t\tparseMaterialIndices: function ( MaterialNode ) {\n\n\t\t\t\tvar mappingType = MaterialNode.MappingInformationType;\n\t\t\t\tvar referenceType = MaterialNode.ReferenceInformationType;\n\n\t\t\t\tif ( mappingType === 'NoMappingInformation' ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdataSize: 1,\n\t\t\t\t\t\tbuffer: [ 0 ],\n\t\t\t\t\t\tindices: [ 0 ],\n\t\t\t\t\t\tmappingType: 'AllSame',\n\t\t\t\t\t\treferenceType: referenceType\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tvar materialIndexBuffer = MaterialNode.Materials.a;\n\n\t\t\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n\t\t\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\n\t\t\t\t// for conforming with the other functions we've written for other data.\n\t\t\t\tvar materialIndices = [];\n\n\t\t\t\tfor ( var i = 0; i < materialIndexBuffer.length; ++ i ) {\n\n\t\t\t\t\tmaterialIndices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tdataSize: 1,\n\t\t\t\t\tbuffer: materialIndexBuffer,\n\t\t\t\t\tindices: materialIndices,\n\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\treferenceType: referenceType\n\t\t\t\t};\n\n\t\t\t},\n\n\t\t\t// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\t\t\tparseNurbsGeometry: function ( geoNode ) {\n\n\t\t\t\tif ( THREE.NURBSCurve === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.' );\n\t\t\t\t\treturn new THREE.BufferGeometry();\n\n\t\t\t\t}\n\n\t\t\t\tvar order = parseInt( geoNode.Order );\n\n\t\t\t\tif ( isNaN( order ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );\n\t\t\t\t\treturn new THREE.BufferGeometry();\n\n\t\t\t\t}\n\n\t\t\t\tvar degree = order - 1;\n\n\t\t\t\tvar knots = geoNode.KnotVector.a;\n\t\t\t\tvar controlPoints = [];\n\t\t\t\tvar pointsValues = geoNode.Points.a;\n\n\t\t\t\tfor ( var i = 0, l = pointsValues.length; i < l; i += 4 ) {\n\n\t\t\t\t\tcontrolPoints.push( new THREE.Vector4().fromArray( pointsValues, i ) );\n\n\t\t\t\t}\n\n\t\t\t\tvar startKnot, endKnot;\n\n\t\t\t\tif ( geoNode.Form === 'Closed' ) {\n\n\t\t\t\t\tcontrolPoints.push( controlPoints[ 0 ] );\n\n\t\t\t\t} else if ( geoNode.Form === 'Periodic' ) {\n\n\t\t\t\t\tstartKnot = degree;\n\t\t\t\t\tendKnot = knots.length - 1 - startKnot;\n\n\t\t\t\t\tfor ( var i = 0; i < degree; ++ i ) {\n\n\t\t\t\t\t\tcontrolPoints.push( controlPoints[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar curve = new THREE.NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );\n\t\t\t\tvar vertices = curve.getPoints( controlPoints.length * 7 );\n\n\t\t\t\tvar positions = new Float32Array( vertices.length * 3 );\n\n\t\t\t\tvertices.forEach( function ( vertex, i ) {\n\n\t\t\t\t\tvertex.toArray( positions, i * 3 );\n\n\t\t\t\t} );\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\n\t\t\t\treturn geometry;\n\n\t\t\t},\n\n\t\t};\n\n\t\t// parse animation data from FBXTree\n\t\tfunction AnimationParser() {}\n\n\t\tAnimationParser.prototype = {\n\n\t\t\tconstructor: AnimationParser,\n\n\t\t\t// take raw animation clips and turn them into three.js animation clips\n\t\t\tparse: function () {\n\n\t\t\t\tvar animationClips = [];\n\n\t\t\t\tvar rawClips = this.parseClips();\n\n\t\t\t\tif ( rawClips !== undefined ) {\n\n\t\t\t\t\tfor ( var key in rawClips ) {\n\n\t\t\t\t\t\tvar rawClip = rawClips[ key ];\n\n\t\t\t\t\t\tvar clip = this.addClip( rawClip );\n\n\t\t\t\t\t\tanimationClips.push( clip );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn animationClips;\n\n\t\t\t},\n\n\t\t\tparseClips: function () {\n\n\t\t\t\t// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n\t\t\t\t// if this is undefined we can safely assume there are no animations\n\t\t\t\tif ( fbxTree.Objects.AnimationCurve === undefined ) return undefined;\n\n\t\t\t\tvar curveNodesMap = this.parseAnimationCurveNodes();\n\n\t\t\t\tthis.parseAnimationCurves( curveNodesMap );\n\n\t\t\t\tvar layersMap = this.parseAnimationLayers( curveNodesMap );\n\t\t\t\tvar rawClips = this.parseAnimStacks( layersMap );\n\n\t\t\t\treturn rawClips;\n\n\t\t\t},\n\n\t\t\t// parse nodes in FBXTree.Objects.AnimationCurveNode\n\t\t\t// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n\t\t\t// and is referenced by an AnimationLayer\n\t\t\tparseAnimationCurveNodes: function () {\n\n\t\t\t\tvar rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\n\n\t\t\t\tvar curveNodesMap = new Map();\n\n\t\t\t\tfor ( var nodeID in rawCurveNodes ) {\n\n\t\t\t\t\tvar rawCurveNode = rawCurveNodes[ nodeID ];\n\n\t\t\t\t\tif ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) {\n\n\t\t\t\t\t\tvar curveNode = {\n\n\t\t\t\t\t\t\tid: rawCurveNode.id,\n\t\t\t\t\t\t\tattr: rawCurveNode.attrName,\n\t\t\t\t\t\t\tcurves: {},\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tcurveNodesMap.set( curveNode.id, curveNode );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn curveNodesMap;\n\n\t\t\t},\n\n\t\t\t// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n\t\t\t// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n\t\t\t// axis ( e.g. times and values of x rotation)\n\t\t\tparseAnimationCurves: function ( curveNodesMap ) {\n\n\t\t\t\tvar rawCurves = fbxTree.Objects.AnimationCurve;\n\n\t\t\t\t// TODO: Many values are identical up to roundoff error, but won't be optimised\n\t\t\t\t// e.g. position times: [0, 0.4, 0. 8]\n\t\t\t\t// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n\t\t\t\t// clearly, this should be optimised to\n\t\t\t\t// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n\t\t\t\t// this shows up in nearly every FBX file, and generally time array is length > 100\n\n\t\t\t\tfor ( var nodeID in rawCurves ) {\n\n\t\t\t\t\tvar animationCurve = {\n\n\t\t\t\t\t\tid: rawCurves[ nodeID ].id,\n\t\t\t\t\t\ttimes: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),\n\t\t\t\t\t\tvalues: rawCurves[ nodeID ].KeyValueFloat.a,\n\n\t\t\t\t\t};\n\n\t\t\t\t\tvar relationships = connections.get( animationCurve.id );\n\n\t\t\t\t\tif ( relationships !== undefined ) {\n\n\t\t\t\t\t\tvar animationCurveID = relationships.parents[ 0 ].ID;\n\t\t\t\t\t\tvar animationCurveRelationship = relationships.parents[ 0 ].relationship;\n\n\t\t\t\t\t\tif ( animationCurveRelationship.match( /X/ ) ) {\n\n\t\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;\n\n\t\t\t\t\t\t} else if ( animationCurveRelationship.match( /Y/ ) ) {\n\n\t\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;\n\n\t\t\t\t\t\t} else if ( animationCurveRelationship.match( /Z/ ) ) {\n\n\t\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;\n\n\t\t\t\t\t\t} else if ( animationCurveRelationship.match( /d|DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) {\n\n\t\t\t\t\t\t\tcurveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n\t\t\t// to various AnimationCurveNodes and is referenced by an AnimationStack node\n\t\t\t// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\t\t\tparseAnimationLayers: function ( curveNodesMap ) {\n\n\t\t\t\tvar rawLayers = fbxTree.Objects.AnimationLayer;\n\n\t\t\t\tvar layersMap = new Map();\n\n\t\t\t\tfor ( var nodeID in rawLayers ) {\n\n\t\t\t\t\tvar layerCurveNodes = [];\n\n\t\t\t\t\tvar connection = connections.get( parseInt( nodeID ) );\n\n\t\t\t\t\tif ( connection !== undefined ) {\n\n\t\t\t\t\t\t// all the animationCurveNodes used in the layer\n\t\t\t\t\t\tvar children = connection.children;\n\n\t\t\t\t\t\tchildren.forEach( function ( child, i ) {\n\n\t\t\t\t\t\t\tif ( curveNodesMap.has( child.ID ) ) {\n\n\t\t\t\t\t\t\t\tvar curveNode = curveNodesMap.get( child.ID );\n\n\t\t\t\t\t\t\t\t// check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\t\t\t\t\t\t\t\tif ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\t\t\tvar modelID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\t\tif ( modelID !== undefined ) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar rawModel = fbxTree.Objects.Model[ modelID.toString() ];\n\n\t\t\t\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? THREE.PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\t\t\t\tID: rawModel.id,\n\t\t\t\t\t\t\t\t\t\t\t\tinitialPosition: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\t\t\tinitialRotation: [ 0, 0, 0 ],\n\t\t\t\t\t\t\t\t\t\t\t\tinitialScale: [ 1, 1, 1 ],\n\n\t\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\t\tsceneGraph.traverse( function ( child ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( child.ID === rawModel.id ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tnode.transform = child.matrix;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tif ( child.userData.transformData ) node.eulerOrder = child.userData.transformData.eulerOrder;\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( ! node.transform ) node.transform = new THREE.Matrix4();\n\n\t\t\t\t\t\t\t\t\t\t\t// if the animated model is pre rotated, we'll have to apply the pre rotations to every\n\t\t\t\t\t\t\t\t\t\t\t// animation value as well\n\t\t\t\t\t\t\t\t\t\t\tif ( 'PreRotation' in rawModel ) node.preRotation = rawModel.PreRotation.value;\n\t\t\t\t\t\t\t\t\t\t\tif ( 'PostRotation' in rawModel ) node.postRotation = rawModel.PostRotation.value;\n\n\t\t\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] ) layerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t\t\t} else if ( curveNode.curves.morph !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tif ( layerCurveNodes[ i ] === undefined ) {\n\n\t\t\t\t\t\t\t\t\t\tvar deformerID = connections.get( child.ID ).parents.filter( function ( parent ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\n\t\t\t\t\t\t\t\t\t\t} )[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\t\tvar morpherID = connections.get( deformerID ).parents[ 0 ].ID;\n\t\t\t\t\t\t\t\t\t\tvar geoID = connections.get( morpherID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\t\t// assuming geometry is not used in more than one model\n\t\t\t\t\t\t\t\t\t\tvar modelID = connections.get( geoID ).parents[ 0 ].ID;\n\n\t\t\t\t\t\t\t\t\t\tvar rawModel = fbxTree.Objects.Model[ modelID ];\n\n\t\t\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\t\t\tmodelName: rawModel.attrName ? THREE.PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',\n\t\t\t\t\t\t\t\t\t\t\tmorphName: fbxTree.Objects.Deformer[ deformerID ].attrName,\n\n\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ] = node;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tlayerCurveNodes[ i ][ curveNode.attr ] = curveNode;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tlayersMap.set( parseInt( nodeID ), layerCurveNodes );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn layersMap;\n\n\t\t\t},\n\n\t\t\t// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n\t\t\t// hierarchy. Each Stack node will be used to create a THREE.AnimationClip\n\t\t\tparseAnimStacks: function ( layersMap ) {\n\n\t\t\t\tvar rawStacks = fbxTree.Objects.AnimationStack;\n\n\t\t\t\t// connect the stacks (clips) up to the layers\n\t\t\t\tvar rawClips = {};\n\n\t\t\t\tfor ( var nodeID in rawStacks ) {\n\n\t\t\t\t\tvar children = connections.get( parseInt( nodeID ) ).children;\n\n\t\t\t\t\tif ( children.length > 1 ) {\n\n\t\t\t\t\t\t// it seems like stacks will always be associated with a single layer. But just in case there are files\n\t\t\t\t\t\t// where there are multiple layers per stack, we'll display a warning\n\t\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar layer = layersMap.get( children[ 0 ].ID );\n\n\t\t\t\t\trawClips[ nodeID ] = {\n\n\t\t\t\t\t\tname: rawStacks[ nodeID ].attrName,\n\t\t\t\t\t\tlayer: layer,\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\treturn rawClips;\n\n\t\t\t},\n\n\t\t\taddClip: function ( rawClip ) {\n\n\t\t\t\tvar tracks = [];\n\n\t\t\t\tvar self = this;\n\t\t\t\trawClip.layer.forEach( function ( rawTracks ) {\n\n\t\t\t\t\ttracks = tracks.concat( self.generateTracks( rawTracks ) );\n\n\t\t\t\t} );\n\n\t\t\t\treturn new THREE.AnimationClip( rawClip.name, - 1, tracks );\n\n\t\t\t},\n\n\t\t\tgenerateTracks: function ( rawTracks ) {\n\n\t\t\t\tvar tracks = [];\n\n\t\t\t\tvar initialPosition = new THREE.Vector3();\n\t\t\t\tvar initialRotation = new THREE.Quaternion();\n\t\t\t\tvar initialScale = new THREE.Vector3();\n\n\t\t\t\tif ( rawTracks.transform ) rawTracks.transform.decompose( initialPosition, initialRotation, initialScale );\n\n\t\t\t\tinitialPosition = initialPosition.toArray();\n\t\t\t\tinitialRotation = new THREE.Euler().setFromQuaternion( initialRotation, rawTracks.eulerOrder ).toArray();\n\t\t\t\tinitialScale = initialScale.toArray();\n\n\t\t\t\tif ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {\n\n\t\t\t\t\tvar positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' );\n\t\t\t\t\tif ( positionTrack !== undefined ) tracks.push( positionTrack );\n\n\t\t\t\t}\n\n\t\t\t\tif ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {\n\n\t\t\t\t\tvar rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder );\n\t\t\t\t\tif ( rotationTrack !== undefined ) tracks.push( rotationTrack );\n\n\t\t\t\t}\n\n\t\t\t\tif ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {\n\n\t\t\t\t\tvar scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' );\n\t\t\t\t\tif ( scaleTrack !== undefined ) tracks.push( scaleTrack );\n\n\t\t\t\t}\n\n\t\t\t\tif ( rawTracks.DeformPercent !== undefined ) {\n\n\t\t\t\t\tvar morphTrack = this.generateMorphTrack( rawTracks );\n\t\t\t\t\tif ( morphTrack !== undefined ) tracks.push( morphTrack );\n\n\t\t\t\t}\n\n\t\t\t\treturn tracks;\n\n\t\t\t},\n\n\t\t\tgenerateVectorTrack: function ( modelName, curves, initialValue, type ) {\n\n\t\t\t\tvar times = this.getTimesForAllAxes( curves );\n\t\t\t\tvar values = this.getKeyframeTrackValues( times, curves, initialValue );\n\n\t\t\t\treturn new THREE.VectorKeyframeTrack( modelName + '.' + type, times, values );\n\n\t\t\t},\n\n\t\t\tgenerateRotationTrack: function ( modelName, curves, initialValue, preRotation, postRotation, eulerOrder ) {\n\n\t\t\t\tif ( curves.x !== undefined ) {\n\n\t\t\t\t\tthis.interpolateRotations( curves.x );\n\t\t\t\t\tcurves.x.values = curves.x.values.map( THREE.MathUtils.degToRad );\n\n\t\t\t\t}\n\t\t\t\tif ( curves.y !== undefined ) {\n\n\t\t\t\t\tthis.interpolateRotations( curves.y );\n\t\t\t\t\tcurves.y.values = curves.y.values.map( THREE.MathUtils.degToRad );\n\n\t\t\t\t}\n\t\t\t\tif ( curves.z !== undefined ) {\n\n\t\t\t\t\tthis.interpolateRotations( curves.z );\n\t\t\t\t\tcurves.z.values = curves.z.values.map( THREE.MathUtils.degToRad );\n\n\t\t\t\t}\n\n\t\t\t\tvar times = this.getTimesForAllAxes( curves );\n\t\t\t\tvar values = this.getKeyframeTrackValues( times, curves, initialValue );\n\n\t\t\t\tif ( preRotation !== undefined ) {\n\n\t\t\t\t\tpreRotation = preRotation.map( THREE.MathUtils.degToRad );\n\t\t\t\t\tpreRotation.push( eulerOrder );\n\n\t\t\t\t\tpreRotation = new THREE.Euler().fromArray( preRotation );\n\t\t\t\t\tpreRotation = new THREE.Quaternion().setFromEuler( preRotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( postRotation !== undefined ) {\n\n\t\t\t\t\tpostRotation = postRotation.map( THREE.MathUtils.degToRad );\n\t\t\t\t\tpostRotation.push( eulerOrder );\n\n\t\t\t\t\tpostRotation = new THREE.Euler().fromArray( postRotation );\n\t\t\t\t\tpostRotation = new THREE.Quaternion().setFromEuler( postRotation ).inverse();\n\n\t\t\t\t}\n\n\t\t\t\tvar quaternion = new THREE.Quaternion();\n\t\t\t\tvar euler = new THREE.Euler();\n\n\t\t\t\tvar quaternionValues = [];\n\n\t\t\t\tfor ( var i = 0; i < values.length; i += 3 ) {\n\n\t\t\t\t\teuler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], eulerOrder );\n\n\t\t\t\t\tquaternion.setFromEuler( euler );\n\n\t\t\t\t\tif ( preRotation !== undefined ) quaternion.premultiply( preRotation );\n\t\t\t\t\tif ( postRotation !== undefined ) quaternion.multiply( postRotation );\n\n\t\t\t\t\tquaternion.toArray( quaternionValues, ( i / 3 ) * 4 );\n\n\t\t\t\t}\n\n\t\t\t\treturn new THREE.QuaternionKeyframeTrack( modelName + '.quaternion', times, quaternionValues );\n\n\t\t\t},\n\n\t\t\tgenerateMorphTrack: function ( rawTracks ) {\n\n\t\t\t\tvar curves = rawTracks.DeformPercent.curves.morph;\n\t\t\t\tvar values = curves.values.map( function ( val ) {\n\n\t\t\t\t\treturn val / 100;\n\n\t\t\t\t} );\n\n\t\t\t\tvar morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ];\n\n\t\t\t\treturn new THREE.NumberKeyframeTrack( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values );\n\n\t\t\t},\n\n\t\t\t// For all animated objects, times are defined separately for each axis\n\t\t\t// Here we'll combine the times into one sorted array without duplicates\n\t\t\tgetTimesForAllAxes: function ( curves ) {\n\n\t\t\t\tvar times = [];\n\n\t\t\t\t// first join together the times for each axis, if defined\n\t\t\t\tif ( curves.x !== undefined ) times = times.concat( curves.x.times );\n\t\t\t\tif ( curves.y !== undefined ) times = times.concat( curves.y.times );\n\t\t\t\tif ( curves.z !== undefined ) times = times.concat( curves.z.times );\n\n\t\t\t\t// then sort them and remove duplicates\n\t\t\t\ttimes = times.sort( function ( a, b ) {\n\n\t\t\t\t\treturn a - b;\n\n\t\t\t\t} ).filter( function ( elem, index, array ) {\n\n\t\t\t\t\treturn array.indexOf( elem ) == index;\n\n\t\t\t\t} );\n\n\t\t\t\treturn times;\n\n\t\t\t},\n\n\t\t\tgetKeyframeTrackValues: function ( times, curves, initialValue ) {\n\n\t\t\t\tvar prevValue = initialValue;\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tvar xIndex = - 1;\n\t\t\t\tvar yIndex = - 1;\n\t\t\t\tvar zIndex = - 1;\n\n\t\t\t\ttimes.forEach( function ( time ) {\n\n\t\t\t\t\tif ( curves.x ) xIndex = curves.x.times.indexOf( time );\n\t\t\t\t\tif ( curves.y ) yIndex = curves.y.times.indexOf( time );\n\t\t\t\t\tif ( curves.z ) zIndex = curves.z.times.indexOf( time );\n\n\t\t\t\t\t// if there is an x value defined for this frame, use that\n\t\t\t\t\tif ( xIndex !== - 1 ) {\n\n\t\t\t\t\t\tvar xValue = curves.x.values[ xIndex ];\n\t\t\t\t\t\tvalues.push( xValue );\n\t\t\t\t\t\tprevValue[ 0 ] = xValue;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// otherwise use the x value from the previous frame\n\t\t\t\t\t\tvalues.push( prevValue[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( yIndex !== - 1 ) {\n\n\t\t\t\t\t\tvar yValue = curves.y.values[ yIndex ];\n\t\t\t\t\t\tvalues.push( yValue );\n\t\t\t\t\t\tprevValue[ 1 ] = yValue;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvalues.push( prevValue[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( zIndex !== - 1 ) {\n\n\t\t\t\t\t\tvar zValue = curves.z.values[ zIndex ];\n\t\t\t\t\t\tvalues.push( zValue );\n\t\t\t\t\t\tprevValue[ 2 ] = zValue;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvalues.push( prevValue[ 2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn values;\n\n\t\t\t},\n\n\t\t\t// Rotations are defined as Euler angles which can have values  of any size\n\t\t\t// These will be converted to quaternions which don't support values greater than\n\t\t\t// PI, so we'll interpolate large rotations\n\t\t\tinterpolateRotations: function ( curve ) {\n\n\t\t\t\tfor ( var i = 1; i < curve.values.length; i ++ ) {\n\n\t\t\t\t\tvar initialValue = curve.values[ i - 1 ];\n\t\t\t\t\tvar valuesSpan = curve.values[ i ] - initialValue;\n\n\t\t\t\t\tvar absoluteSpan = Math.abs( valuesSpan );\n\n\t\t\t\t\tif ( absoluteSpan >= 180 ) {\n\n\t\t\t\t\t\tvar numSubIntervals = absoluteSpan / 180;\n\n\t\t\t\t\t\tvar step = valuesSpan / numSubIntervals;\n\t\t\t\t\t\tvar nextValue = initialValue + step;\n\n\t\t\t\t\t\tvar initialTime = curve.times[ i - 1 ];\n\t\t\t\t\t\tvar timeSpan = curve.times[ i ] - initialTime;\n\t\t\t\t\t\tvar interval = timeSpan / numSubIntervals;\n\t\t\t\t\t\tvar nextTime = initialTime + interval;\n\n\t\t\t\t\t\tvar interpolatedTimes = [];\n\t\t\t\t\t\tvar interpolatedValues = [];\n\n\t\t\t\t\t\twhile ( nextTime < curve.times[ i ] ) {\n\n\t\t\t\t\t\t\tinterpolatedTimes.push( nextTime );\n\t\t\t\t\t\t\tnextTime += interval;\n\n\t\t\t\t\t\t\tinterpolatedValues.push( nextValue );\n\t\t\t\t\t\t\tnextValue += step;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurve.times = inject( curve.times, i, interpolatedTimes );\n\t\t\t\t\t\tcurve.values = inject( curve.values, i, interpolatedValues );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t};\n\n\t\t// parse an FBX file in ASCII format\n\t\tfunction TextParser() {}\n\n\t\tTextParser.prototype = {\n\n\t\t\tconstructor: TextParser,\n\n\t\t\tgetPrevNode: function () {\n\n\t\t\t\treturn this.nodeStack[ this.currentIndent - 2 ];\n\n\t\t\t},\n\n\t\t\tgetCurrentNode: function () {\n\n\t\t\t\treturn this.nodeStack[ this.currentIndent - 1 ];\n\n\t\t\t},\n\n\t\t\tgetCurrentProp: function () {\n\n\t\t\t\treturn this.currentProp;\n\n\t\t\t},\n\n\t\t\tpushStack: function ( node ) {\n\n\t\t\t\tthis.nodeStack.push( node );\n\t\t\t\tthis.currentIndent += 1;\n\n\t\t\t},\n\n\t\t\tpopStack: function () {\n\n\t\t\t\tthis.nodeStack.pop();\n\t\t\t\tthis.currentIndent -= 1;\n\n\t\t\t},\n\n\t\t\tsetCurrentProp: function ( val, name ) {\n\n\t\t\t\tthis.currentProp = val;\n\t\t\t\tthis.currentPropName = name;\n\n\t\t\t},\n\n\t\t\tparse: function ( text ) {\n\n\t\t\t\tthis.currentIndent = 0;\n\n\t\t\t\tthis.allNodes = new FBXTree();\n\t\t\t\tthis.nodeStack = [];\n\t\t\t\tthis.currentProp = [];\n\t\t\t\tthis.currentPropName = '';\n\n\t\t\t\tvar self = this;\n\n\t\t\t\tvar split = text.split( /[\\r\\n]+/ );\n\n\t\t\t\tsplit.forEach( function ( line, i ) {\n\n\t\t\t\t\tvar matchComment = line.match( /^[\\s\\t]*;/ );\n\t\t\t\t\tvar matchEmpty = line.match( /^[\\s\\t]*$/ );\n\n\t\t\t\t\tif ( matchComment || matchEmpty ) return;\n\n\t\t\t\t\tvar matchBeginning = line.match( '^\\\\t{' + self.currentIndent + '}(\\\\w+):(.*){', '' );\n\t\t\t\t\tvar matchProperty = line.match( '^\\\\t{' + ( self.currentIndent ) + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)' );\n\t\t\t\t\tvar matchEnd = line.match( '^\\\\t{' + ( self.currentIndent - 1 ) + '}}' );\n\n\t\t\t\t\tif ( matchBeginning ) {\n\n\t\t\t\t\t\tself.parseNodeBegin( line, matchBeginning );\n\n\t\t\t\t\t} else if ( matchProperty ) {\n\n\t\t\t\t\t\tself.parseNodeProperty( line, matchProperty, split[ ++ i ] );\n\n\t\t\t\t\t} else if ( matchEnd ) {\n\n\t\t\t\t\t\tself.popStack();\n\n\t\t\t\t\t} else if ( line.match( /^[^\\s\\t}]/ ) ) {\n\n\t\t\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\n\t\t\t\t\t\t// if this is encountered the line needs to be joined to the previous line\n\t\t\t\t\t\tself.parseNodePropertyContinued( line );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn this.allNodes;\n\n\t\t\t},\n\n\t\t\tparseNodeBegin: function ( line, property ) {\n\n\t\t\t\tvar nodeName = property[ 1 ].trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\t\tvar nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {\n\n\t\t\t\t\treturn attr.trim().replace( /^\"/, '' ).replace( /\"$/, '' );\n\n\t\t\t\t} );\n\n\t\t\t\tvar node = { name: nodeName };\n\t\t\t\tvar attrs = this.parseNodeAttr( nodeAttrs );\n\n\t\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\t\t// a top node\n\t\t\t\tif ( this.currentIndent === 0 ) {\n\n\t\t\t\t\tthis.allNodes.add( nodeName, node );\n\n\t\t\t\t} else { // a subnode\n\n\t\t\t\t\t// if the subnode already exists, append it\n\t\t\t\t\tif ( nodeName in currentNode ) {\n\n\t\t\t\t\t\t// special case Pose needs PoseNodes as an array\n\t\t\t\t\t\tif ( nodeName === 'PoseNode' ) {\n\n\t\t\t\t\t\t\tcurrentNode.PoseNode.push( node );\n\n\t\t\t\t\t\t} else if ( currentNode[ nodeName ].id !== undefined ) {\n\n\t\t\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\t\t\tcurrentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t\t} else if ( typeof attrs.id === 'number' ) {\n\n\t\t\t\t\t\tcurrentNode[ nodeName ] = {};\n\t\t\t\t\t\tcurrentNode[ nodeName ][ attrs.id ] = node;\n\n\t\t\t\t\t} else if ( nodeName !== 'Properties70' ) {\n\n\t\t\t\t\t\tif ( nodeName === 'PoseNode' )\tcurrentNode[ nodeName ] = [ node ];\n\t\t\t\t\t\telse currentNode[ nodeName ] = node;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( typeof attrs.id === 'number' ) node.id = attrs.id;\n\t\t\t\tif ( attrs.name !== '' ) node.attrName = attrs.name;\n\t\t\t\tif ( attrs.type !== '' ) node.attrType = attrs.type;\n\n\t\t\t\tthis.pushStack( node );\n\n\t\t\t},\n\n\t\t\tparseNodeAttr: function ( attrs ) {\n\n\t\t\t\tvar id = attrs[ 0 ];\n\n\t\t\t\tif ( attrs[ 0 ] !== '' ) {\n\n\t\t\t\t\tid = parseInt( attrs[ 0 ] );\n\n\t\t\t\t\tif ( isNaN( id ) ) {\n\n\t\t\t\t\t\tid = attrs[ 0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar name = '', type = '';\n\n\t\t\t\tif ( attrs.length > 1 ) {\n\n\t\t\t\t\tname = attrs[ 1 ].replace( /^(\\w+)::/, '' );\n\t\t\t\t\ttype = attrs[ 2 ];\n\n\t\t\t\t}\n\n\t\t\t\treturn { id: id, name: name, type: type };\n\n\t\t\t},\n\n\t\t\tparseNodeProperty: function ( line, property, contentLine ) {\n\n\t\t\t\tvar propName = property[ 1 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\t\t\t\tvar propValue = property[ 2 ].replace( /^\"/, '' ).replace( /\"$/, '' ).trim();\n\n\t\t\t\t// for special case: base64 image data follows \"Content: ,\" line\n\t\t\t\t//\tContent: ,\n\t\t\t\t//\t \"/9j/4RDaRXhpZgAATU0A...\"\n\t\t\t\tif ( propName === 'Content' && propValue === ',' ) {\n\n\t\t\t\t\tpropValue = contentLine.replace( /\"/g, '' ).replace( /,$/, '' ).trim();\n\n\t\t\t\t}\n\n\t\t\t\tvar currentNode = this.getCurrentNode();\n\t\t\t\tvar parentName = currentNode.name;\n\n\t\t\t\tif ( parentName === 'Properties70' ) {\n\n\t\t\t\t\tthis.parseNodeSpecialProperty( line, propName, propValue );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\t// Connections\n\t\t\t\tif ( propName === 'C' ) {\n\n\t\t\t\t\tvar connProps = propValue.split( ',' ).slice( 1 );\n\t\t\t\t\tvar from = parseInt( connProps[ 0 ] );\n\t\t\t\t\tvar to = parseInt( connProps[ 1 ] );\n\n\t\t\t\t\tvar rest = propValue.split( ',' ).slice( 3 );\n\n\t\t\t\t\trest = rest.map( function ( elem ) {\n\n\t\t\t\t\t\treturn elem.trim().replace( /^\"/, '' );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tpropName = 'connections';\n\t\t\t\t\tpropValue = [ from, to ];\n\t\t\t\t\tappend( propValue, rest );\n\n\t\t\t\t\tif ( currentNode[ propName ] === undefined ) {\n\n\t\t\t\t\t\tcurrentNode[ propName ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Node\n\t\t\t\tif ( propName === 'Node' ) currentNode.id = propValue;\n\n\t\t\t\t// connections\n\t\t\t\tif ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {\n\n\t\t\t\t\tcurrentNode[ propName ].push( propValue );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( propName !== 'a' ) currentNode[ propName ] = propValue;\n\t\t\t\t\telse currentNode.a = propValue;\n\n\t\t\t\t}\n\n\t\t\t\tthis.setCurrentProp( currentNode, propName );\n\n\t\t\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\n\t\t\t\tif ( propName === 'a' && propValue.slice( - 1 ) !== ',' ) {\n\n\t\t\t\t\tcurrentNode.a = parseNumberArray( propValue );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tparseNodePropertyContinued: function ( line ) {\n\n\t\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\t\tcurrentNode.a += line;\n\n\t\t\t\t// if the line doesn't end in ',' we have reached the end of the property value\n\t\t\t\t// so convert the string to an array\n\t\t\t\tif ( line.slice( - 1 ) !== ',' ) {\n\n\t\t\t\t\tcurrentNode.a = parseNumberArray( currentNode.a );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t// parse \"Property70\"\n\t\t\tparseNodeSpecialProperty: function ( line, propName, propValue ) {\n\n\t\t\t\t// split this\n\t\t\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n\t\t\t\t// into array like below\n\t\t\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n\t\t\t\tvar props = propValue.split( '\",' ).map( function ( prop ) {\n\n\t\t\t\t\treturn prop.trim().replace( /^\\\"/, '' ).replace( /\\s/, '_' );\n\n\t\t\t\t} );\n\n\t\t\t\tvar innerPropName = props[ 0 ];\n\t\t\t\tvar innerPropType1 = props[ 1 ];\n\t\t\t\tvar innerPropType2 = props[ 2 ];\n\t\t\t\tvar innerPropFlag = props[ 3 ];\n\t\t\t\tvar innerPropValue = props[ 4 ];\n\n\t\t\t\t// cast values where needed, otherwise leave as strings\n\t\t\t\tswitch ( innerPropType1 ) {\n\n\t\t\t\t\tcase 'int':\n\t\t\t\t\tcase 'enum':\n\t\t\t\t\tcase 'bool':\n\t\t\t\t\tcase 'ULongLong':\n\t\t\t\t\tcase 'double':\n\t\t\t\t\tcase 'Number':\n\t\t\t\t\tcase 'FieldOfView':\n\t\t\t\t\t\tinnerPropValue = parseFloat( innerPropValue );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Color':\n\t\t\t\t\tcase 'ColorRGB':\n\t\t\t\t\tcase 'Vector3D':\n\t\t\t\t\tcase 'Lcl_Translation':\n\t\t\t\t\tcase 'Lcl_Rotation':\n\t\t\t\t\tcase 'Lcl_Scaling':\n\t\t\t\t\t\tinnerPropValue = parseNumberArray( innerPropValue );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// CAUTION: these props must append to parent's parent\n\t\t\t\tthis.getPrevNode()[ innerPropName ] = {\n\n\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t'value': innerPropValue\n\n\t\t\t\t};\n\n\t\t\t\tthis.setCurrentProp( this.getPrevNode(), innerPropName );\n\n\t\t\t},\n\n\t\t};\n\n\t\t// Parse an FBX file in Binary format\n\t\tfunction BinaryParser() {}\n\n\t\tBinaryParser.prototype = {\n\n\t\t\tconstructor: BinaryParser,\n\n\t\t\tparse: function ( buffer ) {\n\n\t\t\t\tvar reader = new BinaryReader( buffer );\n\t\t\t\treader.skip( 23 ); // skip magic 23 bytes\n\n\t\t\t\tvar version = reader.getUint32();\n\n\t\t\t\tconsole.log( 'THREE.FBXLoader: FBX binary version: ' + version );\n\n\t\t\t\tvar allNodes = new FBXTree();\n\n\t\t\t\twhile ( ! this.endOfContent( reader ) ) {\n\n\t\t\t\t\tvar node = this.parseNode( reader, version );\n\t\t\t\t\tif ( node !== null ) allNodes.add( node.name, node );\n\n\t\t\t\t}\n\n\t\t\t\treturn allNodes;\n\n\t\t\t},\n\n\t\t\t// Check if reader has reached the end of content.\n\t\t\tendOfContent: function ( reader ) {\n\n\t\t\t\t// footer size: 160bytes + 16-byte alignment padding\n\t\t\t\t// - 16bytes: magic\n\t\t\t\t// - padding til 16-byte alignment (at least 1byte?)\n\t\t\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\n\t\t\t\t// - 4bytes: magic\n\t\t\t\t// - 4bytes: version\n\t\t\t\t// - 120bytes: zero\n\t\t\t\t// - 16bytes: magic\n\t\t\t\tif ( reader.size() % 16 === 0 ) {\n\n\t\t\t\t\treturn ( ( reader.getOffset() + 160 + 16 ) & ~ 0xf ) >= reader.size();\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t// recursively parse nodes until the end of the file is reached\n\t\t\tparseNode: function ( reader, version ) {\n\n\t\t\t\tvar node = {};\n\n\t\t\t\t// The first three data sizes depends on version.\n\t\t\t\tvar endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\t\t\t\tvar numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t\t\t// note: do not remove this even if you get a linter warning as it moves the buffer forward\n\t\t\t\tvar propertyListLen = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();\n\n\t\t\t\tvar nameLen = reader.getUint8();\n\t\t\t\tvar name = reader.getString( nameLen );\n\n\t\t\t\t// Regards this node as NULL-record if endOffset is zero\n\t\t\t\tif ( endOffset === 0 ) return null;\n\n\t\t\t\tvar propertyList = [];\n\n\t\t\t\tfor ( var i = 0; i < numProperties; i ++ ) {\n\n\t\t\t\t\tpropertyList.push( this.parseProperty( reader ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\n\t\t\t\tvar id = propertyList.length > 0 ? propertyList[ 0 ] : '';\n\t\t\t\tvar attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';\n\t\t\t\tvar attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';\n\n\t\t\t\t// check if this node represents just a single property\n\t\t\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\t\t\t\tnode.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;\n\n\t\t\t\twhile ( endOffset > reader.getOffset() ) {\n\n\t\t\t\t\tvar subNode = this.parseNode( reader, version );\n\n\t\t\t\t\tif ( subNode !== null ) this.parseSubNode( name, node, subNode );\n\n\t\t\t\t}\n\n\t\t\t\tnode.propertyList = propertyList; // raw property list used by parent\n\n\t\t\t\tif ( typeof id === 'number' ) node.id = id;\n\t\t\t\tif ( attrName !== '' ) node.attrName = attrName;\n\t\t\t\tif ( attrType !== '' ) node.attrType = attrType;\n\t\t\t\tif ( name !== '' ) node.name = name;\n\n\t\t\t\treturn node;\n\n\t\t\t},\n\n\t\t\tparseSubNode: function ( name, node, subNode ) {\n\n\t\t\t\t// special case: child node is single property\n\t\t\t\tif ( subNode.singleProperty === true ) {\n\n\t\t\t\t\tvar value = subNode.propertyList[ 0 ];\n\n\t\t\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t\t\tsubNode.a = value;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode[ subNode.name ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( name === 'Connections' && subNode.name === 'C' ) {\n\n\t\t\t\t\tvar array = [];\n\n\t\t\t\t\tsubNode.propertyList.forEach( function ( property, i ) {\n\n\t\t\t\t\t\t// first Connection is FBX type (OO, OP, etc.). We'll discard these\n\t\t\t\t\t\tif ( i !== 0 ) array.push( property );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( node.connections === undefined ) {\n\n\t\t\t\t\t\tnode.connections = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnode.connections.push( array );\n\n\t\t\t\t} else if ( subNode.name === 'Properties70' ) {\n\n\t\t\t\t\tvar keys = Object.keys( subNode );\n\n\t\t\t\t\tkeys.forEach( function ( key ) {\n\n\t\t\t\t\t\tnode[ key ] = subNode[ key ];\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else if ( name === 'Properties70' && subNode.name === 'P' ) {\n\n\t\t\t\t\tvar innerPropName = subNode.propertyList[ 0 ];\n\t\t\t\t\tvar innerPropType1 = subNode.propertyList[ 1 ];\n\t\t\t\t\tvar innerPropType2 = subNode.propertyList[ 2 ];\n\t\t\t\t\tvar innerPropFlag = subNode.propertyList[ 3 ];\n\t\t\t\t\tvar innerPropValue;\n\n\t\t\t\t\tif ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );\n\t\t\t\t\tif ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );\n\n\t\t\t\t\tif ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {\n\n\t\t\t\t\t\tinnerPropValue = [\n\t\t\t\t\t\t\tsubNode.propertyList[ 4 ],\n\t\t\t\t\t\t\tsubNode.propertyList[ 5 ],\n\t\t\t\t\t\t\tsubNode.propertyList[ 6 ]\n\t\t\t\t\t\t];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tinnerPropValue = subNode.propertyList[ 4 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// this will be copied to parent, see above\n\t\t\t\t\tnode[ innerPropName ] = {\n\n\t\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t\t'value': innerPropValue\n\n\t\t\t\t\t};\n\n\t\t\t\t} else if ( node[ subNode.name ] === undefined ) {\n\n\t\t\t\t\tif ( typeof subNode.id === 'number' ) {\n\n\t\t\t\t\t\tnode[ subNode.name ] = {};\n\t\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode[ subNode.name ] = subNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( subNode.name === 'PoseNode' ) {\n\n\t\t\t\t\t\tif ( ! Array.isArray( node[ subNode.name ] ) ) {\n\n\t\t\t\t\t\t\tnode[ subNode.name ] = [ node[ subNode.name ] ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnode[ subNode.name ].push( subNode );\n\n\t\t\t\t\t} else if ( node[ subNode.name ][ subNode.id ] === undefined ) {\n\n\t\t\t\t\t\tnode[ subNode.name ][ subNode.id ] = subNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tparseProperty: function ( reader ) {\n\n\t\t\t\tvar type = reader.getString( 1 );\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\treturn reader.getBoolean();\n\n\t\t\t\t\tcase 'D':\n\t\t\t\t\t\treturn reader.getFloat64();\n\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\treturn reader.getFloat32();\n\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\treturn reader.getInt32();\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\treturn reader.getInt64();\n\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\t\treturn reader.getArrayBuffer( length );\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\t\treturn reader.getString( length );\n\n\t\t\t\t\tcase 'Y':\n\t\t\t\t\t\treturn reader.getInt16();\n\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'c':\n\t\t\t\t\tcase 'd':\n\t\t\t\t\tcase 'f':\n\t\t\t\t\tcase 'i':\n\t\t\t\t\tcase 'l':\n\n\t\t\t\t\t\tvar arrayLength = reader.getUint32();\n\t\t\t\t\t\tvar encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\t\t\t\t\t\tvar compressedLength = reader.getUint32();\n\n\t\t\t\t\t\tif ( encoding === 0 ) {\n\n\t\t\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\t\treturn reader.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\t\treturn reader.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\t\treturn reader.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\t\treturn reader.getInt32Array( arrayLength );\n\n\t\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\t\treturn reader.getInt64Array( arrayLength );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( typeof Zlib === 'undefined' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar inflate = new Zlib.Inflate( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) ); // eslint-disable-line no-undef\n\t\t\t\t\t\tvar reader2 = new BinaryReader( inflate.decompress().buffer );\n\n\t\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\treturn reader2.getBooleanArray( arrayLength );\n\n\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\treturn reader2.getFloat64Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\treturn reader2.getFloat32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\treturn reader2.getInt32Array( arrayLength );\n\n\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\treturn reader2.getInt64Array( arrayLength );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'THREE.FBXLoader: Unknown property type ' + type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction BinaryReader( buffer, littleEndian ) {\n\n\t\t\tthis.dv = new DataView( buffer );\n\t\t\tthis.offset = 0;\n\t\t\tthis.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;\n\n\t\t}\n\n\t\tBinaryReader.prototype = {\n\n\t\t\tconstructor: BinaryReader,\n\n\t\t\tgetOffset: function () {\n\n\t\t\t\treturn this.offset;\n\n\t\t\t},\n\n\t\t\tsize: function () {\n\n\t\t\t\treturn this.dv.buffer.byteLength;\n\n\t\t\t},\n\n\t\t\tskip: function ( length ) {\n\n\t\t\t\tthis.offset += length;\n\n\t\t\t},\n\n\t\t\t// seems like true/false representation depends on exporter.\n\t\t\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n\t\t\t// then sees LSB.\n\t\t\tgetBoolean: function () {\n\n\t\t\t\treturn ( this.getUint8() & 1 ) === 1;\n\n\t\t\t},\n\n\t\t\tgetBooleanArray: function ( size ) {\n\n\t\t\t\tvar a = [];\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\t\ta.push( this.getBoolean() );\n\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\n\t\t\t},\n\n\t\t\tgetUint8: function () {\n\n\t\t\t\tvar value = this.dv.getUint8( this.offset );\n\t\t\t\tthis.offset += 1;\n\t\t\t\treturn value;\n\n\t\t\t},\n\n\t\t\tgetInt16: function () {\n\n\t\t\t\tvar value = this.dv.getInt16( this.offset, this.littleEndian );\n\t\t\t\tthis.offset += 2;\n\t\t\t\treturn value;\n\n\t\t\t},\n\n\t\t\tgetInt32: function () {\n\n\t\t\t\tvar value = this.dv.getInt32( this.offset, this.littleEndian );\n\t\t\t\tthis.offset += 4;\n\t\t\t\treturn value;\n\n\t\t\t},\n\n\t\t\tgetInt32Array: function ( size ) {\n\n\t\t\t\tvar a = [];\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\t\ta.push( this.getInt32() );\n\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\n\t\t\t},\n\n\t\t\tgetUint32: function () {\n\n\t\t\t\tvar value = this.dv.getUint32( this.offset, this.littleEndian );\n\t\t\t\tthis.offset += 4;\n\t\t\t\treturn value;\n\n\t\t\t},\n\n\t\t\t// JavaScript doesn't support 64-bit integer so calculate this here\n\t\t\t// 1 << 32 will return 1 so using multiply operation instead here.\n\t\t\t// There's a possibility that this method returns wrong value if the value\n\t\t\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n\t\t\t// TODO: safely handle 64-bit integer\n\t\t\tgetInt64: function () {\n\n\t\t\t\tvar low, high;\n\n\t\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\t\tlow = this.getUint32();\n\t\t\t\t\thigh = this.getUint32();\n\n\t\t\t\t} else {\n\n\t\t\t\t\thigh = this.getUint32();\n\t\t\t\t\tlow = this.getUint32();\n\n\t\t\t\t}\n\n\t\t\t\t// calculate negative value\n\t\t\t\tif ( high & 0x80000000 ) {\n\n\t\t\t\t\thigh = ~ high & 0xFFFFFFFF;\n\t\t\t\t\tlow = ~ low & 0xFFFFFFFF;\n\n\t\t\t\t\tif ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\t\tlow = ( low + 1 ) & 0xFFFFFFFF;\n\n\t\t\t\t\treturn - ( high * 0x100000000 + low );\n\n\t\t\t\t}\n\n\t\t\t\treturn high * 0x100000000 + low;\n\n\t\t\t},\n\n\t\t\tgetInt64Array: function ( size ) {\n\n\t\t\t\tvar a = [];\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\t\ta.push( this.getInt64() );\n\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\n\t\t\t},\n\n\t\t\t// Note: see getInt64() comment\n\t\t\tgetUint64: function () {\n\n\t\t\t\tvar low, high;\n\n\t\t\t\tif ( this.littleEndian ) {\n\n\t\t\t\t\tlow = this.getUint32();\n\t\t\t\t\thigh = this.getUint32();\n\n\t\t\t\t} else {\n\n\t\t\t\t\thigh = this.getUint32();\n\t\t\t\t\tlow = this.getUint32();\n\n\t\t\t\t}\n\n\t\t\t\treturn high * 0x100000000 + low;\n\n\t\t\t},\n\n\t\t\tgetFloat32: function () {\n\n\t\t\t\tvar value = this.dv.getFloat32( this.offset, this.littleEndian );\n\t\t\t\tthis.offset += 4;\n\t\t\t\treturn value;\n\n\t\t\t},\n\n\t\t\tgetFloat32Array: function ( size ) {\n\n\t\t\t\tvar a = [];\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\t\ta.push( this.getFloat32() );\n\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\n\t\t\t},\n\n\t\t\tgetFloat64: function () {\n\n\t\t\t\tvar value = this.dv.getFloat64( this.offset, this.littleEndian );\n\t\t\t\tthis.offset += 8;\n\t\t\t\treturn value;\n\n\t\t\t},\n\n\t\t\tgetFloat64Array: function ( size ) {\n\n\t\t\t\tvar a = [];\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\t\ta.push( this.getFloat64() );\n\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\n\t\t\t},\n\n\t\t\tgetArrayBuffer: function ( size ) {\n\n\t\t\t\tvar value = this.dv.buffer.slice( this.offset, this.offset + size );\n\t\t\t\tthis.offset += size;\n\t\t\t\treturn value;\n\n\t\t\t},\n\n\t\t\tgetString: function ( size ) {\n\n\t\t\t\t// note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n\t\t\t\tvar a = [];\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\t\ta[ i ] = this.getUint8();\n\n\t\t\t\t}\n\n\t\t\t\tvar nullByte = a.indexOf( 0 );\n\t\t\t\tif ( nullByte >= 0 ) a = a.slice( 0, nullByte );\n\n\t\t\t\treturn THREE.LoaderUtils.decodeText( new Uint8Array( a ) );\n\n\t\t\t}\n\n\t\t};\n\n\t\t// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n\t\t// and BinaryParser( FBX Binary format)\n\t\tfunction FBXTree() {}\n\n\t\tFBXTree.prototype = {\n\n\t\t\tconstructor: FBXTree,\n\n\t\t\tadd: function ( key, val ) {\n\n\t\t\t\tthis[ key ] = val;\n\n\t\t\t},\n\n\t\t};\n\n\t\t// ************** UTILITY FUNCTIONS **************\n\n\t\tfunction isFbxFormatBinary( buffer ) {\n\n\t\t\tvar CORRECT = 'Kaydara FBX Binary  \\0';\n\n\t\t\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length );\n\n\t\t}\n\n\t\tfunction isFbxFormatASCII( text ) {\n\n\t\t\tvar CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\' ];\n\n\t\t\tvar cursor = 0;\n\n\t\t\tfunction read( offset ) {\n\n\t\t\t\tvar result = text[ offset - 1 ];\n\t\t\t\ttext = text.slice( cursor + offset );\n\t\t\t\tcursor ++;\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < CORRECT.length; ++ i ) {\n\n\t\t\t\tvar num = read( 1 );\n\t\t\t\tif ( num === CORRECT[ i ] ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction getFbxVersion( text ) {\n\n\t\t\tvar versionRegExp = /FBXVersion: (\\d+)/;\n\t\t\tvar match = text.match( versionRegExp );\n\t\t\tif ( match ) {\n\n\t\t\t\tvar version = parseInt( match[ 1 ] );\n\t\t\t\treturn version;\n\n\t\t\t}\n\t\t\tthrow new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' );\n\n\t\t}\n\n\t\t// Converts FBX ticks into real time seconds.\n\t\tfunction convertFBXTimeToSeconds( time ) {\n\n\t\t\treturn time / 46186158000;\n\n\t\t}\n\n\t\tvar dataArray = [];\n\n\t\t// extracts the data from the correct position in the FBX array based on indexing type\n\t\tfunction getData( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {\n\n\t\t\tvar index;\n\n\t\t\tswitch ( infoObject.mappingType ) {\n\n\t\t\t\tcase 'ByPolygonVertex' :\n\t\t\t\t\tindex = polygonVertexIndex;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ByPolygon' :\n\t\t\t\t\tindex = polygonIndex;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ByVertice' :\n\t\t\t\t\tindex = vertexIndex;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'AllSame' :\n\t\t\t\t\tindex = infoObject.indices[ 0 ];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault :\n\t\t\t\t\tconsole.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );\n\n\t\t\t}\n\n\t\t\tif ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];\n\n\t\t\tvar from = index * infoObject.dataSize;\n\t\t\tvar to = from + infoObject.dataSize;\n\n\t\t\treturn slice( dataArray, infoObject.buffer, from, to );\n\n\t\t}\n\n\t\tvar tempEuler = new THREE.Euler();\n\t\tvar tempVec = new THREE.Vector3();\n\n\t\t// generate transformation from FBX transform data\n\t\t// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n\t\t// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\n\t\tfunction generateTransform( transformData ) {\n\n\t\t\tvar lTranslationM = new THREE.Matrix4();\n\t\t\tvar lPreRotationM = new THREE.Matrix4();\n\t\t\tvar lRotationM = new THREE.Matrix4();\n\t\t\tvar lPostRotationM = new THREE.Matrix4();\n\n\t\t\tvar lScalingM = new THREE.Matrix4();\n\t\t\tvar lScalingPivotM = new THREE.Matrix4();\n\t\t\tvar lScalingOffsetM = new THREE.Matrix4();\n\t\t\tvar lRotationOffsetM = new THREE.Matrix4();\n\t\t\tvar lRotationPivotM = new THREE.Matrix4();\n\n\t\t\tvar lParentGX = new THREE.Matrix4();\n\t\t\tvar lGlobalT = new THREE.Matrix4();\n\n\t\t\tvar inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0;\n\n\t\t\tif ( transformData.translation ) lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) );\n\n\t\t\tif ( transformData.preRotation ) {\n\n\t\t\t\tvar array = transformData.preRotation.map( THREE.MathUtils.degToRad );\n\t\t\t\tarray.push( transformData.eulerOrder );\n\t\t\t\tlPreRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t\t\t}\n\n\t\t\tif ( transformData.rotation ) {\n\n\t\t\t\tvar array = transformData.rotation.map( THREE.MathUtils.degToRad );\n\t\t\t\tarray.push( transformData.eulerOrder );\n\t\t\t\tlRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t\t\t}\n\n\t\t\tif ( transformData.postRotation ) {\n\n\t\t\t\tvar array = transformData.postRotation.map( THREE.MathUtils.degToRad );\n\t\t\t\tarray.push( transformData.eulerOrder );\n\t\t\t\tlPostRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );\n\n\t\t\t}\n\n\t\t\tif ( transformData.scale ) lScalingM.scale( tempVec.fromArray( transformData.scale ) );\n\n\t\t\t// Pivots and offsets\n\t\t\tif ( transformData.scalingOffset ) lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) );\n\t\t\tif ( transformData.scalingPivot ) lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) );\n\t\t\tif ( transformData.rotationOffset ) lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) );\n\t\t\tif ( transformData.rotationPivot ) lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) );\n\n\t\t\t// parent transform\n\t\t\tif ( transformData.parentMatrixWorld ) lParentGX = transformData.parentMatrixWorld;\n\n\t\t\t// Global Rotation\n\t\t\tvar lLRM = lPreRotationM.multiply( lRotationM ).multiply( lPostRotationM );\n\t\t\tvar lParentGRM = new THREE.Matrix4();\n\t\t\tlParentGX.extractRotation( lParentGRM );\n\n\t\t\t// Global Shear*Scaling\n\t\t\tvar lParentTM = new THREE.Matrix4();\n\t\t\tvar lLSM;\n\t\t\tvar lParentGSM;\n\t\t\tvar lParentGRSM;\n\n\t\t\tlParentTM.copyPosition( lParentGX );\n\t\t\tlParentGRSM = lParentTM.getInverse( lParentTM ).multiply( lParentGX );\n\t\t\tlParentGSM = lParentGRM.getInverse( lParentGRM ).multiply( lParentGRSM );\n\t\t\tlLSM = lScalingM;\n\n\t\t\tvar lGlobalRS;\n\t\t\tif ( inheritType === 0 ) {\n\n\t\t\t\tlGlobalRS = lParentGRM.multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM );\n\n\t\t\t} else if ( inheritType === 1 ) {\n\n\t\t\t\tlGlobalRS = lParentGRM.multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM );\n\n\t\t\t} else {\n\n\t\t\t\tvar lParentLSM = new THREE.Matrix4().copy( lScalingM );\n\n\t\t\t\tvar lParentGSM_noLocal = lParentGSM.multiply( lParentLSM.getInverse( lParentLSM ) );\n\n\t\t\t\tlGlobalRS = lParentGRM.multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM );\n\n\t\t\t}\n\n\t\t\t// Calculate the local transform matrix\n\t\t\tvar lTransform = lTranslationM.multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM.getInverse( lRotationPivotM ) ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM.getInverse( lScalingPivotM ) );\n\n\t\t\tvar lLocalTWithAllPivotAndOffsetInfo = new THREE.Matrix4().copyPosition( lTransform );\n\n\t\t\tvar lGlobalTranslation = lParentGX.multiply( lLocalTWithAllPivotAndOffsetInfo );\n\t\t\tlGlobalT.copyPosition( lGlobalTranslation );\n\n\t\t\tlTransform = lGlobalT.multiply( lGlobalRS );\n\n\t\t\treturn lTransform;\n\n\t\t}\n\n\t\t// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n\t\t// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n\t\tfunction getEulerOrder( order ) {\n\n\t\t\torder = order || 0;\n\n\t\t\tvar enums = [\n\t\t\t\t'ZYX', // -> XYZ extrinsic\n\t\t\t\t'YZX', // -> XZY extrinsic\n\t\t\t\t'XZY', // -> YZX extrinsic\n\t\t\t\t'ZXY', // -> YXZ extrinsic\n\t\t\t\t'YXZ', // -> ZXY extrinsic\n\t\t\t\t'XYZ', // -> ZYX extrinsic\n\t\t\t\t//'SphericXYZ', // not possible to support\n\t\t\t];\n\n\t\t\tif ( order === 6 ) {\n\n\t\t\t\tconsole.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );\n\t\t\t\treturn enums[ 0 ];\n\n\t\t\t}\n\n\t\t\treturn enums[ order ];\n\n\t\t}\n\n\t\t// Parses comma separated list of numbers and returns them an array.\n\t\t// Used internally by the TextParser\n\t\tfunction parseNumberArray( value ) {\n\n\t\t\tvar array = value.split( ',' ).map( function ( val ) {\n\n\t\t\t\treturn parseFloat( val );\n\n\t\t\t} );\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction convertArrayBufferToString( buffer, from, to ) {\n\n\t\t\tif ( from === undefined ) from = 0;\n\t\t\tif ( to === undefined ) to = buffer.byteLength;\n\n\t\t\treturn THREE.LoaderUtils.decodeText( new Uint8Array( buffer, from, to ) );\n\n\t\t}\n\n\t\tfunction append( a, b ) {\n\n\t\t\tfor ( var i = 0, j = a.length, l = b.length; i < l; i ++, j ++ ) {\n\n\t\t\t\ta[ j ] = b[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction slice( a, b, from, to ) {\n\n\t\t\tfor ( var i = from, j = 0; i < to; i ++, j ++ ) {\n\n\t\t\t\ta[ j ] = b[ i ];\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t}\n\n\t\t// inject array a2 into array a1 at index\n\t\tfunction inject( a1, index, a2 ) {\n\n\t\t\treturn a1.slice( 0, index ).concat( a2 ).concat( a1.slice( index ) );\n\n\t\t}\n\n\t\treturn FBXLoader;\n\n\t} )();\n\t\n\treturn THREE.FBXLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/GCodeLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * THREE.GCodeLoader is used to load gcode files usually used for 3D printing or CNC applications.\n\t *\n\t * Gcode files are composed by commands used by machines to create objects.\n\t *\n\t * @class THREE.GCodeLoader\n\t * @param {Manager} manager Loading manager.\n\t * @author tentone\n\t * @author joewalnes\n\t */\n\n\tTHREE.GCodeLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.splitLayer = false;\n\n\t};\n\n\tTHREE.GCodeLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.GCodeLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar self = this;\n\n\t\t\tvar loader = new THREE.FileLoader( self.manager );\n\t\t\tloader.setPath( self.path );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( self.parse( text ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data ) {\n\n\t\t\tvar state = { x: 0, y: 0, z: 0, e: 0, f: 0, extruding: false, relative: false };\n\t\t\tvar layers = [];\n\n\t\t\tvar currentLayer = undefined;\n\n\t\t\tvar pathMaterial = new THREE.LineBasicMaterial( { color: 0xFF0000 } );\n\t\t\tpathMaterial.name = 'path';\n\n\t\t\tvar extrudingMaterial = new THREE.LineBasicMaterial( { color: 0x00FF00 } );\n\t\t\textrudingMaterial.name = 'extruded';\n\n\t\t\tfunction newLayer( line ) {\n\n\t\t\t\tcurrentLayer = { vertex: [], pathVertex: [], z: line.z };\n\t\t\t\tlayers.push( currentLayer );\n\n\t\t\t}\n\n\t\t\t//Create lie segment between p1 and p2\n\t\t\tfunction addSegment( p1, p2 ) {\n\n\t\t\t\tif ( currentLayer === undefined ) {\n\n\t\t\t\t\tnewLayer( p1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( line.extruding ) {\n\n\t\t\t\t\tcurrentLayer.vertex.push( p1.x, p1.y, p1.z );\n\t\t\t\t\tcurrentLayer.vertex.push( p2.x, p2.y, p2.z );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentLayer.pathVertex.push( p1.x, p1.y, p1.z );\n\t\t\t\t\tcurrentLayer.pathVertex.push( p2.x, p2.y, p2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction delta( v1, v2 ) {\n\n\t\t\t\treturn state.relative ? v2 : v2 - v1;\n\n\t\t\t}\n\n\t\t\tfunction absolute( v1, v2 ) {\n\n\t\t\t\treturn state.relative ? v1 + v2 : v2;\n\n\t\t\t}\n\n\t\t\tvar lines = data.replace( /;.+/g, '' ).split( '\\n' );\n\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tvar tokens = lines[ i ].split( ' ' );\n\t\t\t\tvar cmd = tokens[ 0 ].toUpperCase();\n\n\t\t\t\t//Argumments\n\t\t\t\tvar args = {};\n\t\t\t\ttokens.splice( 1 ).forEach( function ( token ) {\n\n\t\t\t\t\tif ( token[ 0 ] !== undefined ) {\n\n\t\t\t\t\t\tvar key = token[ 0 ].toLowerCase();\n\t\t\t\t\t\tvar value = parseFloat( token.substring( 1 ) );\n\t\t\t\t\t\targs[ key ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\t//Process commands\n\t\t\t\t//G0/G1 – Linear Movement\n\t\t\t\tif ( cmd === 'G0' || cmd === 'G1' ) {\n\n\t\t\t\t\tvar line = {\n\t\t\t\t\t\tx: args.x !== undefined ? absolute( state.x, args.x ) : state.x,\n\t\t\t\t\t\ty: args.y !== undefined ? absolute( state.y, args.y ) : state.y,\n\t\t\t\t\t\tz: args.z !== undefined ? absolute( state.z, args.z ) : state.z,\n\t\t\t\t\t\te: args.e !== undefined ? absolute( state.e, args.e ) : state.e,\n\t\t\t\t\t\tf: args.f !== undefined ? absolute( state.f, args.f ) : state.f,\n\t\t\t\t\t};\n\n\t\t\t\t\t//Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position\n\t\t\t\t\tif ( delta( state.e, line.e ) > 0 ) {\n\n\t\t\t\t\t\tline.extruding = delta( state.e, line.e ) > 0;\n\n\t\t\t\t\t\tif ( currentLayer == undefined || line.z != currentLayer.z ) {\n\n\t\t\t\t\t\t\tnewLayer( line );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\taddSegment( state, line );\n\t\t\t\t\tstate = line;\n\n\t\t\t\t} else if ( cmd === 'G2' || cmd === 'G3' ) {\n\n\t\t\t\t\t//G2/G3 - Arc Movement ( G2 clock wise and G3 counter clock wise )\n\t\t\t\t\t//console.warn( 'THREE.GCodeLoader: Arc command not supported' );\n\n\t\t\t\t} else if ( cmd === 'G90' ) {\n\n\t\t\t\t\t//G90: Set to Absolute Positioning\n\t\t\t\t\tstate.relative = false;\n\n\t\t\t\t} else if ( cmd === 'G91' ) {\n\n\t\t\t\t\t//G91: Set to state.relative Positioning\n\t\t\t\t\tstate.relative = true;\n\n\t\t\t\t} else if ( cmd === 'G92' ) {\n\n\t\t\t\t\t//G92: Set Position\n\t\t\t\t\tvar line = state;\n\t\t\t\t\tline.x = args.x !== undefined ? args.x : line.x;\n\t\t\t\t\tline.y = args.y !== undefined ? args.y : line.y;\n\t\t\t\t\tline.z = args.z !== undefined ? args.z : line.z;\n\t\t\t\t\tline.e = args.e !== undefined ? args.e : line.e;\n\t\t\t\t\tstate = line;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t//console.warn( 'THREE.GCodeLoader: Command not supported:' + cmd );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction addObject( vertex, extruding ) {\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertex, 3 ) );\n\n\t\t\t\tvar segments = new THREE.LineSegments( geometry, extruding ? extrudingMaterial : pathMaterial );\n\t\t\t\tsegments.name = 'layer' + i;\n\t\t\t\tobject.add( segments );\n\n\t\t\t}\n\n\t\t\tvar object = new THREE.Group();\n\t\t\tobject.name = 'gcode';\n\n\t\t\tif ( this.splitLayer ) {\n\n\t\t\t\tfor ( var i = 0; i < layers.length; i ++ ) {\n\n\t\t\t\t\tvar layer = layers[ i ];\n\t\t\t\t\taddObject( layer.vertex, true );\n\t\t\t\t\taddObject( layer.pathVertex, false );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar vertex = [], pathVertex = [];\n\n\t\t\t\tfor ( var i = 0; i < layers.length; i ++ ) {\n\n\t\t\t\t\tvar layer = layers[ i ];\n\n\t\t\t\t\tvertex = vertex.concat( layer.vertex );\n\t\t\t\t\tpathVertex = pathVertex.concat( layer.pathVertex );\n\n\t\t\t\t}\n\n\t\t\t\taddObject( vertex, true );\n\t\t\t\taddObject( pathVertex, false );\n\n\t\t\t}\n\n\t\t\tobject.quaternion.setFromEuler( new THREE.Euler( - Math.PI / 2, 0, 0 ) );\n\n\t\t\treturn object;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.GCodeLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/GLTFLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Rich Tibbett / https://github.com/richtr\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Tony Parisi / http://www.tonyparisi.com/\n\t * @author Takahiro / https://github.com/takahirox\n\t * @author Don McCurdy / https://www.donmccurdy.com\n\t */\n\n\tTHREE.GLTFLoader = ( function () {\n\n\t\tfunction GLTFLoader( manager ) {\n\n\t\t\tTHREE.Loader.call( this, manager );\n\n\t\t\tthis.dracoLoader = null;\n\t\t\tthis.ddsLoader = null;\n\n\t\t}\n\n\t\tGLTFLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\t\tconstructor: GLTFLoader,\n\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tvar resourcePath;\n\n\t\t\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\t\t\tresourcePath = this.resourcePath;\n\n\t\t\t\t} else if ( this.path !== '' ) {\n\n\t\t\t\t\tresourcePath = this.path;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresourcePath = THREE.LoaderUtils.extractUrlBase( url );\n\n\t\t\t\t}\n\n\t\t\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\t\t\tscope.manager.itemStart( url );\n\n\t\t\t\tvar _onError = function ( e ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError( url );\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t};\n\n\t\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\t\tif ( scope.crossOrigin === 'use-credentials' ) {\n\n\t\t\t\t\tloader.setWithCredentials( true );\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( url, function ( data ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t\t\t}, _onError );\n\n\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t_onError( e );\n\n\t\t\t\t\t}\n\n\t\t\t\t}, onProgress, _onError );\n\n\t\t\t},\n\n\t\t\tsetDRACOLoader: function ( dracoLoader ) {\n\n\t\t\t\tthis.dracoLoader = dracoLoader;\n\t\t\t\treturn this;\n\n\t\t\t},\n\n\t\t\tsetDDSLoader: function ( ddsLoader ) {\n\n\t\t\t\tthis.ddsLoader = ddsLoader;\n\t\t\t\treturn this;\n\n\t\t\t},\n\n\t\t\tparse: function ( data, path, onLoad, onError ) {\n\n\t\t\t\tvar content;\n\t\t\t\tvar extensions = {};\n\n\t\t\t\tif ( typeof data === 'string' ) {\n\n\t\t\t\t\tcontent = data;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar magic = THREE.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );\n\n\t\t\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcontent = THREE.LoaderUtils.decodeText( new Uint8Array( data ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar json = JSON.parse( content );\n\n\t\t\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.extensionsUsed ) {\n\n\t\t\t\t\tfor ( var i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\t\t\tvar extensionName = json.extensionsUsed[ i ];\n\t\t\t\t\t\tvar extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\t\t\tcase EXTENSIONS.KHR_LIGHTS_PUNCTUAL:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFLightsExtension( json );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_CLEARCOAT:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsClearcoatExtension();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EXTENSIONS.MSFT_TEXTURE_DDS:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureDDSExtension( this.ddsLoader );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 ) {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar parser = new GLTFParser( json, extensions, {\n\n\t\t\t\t\tpath: path || this.resourcePath || '',\n\t\t\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\t\t\tmanager: this.manager\n\n\t\t\t\t} );\n\n\t\t\t\tparser.parse( onLoad, onError );\n\n\t\t\t}\n\n\t\t} );\n\n\t\t/* GLTFREGISTRY */\n\n\t\tfunction GLTFRegistry() {\n\n\t\t\tvar objects = {};\n\n\t\t\treturn\t{\n\n\t\t\t\tget: function ( key ) {\n\n\t\t\t\t\treturn objects[ key ];\n\n\t\t\t\t},\n\n\t\t\t\tadd: function ( key, object ) {\n\n\t\t\t\t\tobjects[ key ] = object;\n\n\t\t\t\t},\n\n\t\t\t\tremove: function ( key ) {\n\n\t\t\t\t\tdelete objects[ key ];\n\n\t\t\t\t},\n\n\t\t\t\tremoveAll: function () {\n\n\t\t\t\t\tobjects = {};\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\t/*********************************/\n\t\t/********** EXTENSIONS ***********/\n\t\t/*********************************/\n\n\t\tvar EXTENSIONS = {\n\t\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\t\t\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\t\t\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\t\t\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\t\t\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n\t\t\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\t\t\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\t\t\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\t\t\tMSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n\t\t};\n\n\t\t/**\n\t\t * DDS Texture Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\n\t\t *\n\t\t */\n\t\tfunction GLTFTextureDDSExtension( ddsLoader ) {\n\n\t\t\tif ( ! ddsLoader ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader' );\n\n\t\t\t}\n\n\t\t\tthis.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n\t\t\tthis.ddsLoader = ddsLoader;\n\n\t\t}\n\n\t\t/**\n\t\t * Punctual Lights Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\t\t */\n\t\tfunction GLTFLightsExtension( json ) {\n\n\t\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t\tvar extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ] ) || {};\n\t\t\tthis.lightDefs = extension.lights || [];\n\n\t\t}\n\n\t\tGLTFLightsExtension.prototype.loadLight = function ( lightIndex ) {\n\n\t\t\tvar lightDef = this.lightDefs[ lightIndex ];\n\t\t\tvar lightNode;\n\n\t\t\tvar color = new THREE.Color( 0xffffff );\n\t\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\n\n\t\t\tvar range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\t\tswitch ( lightDef.type ) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlightNode = new THREE.DirectionalLight( color );\n\t\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlightNode = new THREE.PointLight( color );\n\t\t\t\t\tlightNode.distance = range;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlightNode = new THREE.SpotLight( color );\n\t\t\t\t\tlightNode.distance = range;\n\t\t\t\t\t// Handle spotlight properties.\n\t\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".' );\n\n\t\t\t}\n\n\t\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\t\tlightNode.decay = 2;\n\n\t\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\t\tlightNode.name = lightDef.name || ( 'light_' + lightIndex );\n\n\t\t\treturn Promise.resolve( lightNode );\n\n\t\t};\n\n\t\t/**\n\t\t * Unlit Materials Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n\t\t */\n\t\tfunction GLTFMaterialsUnlitExtension() {\n\n\t\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t\t}\n\n\t\tGLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {\n\n\t\t\treturn THREE.MeshBasicMaterial;\n\n\t\t};\n\n\t\tGLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, materialDef, parser ) {\n\n\t\t\tvar pending = [];\n\n\t\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\t\tif ( metallicRoughness ) {\n\n\t\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pending );\n\n\t\t};\n\n\t\t/**\n\t\t * Clearcoat Materials Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n\t\t */\n\t\tfunction GLTFMaterialsClearcoatExtension() {\n\n\t\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t\t}\n\n\t\tGLTFMaterialsClearcoatExtension.prototype.getMaterialType = function () {\n\n\t\t\treturn THREE.MeshPhysicalMaterial;\n\n\t\t};\n\n\t\tGLTFMaterialsClearcoatExtension.prototype.extendParams = function ( materialParams, materialDef, parser ) {\n\n\t\t\tvar pending = [];\n\n\t\t\tvar extension = materialDef.extensions[ this.name ];\n\n\t\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t\t}\n\n\t\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t\t}\n\n\t\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t\t}\n\n\t\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\t\tvar scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\t\tmaterialParams.clearcoatNormalScale = new THREE.Vector2( scale, scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pending );\n\n\t\t};\n\n\t\t/* BINARY EXTENSION */\n\t\tvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n\t\tvar BINARY_EXTENSION_HEADER_LENGTH = 12;\n\t\tvar BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\n\t\tfunction GLTFBinaryExtension( data ) {\n\n\t\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\t\tthis.content = null;\n\t\t\tthis.body = null;\n\n\t\t\tvar headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\n\t\t\tthis.header = {\n\t\t\t\tmagic: THREE.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\t\tlength: headerView.getUint32( 8, true )\n\t\t\t};\n\n\t\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t\t}\n\n\t\t\tvar chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\t\tvar chunkIndex = 0;\n\n\t\t\twhile ( chunkIndex < chunkView.byteLength ) {\n\n\t\t\t\tvar chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\t\tchunkIndex += 4;\n\n\t\t\t\tvar chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\t\tchunkIndex += 4;\n\n\t\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\t\tvar contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\t\tthis.content = THREE.LoaderUtils.decodeText( contentArray );\n\n\t\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\t\tvar byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t\t}\n\n\t\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\t\tchunkIndex += chunkLength;\n\n\t\t\t}\n\n\t\t\tif ( this.content === null ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * DRACO Mesh Compression Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n\t\t */\n\t\tfunction GLTFDracoMeshCompressionExtension( json, dracoLoader ) {\n\n\t\t\tif ( ! dracoLoader ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t\t}\n\n\t\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\t\tthis.json = json;\n\t\t\tthis.dracoLoader = dracoLoader;\n\t\t\tthis.dracoLoader.preload();\n\n\t\t}\n\n\t\tGLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar dracoLoader = this.dracoLoader;\n\t\t\tvar bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\t\tvar gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\t\tvar threeAttributeMap = {};\n\t\t\tvar attributeNormalizedMap = {};\n\t\t\tvar attributeTypeMap = {};\n\n\t\t\tfor ( var attributeName in gltfAttributeMap ) {\n\n\t\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t\t}\n\n\t\t\tfor ( attributeName in primitive.attributes ) {\n\n\t\t\t\tvar threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\t\tvar accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\t\tvar componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType;\n\t\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\t\tfor ( var attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\t\tvar normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t\t}, threeAttributeMap, attributeTypeMap );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Texture Transform Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n\t\t */\n\t\tfunction GLTFTextureTransformExtension() {\n\n\t\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t\t}\n\n\t\tGLTFTextureTransformExtension.prototype.extendTexture = function ( texture, transform ) {\n\n\t\t\ttexture = texture.clone();\n\n\t\t\tif ( transform.offset !== undefined ) {\n\n\t\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t\t}\n\n\t\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\t\ttexture.rotation = transform.rotation;\n\n\t\t\t}\n\n\t\t\tif ( transform.scale !== undefined ) {\n\n\t\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t\t}\n\n\t\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.' );\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\treturn texture;\n\n\t\t};\n\n\t\t/**\n\t\t * Specular-Glossiness Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n\t\t */\n\n\t\t/**\n\t\t * A sub class of THREE.StandardMaterial with some of the functionality\n\t\t * changed via the `onBeforeCompile` callback\n\t\t * @pailhead\n\t\t */\n\n\t\tfunction GLTFMeshStandardSGMaterial( params ) {\n\n\t\t\tTHREE.MeshStandardMaterial.call( this );\n\n\t\t\tthis.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t\t//various chunks that need replacing\n\t\t\tvar specularMapParsFragmentChunk = [\n\t\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t\t'\tuniform sampler2D specularMap;',\n\t\t\t\t'#endif'\n\t\t\t].join( '\\n' );\n\n\t\t\tvar glossinessMapParsFragmentChunk = [\n\t\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t\t'\tuniform sampler2D glossinessMap;',\n\t\t\t\t'#endif'\n\t\t\t].join( '\\n' );\n\n\t\t\tvar specularMapFragmentChunk = [\n\t\t\t\t'vec3 specularFactor = specular;',\n\t\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t\t'\tvec4 texelSpecular = texture2D( specularMap, vUv );',\n\t\t\t\t'\ttexelSpecular = sRGBToLinear( texelSpecular );',\n\t\t\t\t'\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t\t'\tspecularFactor *= texelSpecular.rgb;',\n\t\t\t\t'#endif'\n\t\t\t].join( '\\n' );\n\n\t\t\tvar glossinessMapFragmentChunk = [\n\t\t\t\t'float glossinessFactor = glossiness;',\n\t\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t\t'\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\n\t\t\t\t'\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t\t'\tglossinessFactor *= texelGlossiness.a;',\n\t\t\t\t'#endif'\n\t\t\t].join( '\\n' );\n\n\t\t\tvar lightPhysicalFragmentChunk = [\n\t\t\t\t'PhysicalMaterial material;',\n\t\t\t\t'material.diffuseColor = diffuseColor.rgb;',\n\t\t\t\t'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',\n\t\t\t\t'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',\n\t\t\t\t'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.',\n\t\t\t\t'material.specularRoughness += geometryRoughness;',\n\t\t\t\t'material.specularRoughness = min( material.specularRoughness, 1.0 );',\n\t\t\t\t'material.specularColor = specularFactor.rgb;',\n\t\t\t].join( '\\n' );\n\n\t\t\tvar uniforms = {\n\t\t\t\tspecular: { value: new THREE.Color().setHex( 0xffffff ) },\n\t\t\t\tglossiness: { value: 1 },\n\t\t\t\tspecularMap: { value: null },\n\t\t\t\tglossinessMap: { value: null }\n\t\t\t};\n\n\t\t\tthis._extraUniforms = uniforms;\n\n\t\t\t// please see #14031 or #13198 for an alternate approach\n\t\t\tthis.onBeforeCompile = function ( shader ) {\n\n\t\t\t\tfor ( var uniformName in uniforms ) {\n\n\t\t\t\t\tshader.uniforms[ uniformName ] = uniforms[ uniformName ];\n\n\t\t\t\t}\n\n\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( 'uniform float roughness;', 'uniform vec3 specular;' );\n\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( 'uniform float metalness;', 'uniform float glossiness;' );\n\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk );\n\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk );\n\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk );\n\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk );\n\t\t\t\tshader.fragmentShader = shader.fragmentShader.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );\n\n\t\t\t};\n\n\t\t\t/*eslint-disable*/\n\t\t\tObject.defineProperties(\n\t\t\t\tthis,\n\t\t\t\t{\n\t\t\t\t\tspecular: {\n\t\t\t\t\t\tget: function () { return uniforms.specular.value; },\n\t\t\t\t\t\tset: function ( v ) { uniforms.specular.value = v; }\n\t\t\t\t\t},\n\t\t\t\t\tspecularMap: {\n\t\t\t\t\t\tget: function () { return uniforms.specularMap.value; },\n\t\t\t\t\t\tset: function ( v ) { uniforms.specularMap.value = v; }\n\t\t\t\t\t},\n\t\t\t\t\tglossiness: {\n\t\t\t\t\t\tget: function () { return uniforms.glossiness.value; },\n\t\t\t\t\t\tset: function ( v ) { uniforms.glossiness.value = v; }\n\t\t\t\t\t},\n\t\t\t\t\tglossinessMap: {\n\t\t\t\t\t\tget: function () { return uniforms.glossinessMap.value; },\n\t\t\t\t\t\tset: function ( v ) {\n\n\t\t\t\t\t\t\tuniforms.glossinessMap.value = v;\n\t\t\t\t\t\t\t//how about something like this - @pailhead\n\t\t\t\t\t\t\tif ( v ) {\n\n\t\t\t\t\t\t\t\tthis.defines.USE_GLOSSINESSMAP = '';\n\t\t\t\t\t\t\t\t// set USE_ROUGHNESSMAP to enable vUv\n\t\t\t\t\t\t\t\tthis.defines.USE_ROUGHNESSMAP = '';\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tdelete this.defines.USE_ROUGHNESSMAP;\n\t\t\t\t\t\t\t\tdelete this.defines.USE_GLOSSINESSMAP;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t/*eslint-enable*/\n\t\t\tdelete this.metalness;\n\t\t\tdelete this.roughness;\n\t\t\tdelete this.metalnessMap;\n\t\t\tdelete this.roughnessMap;\n\n\t\t\tthis.setValues( params );\n\n\t\t}\n\n\t\tGLTFMeshStandardSGMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );\n\t\tGLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;\n\n\t\tGLTFMeshStandardSGMaterial.prototype.copy = function ( source ) {\n\n\t\t\tTHREE.MeshStandardMaterial.prototype.copy.call( this, source );\n\t\t\tthis.specularMap = source.specularMap;\n\t\t\tthis.specular.copy( source.specular );\n\t\t\tthis.glossinessMap = source.glossinessMap;\n\t\t\tthis.glossiness = source.glossiness;\n\t\t\tdelete this.metalness;\n\t\t\tdelete this.roughness;\n\t\t\tdelete this.metalnessMap;\n\t\t\tdelete this.roughnessMap;\n\t\t\treturn this;\n\n\t\t};\n\n\t\tfunction GLTFMaterialsPbrSpecularGlossinessExtension() {\n\n\t\t\treturn {\n\n\t\t\t\tname: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n\n\t\t\t\tspecularGlossinessParams: [\n\t\t\t\t\t'color',\n\t\t\t\t\t'map',\n\t\t\t\t\t'lightMap',\n\t\t\t\t\t'lightMapIntensity',\n\t\t\t\t\t'aoMap',\n\t\t\t\t\t'aoMapIntensity',\n\t\t\t\t\t'emissive',\n\t\t\t\t\t'emissiveIntensity',\n\t\t\t\t\t'emissiveMap',\n\t\t\t\t\t'bumpMap',\n\t\t\t\t\t'bumpScale',\n\t\t\t\t\t'normalMap',\n\t\t\t\t\t'normalMapType',\n\t\t\t\t\t'displacementMap',\n\t\t\t\t\t'displacementScale',\n\t\t\t\t\t'displacementBias',\n\t\t\t\t\t'specularMap',\n\t\t\t\t\t'specular',\n\t\t\t\t\t'glossinessMap',\n\t\t\t\t\t'glossiness',\n\t\t\t\t\t'alphaMap',\n\t\t\t\t\t'envMap',\n\t\t\t\t\t'envMapIntensity',\n\t\t\t\t\t'refractionRatio',\n\t\t\t\t],\n\n\t\t\t\tgetMaterialType: function () {\n\n\t\t\t\t\treturn GLTFMeshStandardSGMaterial;\n\n\t\t\t\t},\n\n\t\t\t\textendParams: function ( materialParams, materialDef, parser ) {\n\n\t\t\t\t\tvar pbrSpecularGlossiness = materialDef.extensions[ this.name ];\n\n\t\t\t\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\n\t\t\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\t\t\tvar pending = [];\n\n\t\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {\n\n\t\t\t\t\t\tvar array = pbrSpecularGlossiness.diffuseFactor;\n\n\t\t\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {\n\n\t\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterialParams.emissive = new THREE.Color( 0.0, 0.0, 0.0 );\n\t\t\t\t\tmaterialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n\t\t\t\t\tmaterialParams.specular = new THREE.Color( 1.0, 1.0, 1.0 );\n\n\t\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {\n\n\t\t\t\t\t\tmaterialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {\n\n\t\t\t\t\t\tvar specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n\t\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );\n\t\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Promise.all( pending );\n\n\t\t\t\t},\n\n\t\t\t\tcreateMaterial: function ( materialParams ) {\n\n\t\t\t\t\tvar material = new GLTFMeshStandardSGMaterial( materialParams );\n\t\t\t\t\tmaterial.fog = true;\n\n\t\t\t\t\tmaterial.color = materialParams.color;\n\n\t\t\t\t\tmaterial.map = materialParams.map === undefined ? null : materialParams.map;\n\n\t\t\t\t\tmaterial.lightMap = null;\n\t\t\t\t\tmaterial.lightMapIntensity = 1.0;\n\n\t\t\t\t\tmaterial.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\n\t\t\t\t\tmaterial.aoMapIntensity = 1.0;\n\n\t\t\t\t\tmaterial.emissive = materialParams.emissive;\n\t\t\t\t\tmaterial.emissiveIntensity = 1.0;\n\t\t\t\t\tmaterial.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\n\n\t\t\t\t\tmaterial.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n\t\t\t\t\tmaterial.bumpScale = 1;\n\n\t\t\t\t\tmaterial.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\n\t\t\t\t\tmaterial.normalMapType = THREE.TangentSpaceNormalMap;\n\n\t\t\t\t\tif ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;\n\n\t\t\t\t\tmaterial.displacementMap = null;\n\t\t\t\t\tmaterial.displacementScale = 1;\n\t\t\t\t\tmaterial.displacementBias = 0;\n\n\t\t\t\t\tmaterial.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\n\t\t\t\t\tmaterial.specular = materialParams.specular;\n\n\t\t\t\t\tmaterial.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\n\t\t\t\t\tmaterial.glossiness = materialParams.glossiness;\n\n\t\t\t\t\tmaterial.alphaMap = null;\n\n\t\t\t\t\tmaterial.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\n\t\t\t\t\tmaterial.envMapIntensity = 1.0;\n\n\t\t\t\t\tmaterial.refractionRatio = 0.98;\n\n\t\t\t\t\treturn material;\n\n\t\t\t\t},\n\n\t\t\t};\n\n\t\t}\n\n\t\t/**\n\t\t * Mesh Quantization Extension\n\t\t *\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n\t\t */\n\t\tfunction GLTFMeshQuantizationExtension() {\n\n\t\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t\t}\n\n\t\t/*********************************/\n\t\t/********** INTERPOLATION ********/\n\t\t/*********************************/\n\n\t\t// Spline Interpolation\n\t\t// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\t\tfunction GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\t\tTHREE.Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\t}\n\n\t\tGLTFCubicSplineInterpolant.prototype = Object.create( THREE.Interpolant.prototype );\n\t\tGLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n\t\tGLTFCubicSplineInterpolant.prototype.copySampleValue_ = function ( index ) {\n\n\t\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\t\tvar result = this.resultBuffer,\n\t\t\t\tvalues = this.sampleValues,\n\t\t\t\tvalueSize = this.valueSize,\n\t\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\t\tfor ( var i = 0; i !== valueSize; i ++ ) {\n\n\t\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t};\n\n\t\tGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n\t\tGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n\t\tGLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {\n\n\t\t\tvar result = this.resultBuffer;\n\t\t\tvar values = this.sampleValues;\n\t\t\tvar stride = this.valueSize;\n\n\t\t\tvar stride2 = stride * 2;\n\t\t\tvar stride3 = stride * 3;\n\n\t\t\tvar td = t1 - t0;\n\n\t\t\tvar p = ( t - t0 ) / td;\n\t\t\tvar pp = p * p;\n\t\t\tvar ppp = pp * p;\n\n\t\t\tvar offset1 = i1 * stride3;\n\t\t\tvar offset0 = offset1 - stride3;\n\n\t\t\tvar s2 = - 2 * ppp + 3 * pp;\n\t\t\tvar s3 = ppp - pp;\n\t\t\tvar s0 = 1 - s2;\n\t\t\tvar s1 = s3 - pp + p;\n\n\t\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\t\tfor ( var i = 0; i !== stride; i ++ ) {\n\n\t\t\t\tvar p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\t\tvar m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\t\tvar p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\t\tvar m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t};\n\n\t\t/*********************************/\n\t\t/********** INTERNALS ************/\n\t\t/*********************************/\n\n\t\t/* CONSTANTS */\n\n\t\tvar WEBGL_CONSTANTS = {\n\t\t\tFLOAT: 5126,\n\t\t\t//FLOAT_MAT2: 35674,\n\t\t\tFLOAT_MAT3: 35675,\n\t\t\tFLOAT_MAT4: 35676,\n\t\t\tFLOAT_VEC2: 35664,\n\t\t\tFLOAT_VEC3: 35665,\n\t\t\tFLOAT_VEC4: 35666,\n\t\t\tLINEAR: 9729,\n\t\t\tREPEAT: 10497,\n\t\t\tSAMPLER_2D: 35678,\n\t\t\tPOINTS: 0,\n\t\t\tLINES: 1,\n\t\t\tLINE_LOOP: 2,\n\t\t\tLINE_STRIP: 3,\n\t\t\tTRIANGLES: 4,\n\t\t\tTRIANGLE_STRIP: 5,\n\t\t\tTRIANGLE_FAN: 6,\n\t\t\tUNSIGNED_BYTE: 5121,\n\t\t\tUNSIGNED_SHORT: 5123\n\t\t};\n\n\t\tvar WEBGL_COMPONENT_TYPES = {\n\t\t\t5120: Int8Array,\n\t\t\t5121: Uint8Array,\n\t\t\t5122: Int16Array,\n\t\t\t5123: Uint16Array,\n\t\t\t5125: Uint32Array,\n\t\t\t5126: Float32Array\n\t\t};\n\n\t\tvar WEBGL_FILTERS = {\n\t\t\t9728: THREE.NearestFilter,\n\t\t\t9729: THREE.LinearFilter,\n\t\t\t9984: THREE.NearestMipmapNearestFilter,\n\t\t\t9985: THREE.LinearMipmapNearestFilter,\n\t\t\t9986: THREE.NearestMipmapLinearFilter,\n\t\t\t9987: THREE.LinearMipmapLinearFilter\n\t\t};\n\n\t\tvar WEBGL_WRAPPINGS = {\n\t\t\t33071: THREE.ClampToEdgeWrapping,\n\t\t\t33648: THREE.MirroredRepeatWrapping,\n\t\t\t10497: THREE.RepeatWrapping\n\t\t};\n\n\t\tvar WEBGL_TYPE_SIZES = {\n\t\t\t'SCALAR': 1,\n\t\t\t'VEC2': 2,\n\t\t\t'VEC3': 3,\n\t\t\t'VEC4': 4,\n\t\t\t'MAT2': 4,\n\t\t\t'MAT3': 9,\n\t\t\t'MAT4': 16\n\t\t};\n\n\t\tvar ATTRIBUTES = {\n\t\t\tPOSITION: 'position',\n\t\t\tNORMAL: 'normal',\n\t\t\tTANGENT: 'tangent',\n\t\t\tTEXCOORD_0: 'uv',\n\t\t\tTEXCOORD_1: 'uv2',\n\t\t\tCOLOR_0: 'color',\n\t\t\tWEIGHTS_0: 'skinWeight',\n\t\t\tJOINTS_0: 'skinIndex',\n\t\t};\n\n\t\tvar PATH_PROPERTIES = {\n\t\t\tscale: 'scale',\n\t\t\ttranslation: 'position',\n\t\t\trotation: 'quaternion',\n\t\t\tweights: 'morphTargetInfluences'\n\t\t};\n\n\t\tvar INTERPOLATION = {\n\t\t\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\t\t\tLINEAR: THREE.InterpolateLinear,\n\t\t\tSTEP: THREE.InterpolateDiscrete\n\t\t};\n\n\t\tvar ALPHA_MODES = {\n\t\t\tOPAQUE: 'OPAQUE',\n\t\t\tMASK: 'MASK',\n\t\t\tBLEND: 'BLEND'\n\t\t};\n\n\t\tvar MIME_TYPE_FORMATS = {\n\t\t\t'image/png': THREE.RGBAFormat,\n\t\t\t'image/jpeg': THREE.RGBFormat\n\t\t};\n\n\t\t/* UTILITY FUNCTIONS */\n\n\t\tfunction resolveURL( url, path ) {\n\n\t\t\t// Invalid URL\n\t\t\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t\t\t// Host Relative URL\n\t\t\tif ( /^https?:\\/\\//i.test( path ) && /^\\//.test( url ) ) {\n\n\t\t\t\tpath = path.replace( /(^https?:\\/\\/[^\\/]+).*/i, '$1' );\n\n\t\t\t}\n\n\t\t\t// Absolute URL http://,https://,//\n\t\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t\t\t// Data URI\n\t\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t\t\t// Blob URL\n\t\t\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t\t\t// Relative URL\n\t\t\treturn path + url;\n\n\t\t}\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n\t\t */\n\t\tfunction createDefaultMaterial( cache ) {\n\n\t\t\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\t\t\tcache[ 'DefaultMaterial' ] = new THREE.MeshStandardMaterial( {\n\t\t\t\t\tcolor: 0xFFFFFF,\n\t\t\t\t\temissive: 0x000000,\n\t\t\t\t\tmetalness: 1,\n\t\t\t\t\troughness: 1,\n\t\t\t\t\ttransparent: false,\n\t\t\t\t\tdepthTest: true,\n\t\t\t\t\tside: THREE.FrontSide\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn cache[ 'DefaultMaterial' ];\n\n\t\t}\n\n\t\tfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t\t\t// Add unknown glTF extensions to an object's userData.\n\n\t\t\tfor ( var name in objectDef.extensions ) {\n\n\t\t\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry} object\n\t\t * @param {GLTF.definition} gltfDef\n\t\t */\n\t\tfunction assignExtrasToUserData( object, gltfDef ) {\n\n\t\t\tif ( gltfDef.extras !== undefined ) {\n\n\t\t\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n\t\t *\n\t\t * @param {THREE.BufferGeometry} geometry\n\t\t * @param {Array<GLTF.Target>} targets\n\t\t * @param {GLTFParser} parser\n\t\t * @return {Promise<THREE.BufferGeometry>}\n\t\t */\n\t\tfunction addMorphTargets( geometry, targets, parser ) {\n\n\t\t\tvar hasMorphPosition = false;\n\t\t\tvar hasMorphNormal = false;\n\n\t\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\t\tvar target = targets[ i ];\n\n\t\t\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\t\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\n\t\t\t\tif ( hasMorphPosition && hasMorphNormal ) break;\n\n\t\t\t}\n\n\t\t\tif ( ! hasMorphPosition && ! hasMorphNormal ) return Promise.resolve( geometry );\n\n\t\t\tvar pendingPositionAccessors = [];\n\t\t\tvar pendingNormalAccessors = [];\n\n\t\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\t\tvar target = targets[ i ];\n\n\t\t\t\tif ( hasMorphPosition ) {\n\n\t\t\t\t\tvar pendingAccessor = target.POSITION !== undefined\n\t\t\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t\t\t: geometry.attributes.position;\n\n\t\t\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t\t\t}\n\n\t\t\t\tif ( hasMorphNormal ) {\n\n\t\t\t\t\tvar pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t\t\t: geometry.attributes.normal;\n\n\t\t\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Promise.all( [\n\t\t\t\tPromise.all( pendingPositionAccessors ),\n\t\t\t\tPromise.all( pendingNormalAccessors )\n\t\t\t] ).then( function ( accessors ) {\n\n\t\t\t\tvar morphPositions = accessors[ 0 ];\n\t\t\t\tvar morphNormals = accessors[ 1 ];\n\n\t\t\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\t\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\t\t\tgeometry.morphTargetsRelative = true;\n\n\t\t\t\treturn geometry;\n\n\t\t\t} );\n\n\t\t}\n\n\t\t/**\n\t\t * @param {THREE.Mesh} mesh\n\t\t * @param {GLTF.Mesh} meshDef\n\t\t */\n\t\tfunction updateMorphTargets( mesh, meshDef ) {\n\n\t\t\tmesh.updateMorphTargets();\n\n\t\t\tif ( meshDef.weights !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\t\t\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\t\t\tvar targetNames = meshDef.extras.targetNames;\n\n\t\t\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\t\t\tfor ( var i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createPrimitiveKey( primitiveDef ) {\n\n\t\t\tvar dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\t\t\tvar geometryKey;\n\n\t\t\tif ( dracoExtension ) {\n\n\t\t\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t\t\t} else {\n\n\t\t\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t\t\t}\n\n\t\t\treturn geometryKey;\n\n\t\t}\n\n\t\tfunction createAttributesKey( attributes ) {\n\n\t\t\tvar attributesKey = '';\n\n\t\t\tvar keys = Object.keys( attributes ).sort();\n\n\t\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t\t\t}\n\n\t\t\treturn attributesKey;\n\n\t\t}\n\n\t\t/* GLTF PARSER */\n\n\t\tfunction GLTFParser( json, extensions, options ) {\n\n\t\t\tthis.json = json || {};\n\t\t\tthis.extensions = extensions || {};\n\t\t\tthis.options = options || {};\n\n\t\t\t// loader object cache\n\t\t\tthis.cache = new GLTFRegistry();\n\n\t\t\t// BufferGeometry caching\n\t\t\tthis.primitiveCache = {};\n\n\t\t\tthis.textureLoader = new THREE.TextureLoader( this.options.manager );\n\t\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\n\t\t\tthis.fileLoader = new THREE.FileLoader( this.options.manager );\n\t\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tGLTFParser.prototype.parse = function ( onLoad, onError ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar json = this.json;\n\t\t\tvar extensions = this.extensions;\n\n\t\t\t// Clear the loader cache\n\t\t\tthis.cache.removeAll();\n\n\t\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\t\tthis.markDefs();\n\n\t\t\tPromise.all( [\n\n\t\t\t\tthis.getDependencies( 'scene' ),\n\t\t\t\tthis.getDependencies( 'animation' ),\n\t\t\t\tthis.getDependencies( 'camera' ),\n\n\t\t\t] ).then( function ( dependencies ) {\n\n\t\t\t\tvar result = {\n\t\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\t\tasset: json.asset,\n\t\t\t\t\tparser: parser,\n\t\t\t\t\tuserData: {}\n\t\t\t\t};\n\n\t\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} ).catch( onError );\n\n\t\t};\n\n\t\t/**\n\t\t * Marks the special nodes/meshes in json for efficient parse.\n\t\t */\n\t\tGLTFParser.prototype.markDefs = function () {\n\n\t\t\tvar nodeDefs = this.json.nodes || [];\n\t\t\tvar skinDefs = this.json.skins || [];\n\t\t\tvar meshDefs = this.json.meshes || [];\n\n\t\t\tvar meshReferences = {};\n\t\t\tvar meshUses = {};\n\n\t\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\t\tfor ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\t\tvar joints = skinDefs[ skinIndex ].joints;\n\n\t\t\t\tfor ( var i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n\t\t\t// avoid having more than one THREE.Mesh with the same name, count\n\t\t\t// references and rename instances below.\n\t\t\t//\n\t\t\t// Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\t\tif ( meshReferences[ nodeDef.mesh ] === undefined ) {\n\n\t\t\t\t\t\tmeshReferences[ nodeDef.mesh ] = meshUses[ nodeDef.mesh ] = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmeshReferences[ nodeDef.mesh ] ++;\n\n\t\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.json.meshReferences = meshReferences;\n\t\t\tthis.json.meshUses = meshUses;\n\n\t\t};\n\n\t\t/**\n\t\t * Requests the specified dependency asynchronously, with caching.\n\t\t * @param {string} type\n\t\t * @param {number} index\n\t\t * @return {Promise<THREE.Object3D|THREE.Material|THREE.Texture|THREE.AnimationClip|ArrayBuffer|Object>}\n\t\t */\n\t\tGLTFParser.prototype.getDependency = function ( type, index ) {\n\n\t\t\tvar cacheKey = type + ':' + index;\n\t\t\tvar dependency = this.cache.get( cacheKey );\n\n\t\t\tif ( ! dependency ) {\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'scene':\n\t\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'node':\n\t\t\t\t\t\tdependency = this.loadNode( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'mesh':\n\t\t\t\t\t\tdependency = this.loadMesh( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'accessor':\n\t\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bufferView':\n\t\t\t\t\t\tdependency = this.loadBufferView( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'buffer':\n\t\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'material':\n\t\t\t\t\t\tdependency = this.loadMaterial( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdependency = this.loadTexture( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'animation':\n\t\t\t\t\t\tdependency = this.loadAnimation( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'camera':\n\t\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'light':\n\t\t\t\t\t\tdependency = this.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].loadLight( index );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t\t}\n\n\t\t\treturn dependency;\n\n\t\t};\n\n\t\t/**\n\t\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t\t * @param {string} type\n\t\t * @return {Promise<Array<Object>>}\n\t\t */\n\t\tGLTFParser.prototype.getDependencies = function ( type ) {\n\n\t\t\tvar dependencies = this.cache.get( type );\n\n\t\t\tif ( ! dependencies ) {\n\n\t\t\t\tvar parser = this;\n\t\t\t\tvar defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t\t} ) );\n\n\t\t\t\tthis.cache.add( type, dependencies );\n\n\t\t\t}\n\n\t\t\treturn dependencies;\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t\t * @param {number} bufferIndex\n\t\t * @return {Promise<ArrayBuffer>}\n\t\t */\n\t\tGLTFParser.prototype.loadBuffer = function ( bufferIndex ) {\n\n\t\t\tvar bufferDef = this.json.buffers[ bufferIndex ];\n\t\t\tvar loader = this.fileLoader;\n\n\t\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t\t}\n\n\t\t\t// If present, GLB container is required to be the first buffer.\n\t\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t\t}\n\n\t\t\tvar options = this.options;\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tloader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t\t * @param {number} bufferViewIndex\n\t\t * @return {Promise<ArrayBuffer>}\n\t\t */\n\t\tGLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {\n\n\t\t\tvar bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\t\tvar byteLength = bufferViewDef.byteLength || 0;\n\t\t\t\tvar byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t\t * @param {number} accessorIndex\n\t\t * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}\n\t\t */\n\t\tGLTFParser.prototype.loadAccessor = function ( accessorIndex ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar json = this.json;\n\n\t\t\tvar accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\t\t// Ignore empty accessors, which may be used to declare runtime\n\t\t\t\t// information about attributes coming from another source (e.g. Draco\n\t\t\t\t// compression extension).\n\t\t\t\treturn Promise.resolve( null );\n\n\t\t\t}\n\n\t\t\tvar pendingBufferViews = [];\n\n\t\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t\t} else {\n\n\t\t\t\tpendingBufferViews.push( null );\n\n\t\t\t}\n\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\t\tvar bufferView = bufferViews[ 0 ];\n\n\t\t\t\tvar itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\t\tvar TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\t\tvar elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\t\tvar itemBytes = elementBytes * itemSize;\n\t\t\t\tvar byteOffset = accessorDef.byteOffset || 0;\n\t\t\t\tvar byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\t\tvar normalized = accessorDef.normalized === true;\n\t\t\t\tvar array, bufferAttribute;\n\n\t\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\t\tvar ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\t\tvar ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\t\tvar ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\t\tib = new THREE.InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbufferAttribute = new THREE.InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbufferAttribute = new THREE.BufferAttribute( array, itemSize, normalized );\n\n\t\t\t\t}\n\n\t\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\t\tvar itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\t\tvar TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\t\tvar byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\t\tvar byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\t\tvar sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\t\tvar sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\t\tbufferAttribute = new THREE.BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar index = sparseIndices[ i ];\n\n\t\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn bufferAttribute;\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t\t * @param {number} textureIndex\n\t\t * @return {Promise<THREE.Texture>}\n\t\t */\n\t\tGLTFParser.prototype.loadTexture = function ( textureIndex ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar json = this.json;\n\t\t\tvar options = this.options;\n\t\t\tvar textureLoader = this.textureLoader;\n\n\t\t\tvar URL = self.URL || self.webkitURL;\n\n\t\t\tvar textureDef = json.textures[ textureIndex ];\n\n\t\t\tvar textureExtensions = textureDef.extensions || {};\n\n\t\t\tvar source;\n\n\t\t\tif ( textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] ) {\n\n\t\t\t\tsource = json.images[ textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].source ];\n\n\t\t\t} else {\n\n\t\t\t\tsource = json.images[ textureDef.source ];\n\n\t\t\t}\n\n\t\t\tvar sourceURI = source.uri;\n\t\t\tvar isObjectURL = false;\n\n\t\t\tif ( source.bufferView !== undefined ) {\n\n\t\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\t\tsourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\t\tisObjectURL = true;\n\t\t\t\t\tvar blob = new Blob( [ bufferView ], { type: source.mimeType } );\n\t\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\t\treturn sourceURI;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\t\t// Load Texture resource.\n\n\t\t\t\tvar loader = options.manager.getHandler( sourceURI );\n\n\t\t\t\tif ( ! loader ) {\n\n\t\t\t\t\tloader = textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ]\n\t\t\t\t\t\t? parser.extensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].ddsLoader\n\t\t\t\t\t\t: textureLoader;\n\n\t\t\t\t}\n\n\t\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\t\tloader.load( resolveURL( sourceURI, options.path ), resolve, undefined, reject );\n\n\t\t\t\t} );\n\n\t\t\t} ).then( function ( texture ) {\n\n\t\t\t\t// Clean up resources and configure Texture.\n\n\t\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.flipY = false;\n\n\t\t\t\tif ( textureDef.name ) texture.name = textureDef.name;\n\n\t\t\t\t// Ignore unknown mime types, like DDS files.\n\t\t\t\tif ( source.mimeType in MIME_TYPE_FORMATS ) {\n\n\t\t\t\t\ttexture.format = MIME_TYPE_FORMATS[ source.mimeType ];\n\n\t\t\t\t}\n\n\t\t\t\tvar samplers = json.samplers || {};\n\t\t\t\tvar sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || THREE.LinearFilter;\n\t\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || THREE.LinearMipmapLinearFilter;\n\t\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || THREE.RepeatWrapping;\n\t\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || THREE.RepeatWrapping;\n\n\t\t\t\treturn texture;\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Asynchronously assigns a texture to the given material parameters.\n\t\t * @param {Object} materialParams\n\t\t * @param {string} mapName\n\t\t * @param {Object} mapDef\n\t\t * @return {Promise}\n\t\t */\n\t\tGLTFParser.prototype.assignTexture = function ( materialParams, mapName, mapDef ) {\n\n\t\t\tvar parser = this;\n\n\t\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\t\tif ( ! texture.isCompressedTexture ) {\n\n\t\t\t\t\tswitch ( mapName ) {\n\n\t\t\t\t\t\tcase 'aoMap':\n\t\t\t\t\t\tcase 'emissiveMap':\n\t\t\t\t\t\tcase 'metalnessMap':\n\t\t\t\t\t\tcase 'normalMap':\n\t\t\t\t\t\tcase 'roughnessMap':\n\t\t\t\t\t\t\ttexture.format = THREE.RGBFormat;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n\t\t\t\t// However, we will copy UV set 0 to UV set 1 on demand for aoMap\n\t\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\t\tvar transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\t\tif ( transform ) {\n\n\t\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t\t * already has a material (generated from the glTF material options alone)\n\t\t * but reuse of the same glTF material may require multiple threejs materials\n\t\t * to accomodate different primitive types, defines, etc. New materials will\n\t\t * be created if necessary, and reused from a cache.\n\t\t * @param  {THREE.Object3D} mesh Mesh, Line, or Points instance.\n\t\t */\n\t\tGLTFParser.prototype.assignFinalMaterial = function ( mesh ) {\n\n\t\t\tvar geometry = mesh.geometry;\n\t\t\tvar material = mesh.material;\n\n\t\t\tvar useVertexTangents = geometry.attributes.tangent !== undefined;\n\t\t\tvar useVertexColors = geometry.attributes.color !== undefined;\n\t\t\tvar useFlatShading = geometry.attributes.normal === undefined;\n\t\t\tvar useSkinning = mesh.isSkinnedMesh === true;\n\t\t\tvar useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;\n\t\t\tvar useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n\t\t\tif ( mesh.isPoints ) {\n\n\t\t\t\tvar cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\t\tvar pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\t\tpointsMaterial = new THREE.PointsMaterial();\n\t\t\t\t\tTHREE.Material.prototype.copy.call( pointsMaterial, material );\n\t\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t\t}\n\n\t\t\t\tmaterial = pointsMaterial;\n\n\t\t\t} else if ( mesh.isLine ) {\n\n\t\t\t\tvar cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\t\tvar lineMaterial = this.cache.get( cacheKey );\n\n\t\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\t\tlineMaterial = new THREE.LineBasicMaterial();\n\t\t\t\t\tTHREE.Material.prototype.copy.call( lineMaterial, material );\n\t\t\t\t\tlineMaterial.color.copy( material.color );\n\n\t\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t\t}\n\n\t\t\t\tmaterial = lineMaterial;\n\n\t\t\t}\n\n\t\t\t// Clone the material if it will be modified\n\t\t\tif ( useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {\n\n\t\t\t\tvar cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';\n\t\t\t\tif ( useSkinning ) cacheKey += 'skinning:';\n\t\t\t\tif ( useVertexTangents ) cacheKey += 'vertex-tangents:';\n\t\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\t\t\t\tif ( useMorphTargets ) cacheKey += 'morph-targets:';\n\t\t\t\tif ( useMorphNormals ) cacheKey += 'morph-normals:';\n\n\t\t\t\tvar cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\t\tif ( useSkinning ) cachedMaterial.skinning = true;\n\t\t\t\t\tif ( useVertexTangents ) cachedMaterial.vertexTangents = true;\n\t\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\t\t\t\t\tif ( useMorphTargets ) cachedMaterial.morphTargets = true;\n\t\t\t\t\tif ( useMorphNormals ) cachedMaterial.morphNormals = true;\n\n\t\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\t}\n\n\t\t\t\tmaterial = cachedMaterial;\n\n\t\t\t}\n\n\t\t\t// workarounds for mesh and geometry\n\n\t\t\tif ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {\n\n\t\t\t\tgeometry.setAttribute( 'uv2', new THREE.BufferAttribute( geometry.attributes.uv.array, 2 ) );\n\n\t\t\t}\n\n\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\tif ( material.normalScale && ! useVertexTangents ) {\n\n\t\t\t\tmaterial.normalScale.y = - material.normalScale.y;\n\n\t\t\t}\n\n\t\t\tif ( material.clearcoatNormalScale && ! useVertexTangents ) {\n\n\t\t\t\tmaterial.clearcoatNormalScale.y = - material.clearcoatNormalScale.y;\n\n\t\t\t}\n\n\t\t\tmesh.material = material;\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t\t * @param {number} materialIndex\n\t\t * @return {Promise<THREE.Material>}\n\t\t */\n\t\tGLTFParser.prototype.loadMaterial = function ( materialIndex ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar json = this.json;\n\t\t\tvar extensions = this.extensions;\n\t\t\tvar materialDef = json.materials[ materialIndex ];\n\n\t\t\tvar materialType;\n\t\t\tvar materialParams = {};\n\t\t\tvar materialExtensions = materialDef.extensions || {};\n\n\t\t\tvar pending = [];\n\n\t\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {\n\n\t\t\t\tvar sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\n\t\t\t\tmaterialType = sgExtension.getMaterialType();\n\t\t\t\tpending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t\t} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\t\tvar kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t\t} else {\n\n\t\t\t\t// Specification:\n\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\t\tmaterialType = THREE.MeshStandardMaterial;\n\n\t\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\n\t\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );\n\n\t\t\t\t}\n\n\t\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\t\tmaterialParams.side = THREE.DoubleSide;\n\n\t\t\t}\n\n\t\t\tvar alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\t\tmaterialParams.transparent = true;\n\n\t\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\t\tmaterialParams.depthWrite = false;\n\n\t\t\t} else {\n\n\t\t\t\tmaterialParams.transparent = false;\n\n\t\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\t\tmaterialParams.normalScale = new THREE.Vector2( 1, 1 );\n\n\t\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\t\tmaterialParams.normalScale.set( materialDef.normalTexture.scale, materialDef.normalTexture.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial ) {\n\n\t\t\t\tmaterialParams.emissive = new THREE.Color().fromArray( materialDef.emissiveFactor );\n\n\t\t\t}\n\n\t\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );\n\n\t\t\t}\n\n\t\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_CLEARCOAT ] ) {\n\n\t\t\t\tvar clearcoatExtension = extensions[ EXTENSIONS.KHR_MATERIALS_CLEARCOAT ];\n\t\t\t\tmaterialType = clearcoatExtension.getMaterialType();\n\t\t\t\tpending.push( clearcoatExtension.extendParams( materialParams, { extensions: materialExtensions }, parser ) );\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\t\tvar material;\n\n\t\t\t\tif ( materialType === GLTFMeshStandardSGMaterial ) {\n\n\t\t\t\t\tmaterial = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = new materialType( materialParams );\n\n\t\t\t\t}\n\n\t\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\t\t// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\t\t\t\tif ( material.map ) material.map.encoding = THREE.sRGBEncoding;\n\t\t\t\tif ( material.emissiveMap ) material.emissiveMap.encoding = THREE.sRGBEncoding;\n\n\t\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\t\treturn material;\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * @param {THREE.BufferGeometry} geometry\n\t\t * @param {GLTF.Primitive} primitiveDef\n\t\t * @param {GLTFParser} parser\n\t\t */\n\t\tfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\t\t\tvar attributes = primitiveDef.attributes;\n\n\t\t\tvar box = new THREE.Box3();\n\n\t\t\tif ( attributes.POSITION !== undefined ) {\n\n\t\t\t\tvar accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\t\t\tvar min = accessor.min;\n\t\t\t\tvar max = accessor.max;\n\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\tbox.set(\n\t\t\t\t\t\tnew THREE.Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\t\t\tnew THREE.Vector3( max[ 0 ], max[ 1 ], max[ 2 ] ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar targets = primitiveDef.targets;\n\n\t\t\tif ( targets !== undefined ) {\n\n\t\t\t\tvar maxDisplacement = new THREE.Vector3();\n\t\t\t\tvar vector = new THREE.Vector3();\n\n\t\t\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar target = targets[ i ];\n\n\t\t\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\t\t\tvar accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\t\t\tvar min = accessor.min;\n\t\t\t\t\t\tvar max = accessor.max;\n\n\t\t\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\t\t\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\t\t\tbox.expandByVector( maxDisplacement );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingBox = box;\n\n\t\t\tvar sphere = new THREE.Sphere();\n\n\t\t\tbox.getCenter( sphere.center );\n\t\t\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\t\t\tgeometry.boundingSphere = sphere;\n\n\t\t}\n\n\t\t/**\n\t\t * @param {THREE.BufferGeometry} geometry\n\t\t * @param {GLTF.Primitive} primitiveDef\n\t\t * @param {GLTFParser} parser\n\t\t * @return {Promise<THREE.BufferGeometry>}\n\t\t */\n\t\tfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\t\t\tvar attributes = primitiveDef.attributes;\n\n\t\t\tvar pending = [];\n\n\t\t\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\t\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t\t\t.then( function ( accessor ) {\n\n\t\t\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfor ( var gltfAttributeName in attributes ) {\n\n\t\t\t\tvar threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\t\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\t\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t\t\t}\n\n\t\t\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\t\t\tvar accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\t\t\tgeometry.setIndex( accessor );\n\n\t\t\t\t} );\n\n\t\t\t\tpending.push( accessor );\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( geometry, primitiveDef );\n\n\t\t\tcomputeBounds( geometry, primitiveDef, parser );\n\n\t\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\t\treturn primitiveDef.targets !== undefined\n\t\t\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t\t\t: geometry;\n\n\t\t\t} );\n\n\t\t}\n\n\t\t/**\n\t\t * @param {THREE.BufferGeometry} geometry\n\t\t * @param {Number} drawMode\n\t\t * @return {THREE.BufferGeometry}\n\t\t */\n\t\tfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\t\t\tvar index = geometry.getIndex();\n\n\t\t\t// generate index if not present\n\n\t\t\tif ( index === null ) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\t\tif ( position !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\t\tindices.push( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar numberOfTriangles = index.count - 2;\n\t\t\tvar newIndices = [];\n\n\t\t\tif ( drawMode === THREE.TriangleFanDrawMode ) {\n\n\t\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\t\tfor ( var i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\t\tfor ( var i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\t\tconsole.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t\t}\n\n\t\t\t// build final geometry\n\n\t\t\tvar newGeometry = geometry.clone();\n\t\t\tnewGeometry.setIndex( newIndices );\n\n\t\t\treturn newGeometry;\n\n\t\t}\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t\t *\n\t\t * Creates BufferGeometries from primitives.\n\t\t *\n\t\t * @param {Array<GLTF.Primitive>} primitives\n\t\t * @return {Promise<Array<THREE.BufferGeometry>>}\n\t\t */\n\t\tGLTFParser.prototype.loadGeometries = function ( primitives ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar extensions = this.extensions;\n\t\t\tvar cache = this.primitiveCache;\n\n\t\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tvar pending = [];\n\n\t\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\t\tvar primitive = primitives[ i ];\n\t\t\t\tvar cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t\t// See if we've already created this geometry\n\t\t\t\tvar cached = cache[ cacheKey ];\n\n\t\t\t\tif ( cached ) {\n\n\t\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\t\tpending.push( cached.promise );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar geometryPromise;\n\n\t\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new THREE.BufferGeometry(), primitive, parser );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Cache this geometry\n\t\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Promise.all( pending );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t\t * @param {number} meshIndex\n\t\t * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}\n\t\t */\n\t\tGLTFParser.prototype.loadMesh = function ( meshIndex ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar json = this.json;\n\n\t\t\tvar meshDef = json.meshes[ meshIndex ];\n\t\t\tvar primitives = meshDef.primitives;\n\n\t\t\tvar pending = [];\n\n\t\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\t\tvar material = primitives[ i ].material === undefined\n\t\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\t\tpending.push( material );\n\n\t\t\t}\n\n\t\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\t\tvar materials = results.slice( 0, results.length - 1 );\n\t\t\t\tvar geometries = results[ results.length - 1 ];\n\n\t\t\t\tvar meshes = [];\n\n\t\t\t\tfor ( var i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar geometry = geometries[ i ];\n\t\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\t\t// 1. create Mesh\n\n\t\t\t\t\tvar mesh;\n\n\t\t\t\t\tvar material = materials[ i ];\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See .markDefs()\n\t\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t\t? new THREE.SkinnedMesh( geometry, material )\n\t\t\t\t\t\t\t: new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\tif ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {\n\n\t\t\t\t\t\t\t// we normalize floating point skin weight array to fix malformed assets (see #15319)\n\t\t\t\t\t\t\t// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n\t\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, THREE.TriangleStripDrawMode );\n\n\t\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, THREE.TriangleFanDrawMode );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\t\tmesh = new THREE.LineSegments( geometry, material );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\t\tmesh = new THREE.Line( geometry, material );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\t\tmesh = new THREE.LineLoop( geometry, material );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\t\tmesh = new THREE.Points( geometry, material );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.name = meshDef.name || ( 'mesh_' + meshIndex );\n\n\t\t\t\t\tif ( geometries.length > 1 ) mesh.name += '_' + i;\n\n\t\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tvar group = new THREE.Group();\n\n\t\t\t\tfor ( var i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn group;\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t\t * @param {number} cameraIndex\n\t\t * @return {Promise<THREE.Camera>}\n\t\t */\n\t\tGLTFParser.prototype.loadCamera = function ( cameraIndex ) {\n\n\t\t\tvar camera;\n\t\t\tvar cameraDef = this.json.cameras[ cameraIndex ];\n\t\t\tvar params = cameraDef[ cameraDef.type ];\n\n\t\t\tif ( ! params ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( THREE.MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\t\tcamera = new THREE.OrthographicCamera( params.xmag / - 2, params.xmag / 2, params.ymag / 2, params.ymag / - 2, params.znear, params.zfar );\n\n\t\t\t}\n\n\t\t\tif ( cameraDef.name ) camera.name = cameraDef.name;\n\n\t\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\t\treturn Promise.resolve( camera );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t\t * @param {number} skinIndex\n\t\t * @return {Promise<Object>}\n\t\t */\n\t\tGLTFParser.prototype.loadSkin = function ( skinIndex ) {\n\n\t\t\tvar skinDef = this.json.skins[ skinIndex ];\n\n\t\t\tvar skinEntry = { joints: skinDef.joints };\n\n\t\t\tif ( skinDef.inverseBindMatrices === undefined ) {\n\n\t\t\t\treturn Promise.resolve( skinEntry );\n\n\t\t\t}\n\n\t\t\treturn this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {\n\n\t\t\t\tskinEntry.inverseBindMatrices = accessor;\n\n\t\t\t\treturn skinEntry;\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t\t * @param {number} animationIndex\n\t\t * @return {Promise<THREE.AnimationClip>}\n\t\t */\n\t\tGLTFParser.prototype.loadAnimation = function ( animationIndex ) {\n\n\t\t\tvar json = this.json;\n\n\t\t\tvar animationDef = json.animations[ animationIndex ];\n\n\t\t\tvar pendingNodes = [];\n\t\t\tvar pendingInputAccessors = [];\n\t\t\tvar pendingOutputAccessors = [];\n\t\t\tvar pendingSamplers = [];\n\t\t\tvar pendingTargets = [];\n\n\t\t\tfor ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\t\tvar channel = animationDef.channels[ i ];\n\t\t\t\tvar sampler = animationDef.samplers[ channel.sampler ];\n\t\t\t\tvar target = channel.target;\n\t\t\t\tvar name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\t\t\tvar input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\t\tvar output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\t\tpendingSamplers.push( sampler );\n\t\t\t\tpendingTargets.push( target );\n\n\t\t\t}\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tPromise.all( pendingNodes ),\n\t\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\t\tPromise.all( pendingSamplers ),\n\t\t\t\tPromise.all( pendingTargets )\n\n\t\t\t] ).then( function ( dependencies ) {\n\n\t\t\t\tvar nodes = dependencies[ 0 ];\n\t\t\t\tvar inputAccessors = dependencies[ 1 ];\n\t\t\t\tvar outputAccessors = dependencies[ 2 ];\n\t\t\t\tvar samplers = dependencies[ 3 ];\n\t\t\t\tvar targets = dependencies[ 4 ];\n\n\t\t\t\tvar tracks = [];\n\n\t\t\t\tfor ( var i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar node = nodes[ i ];\n\t\t\t\t\tvar inputAccessor = inputAccessors[ i ];\n\t\t\t\t\tvar outputAccessor = outputAccessors[ i ];\n\t\t\t\t\tvar sampler = samplers[ i ];\n\t\t\t\t\tvar target = targets[ i ];\n\n\t\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\t\tnode.updateMatrix();\n\t\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\t\tvar TypedKeyframeTrack;\n\n\t\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\t\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.NumberKeyframeTrack;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase PATH_PROPERTIES.position:\n\t\t\t\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.VectorKeyframeTrack;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar targetName = node.name ? node.name : node.uuid;\n\n\t\t\t\t\tvar interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : THREE.InterpolateLinear;\n\n\t\t\t\t\tvar targetNames = [];\n\n\t\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\t\t\t\t// Node may be a THREE.Group (glTF mesh with several primitives) or a THREE.Mesh.\n\t\t\t\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\t\t\t\tif ( object.isMesh === true && object.morphTargetInfluences ) {\n\n\t\t\t\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetNames.push( targetName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar outputArray = outputAccessor.array;\n\n\t\t\t\t\tif ( outputAccessor.normalized ) {\n\n\t\t\t\t\t\tvar scale;\n\n\t\t\t\t\t\tif ( outputArray.constructor === Int8Array ) {\n\n\t\t\t\t\t\t\tscale = 1 / 127;\n\n\t\t\t\t\t\t} else if ( outputArray.constructor === Uint8Array ) {\n\n\t\t\t\t\t\t\tscale = 1 / 255;\n\n\t\t\t\t\t\t} else if ( outputArray.constructor == Int16Array ) {\n\n\t\t\t\t\t\t\tscale = 1 / 32767;\n\n\t\t\t\t\t\t} else if ( outputArray.constructor === Uint16Array ) {\n\n\t\t\t\t\t\t\tscale = 1 / 65535;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported output accessor component type.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar scaled = new Float32Array( outputArray.length );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toutputArray = scaled;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar track = new TypedKeyframeTrack(\n\t\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\t\t\t\tinputAccessor.array,\n\t\t\t\t\t\t\toutputArray,\n\t\t\t\t\t\t\tinterpolation\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Override interpolation with custom factory method.\n\t\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttracks.push( track );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\t\t\treturn new THREE.AnimationClip( name, undefined, tracks );\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t\t * @param {number} nodeIndex\n\t\t * @return {Promise<THREE.Object3D>}\n\t\t */\n\t\tGLTFParser.prototype.loadNode = function ( nodeIndex ) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar extensions = this.extensions;\n\t\t\tvar parser = this;\n\n\t\t\tvar meshReferences = json.meshReferences;\n\t\t\tvar meshUses = json.meshUses;\n\n\t\t\tvar nodeDef = json.nodes[ nodeIndex ];\n\n\t\t\treturn ( function () {\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\t\t\t\tvar node;\n\n\t\t\t\t\t\tif ( meshReferences[ nodeDef.mesh ] > 1 ) {\n\n\t\t\t\t\t\t\tvar instanceNum = meshUses[ nodeDef.mesh ] ++;\n\n\t\t\t\t\t\t\tnode = mesh.clone();\n\t\t\t\t\t\t\tnode.name += '_instance_' + instanceNum;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnode = mesh;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\t\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\t\t\t\tfor ( var i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn node;\n\n\t\t\t\t\t} ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.extensions\n\t\t\t\t\t&& nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ]\n\t\t\t\t\t&& nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.getDependency( 'light', nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all( pending );\n\n\t\t\t}() ).then( function ( objects ) {\n\n\t\t\t\tvar node;\n\n\t\t\t\t// .isBone isn't in glTF spec. See .markDefs\n\t\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\t\tnode = new THREE.Bone();\n\n\t\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\t\tnode = new THREE.Group();\n\n\t\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode = new THREE.Object3D();\n\n\t\t\t\t}\n\n\t\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\t\tnode.name = THREE.PropertyBinding.sanitizeNodeName( nodeDef.name );\n\n\t\t\t\t}\n\n\t\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn node;\n\n\t\t\t} );\n\n\t\t};\n\n\t\t/**\n\t\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t\t * @param {number} sceneIndex\n\t\t * @return {Promise<THREE.Group>}\n\t\t */\n\t\tGLTFParser.prototype.loadScene = function () {\n\n\t\t\t// scene node hierachy builder\n\n\t\t\tfunction buildNodeHierachy( nodeId, parentObject, json, parser ) {\n\n\t\t\t\tvar nodeDef = json.nodes[ nodeId ];\n\n\t\t\t\treturn parser.getDependency( 'node', nodeId ).then( function ( node ) {\n\n\t\t\t\t\tif ( nodeDef.skin === undefined ) return node;\n\n\t\t\t\t\t// build skeleton here as well\n\n\t\t\t\t\tvar skinEntry;\n\n\t\t\t\t\treturn parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {\n\n\t\t\t\t\t\tskinEntry = skin;\n\n\t\t\t\t\t\tvar pendingJoints = [];\n\n\t\t\t\t\t\tfor ( var i = 0, il = skinEntry.joints.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tpendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn Promise.all( pendingJoints );\n\n\t\t\t\t\t} ).then( function ( jointNodes ) {\n\n\t\t\t\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\t\t\t\tif ( ! mesh.isMesh ) return;\n\n\t\t\t\t\t\t\tvar bones = [];\n\t\t\t\t\t\t\tvar boneInverses = [];\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = jointNodes.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar jointNode = jointNodes[ j ];\n\n\t\t\t\t\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\t\t\t\t\tvar mat = new THREE.Matrix4();\n\n\t\t\t\t\t\t\t\t\tif ( skinEntry.inverseBindMatrices !== undefined ) {\n\n\t\t\t\t\t\t\t\t\t\tmat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[ j ] );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmesh.bind( new THREE.Skeleton( bones, boneInverses ), mesh.matrixWorld );\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\treturn node;\n\n\t\t\t\t\t} );\n\n\t\t\t\t} ).then( function ( node ) {\n\n\t\t\t\t\t// build node hierachy\n\n\t\t\t\t\tparentObject.add( node );\n\n\t\t\t\t\tvar pending = [];\n\n\t\t\t\t\tif ( nodeDef.children ) {\n\n\t\t\t\t\t\tvar children = nodeDef.children;\n\n\t\t\t\t\t\tfor ( var i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tvar child = children[ i ];\n\t\t\t\t\t\t\tpending.push( buildNodeHierachy( child, node, json, parser ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Promise.all( pending );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn function loadScene( sceneIndex ) {\n\n\t\t\t\tvar json = this.json;\n\t\t\t\tvar extensions = this.extensions;\n\t\t\t\tvar sceneDef = this.json.scenes[ sceneIndex ];\n\t\t\t\tvar parser = this;\n\n\t\t\t\t// Loader returns Group, not Scene.\n\t\t\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\t\t\tvar scene = new THREE.Group();\n\t\t\t\tif ( sceneDef.name ) scene.name = sceneDef.name;\n\n\t\t\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\t\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\t\t\tvar nodeIds = sceneDef.nodes || [];\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tfor ( var i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\t\t\tpending.push( buildNodeHierachy( nodeIds[ i ], scene, json, parser ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\t\t\treturn scene;\n\n\t\t\t\t} );\n\n\t\t\t};\n\n\t\t}();\n\n\t\treturn GLTFLoader;\n\n\t} )();\n\t\n\treturn THREE.GLTFLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/MTLLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * Loads a Wavefront .mtl file specifying materials\n\t *\n\t * @author angelxuanchang\n\t */\n\n\tTHREE.MTLLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.MTLLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.MTLLoader,\n\n\t\t/**\n\t\t * Loads and parses a MTL asset from a URL.\n\t\t *\n\t\t * @param {String} url - URL to the MTL file.\n\t\t * @param {Function} [onLoad] - Callback invoked with the loaded object.\n\t\t * @param {Function} [onProgress] - Callback for download progress.\n\t\t * @param {Function} [onError] - Callback for download errors.\n\t\t *\n\t\t * @see setPath setResourcePath\n\t\t *\n\t\t * @note In order for relative texture references to resolve correctly\n\t\t * you must call setResourcePath() explicitly prior to load.\n\t\t */\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( this.path === '' ) ? THREE.LoaderUtils.extractUrlBase( url ) : this.path;\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetMaterialOptions: function ( value ) {\n\n\t\t\tthis.materialOptions = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\t/**\n\t\t * Parses a MTL file.\n\t\t *\n\t\t * @param {String} text - Content of MTL file\n\t\t * @return {THREE.MTLLoader.MaterialCreator}\n\t\t *\n\t\t * @see setPath setResourcePath\n\t\t *\n\t\t * @note In order for relative texture references to resolve correctly\n\t\t * you must call setResourcePath() explicitly prior to parse.\n\t\t */\n\t\tparse: function ( text, path ) {\n\n\t\t\tvar lines = text.split( '\\n' );\n\t\t\tvar info = {};\n\t\t\tvar delimiter_pattern = /\\s+/;\n\t\t\tvar materialsInfo = {};\n\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tvar line = lines[ i ];\n\t\t\t\tline = line.trim();\n\n\t\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\n\n\t\t\t\t\t// Blank line or comment ignore\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar pos = line.indexOf( ' ' );\n\n\t\t\t\tvar key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;\n\t\t\t\tkey = key.toLowerCase();\n\n\t\t\t\tvar value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';\n\t\t\t\tvalue = value.trim();\n\n\t\t\t\tif ( key === 'newmtl' ) {\n\n\t\t\t\t\t// New material\n\n\t\t\t\t\tinfo = { name: value };\n\t\t\t\t\tmaterialsInfo[ value ] = info;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke' ) {\n\n\t\t\t\t\t\tvar ss = value.split( delimiter_pattern, 3 );\n\t\t\t\t\t\tinfo[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tinfo[ key ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar materialCreator = new THREE.MTLLoader.MaterialCreator( this.resourcePath || path, this.materialOptions );\n\t\t\tmaterialCreator.setCrossOrigin( this.crossOrigin );\n\t\t\tmaterialCreator.setManager( this.manager );\n\t\t\tmaterialCreator.setMaterials( materialsInfo );\n\t\t\treturn materialCreator;\n\n\t\t}\n\n\t} );\n\n\n\t/**\n\t * Create a new THREE.MTLLoader.MaterialCreator\n\t * @param baseUrl - Url relative to which textures are loaded\n\t * @param options - Set of options on how to construct the materials\n\t *                  side: Which side to apply the material\n\t *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide\n\t *                  wrap: What type of wrapping to apply for textures\n\t *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n\t *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n\t *                                Default: false, assumed to be already normalized\n\t *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n\t *                                  Default: false\n\t * @constructor\n\t */\n\n\tTHREE.MTLLoader.MaterialCreator = function ( baseUrl, options ) {\n\n\t\tthis.baseUrl = baseUrl || '';\n\t\tthis.options = options;\n\t\tthis.materialsInfo = {};\n\t\tthis.materials = {};\n\t\tthis.materialsArray = [];\n\t\tthis.nameLookup = {};\n\n\t\tthis.side = ( this.options && this.options.side ) ? this.options.side : THREE.FrontSide;\n\t\tthis.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : THREE.RepeatWrapping;\n\n\t};\n\n\tTHREE.MTLLoader.MaterialCreator.prototype = {\n\n\t\tconstructor: THREE.MTLLoader.MaterialCreator,\n\n\t\tcrossOrigin: 'anonymous',\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetManager: function ( value ) {\n\n\t\t\tthis.manager = value;\n\n\t\t},\n\n\t\tsetMaterials: function ( materialsInfo ) {\n\n\t\t\tthis.materialsInfo = this.convert( materialsInfo );\n\t\t\tthis.materials = {};\n\t\t\tthis.materialsArray = [];\n\t\t\tthis.nameLookup = {};\n\n\t\t},\n\n\t\tconvert: function ( materialsInfo ) {\n\n\t\t\tif ( ! this.options ) return materialsInfo;\n\n\t\t\tvar converted = {};\n\n\t\t\tfor ( var mn in materialsInfo ) {\n\n\t\t\t\t// Convert materials info into normalized form based on options\n\n\t\t\t\tvar mat = materialsInfo[ mn ];\n\n\t\t\t\tvar covmat = {};\n\n\t\t\t\tconverted[ mn ] = covmat;\n\n\t\t\t\tfor ( var prop in mat ) {\n\n\t\t\t\t\tvar save = true;\n\t\t\t\t\tvar value = mat[ prop ];\n\t\t\t\t\tvar lprop = prop.toLowerCase();\n\n\t\t\t\t\tswitch ( lprop ) {\n\n\t\t\t\t\t\tcase 'kd':\n\t\t\t\t\t\tcase 'ka':\n\t\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\t\tif ( this.options && this.options.normalizeRGB ) {\n\n\t\t\t\t\t\t\t\tvalue = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( this.options && this.options.ignoreZeroRGBs ) {\n\n\t\t\t\t\t\t\t\tif ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {\n\n\t\t\t\t\t\t\t\t\t// ignore\n\n\t\t\t\t\t\t\t\t\tsave = false;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( save ) {\n\n\t\t\t\t\t\tcovmat[ lprop ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn converted;\n\n\t\t},\n\n\t\tpreload: function () {\n\n\t\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\t\tthis.create( mn );\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetIndex: function ( materialName ) {\n\n\t\t\treturn this.nameLookup[ materialName ];\n\n\t\t},\n\n\t\tgetAsArray: function () {\n\n\t\t\tvar index = 0;\n\n\t\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\t\tthis.materialsArray[ index ] = this.create( mn );\n\t\t\t\tthis.nameLookup[ mn ] = index;\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\treturn this.materialsArray;\n\n\t\t},\n\n\t\tcreate: function ( materialName ) {\n\n\t\t\tif ( this.materials[ materialName ] === undefined ) {\n\n\t\t\t\tthis.createMaterial_( materialName );\n\n\t\t\t}\n\n\t\t\treturn this.materials[ materialName ];\n\n\t\t},\n\n\t\tcreateMaterial_: function ( materialName ) {\n\n\t\t\t// Create material\n\n\t\t\tvar scope = this;\n\t\t\tvar mat = this.materialsInfo[ materialName ];\n\t\t\tvar params = {\n\n\t\t\t\tname: materialName,\n\t\t\t\tside: this.side\n\n\t\t\t};\n\n\t\t\tfunction resolveURL( baseUrl, url ) {\n\n\t\t\t\tif ( typeof url !== 'string' || url === '' )\n\t\t\t\t\treturn '';\n\n\t\t\t\t// Absolute URL\n\t\t\t\tif ( /^https?:\\/\\//i.test( url ) ) return url;\n\n\t\t\t\treturn baseUrl + url;\n\n\t\t\t}\n\n\t\t\tfunction setMapForType( mapType, value ) {\n\n\t\t\t\tif ( params[ mapType ] ) return; // Keep the first encountered texture\n\n\t\t\t\tvar texParams = scope.getTextureParams( value, params );\n\t\t\t\tvar map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );\n\n\t\t\t\tmap.repeat.copy( texParams.scale );\n\t\t\t\tmap.offset.copy( texParams.offset );\n\n\t\t\t\tmap.wrapS = scope.wrap;\n\t\t\t\tmap.wrapT = scope.wrap;\n\n\t\t\t\tparams[ mapType ] = map;\n\n\t\t\t}\n\n\t\t\tfor ( var prop in mat ) {\n\n\t\t\t\tvar value = mat[ prop ];\n\t\t\t\tvar n;\n\n\t\t\t\tif ( value === '' ) continue;\n\n\t\t\t\tswitch ( prop.toLowerCase() ) {\n\n\t\t\t\t\t// Ns is material specular exponent\n\n\t\t\t\t\tcase 'kd':\n\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\tparams.color = new THREE.Color().fromArray( value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\n\t\t\t\t\t\tparams.specular = new THREE.Color().fromArray( value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ke':\n\n\t\t\t\t\t\t// Emissive using RGB values\n\t\t\t\t\t\tparams.emissive = new THREE.Color().fromArray( value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'map_kd':\n\n\t\t\t\t\t\t// Diffuse texture map\n\n\t\t\t\t\t\tsetMapForType( \"map\", value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'map_ks':\n\n\t\t\t\t\t\t// Specular map\n\n\t\t\t\t\t\tsetMapForType( \"specularMap\", value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'map_ke':\n\n\t\t\t\t\t\t// Emissive map\n\n\t\t\t\t\t\tsetMapForType( \"emissiveMap\", value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'norm':\n\n\t\t\t\t\t\tsetMapForType( \"normalMap\", value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'map_bump':\n\t\t\t\t\tcase 'bump':\n\n\t\t\t\t\t\t// Bump texture map\n\n\t\t\t\t\t\tsetMapForType( \"bumpMap\", value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'map_d':\n\n\t\t\t\t\t\t// Alpha map\n\n\t\t\t\t\t\tsetMapForType( \"alphaMap\", value );\n\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ns':\n\n\t\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\n\t\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n\t\t\t\t\t\tparams.shininess = parseFloat( value );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tn = parseFloat( value );\n\n\t\t\t\t\t\tif ( n < 1 ) {\n\n\t\t\t\t\t\t\tparams.opacity = n;\n\t\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'tr':\n\t\t\t\t\t\tn = parseFloat( value );\n\n\t\t\t\t\t\tif ( this.options && this.options.invertTrProperty ) n = 1 - n;\n\n\t\t\t\t\t\tif ( n > 0 ) {\n\n\t\t\t\t\t\t\tparams.opacity = 1 - n;\n\t\t\t\t\t\t\tparams.transparent = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.materials[ materialName ] = new THREE.MeshPhongMaterial( params );\n\t\t\treturn this.materials[ materialName ];\n\n\t\t},\n\n\t\tgetTextureParams: function ( value, matParams ) {\n\n\t\t\tvar texParams = {\n\n\t\t\t\tscale: new THREE.Vector2( 1, 1 ),\n\t\t\t\toffset: new THREE.Vector2( 0, 0 )\n\n\t\t\t };\n\n\t\t\tvar items = value.split( /\\s+/ );\n\t\t\tvar pos;\n\n\t\t\tpos = items.indexOf( '-bm' );\n\n\t\t\tif ( pos >= 0 ) {\n\n\t\t\t\tmatParams.bumpScale = parseFloat( items[ pos + 1 ] );\n\t\t\t\titems.splice( pos, 2 );\n\n\t\t\t}\n\n\t\t\tpos = items.indexOf( '-s' );\n\n\t\t\tif ( pos >= 0 ) {\n\n\t\t\t\ttexParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t\t}\n\n\t\t\tpos = items.indexOf( '-o' );\n\n\t\t\tif ( pos >= 0 ) {\n\n\t\t\t\ttexParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );\n\t\t\t\titems.splice( pos, 4 ); // we expect 3 parameters here!\n\n\t\t\t}\n\n\t\t\ttexParams.url = items.join( ' ' ).trim();\n\t\t\treturn texParams;\n\n\t\t},\n\n\t\tloadTexture: function ( url, mapping, onLoad, onProgress, onError ) {\n\n\t\t\tvar texture;\n\t\t\tvar manager = ( this.manager !== undefined ) ? this.manager : THREE.DefaultLoadingManager;\n\t\t\tvar loader = manager.getHandler( url );\n\n\t\t\tif ( loader === null ) {\n\n\t\t\t\tloader = new THREE.TextureLoader( manager );\n\n\t\t\t}\n\n\t\t\tif ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );\n\t\t\ttexture = loader.load( url, onLoad, onProgress, onError );\n\n\t\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\t\treturn texture;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.MTLLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/OBJLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tTHREE.OBJLoader = ( function () {\n\n\t\t// o object_name | g group_name\n\t\tvar object_pattern = /^[og]\\s*(.+)?/;\n\t\t// mtllib file_reference\n\t\tvar material_library_pattern = /^mtllib /;\n\t\t// usemtl material_name\n\t\tvar material_use_pattern = /^usemtl /;\n\t\t// usemap map_name\n\t\tvar map_use_pattern = /^usemap /;\n\n\t\tfunction ParserState() {\n\n\t\t\tvar state = {\n\t\t\t\tobjects: [],\n\t\t\t\tobject: {},\n\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tcolors: [],\n\t\t\t\tuvs: [],\n\n\t\t\t\tmaterials: {},\n\t\t\t\tmaterialLibraries: [],\n\n\t\t\t\tstartObject: function ( name, fromDeclaration ) {\n\n\t\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\n\t\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\n\t\t\t\t\tif ( this.object && this.object.fromDeclaration === false ) {\n\n\t\t\t\t\t\tthis.object.name = name;\n\t\t\t\t\t\tthis.object.fromDeclaration = ( fromDeclaration !== false );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );\n\n\t\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\t\t\tthis.object._finalize( true );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.object = {\n\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\tfromDeclaration: ( fromDeclaration !== false ),\n\n\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\tvertices: [],\n\t\t\t\t\t\t\tnormals: [],\n\t\t\t\t\t\t\tcolors: [],\n\t\t\t\t\t\t\tuvs: []\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmaterials: [],\n\t\t\t\t\t\tsmooth: true,\n\n\t\t\t\t\t\tstartMaterial: function ( name, libraries ) {\n\n\t\t\t\t\t\t\tvar previous = this._finalize( false );\n\n\t\t\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\n\t\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\n\t\t\t\t\t\t\tif ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {\n\n\t\t\t\t\t\t\t\tthis.materials.splice( previous.index, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar material = {\n\t\t\t\t\t\t\t\tindex: this.materials.length,\n\t\t\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\t\t\tmtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),\n\t\t\t\t\t\t\t\tsmooth: ( previous !== undefined ? previous.smooth : this.smooth ),\n\t\t\t\t\t\t\t\tgroupStart: ( previous !== undefined ? previous.groupEnd : 0 ),\n\t\t\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\t\t\tinherited: false,\n\n\t\t\t\t\t\t\t\tclone: function ( index ) {\n\n\t\t\t\t\t\t\t\t\tvar cloned = {\n\t\t\t\t\t\t\t\t\t\tindex: ( typeof index === 'number' ? index : this.index ),\n\t\t\t\t\t\t\t\t\t\tname: this.name,\n\t\t\t\t\t\t\t\t\t\tmtllib: this.mtllib,\n\t\t\t\t\t\t\t\t\t\tsmooth: this.smooth,\n\t\t\t\t\t\t\t\t\t\tgroupStart: 0,\n\t\t\t\t\t\t\t\t\t\tgroupEnd: - 1,\n\t\t\t\t\t\t\t\t\t\tgroupCount: - 1,\n\t\t\t\t\t\t\t\t\t\tinherited: false\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind( cloned );\n\t\t\t\t\t\t\t\t\treturn cloned;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tthis.materials.push( material );\n\n\t\t\t\t\t\t\treturn material;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcurrentMaterial: function () {\n\n\t\t\t\t\t\t\tif ( this.materials.length > 0 ) {\n\n\t\t\t\t\t\t\t\treturn this.materials[ this.materials.length - 1 ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn undefined;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t_finalize: function ( end ) {\n\n\t\t\t\t\t\t\tvar lastMultiMaterial = this.currentMaterial();\n\t\t\t\t\t\t\tif ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {\n\n\t\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n\t\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n\t\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\t\t\t\t\t\t\tif ( end && this.materials.length > 1 ) {\n\n\t\t\t\t\t\t\t\tfor ( var mi = this.materials.length - 1; mi >= 0; mi -- ) {\n\n\t\t\t\t\t\t\t\t\tif ( this.materials[ mi ].groupCount <= 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tthis.materials.splice( mi, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\n\t\t\t\t\t\t\tif ( end && this.materials.length === 0 ) {\n\n\t\t\t\t\t\t\t\tthis.materials.push( {\n\t\t\t\t\t\t\t\t\tname: '',\n\t\t\t\t\t\t\t\t\tsmooth: this.smooth\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn lastMultiMaterial;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Inherit previous objects material.\n\t\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\n\t\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\n\t\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\n\t\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n\t\t\t\t\tif ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {\n\n\t\t\t\t\t\tvar declared = previousMaterial.clone( 0 );\n\t\t\t\t\t\tdeclared.inherited = true;\n\t\t\t\t\t\tthis.object.materials.push( declared );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.objects.push( this.object );\n\n\t\t\t\t},\n\n\t\t\t\tfinalize: function () {\n\n\t\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\t\t\tthis.object._finalize( true );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tparseVertexIndex: function ( value, len ) {\n\n\t\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t\t\t},\n\n\t\t\t\tparseNormalIndex: function ( value, len ) {\n\n\t\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t\t\t},\n\n\t\t\t\tparseUVIndex: function ( value, len ) {\n\n\t\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 2 ) * 2;\n\n\t\t\t\t},\n\n\t\t\t\taddVertex: function ( a, b, c ) {\n\n\t\t\t\t\tvar src = this.vertices;\n\t\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t\t},\n\n\t\t\t\taddVertexPoint: function ( a ) {\n\n\t\t\t\t\tvar src = this.vertices;\n\t\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t\t\t},\n\n\t\t\t\taddVertexLine: function ( a ) {\n\n\t\t\t\t\tvar src = this.vertices;\n\t\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\n\t\t\t\t},\n\n\t\t\t\taddNormal: function ( a, b, c ) {\n\n\t\t\t\t\tvar src = this.normals;\n\t\t\t\t\tvar dst = this.object.geometry.normals;\n\n\t\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t\t},\n\n\t\t\t\taddColor: function ( a, b, c ) {\n\n\t\t\t\t\tvar src = this.colors;\n\t\t\t\t\tvar dst = this.object.geometry.colors;\n\n\t\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t\t},\n\n\t\t\t\taddUV: function ( a, b, c ) {\n\n\t\t\t\t\tvar src = this.uvs;\n\t\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\t\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ] );\n\t\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ] );\n\n\t\t\t\t},\n\n\t\t\t\taddUVLine: function ( a ) {\n\n\t\t\t\t\tvar src = this.uvs;\n\t\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ] );\n\n\t\t\t\t},\n\n\t\t\t\taddFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {\n\n\t\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\t\tvar ia = this.parseVertexIndex( a, vLen );\n\t\t\t\t\tvar ib = this.parseVertexIndex( b, vLen );\n\t\t\t\t\tvar ic = this.parseVertexIndex( c, vLen );\n\n\t\t\t\t\tthis.addVertex( ia, ib, ic );\n\n\t\t\t\t\tif ( this.colors.length > 0 ) {\n\n\t\t\t\t\t\tthis.addColor( ia, ib, ic );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ua !== undefined && ua !== '' ) {\n\n\t\t\t\t\t\tvar uvLen = this.uvs.length;\n\t\t\t\t\t\tia = this.parseUVIndex( ua, uvLen );\n\t\t\t\t\t\tib = this.parseUVIndex( ub, uvLen );\n\t\t\t\t\t\tic = this.parseUVIndex( uc, uvLen );\n\t\t\t\t\t\tthis.addUV( ia, ib, ic );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( na !== undefined && na !== '' ) {\n\n\t\t\t\t\t\t// Normals are many times the same. If so, skip function call and parseInt.\n\t\t\t\t\t\tvar nLen = this.normals.length;\n\t\t\t\t\t\tia = this.parseNormalIndex( na, nLen );\n\n\t\t\t\t\t\tib = na === nb ? ia : this.parseNormalIndex( nb, nLen );\n\t\t\t\t\t\tic = na === nc ? ia : this.parseNormalIndex( nc, nLen );\n\n\t\t\t\t\t\tthis.addNormal( ia, ib, ic );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\taddPointGeometry: function ( vertices ) {\n\n\t\t\t\t\tthis.object.geometry.type = 'Points';\n\n\t\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\t\t\tthis.addVertexPoint( this.parseVertexIndex( vertices[ vi ], vLen ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\taddLineGeometry: function ( vertices, uvs ) {\n\n\t\t\t\t\tthis.object.geometry.type = 'Line';\n\n\t\t\t\t\tvar vLen = this.vertices.length;\n\t\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\t\t\tthis.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {\n\n\t\t\t\t\t\tthis.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tstate.startObject( '', false );\n\n\t\t\treturn state;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction OBJLoader( manager ) {\n\n\t\t\tTHREE.Loader.call( this, manager );\n\n\t\t\tthis.materials = null;\n\n\t\t}\n\n\t\tOBJLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\t\tconstructor: OBJLoader,\n\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\t\tloader.setPath( this.path );\n\t\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t},\n\n\t\t\tsetMaterials: function ( materials ) {\n\n\t\t\t\tthis.materials = materials;\n\n\t\t\t\treturn this;\n\n\t\t\t},\n\n\t\t\tparse: function ( text ) {\n\n\t\t\t\tvar state = new ParserState();\n\n\t\t\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( text.indexOf( '\\\\\\n' ) !== - 1 ) {\n\n\t\t\t\t\t// join lines separated by a line continuation character (\\)\n\t\t\t\t\ttext = text.replace( /\\\\\\n/g, '' );\n\n\t\t\t\t}\n\n\t\t\t\tvar lines = text.split( '\\n' );\n\t\t\t\tvar line = '', lineFirstChar = '';\n\t\t\t\tvar lineLength = 0;\n\t\t\t\tvar result = [];\n\n\t\t\t\t// Faster to just trim left side of the line. Use if available.\n\t\t\t\tvar trimLeft = ( typeof ''.trimLeft === 'function' );\n\n\t\t\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\t\tline = lines[ i ];\n\n\t\t\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\n\n\t\t\t\t\tlineLength = line.length;\n\n\t\t\t\t\tif ( lineLength === 0 ) continue;\n\n\t\t\t\t\tlineFirstChar = line.charAt( 0 );\n\n\t\t\t\t\t// @todo invoke passed in handler if any\n\t\t\t\t\tif ( lineFirstChar === '#' ) continue;\n\n\t\t\t\t\tif ( lineFirstChar === 'v' ) {\n\n\t\t\t\t\t\tvar data = line.split( /\\s+/ );\n\n\t\t\t\t\t\tswitch ( data[ 0 ] ) {\n\n\t\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\t\tstate.vertices.push(\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif ( data.length >= 7 ) {\n\n\t\t\t\t\t\t\t\t\tstate.colors.push(\n\t\t\t\t\t\t\t\t\t\tparseFloat( data[ 4 ] ),\n\t\t\t\t\t\t\t\t\t\tparseFloat( data[ 5 ] ),\n\t\t\t\t\t\t\t\t\t\tparseFloat( data[ 6 ] )\n\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'vn':\n\t\t\t\t\t\t\t\tstate.normals.push(\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 3 ] )\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'vt':\n\t\t\t\t\t\t\t\tstate.uvs.push(\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 1 ] ),\n\t\t\t\t\t\t\t\t\tparseFloat( data[ 2 ] )\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( lineFirstChar === 'f' ) {\n\n\t\t\t\t\t\tvar lineData = line.substr( 1 ).trim();\n\t\t\t\t\t\tvar vertexData = lineData.split( /\\s+/ );\n\t\t\t\t\t\tvar faceVertices = [];\n\n\t\t\t\t\t\t// Parse the face vertex data into an easy to work with format\n\n\t\t\t\t\t\tfor ( var j = 0, jl = vertexData.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar vertex = vertexData[ j ];\n\n\t\t\t\t\t\t\tif ( vertex.length > 0 ) {\n\n\t\t\t\t\t\t\t\tvar vertexParts = vertex.split( '/' );\n\t\t\t\t\t\t\t\tfaceVertices.push( vertexParts );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n\t\t\t\t\t\tvar v1 = faceVertices[ 0 ];\n\n\t\t\t\t\t\tfor ( var j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar v2 = faceVertices[ j ];\n\t\t\t\t\t\t\tvar v3 = faceVertices[ j + 1 ];\n\n\t\t\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\t\t\tv1[ 0 ], v2[ 0 ], v3[ 0 ],\n\t\t\t\t\t\t\t\tv1[ 1 ], v2[ 1 ], v3[ 1 ],\n\t\t\t\t\t\t\t\tv1[ 2 ], v2[ 2 ], v3[ 2 ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( lineFirstChar === 'l' ) {\n\n\t\t\t\t\t\tvar lineParts = line.substring( 1 ).trim().split( \" \" );\n\t\t\t\t\t\tvar lineVertices = [], lineUVs = [];\n\n\t\t\t\t\t\tif ( line.indexOf( \"/\" ) === - 1 ) {\n\n\t\t\t\t\t\t\tlineVertices = lineParts;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {\n\n\t\t\t\t\t\t\t\tvar parts = lineParts[ li ].split( \"/\" );\n\n\t\t\t\t\t\t\t\tif ( parts[ 0 ] !== \"\" ) lineVertices.push( parts[ 0 ] );\n\t\t\t\t\t\t\t\tif ( parts[ 1 ] !== \"\" ) lineUVs.push( parts[ 1 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate.addLineGeometry( lineVertices, lineUVs );\n\n\t\t\t\t\t} else if ( lineFirstChar === 'p' ) {\n\n\t\t\t\t\t\tvar lineData = line.substr( 1 ).trim();\n\t\t\t\t\t\tvar pointData = lineData.split( \" \" );\n\n\t\t\t\t\t\tstate.addPointGeometry( pointData );\n\n\t\t\t\t\t} else if ( ( result = object_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t// o object_name\n\t\t\t\t\t\t// or\n\t\t\t\t\t\t// g group_name\n\n\t\t\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t\t\t// var name = result[ 0 ].substr( 1 ).trim();\n\t\t\t\t\t\tvar name = ( \" \" + result[ 0 ].substr( 1 ).trim() ).substr( 1 );\n\n\t\t\t\t\t\tstate.startObject( name );\n\n\t\t\t\t\t} else if ( material_use_pattern.test( line ) ) {\n\n\t\t\t\t\t\t// material\n\n\t\t\t\t\t\tstate.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );\n\n\t\t\t\t\t} else if ( material_library_pattern.test( line ) ) {\n\n\t\t\t\t\t\t// mtl file\n\n\t\t\t\t\t\tstate.materialLibraries.push( line.substring( 7 ).trim() );\n\n\t\t\t\t\t} else if ( map_use_pattern.test( line ) ) {\n\n\t\t\t\t\t\t// the line is parsed but ignored since the loader assumes textures are defined MTL files\n\t\t\t\t\t\t// (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n\n\t\t\t\t\t\tconsole.warn( 'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.' );\n\n\t\t\t\t\t} else if ( lineFirstChar === 's' ) {\n\n\t\t\t\t\t\tresult = line.split( ' ' );\n\n\t\t\t\t\t\t// smooth shading\n\n\t\t\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n\t\t\t\t\t\t// but does not define a usemtl for each face set.\n\t\t\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n\t\t\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n\t\t\t\t\t\t// where explicit usemtl defines geometry groups.\n\t\t\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * http://paulbourke.net/dataformats/obj/\n\t\t\t\t\t\t * or\n\t\t\t\t\t\t * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n\t\t\t\t\t\t * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n\t\t\t\t\t\t * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n\t\t\t\t\t\t * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n\t\t\t\t\t\t * than 0.\"\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ( result.length > 1 ) {\n\n\t\t\t\t\t\t\tvar value = result[ 1 ].trim().toLowerCase();\n\t\t\t\t\t\t\tstate.object.smooth = ( value !== '0' && value !== 'off' );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// ZBrush can produce \"s\" lines #11707\n\t\t\t\t\t\t\tstate.object.smooth = true;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar material = state.object.currentMaterial();\n\t\t\t\t\t\tif ( material ) material.smooth = state.object.smooth;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Handle null terminated files without exception\n\t\t\t\t\t\tif ( line === '\\0' ) continue;\n\n\t\t\t\t\t\tconsole.warn( 'THREE.OBJLoader: Unexpected line: \"' + line + '\"' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tstate.finalize();\n\n\t\t\t\tvar container = new THREE.Group();\n\t\t\t\tcontainer.materialLibraries = [].concat( state.materialLibraries );\n\n\t\t\t\tfor ( var i = 0, l = state.objects.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar object = state.objects[ i ];\n\t\t\t\t\tvar geometry = object.geometry;\n\t\t\t\t\tvar materials = object.materials;\n\t\t\t\t\tvar isLine = ( geometry.type === 'Line' );\n\t\t\t\t\tvar isPoints = ( geometry.type === 'Points' );\n\t\t\t\t\tvar hasVertexColors = false;\n\n\t\t\t\t\t// Skip o/g line declarations that did not follow with any faces\n\t\t\t\t\tif ( geometry.vertices.length === 0 ) continue;\n\n\t\t\t\t\tvar buffergeometry = new THREE.BufferGeometry();\n\n\t\t\t\t\tbuffergeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( geometry.vertices, 3 ) );\n\n\t\t\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( geometry.normals, 3 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuffergeometry.computeVertexNormals();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\t\t\t\thasVertexColors = true;\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( geometry.colors, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\t\t\t\tbuffergeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( geometry.uvs, 2 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create materials\n\n\t\t\t\t\tvar createdMaterials = [];\n\n\t\t\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\t\tvar sourceMaterial = materials[ mi ];\n\t\t\t\t\t\tvar materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;\n\t\t\t\t\t\tvar material = state.materials[ materialHash ];\n\n\t\t\t\t\t\tif ( this.materials !== null ) {\n\n\t\t\t\t\t\t\tmaterial = this.materials.create( sourceMaterial.name );\n\n\t\t\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\t\t\t\t\t\t\tif ( isLine && material && ! ( material instanceof THREE.LineBasicMaterial ) ) {\n\n\t\t\t\t\t\t\t\tvar materialLine = new THREE.LineBasicMaterial();\n\t\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call( materialLine, material );\n\t\t\t\t\t\t\t\tmaterialLine.color.copy( material.color );\n\t\t\t\t\t\t\t\tmaterial = materialLine;\n\n\t\t\t\t\t\t\t} else if ( isPoints && material && ! ( material instanceof THREE.PointsMaterial ) ) {\n\n\t\t\t\t\t\t\t\tvar materialPoints = new THREE.PointsMaterial( { size: 10, sizeAttenuation: false } );\n\t\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call( materialPoints, material );\n\t\t\t\t\t\t\t\tmaterialPoints.color.copy( material.color );\n\t\t\t\t\t\t\t\tmaterialPoints.map = material.map;\n\t\t\t\t\t\t\t\tmaterial = materialPoints;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( material === undefined ) {\n\n\t\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial();\n\n\t\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\t\tmaterial = new THREE.PointsMaterial( { size: 1, sizeAttenuation: false } );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaterial.name = sourceMaterial.name;\n\t\t\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;\n\t\t\t\t\t\t\tmaterial.vertexColors = hasVertexColors;\n\n\t\t\t\t\t\t\tstate.materials[ materialHash ] = material;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcreatedMaterials.push( material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create mesh\n\n\t\t\t\t\tvar mesh;\n\n\t\t\t\t\tif ( createdMaterials.length > 1 ) {\n\n\t\t\t\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {\n\n\t\t\t\t\t\t\tvar sourceMaterial = materials[ mi ];\n\t\t\t\t\t\t\tbuffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\tmesh = new THREE.LineSegments( buffergeometry, createdMaterials );\n\n\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\tmesh = new THREE.Points( buffergeometry, createdMaterials );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new THREE.Mesh( buffergeometry, createdMaterials );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\t\tmesh = new THREE.LineSegments( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\t\tmesh = new THREE.Points( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new THREE.Mesh( buffergeometry, createdMaterials[ 0 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.name = object.name;\n\n\t\t\t\t\tcontainer.add( mesh );\n\n\t\t\t\t}\n\n\t\t\t\treturn container;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn OBJLoader;\n\n\t} )();\n\t\n\treturn THREE.OBJLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/PCDLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Filipe Caixeta / http://filipecaixeta.com.br\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Description: A THREE loader for PCD ascii and binary files.\n\t */\n\n\tTHREE.PCDLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.littleEndian = true;\n\n\t};\n\n\n\tTHREE.PCDLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.PCDLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( data ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( scope.parse( data, url ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow e;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data, url ) {\n\n\t\t\t// from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n\n\t\t\tfunction decompressLZF( inData, outLength ) {\n\n\t\t\t\tvar inLength = inData.length;\n\t\t\t\tvar outData = new Uint8Array( outLength );\n\t\t\t\tvar inPtr = 0;\n\t\t\t\tvar outPtr = 0;\n\t\t\t\tvar ctrl;\n\t\t\t\tvar len;\n\t\t\t\tvar ref;\n\t\t\t\tdo {\n\n\t\t\t\t\tctrl = inData[ inPtr ++ ];\n\t\t\t\t\tif ( ctrl < ( 1 << 5 ) ) {\n\n\t\t\t\t\t\tctrl ++;\n\t\t\t\t\t\tif ( outPtr + ctrl > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\t\tif ( inPtr + ctrl > inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\toutData[ outPtr ++ ] = inData[ inPtr ++ ];\n\n\t\t\t\t\t\t} while ( -- ctrl );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlen = ctrl >> 5;\n\t\t\t\t\t\tref = outPtr - ( ( ctrl & 0x1f ) << 8 ) - 1;\n\t\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\t\tif ( len === 7 ) {\n\n\t\t\t\t\t\t\tlen += inData[ inPtr ++ ];\n\t\t\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tref -= inData[ inPtr ++ ];\n\t\t\t\t\t\tif ( outPtr + len + 2 > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\t\tif ( ref < 0 ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\t\tif ( ref >= outPtr ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\toutData[ outPtr ++ ] = outData[ ref ++ ];\n\n\t\t\t\t\t\t} while ( -- len + 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} while ( inPtr < inLength );\n\n\t\t\t\treturn outData;\n\n\t\t\t}\n\n\t\t\tfunction parseHeader( data ) {\n\n\t\t\t\tvar PCDheader = {};\n\t\t\t\tvar result1 = data.search( /[\\r\\n]DATA\\s(\\S*)\\s/i );\n\t\t\t\tvar result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec( data.substr( result1 - 1 ) );\n\n\t\t\t\tPCDheader.data = result2[ 1 ];\n\t\t\t\tPCDheader.headerLen = result2[ 0 ].length + result1;\n\t\t\t\tPCDheader.str = data.substr( 0, PCDheader.headerLen );\n\n\t\t\t\t// remove comments\n\n\t\t\t\tPCDheader.str = PCDheader.str.replace( /\\#.*/gi, '' );\n\n\t\t\t\t// parse\n\n\t\t\t\tPCDheader.version = /VERSION (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.fields = /FIELDS (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.size = /SIZE (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.type = /TYPE (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.count = /COUNT (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.width = /WIDTH (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.height = /HEIGHT (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.viewpoint = /VIEWPOINT (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.points = /POINTS (.*)/i.exec( PCDheader.str );\n\n\t\t\t\t// evaluate\n\n\t\t\t\tif ( PCDheader.version !== null )\n\t\t\t\t\tPCDheader.version = parseFloat( PCDheader.version[ 1 ] );\n\n\t\t\t\tif ( PCDheader.fields !== null )\n\t\t\t\t\tPCDheader.fields = PCDheader.fields[ 1 ].split( ' ' );\n\n\t\t\t\tif ( PCDheader.type !== null )\n\t\t\t\t\tPCDheader.type = PCDheader.type[ 1 ].split( ' ' );\n\n\t\t\t\tif ( PCDheader.width !== null )\n\t\t\t\t\tPCDheader.width = parseInt( PCDheader.width[ 1 ] );\n\n\t\t\t\tif ( PCDheader.height !== null )\n\t\t\t\t\tPCDheader.height = parseInt( PCDheader.height[ 1 ] );\n\n\t\t\t\tif ( PCDheader.viewpoint !== null )\n\t\t\t\t\tPCDheader.viewpoint = PCDheader.viewpoint[ 1 ];\n\n\t\t\t\tif ( PCDheader.points !== null )\n\t\t\t\t\tPCDheader.points = parseInt( PCDheader.points[ 1 ], 10 );\n\n\t\t\t\tif ( PCDheader.points === null )\n\t\t\t\t\tPCDheader.points = PCDheader.width * PCDheader.height;\n\n\t\t\t\tif ( PCDheader.size !== null ) {\n\n\t\t\t\t\tPCDheader.size = PCDheader.size[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tif ( PCDheader.count !== null ) {\n\n\t\t\t\t\tPCDheader.count = PCDheader.count[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tPCDheader.count = [];\n\n\t\t\t\t\tfor ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tPCDheader.count.push( 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tPCDheader.offset = {};\n\n\t\t\t\tvar sizeSum = 0;\n\n\t\t\t\tfor ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = i;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = sizeSum;\n\t\t\t\t\t\tsizeSum += PCDheader.size[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// for binary only\n\n\t\t\t\tPCDheader.rowSize = sizeSum;\n\n\t\t\t\treturn PCDheader;\n\n\t\t\t}\n\n\t\t\tvar textData = THREE.LoaderUtils.decodeText( new Uint8Array( data ) );\n\n\t\t\t// parse header (always ascii format)\n\n\t\t\tvar PCDheader = parseHeader( textData );\n\n\t\t\t// parse data\n\n\t\t\tvar position = [];\n\t\t\tvar normal = [];\n\t\t\tvar color = [];\n\n\t\t\t// ascii\n\n\t\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\t\tvar offset = PCDheader.offset;\n\t\t\t\tvar pcdData = textData.substr( PCDheader.headerLen );\n\t\t\t\tvar lines = pcdData.split( '\\n' );\n\n\t\t\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( lines[ i ] === '' ) continue;\n\n\t\t\t\t\tvar line = lines[ i ].split( ' ' );\n\n\t\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\t\tposition.push( parseFloat( line[ offset.x ] ) );\n\t\t\t\t\t\tposition.push( parseFloat( line[ offset.y ] ) );\n\t\t\t\t\t\tposition.push( parseFloat( line[ offset.z ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\t\tvar rgb = parseFloat( line[ offset.rgb ] );\n\t\t\t\t\t\tvar r = ( rgb >> 16 ) & 0x0000ff;\n\t\t\t\t\t\tvar g = ( rgb >> 8 ) & 0x0000ff;\n\t\t\t\t\t\tvar b = ( rgb >> 0 ) & 0x0000ff;\n\t\t\t\t\t\tcolor.push( r / 255, g / 255, b / 255 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_x ] ) );\n\t\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_y ] ) );\n\t\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_z ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// binary-compressed\n\n\t\t\t// normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n\t\t\t// binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n\t\t\t// that requires a totally different parsing approach compared to non-compressed data\n\n\t\t\tif ( PCDheader.data === 'binary_compressed' ) {\n\n\t\t\t\tvar sizes = new Uint32Array( data.slice( PCDheader.headerLen, PCDheader.headerLen + 8 ) );\n\t\t\t\tvar compressedSize = sizes[ 0 ];\n\t\t\t\tvar decompressedSize = sizes[ 1 ];\n\t\t\t\tvar decompressed = decompressLZF( new Uint8Array( data, PCDheader.headerLen + 8, compressedSize ), decompressedSize );\n\t\t\t\tvar dataview = new DataView( decompressed.buffer );\n\n\t\t\t\tvar offset = PCDheader.offset;\n\n\t\t\t\tfor ( var i = 0; i < PCDheader.points; i ++ ) {\n\n\t\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.x ) + PCDheader.size[ 0 ] * i, this.littleEndian ) );\n\t\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.y ) + PCDheader.size[ 1 ] * i, this.littleEndian ) );\n\t\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.z ) + PCDheader.size[ 2 ] * i, this.littleEndian ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 0 ) / 255.0 );\n\t\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 1 ) / 255.0 );\n\t\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 2 ) / 255.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_x ) + PCDheader.size[ 4 ] * i, this.littleEndian ) );\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_y ) + PCDheader.size[ 5 ] * i, this.littleEndian ) );\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_z ) + PCDheader.size[ 6 ] * i, this.littleEndian ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// binary\n\n\t\t\tif ( PCDheader.data === 'binary' ) {\n\n\t\t\t\tvar dataview = new DataView( data, PCDheader.headerLen );\n\t\t\t\tvar offset = PCDheader.offset;\n\n\t\t\t\tfor ( var i = 0, row = 0; i < PCDheader.points; i ++, row += PCDheader.rowSize ) {\n\n\t\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.x, this.littleEndian ) );\n\t\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.y, this.littleEndian ) );\n\t\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.z, this.littleEndian ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 2 ) / 255.0 );\n\t\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 1 ) / 255.0 );\n\t\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 0 ) / 255.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_x, this.littleEndian ) );\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_y, this.littleEndian ) );\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_z, this.littleEndian ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tif ( position.length > 0 ) geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( position, 3 ) );\n\t\t\tif ( normal.length > 0 ) geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normal, 3 ) );\n\t\t\tif ( color.length > 0 ) geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( color, 3 ) );\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t// build material\n\n\t\t\tvar material = new THREE.PointsMaterial( { size: 0.005 } );\n\n\t\t\tif ( color.length > 0 ) {\n\n\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.color.setHex( Math.random() * 0xffffff );\n\n\t\t\t}\n\n\t\t\t// build point cloud\n\n\t\t\tvar mesh = new THREE.Points( geometry, material );\n\t\t\tvar name = url.split( '' ).reverse().join( '' );\n\t\t\tname = /([^\\/]*)/.exec( name );\n\t\t\tname = name[ 1 ].split( '' ).reverse().join( '' );\n\t\t\tmesh.name = name;\n\n\t\t\treturn mesh;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.PCDLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/PLYLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Wei Meng / http://about.me/menway\n\t *\n\t * Description: A THREE loader for PLY ASCII files (known as the Polygon\n\t * File Format or the Stanford Triangle Format).\n\t *\n\t * Limitations: ASCII decoding assumes file is UTF-8.\n\t *\n\t * Usage:\n\t *\tvar loader = new THREE.PLYLoader();\n\t *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n\t *\n\t *\t\tscene.add( new THREE.Mesh( geometry ) );\n\t *\n\t *\t} );\n\t *\n\t * If the PLY file uses non standard property names, they can be mapped while\n\t * loading. For example, the following maps the properties\n\t * “diffuse_(red|green|blue)” in the file to standard color names.\n\t *\n\t * loader.setPropertyNameMapping( {\n\t *\tdiffuse_red: 'red',\n\t *\tdiffuse_green: 'green',\n\t *\tdiffuse_blue: 'blue'\n\t * } );\n\t *\n\t */\n\n\n\tTHREE.PLYLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.propertyNameMapping = {};\n\n\t};\n\n\tTHREE.PLYLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.PLYLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetPropertyNameMapping: function ( mapping ) {\n\n\t\t\tthis.propertyNameMapping = mapping;\n\n\t\t},\n\n\t\tparse: function ( data ) {\n\n\t\t\tfunction parseHeader( data ) {\n\n\t\t\t\tvar patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n\t\t\t\tvar headerText = '';\n\t\t\t\tvar headerLength = 0;\n\t\t\t\tvar result = patternHeader.exec( data );\n\n\t\t\t\tif ( result !== null ) {\n\n\t\t\t\t\theaderText = result[ 1 ];\n\t\t\t\t\theaderLength = result[ 0 ].length;\n\n\t\t\t\t}\n\n\t\t\t\tvar header = {\n\t\t\t\t\tcomments: [],\n\t\t\t\t\telements: [],\n\t\t\t\t\theaderLength: headerLength\n\t\t\t\t};\n\n\t\t\t\tvar lines = headerText.split( '\\n' );\n\t\t\t\tvar currentElement;\n\t\t\t\tvar lineType, lineValues;\n\n\t\t\t\tfunction make_ply_element_property( propertValues, propertyNameMapping ) {\n\n\t\t\t\t\tvar property = { type: propertValues[ 0 ] };\n\n\t\t\t\t\tif ( property.type === 'list' ) {\n\n\t\t\t\t\t\tproperty.name = propertValues[ 3 ];\n\t\t\t\t\t\tproperty.countType = propertValues[ 1 ];\n\t\t\t\t\t\tproperty.itemType = propertValues[ 2 ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tproperty.name = propertValues[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( property.name in propertyNameMapping ) {\n\n\t\t\t\t\t\tproperty.name = propertyNameMapping[ property.name ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn property;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\t\tvar line = lines[ i ];\n\t\t\t\t\tline = line.trim();\n\n\t\t\t\t\tif ( line === '' ) continue;\n\n\t\t\t\t\tlineValues = line.split( /\\s+/ );\n\t\t\t\t\tlineType = lineValues.shift();\n\t\t\t\t\tline = lineValues.join( ' ' );\n\n\t\t\t\t\tswitch ( lineType ) {\n\n\t\t\t\t\t\tcase 'format':\n\n\t\t\t\t\t\t\theader.format = lineValues[ 0 ];\n\t\t\t\t\t\t\theader.version = lineValues[ 1 ];\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'comment':\n\n\t\t\t\t\t\t\theader.comments.push( line );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'element':\n\n\t\t\t\t\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\t\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcurrentElement = {};\n\t\t\t\t\t\t\tcurrentElement.name = lineValues[ 0 ];\n\t\t\t\t\t\t\tcurrentElement.count = parseInt( lineValues[ 1 ] );\n\t\t\t\t\t\t\tcurrentElement.properties = [];\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'property':\n\n\t\t\t\t\t\t\tcurrentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );\n\n\t\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconsole.log( 'unhandled', lineType, lineValues );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t\t}\n\n\t\t\t\treturn header;\n\n\t\t\t}\n\n\t\t\tfunction parseASCIINumber( n, type ) {\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':\n\t\t\t\t\tcase 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':\n\n\t\t\t\t\t\treturn parseInt( n );\n\n\t\t\t\t\tcase 'float': case 'double': case 'float32': case 'float64':\n\n\t\t\t\t\t\treturn parseFloat( n );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseASCIIElement( properties, line ) {\n\n\t\t\t\tvar values = line.split( /\\s+/ );\n\n\t\t\t\tvar element = {};\n\n\t\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\t\tvar list = [];\n\t\t\t\t\t\tvar n = parseASCIINumber( values.shift(), properties[ i ].countType );\n\n\t\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\t\tlist.push( parseASCIINumber( values.shift(), properties[ i ].itemType ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\telement[ properties[ i ].name ] = parseASCIINumber( values.shift(), properties[ i ].type );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn element;\n\n\t\t\t}\n\n\t\t\tfunction parseASCII( data, header ) {\n\n\t\t\t\t// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n\t\t\t\tvar buffer = {\n\t\t\t\t\tindices: [],\n\t\t\t\t\tvertices: [],\n\t\t\t\t\tnormals: [],\n\t\t\t\t\tuvs: [],\n\t\t\t\t\tfaceVertexUvs: [],\n\t\t\t\t\tcolors: []\n\t\t\t\t};\n\n\t\t\t\tvar result;\n\n\t\t\t\tvar patternBody = /end_header\\s([\\s\\S]*)$/;\n\t\t\t\tvar body = '';\n\t\t\t\tif ( ( result = patternBody.exec( data ) ) !== null ) {\n\n\t\t\t\t\tbody = result[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tvar lines = body.split( '\\n' );\n\t\t\t\tvar currentElement = 0;\n\t\t\t\tvar currentElementCount = 0;\n\n\t\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\t\tvar line = lines[ i ];\n\t\t\t\t\tline = line.trim();\n\t\t\t\t\tif ( line === '' ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( currentElementCount >= header.elements[ currentElement ].count ) {\n\n\t\t\t\t\t\tcurrentElement ++;\n\t\t\t\t\t\tcurrentElementCount = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar element = parseASCIIElement( header.elements[ currentElement ].properties, line );\n\n\t\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\t\tcurrentElementCount ++;\n\n\t\t\t\t}\n\n\t\t\t\treturn postProcess( buffer );\n\n\t\t\t}\n\n\t\t\tfunction postProcess( buffer ) {\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\t// mandatory buffer data\n\n\t\t\t\tif ( buffer.indices.length > 0 ) {\n\n\t\t\t\t\tgeometry.setIndex( buffer.indices );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( buffer.vertices, 3 ) );\n\n\t\t\t\t// optional buffer data\n\n\t\t\t\tif ( buffer.normals.length > 0 ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( buffer.normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( buffer.uvs.length > 0 ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( buffer.uvs, 2 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( buffer.colors.length > 0 ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( buffer.colors, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( buffer.faceVertexUvs.length > 0 ) {\n\n\t\t\t\t\tgeometry = geometry.toNonIndexed();\n\t\t\t\t\tgeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( buffer.faceVertexUvs, 2 ) );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction handleElement( buffer, elementName, element ) {\n\n\t\t\t\tif ( elementName === 'vertex' ) {\n\n\t\t\t\t\tbuffer.vertices.push( element.x, element.y, element.z );\n\n\t\t\t\t\tif ( 'nx' in element && 'ny' in element && 'nz' in element ) {\n\n\t\t\t\t\t\tbuffer.normals.push( element.nx, element.ny, element.nz );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 's' in element && 't' in element ) {\n\n\t\t\t\t\t\tbuffer.uvs.push( element.s, element.t );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'red' in element && 'green' in element && 'blue' in element ) {\n\n\t\t\t\t\t\tbuffer.colors.push( element.red / 255.0, element.green / 255.0, element.blue / 255.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( elementName === 'face' ) {\n\n\t\t\t\t\tvar vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\t\t\t\t\tvar texcoord = element.texcoord;\n\n\t\t\t\t\tif ( vertex_indices.length === 3 ) {\n\n\t\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );\n\n\t\t\t\t\t\tif ( texcoord && texcoord.length === 6 ) {\n\n\t\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 0 ], texcoord[ 1 ] );\n\t\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 2 ], texcoord[ 3 ] );\n\t\t\t\t\t\t\tbuffer.faceVertexUvs.push( texcoord[ 4 ], texcoord[ 5 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( vertex_indices.length === 4 ) {\n\n\t\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );\n\t\t\t\t\t\tbuffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction binaryRead( dataview, at, type, little_endian ) {\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t// corespondences for non-specific length types here match rply:\n\t\t\t\t\tcase 'int8':\t\tcase 'char':\t return [ dataview.getInt8( at ), 1 ];\n\t\t\t\t\tcase 'uint8':\t\tcase 'uchar':\t return [ dataview.getUint8( at ), 1 ];\n\t\t\t\t\tcase 'int16':\t\tcase 'short':\t return [ dataview.getInt16( at, little_endian ), 2 ];\n\t\t\t\t\tcase 'uint16':\tcase 'ushort': return [ dataview.getUint16( at, little_endian ), 2 ];\n\t\t\t\t\tcase 'int32':\t\tcase 'int':\t\t return [ dataview.getInt32( at, little_endian ), 4 ];\n\t\t\t\t\tcase 'uint32':\tcase 'uint':\t return [ dataview.getUint32( at, little_endian ), 4 ];\n\t\t\t\t\tcase 'float32': case 'float':\t return [ dataview.getFloat32( at, little_endian ), 4 ];\n\t\t\t\t\tcase 'float64': case 'double': return [ dataview.getFloat64( at, little_endian ), 8 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction binaryReadElement( dataview, at, properties, little_endian ) {\n\n\t\t\t\tvar element = {};\n\t\t\t\tvar result, read = 0;\n\n\t\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\t\tvar list = [];\n\n\t\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].countType, little_endian );\n\t\t\t\t\t\tvar n = result[ 0 ];\n\t\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].itemType, little_endian );\n\t\t\t\t\t\t\tlist.push( result[ 0 ] );\n\t\t\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].type, little_endian );\n\t\t\t\t\t\telement[ properties[ i ].name ] = result[ 0 ];\n\t\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn [ element, read ];\n\n\t\t\t}\n\n\t\t\tfunction parseBinary( data, header ) {\n\n\t\t\t\tvar buffer = {\n\t\t\t\t\tindices: [],\n\t\t\t\t\tvertices: [],\n\t\t\t\t\tnormals: [],\n\t\t\t\t\tuvs: [],\n\t\t\t\t\tfaceVertexUvs: [],\n\t\t\t\t\tcolors: []\n\t\t\t\t};\n\n\t\t\t\tvar little_endian = ( header.format === 'binary_little_endian' );\n\t\t\t\tvar body = new DataView( data, header.headerLength );\n\t\t\t\tvar result, loc = 0;\n\n\t\t\t\tfor ( var currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {\n\n\t\t\t\t\tfor ( var currentElementCount = 0; currentElementCount < header.elements[ currentElement ].count; currentElementCount ++ ) {\n\n\t\t\t\t\t\tresult = binaryReadElement( body, loc, header.elements[ currentElement ].properties, little_endian );\n\t\t\t\t\t\tloc += result[ 1 ];\n\t\t\t\t\t\tvar element = result[ 0 ];\n\n\t\t\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn postProcess( buffer );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar geometry;\n\t\t\tvar scope = this;\n\n\t\t\tif ( data instanceof ArrayBuffer ) {\n\n\t\t\t\tvar text = THREE.LoaderUtils.decodeText( new Uint8Array( data ) );\n\t\t\t\tvar header = parseHeader( text );\n\n\t\t\t\tgeometry = header.format === 'ascii' ? parseASCII( text, header ) : parseBinary( data, header );\n\n\t\t\t} else {\n\n\t\t\t\tgeometry = parseASCII( data, parseHeader( data ) );\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.PLYLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/PRWMLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Kevin Chapelier / https://github.com/kchapelier\n\t * See https://github.com/kchapelier/PRWM for more informations about this file format\n\t */\n\n\tTHREE.PRWMLoader = ( function () {\n\n\t\tvar bigEndianPlatform = null;\n\n\t\t/**\n\t\t * Check if the endianness of the platform is big-endian (most significant bit first)\n\t\t * @returns {boolean} True if big-endian, false if little-endian\n\t\t */\n\t\tfunction isBigEndianPlatform() {\n\n\t\t\tif ( bigEndianPlatform === null ) {\n\n\t\t\t\tvar buffer = new ArrayBuffer( 2 ),\n\t\t\t\t\tuint8Array = new Uint8Array( buffer ),\n\t\t\t\t\tuint16Array = new Uint16Array( buffer );\n\n\t\t\t\tuint8Array[ 0 ] = 0xAA; // set first byte\n\t\t\t\tuint8Array[ 1 ] = 0xBB; // set second byte\n\t\t\t\tbigEndianPlatform = ( uint16Array[ 0 ] === 0xAABB );\n\n\t\t\t}\n\n\t\t\treturn bigEndianPlatform;\n\n\t\t}\n\n\t\t// match the values defined in the spec to the TypedArray types\n\t\tvar InvertedEncodingTypes = [\n\t\t\tnull,\n\t\t\tFloat32Array,\n\t\t\tnull,\n\t\t\tInt8Array,\n\t\t\tInt16Array,\n\t\t\tnull,\n\t\t\tInt32Array,\n\t\t\tUint8Array,\n\t\t\tUint16Array,\n\t\t\tnull,\n\t\t\tUint32Array\n\t\t];\n\n\t\t// define the method to use on a DataView, corresponding the TypedArray type\n\t\tvar getMethods = {\n\t\t\tUint16Array: 'getUint16',\n\t\t\tUint32Array: 'getUint32',\n\t\t\tInt16Array: 'getInt16',\n\t\t\tInt32Array: 'getInt32',\n\t\t\tFloat32Array: 'getFloat32',\n\t\t\tFloat64Array: 'getFloat64'\n\t\t};\n\n\n\t\tfunction copyFromBuffer( sourceArrayBuffer, viewType, position, length, fromBigEndian ) {\n\n\t\t\tvar bytesPerElement = viewType.BYTES_PER_ELEMENT,\n\t\t\t\tresult;\n\n\t\t\tif ( fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1 ) {\n\n\t\t\t\tresult = new viewType( sourceArrayBuffer, position, length );\n\n\t\t\t} else {\n\n\t\t\t\tvar readView = new DataView( sourceArrayBuffer, position, length * bytesPerElement ),\n\t\t\t\t\tgetMethod = getMethods[ viewType.name ],\n\t\t\t\t\tlittleEndian = ! fromBigEndian,\n\t\t\t\t\ti = 0;\n\n\t\t\t\tresult = new viewType( length );\n\n\t\t\t\tfor ( ; i < length; i ++ ) {\n\n\t\t\t\t\tresult[ i ] = readView[ getMethod ]( i * bytesPerElement, littleEndian );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\n\t\tfunction decodePrwm( buffer ) {\n\n\t\t\tvar array = new Uint8Array( buffer ),\n\t\t\t\tversion = array[ 0 ],\n\t\t\t\tflags = array[ 1 ],\n\t\t\t\tindexedGeometry = !! ( flags >> 7 & 0x01 ),\n\t\t\t\tindicesType = flags >> 6 & 0x01,\n\t\t\t\tbigEndian = ( flags >> 5 & 0x01 ) === 1,\n\t\t\t\tattributesNumber = flags & 0x1F,\n\t\t\t\tvaluesNumber = 0,\n\t\t\t\tindicesNumber = 0;\n\n\t\t\tif ( bigEndian ) {\n\n\t\t\t\tvaluesNumber = ( array[ 2 ] << 16 ) + ( array[ 3 ] << 8 ) + array[ 4 ];\n\t\t\t\tindicesNumber = ( array[ 5 ] << 16 ) + ( array[ 6 ] << 8 ) + array[ 7 ];\n\n\t\t\t} else {\n\n\t\t\t\tvaluesNumber = array[ 2 ] + ( array[ 3 ] << 8 ) + ( array[ 4 ] << 16 );\n\t\t\t\tindicesNumber = array[ 5 ] + ( array[ 6 ] << 8 ) + ( array[ 7 ] << 16 );\n\n\t\t\t}\n\n\t\t\t/** PRELIMINARY CHECKS **/\n\n\t\t\tif ( version === 0 ) {\n\n\t\t\t\tthrow new Error( 'PRWM decoder: Invalid format version: 0' );\n\n\t\t\t} else if ( version !== 1 ) {\n\n\t\t\t\tthrow new Error( 'PRWM decoder: Unsupported format version: ' + version );\n\n\t\t\t}\n\n\t\t\tif ( ! indexedGeometry ) {\n\n\t\t\t\tif ( indicesType !== 0 ) {\n\n\t\t\t\t\tthrow new Error( 'PRWM decoder: Indices type must be set to 0 for non-indexed geometries' );\n\n\t\t\t\t} else if ( indicesNumber !== 0 ) {\n\n\t\t\t\t\tthrow new Error( 'PRWM decoder: Number of indices must be set to 0 for non-indexed geometries' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/** PARSING **/\n\n\t\t\tvar pos = 8;\n\n\t\t\tvar attributes = {},\n\t\t\t\tattributeName,\n\t\t\t\tchar,\n\t\t\t\tattributeType,\n\t\t\t\tcardinality,\n\t\t\t\tencodingType,\n\t\t\t\tarrayType,\n\t\t\t\tvalues,\n\t\t\t\tindices,\n\t\t\t\ti;\n\n\t\t\tfor ( i = 0; i < attributesNumber; i ++ ) {\n\n\t\t\t\tattributeName = '';\n\n\t\t\t\twhile ( pos < array.length ) {\n\n\t\t\t\t\tchar = array[ pos ];\n\t\t\t\t\tpos ++;\n\n\t\t\t\t\tif ( char === 0 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tattributeName += String.fromCharCode( char );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tflags = array[ pos ];\n\n\t\t\t\tattributeType = flags >> 7 & 0x01;\n\t\t\t\tcardinality = ( flags >> 4 & 0x03 ) + 1;\n\t\t\t\tencodingType = flags & 0x0F;\n\t\t\t\tarrayType = InvertedEncodingTypes[ encodingType ];\n\n\t\t\t\tpos ++;\n\n\t\t\t\t// padding to next multiple of 4\n\t\t\t\tpos = Math.ceil( pos / 4 ) * 4;\n\n\t\t\t\tvalues = copyFromBuffer( buffer, arrayType, pos, cardinality * valuesNumber, bigEndian );\n\n\t\t\t\tpos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n\n\t\t\t\tattributes[ attributeName ] = {\n\t\t\t\t\ttype: attributeType,\n\t\t\t\t\tcardinality: cardinality,\n\t\t\t\t\tvalues: values\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tpos = Math.ceil( pos / 4 ) * 4;\n\n\t\t\tindices = null;\n\n\t\t\tif ( indexedGeometry ) {\n\n\t\t\t\tindices = copyFromBuffer(\n\t\t\t\t\tbuffer,\n\t\t\t\t\tindicesType === 1 ? Uint32Array : Uint16Array,\n\t\t\t\t\tpos,\n\t\t\t\t\tindicesNumber,\n\t\t\t\t\tbigEndian\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tversion: version,\n\t\t\t\tattributes: attributes,\n\t\t\t\tindices: indices\n\t\t\t};\n\n\t\t}\n\n\t\t// Define the public interface\n\n\t\tfunction PRWMLoader( manager ) {\n\n\t\t\tTHREE.Loader.call( this, manager );\n\n\t\t}\n\n\t\tPRWMLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\t\tconstructor: PRWMLoader,\n\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\t\tloader.setPath( scope.path );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\t\turl = url.replace( /\\*/g, isBigEndianPlatform() ? 'be' : 'le' );\n\n\t\t\t\tloader.load( url, function ( arrayBuffer ) {\n\n\t\t\t\t\tonLoad( scope.parse( arrayBuffer ) );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t},\n\n\t\t\tparse: function ( arrayBuffer ) {\n\n\t\t\t\tvar data = decodePrwm( arrayBuffer ),\n\t\t\t\t\tattributesKey = Object.keys( data.attributes ),\n\t\t\t\t\tbufferGeometry = new THREE.BufferGeometry(),\n\t\t\t\t\tattribute,\n\t\t\t\t\ti;\n\n\t\t\t\tfor ( i = 0; i < attributesKey.length; i ++ ) {\n\n\t\t\t\t\tattribute = data.attributes[ attributesKey[ i ] ];\n\t\t\t\t\tbufferGeometry.setAttribute( attributesKey[ i ], new THREE.BufferAttribute( attribute.values, attribute.cardinality, attribute.normalized ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.indices !== null ) {\n\n\t\t\t\t\tbufferGeometry.setIndex( new THREE.BufferAttribute( data.indices, 1 ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn bufferGeometry;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tPRWMLoader.isBigEndianPlatform = function () {\n\n\t\t\treturn isBigEndianPlatform();\n\n\t\t};\n\n\t\treturn PRWMLoader;\n\n\t} )();\n\t\n\treturn THREE.PRWMLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/STLLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author aleeper / http://adamleeper.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author gero3 / https://github.com/gero3\n\t * @author Mugen87 / https://github.com/Mugen87\n\t * @author neverhood311 / https://github.com/neverhood311\n\t *\n\t * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n\t *\n\t * Supports both binary and ASCII encoded files, with automatic detection of type.\n\t *\n\t * The loader returns a non-indexed buffer geometry.\n\t *\n\t * Limitations:\n\t *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n\t *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n\t *  ASCII decoding assumes file is UTF-8.\n\t *\n\t * Usage:\n\t *  var loader = new THREE.STLLoader();\n\t *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n\t *    scene.add( new THREE.Mesh( geometry ) );\n\t *  });\n\t *\n\t * For binary STLs geometry might contain colors for vertices. To use it:\n\t *  // use the same code to load STL as above\n\t *  if (geometry.hasColors) {\n\t *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });\n\t *  } else { .... }\n\t *  var mesh = new THREE.Mesh( geometry, material );\n\t *\n\t * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n\t * Groups can be used to assign a different color by defining an array of materials with the same length of\n\t * geometry.groups and passing it to the Mesh constructor:\n\t *\n\t * var mesh = new THREE.Mesh( geometry, material );\n\t *\n\t * For example:\n\t *\n\t *  var materials = [];\n\t *  var nGeometryGroups = geometry.groups.length;\n\t *\n\t *  var colorMap = ...; // Some logic to index colors.\n\t *\n\t *  for (var i = 0; i < nGeometryGroups; i++) {\n\t *\n\t *\t\tvar material = new THREE.MeshPhongMaterial({\n\t *\t\t\tcolor: colorMap[i],\n\t *\t\t\twireframe: false\n\t *\t\t});\n\t *\n\t *  }\n\t *\n\t *  materials.push(material);\n\t *  var mesh = new THREE.Mesh(geometry, materials);\n\t */\n\n\n\tTHREE.STLLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.STLLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.STLLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t\t} catch ( exception ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( exception );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data ) {\n\n\t\t\tfunction isBinary( data ) {\n\n\t\t\t\tvar expect, face_size, n_faces, reader;\n\t\t\t\treader = new DataView( data );\n\t\t\t\tface_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\n\t\t\t\tn_faces = reader.getUint32( 80, true );\n\t\t\t\texpect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\n\n\t\t\t\tif ( expect === reader.byteLength ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n\t\t\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n\t\t\t\t// Search for \"solid\" to start anywhere after those prefixes.\n\n\t\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\t\t\t\tvar solid = [ 115, 111, 108, 105, 100 ];\n\n\t\t\t\tfor ( var off = 0; off < 5; off ++ ) {\n\n\t\t\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n\t\t\t\t\tif ( matchDataViewAt( solid, reader, off ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tfunction matchDataViewAt( query, reader, offset ) {\n\n\t\t\t\t// Check if each byte in query matches the corresponding byte from the current offset\n\n\t\t\t\tfor ( var i = 0, il = query.length; i < il; i ++ ) {\n\n\t\t\t\t\tif ( query[ i ] !== reader.getUint8( offset + i, false ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tfunction parseBinary( data ) {\n\n\t\t\t\tvar reader = new DataView( data );\n\t\t\t\tvar faces = reader.getUint32( 80, true );\n\n\t\t\t\tvar r, g, b, hasColors = false, colors;\n\t\t\t\tvar defaultR, defaultG, defaultB, alpha;\n\n\t\t\t\t// process STL header\n\t\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\n\t\t\t\tfor ( var index = 0; index < 80 - 10; index ++ ) {\n\n\t\t\t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&\n\t\t\t\t\t\t( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&\n\t\t\t\t\t\t( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {\n\n\t\t\t\t\t\thasColors = true;\n\t\t\t\t\t\tcolors = new Float32Array( faces * 3 * 3 );\n\n\t\t\t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\n\t\t\t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\n\t\t\t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\n\t\t\t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar dataOffset = 84;\n\t\t\t\tvar faceLength = 12 * 4 + 2;\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\tvar vertices = new Float32Array( faces * 3 * 3 );\n\t\t\t\tvar normals = new Float32Array( faces * 3 * 3 );\n\n\t\t\t\tfor ( var face = 0; face < faces; face ++ ) {\n\n\t\t\t\t\tvar start = dataOffset + face * faceLength;\n\t\t\t\t\tvar normalX = reader.getFloat32( start, true );\n\t\t\t\t\tvar normalY = reader.getFloat32( start + 4, true );\n\t\t\t\t\tvar normalZ = reader.getFloat32( start + 8, true );\n\n\t\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\t\tvar packedColor = reader.getUint16( start + 48, true );\n\n\t\t\t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\n\n\t\t\t\t\t\t\t// facet has its own unique color\n\n\t\t\t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\n\t\t\t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\n\t\t\t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tr = defaultR;\n\t\t\t\t\t\t\tg = defaultG;\n\t\t\t\t\t\t\tb = defaultB;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 1; i <= 3; i ++ ) {\n\n\t\t\t\t\t\tvar vertexstart = start + i * 12;\n\t\t\t\t\t\tvar componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );\n\n\t\t\t\t\t\tvertices[ componentIdx ] = reader.getFloat32( vertexstart, true );\n\t\t\t\t\t\tvertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );\n\t\t\t\t\t\tvertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );\n\n\t\t\t\t\t\tnormals[ componentIdx ] = normalX;\n\t\t\t\t\t\tnormals[ componentIdx + 1 ] = normalY;\n\t\t\t\t\t\tnormals[ componentIdx + 2 ] = normalZ;\n\n\t\t\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\t\t\tcolors[ componentIdx ] = r;\n\t\t\t\t\t\t\tcolors[ componentIdx + 1 ] = g;\n\t\t\t\t\t\t\tcolors[ componentIdx + 2 ] = b;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\n\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\n\t\t\t\t\tgeometry.hasColors = true;\n\t\t\t\t\tgeometry.alpha = alpha;\n\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction parseASCII( data ) {\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tvar patternSolid = /solid([\\s\\S]*?)endsolid/g;\n\t\t\t\tvar patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\t\t\tvar faceCounter = 0;\n\n\t\t\t\tvar patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\t\t\tvar patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );\n\t\t\t\tvar patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );\n\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar normals = [];\n\n\t\t\t\tvar normal = new THREE.Vector3();\n\n\t\t\t\tvar result;\n\n\t\t\t\tvar groupCount = 0;\n\t\t\t\tvar startVertex = 0;\n\t\t\t\tvar endVertex = 0;\n\n\t\t\t\twhile ( ( result = patternSolid.exec( data ) ) !== null ) {\n\n\t\t\t\t\tstartVertex = endVertex;\n\n\t\t\t\t\tvar solid = result[ 0 ];\n\n\t\t\t\t\twhile ( ( result = patternFace.exec( solid ) ) !== null ) {\n\n\t\t\t\t\t\tvar vertexCountPerFace = 0;\n\t\t\t\t\t\tvar normalCountPerFace = 0;\n\n\t\t\t\t\t\tvar text = result[ 0 ];\n\n\t\t\t\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\t\tnormal.x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\tnormal.y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\tnormal.z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\tnormalCountPerFace ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\n\t\t\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\t\t\t\t\t\tvertexCountPerFace ++;\n\t\t\t\t\t\t\tendVertex ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// every face have to own ONE valid normal\n\n\t\t\t\t\t\tif ( normalCountPerFace !== 1 ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// each face have to own THREE valid vertices\n\n\t\t\t\t\t\tif ( vertexCountPerFace !== 3 ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfaceCounter ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar start = startVertex;\n\t\t\t\t\tvar count = endVertex - startVertex;\n\n\t\t\t\t\tgeometry.addGroup( start, count, groupCount );\n\t\t\t\t\tgroupCount ++;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction ensureString( buffer ) {\n\n\t\t\t\tif ( typeof buffer !== 'string' ) {\n\n\t\t\t\t\treturn THREE.LoaderUtils.decodeText( new Uint8Array( buffer ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn buffer;\n\n\t\t\t}\n\n\t\t\tfunction ensureBinary( buffer ) {\n\n\t\t\t\tif ( typeof buffer === 'string' ) {\n\n\t\t\t\t\tvar array_buffer = new Uint8Array( buffer.length );\n\t\t\t\t\tfor ( var i = 0; i < buffer.length; i ++ ) {\n\n\t\t\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn array_buffer.buffer || array_buffer;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn buffer;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tvar binData = ensureBinary( data );\n\n\t\t\treturn isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.STLLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/SVGLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author zz85 / http://joshuakoo.com/\n\t * @author yomboprime / https://yombo.org\n\t */\n\n\tTHREE.SVGLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\t// Default dots per inch\n\t\tthis.defaultDPI = 90;\n\n\t\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\t\tthis.defaultUnit = \"px\";\n\n\t};\n\n\tTHREE.SVGLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.SVGLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( text ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tfunction parseNode( node, style ) {\n\n\t\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\t\tvar transform = getNodeTransform( node );\n\n\t\t\t\tvar path = null;\n\n\t\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\t\tcase 'svg':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'g':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'path':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rect':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polygon':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polyline':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'circle':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ellipse':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'line':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( node );\n\n\t\t\t\t}\n\n\t\t\t\tif ( path ) {\n\n\t\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\t\tpaths.push( path );\n\n\t\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t\t}\n\n\t\t\t\tvar nodes = node.childNodes;\n\n\t\t\t\tfor ( var i = 0; i < nodes.length; i ++ ) {\n\n\t\t\t\t\tparseNode( nodes[ i ], style );\n\n\t\t\t\t}\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\ttransformStack.pop();\n\n\t\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parsePathNode( node ) {\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\n\t\t\t\tvar point = new THREE.Vector2();\n\t\t\t\tvar control = new THREE.Vector2();\n\n\t\t\t\tvar firstPoint = new THREE.Vector2();\n\t\t\t\tvar isFirstPoint = true;\n\t\t\t\tvar doSetFirstPoint = false;\n\n\t\t\t\tvar d = node.getAttribute( 'd' );\n\n\t\t\t\t// console.log( d );\n\n\t\t\t\tvar commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\t\tfor ( var i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar command = commands[ i ];\n\n\t\t\t\t\tvar type = command.charAt( 0 );\n\t\t\t\t\tvar data = command.substr( 1 ).trim();\n\n\t\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'M':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'H':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'V':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'C':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'S':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'T':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'm':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'h':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 's':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'q':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 't':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'a':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Z':\n\t\t\t\t\t\tcase 'z':\n\t\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t\t * From\n\t\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t\t * To\n\t\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t\t */\n\n\t\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t\t// Ensure radii are positive\n\t\t\t\trx = Math.abs( rx );\n\t\t\t\try = Math.abs( ry );\n\n\t\t\t\t// Compute (x1′, y1′)\n\t\t\t\tvar dx2 = ( start.x - end.x ) / 2.0;\n\t\t\t\tvar dy2 = ( start.y - end.y ) / 2.0;\n\t\t\t\tvar x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\t\tvar y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t\t// Compute (cx′, cy′)\n\t\t\t\tvar rxs = rx * rx;\n\t\t\t\tvar rys = ry * ry;\n\t\t\t\tvar x1ps = x1p * x1p;\n\t\t\t\tvar y1ps = y1p * y1p;\n\n\t\t\t\t// Ensure radii are large enough\n\t\t\t\tvar cr = x1ps / rxs + y1ps / rys;\n\n\t\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\t\tvar s = Math.sqrt( cr );\n\t\t\t\t\trx = s * rx;\n\t\t\t\t\try = s * ry;\n\t\t\t\t\trxs = rx * rx;\n\t\t\t\t\trys = ry * ry;\n\n\t\t\t\t}\n\n\t\t\t\tvar dq = ( rxs * y1ps + rys * x1ps );\n\t\t\t\tvar pq = ( rxs * rys - dq ) / dq;\n\t\t\t\tvar q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\t\tvar cxp = q * rx * y1p / ry;\n\t\t\t\tvar cyp = - q * ry * x1p / rx;\n\n\t\t\t\t// Step 3: Compute (cx, cy) from (cx′, cy′)\n\t\t\t\tvar cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\t\tvar cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t\t// Step 4: Compute θ1 and Δθ\n\t\t\t\tvar theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\t\tvar delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t\t}\n\n\t\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\t\tvar dot = ux * vx + uy * vy;\n\t\t\t\tvar len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\t\tvar ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\t\treturn ang;\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t\t*/\n\t\t\tfunction parseRectNode( node ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\t\t\t\tvar w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\t\tvar h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\t\t\t\tpath.moveTo( x + 2 * rx, y );\n\t\t\t\tpath.lineTo( x + w - 2 * rx, y );\n\t\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry );\n\t\t\t\tpath.lineTo( x + w, y + h - 2 * ry );\n\t\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h );\n\t\t\t\tpath.lineTo( x + 2 * rx, y + h );\n\n\t\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\t\tpath.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );\n\n\t\t\t\t}\n\n\t\t\t\tpath.lineTo( x, y + 2 * ry );\n\n\t\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\t\tpath.bezierCurveTo( x, y, x, y, x + 2 * rx, y );\n\n\t\t\t\t}\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\tfunction parsePolygonNode( node ) {\n\n\t\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\n\t\t\t\tvar index = 0;\n\n\t\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\tfunction parsePolylineNode( node ) {\n\n\t\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\n\t\t\t\tvar index = 0;\n\n\t\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\tfunction parseCircleNode( node ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\t\tvar r = parseFloatWithUnits( node.getAttribute( 'r' ) );\n\n\t\t\t\tvar subpath = new THREE.Path();\n\t\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\t\t\t\tpath.subPaths.push( subpath );\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\tfunction parseEllipseNode( node ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) );\n\t\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) );\n\n\t\t\t\tvar subpath = new THREE.Path();\n\t\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\t\t\t\tpath.subPaths.push( subpath );\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\tfunction parseLineNode( node ) {\n\n\t\t\t\tvar x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) );\n\t\t\t\tvar y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) );\n\t\t\t\tvar x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) );\n\t\t\t\tvar y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) );\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\t\t\t\tpath.moveTo( x1, y1 );\n\t\t\t\tpath.lineTo( x2, y2 );\n\t\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction parseStyle( node, style ) {\n\n\t\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\t\treturn v;\n\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t\t}\n\n\t\t\t\tfunction clamp( v ) {\n\n\t\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tfunction positive( v ) {\n\n\t\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t\t}\n\n\t\t\t\taddStyle( 'fill', 'fill' );\n\t\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\n\t\t\t\treturn style;\n\n\t\t\t}\n\n\t\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\t\tfunction getReflection( a, b ) {\n\n\t\t\t\treturn a - ( b - a );\n\n\t\t\t}\n\n\t\t\tfunction parseFloats( string ) {\n\n\t\t\t\tvar array = string.split( /[\\s,]+|(?=\\s?[+\\-])/ );\n\n\t\t\t\tfor ( var i = 0; i < array.length; i ++ ) {\n\n\t\t\t\t\tvar number = array[ i ];\n\n\t\t\t\t\t// Handle values like 48.6037.7.8\n\t\t\t\t\t// TODO Find a regex for this\n\n\t\t\t\t\tif ( number.indexOf( '.' ) !== number.lastIndexOf( '.' ) ) {\n\n\t\t\t\t\t\tvar split = number.split( '.' );\n\n\t\t\t\t\t\tfor ( var s = 2; s < split.length; s ++ ) {\n\n\t\t\t\t\t\t\tarray.splice( i + s - 1, 0, '0.' + split[ s ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tarray[ i ] = parseFloatWithUnits( number );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\n\t\t\t}\n\n\t\t\t// Units\n\n\t\t\tvar units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\t\tvar unitConversion = {\n\n\t\t\t\t\"mm\": {\n\t\t\t\t\t\"mm\": 1,\n\t\t\t\t\t\"cm\": 0.1,\n\t\t\t\t\t\"in\": 1 / 25.4,\n\t\t\t\t\t\"pt\": 72 / 25.4,\n\t\t\t\t\t\"pc\": 6 / 25.4,\n\t\t\t\t\t\"px\": - 1\n\t\t\t\t},\n\t\t\t\t\"cm\": {\n\t\t\t\t\t\"mm\": 10,\n\t\t\t\t\t\"cm\": 1,\n\t\t\t\t\t\"in\": 1 / 2.54,\n\t\t\t\t\t\"pt\": 72 / 2.54,\n\t\t\t\t\t\"pc\": 6 / 2.54,\n\t\t\t\t\t\"px\": - 1\n\t\t\t\t},\n\t\t\t\t\"in\": {\n\t\t\t\t\t\"mm\": 25.4,\n\t\t\t\t\t\"cm\": 2.54,\n\t\t\t\t\t\"in\": 1,\n\t\t\t\t\t\"pt\": 72,\n\t\t\t\t\t\"pc\": 6,\n\t\t\t\t\t\"px\": - 1\n\t\t\t\t},\n\t\t\t\t\"pt\": {\n\t\t\t\t\t\"mm\": 25.4 / 72,\n\t\t\t\t\t\"cm\": 2.54 / 72,\n\t\t\t\t\t\"in\": 1 / 72,\n\t\t\t\t\t\"pt\": 1,\n\t\t\t\t\t\"pc\": 6 / 72,\n\t\t\t\t\t\"px\": - 1\n\t\t\t\t},\n\t\t\t\t\"pc\": {\n\t\t\t\t\t\"mm\": 25.4 / 6,\n\t\t\t\t\t\"cm\": 2.54 / 6,\n\t\t\t\t\t\"in\": 1 / 6,\n\t\t\t\t\t\"pt\": 72 / 6,\n\t\t\t\t\t\"pc\": 1,\n\t\t\t\t\t\"px\": - 1\n\t\t\t\t},\n\t\t\t\t\"px\": {\n\t\t\t\t\t\"px\": 1\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\t\tvar theUnit = \"px\";\n\n\t\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\t\tfor ( var i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\t\tvar u = units[ i ];\n\n\t\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar scale = undefined;\n\n\t\t\t\tif ( theUnit === \"px\" && scope.defaultUnit !== \"px\" ) {\n\n\t\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\t\tscale = unitConversion[ \"in\" ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\t\tscale = unitConversion[ theUnit ][ \"in\" ] * scope.defaultDPI;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn scale * parseFloat( string );\n\n\t\t\t}\n\n\t\t\t// Transforms\n\n\t\t\tfunction getNodeTransform( node ) {\n\n\t\t\t\tif ( ! node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tvar transform = parseNodeTransform( node );\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tcurrentTransform.copy( transform );\n\t\t\t\ttransformStack.push( transform );\n\n\t\t\t\treturn transform;\n\n\t\t\t}\n\n\t\t\tfunction parseNodeTransform( node ) {\n\n\t\t\t\tvar transform = new THREE.Matrix3();\n\t\t\t\tvar currentTransform = tempTransform0;\n\t\t\t\tvar transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tvar transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tvar openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tvar closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tvar transformType = transformText.substr( 0, openParPos );\n\n\t\t\t\t\t\tvar array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase \"translate\":\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tvar ty = tx;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"rotate\":\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar angle = 0;\n\t\t\t\t\t\t\t\t\tvar cx = 0;\n\t\t\t\t\t\t\t\t\tvar cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"scale\":\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tvar scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"skewX\":\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"skewY\":\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"matrix\":\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t\treturn transform;\n\n\t\t\t}\n\n\t\t\tfunction transformPath( path, m ) {\n\n\t\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t\t}\n\n\t\t\t\tvar isRotated = isTransformRotated( m );\n\n\t\t\t\tvar subPaths = path.subPaths;\n\n\t\t\t\tfor ( var i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\t\tvar subPath = subPaths[ i ];\n\t\t\t\t\tvar curves = subPath.curves;\n\n\t\t\t\t\tfor ( var j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\t\tvar curve = curves[ j ];\n\n\t\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( \"SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.\" );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction isTransformRotated( m ) {\n\n\t\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t\t}\n\n\t\t\tfunction getTransformScaleX( m ) {\n\n\t\t\t\tvar te = m.elements;\n\t\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t\t}\n\n\t\t\tfunction getTransformScaleY( m ) {\n\n\t\t\t\tvar te = m.elements;\n\t\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar paths = [];\n\n\t\t\tvar transformStack = [];\n\n\t\t\tvar tempTransform0 = new THREE.Matrix3();\n\t\t\tvar tempTransform1 = new THREE.Matrix3();\n\t\t\tvar tempTransform2 = new THREE.Matrix3();\n\t\t\tvar tempTransform3 = new THREE.Matrix3();\n\t\t\tvar tempV2 = new THREE.Vector2();\n\t\t\tvar tempV3 = new THREE.Vector3();\n\n\t\t\tvar currentTransform = new THREE.Matrix3();\n\n\t\t\tvar xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\t\tparseNode( xml.documentElement, {\n\t\t\t\tfill: '#000',\n\t\t\t\tfillOpacity: 1,\n\t\t\t\tstrokeOpacity: 1,\n\t\t\t\tstrokeWidth: 1,\n\t\t\t\tstrokeLineJoin: 'miter',\n\t\t\t\tstrokeLineCap: 'butt',\n\t\t\t\tstrokeMiterLimit: 4\n\t\t\t} );\n\n\t\t\tvar data = { paths: paths, xml: xml.documentElement };\n\n\t\t\t// console.log( paths );\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\tTHREE.SVGLoader.getStrokeStyle = function ( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t\t// Param width: Stroke width\n\t\t// Param color: As returned by THREE.Color.getStyle()\n\t\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t\t// Returns style object\n\n\t\twidth = width !== undefined ? width : 1;\n\t\tcolor = color !== undefined ? color : '#000';\n\t\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\t\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\t\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\t\treturn {\n\t\t\tstrokeColor: color,\n\t\t\tstrokeWidth: width,\n\t\t\tstrokeLineJoin: lineJoin,\n\t\t\tstrokeLineCap: lineCap,\n\t\t\tstrokeMiterLimit: miterLimit\n\t\t};\n\n\t};\n\n\tTHREE.SVGLoader.pointsToStroke = function ( points, style, arcDivisions, minDistance ) {\n\n\t\t// Generates a stroke with some witdh around the given path.\n\t\t// The path can be open or closed (last point equals to first point)\n\t\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\tif ( THREE.SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n\t\tgeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );\n\n\t\treturn geometry;\n\n\t};\n\n\tTHREE.SVGLoader.pointsToStrokeWithBuffers = function () {\n\n\t\tvar tempV2_1 = new THREE.Vector2();\n\t\tvar tempV2_2 = new THREE.Vector2();\n\t\tvar tempV2_3 = new THREE.Vector2();\n\t\tvar tempV2_4 = new THREE.Vector2();\n\t\tvar tempV2_5 = new THREE.Vector2();\n\t\tvar tempV2_6 = new THREE.Vector2();\n\t\tvar tempV2_7 = new THREE.Vector2();\n\t\tvar lastPointL = new THREE.Vector2();\n\t\tvar lastPointR = new THREE.Vector2();\n\t\tvar point0L = new THREE.Vector2();\n\t\tvar point0R = new THREE.Vector2();\n\t\tvar currentPointL = new THREE.Vector2();\n\t\tvar currentPointR = new THREE.Vector2();\n\t\tvar nextPointL = new THREE.Vector2();\n\t\tvar nextPointR = new THREE.Vector2();\n\t\tvar innerPoint = new THREE.Vector2();\n\t\tvar outerPoint = new THREE.Vector2();\n\n\t\treturn function ( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t\t// This function can be called to update existing arrays or buffers.\n\t\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t\t// First ensure there are no duplicated points\n\t\t\tpoints = removeDuplicatedPoints( points );\n\n\t\t\tvar numPoints = points.length;\n\n\t\t\tif ( numPoints < 2 ) return 0;\n\n\t\t\tvar isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\t\tvar currentPoint;\n\t\t\tvar previousPoint = points[ 0 ];\n\t\t\tvar nextPoint;\n\n\t\t\tvar strokeWidth2 = style.strokeWidth / 2;\n\n\t\t\tvar deltaU = 1 / ( numPoints - 1 );\n\t\t\tvar u0 = 0;\n\n\t\t\tvar innerSideModified;\n\t\t\tvar joinIsOnLeftSide;\n\t\t\tvar isMiter;\n\t\t\tvar initialJoinIsOnLeftSide = false;\n\n\t\t\tvar numVertices = 0;\n\t\t\tvar currentCoordinate = vertexOffset * 3;\n\t\t\tvar currentCoordinateUV = vertexOffset * 2;\n\n\t\t\t// Get initial left and right stroke points\n\t\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\t\tpoint0L.copy( lastPointL );\n\t\t\tpoint0R.copy( lastPointR );\n\n\t\t\tfor ( var iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t\t// Get next point\n\t\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t\t}\n\n\t\t\t\t// Normal of previous segment in tempV2_1\n\t\t\t\tvar normal1 = tempV2_1;\n\t\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tvar u1 = u0 + deltaU;\n\n\t\t\t\tinnerSideModified = false;\n\n\t\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\t\ttempV2_3.normalize();\n\t\t\t\t\tvar dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t\t// If path is straight, don't create join\n\t\t\t\t\tif ( dot !== 0 ) {\n\n\t\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\t\tvar miterSide = strokeWidth2 / dot;\n\t\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\t\tvar miterLength2 = tempV2_5.length();\n\t\t\t\t\t\tvar segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\t\tvar segmentLengthNext = tempV2_6.length();\n\t\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tvar miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t\t// Start line endcap\n\t\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t\t}\n\n\t\t\t\t// Increment loop variables\n\n\t\t\t\tu0 = u1;\n\n\t\t\t\tpreviousPoint = currentPoint;\n\n\t\t\t\tlastPointL.copy( nextPointL );\n\t\t\t\tlastPointR.copy( nextPointR );\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed ) {\n\n\t\t\t\t// Ending line endcap\n\t\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\t\tvar lastOuter = outerPoint;\n\t\t\t\tvar lastInner = innerPoint;\n\n\t\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\t\tlastOuter = innerPoint;\n\t\t\t\t\tlastInner = outerPoint;\n\n\t\t\t\t}\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn numVertices;\n\n\t\t\t// -- End of algorithm\n\n\t\t\t// -- Functions\n\n\t\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\t\tresult.subVectors( p2, p1 );\n\t\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t\t}\n\n\t\t\tfunction addVertex( position, u, v ) {\n\n\t\t\t\tif ( vertices ) {\n\n\t\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\t\tif ( normals ) {\n\n\t\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnumVertices += 3;\n\n\t\t\t}\n\n\t\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\t\tvar angle = Math.PI;\n\t\t\t\tvar dot = tempV2_1.dot( tempV2_2 );\n\t\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\t\tangle /= arcDivisions;\n\n\t\t\t\ttempV2_3.copy( p1 );\n\n\t\t\t\tfor ( var i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t\t}\n\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( p2, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t}\n\n\t\t\tfunction makeSegmentTriangles() {\n\n\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t\t}\n\n\t\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t\t// param center: End point of the path\n\t\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'square':\n\n\t\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t\tvar vl = vertices.length;\n\n\t\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'butt':\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t// Nothing to do here\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\t\tvar dupPoints = false;\n\t\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\t\tdupPoints = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\t\tvar newPoints = [];\n\t\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\t\treturn newPoints;\n\n\t\t\t}\n\n\t\t};\n\n\t}();\n\t\n\treturn THREE.SVGLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/TDSLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * Autodesk 3DS three.js file loader, based on lib3ds.\n\t *\n\t * Loads geometry with uv and materials basic properties with texture support.\n\t *\n\t * @author @tentone\n\t * @author @timknip\n\t * @class TDSLoader\n\t * @constructor\n\t */\n\n\tTHREE.TDSLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.debug = false;\n\n\t\tthis.group = null;\n\t\tthis.position = 0;\n\n\t\tthis.materials = [];\n\t\tthis.meshes = [];\n\n\t};\n\n\tTHREE.TDSLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.TDSLoader,\n\n\t\t/**\n\t\t * Load 3ds file from url.\n\t\t *\n\t\t * @method load\n\t\t * @param {[type]} url URL for the file.\n\t\t * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n\t\t * @param {Function} onProgress onProgress callback.\n\t\t * @param {Function} onError onError callback.\n\t\t */\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( scope.path === '' ) ? THREE.LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tloader.load( url, function ( data ) {\n\n\t\t\t\tonLoad( scope.parse( data, path ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\t/**\n\t\t * Parse arraybuffer data and load 3ds file.\n\t\t *\n\t\t * @method parse\n\t\t * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n\t\t * @param {String} path Path for external resources.\n\t\t * @return {Group} Group loaded from 3ds file.\n\t\t */\n\t\tparse: function ( arraybuffer, path ) {\n\n\t\t\tthis.group = new THREE.Group();\n\t\t\tthis.position = 0;\n\t\t\tthis.materials = [];\n\t\t\tthis.meshes = [];\n\n\t\t\tthis.readFile( arraybuffer, path );\n\n\t\t\tfor ( var i = 0; i < this.meshes.length; i ++ ) {\n\n\t\t\t\tthis.group.add( this.meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this.group;\n\n\t\t},\n\n\t\t/**\n\t\t * Decode file content to read 3ds data.\n\t\t *\n\t\t * @method readFile\n\t\t * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n\t\t * @param {String} path Path for external resources.\n\t\t */\n\t\treadFile: function ( arraybuffer, path ) {\n\n\t\t\tvar data = new DataView( arraybuffer );\n\t\t\tvar chunk = this.readChunk( data );\n\n\t\t\tif ( chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC ) {\n\n\t\t\t\tvar next = this.nextChunk( data, chunk );\n\n\t\t\t\twhile ( next !== 0 ) {\n\n\t\t\t\t\tif ( next === M3D_VERSION ) {\n\n\t\t\t\t\t\tvar version = this.readDWord( data );\n\t\t\t\t\t\tthis.debugMessage( '3DS file version: ' + version );\n\n\t\t\t\t\t} else if ( next === MDATA ) {\n\n\t\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\t\tthis.readMeshData( data, path );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.debugMessage( 'Unknown main chunk: ' + next.toString( 16 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.debugMessage( 'Parsed ' + this.meshes.length + ' meshes' );\n\n\t\t},\n\n\t\t/**\n\t\t * Read mesh data chunk.\n\t\t *\n\t\t * @method readMeshData\n\t\t * @param {Dataview} data Dataview in use.\n\t\t * @param {String} path Path for external resources.\n\t\t */\n\t\treadMeshData: function ( data, path ) {\n\n\t\t\tvar chunk = this.readChunk( data );\n\t\t\tvar next = this.nextChunk( data, chunk );\n\n\t\t\twhile ( next !== 0 ) {\n\n\t\t\t\tif ( next === MESH_VERSION ) {\n\n\t\t\t\t\tvar version = + this.readDWord( data );\n\t\t\t\t\tthis.debugMessage( 'Mesh Version: ' + version );\n\n\t\t\t\t} else if ( next === MASTER_SCALE ) {\n\n\t\t\t\t\tvar scale = this.readFloat( data );\n\t\t\t\t\tthis.debugMessage( 'Master scale: ' + scale );\n\t\t\t\t\tthis.group.scale.set( scale, scale, scale );\n\n\t\t\t\t} else if ( next === NAMED_OBJECT ) {\n\n\t\t\t\t\tthis.debugMessage( 'Named Object' );\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tthis.readNamedObject( data );\n\n\t\t\t\t} else if ( next === MAT_ENTRY ) {\n\n\t\t\t\t\tthis.debugMessage( 'Material' );\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tthis.readMaterialEntry( data, path );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( 'Unknown MDATA chunk: ' + next.toString( 16 ) );\n\n\t\t\t\t}\n\n\t\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t\t}\n\n\t\t},\n\n\t\t/**\n\t\t * Read named object chunk.\n\t\t *\n\t\t * @method readNamedObject\n\t\t * @param {Dataview} data Dataview in use.\n\t\t */\n\t\treadNamedObject: function ( data ) {\n\n\t\t\tvar chunk = this.readChunk( data );\n\t\t\tvar name = this.readString( data, 64 );\n\t\t\tchunk.cur = this.position;\n\n\t\t\tvar next = this.nextChunk( data, chunk );\n\t\t\twhile ( next !== 0 ) {\n\n\t\t\t\tif ( next === N_TRI_OBJECT ) {\n\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tvar mesh = this.readMesh( data );\n\t\t\t\t\tmesh.name = name;\n\t\t\t\t\tthis.meshes.push( mesh );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( 'Unknown named object chunk: ' + next.toString( 16 ) );\n\n\t\t\t\t}\n\n\t\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t\t}\n\n\t\t\tthis.endChunk( chunk );\n\n\t\t},\n\n\t\t/**\n\t\t * Read material data chunk and add it to the material list.\n\t\t *\n\t\t * @method readMaterialEntry\n\t\t * @param {Dataview} data Dataview in use.\n\t\t * @param {String} path Path for external resources.\n\t\t */\n\t\treadMaterialEntry: function ( data, path ) {\n\n\t\t\tvar chunk = this.readChunk( data );\n\t\t\tvar next = this.nextChunk( data, chunk );\n\t\t\tvar material = new THREE.MeshPhongMaterial();\n\n\t\t\twhile ( next !== 0 ) {\n\n\t\t\t\tif ( next === MAT_NAME ) {\n\n\t\t\t\t\tmaterial.name = this.readString( data, 64 );\n\t\t\t\t\tthis.debugMessage( '   Name: ' + material.name );\n\n\t\t\t\t} else if ( next === MAT_WIRE ) {\n\n\t\t\t\t\tthis.debugMessage( '   Wireframe' );\n\t\t\t\t\tmaterial.wireframe = true;\n\n\t\t\t\t} else if ( next === MAT_WIRE_SIZE ) {\n\n\t\t\t\t\tvar value = this.readByte( data );\n\t\t\t\t\tmaterial.wireframeLinewidth = value;\n\t\t\t\t\tthis.debugMessage( '   Wireframe Thickness: ' + value );\n\n\t\t\t\t} else if ( next === MAT_TWO_SIDE ) {\n\n\t\t\t\t\tmaterial.side = THREE.DoubleSide;\n\t\t\t\t\tthis.debugMessage( '   DoubleSided' );\n\n\t\t\t\t} else if ( next === MAT_ADDITIVE ) {\n\n\t\t\t\t\tthis.debugMessage( '   Additive Blending' );\n\t\t\t\t\tmaterial.blending = THREE.AdditiveBlending;\n\n\t\t\t\t} else if ( next === MAT_DIFFUSE ) {\n\n\t\t\t\t\tthis.debugMessage( '   Diffuse Color' );\n\t\t\t\t\tmaterial.color = this.readColor( data );\n\n\t\t\t\t} else if ( next === MAT_SPECULAR ) {\n\n\t\t\t\t\tthis.debugMessage( '   Specular Color' );\n\t\t\t\t\tmaterial.specular = this.readColor( data );\n\n\t\t\t\t} else if ( next === MAT_AMBIENT ) {\n\n\t\t\t\t\tthis.debugMessage( '   Ambient color' );\n\t\t\t\t\tmaterial.color = this.readColor( data );\n\n\t\t\t\t} else if ( next === MAT_SHININESS ) {\n\n\t\t\t\t\tvar shininess = this.readWord( data );\n\t\t\t\t\tmaterial.shininess = shininess;\n\t\t\t\t\tthis.debugMessage( '   Shininess : ' + shininess );\n\n\t\t\t\t} else if ( next === MAT_TRANSPARENCY ) {\n\n\t\t\t\t\tvar opacity = this.readWord( data );\n\t\t\t\t\tmaterial.opacity = opacity * 0.01;\n\t\t\t\t\tthis.debugMessage( '  Opacity : ' + opacity );\n\t\t\t\t\tmaterial.transparent = opacity < 100 ? true : false;\n\n\t\t\t\t} else if ( next === MAT_TEXMAP ) {\n\n\t\t\t\t\tthis.debugMessage( '   ColorMap' );\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tmaterial.map = this.readMap( data, path );\n\n\t\t\t\t} else if ( next === MAT_BUMPMAP ) {\n\n\t\t\t\t\tthis.debugMessage( '   BumpMap' );\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tmaterial.bumpMap = this.readMap( data, path );\n\n\t\t\t\t} else if ( next === MAT_OPACMAP ) {\n\n\t\t\t\t\tthis.debugMessage( '   OpacityMap' );\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tmaterial.alphaMap = this.readMap( data, path );\n\n\t\t\t\t} else if ( next === MAT_SPECMAP ) {\n\n\t\t\t\t\tthis.debugMessage( '   SpecularMap' );\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tmaterial.specularMap = this.readMap( data, path );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( '   Unknown material chunk: ' + next.toString( 16 ) );\n\n\t\t\t\t}\n\n\t\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t\t}\n\n\t\t\tthis.endChunk( chunk );\n\n\t\t\tthis.materials[ material.name ] = material;\n\n\t\t},\n\n\t\t/**\n\t\t * Read mesh data chunk.\n\t\t *\n\t\t * @method readMesh\n\t\t * @param {Dataview} data Dataview in use.\n\t\t * @return {Mesh} The parsed mesh.\n\t\t */\n\t\treadMesh: function ( data ) {\n\n\t\t\tvar chunk = this.readChunk( data );\n\t\t\tvar next = this.nextChunk( data, chunk );\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\tvar uvs = [];\n\n\t\t\tvar material = new THREE.MeshPhongMaterial();\n\t\t\tvar mesh = new THREE.Mesh( geometry, material );\n\t\t\tmesh.name = 'mesh';\n\n\t\t\twhile ( next !== 0 ) {\n\n\t\t\t\tif ( next === POINT_ARRAY ) {\n\n\t\t\t\t\tvar points = this.readWord( data );\n\n\t\t\t\t\tthis.debugMessage( '   Vertex: ' + points );\n\n\t\t\t\t\t//BufferGeometry\n\n\t\t\t\t\tvar vertices = [];\n\n\t\t\t\t\tfor ( var i = 0; i < points; i ++ )\t\t{\n\n\t\t\t\t\t\tvertices.push( this.readFloat( data ) );\n\t\t\t\t\t\tvertices.push( this.readFloat( data ) );\n\t\t\t\t\t\tvertices.push( this.readFloat( data ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\n\t\t\t\t} else if ( next === FACE_ARRAY ) {\n\n\t\t\t\t\tthis.resetPosition( data );\n\t\t\t\t\tthis.readFaceArray( data, mesh );\n\n\t\t\t\t} else if ( next === TEX_VERTS ) {\n\n\t\t\t\t\tvar texels = this.readWord( data );\n\n\t\t\t\t\tthis.debugMessage( '   UV: ' + texels );\n\n\t\t\t\t\t//BufferGeometry\n\n\t\t\t\t\tvar uvs = [];\n\n\t\t\t\t\tfor ( var i = 0; i < texels; i ++ )\t\t{\n\n\t\t\t\t\t\tuvs.push( this.readFloat( data ) );\n\t\t\t\t\t\tuvs.push( this.readFloat( data ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t\t\t} else if ( next === MESH_MATRIX ) {\n\n\t\t\t\t\tthis.debugMessage( '   Tranformation Matrix (TODO)' );\n\n\t\t\t\t\tvar values = [];\n\t\t\t\t\tfor ( var i = 0; i < 12; i ++ ) {\n\n\t\t\t\t\t\tvalues[ i ] = this.readFloat( data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar matrix = new THREE.Matrix4();\n\n\t\t\t\t\t//X Line\n\t\t\t\t\tmatrix.elements[ 0 ] = values[ 0 ];\n\t\t\t\t\tmatrix.elements[ 1 ] = values[ 6 ];\n\t\t\t\t\tmatrix.elements[ 2 ] = values[ 3 ];\n\t\t\t\t\tmatrix.elements[ 3 ] = values[ 9 ];\n\n\t\t\t\t\t//Y Line\n\t\t\t\t\tmatrix.elements[ 4 ] = values[ 2 ];\n\t\t\t\t\tmatrix.elements[ 5 ] = values[ 8 ];\n\t\t\t\t\tmatrix.elements[ 6 ] = values[ 5 ];\n\t\t\t\t\tmatrix.elements[ 7 ] = values[ 11 ];\n\n\t\t\t\t\t//Z Line\n\t\t\t\t\tmatrix.elements[ 8 ] = values[ 1 ];\n\t\t\t\t\tmatrix.elements[ 9 ] = values[ 7 ];\n\t\t\t\t\tmatrix.elements[ 10 ] = values[ 4 ];\n\t\t\t\t\tmatrix.elements[ 11 ] = values[ 10 ];\n\n\t\t\t\t\t//W Line\n\t\t\t\t\tmatrix.elements[ 12 ] = 0;\n\t\t\t\t\tmatrix.elements[ 13 ] = 0;\n\t\t\t\t\tmatrix.elements[ 14 ] = 0;\n\t\t\t\t\tmatrix.elements[ 15 ] = 1;\n\n\t\t\t\t\tmatrix.transpose();\n\n\t\t\t\t\tvar inverse = new THREE.Matrix4();\n\t\t\t\t\tinverse.getInverse( matrix );\n\t\t\t\t\tgeometry.applyMatrix4( inverse );\n\n\t\t\t\t\tmatrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( '   Unknown mesh chunk: ' + next.toString( 16 ) );\n\n\t\t\t\t}\n\n\t\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t\t}\n\n\t\t\tthis.endChunk( chunk );\n\n\t\t\tgeometry.computeVertexNormals();\n\n\t\t\treturn mesh;\n\n\t\t},\n\n\t\t/**\n\t\t * Read face array data chunk.\n\t\t *\n\t\t * @method readFaceArray\n\t\t * @param {Dataview} data Dataview in use.\n\t\t * @param {Mesh} mesh Mesh to be filled with the data read.\n\t\t */\n\t\treadFaceArray: function ( data, mesh ) {\n\n\t\t\tvar chunk = this.readChunk( data );\n\t\t\tvar faces = this.readWord( data );\n\n\t\t\tthis.debugMessage( '   Faces: ' + faces );\n\n\t\t\tvar index = [];\n\n\t\t\tfor ( var i = 0; i < faces; ++ i ) {\n\n\t\t\t\tindex.push( this.readWord( data ), this.readWord( data ), this.readWord( data ) );\n\n\t\t\t\tthis.readWord( data ); // visibility\n\n\t\t\t}\n\n\t\t\tmesh.geometry.setIndex( index );\n\n\t\t\t//The rest of the FACE_ARRAY chunk is subchunks\n\n\t\t\twhile ( this.position < chunk.end ) {\n\n\t\t\t\tvar chunk = this.readChunk( data );\n\n\t\t\t\tif ( chunk.id === MSH_MAT_GROUP ) {\n\n\t\t\t\t\tthis.debugMessage( '      Material Group' );\n\n\t\t\t\t\tthis.resetPosition( data );\n\n\t\t\t\t\tvar group = this.readMaterialGroup( data );\n\n\t\t\t\t\tvar material = this.materials[ group.name ];\n\n\t\t\t\t\tif ( material !== undefined )\t{\n\n\t\t\t\t\t\tmesh.material = material;\n\n\t\t\t\t\t\tif ( material.name === '' )\t\t{\n\n\t\t\t\t\t\t\tmaterial.name = mesh.name;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( '      Unknown face array chunk: ' + chunk.toString( 16 ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.endChunk( chunk );\n\n\t\t\t}\n\n\t\t\tthis.endChunk( chunk );\n\n\t\t},\n\n\t\t/**\n\t\t * Read texture map data chunk.\n\t\t *\n\t\t * @method readMap\n\t\t * @param {Dataview} data Dataview in use.\n\t\t * @param {String} path Path for external resources.\n\t\t * @return {Texture} Texture read from this data chunk.\n\t\t */\n\t\treadMap: function ( data, path ) {\n\n\t\t\tvar chunk = this.readChunk( data );\n\t\t\tvar next = this.nextChunk( data, chunk );\n\t\t\tvar texture = {};\n\n\t\t\tvar loader = new THREE.TextureLoader( this.manager );\n\t\t\tloader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\twhile ( next !== 0 ) {\n\n\t\t\t\tif ( next === MAT_MAPNAME ) {\n\n\t\t\t\t\tvar name = this.readString( data, 128 );\n\t\t\t\t\ttexture = loader.load( name );\n\n\t\t\t\t\tthis.debugMessage( '      File: ' + path + name );\n\n\t\t\t\t} else if ( next === MAT_MAP_UOFFSET ) {\n\n\t\t\t\t\ttexture.offset.x = this.readFloat( data );\n\t\t\t\t\tthis.debugMessage( '      OffsetX: ' + texture.offset.x );\n\n\t\t\t\t} else if ( next === MAT_MAP_VOFFSET ) {\n\n\t\t\t\t\ttexture.offset.y = this.readFloat( data );\n\t\t\t\t\tthis.debugMessage( '      OffsetY: ' + texture.offset.y );\n\n\t\t\t\t} else if ( next === MAT_MAP_USCALE ) {\n\n\t\t\t\t\ttexture.repeat.x = this.readFloat( data );\n\t\t\t\t\tthis.debugMessage( '      RepeatX: ' + texture.repeat.x );\n\n\t\t\t\t} else if ( next === MAT_MAP_VSCALE ) {\n\n\t\t\t\t\ttexture.repeat.y = this.readFloat( data );\n\t\t\t\t\tthis.debugMessage( '      RepeatY: ' + texture.repeat.y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage( '      Unknown map chunk: ' + next.toString( 16 ) );\n\n\t\t\t\t}\n\n\t\t\t\tnext = this.nextChunk( data, chunk );\n\n\t\t\t}\n\n\t\t\tthis.endChunk( chunk );\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\t/**\n\t\t * Read material group data chunk.\n\t\t *\n\t\t * @method readMaterialGroup\n\t\t * @param {Dataview} data Dataview in use.\n\t\t * @return {Object} Object with name and index of the object.\n\t\t */\n\t\treadMaterialGroup: function ( data ) {\n\n\t\t\tthis.readChunk( data );\n\t\t\tvar name = this.readString( data, 64 );\n\t\t\tvar numFaces = this.readWord( data );\n\n\t\t\tthis.debugMessage( '         Name: ' + name );\n\t\t\tthis.debugMessage( '         Faces: ' + numFaces );\n\n\t\t\tvar index = [];\n\t\t\tfor ( var i = 0; i < numFaces; ++ i ) {\n\n\t\t\t\tindex.push( this.readWord( data ) );\n\n\t\t\t}\n\n\t\t\treturn { name: name, index: index };\n\n\t\t},\n\n\t\t/**\n\t\t * Read a color value.\n\t\t *\n\t\t * @method readColor\n\t\t * @param {DataView} data Dataview.\n\t\t * @return {Color} Color value read..\n\t\t */\n\t\treadColor: function ( data ) {\n\n\t\t\tvar chunk = this.readChunk( data );\n\t\t\tvar color = new THREE.Color();\n\n\t\t\tif ( chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24 ) {\n\n\t\t\t\tvar r = this.readByte( data );\n\t\t\t\tvar g = this.readByte( data );\n\t\t\t\tvar b = this.readByte( data );\n\n\t\t\t\tcolor.setRGB( r / 255, g / 255, b / 255 );\n\n\t\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\n\n\t\t\t}\telse if ( chunk.id === COLOR_F || chunk.id === LIN_COLOR_F ) {\n\n\t\t\t\tvar r = this.readFloat( data );\n\t\t\t\tvar g = this.readFloat( data );\n\t\t\t\tvar b = this.readFloat( data );\n\n\t\t\t\tcolor.setRGB( r, g, b );\n\n\t\t\t\tthis.debugMessage( '      Color: ' + color.r + ', ' + color.g + ', ' + color.b );\n\n\t\t\t}\telse {\n\n\t\t\t\tthis.debugMessage( '      Unknown color chunk: ' + chunk.toString( 16 ) );\n\n\t\t\t}\n\n\t\t\tthis.endChunk( chunk );\n\t\t\treturn color;\n\n\t\t},\n\n\t\t/**\n\t\t * Read next chunk of data.\n\t\t *\n\t\t * @method readChunk\n\t\t * @param {DataView} data Dataview.\n\t\t * @return {Object} Chunk of data read.\n\t\t */\n\t\treadChunk: function ( data ) {\n\n\t\t\tvar chunk = {};\n\n\t\t\tchunk.cur = this.position;\n\t\t\tchunk.id = this.readWord( data );\n\t\t\tchunk.size = this.readDWord( data );\n\t\t\tchunk.end = chunk.cur + chunk.size;\n\t\t\tchunk.cur += 6;\n\n\t\t\treturn chunk;\n\n\t\t},\n\n\t\t/**\n\t\t * Set position to the end of the current chunk of data.\n\t\t *\n\t\t * @method endChunk\n\t\t * @param {Object} chunk Data chunk.\n\t\t */\n\t\tendChunk: function ( chunk ) {\n\n\t\t\tthis.position = chunk.end;\n\n\t\t},\n\n\t\t/**\n\t\t * Move to the next data chunk.\n\t\t *\n\t\t * @method nextChunk\n\t\t * @param {DataView} data Dataview.\n\t\t * @param {Object} chunk Data chunk.\n\t\t */\n\t\tnextChunk: function ( data, chunk ) {\n\n\t\t\tif ( chunk.cur >= chunk.end ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tthis.position = chunk.cur;\n\n\t\t\ttry {\n\n\t\t\t\tvar next = this.readChunk( data );\n\t\t\t\tchunk.cur += next.size;\n\t\t\t\treturn next.id;\n\n\t\t\t}\tcatch ( e ) {\n\n\t\t\t\tthis.debugMessage( 'Unable to read chunk at ' + this.position );\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t},\n\n\t\t/**\n\t\t * Reset dataview position.\n\t\t *\n\t\t * @method resetPosition\n\t\t */\n\t\tresetPosition: function () {\n\n\t\t\tthis.position -= 6;\n\n\t\t},\n\n\t\t/**\n\t\t * Read byte value.\n\t\t *\n\t\t * @method readByte\n\t\t * @param {DataView} data Dataview to read data from.\n\t\t * @return {Number} Data read from the dataview.\n\t\t */\n\t\treadByte: function ( data ) {\n\n\t\t\tvar v = data.getUint8( this.position, true );\n\t\t\tthis.position += 1;\n\t\t\treturn v;\n\n\t\t},\n\n\t\t/**\n\t\t * Read 32 bit float value.\n\t\t *\n\t\t * @method readFloat\n\t\t * @param {DataView} data Dataview to read data from.\n\t\t * @return {Number} Data read from the dataview.\n\t\t */\n\t\treadFloat: function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tvar v = data.getFloat32( this.position, true );\n\t\t\t\tthis.position += 4;\n\t\t\t\treturn v;\n\n\t\t\t}\tcatch ( e ) {\n\n\t\t\t\tthis.debugMessage( e + ' ' + this.position + ' ' + data.byteLength );\n\n\t\t\t}\n\n\t\t},\n\n\t\t/**\n\t\t * Read 32 bit signed integer value.\n\t\t *\n\t\t * @method readInt\n\t\t * @param {DataView} data Dataview to read data from.\n\t\t * @return {Number} Data read from the dataview.\n\t\t */\n\t\treadInt: function ( data ) {\n\n\t\t\tvar v = data.getInt32( this.position, true );\n\t\t\tthis.position += 4;\n\t\t\treturn v;\n\n\t\t},\n\n\t\t/**\n\t\t * Read 16 bit signed integer value.\n\t\t *\n\t\t * @method readShort\n\t\t * @param {DataView} data Dataview to read data from.\n\t\t * @return {Number} Data read from the dataview.\n\t\t */\n\t\treadShort: function ( data ) {\n\n\t\t\tvar v = data.getInt16( this.position, true );\n\t\t\tthis.position += 2;\n\t\t\treturn v;\n\n\t\t},\n\n\t\t/**\n\t\t * Read 64 bit unsigned integer value.\n\t\t *\n\t\t * @method readDWord\n\t\t * @param {DataView} data Dataview to read data from.\n\t\t * @return {Number} Data read from the dataview.\n\t\t */\n\t\treadDWord: function ( data ) {\n\n\t\t\tvar v = data.getUint32( this.position, true );\n\t\t\tthis.position += 4;\n\t\t\treturn v;\n\n\t\t},\n\n\t\t/**\n\t\t * Read 32 bit unsigned integer value.\n\t\t *\n\t\t * @method readWord\n\t\t * @param {DataView} data Dataview to read data from.\n\t\t * @return {Number} Data read from the dataview.\n\t\t */\n\t\treadWord: function ( data ) {\n\n\t\t\tvar v = data.getUint16( this.position, true );\n\t\t\tthis.position += 2;\n\t\t\treturn v;\n\n\t\t},\n\n\t\t/**\n\t\t * Read string value.\n\t\t *\n\t\t * @method readString\n\t\t * @param {DataView} data Dataview to read data from.\n\t\t * @param {Number} maxLength Max size of the string to be read.\n\t\t * @return {String} Data read from the dataview.\n\t\t */\n\t\treadString: function ( data, maxLength ) {\n\n\t\t\tvar s = '';\n\n\t\t\tfor ( var i = 0; i < maxLength; i ++ ) {\n\n\t\t\t\tvar c = this.readByte( data );\n\t\t\t\tif ( ! c ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\ts += String.fromCharCode( c );\n\n\t\t\t}\n\n\t\t\treturn s;\n\n\t\t},\n\n\t\t/**\n\t\t * Print debug message to the console.\n\t\t *\n\t\t * Is controlled by a flag to show or hide debug messages.\n\t\t *\n\t\t * @method debugMessage\n\t\t * @param {Object} message Debug message to print to the console.\n\t\t */\n\t\tdebugMessage: function ( message ) {\n\n\t\t\tif ( this.debug ) {\n\n\t\t\t\tconsole.log( message );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\t// var NULL_CHUNK = 0x0000;\n\tvar M3DMAGIC = 0x4D4D;\n\t// var SMAGIC = 0x2D2D;\n\t// var LMAGIC = 0x2D3D;\n\tvar MLIBMAGIC = 0x3DAA;\n\t// var MATMAGIC = 0x3DFF;\n\tvar CMAGIC = 0xC23D;\n\tvar M3D_VERSION = 0x0002;\n\t// var M3D_KFVERSION = 0x0005;\n\tvar COLOR_F = 0x0010;\n\tvar COLOR_24 = 0x0011;\n\tvar LIN_COLOR_24 = 0x0012;\n\tvar LIN_COLOR_F = 0x0013;\n\t// var INT_PERCENTAGE = 0x0030;\n\t// var FLOAT_PERCENTAGE = 0x0031;\n\tvar MDATA = 0x3D3D;\n\tvar MESH_VERSION = 0x3D3E;\n\tvar MASTER_SCALE = 0x0100;\n\t// var LO_SHADOW_BIAS = 0x1400;\n\t// var HI_SHADOW_BIAS = 0x1410;\n\t// var SHADOW_MAP_SIZE = 0x1420;\n\t// var SHADOW_SAMPLES = 0x1430;\n\t// var SHADOW_RANGE = 0x1440;\n\t// var SHADOW_FILTER = 0x1450;\n\t// var RAY_BIAS = 0x1460;\n\t// var O_CONSTS = 0x1500;\n\t// var AMBIENT_LIGHT = 0x2100;\n\t// var BIT_MAP = 0x1100;\n\t// var SOLID_BGND = 0x1200;\n\t// var V_GRADIENT = 0x1300;\n\t// var USE_BIT_MAP = 0x1101;\n\t// var USE_SOLID_BGND = 0x1201;\n\t// var USE_V_GRADIENT = 0x1301;\n\t// var FOG = 0x2200;\n\t// var FOG_BGND = 0x2210;\n\t// var LAYER_FOG = 0x2302;\n\t// var DISTANCE_CUE = 0x2300;\n\t// var DCUE_BGND = 0x2310;\n\t// var USE_FOG = 0x2201;\n\t// var USE_LAYER_FOG = 0x2303;\n\t// var USE_DISTANCE_CUE = 0x2301;\n\tvar MAT_ENTRY = 0xAFFF;\n\tvar MAT_NAME = 0xA000;\n\tvar MAT_AMBIENT = 0xA010;\n\tvar MAT_DIFFUSE = 0xA020;\n\tvar MAT_SPECULAR = 0xA030;\n\tvar MAT_SHININESS = 0xA040;\n\t// var MAT_SHIN2PCT = 0xA041;\n\tvar MAT_TRANSPARENCY = 0xA050;\n\t// var MAT_XPFALL = 0xA052;\n\t// var MAT_USE_XPFALL = 0xA240;\n\t// var MAT_REFBLUR = 0xA053;\n\t// var MAT_SHADING = 0xA100;\n\t// var MAT_USE_REFBLUR = 0xA250;\n\t// var MAT_SELF_ILLUM = 0xA084;\n\tvar MAT_TWO_SIDE = 0xA081;\n\t// var MAT_DECAL = 0xA082;\n\tvar MAT_ADDITIVE = 0xA083;\n\tvar MAT_WIRE = 0xA085;\n\t// var MAT_FACEMAP = 0xA088;\n\t// var MAT_TRANSFALLOFF_IN = 0xA08A;\n\t// var MAT_PHONGSOFT = 0xA08C;\n\t// var MAT_WIREABS = 0xA08E;\n\tvar MAT_WIRE_SIZE = 0xA087;\n\tvar MAT_TEXMAP = 0xA200;\n\t// var MAT_SXP_TEXT_DATA = 0xA320;\n\t// var MAT_TEXMASK = 0xA33E;\n\t// var MAT_SXP_TEXTMASK_DATA = 0xA32A;\n\t// var MAT_TEX2MAP = 0xA33A;\n\t// var MAT_SXP_TEXT2_DATA = 0xA321;\n\t// var MAT_TEX2MASK = 0xA340;\n\t// var MAT_SXP_TEXT2MASK_DATA = 0xA32C;\n\tvar MAT_OPACMAP = 0xA210;\n\t// var MAT_SXP_OPAC_DATA = 0xA322;\n\t// var MAT_OPACMASK = 0xA342;\n\t// var MAT_SXP_OPACMASK_DATA = 0xA32E;\n\tvar MAT_BUMPMAP = 0xA230;\n\t// var MAT_SXP_BUMP_DATA = 0xA324;\n\t// var MAT_BUMPMASK = 0xA344;\n\t// var MAT_SXP_BUMPMASK_DATA = 0xA330;\n\tvar MAT_SPECMAP = 0xA204;\n\t// var MAT_SXP_SPEC_DATA = 0xA325;\n\t// var MAT_SPECMASK = 0xA348;\n\t// var MAT_SXP_SPECMASK_DATA = 0xA332;\n\t// var MAT_SHINMAP = 0xA33C;\n\t// var MAT_SXP_SHIN_DATA = 0xA326;\n\t// var MAT_SHINMASK = 0xA346;\n\t// var MAT_SXP_SHINMASK_DATA = 0xA334;\n\t// var MAT_SELFIMAP = 0xA33D;\n\t// var MAT_SXP_SELFI_DATA = 0xA328;\n\t// var MAT_SELFIMASK = 0xA34A;\n\t// var MAT_SXP_SELFIMASK_DATA = 0xA336;\n\t// var MAT_REFLMAP = 0xA220;\n\t// var MAT_REFLMASK = 0xA34C;\n\t// var MAT_SXP_REFLMASK_DATA = 0xA338;\n\t// var MAT_ACUBIC = 0xA310;\n\tvar MAT_MAPNAME = 0xA300;\n\t// var MAT_MAP_TILING = 0xA351;\n\t// var MAT_MAP_TEXBLUR = 0xA353;\n\tvar MAT_MAP_USCALE = 0xA354;\n\tvar MAT_MAP_VSCALE = 0xA356;\n\tvar MAT_MAP_UOFFSET = 0xA358;\n\tvar MAT_MAP_VOFFSET = 0xA35A;\n\t// var MAT_MAP_ANG = 0xA35C;\n\t// var MAT_MAP_COL1 = 0xA360;\n\t// var MAT_MAP_COL2 = 0xA362;\n\t// var MAT_MAP_RCOL = 0xA364;\n\t// var MAT_MAP_GCOL = 0xA366;\n\t// var MAT_MAP_BCOL = 0xA368;\n\tvar NAMED_OBJECT = 0x4000;\n\t// var N_DIRECT_LIGHT = 0x4600;\n\t// var DL_OFF = 0x4620;\n\t// var DL_OUTER_RANGE = 0x465A;\n\t// var DL_INNER_RANGE = 0x4659;\n\t// var DL_MULTIPLIER = 0x465B;\n\t// var DL_EXCLUDE = 0x4654;\n\t// var DL_ATTENUATE = 0x4625;\n\t// var DL_SPOTLIGHT = 0x4610;\n\t// var DL_SPOT_ROLL = 0x4656;\n\t// var DL_SHADOWED = 0x4630;\n\t// var DL_LOCAL_SHADOW2 = 0x4641;\n\t// var DL_SEE_CONE = 0x4650;\n\t// var DL_SPOT_RECTANGULAR = 0x4651;\n\t// var DL_SPOT_ASPECT = 0x4657;\n\t// var DL_SPOT_PROJECTOR = 0x4653;\n\t// var DL_SPOT_OVERSHOOT = 0x4652;\n\t// var DL_RAY_BIAS = 0x4658;\n\t// var DL_RAYSHAD = 0x4627;\n\t// var N_CAMERA = 0x4700;\n\t// var CAM_SEE_CONE = 0x4710;\n\t// var CAM_RANGES = 0x4720;\n\t// var OBJ_HIDDEN = 0x4010;\n\t// var OBJ_VIS_LOFTER = 0x4011;\n\t// var OBJ_DOESNT_CAST = 0x4012;\n\t// var OBJ_DONT_RECVSHADOW = 0x4017;\n\t// var OBJ_MATTE = 0x4013;\n\t// var OBJ_FAST = 0x4014;\n\t// var OBJ_PROCEDURAL = 0x4015;\n\t// var OBJ_FROZEN = 0x4016;\n\tvar N_TRI_OBJECT = 0x4100;\n\tvar POINT_ARRAY = 0x4110;\n\t// var POINT_FLAG_ARRAY = 0x4111;\n\tvar FACE_ARRAY = 0x4120;\n\tvar MSH_MAT_GROUP = 0x4130;\n\t// var SMOOTH_GROUP = 0x4150;\n\t// var MSH_BOXMAP = 0x4190;\n\tvar TEX_VERTS = 0x4140;\n\tvar MESH_MATRIX = 0x4160;\n\t// var MESH_COLOR = 0x4165;\n\t// var MESH_TEXTURE_INFO = 0x4170;\n\t// var KFDATA = 0xB000;\n\t// var KFHDR = 0xB00A;\n\t// var KFSEG = 0xB008;\n\t// var KFCURTIME = 0xB009;\n\t// var AMBIENT_NODE_TAG = 0xB001;\n\t// var OBJECT_NODE_TAG = 0xB002;\n\t// var CAMERA_NODE_TAG = 0xB003;\n\t// var TARGET_NODE_TAG = 0xB004;\n\t// var LIGHT_NODE_TAG = 0xB005;\n\t// var L_TARGET_NODE_TAG = 0xB006;\n\t// var SPOTLIGHT_NODE_TAG = 0xB007;\n\t// var NODE_ID = 0xB030;\n\t// var NODE_HDR = 0xB010;\n\t// var PIVOT = 0xB013;\n\t// var INSTANCE_NAME = 0xB011;\n\t// var MORPH_SMOOTH = 0xB015;\n\t// var BOUNDBOX = 0xB014;\n\t// var POS_TRACK_TAG = 0xB020;\n\t// var COL_TRACK_TAG = 0xB025;\n\t// var ROT_TRACK_TAG = 0xB021;\n\t// var SCL_TRACK_TAG = 0xB022;\n\t// var MORPH_TRACK_TAG = 0xB026;\n\t// var FOV_TRACK_TAG = 0xB023;\n\t// var ROLL_TRACK_TAG = 0xB024;\n\t// var HOT_TRACK_TAG = 0xB027;\n\t// var FALL_TRACK_TAG = 0xB028;\n\t// var HIDE_TRACK_TAG = 0xB029;\n\t// var POLY_2D = 0x5000;\n\t// var SHAPE_OK = 0x5010;\n\t// var SHAPE_NOT_OK = 0x5011;\n\t// var SHAPE_HOOK = 0x5020;\n\t// var PATH_3D = 0x6000;\n\t// var PATH_MATRIX = 0x6005;\n\t// var SHAPE_2D = 0x6010;\n\t// var M_SCALE = 0x6020;\n\t// var M_TWIST = 0x6030;\n\t// var M_TEETER = 0x6040;\n\t// var M_FIT = 0x6050;\n\t// var M_BEVEL = 0x6060;\n\t// var XZ_CURVE = 0x6070;\n\t// var YZ_CURVE = 0x6080;\n\t// var INTERPCT = 0x6090;\n\t// var DEFORM_LIMIT = 0x60A0;\n\t// var USE_CONTOUR = 0x6100;\n\t// var USE_TWEEN = 0x6110;\n\t// var USE_SCALE = 0x6120;\n\t// var USE_TWIST = 0x6130;\n\t// var USE_TEETER = 0x6140;\n\t// var USE_FIT = 0x6150;\n\t// var USE_BEVEL = 0x6160;\n\t// var DEFAULT_VIEW = 0x3000;\n\t// var VIEW_TOP = 0x3010;\n\t// var VIEW_BOTTOM = 0x3020;\n\t// var VIEW_LEFT = 0x3030;\n\t// var VIEW_RIGHT = 0x3040;\n\t// var VIEW_FRONT = 0x3050;\n\t// var VIEW_BACK = 0x3060;\n\t// var VIEW_USER = 0x3070;\n\t// var VIEW_CAMERA = 0x3080;\n\t// var VIEW_WINDOW = 0x3090;\n\t// var VIEWPORT_LAYOUT_OLD = 0x7000;\n\t// var VIEWPORT_DATA_OLD = 0x7010;\n\t// var VIEWPORT_LAYOUT = 0x7001;\n\t// var VIEWPORT_DATA = 0x7011;\n\t// var VIEWPORT_DATA_3 = 0x7012;\n\t// var VIEWPORT_SIZE = 0x7020;\n\t// var NETWORK_VIEW = 0x7030;\n\t\n\treturn THREE.TDSLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/VTKLoader',[\n\t\"skylark-threejs\"\n],function(THREE,Zlib){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Alex Pletzer\n\t *\n\t * Updated on 22.03.2017\n\t * VTK header is now parsed and used to extract all the compressed data\n\t * @author Andrii Iudin https://github.com/andreyyudin\n\t * @author Paul Kibet Korir https://github.com/polarise\n\t * @author Sriram Somasundharam https://github.com/raamssundar\n\t */\n\n\tTHREE.VTKLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.VTKLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.VTKLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data ) {\n\n\t\t\tfunction parseASCII( data ) {\n\n\t\t\t\t// connectivity of the triangles\n\t\t\t\tvar indices = [];\n\n\t\t\t\t// triangles vertices\n\t\t\t\tvar positions = [];\n\n\t\t\t\t// red, green, blue colors in the range 0 to 1\n\t\t\t\tvar colors = [];\n\n\t\t\t\t// normal vector, one per vertex\n\t\t\t\tvar normals = [];\n\n\t\t\t\tvar result;\n\n\t\t\t\t// pattern for detecting the end of a number sequence\n\t\t\t\tvar patWord = /^[^\\d.\\s-]+/;\n\n\t\t\t\t// pattern for reading vertices, 3 floats or integers\n\t\t\t\tvar pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g;\n\n\t\t\t\t// pattern for connectivity, an integer followed by any number of ints\n\t\t\t\t// the first integer is the number of polygon nodes\n\t\t\t\tvar patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/;\n\n\t\t\t\t// indicates start of vertex data section\n\t\t\t\tvar patPOINTS = /^POINTS /;\n\n\t\t\t\t// indicates start of polygon connectivity section\n\t\t\t\tvar patPOLYGONS = /^POLYGONS /;\n\n\t\t\t\t// indicates start of triangle strips section\n\t\t\t\tvar patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;\n\n\t\t\t\t// POINT_DATA number_of_values\n\t\t\t\tvar patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/;\n\n\t\t\t\t// CELL_DATA number_of_polys\n\t\t\t\tvar patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/;\n\n\t\t\t\t// Start of color section\n\t\t\t\tvar patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/;\n\n\t\t\t\t// NORMALS Normals float\n\t\t\t\tvar patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n\n\t\t\t\tvar inPointsSection = false;\n\t\t\t\tvar inPolygonsSection = false;\n\t\t\t\tvar inTriangleStripSection = false;\n\t\t\t\tvar inPointDataSection = false;\n\t\t\t\tvar inCellDataSection = false;\n\t\t\t\tvar inColorSection = false;\n\t\t\t\tvar inNormalsSection = false;\n\n\t\t\t\tvar lines = data.split( '\\n' );\n\n\t\t\t\tfor ( var i in lines ) {\n\n\t\t\t\t\tvar line = lines[ i ].trim();\n\n\t\t\t\t\tif ( line.indexOf( 'DATASET' ) === 0 ) {\n\n\t\t\t\t\t\tvar dataset = line.split( ' ' )[ 1 ];\n\n\t\t\t\t\t\tif ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );\n\n\t\t\t\t\t} else if ( inPointsSection ) {\n\n\t\t\t\t\t\t// get the vertices\n\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\t\tvar x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\tvar y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\tvar z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\tpositions.push( x, y, z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( inPolygonsSection ) {\n\n\t\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\t\tvar numVertices = parseInt( result[ 1 ] );\n\t\t\t\t\t\t\tvar inds = result[ 2 ].split( /\\s+/ );\n\n\t\t\t\t\t\t\tif ( numVertices >= 3 ) {\n\n\t\t\t\t\t\t\t\tvar i0 = parseInt( inds[ 0 ] );\n\t\t\t\t\t\t\t\tvar i1, i2;\n\t\t\t\t\t\t\t\tvar k = 1;\n\t\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\t\tfor ( var j = 0; j < numVertices - 2; ++ j ) {\n\n\t\t\t\t\t\t\t\t\ti1 = parseInt( inds[ k ] );\n\t\t\t\t\t\t\t\t\ti2 = parseInt( inds[ k + 1 ] );\n\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\t\t\t\t\t\t\t\t\tk ++;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( inTriangleStripSection ) {\n\n\t\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\t\tvar numVertices = parseInt( result[ 1 ] );\n\t\t\t\t\t\t\tvar inds = result[ 2 ].split( /\\s+/ );\n\n\t\t\t\t\t\t\tif ( numVertices >= 3 ) {\n\n\t\t\t\t\t\t\t\tvar i0, i1, i2;\n\t\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\t\tfor ( var j = 0; j < numVertices - 2; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tif ( j % 2 === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\ti0 = parseInt( inds[ j ] );\n\t\t\t\t\t\t\t\t\t\ti1 = parseInt( inds[ j + 2 ] );\n\t\t\t\t\t\t\t\t\t\ti2 = parseInt( inds[ j + 1 ] );\n\t\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ti0 = parseInt( inds[ j ] );\n\t\t\t\t\t\t\t\t\t\ti1 = parseInt( inds[ j + 1 ] );\n\t\t\t\t\t\t\t\t\t\ti2 = parseInt( inds[ j + 2 ] );\n\t\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( inPointDataSection || inCellDataSection ) {\n\n\t\t\t\t\t\tif ( inColorSection ) {\n\n\t\t\t\t\t\t\t// Get the colors\n\n\t\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\t\t\tvar r = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\t\tvar g = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\t\tvar b = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\t\tcolors.push( r, g, b );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( inNormalsSection ) {\n\n\t\t\t\t\t\t\t// Get the normal vectors\n\n\t\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\t\t\tvar nx = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\t\tvar ny = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\t\tvar nz = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\t\tnormals.push( nx, ny, nz );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( patPOLYGONS.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinPolygonsSection = true;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t} else if ( patPOINTS.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinPointsSection = true;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t} else if ( patTRIANGLE_STRIPS.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = true;\n\n\t\t\t\t\t} else if ( patPOINT_DATA.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinPointDataSection = true;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t} else if ( patCELL_DATA.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinCellDataSection = true;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t} else if ( patCOLOR_SCALARS.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinColorSection = true;\n\t\t\t\t\t\tinNormalsSection = false;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t} else if ( patNORMALS.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinNormalsSection = true;\n\t\t\t\t\t\tinColorSection = false;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\n\t\t\t\tif ( normals.length === positions.length ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( colors.length !== indices.length ) {\n\n\t\t\t\t\t// stagger\n\n\t\t\t\t\tif ( colors.length === positions.length ) {\n\n\t\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// cell\n\n\t\t\t\t\tgeometry = geometry.toNonIndexed();\n\t\t\t\t\tvar numTriangles = geometry.attributes.position.count / 3;\n\n\t\t\t\t\tif ( colors.length === ( numTriangles * 3 ) ) {\n\n\t\t\t\t\t\tvar newColors = [];\n\n\t\t\t\t\t\tfor ( var i = 0; i < numTriangles; i ++ ) {\n\n\t\t\t\t\t\t\tvar r = colors[ 3 * i + 0 ];\n\t\t\t\t\t\t\tvar g = colors[ 3 * i + 1 ];\n\t\t\t\t\t\t\tvar b = colors[ 3 * i + 2 ];\n\n\t\t\t\t\t\t\tnewColors.push( r, g, b );\n\t\t\t\t\t\t\tnewColors.push( r, g, b );\n\t\t\t\t\t\t\tnewColors.push( r, g, b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( newColors, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction parseBinary( data ) {\n\n\t\t\t\tvar count, pointIndex, i, numberOfPoints, s;\n\t\t\t\tvar buffer = new Uint8Array( data );\n\t\t\t\tvar dataView = new DataView( data );\n\n\t\t\t\t// Points and normals, by default, are empty\n\t\t\t\tvar points = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar indices = [];\n\n\t\t\t\t// Going to make a big array of strings\n\t\t\t\tvar vtk = [];\n\t\t\t\tvar index = 0;\n\n\t\t\t\tfunction findString( buffer, start ) {\n\n\t\t\t\t\tvar index = start;\n\t\t\t\t\tvar c = buffer[ index ];\n\t\t\t\t\tvar s = [];\n\t\t\t\t\twhile ( c !== 10 ) {\n\n\t\t\t\t\t\ts.push( String.fromCharCode( c ) );\n\t\t\t\t\t\tindex ++;\n\t\t\t\t\t\tc = buffer[ index ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { start: start,\n\t\t\t\t\t\tend: index,\n\t\t\t\t\t\tnext: index + 1,\n\t\t\t\t\t\tparsedString: s.join( '' ) };\n\n\t\t\t\t}\n\n\t\t\t\tvar state, line;\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t// Get a string\n\t\t\t\t\tstate = findString( buffer, index );\n\t\t\t\t\tline = state.parsedString;\n\n\t\t\t\t\tif ( line.indexOf( 'DATASET' ) === 0 ) {\n\n\t\t\t\t\t\tvar dataset = line.split( ' ' )[ 1 ];\n\n\t\t\t\t\t\tif ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );\n\n\t\t\t\t\t} else if ( line.indexOf( 'POINTS' ) === 0 ) {\n\n\t\t\t\t\t\tvtk.push( line );\n\t\t\t\t\t\t// Add the points\n\t\t\t\t\t\tnumberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\n\n\t\t\t\t\t\t// Each point is 3 4-byte floats\n\t\t\t\t\t\tcount = numberOfPoints * 4 * 3;\n\n\t\t\t\t\t\tpoints = new Float32Array( numberOfPoints * 3 );\n\n\t\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\t\tfor ( i = 0; i < numberOfPoints; i ++ ) {\n\n\t\t\t\t\t\t\tpoints[ 3 * i ] = dataView.getFloat32( pointIndex, false );\n\t\t\t\t\t\t\tpoints[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\n\t\t\t\t\t\t\tpoints[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\n\t\t\t\t\t\t\tpointIndex = pointIndex + 12;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// increment our next pointer\n\t\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t\t} else if ( line.indexOf( 'TRIANGLE_STRIPS' ) === 0 ) {\n\n\t\t\t\t\t\tvar numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\n\t\t\t\t\t\tvar size = parseInt( line.split( ' ' )[ 2 ], 10 );\n\t\t\t\t\t\t// 4 byte integers\n\t\t\t\t\t\tcount = size * 4;\n\n\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\t\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\t\tfor ( i = 0; i < numberOfStrips; i ++ ) {\n\n\t\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\t\tvar indexCount = dataView.getInt32( pointIndex, false );\n\t\t\t\t\t\t\tvar strip = [];\n\t\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\t\tfor ( s = 0; s < indexCount; s ++ ) {\n\n\t\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\n\t\t\t\t\t\t\t\tpointIndex += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// retrieves the n-2 triangles from the triangle strip\n\t\t\t\t\t\t\tfor ( var j = 0; j < indexCount - 2; j ++ ) {\n\n\t\t\t\t\t\t\t\tif ( j % 2 ) {\n\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t\t\t} else {\n\n\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// increment our next pointer\n\t\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t\t} else if ( line.indexOf( 'POLYGONS' ) === 0 ) {\n\n\t\t\t\t\t\tvar numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\n\t\t\t\t\t\tvar size = parseInt( line.split( ' ' )[ 2 ], 10 );\n\t\t\t\t\t\t// 4 byte integers\n\t\t\t\t\t\tcount = size * 4;\n\n\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\t\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\t\tfor ( i = 0; i < numberOfStrips; i ++ ) {\n\n\t\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\t\tvar indexCount = dataView.getInt32( pointIndex, false );\n\t\t\t\t\t\t\tvar strip = [];\n\t\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\t\tfor ( s = 0; s < indexCount; s ++ ) {\n\n\t\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\n\t\t\t\t\t\t\t\tpointIndex += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// divide the polygon in n-2 triangle\n\t\t\t\t\t\t\tfor ( var j = 1; j < indexCount - 1; j ++ ) {\n\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ 0 ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// increment our next pointer\n\t\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t\t} else if ( line.indexOf( 'POINT_DATA' ) === 0 ) {\n\n\t\t\t\t\t\tnumberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\n\n\t\t\t\t\t\t// Grab the next line\n\t\t\t\t\t\tstate = findString( buffer, state.next );\n\n\t\t\t\t\t\t// Now grab the binary data\n\t\t\t\t\t\tcount = numberOfPoints * 4 * 3;\n\n\t\t\t\t\t\tnormals = new Float32Array( numberOfPoints * 3 );\n\t\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\t\tfor ( i = 0; i < numberOfPoints; i ++ ) {\n\n\t\t\t\t\t\t\tnormals[ 3 * i ] = dataView.getFloat32( pointIndex, false );\n\t\t\t\t\t\t\tnormals[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\n\t\t\t\t\t\t\tnormals[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\n\t\t\t\t\t\t\tpointIndex += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Increment past our data\n\t\t\t\t\t\tstate.next = state.next + count;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Increment index\n\t\t\t\t\tindex = state.next;\n\n\t\t\t\t\tif ( index >= buffer.byteLength ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( points, 3 ) );\n\n\t\t\t\tif ( normals.length === points.length ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction Float32Concat( first, second ) {\n\n\t\t\t    var firstLength = first.length, result = new Float32Array( firstLength + second.length );\n\n\t\t\t    result.set( first );\n\t\t\t    result.set( second, firstLength );\n\n\t\t\t    return result;\n\n\t\t\t}\n\n\t\t\tfunction Int32Concat( first, second ) {\n\n\t\t\t    var firstLength = first.length, result = new Int32Array( firstLength + second.length );\n\n\t\t\t    result.set( first );\n\t\t\t    result.set( second, firstLength );\n\n\t\t\t    return result;\n\n\t\t\t}\n\n\t\t\tfunction parseXML( stringFile ) {\n\n\t\t\t\t// Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n\n\t\t\t\tfunction xmlToJson( xml ) {\n\n\t\t\t\t\t// Create the return object\n\t\t\t\t\tvar obj = {};\n\n\t\t\t\t\tif ( xml.nodeType === 1 ) { // element\n\n\t\t\t\t\t\t// do attributes\n\n\t\t\t\t\t\tif ( xml.attributes ) {\n\n\t\t\t\t\t\t\tif ( xml.attributes.length > 0 ) {\n\n\t\t\t\t\t\t\t\tobj[ 'attributes' ] = {};\n\n\t\t\t\t\t\t\t\tfor ( var j = 0; j < xml.attributes.length; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar attribute = xml.attributes.item( j );\n\t\t\t\t\t\t\t\t\tobj[ 'attributes' ][ attribute.nodeName ] = attribute.nodeValue.trim();\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( xml.nodeType === 3 ) { // text\n\n\t\t\t\t\t\tobj = xml.nodeValue.trim();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// do children\n\t\t\t\t\tif ( xml.hasChildNodes() ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\t\t\tvar item = xml.childNodes.item( i );\n\t\t\t\t\t\t\tvar nodeName = item.nodeName;\n\n\t\t\t\t\t\t\tif ( typeof obj[ nodeName ] === 'undefined' ) {\n\n\t\t\t\t\t\t\t\tvar tmp = xmlToJson( item );\n\n\t\t\t\t\t\t\t\tif ( tmp !== '' ) obj[ nodeName ] = tmp;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tif ( typeof obj[ nodeName ].push === 'undefined' ) {\n\n\t\t\t\t\t\t\t\t\tvar old = obj[ nodeName ];\n\t\t\t\t\t\t\t\t\tobj[ nodeName ] = [ old ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar tmp = xmlToJson( item );\n\n\t\t\t\t\t\t\t\tif ( tmp !== '' ) obj[ nodeName ].push( tmp );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn obj;\n\n\t\t\t\t}\n\n\t\t\t\t// Taken from Base64-js\n\t\t\t\tfunction Base64toByteArray( b64 ) {\n\n\t\t\t\t\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar lookup = [];\n\t\t\t\t\tvar revLookup = [];\n\t\t\t\t\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\t\t\t\tvar len = code.length;\n\n\t\t\t\t\tfor ( i = 0; i < len; i ++ ) {\n\n\t\t\t\t\t\tlookup[ i ] = code[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( i = 0; i < len; ++ i ) {\n\n\t\t\t\t\t\trevLookup[ code.charCodeAt( i ) ] = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t\trevLookup[ '-'.charCodeAt( 0 ) ] = 62;\n\t\t\t\t\trevLookup[ '_'.charCodeAt( 0 ) ] = 63;\n\n\t\t\t\t\tvar j, l, tmp, placeHolders, arr;\n\t\t\t\t\tvar len = b64.length;\n\n\t\t\t\t\tif ( len % 4 > 0 ) {\n\n\t\t\t\t\t\tthrow new Error( 'Invalid string. Length must be a multiple of 4' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tplaceHolders = b64[ len - 2 ] === '=' ? 2 : b64[ len - 1 ] === '=' ? 1 : 0;\n\t\t\t\t\tarr = new Arr( len * 3 / 4 - placeHolders );\n\t\t\t\t\tl = placeHolders > 0 ? len - 4 : len;\n\n\t\t\t\t\tvar L = 0;\n\n\t\t\t\t\tfor ( i = 0, j = 0; i < l; i += 4, j += 3 ) {\n\n\t\t\t\t\t\ttmp = ( revLookup[ b64.charCodeAt( i ) ] << 18 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 12 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] << 6 ) | revLookup[ b64.charCodeAt( i + 3 ) ];\n\t\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF0000 ) >> 16;\n\t\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF00 ) >> 8;\n\t\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( placeHolders === 2 ) {\n\n\t\t\t\t\t\ttmp = ( revLookup[ b64.charCodeAt( i ) ] << 2 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] >> 4 );\n\t\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t\t} else if ( placeHolders === 1 ) {\n\n\t\t\t\t\t\ttmp = ( revLookup[ b64.charCodeAt( i ) ] << 10 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 4 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] >> 2 );\n\t\t\t\t\t\tarr[ L ++ ] = ( tmp >> 8 ) & 0xFF;\n\t\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn arr;\n\n\t\t\t\t}\n\n\t\t\t\tfunction parseDataArray( ele, compressed ) {\n\n\t\t\t\t\tvar numBytes = 0;\n\n\t\t\t\t\tif ( json.attributes.header_type === 'UInt64' ) {\n\n\t\t\t\t\t\tnumBytes = 8;\n\n\t\t\t\t\t}\telse if ( json.attributes.header_type === 'UInt32' ) {\n\n\t\t\t\t\t\tnumBytes = 4;\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// Check the format\n\t\t\t\t\tif ( ele.attributes.format === 'binary' && compressed ) {\n\n\t\t\t\t\t\tvar rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n\n\t\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\t\tvar txt = new Float32Array( );\n\n\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\t\tvar txt = new Int32Array( );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// VTP data with the header has the following structure:\n\t\t\t\t\t\t// [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n\t\t\t\t\t\t// [#blocks] = Number of blocks\n\t\t\t\t\t\t// [#u-size] = Block size before compression\n\t\t\t\t\t\t// [#p-size] = Size of last partial block (zero if it not needed)\n\t\t\t\t\t\t// [#c-size-i] = Size in bytes of block i after compression\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n\t\t\t\t\t\t// computed by summing the compressed block sizes from preceding blocks according to the header.\n\n\t\t\t\t\t\trawData = ele[ '#text' ];\n\n\t\t\t\t\t\tbyteData = Base64toByteArray( rawData );\n\n\t\t\t\t\t\tblocks = byteData[ 0 ];\n\t\t\t\t\t\tfor ( var i = 1; i < numBytes - 1; i ++ ) {\n\n\t\t\t\t\t\t\tblocks = blocks | ( byteData[ i ] << ( i * numBytes ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\theaderSize = ( blocks + 3 ) * numBytes;\n\t\t\t\t\t\tpadding = ( ( headerSize % 3 ) > 0 ) ? 3 - ( headerSize % 3 ) : 0;\n\t\t\t\t\t\theaderSize = headerSize + padding;\n\n\t\t\t\t\t\tdataOffsets = [];\n\t\t\t\t\t\tcurrentOffset = headerSize;\n\t\t\t\t\t\tdataOffsets.push( currentOffset );\n\n\t\t\t\t\t\t// Get the blocks sizes after the compression.\n\t\t\t\t\t\t// There are three blocks before c-size-i, so we skip 3*numBytes\n\t\t\t\t\t\tcSizeStart = 3 * numBytes;\n\n\t\t\t\t\t\tfor ( var i = 0; i < blocks; i ++ ) {\n\n\t\t\t\t\t\t\tvar currentBlockSize = byteData[ i * numBytes + cSizeStart ];\n\n\t\t\t\t\t\t\tfor ( var j = 1; j < numBytes - 1; j ++ ) {\n\n\t\t\t\t\t\t\t\t// Each data point consists of 8 bytes regardless of the header type\n\t\t\t\t\t\t\t\tcurrentBlockSize = currentBlockSize | ( byteData[ i * numBytes + cSizeStart + j ] << ( j * 8 ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcurrentOffset = currentOffset + currentBlockSize;\n\t\t\t\t\t\t\tdataOffsets.push( currentOffset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( var i = 0; i < dataOffsets.length - 1; i ++ ) {\n\n\t\t\t\t\t\t\tvar inflate = new Zlib.Inflate( byteData.slice( dataOffsets[ i ], dataOffsets[ i + 1 ] ), { resize: true, verify: true } ); // eslint-disable-line no-undef\n\t\t\t\t\t\t\tcontent = inflate.decompress();\n\t\t\t\t\t\t\tcontent = content.buffer;\n\n\t\t\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\t\t\tcontent = new Float32Array( content );\n\t\t\t\t\t\t\t\ttxt = Float32Concat( txt, content );\n\n\t\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\t\t\tcontent = new Int32Array( content );\n\t\t\t\t\t\t\t\ttxt = Int32Concat( txt, content );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete ele[ '#text' ];\n\n\t\t\t\t\t\tif ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\n\n\t\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\n\n\t\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) return true;\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ele.attributes.format === 'binary' && ! compressed ) {\n\n\t\t\t\t\t\t\tvar content = Base64toByteArray( ele[ '#text' ] );\n\n\t\t\t\t\t\t\t//  VTP data for the uncompressed case has the following structure:\n\t\t\t\t\t\t\t// [#bytes][DATA]\n\t\t\t\t\t\t\t// where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\t\t\t\t\t\t\tcontent = content.slice( numBytes ).buffer;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( ele[ '#text' ] ) {\n\n\t\t\t\t\t\t\t\tvar content = ele[ '#text' ].split( /\\s+/ ).filter( function ( el ) {\n\n\t\t\t\t\t\t\t\t\tif ( el !== '' ) return el;\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar content = new Int32Array( 0 ).buffer;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete ele[ '#text' ];\n\n\t\t\t\t\t\t// Get the content and optimize it\n\t\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\t\tvar txt = new Float32Array( content );\n\n\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int32' ) {\n\n\t\t\t\t\t\t\tvar txt = new Int32Array( content );\n\n\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\t\tvar txt = new Int32Array( content );\n\n\t\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\n\n\t\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\n\n\t\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) return true;\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // endif ( ele.attributes.format === 'binary' && compressed )\n\n\t\t\t\t\treturn txt;\n\n\t\t\t\t}\n\n\t\t\t\t// Main part\n\t\t\t\t// Get Dom\n\t\t\t\tvar dom = null;\n\n\t\t\t\tif ( window.DOMParser ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tdom = ( new DOMParser() ).parseFromString( stringFile, 'text/xml' );\n\n\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\tdom = null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( window.ActiveXObject ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tdom = new ActiveXObject( 'Microsoft.XMLDOM' ); // eslint-disable-line no-undef\n\t\t\t\t\t\tdom.async = false;\n\n\t\t\t\t\t\tif ( ! dom.loadXML( /* xml */ ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( dom.parseError.reason + dom.parseError.srcText );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\tdom = null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'Cannot parse xml string!' );\n\n\t\t\t\t}\n\n\t\t\t\t// Get the doc\n\t\t\t\tvar doc = dom.documentElement;\n\t\t\t\t// Convert to json\n\t\t\t\tvar json = xmlToJson( doc );\n\t\t\t\tvar points = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar indices = [];\n\n\t\t\t\tif ( json.PolyData ) {\n\n\t\t\t\t\tvar piece = json.PolyData.Piece;\n\t\t\t\t\tvar compressed = json.attributes.hasOwnProperty( 'compressor' );\n\n\t\t\t\t\t// Can be optimized\n\t\t\t\t\t// Loop through the sections\n\t\t\t\t\tvar sections = [ 'PointData', 'Points', 'Strips', 'Polys' ];// +['CellData', 'Verts', 'Lines'];\n\t\t\t\t\tvar sectionIndex = 0, numberOfSections = sections.length;\n\n\t\t\t\t\twhile ( sectionIndex < numberOfSections ) {\n\n\t\t\t\t\t\tvar section = piece[ sections[ sectionIndex ] ];\n\n\t\t\t\t\t\t// If it has a DataArray in it\n\n\t\t\t\t\t\tif ( section && section.DataArray ) {\n\n\t\t\t\t\t\t\t// Depending on the number of DataArrays\n\n\t\t\t\t\t\t\tif ( Object.prototype.toString.call( section.DataArray ) === '[object Array]' ) {\n\n\t\t\t\t\t\t\t\tvar arr = section.DataArray;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar arr = [ section.DataArray ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar dataArrayIndex = 0, numberOfDataArrays = arr.length;\n\n\t\t\t\t\t\t\twhile ( dataArrayIndex < numberOfDataArrays ) {\n\n\t\t\t\t\t\t\t\t// Parse the DataArray\n\t\t\t\t\t\t\t\tif ( ( '#text' in arr[ dataArrayIndex ] ) && ( arr[ dataArrayIndex ][ '#text' ].length > 0 ) ) {\n\n\t\t\t\t\t\t\t\t\tarr[ dataArrayIndex ].text = parseDataArray( arr[ dataArrayIndex ], compressed );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tdataArrayIndex ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tswitch ( sections[ sectionIndex ] ) {\n\n\t\t\t\t\t\t\t\t// if iti is point data\n\t\t\t\t\t\t\t\tcase 'PointData':\n\n\t\t\t\t\t\t\t\t\tvar numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\n\t\t\t\t\t\t\t\t\tvar normalsName = section.attributes.Normals;\n\n\t\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tfor ( var i = 0, len = arr.length; i < len; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( normalsName === arr[ i ].attributes.Name ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar components = arr[ i ].attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\t\t\t\tnormals = new Float32Array( numberOfPoints * components );\n\t\t\t\t\t\t\t\t\t\t\t\tnormals.set( arr[ i ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t// if it is points\n\t\t\t\t\t\t\t\tcase 'Points':\n\n\t\t\t\t\t\t\t\t\tvar numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\n\n\t\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tvar components = section.DataArray.attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\t\tpoints = new Float32Array( numberOfPoints * components );\n\t\t\t\t\t\t\t\t\t\tpoints.set( section.DataArray.text, 0 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t// if it is strips\n\t\t\t\t\t\t\t\tcase 'Strips':\n\n\t\t\t\t\t\t\t\t\tvar numberOfStrips = parseInt( piece.attributes.NumberOfStrips );\n\n\t\t\t\t\t\t\t\t\tif ( numberOfStrips > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tvar connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\n\t\t\t\t\t\t\t\t\t\tvar offset = new Int32Array( section.DataArray[ 1 ].text.length );\n\t\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\n\t\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\tvar size = numberOfStrips + connectivity.length;\n\t\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\n\t\t\t\t\t\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\t\t\t\t\t\tfor ( var i = 0, len = numberOfStrips; i < len; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar strip = [];\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( var s = 0, len1 = offset[ i ], len0 = 0; s < len1 - len0; s ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tstrip.push( connectivity[ s ] );\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) len0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( var j = 0, len1 = offset[ i ], len0 = 0; j < len1 - len0 - 2; j ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( j % 2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) len0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t// if it is polys\n\t\t\t\t\t\t\t\tcase 'Polys':\n\n\t\t\t\t\t\t\t\t\tvar numberOfPolys = parseInt( piece.attributes.NumberOfPolys );\n\n\t\t\t\t\t\t\t\t\tif ( numberOfPolys > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tvar connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\n\t\t\t\t\t\t\t\t\t\tvar offset = new Int32Array( section.DataArray[ 1 ].text.length );\n\t\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\n\t\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\tvar size = numberOfPolys + connectivity.length;\n\t\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfPolys );\n\t\t\t\t\t\t\t\t\t\tvar indicesIndex = 0, connectivityIndex = 0;\n\t\t\t\t\t\t\t\t\t\tvar i = 0, len = numberOfPolys, len0 = 0;\n\n\t\t\t\t\t\t\t\t\t\twhile ( i < len ) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar poly = [];\n\t\t\t\t\t\t\t\t\t\t\tvar s = 0, len1 = offset[ i ];\n\n\t\t\t\t\t\t\t\t\t\t\twhile ( s < len1 - len0 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpoly.push( connectivity[ connectivityIndex ++ ] );\n\t\t\t\t\t\t\t\t\t\t\t\ts ++;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tvar j = 1;\n\n\t\t\t\t\t\t\t\t\t\t\twhile ( j < len1 - len0 - 1 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ 0 ];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j + 1 ];\n\t\t\t\t\t\t\t\t\t\t\t\tj ++;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\ti ++;\n\t\t\t\t\t\t\t\t\t\t\tlen0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsectionIndex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( points, 3 ) );\n\n\t\t\t\t\tif ( normals.length === points.length ) {\n\n\t\t\t\t\t\tgeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'Unsupported DATASET type' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getStringFile( data ) {\n\n\t\t\t\tvar stringFile = '';\n\t\t\t\tvar charArray = new Uint8Array( data );\n\t\t\t\tvar i = 0;\n\t\t\t\tvar len = charArray.length;\n\n\t\t\t\twhile ( len -- ) {\n\n\t\t\t\t\tstringFile += String.fromCharCode( charArray[ i ++ ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn stringFile;\n\n\t\t\t}\n\n\t\t\t// get the 5 first lines of the files to check if there is the key word binary\n\t\t\tvar meta = THREE.LoaderUtils.decodeText( new Uint8Array( data, 0, 250 ) ).split( '\\n' );\n\n\t\t\tif ( meta[ 0 ].indexOf( 'xml' ) !== - 1 ) {\n\n\t\t\t\treturn parseXML( getStringFile( data ) );\n\n\t\t\t} else if ( meta[ 2 ].includes( 'ASCII' ) ) {\n\n\t\t\t\treturn parseASCII( getStringFile( data ) );\n\n\t\t\t} else {\n\n\t\t\t\treturn parseBinary( data );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.VTKLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/XLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author adrs2002 / https://github.com/adrs2002\n\t */\n\n\tTHREE.XLoader = ( function () {\n\n\t\tvar classCallCheck = function ( instance, Constructor ) {\n\n\t\t\tif ( ! ( instance instanceof Constructor ) ) {\n\n\t\t\t\tthrow new TypeError( \"Cannot call a class as a function\" );\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar createClass = function () {\n\n\t\t\tfunction defineProperties( target, props ) {\n\n\t\t\t\tfor ( var i = 0; i < props.length; i ++ ) {\n\n\t\t\t\t\tvar descriptor = props[ i ];\n\t\t\t\t\tdescriptor.enumerable = descriptor.enumerable || false;\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t\tif ( \"value\" in descriptor ) descriptor.writable = true;\n\t\t\t\t\tObject.defineProperty( target, descriptor.key, descriptor );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn function ( Constructor, protoProps, staticProps ) {\n\n\t\t\t\tif ( protoProps ) defineProperties( Constructor.prototype, protoProps );\n\t\t\t\tif ( staticProps ) defineProperties( Constructor, staticProps );\n\t\t\t\treturn Constructor;\n\n\t\t\t};\n\n\t\t}();\n\n\t\tvar XboneInf = function XboneInf() {\n\n\t\t\tclassCallCheck( this, XboneInf );\n\n\t\t\tthis.boneName = \"\";\n\t\t\tthis.BoneIndex = 0;\n\t\t\tthis.Indeces = [];\n\t\t\tthis.Weights = [];\n\t\t\tthis.initMatrix = null;\n\t\t\tthis.OffsetMatrix = null;\n\n\t\t};\n\n\t\tvar XAnimationInfo = function XAnimationInfo() {\n\n\t\t\tclassCallCheck( this, XAnimationInfo );\n\n\t\t\tthis.animeName = \"\";\n\t\t\tthis.boneName = \"\";\n\t\t\tthis.targetBone = null;\n\t\t\tthis.keyType = 4;\n\t\t\tthis.frameStartLv = 0;\n\t\t\tthis.keyFrames = [];\n\t\t\tthis.InverseMx = null;\n\n\t\t};\n\n\t\tvar XAnimationObj = function () {\n\n\t\t\tfunction XAnimationObj( _flags ) {\n\n\t\t\t\tclassCallCheck( this, XAnimationObj );\n\n\t\t\t\tthis.fps = 30;\n\t\t\t\tthis.name = 'xanimation';\n\t\t\t\tthis.length = 0;\n\t\t\t\tthis.hierarchy = [];\n\t\t\t\tthis.putFlags = _flags;\n\t\t\t\tif ( this.putFlags.putPos === undefined ) {\n\n\t\t\t\t\tthis.putFlags.putPos = true;\n\n\t\t\t\t}\n\t\t\t\tif ( this.putFlags.putRot === undefined ) {\n\n\t\t\t\t\tthis.putFlags.putRot = true;\n\n\t\t\t\t}\n\t\t\t\tif ( this.putFlags.putScl === undefined ) {\n\n\t\t\t\t\tthis.putFlags.putScl = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcreateClass( XAnimationObj, [ {\n\t\t\t\tkey: \"make\",\n\t\t\t\tvalue: function make( XAnimationInfoArray ) {\n\n\t\t\t\t\tfor ( var i = 0; i < XAnimationInfoArray.length; i ++ ) {\n\n\t\t\t\t\t\tthis.hierarchy.push( this.makeBonekeys( XAnimationInfoArray[ i ] ) );\n\n\t\t\t\t\t}\n\t\t\t\t\tthis.length = this.hierarchy[ 0 ].keys[ this.hierarchy[ 0 ].keys.length - 1 ].time;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: \"clone\",\n\t\t\t\tvalue: function clone() {\n\n\t\t\t\t\treturn Object.assign( {}, this );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: \"makeBonekeys\",\n\t\t\t\tvalue: function makeBonekeys( XAnimationInfo ) {\n\n\t\t\t\t\tvar refObj = {};\n\t\t\t\t\trefObj.name = XAnimationInfo.boneName;\n\t\t\t\t\trefObj.parent = \"\";\n\t\t\t\t\trefObj.keys = this.keyFrameRefactor( XAnimationInfo );\n\t\t\t\t\trefObj.copy = function () {\n\n\t\t\t\t\t\treturn Object.assign( {}, this );\n\n\t\t\t\t\t};\n\t\t\t\t\treturn refObj;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: \"keyFrameRefactor\",\n\t\t\t\tvalue: function keyFrameRefactor( XAnimationInfo ) {\n\n\t\t\t\t\tvar keys = [];\n\t\t\t\t\tfor ( var i = 0; i < XAnimationInfo.keyFrames.length; i ++ ) {\n\n\t\t\t\t\t\tvar keyframe = {};\n\t\t\t\t\t\tkeyframe.time = XAnimationInfo.keyFrames[ i ].time * this.fps;\n\t\t\t\t\t\tif ( XAnimationInfo.keyFrames[ i ].pos && this.putFlags.putPos ) {\n\n\t\t\t\t\t\t\tkeyframe.pos = XAnimationInfo.keyFrames[ i ].pos;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( XAnimationInfo.keyFrames[ i ].rot && this.putFlags.putRot ) {\n\n\t\t\t\t\t\t\tkeyframe.rot = XAnimationInfo.keyFrames[ i ].rot;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( XAnimationInfo.keyFrames[ i ].scl && this.putFlags.putScl ) {\n\n\t\t\t\t\t\t\tkeyframe.scl = XAnimationInfo.keyFrames[ i ].scl;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( XAnimationInfo.keyFrames[ i ].matrix ) {\n\n\t\t\t\t\t\t\tkeyframe.matrix = XAnimationInfo.keyFrames[ i ].matrix;\n\t\t\t\t\t\t\tif ( this.putFlags.putPos ) {\n\n\t\t\t\t\t\t\t\tkeyframe.pos = new THREE.Vector3().setFromMatrixPosition( keyframe.matrix );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( this.putFlags.putRot ) {\n\n\t\t\t\t\t\t\t\tkeyframe.rot = new THREE.Quaternion().setFromRotationMatrix( keyframe.matrix );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( this.putFlags.putScl ) {\n\n\t\t\t\t\t\t\t\tkeyframe.scl = new THREE.Vector3().setFromMatrixScale( keyframe.matrix );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkeys.push( keyframe );\n\n\t\t\t\t\t}\n\t\t\t\t\treturn keys;\n\n\t\t\t\t}\n\t\t\t} ] );\n\t\t\treturn XAnimationObj;\n\n\t\t}();\n\n\t\tvar XKeyFrameInfo = function XKeyFrameInfo() {\n\n\t\t\tclassCallCheck( this, XKeyFrameInfo );\n\n\t\t\tthis.index = 0;\n\t\t\tthis.Frame = 0;\n\t\t\tthis.time = 0.0;\n\t\t\tthis.matrix = null;\n\n\t\t};\n\n\t\tvar XLoader = function () {\n\n\t\t\tfunction XLoader( manager ) {\n\n\t\t\t\tTHREE.Loader.call( this, manager );\n\n\t\t\t\tclassCallCheck( this, XLoader );\n\n\t\t\t\tthis.debug = false;\n\t\t\t\tthis.texloader = new THREE.TextureLoader( this.manager );\n\t\t\t\tthis.url = \"\";\n\t\t\t\tthis._putMatLength = 0;\n\t\t\t\tthis._nowMat = null;\n\t\t\t\tthis._nowFrameName = \"\";\n\t\t\t\tthis.frameHierarchie = [];\n\t\t\t\tthis.Hierarchies = {};\n\t\t\t\tthis.HieStack = [];\n\t\t\t\tthis._currentObject = {};\n\t\t\t\tthis._currentFrame = {};\n\t\t\t\tthis._data = null;\n\t\t\t\tthis.onLoad = null;\n\t\t\t\tthis.IsUvYReverse = true;\n\t\t\t\tthis.Meshes = [];\n\t\t\t\tthis.animations = [];\n\t\t\t\tthis.animTicksPerSecond = 30;\n\t\t\t\tthis._currentGeo = null;\n\t\t\t\tthis._currentAnime = null;\n\t\t\t\tthis._currentAnimeFrames = null;\n\n\t\t\t}\n\n\t\t\tcreateClass( XLoader, [ {\n\t\t\t\tkey: '_setArgOption',\n\t\t\t\tvalue: function _setArgOption( _arg ) {\n\n\t\t\t\t\tvar _start = arguments.length > 1 && arguments[ 1 ] !== undefined ? arguments[ 1 ] : 0;\n\n\t\t\t\t\tif ( ! _arg ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\t\t\t\t\tfor ( var i = _start; i < _arg.length; i ++ ) {\n\n\t\t\t\t\t\tswitch ( i ) {\n\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tthis.url = _arg[ i ];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tthis.options = _arg[ i ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( this.options === undefined ) {\n\n\t\t\t\t\t\tthis.options = {};\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'load',\n\t\t\t\tvalue: function load( _arg, onLoad, onProgress, onError ) {\n\n\t\t\t\t\tvar _this = this;\n\n\t\t\t\t\tthis._setArgOption( _arg );\n\t\t\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\t\t\tloader.setPath( this.path );\n\t\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\t\t\tloader.load( this.url, function ( response ) {\n\n\t\t\t\t\t\t_this.parse( response, onLoad );\n\n\t\t\t\t\t}, onProgress, onError );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_readLine',\n\t\t\t\tvalue: function _readLine( line ) {\n\n\t\t\t\t\tvar readed = 0;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tvar find = - 1;\n\t\t\t\t\t\tfind = line.indexOf( '//', readed );\n\t\t\t\t\t\tif ( find === - 1 ) {\n\n\t\t\t\t\t\t\tfind = line.indexOf( '#', readed );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( find > - 1 && find < 2 ) {\n\n\t\t\t\t\t\t\tvar foundNewLine = - 1;\n\t\t\t\t\t\t\tfoundNewLine = line.indexOf( \"\\r\\n\", readed );\n\t\t\t\t\t\t\tif ( foundNewLine > 0 ) {\n\n\t\t\t\t\t\t\t\treaded = foundNewLine + 2;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tfoundNewLine = line.indexOf( \"\\r\", readed );\n\t\t\t\t\t\t\t\tif ( foundNewLine > 0 ) {\n\n\t\t\t\t\t\t\t\t\treaded = foundNewLine + 1;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\treaded = line.indexOf( \"\\n\", readed ) + 1;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn line.substr( readed );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_readLine',\n\t\t\t\tvalue: function _readLine( line ) {\n\n\t\t\t\t\tvar readed = 0;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tvar find = - 1;\n\t\t\t\t\t\tfind = line.indexOf( '//', readed );\n\t\t\t\t\t\tif ( find === - 1 ) {\n\n\t\t\t\t\t\t\tfind = line.indexOf( '#', readed );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( find > - 1 && find < 2 ) {\n\n\t\t\t\t\t\t\tvar foundNewLine = - 1;\n\t\t\t\t\t\t\tfoundNewLine = line.indexOf( \"\\r\\n\", readed );\n\t\t\t\t\t\t\tif ( foundNewLine > 0 ) {\n\n\t\t\t\t\t\t\t\treaded = foundNewLine + 2;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tfoundNewLine = line.indexOf( \"\\r\", readed );\n\t\t\t\t\t\t\t\tif ( foundNewLine > 0 ) {\n\n\t\t\t\t\t\t\t\t\treaded = foundNewLine + 1;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\treaded = line.indexOf( \"\\n\", readed ) + 1;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn line.substr( readed );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_isBinary',\n\t\t\t\tvalue: function _isBinary( binData ) {\n\n\t\t\t\t\tvar reader = new DataView( binData );\n\t\t\t\t\tvar face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\n\t\t\t\t\tvar n_faces = reader.getUint32( 80, true );\n\t\t\t\t\tvar expect = 80 + 32 / 8 + n_faces * face_size;\n\t\t\t\t\tif ( expect === reader.byteLength ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\t\t\t\t\tvar fileLength = reader.byteLength;\n\t\t\t\t\tfor ( var index = 0; index < fileLength; index ++ ) {\n\n\t\t\t\t\t\tif ( reader.getUint8( index, false ) > 127 ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_ensureBinary',\n\t\t\t\tvalue: function _ensureBinary( buf ) {\n\n\t\t\t\t\tif ( typeof buf === \"string\" ) {\n\n\t\t\t\t\t\tvar array_buffer = new Uint8Array( buf.length );\n\t\t\t\t\t\tfor ( var i = 0; i < buf.length; i ++ ) {\n\n\t\t\t\t\t\t\tarray_buffer[ i ] = buf.charCodeAt( i ) & 0xff;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn array_buffer.buffer || array_buffer;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn buf;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_ensureString',\n\t\t\t\tvalue: function _ensureString( buf ) {\n\n\t\t\t\t\tif ( typeof buf !== \"string\" ) {\n\n\t\t\t\t\t\treturn THREE.LoaderUtils.decodeText( new Uint8Array( buf ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn buf;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'parse',\n\t\t\t\tvalue: function _parse( data, onLoad ) {\n\n\t\t\t\t\tvar binData = this._ensureBinary( data );\n\t\t\t\t\tthis._data = this._ensureString( data );\n\t\t\t\t\tthis.onLoad = onLoad;\n\t\t\t\t\treturn this._isBinary( binData ) ? this._parseBinary( binData ) : this._parseASCII();\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_parseBinary',\n\t\t\t\tvalue: function _parseBinary( data ) {\n\n\t\t\t\t\treturn this._parseASCII( THREE.LoaderUtils.decodeText( new Uint8Array( data ) ) );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_parseASCII',\n\t\t\t\tvalue: function _parseASCII() {\n\n\t\t\t\t\tvar path;\n\n\t\t\t\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\t\t\t\tpath = this.resourcePath;\n\n\t\t\t\t\t} else if ( this.path !== '' ) {\n\n\t\t\t\t\t\tpath = this.path;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpath = THREE.LoaderUtils.extractUrlBase( this.url );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.texloader.setPath( path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\t\t\tvar endRead = 16;\n\t\t\t\t\tthis.Hierarchies.children = [];\n\t\t\t\t\tthis._hierarchieParse( this.Hierarchies, endRead );\n\t\t\t\t\tthis._changeRoot();\n\t\t\t\t\tthis._currentObject = this.Hierarchies.children.shift();\n\t\t\t\t\tthis._mainloop();\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_hierarchieParse',\n\t\t\t\tvalue: function _hierarchieParse( _parent, _end ) {\n\n\t\t\t\t\tvar endRead = _end;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tvar find1 = this._data.indexOf( '{', endRead ) + 1;\n\t\t\t\t\t\tvar findEnd = this._data.indexOf( '}', endRead );\n\t\t\t\t\t\tvar findNext = this._data.indexOf( '{', find1 ) + 1;\n\t\t\t\t\t\tif ( find1 > 0 && findEnd > find1 ) {\n\n\t\t\t\t\t\t\tvar _currentObject = {};\n\t\t\t\t\t\t\t_currentObject.children = [];\n\t\t\t\t\t\t\tvar nameData = this._readLine( this._data.substr( endRead, find1 - endRead - 1 ) ).trim();\n\t\t\t\t\t\t\tvar word = nameData.split( / /g );\n\t\t\t\t\t\t\tif ( word.length > 0 ) {\n\n\t\t\t\t\t\t\t\t_currentObject.type = word[ 0 ];\n\t\t\t\t\t\t\t\tif ( word.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t_currentObject.name = word[ 1 ];\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t_currentObject.name = word[ 0 ] + this.Hierarchies.children.length;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t_currentObject.name = nameData;\n\t\t\t\t\t\t\t\t_currentObject.type = \"\";\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( _currentObject.type === \"Animation\" ) {\n\n\t\t\t\t\t\t\t\t_currentObject.data = this._data.substr( findNext, findEnd - findNext ).trim();\n\t\t\t\t\t\t\t\tvar refs = this._hierarchieParse( _currentObject, findEnd + 1 );\n\t\t\t\t\t\t\t\tendRead = refs.end;\n\t\t\t\t\t\t\t\t_currentObject.children = refs.parent.children;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar DataEnder = this._data.lastIndexOf( ';', findNext > 0 ? Math.min( findNext, findEnd ) : findEnd );\n\t\t\t\t\t\t\t\t_currentObject.data = this._data.substr( find1, DataEnder - find1 ).trim();\n\t\t\t\t\t\t\t\tif ( findNext <= 0 || findEnd < findNext ) {\n\n\t\t\t\t\t\t\t\t\tendRead = findEnd + 1;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tvar nextStart = Math.max( DataEnder + 1, find1 );\n\t\t\t\t\t\t\t\t\tvar _refs = this._hierarchieParse( _currentObject, nextStart );\n\t\t\t\t\t\t\t\t\tendRead = _refs.end;\n\t\t\t\t\t\t\t\t\t_currentObject.children = _refs.parent.children;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_currentObject.parent = _parent;\n\t\t\t\t\t\t\tif ( _currentObject.type != \"template\" ) {\n\n\t\t\t\t\t\t\t\t_parent.children.push( _currentObject );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tendRead = find1 === - 1 ? this._data.length : findEnd + 1;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tparent: _parent,\n\t\t\t\t\t\tend: endRead\n\t\t\t\t\t};\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_mainloop',\n\t\t\t\tvalue: function _mainloop() {\n\n\t\t\t\t\tvar _this2 = this;\n\n\t\t\t\t\tthis._mainProc();\n\t\t\t\t\tif ( this._currentObject.parent || this._currentObject.children.length > 0 || ! this._currentObject.worked ) {\n\n\t\t\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\t\t\t_this2._mainloop();\n\n\t\t\t\t\t\t}, 1 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tsetTimeout( function () {\n\n\t\t\t\t\t\t\t_this2.onLoad( {\n\t\t\t\t\t\t\t\tmodels: _this2.Meshes,\n\t\t\t\t\t\t\t\tanimations: _this2.animations\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_mainProc',\n\t\t\t\tvalue: function _mainProc() {\n\n\t\t\t\t\tvar breakFlag = false;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tif ( ! this._currentObject.worked ) {\n\n\t\t\t\t\t\t\tswitch ( this._currentObject.type ) {\n\n\t\t\t\t\t\t\t\tcase \"template\":\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"AnimTicksPerSecond\":\n\t\t\t\t\t\t\t\t\tthis.animTicksPerSecond = parseInt( this._currentObject.data );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"Frame\":\n\t\t\t\t\t\t\t\t\tthis._setFrame();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"FrameTransformMatrix\":\n\t\t\t\t\t\t\t\t\tthis._setFrameTransformMatrix();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"Mesh\":\n\t\t\t\t\t\t\t\t\tthis._changeRoot();\n\t\t\t\t\t\t\t\t\tthis._currentGeo = {};\n\t\t\t\t\t\t\t\t\tthis._currentGeo.name = this._currentObject.name.trim();\n\t\t\t\t\t\t\t\t\tthis._currentGeo.parentName = this._getParentName( this._currentObject ).trim();\n\t\t\t\t\t\t\t\t\tthis._currentGeo.VertexSetedBoneCount = [];\n\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData = {\n\t\t\t\t\t\t\t\t\t\tvertices: [],\n\t\t\t\t\t\t\t\t\t\tnormals: [],\n\t\t\t\t\t\t\t\t\t\tuvs: [],\n\t\t\t\t\t\t\t\t\t\tskinIndices: [],\n\t\t\t\t\t\t\t\t\t\tskinWeights: [],\n\t\t\t\t\t\t\t\t\t\tindices: [],\n\t\t\t\t\t\t\t\t\t\tmaterialIndices: []\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tthis._currentGeo.Materials = [];\n\t\t\t\t\t\t\t\t\tthis._currentGeo.normalVectors = [];\n\t\t\t\t\t\t\t\t\tthis._currentGeo.BoneInfs = [];\n\t\t\t\t\t\t\t\t\tthis._currentGeo.baseFrame = this._currentFrame;\n\t\t\t\t\t\t\t\t\tthis._makeBoneFrom_CurrentFrame();\n\t\t\t\t\t\t\t\t\tthis._readVertexDatas();\n\t\t\t\t\t\t\t\t\tbreakFlag = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"MeshNormals\":\n\t\t\t\t\t\t\t\t\tthis._readVertexDatas();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"MeshTextureCoords\":\n\t\t\t\t\t\t\t\t\tthis._setMeshTextureCoords();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"VertexDuplicationIndices\":\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"MeshMaterialList\":\n\t\t\t\t\t\t\t\t\tthis._setMeshMaterialList();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"Material\":\n\t\t\t\t\t\t\t\t\tthis._setMaterial();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"SkinWeights\":\n\t\t\t\t\t\t\t\t\tthis._setSkinWeights();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"AnimationSet\":\n\t\t\t\t\t\t\t\t\tthis._changeRoot();\n\t\t\t\t\t\t\t\t\tthis._currentAnime = {};\n\t\t\t\t\t\t\t\t\tthis._currentAnime.name = this._currentObject.name.trim();\n\t\t\t\t\t\t\t\t\tthis._currentAnime.AnimeFrames = [];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"Animation\":\n\t\t\t\t\t\t\t\t\tif ( this._currentAnimeFrames ) {\n\n\t\t\t\t\t\t\t\t\t\tthis._currentAnime.AnimeFrames.push( this._currentAnimeFrames );\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tthis._currentAnimeFrames = new XAnimationInfo();\n\t\t\t\t\t\t\t\t\tthis._currentAnimeFrames.boneName = this._currentObject.data.trim();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"AnimationKey\":\n\t\t\t\t\t\t\t\t\tthis._readAnimationKey();\n\t\t\t\t\t\t\t\t\tbreakFlag = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._currentObject.worked = true;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( this._currentObject.children.length > 0 ) {\n\n\t\t\t\t\t\t\tthis._currentObject = this._currentObject.children.shift();\n\t\t\t\t\t\t\tif ( this.debug ) {\n\n\t\t\t\t\t\t\t\tconsole.log( 'processing ' + this._currentObject.name );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( breakFlag ) break;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( this._currentObject.worked ) {\n\n\t\t\t\t\t\t\t\tif ( this._currentObject.parent && ! this._currentObject.parent.parent ) {\n\n\t\t\t\t\t\t\t\t\tthis._changeRoot();\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( this._currentObject.parent ) {\n\n\t\t\t\t\t\t\t\tthis._currentObject = this._currentObject.parent;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tbreakFlag = true;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( breakFlag ) break;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_changeRoot',\n\t\t\t\tvalue: function _changeRoot() {\n\n\t\t\t\t\tif ( this._currentGeo != null && this._currentGeo.name ) {\n\n\t\t\t\t\t\tthis._makeOutputGeometry();\n\n\t\t\t\t\t}\n\t\t\t\t\tthis._currentGeo = {};\n\t\t\t\t\tif ( this._currentAnime != null && this._currentAnime.name ) {\n\n\t\t\t\t\t\tif ( this._currentAnimeFrames ) {\n\n\t\t\t\t\t\t\tthis._currentAnime.AnimeFrames.push( this._currentAnimeFrames );\n\t\t\t\t\t\t\tthis._currentAnimeFrames = null;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._makeOutputAnimation();\n\n\t\t\t\t\t}\n\t\t\t\t\tthis._currentAnime = {};\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_getParentName',\n\t\t\t\tvalue: function _getParentName( _obj ) {\n\n\t\t\t\t\tif ( _obj.parent ) {\n\n\t\t\t\t\t\tif ( _obj.parent.name ) {\n\n\t\t\t\t\t\t\treturn _obj.parent.name;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\treturn this._getParentName( _obj.parent );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn \"\";\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_setFrame',\n\t\t\t\tvalue: function _setFrame() {\n\n\t\t\t\t\tthis._nowFrameName = this._currentObject.name.trim();\n\t\t\t\t\tthis._currentFrame = {};\n\t\t\t\t\tthis._currentFrame.name = this._nowFrameName;\n\t\t\t\t\tthis._currentFrame.children = [];\n\t\t\t\t\tif ( this._currentObject.parent && this._currentObject.parent.name ) {\n\n\t\t\t\t\t\tthis._currentFrame.parentName = this._currentObject.parent.name;\n\n\t\t\t\t\t}\n\t\t\t\t\tthis.frameHierarchie.push( this._nowFrameName );\n\t\t\t\t\tthis.HieStack[ this._nowFrameName ] = this._currentFrame;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_setFrameTransformMatrix',\n\t\t\t\tvalue: function _setFrameTransformMatrix() {\n\n\t\t\t\t\tthis._currentFrame.FrameTransformMatrix = new THREE.Matrix4();\n\t\t\t\t\tvar data = this._currentObject.data.split( \",\" );\n\t\t\t\t\tthis._ParseMatrixData( this._currentFrame.FrameTransformMatrix, data );\n\t\t\t\t\tthis._makeBoneFrom_CurrentFrame();\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_makeBoneFrom_CurrentFrame',\n\t\t\t\tvalue: function _makeBoneFrom_CurrentFrame() {\n\n\t\t\t\t\tif ( ! this._currentFrame.FrameTransformMatrix ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\t\t\t\t\tvar b = new THREE.Bone();\n\t\t\t\t\tb.name = this._currentFrame.name;\n\t\t\t\t\tb.applyMatrix4( this._currentFrame.FrameTransformMatrix );\n\t\t\t\t\tb.matrixWorld = b.matrix;\n\t\t\t\t\tb.FrameTransformMatrix = this._currentFrame.FrameTransformMatrix;\n\t\t\t\t\tthis._currentFrame.putBone = b;\n\t\t\t\t\tif ( this._currentFrame.parentName ) {\n\n\t\t\t\t\t\tfor ( var frame in this.HieStack ) {\n\n\t\t\t\t\t\t\tif ( this.HieStack[ frame ].name === this._currentFrame.parentName ) {\n\n\t\t\t\t\t\t\t\tthis.HieStack[ frame ].putBone.add( this._currentFrame.putBone );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_readVertexDatas',\n\t\t\t\tvalue: function _readVertexDatas() {\n\n\t\t\t\t\tvar endRead = 0;\n\t\t\t\t\tvar mode = 0;\n\t\t\t\t\tvar mode_local = 0;\n\t\t\t\t\tvar maxLength = 0;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tvar changeMode = false;\n\t\t\t\t\t\tif ( mode_local === 0 ) {\n\n\t\t\t\t\t\t\tvar refO = this._readInt1( endRead );\n\t\t\t\t\t\t\tendRead = refO.endRead;\n\t\t\t\t\t\t\tmode_local = 1;\n\t\t\t\t\t\t\tmaxLength = this._currentObject.data.indexOf( ';;', endRead ) + 1;\n\t\t\t\t\t\t\tif ( maxLength <= 0 ) {\n\n\t\t\t\t\t\t\t\tmaxLength = this._currentObject.data.length;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar find = 0;\n\t\t\t\t\t\t\tswitch ( mode ) {\n\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tfind = this._currentObject.data.indexOf( ',', endRead ) + 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tfind = this._currentObject.data.indexOf( ';,', endRead ) + 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( find === 0 || find > maxLength ) {\n\n\t\t\t\t\t\t\t\tfind = maxLength;\n\t\t\t\t\t\t\t\tmode_local = 0;\n\t\t\t\t\t\t\t\tchangeMode = true;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tswitch ( this._currentObject.type ) {\n\n\t\t\t\t\t\t\t\tcase \"Mesh\":\n\t\t\t\t\t\t\t\t\tswitch ( mode ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\tthis._readVertex1( this._currentObject.data.substr( endRead, find - endRead ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\tthis._readFace1( this._currentObject.data.substr( endRead, find - endRead ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"MeshNormals\":\n\t\t\t\t\t\t\t\t\tswitch ( mode ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\tthis._readNormalVector1( this._currentObject.data.substr( endRead, find - endRead ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\t\t\tif ( changeMode ) {\n\n\t\t\t\t\t\t\t\tmode ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( endRead >= this._currentObject.data.length ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_readInt1',\n\t\t\t\tvalue: function _readInt1( start ) {\n\n\t\t\t\t\tvar find = this._currentObject.data.indexOf( ';', start );\n\t\t\t\t\treturn {\n\t\t\t\t\t\trefI: parseInt( this._currentObject.data.substr( start, find - start ) ),\n\t\t\t\t\t\tendRead: find + 1\n\t\t\t\t\t};\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_readVertex1',\n\t\t\t\tvalue: function _readVertex1( line ) {\n\n\t\t\t\t\tvar data = this._readLine( line.trim() ).substr( 0, line.length - 2 ).split( \";\" );\n\t\t\t\t\tthis._currentGeo.GeometryData.vertices.push( parseFloat( data[ 0 ] ), parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ) );\n\t\t\t\t\tthis._currentGeo.GeometryData.skinIndices.push( 0, 0, 0, 0 );\n\t\t\t\t\tthis._currentGeo.GeometryData.skinWeights.push( 1, 0, 0, 0 );\n\t\t\t\t\tthis._currentGeo.VertexSetedBoneCount.push( 0 );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_readFace1',\n\t\t\t\tvalue: function _readFace1( line ) {\n\n\t\t\t\t\tvar data = this._readLine( line.trim() ).substr( 2, line.length - 4 ).split( \",\" );\n\t\t\t\t\tthis._currentGeo.GeometryData.indices.push( parseInt( data[ 0 ], 10 ), parseInt( data[ 1 ], 10 ), parseInt( data[ 2 ], 10 ) );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_readNormalVector1',\n\t\t\t\tvalue: function _readNormalVector1( line ) {\n\n\t\t\t\t\tvar data = this._readLine( line.trim() ).substr( 0, line.length - 2 ).split( \";\" );\n\t\t\t\t\tthis._currentGeo.GeometryData.normals.push( parseFloat( data[ 0 ] ), parseFloat( data[ 1 ] ), parseFloat( data[ 2 ] ) );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_buildGeometry',\n\t\t\t\tvalue: function _buildGeometry() {\n\n\t\t\t\t\tvar bufferGeometry = new THREE.BufferGeometry();\n\t\t\t\t\tvar position = [];\n\t\t\t\t\tvar normals = [];\n\t\t\t\t\tvar uvs = [];\n\t\t\t\t\tvar skinIndices = [];\n\t\t\t\t\tvar skinWeights = [];\n\n\t\t\t\t\t//\n\n\t\t\t\t\tvar data = this._currentGeo.GeometryData;\n\n\t\t\t\t\tfor ( var i = 0, l = data.indices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar stride2 = data.indices[ i ] * 2;\n\t\t\t\t\t\tvar stride3 = data.indices[ i ] * 3;\n\t\t\t\t\t\tvar stride4 = data.indices[ i ] * 4;\n\n\t\t\t\t\t\tposition.push( data.vertices[ stride3 ], data.vertices[ stride3 + 1 ], data.vertices[ stride3 + 2 ] );\n\t\t\t\t\t\tnormals.push( data.normals[ stride3 ], data.normals[ stride3 + 1 ], data.normals[ stride3 + 2 ] );\n\t\t\t\t\t\tskinIndices.push( data.skinIndices[ stride4 ], data.skinIndices[ stride4 + 1 ], data.skinIndices[ stride4 + 2 ], data.skinIndices[ stride4 + 3 ] );\n\t\t\t\t\t\tskinWeights.push( data.skinWeights[ stride4 ], data.skinWeights[ stride4 + 1 ], data.skinWeights[ stride4 + 2 ], data.skinWeights[ stride4 + 3 ] );\n\t\t\t\t\t\tuvs.push( data.uvs[ stride2 ], data.uvs[ stride2 + 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\tbufferGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( position, 3 ) );\n\t\t\t\t\tbufferGeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n\t\t\t\t\tbufferGeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );\n\t\t\t\t\tbufferGeometry.setAttribute( 'skinIndex', new THREE.Uint16BufferAttribute( skinIndices, 4 ) );\n\t\t\t\t\tbufferGeometry.setAttribute( 'skinWeight', new THREE.Float32BufferAttribute( skinWeights, 4 ) );\n\n\t\t\t\t\tthis._computeGroups( bufferGeometry, data.materialIndices );\n\n\t\t\t\t\treturn bufferGeometry;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_computeGroups',\n\t\t\t\tvalue: function _computeGroups( bufferGeometry, materialIndices ) {\n\n\t\t\t\t\tvar group;\n\t\t\t\t\tvar groups = [];\n\t\t\t\t\tvar materialIndex = undefined;\n\n\t\t\t\t\tfor ( var i = 0; i < materialIndices.length; i ++ ) {\n\n\t\t\t\t\t\tvar currentMaterialIndex = materialIndices[ i ];\n\n\t\t\t\t\t\tif ( currentMaterialIndex !== materialIndex ) {\n\n\t\t\t\t\t\t\tmaterialIndex = currentMaterialIndex;\n\n\t\t\t\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgroup = {\n\t\t\t\t\t\t\t\tstart: i * 3,\n\t\t\t\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbufferGeometry.groups = groups;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_setMeshTextureCoords',\n\t\t\t\tvalue: function _setMeshTextureCoords() {\n\n\t\t\t\t\tvar endRead = 0;\n\t\t\t\t\tvar mode = 0;\n\t\t\t\t\tvar mode_local = 0;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tswitch ( mode ) {\n\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tif ( mode_local === 0 ) {\n\n\t\t\t\t\t\t\t\t\tvar refO = this._readInt1( 0 );\n\t\t\t\t\t\t\t\t\tendRead = refO.endRead;\n\t\t\t\t\t\t\t\t\tmode_local = 1;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tvar find = this._currentObject.data.indexOf( ',', endRead ) + 1;\n\t\t\t\t\t\t\t\t\tif ( find === 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tfind = this._currentObject.data.length;\n\t\t\t\t\t\t\t\t\t\tmode = 2;\n\t\t\t\t\t\t\t\t\t\tmode_local = 0;\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tvar line = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\t\t\t\t\tvar data = this._readLine( line.trim() ).split( \";\" );\n\t\t\t\t\t\t\t\t\tif ( this.IsUvYReverse ) {\n\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.uvs.push( parseFloat( data[ 0 ] ), 1 - parseFloat( data[ 1 ] ) );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.uvs.push( parseFloat( data[ 0 ] ), parseFloat( data[ 1 ] ) );\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tendRead = find + 1;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( endRead >= this._currentObject.data.length ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_setMeshMaterialList',\n\t\t\t\tvalue: function _setMeshMaterialList() {\n\n\t\t\t\t\tvar endRead = 0;\n\t\t\t\t\tvar mode = 0;\n\t\t\t\t\tvar mode_local = 0;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tif ( mode_local < 2 ) {\n\n\t\t\t\t\t\t\tvar refO = this._readInt1( endRead );\n\t\t\t\t\t\t\tendRead = refO.endRead;\n\t\t\t\t\t\t\tmode_local ++;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar find = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\t\t\tif ( find === - 1 ) {\n\n\t\t\t\t\t\t\t\tfind = this._currentObject.data.length;\n\t\t\t\t\t\t\t\tmode = 3;\n\t\t\t\t\t\t\t\tmode_local = 0;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar line = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\t\t\tvar data = this._readLine( line.trim() ).split( \",\" );\n\t\t\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.materialIndices[ i ] = parseInt( data[ i ] );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tendRead = this._currentObject.data.length;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( endRead >= this._currentObject.data.length || mode >= 3 ) {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_setMaterial',\n\t\t\t\tvalue: function _setMaterial() {\n\n\t\t\t\t\tvar _nowMat = new THREE.MeshPhongMaterial( {\n\t\t\t\t\t\tcolor: Math.random() * 0xffffff\n\t\t\t\t\t} );\n\t\t\t\t\t_nowMat.side = THREE.FrontSide;\n\t\t\t\t\t_nowMat.name = this._currentObject.name;\n\t\t\t\t\tvar endRead = 0;\n\t\t\t\t\tvar find = this._currentObject.data.indexOf( ';;', endRead );\n\t\t\t\t\tvar line = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tvar data = this._readLine( line.trim() ).split( \";\" );\n\t\t\t\t\t_nowMat.color.r = parseFloat( data[ 0 ] );\n\t\t\t\t\t_nowMat.color.g = parseFloat( data[ 1 ] );\n\t\t\t\t\t_nowMat.color.b = parseFloat( data[ 2 ] );\n\t\t\t\t\tendRead = find + 2;\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tline = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\t_nowMat.shininess = parseFloat( this._readLine( line ) );\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';;', endRead );\n\t\t\t\t\tline = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tvar data2 = this._readLine( line.trim() ).split( \";\" );\n\t\t\t\t\t_nowMat.specular.r = parseFloat( data2[ 0 ] );\n\t\t\t\t\t_nowMat.specular.g = parseFloat( data2[ 1 ] );\n\t\t\t\t\t_nowMat.specular.b = parseFloat( data2[ 2 ] );\n\t\t\t\t\tendRead = find + 2;\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';;', endRead );\n\t\t\t\t\tif ( find === - 1 ) {\n\n\t\t\t\t\t\tfind = this._currentObject.data.length;\n\n\t\t\t\t\t}\n\t\t\t\t\tline = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tvar data3 = this._readLine( line.trim() ).split( \";\" );\n\t\t\t\t\t_nowMat.emissive.r = parseFloat( data3[ 0 ] );\n\t\t\t\t\t_nowMat.emissive.g = parseFloat( data3[ 1 ] );\n\t\t\t\t\t_nowMat.emissive.b = parseFloat( data3[ 2 ] );\n\t\t\t\t\tvar localObject = null;\n\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\tif ( this._currentObject.children.length > 0 ) {\n\n\t\t\t\t\t\t\tlocalObject = this._currentObject.children.shift();\n\t\t\t\t\t\t\tif ( this.debug ) {\n\n\t\t\t\t\t\t\t\tconsole.log( 'processing ' + localObject.name );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar fileName = localObject.data.substr( 1, localObject.data.length - 2 );\n\t\t\t\t\t\t\tswitch ( localObject.type ) {\n\n\t\t\t\t\t\t\t\tcase \"TextureFilename\":\n\t\t\t\t\t\t\t\t\t_nowMat.map = this.texloader.load( fileName );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"BumpMapFilename\":\n\t\t\t\t\t\t\t\t\t_nowMat.bumpMap = this.texloader.load( fileName );\n\t\t\t\t\t\t\t\t\t_nowMat.bumpScale = 0.05;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"NormalMapFilename\":\n\t\t\t\t\t\t\t\t\t_nowMat.normalMap = this.texloader.load( fileName );\n\t\t\t\t\t\t\t\t\t_nowMat.normalScale = new THREE.Vector2( 2, 2 );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"EmissiveMapFilename\":\n\t\t\t\t\t\t\t\t\t_nowMat.emissiveMap = this.texloader.load( fileName );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"LightMapFilename\":\n\t\t\t\t\t\t\t\t\t_nowMat.lightMap = this.texloader.load( fileName );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tthis._currentGeo.Materials.push( _nowMat );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_setSkinWeights',\n\t\t\t\tvalue: function _setSkinWeights() {\n\n\t\t\t\t\tvar boneInf = new XboneInf();\n\t\t\t\t\tvar endRead = 0;\n\t\t\t\t\tvar find = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tvar line = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tboneInf.boneName = line.substr( 1, line.length - 2 );\n\t\t\t\t\tboneInf.BoneIndex = this._currentGeo.BoneInfs.length;\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tline = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tvar data = this._readLine( line.trim() ).split( \",\" );\n\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\tboneInf.Indeces.push( parseInt( data[ i ] ) );\n\n\t\t\t\t\t}\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tline = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tvar data2 = this._readLine( line.trim() ).split( \",\" );\n\t\t\t\t\tfor ( var _i = 0; _i < data2.length; _i ++ ) {\n\n\t\t\t\t\t\tboneInf.Weights.push( parseFloat( data2[ _i ] ) );\n\n\t\t\t\t\t}\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tif ( find <= 0 ) {\n\n\t\t\t\t\t\tfind = this._currentObject.data.length;\n\n\t\t\t\t\t}\n\t\t\t\t\tline = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tvar data3 = this._readLine( line.trim() ).split( \",\" );\n\t\t\t\t\tboneInf.OffsetMatrix = new THREE.Matrix4();\n\t\t\t\t\tthis._ParseMatrixData( boneInf.OffsetMatrix, data3 );\n\t\t\t\t\tthis._currentGeo.BoneInfs.push( boneInf );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_makePutBoneList',\n\t\t\t\tvalue: function _makePutBoneList( _RootName, _bones ) {\n\n\t\t\t\t\tvar putting = false;\n\t\t\t\t\tfor ( var frame in this.HieStack ) {\n\n\t\t\t\t\t\tif ( this.HieStack[ frame ].name === _RootName || putting ) {\n\n\t\t\t\t\t\t\tputting = true;\n\t\t\t\t\t\t\tvar b = new THREE.Bone();\n\t\t\t\t\t\t\tb.name = this.HieStack[ frame ].name;\n\t\t\t\t\t\t\tb.applyMatrix4( this.HieStack[ frame ].FrameTransformMatrix );\n\t\t\t\t\t\t\tb.matrixWorld = b.matrix;\n\t\t\t\t\t\t\tb.FrameTransformMatrix = this.HieStack[ frame ].FrameTransformMatrix;\n\t\t\t\t\t\t\tb.pos = new THREE.Vector3().setFromMatrixPosition( b.FrameTransformMatrix ).toArray();\n\t\t\t\t\t\t\tb.rotq = new THREE.Quaternion().setFromRotationMatrix( b.FrameTransformMatrix ).toArray();\n\t\t\t\t\t\t\tb.scl = new THREE.Vector3().setFromMatrixScale( b.FrameTransformMatrix ).toArray();\n\t\t\t\t\t\t\tif ( this.HieStack[ frame ].parentName && this.HieStack[ frame ].parentName.length > 0 ) {\n\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < _bones.length; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tif ( this.HieStack[ frame ].parentName === _bones[ i ].name ) {\n\n\t\t\t\t\t\t\t\t\t\t_bones[ i ].add( b );\n\t\t\t\t\t\t\t\t\t\tb.parent = i;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_bones.push( b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_makeOutputGeometry',\n\t\t\t\tvalue: function _makeOutputGeometry() {\n\n\t\t\t\t\tvar mesh = null;\n\t\t\t\t\tif ( this._currentGeo.BoneInfs.length > 0 ) {\n\n\t\t\t\t\t\tvar putBones = [];\n\t\t\t\t\t\tthis._makePutBoneList( this._currentGeo.baseFrame.parentName, putBones );\n\t\t\t\t\t\tfor ( var bi = 0; bi < this._currentGeo.BoneInfs.length; bi ++ ) {\n\n\t\t\t\t\t\t\tvar boneIndex = 0;\n\t\t\t\t\t\t\tfor ( var bb = 0; bb < putBones.length; bb ++ ) {\n\n\t\t\t\t\t\t\t\tif ( putBones[ bb ].name === this._currentGeo.BoneInfs[ bi ].boneName ) {\n\n\t\t\t\t\t\t\t\t\tboneIndex = bb;\n\t\t\t\t\t\t\t\t\tputBones[ bb ].OffsetMatrix = new THREE.Matrix4();\n\t\t\t\t\t\t\t\t\tputBones[ bb ].OffsetMatrix.copy( this._currentGeo.BoneInfs[ bi ].OffsetMatrix );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor ( var vi = 0; vi < this._currentGeo.BoneInfs[ bi ].Indeces.length; vi ++ ) {\n\n\t\t\t\t\t\t\t\tvar nowVertexID = this._currentGeo.BoneInfs[ bi ].Indeces[ vi ];\n\t\t\t\t\t\t\t\tvar nowVal = this._currentGeo.BoneInfs[ bi ].Weights[ vi ];\n\n\t\t\t\t\t\t\t\tvar stride = nowVertexID * 4;\n\n\t\t\t\t\t\t\t\tswitch ( this._currentGeo.VertexSetedBoneCount[ nowVertexID ] ) {\n\n\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinIndices[ stride ] = boneIndex;\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinWeights[ stride ] = nowVal;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinIndices[ stride + 1 ] = boneIndex;\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinWeights[ stride + 1 ] = nowVal;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinIndices[ stride + 2 ] = boneIndex;\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinWeights[ stride + 2 ] = nowVal;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinIndices[ stride + 3 ] = boneIndex;\n\t\t\t\t\t\t\t\t\t\tthis._currentGeo.GeometryData.skinWeights[ stride + 3 ] = nowVal;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis._currentGeo.VertexSetedBoneCount[ nowVertexID ] ++;\n\t\t\t\t\t\t\t\tif ( this._currentGeo.VertexSetedBoneCount[ nowVertexID ] > 4 ) {\n\n\t\t\t\t\t\t\t\t\tconsole.log( 'warn! over 4 bone weight! :' + nowVertexID );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor ( var sk = 0; sk < this._currentGeo.Materials.length; sk ++ ) {\n\n\t\t\t\t\t\t\tthis._currentGeo.Materials[ sk ].skinning = true;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar offsetList = [];\n\t\t\t\t\t\tfor ( var _bi = 0; _bi < putBones.length; _bi ++ ) {\n\n\t\t\t\t\t\t\tif ( putBones[ _bi ].OffsetMatrix ) {\n\n\t\t\t\t\t\t\t\toffsetList.push( putBones[ _bi ].OffsetMatrix );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\toffsetList.push( new THREE.Matrix4() );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar bufferGeometry = this._buildGeometry();\n\t\t\t\t\t\tmesh = new THREE.SkinnedMesh( bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[ 0 ] : this._currentGeo.Materials );\n\n\t\t\t\t\t\tthis._initSkeleton( mesh, putBones, offsetList );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar _bufferGeometry = this._buildGeometry();\n\t\t\t\t\t\tmesh = new THREE.Mesh( _bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[ 0 ] : this._currentGeo.Materials );\n\n\t\t\t\t\t}\n\t\t\t\t\tmesh.name = this._currentGeo.name;\n\t\t\t\t\tvar worldBaseMx = new THREE.Matrix4();\n\t\t\t\t\tvar currentMxFrame = this._currentGeo.baseFrame.putBone;\n\t\t\t\t\tif ( currentMxFrame && currentMxFrame.parent ) {\n\n\t\t\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t\t\tcurrentMxFrame = currentMxFrame.parent;\n\t\t\t\t\t\t\tif ( currentMxFrame ) {\n\n\t\t\t\t\t\t\t\tworldBaseMx.multiply( currentMxFrame.FrameTransformMatrix );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmesh.applyMatrix4( worldBaseMx );\n\n\t\t\t\t\t}\n\t\t\t\t\tthis.Meshes.push( mesh );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_initSkeleton',\n\t\t\t\tvalue: function _initSkeleton( mesh, boneList, boneInverses ) {\n\n\t\t\t\t\tvar bones = [], bone, gbone;\n\t\t\t\t\tvar i, il;\n\n\t\t\t\t\tfor ( i = 0, il = boneList.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tgbone = boneList[ i ];\n\n\t\t\t\t\t\tbone = new THREE.Bone();\n\t\t\t\t\t\tbones.push( bone );\n\n\t\t\t\t\t\tbone.name = gbone.name;\n\t\t\t\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( i = 0, il = boneList.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tgbone = boneList[ i ];\n\n\t\t\t\t\t\tif ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {\n\n\t\t\t\t\t\t\tbones[ gbone.parent ].add( bones[ i ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh.add( bones[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.updateMatrixWorld( true );\n\n\t\t\t\t\tvar skeleton = new THREE.Skeleton( bones, boneInverses );\n\t\t\t\t\tmesh.bind( skeleton, mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t}, {\n\t\t\t\tkey: '_readAnimationKey',\n\t\t\t\tvalue: function _readAnimationKey() {\n\n\t\t\t\t\tvar endRead = 0;\n\t\t\t\t\tvar find = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tvar line = this._currentObject.data.substr( endRead, find - endRead );\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tvar nowKeyType = parseInt( this._readLine( line ) );\n\t\t\t\t\tfind = this._currentObject.data.indexOf( ';', endRead );\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tline = this._currentObject.data.substr( endRead );\n\t\t\t\t\tvar data = this._readLine( line.trim() ).split( \";;,\" );\n\t\t\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\n\n\t\t\t\t\t\tvar data2 = data[ i ].split( \";\" );\n\t\t\t\t\t\tvar keyInfo = new XKeyFrameInfo();\n\t\t\t\t\t\tkeyInfo.type = nowKeyType;\n\t\t\t\t\t\tkeyInfo.Frame = parseInt( data2[ 0 ] );\n\t\t\t\t\t\tkeyInfo.index = this._currentAnimeFrames.keyFrames.length;\n\t\t\t\t\t\tkeyInfo.time = keyInfo.Frame;\n\t\t\t\t\t\tif ( nowKeyType != 4 ) {\n\n\t\t\t\t\t\t\tvar frameFound = false;\n\t\t\t\t\t\t\tfor ( var mm = 0; mm < this._currentAnimeFrames.keyFrames.length; mm ++ ) {\n\n\t\t\t\t\t\t\t\tif ( this._currentAnimeFrames.keyFrames[ mm ].Frame === keyInfo.Frame ) {\n\n\t\t\t\t\t\t\t\t\tkeyInfo = this._currentAnimeFrames.keyFrames[ mm ];\n\t\t\t\t\t\t\t\t\tframeFound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar frameValue = data2[ 2 ].split( \",\" );\n\t\t\t\t\t\t\tswitch ( nowKeyType ) {\n\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tkeyInfo.rot = new THREE.Quaternion( parseFloat( frameValue[ 1 ] ), parseFloat( frameValue[ 2 ] ), parseFloat( frameValue[ 3 ] ), parseFloat( frameValue[ 0 ] ) * - 1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tkeyInfo.scl = new THREE.Vector3( parseFloat( frameValue[ 0 ] ), parseFloat( frameValue[ 1 ] ), parseFloat( frameValue[ 2 ] ) );\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tkeyInfo.pos = new THREE.Vector3( parseFloat( frameValue[ 0 ] ), parseFloat( frameValue[ 1 ] ), parseFloat( frameValue[ 2 ] ) );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( ! frameFound ) {\n\n\t\t\t\t\t\t\t\tthis._currentAnimeFrames.keyFrames.push( keyInfo );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tkeyInfo.matrix = new THREE.Matrix4();\n\t\t\t\t\t\t\tthis._ParseMatrixData( keyInfo.matrix, data2[ 2 ].split( \",\" ) );\n\t\t\t\t\t\t\tthis._currentAnimeFrames.keyFrames.push( keyInfo );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_makeOutputAnimation',\n\t\t\t\tvalue: function _makeOutputAnimation() {\n\n\t\t\t\t\tvar animationObj = new XAnimationObj( this.options );\n\t\t\t\t\tanimationObj.fps = this.animTicksPerSecond;\n\t\t\t\t\tanimationObj.name = this._currentAnime.name;\n\t\t\t\t\tanimationObj.make( this._currentAnime.AnimeFrames );\n\t\t\t\t\tthis.animations.push( animationObj );\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'assignAnimation',\n\t\t\t\tvalue: function assignAnimation( _model, _animation ) {\n\n\t\t\t\t\tvar model = _model;\n\t\t\t\t\tvar animation = _animation;\n\t\t\t\t\tif ( ! model ) {\n\n\t\t\t\t\t\tmodel = this.Meshes[ 0 ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ! animation ) {\n\n\t\t\t\t\t\tanimation = this.animations[ 0 ];\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ! model || ! animation ) {\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\t\t\t\t\tvar put = {};\n\t\t\t\t\tput.fps = animation.fps;\n\t\t\t\t\tput.name = animation.name;\n\t\t\t\t\tput.length = animation.length;\n\t\t\t\t\tput.hierarchy = [];\n\t\t\t\t\tfor ( var b = 0; b < model.skeleton.bones.length; b ++ ) {\n\n\t\t\t\t\t\tvar findAnimation = false;\n\t\t\t\t\t\tfor ( var i = 0; i < animation.hierarchy.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( model.skeleton.bones[ b ].name === animation.hierarchy[ i ].name ) {\n\n\t\t\t\t\t\t\t\tfindAnimation = true;\n\t\t\t\t\t\t\t\tvar c_key = animation.hierarchy[ i ].copy();\n\t\t\t\t\t\t\t\tc_key.parent = - 1;\n\t\t\t\t\t\t\t\tif ( model.skeleton.bones[ b ].parent && model.skeleton.bones[ b ].parent.type === \"Bone\" ) {\n\n\t\t\t\t\t\t\t\t\tfor ( var bb = 0; bb < put.hierarchy.length; bb ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tif ( put.hierarchy[ bb ].name === model.skeleton.bones[ b ].parent.name ) {\n\n\t\t\t\t\t\t\t\t\t\t\tc_key.parent = bb;\n\t\t\t\t\t\t\t\t\t\t\tc_key.parentName = model.skeleton.bones[ b ].parent.name;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tput.hierarchy.push( c_key );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ! findAnimation ) {\n\n\t\t\t\t\t\t\tvar _c_key = animation.hierarchy[ 0 ].copy();\n\t\t\t\t\t\t\t_c_key.name = model.skeleton.bones[ b ].name;\n\t\t\t\t\t\t\t_c_key.parent = - 1;\n\t\t\t\t\t\t\tfor ( var k = 0; k < _c_key.keys.length; k ++ ) {\n\n\t\t\t\t\t\t\t\tif ( _c_key.keys[ k ].pos ) {\n\n\t\t\t\t\t\t\t\t\t_c_key.keys[ k ].pos.set( 0, 0, 0 );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( _c_key.keys[ k ].scl ) {\n\n\t\t\t\t\t\t\t\t\t_c_key.keys[ k ].scl.set( 1, 1, 1 );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( _c_key.keys[ k ].rot ) {\n\n\t\t\t\t\t\t\t\t\t_c_key.keys[ k ].rot.set( 0, 0, 0, 1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tput.hierarchy.push( _c_key );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ! model.geometry.animations ) {\n\n\t\t\t\t\t\tmodel.geometry.animations = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmodel.geometry.animations.push( THREE.AnimationClip.parseAnimation( put, model.skeleton.bones ) );\n\t\t\t\t\tif ( ! model.animationMixer ) {\n\n\t\t\t\t\t\tmodel.animationMixer = new THREE.AnimationMixer( model );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn put;\n\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: '_ParseMatrixData',\n\t\t\t\tvalue: function _ParseMatrixData( targetMatrix, data ) {\n\n\t\t\t\t\ttargetMatrix.set( parseFloat( data[ 0 ] ), parseFloat( data[ 4 ] ), parseFloat( data[ 8 ] ), parseFloat( data[ 12 ] ), parseFloat( data[ 1 ] ), parseFloat( data[ 5 ] ), parseFloat( data[ 9 ] ), parseFloat( data[ 13 ] ), parseFloat( data[ 2 ] ), parseFloat( data[ 6 ] ), parseFloat( data[ 10 ] ), parseFloat( data[ 14 ] ), parseFloat( data[ 3 ] ), parseFloat( data[ 7 ] ), parseFloat( data[ 11 ] ), parseFloat( data[ 15 ] ) );\n\n\t\t\t\t}\n\t\t\t} ] );\n\t\t\treturn XLoader;\n\n\t\t}();\n\n\t\treturn XLoader;\n\n\t} )();\n\t\n\treturn THREE.XLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/DDSLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tTHREE.DDSLoader = function ( manager ) {\n\n\t\tTHREE.CompressedTextureLoader.call( this, manager );\n\n\t};\n\n\tTHREE.DDSLoader.prototype = Object.assign( Object.create( THREE.CompressedTextureLoader.prototype ), {\n\n\t\tconstructor: THREE.DDSLoader,\n\n\t\tparse: function ( buffer, loadMipmaps ) {\n\n\t\t\tvar dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n\n\t\t\t// Adapted from @toji's DDS utils\n\t\t\t// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n\t\t\t// All values and structures referenced from:\n\t\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n\t\t\tvar DDS_MAGIC = 0x20534444;\n\n\t\t\tvar DDSD_CAPS = 0x1,\n\t\t\t\tDDSD_HEIGHT = 0x2,\n\t\t\t\tDDSD_WIDTH = 0x4,\n\t\t\t\tDDSD_PITCH = 0x8,\n\t\t\t\tDDSD_PIXELFORMAT = 0x1000,\n\t\t\t\tDDSD_MIPMAPCOUNT = 0x20000,\n\t\t\t\tDDSD_LINEARSIZE = 0x80000,\n\t\t\t\tDDSD_DEPTH = 0x800000;\n\n\t\t\tvar DDSCAPS_COMPLEX = 0x8,\n\t\t\t\tDDSCAPS_MIPMAP = 0x400000,\n\t\t\t\tDDSCAPS_TEXTURE = 0x1000;\n\n\t\t\tvar DDSCAPS2_CUBEMAP = 0x200,\n\t\t\t\tDDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n\t\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n\t\t\t\tDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n\t\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n\t\t\t\tDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n\t\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n\t\t\t\tDDSCAPS2_VOLUME = 0x200000;\n\n\t\t\tvar DDPF_ALPHAPIXELS = 0x1,\n\t\t\t\tDDPF_ALPHA = 0x2,\n\t\t\t\tDDPF_FOURCC = 0x4,\n\t\t\t\tDDPF_RGB = 0x40,\n\t\t\t\tDDPF_YUV = 0x200,\n\t\t\t\tDDPF_LUMINANCE = 0x20000;\n\n\t\t\tfunction fourCCToInt32( value ) {\n\n\t\t\t\treturn value.charCodeAt( 0 ) +\n\t\t\t\t\t( value.charCodeAt( 1 ) << 8 ) +\n\t\t\t\t\t( value.charCodeAt( 2 ) << 16 ) +\n\t\t\t\t\t( value.charCodeAt( 3 ) << 24 );\n\n\t\t\t}\n\n\t\t\tfunction int32ToFourCC( value ) {\n\n\t\t\t\treturn String.fromCharCode(\n\t\t\t\t\tvalue & 0xff,\n\t\t\t\t\t( value >> 8 ) & 0xff,\n\t\t\t\t\t( value >> 16 ) & 0xff,\n\t\t\t\t\t( value >> 24 ) & 0xff\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tfunction loadARGBMip( buffer, dataOffset, width, height ) {\n\n\t\t\t\tvar dataLength = width * height * 4;\n\t\t\t\tvar srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\n\t\t\t\tvar byteArray = new Uint8Array( dataLength );\n\t\t\t\tvar dst = 0;\n\t\t\t\tvar src = 0;\n\t\t\t\tfor ( var y = 0; y < height; y ++ ) {\n\n\t\t\t\t\tfor ( var x = 0; x < width; x ++ ) {\n\n\t\t\t\t\t\tvar b = srcBuffer[ src ]; src ++;\n\t\t\t\t\t\tvar g = srcBuffer[ src ]; src ++;\n\t\t\t\t\t\tvar r = srcBuffer[ src ]; src ++;\n\t\t\t\t\t\tvar a = srcBuffer[ src ]; src ++;\n\t\t\t\t\t\tbyteArray[ dst ] = r; dst ++;\t//r\n\t\t\t\t\t\tbyteArray[ dst ] = g; dst ++;\t//g\n\t\t\t\t\t\tbyteArray[ dst ] = b; dst ++;\t//b\n\t\t\t\t\t\tbyteArray[ dst ] = a; dst ++;\t//a\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn byteArray;\n\n\t\t\t}\n\n\t\t\tvar FOURCC_DXT1 = fourCCToInt32( \"DXT1\" );\n\t\t\tvar FOURCC_DXT3 = fourCCToInt32( \"DXT3\" );\n\t\t\tvar FOURCC_DXT5 = fourCCToInt32( \"DXT5\" );\n\t\t\tvar FOURCC_ETC1 = fourCCToInt32( \"ETC1\" );\n\n\t\t\tvar headerLengthInt = 31; // The header length in 32 bit ints\n\n\t\t\t// Offsets into the header array\n\n\t\t\tvar off_magic = 0;\n\n\t\t\tvar off_size = 1;\n\t\t\tvar off_flags = 2;\n\t\t\tvar off_height = 3;\n\t\t\tvar off_width = 4;\n\n\t\t\tvar off_mipmapCount = 7;\n\n\t\t\tvar off_pfFlags = 20;\n\t\t\tvar off_pfFourCC = 21;\n\t\t\tvar off_RGBBitCount = 22;\n\t\t\tvar off_RBitMask = 23;\n\t\t\tvar off_GBitMask = 24;\n\t\t\tvar off_BBitMask = 25;\n\t\t\tvar off_ABitMask = 26;\n\n\t\t\tvar off_caps = 27;\n\t\t\tvar off_caps2 = 28;\n\t\t\tvar off_caps3 = 29;\n\t\t\tvar off_caps4 = 30;\n\n\t\t\t// Parse header\n\n\t\t\tvar header = new Int32Array( buffer, 0, headerLengthInt );\n\n\t\t\tif ( header[ off_magic ] !== DDS_MAGIC ) {\n\n\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' );\n\t\t\t\treturn dds;\n\n\t\t\t}\n\n\t\t\tif ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {\n\n\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.' );\n\t\t\t\treturn dds;\n\n\t\t\t}\n\n\t\t\tvar blockBytes;\n\n\t\t\tvar fourCC = header[ off_pfFourCC ];\n\n\t\t\tvar isRGBAUncompressed = false;\n\n\t\t\tswitch ( fourCC ) {\n\n\t\t\t\tcase FOURCC_DXT1:\n\n\t\t\t\t\tblockBytes = 8;\n\t\t\t\t\tdds.format = THREE.RGB_S3TC_DXT1_Format;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FOURCC_DXT3:\n\n\t\t\t\t\tblockBytes = 16;\n\t\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT3_Format;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FOURCC_DXT5:\n\n\t\t\t\t\tblockBytes = 16;\n\t\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT5_Format;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FOURCC_ETC1:\n\n\t\t\t\t\tblockBytes = 8;\n\t\t\t\t\tdds.format = THREE.RGB_ETC1_Format;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( header[ off_RGBBitCount ] === 32\n\t\t\t\t\t\t&& header[ off_RBitMask ] & 0xff0000\n\t\t\t\t\t\t&& header[ off_GBitMask ] & 0xff00\n\t\t\t\t\t\t&& header[ off_BBitMask ] & 0xff\n\t\t\t\t\t\t&& header[ off_ABitMask ] & 0xff000000 ) {\n\n\t\t\t\t\t\tisRGBAUncompressed = true;\n\t\t\t\t\t\tblockBytes = 64;\n\t\t\t\t\t\tdds.format = THREE.RGBAFormat;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );\n\t\t\t\t\t\treturn dds;\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdds.mipmapCount = 1;\n\n\t\t\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\n\n\t\t\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\n\n\t\t\t}\n\n\t\t\tvar caps2 = header[ off_caps2 ];\n\t\t\tdds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n\t\t\tif ( dds.isCubemap && (\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ||\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ||\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ||\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ||\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ||\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ )\n\t\t\t) ) {\n\n\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Incomplete cubemap faces' );\n\t\t\t\treturn dds;\n\n\t\t\t}\n\n\t\t\tdds.width = header[ off_width ];\n\t\t\tdds.height = header[ off_height ];\n\n\t\t\tvar dataOffset = header[ off_size ] + 4;\n\n\t\t\t// Extract mipmaps buffers\n\n\t\t\tvar faces = dds.isCubemap ? 6 : 1;\n\n\t\t\tfor ( var face = 0; face < faces; face ++ ) {\n\n\t\t\t\tvar width = dds.width;\n\t\t\t\tvar height = dds.height;\n\n\t\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\t\tif ( isRGBAUncompressed ) {\n\n\t\t\t\t\t\tvar byteArray = loadARGBMip( buffer, dataOffset, width, height );\n\t\t\t\t\t\tvar dataLength = byteArray.length;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\n\t\t\t\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataLength );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar mipmap = { \"data\": byteArray, \"width\": width, \"height\": height };\n\t\t\t\t\tdds.mipmaps.push( mipmap );\n\n\t\t\t\t\tdataOffset += dataLength;\n\n\t\t\t\t\twidth = Math.max( width >> 1, 1 );\n\t\t\t\t\theight = Math.max( height >> 1, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dds;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.DDSLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/PVRLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/*\n\t *\t PVRLoader\n\t *   Author: pierre lepers\n\t *   Date: 17/09/2014 11:09\n\t *\n\t *\t PVR v2 (legacy) parser\n\t *   TODO : Add Support for PVR v3 format\n\t *   TODO : implement loadMipmaps option\n\t */\n\n\tTHREE.PVRLoader = function ( manager ) {\n\n\t\tTHREE.CompressedTextureLoader.call( this, manager );\n\n\t};\n\n\tTHREE.PVRLoader.prototype = Object.assign( Object.create( THREE.CompressedTextureLoader.prototype ), {\n\n\t\tconstructor: THREE.PVRLoader,\n\n\t\tparse: function ( buffer, loadMipmaps ) {\n\n\t\t\tvar headerLengthInt = 13;\n\t\t\tvar header = new Uint32Array( buffer, 0, headerLengthInt );\n\n\t\t\tvar pvrDatas = {\n\t\t\t\tbuffer: buffer,\n\t\t\t\theader: header,\n\t\t\t\tloadMipmaps: loadMipmaps\n\t\t\t};\n\n\t\t\tif ( header[ 0 ] === 0x03525650 ) {\n\n\t\t\t\t// PVR v3\n\n\t\t\t\treturn THREE.PVRLoader._parseV3( pvrDatas );\n\n\t\t\t} else if ( header[ 11 ] === 0x21525650 ) {\n\n\t\t\t\t// PVR v2\n\n\t\t\t\treturn THREE.PVRLoader._parseV2( pvrDatas );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.PVRLoader: Unknown PVR format.' );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tTHREE.PVRLoader._parseV3 = function ( pvrDatas ) {\n\n\t\tvar header = pvrDatas.header;\n\t\tvar bpp, format;\n\n\n\t\tvar metaLen = header[ 12 ],\n\t\t\tpixelFormat = header[ 2 ],\n\t\t\theight = header[ 6 ],\n\t\t\twidth = header[ 7 ],\n\t\t\t// numSurfs = header[ 9 ],\n\t\t\tnumFaces = header[ 10 ],\n\t\t\tnumMipmaps = header[ 11 ];\n\n\t\tswitch ( pixelFormat ) {\n\n\t\t\tcase 0 : // PVRTC 2bpp RGB\n\t\t\t\tbpp = 2;\n\t\t\t\tformat = THREE.RGB_PVRTC_2BPPV1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase 1 : // PVRTC 2bpp RGBA\n\t\t\t\tbpp = 2;\n\t\t\t\tformat = THREE.RGBA_PVRTC_2BPPV1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase 2 : // PVRTC 4bpp RGB\n\t\t\t\tbpp = 4;\n\t\t\t\tformat = THREE.RGB_PVRTC_4BPPV1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase 3 : // PVRTC 4bpp RGBA\n\t\t\t\tbpp = 4;\n\t\t\t\tformat = THREE.RGBA_PVRTC_4BPPV1_Format;\n\t\t\t\tbreak;\n\n\t\t\tdefault :\n\t\t\t\tconsole.error( 'THREE.PVRLoader: Unsupported PVR format:', pixelFormat );\n\n\t\t}\n\n\t\tpvrDatas.dataPtr = 52 + metaLen;\n\t\tpvrDatas.bpp = bpp;\n\t\tpvrDatas.format = format;\n\t\tpvrDatas.width = width;\n\t\tpvrDatas.height = height;\n\t\tpvrDatas.numSurfaces = numFaces;\n\t\tpvrDatas.numMipmaps = numMipmaps;\n\t\tpvrDatas.isCubemap \t= ( numFaces === 6 );\n\n\t\treturn THREE.PVRLoader._extract( pvrDatas );\n\n\t};\n\n\tTHREE.PVRLoader._parseV2 = function ( pvrDatas ) {\n\n\t\tvar header = pvrDatas.header;\n\n\t\tvar headerLength = header[ 0 ],\n\t\t\theight = header[ 1 ],\n\t\t\twidth = header[ 2 ],\n\t\t\tnumMipmaps = header[ 3 ],\n\t\t\tflags = header[ 4 ],\n\t\t\t// dataLength = header[ 5 ],\n\t\t\t// bpp =  header[ 6 ],\n\t\t\t// bitmaskRed = header[ 7 ],\n\t\t\t// bitmaskGreen = header[ 8 ],\n\t\t\t// bitmaskBlue = header[ 9 ],\n\t\t\tbitmaskAlpha = header[ 10 ],\n\t\t\t// pvrTag = header[ 11 ],\n\t\t\tnumSurfs = header[ 12 ];\n\n\n\t\tvar TYPE_MASK = 0xff;\n\t\tvar PVRTC_2 = 24,\n\t\t\tPVRTC_4 = 25;\n\n\t\tvar formatFlags = flags & TYPE_MASK;\n\n\t\tvar bpp, format;\n\t\tvar _hasAlpha = bitmaskAlpha > 0;\n\n\t\tif ( formatFlags === PVRTC_4 ) {\n\n\t\t\tformat = _hasAlpha ? THREE.RGBA_PVRTC_4BPPV1_Format : THREE.RGB_PVRTC_4BPPV1_Format;\n\t\t\tbpp = 4;\n\n\t\t} else if ( formatFlags === PVRTC_2 ) {\n\n\t\t\tformat = _hasAlpha ? THREE.RGBA_PVRTC_2BPPV1_Format : THREE.RGB_PVRTC_2BPPV1_Format;\n\t\t\tbpp = 2;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.PVRLoader: Unknown PVR format:', formatFlags );\n\n\t\t}\n\n\t\tpvrDatas.dataPtr = headerLength;\n\t\tpvrDatas.bpp = bpp;\n\t\tpvrDatas.format = format;\n\t\tpvrDatas.width = width;\n\t\tpvrDatas.height = height;\n\t\tpvrDatas.numSurfaces = numSurfs;\n\t\tpvrDatas.numMipmaps = numMipmaps + 1;\n\n\t\t// guess cubemap type seems tricky in v2\n\t\t// it juste a pvr containing 6 surface (no explicit cubemap type)\n\t\tpvrDatas.isCubemap \t= ( numSurfs === 6 );\n\n\t\treturn THREE.PVRLoader._extract( pvrDatas );\n\n\t};\n\n\n\tTHREE.PVRLoader._extract = function ( pvrDatas ) {\n\n\t\tvar pvr = {\n\t\t\tmipmaps: [],\n\t\t\twidth: pvrDatas.width,\n\t\t\theight: pvrDatas.height,\n\t\t\tformat: pvrDatas.format,\n\t\t\tmipmapCount: pvrDatas.numMipmaps,\n\t\t\tisCubemap: pvrDatas.isCubemap\n\t\t};\n\n\t\tvar buffer = pvrDatas.buffer;\n\n\t\tvar dataOffset = pvrDatas.dataPtr,\n\t\t\tbpp = pvrDatas.bpp,\n\t\t\tnumSurfs = pvrDatas.numSurfaces,\n\t\t\tdataSize = 0,\n\t\t\tblockSize = 0,\n\t\t\tblockWidth = 0,\n\t\t\tblockHeight = 0,\n\t\t\twidthBlocks = 0,\n\t\t\theightBlocks = 0;\n\n\t\tif ( bpp === 2 ) {\n\n\t\t\tblockWidth = 8;\n\t\t\tblockHeight = 4;\n\n\t\t} else {\n\n\t\t\tblockWidth = 4;\n\t\t\tblockHeight = 4;\n\n\t\t}\n\n\t\tblockSize = ( blockWidth * blockHeight ) * bpp / 8;\n\n\t\tpvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;\n\n\t\tvar mipLevel = 0;\n\n\t\twhile ( mipLevel < pvrDatas.numMipmaps ) {\n\n\t\t\tvar sWidth = pvrDatas.width >> mipLevel,\n\t\t\t\tsHeight = pvrDatas.height >> mipLevel;\n\n\t\t\twidthBlocks = sWidth / blockWidth;\n\t\t\theightBlocks = sHeight / blockHeight;\n\n\t\t\t// Clamp to minimum number of blocks\n\t\t\tif ( widthBlocks < 2 ) widthBlocks = 2;\n\t\t\tif ( heightBlocks < 2 ) heightBlocks = 2;\n\n\t\t\tdataSize = widthBlocks * heightBlocks * blockSize;\n\n\t\t\tfor ( var surfIndex = 0; surfIndex < numSurfs; surfIndex ++ ) {\n\n\t\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataSize );\n\n\t\t\t\tvar mipmap = {\n\t\t\t\t\tdata: byteArray,\n\t\t\t\t\twidth: sWidth,\n\t\t\t\t\theight: sHeight\n\t\t\t\t};\n\n\t\t\t\tpvr.mipmaps[ surfIndex * pvrDatas.numMipmaps + mipLevel ] = mipmap;\n\n\t\t\t\tdataOffset += dataSize;\n\n\t\t\t}\n\n\t\t\tmipLevel ++;\n\n\t\t}\n\n\t\treturn pvr;\n\n\t};\n\t\n\treturn THREE.PVRLoader;\n});\n\ndefine('skylark-threejs-ex/loaders/KTXLoader',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author amakaseev / https://github.com/amakaseev\n\t *\n\t * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\n\t * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\n\t *\n\t * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts\n\t */\n\n\n\tTHREE.KTXLoader = function ( manager ) {\n\n\t\tTHREE.CompressedTextureLoader.call( this, manager );\n\n\t};\n\n\tTHREE.KTXLoader.prototype = Object.assign( Object.create( THREE.CompressedTextureLoader.prototype ), {\n\n\t\tconstructor: THREE.KTXLoader,\n\n\t\tparse: function ( buffer, loadMipmaps ) {\n\n\t\t\tvar ktx = new KhronosTextureContainer( buffer, 1 );\n\n\t\t\treturn {\n\t\t\t\tmipmaps: ktx.mipmaps( loadMipmaps ),\n\t\t\t\twidth: ktx.pixelWidth,\n\t\t\t\theight: ktx.pixelHeight,\n\t\t\t\tformat: ktx.glInternalFormat,\n\t\t\t\tisCubemap: ktx.numberOfFaces === 6,\n\t\t\t\tmipmapCount: ktx.numberOfMipmapLevels\n\t\t\t};\n\n\t\t}\n\n\t} );\n\n\tvar KhronosTextureContainer = ( function () {\n\n\t\t/**\n\t\t * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file\n\t\t * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or\n\t\t * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented\n\t\t * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented\n\t\t */\n\t\tfunction KhronosTextureContainer( arrayBuffer, facesExpected /*, threeDExpected, textureArrayExpected */ ) {\n\n\t\t\tthis.arrayBuffer = arrayBuffer;\n\n\t\t\t// Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:\n\t\t\t// '´', 'K', 'T', 'X', ' ', '1', '1', 'ª', '\\r', '\\n', '\\x1A', '\\n'\n\t\t\t// 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\n\t\t\tvar identifier = new Uint8Array( this.arrayBuffer, 0, 12 );\n\t\t\tif ( identifier[ 0 ] !== 0xAB ||\n\t\t\t\tidentifier[ 1 ] !== 0x4B ||\n\t\t\t\tidentifier[ 2 ] !== 0x54 ||\n\t\t\t\tidentifier[ 3 ] !== 0x58 ||\n\t\t\t\tidentifier[ 4 ] !== 0x20 ||\n\t\t\t\tidentifier[ 5 ] !== 0x31 ||\n\t\t\t\tidentifier[ 6 ] !== 0x31 ||\n\t\t\t\tidentifier[ 7 ] !== 0xBB ||\n\t\t\t\tidentifier[ 8 ] !== 0x0D ||\n\t\t\t\tidentifier[ 9 ] !== 0x0A ||\n\t\t\t\tidentifier[ 10 ] !== 0x1A ||\n\t\t\t\tidentifier[ 11 ] !== 0x0A ) {\n\n\t\t\t\tconsole.error( 'texture missing KTX identifier' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// load the reset of the header in native 32 bit uint\n\t\t\tvar dataSize = Uint32Array.BYTES_PER_ELEMENT;\n\t\t\tvar headerDataView = new DataView( this.arrayBuffer, 12, 13 * dataSize );\n\t\t\tvar endianness = headerDataView.getUint32( 0, true );\n\t\t\tvar littleEndian = endianness === 0x04030201;\n\n\t\t\tthis.glType = headerDataView.getUint32( 1 * dataSize, littleEndian ); // must be 0 for compressed textures\n\t\t\tthis.glTypeSize = headerDataView.getUint32( 2 * dataSize, littleEndian ); // must be 1 for compressed textures\n\t\t\tthis.glFormat = headerDataView.getUint32( 3 * dataSize, littleEndian ); // must be 0 for compressed textures\n\t\t\tthis.glInternalFormat = headerDataView.getUint32( 4 * dataSize, littleEndian ); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\n\t\t\tthis.glBaseInternalFormat = headerDataView.getUint32( 5 * dataSize, littleEndian ); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\n\t\t\tthis.pixelWidth = headerDataView.getUint32( 6 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\n\t\t\tthis.pixelHeight = headerDataView.getUint32( 7 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\n\t\t\tthis.pixelDepth = headerDataView.getUint32( 8 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\n\t\t\tthis.numberOfArrayElements = headerDataView.getUint32( 9 * dataSize, littleEndian ); // used for texture arrays\n\t\t\tthis.numberOfFaces = headerDataView.getUint32( 10 * dataSize, littleEndian ); // used for cubemap textures, should either be 1 or 6\n\t\t\tthis.numberOfMipmapLevels = headerDataView.getUint32( 11 * dataSize, littleEndian ); // number of levels; disregard possibility of 0 for compressed textures\n\t\t\tthis.bytesOfKeyValueData = headerDataView.getUint32( 12 * dataSize, littleEndian ); // the amount of space after the header for meta-data\n\n\t\t\t// Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\n\t\t\tif ( this.glType !== 0 ) {\n\n\t\t\t\tconsole.warn( 'only compressed formats currently supported' );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\t// value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\n\t\t\t\tthis.numberOfMipmapLevels = Math.max( 1, this.numberOfMipmapLevels );\n\n\t\t\t}\n\t\t\tif ( this.pixelHeight === 0 || this.pixelDepth !== 0 ) {\n\n\t\t\t\tconsole.warn( 'only 2D textures currently supported' );\n\t\t\t\treturn;\n\n\t\t\t}\n\t\t\tif ( this.numberOfArrayElements !== 0 ) {\n\n\t\t\t\tconsole.warn( 'texture arrays not currently supported' );\n\t\t\t\treturn;\n\n\t\t\t}\n\t\t\tif ( this.numberOfFaces !== facesExpected ) {\n\n\t\t\t\tconsole.warn( 'number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces );\n\t\t\t\treturn;\n\n\t\t\t}\n\t\t\t// we now have a completely validated file, so could use existence of loadType as success\n\t\t\t// would need to make this more elaborate & adjust checks above to support more than one load type\n\t\t\tthis.loadType = KhronosTextureContainer.COMPRESSED_2D;\n\n\t\t}\n\n\t\t// return mipmaps for THREE.js\n\t\tKhronosTextureContainer.prototype.mipmaps = function ( loadMipmaps ) {\n\n\t\t\tvar mipmaps = [];\n\n\t\t\t// initialize width & height for level 1\n\t\t\tvar dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;\n\t\t\tvar width = this.pixelWidth;\n\t\t\tvar height = this.pixelHeight;\n\t\t\tvar mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\n\n\t\t\tfor ( var level = 0; level < mipmapCount; level ++ ) {\n\n\t\t\t\tvar imageSize = new Int32Array( this.arrayBuffer, dataOffset, 1 )[ 0 ]; // size per face, since not supporting array cubemaps\n\t\t\t\tdataOffset += 4; // size of the image + 4 for the imageSize field\n\n\t\t\t\tfor ( var face = 0; face < this.numberOfFaces; face ++ ) {\n\n\t\t\t\t\tvar byteArray = new Uint8Array( this.arrayBuffer, dataOffset, imageSize );\n\n\t\t\t\t\tmipmaps.push( { \"data\": byteArray, \"width\": width, \"height\": height } );\n\n\t\t\t\t\tdataOffset += imageSize;\n\t\t\t\t\tdataOffset += 3 - ( ( imageSize + 3 ) % 4 ); // add padding for odd sized image\n\n\t\t\t\t}\n\t\t\t\twidth = Math.max( 1.0, width * 0.5 );\n\t\t\t\theight = Math.max( 1.0, height * 0.5 );\n\n\t\t\t}\n\n\t\t\treturn mipmaps;\n\n\t\t};\n\n\t\tKhronosTextureContainer.HEADER_LEN = 12 + ( 13 * 4 ); // identifier + header elements (not including key value meta-data pairs)\n\t\t// load types\n\t\tKhronosTextureContainer.COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\n\t\tKhronosTextureContainer.COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\n\t\tKhronosTextureContainer.TEX_2D = 2; // uses a gl.texImage2D()\n\t\tKhronosTextureContainer.TEX_3D = 3; // uses a gl.texImage3D()\n\n\t\treturn KhronosTextureContainer;\n\n\t}() );\n\n\t\n\treturn THREE.KTXLoader;\n});\n\ndefine('skylark-threejs-ex/modifiers/SimplifyModifier',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n\t *\n\t *\tSimplification Geometry Modifier\n\t *    - based on code and technique\n\t *\t  - by Stan Melax in 1998\n\t *\t  - Progressive Mesh type Polygon Reduction Algorithm\n\t *    - http://www.melax.com/polychop/\n\t */\n\n\tTHREE.SimplifyModifier = function () {};\n\n\t( function () {\n\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\tfunction pushIfUnique( array, object ) {\n\n\t\t\tif ( array.indexOf( object ) === - 1 ) array.push( object );\n\n\t\t}\n\n\t\tfunction removeFromArray( array, object ) {\n\n\t\t\tvar k = array.indexOf( object );\n\t\t\tif ( k > - 1 ) array.splice( k, 1 );\n\n\t\t}\n\n\t\tfunction computeEdgeCollapseCost( u, v ) {\n\n\t\t\t// if we collapse edge uv by moving u to v then how\n\t\t\t// much different will the model change, i.e. the \"error\".\n\n\t\t\tvar edgelength = v.position.distanceTo( u.position );\n\t\t\tvar curvature = 0;\n\n\t\t\tvar sideFaces = [];\n\t\t\tvar i, il = u.faces.length, face, sideFace;\n\n\t\t\t// find the \"sides\" triangles that are on the edge uv\n\t\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\t\tface = u.faces[ i ];\n\n\t\t\t\tif ( face.hasVertex( v ) ) {\n\n\t\t\t\t\tsideFaces.push( face );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// use the triangle facing most away from the sides\n\t\t\t// to determine our curvature term\n\t\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\t\tvar minCurvature = 1;\n\t\t\t\tface = u.faces[ i ];\n\n\t\t\t\tfor ( var j = 0; j < sideFaces.length; j ++ ) {\n\n\t\t\t\t\tsideFace = sideFaces[ j ];\n\t\t\t\t\t// use dot product of face normals.\n\t\t\t\t\tvar dotProd = face.normal.dot( sideFace.normal );\n\t\t\t\t\tminCurvature = Math.min( minCurvature, ( 1.001 - dotProd ) / 2 );\n\n\t\t\t\t}\n\n\t\t\t\tcurvature = Math.max( curvature, minCurvature );\n\n\t\t\t}\n\n\t\t\t// crude approach in attempt to preserve borders\n\t\t\t// though it seems not to be totally correct\n\t\t\tvar borders = 0;\n\t\t\tif ( sideFaces.length < 2 ) {\n\n\t\t\t\t// we add some arbitrary cost for borders,\n\t\t\t\t// borders += 10;\n\t\t\t\tcurvature = 1;\n\n\t\t\t}\n\n\t\t\tvar amt = edgelength * curvature + borders;\n\n\t\t\treturn amt;\n\n\t\t}\n\n\t\tfunction computeEdgeCostAtVertex( v ) {\n\n\t\t\t// compute the edge collapse cost for all edges that start\n\t\t\t// from vertex v.  Since we are only interested in reducing\n\t\t\t// the object by selecting the min cost edge at each step, we\n\t\t\t// only cache the cost of the least cost edge at this vertex\n\t\t\t// (in member variable collapse) as well as the value of the\n\t\t\t// cost (in member variable collapseCost).\n\n\t\t\tif ( v.neighbors.length === 0 ) {\n\n\t\t\t\t// collapse if no neighbors.\n\t\t\t\tv.collapseNeighbor = null;\n\t\t\t\tv.collapseCost = - 0.01;\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tv.collapseCost = 100000;\n\t\t\tv.collapseNeighbor = null;\n\n\t\t\t// search all neighboring edges for \"least cost\" edge\n\t\t\tfor ( var i = 0; i < v.neighbors.length; i ++ ) {\n\n\t\t\t\tvar collapseCost = computeEdgeCollapseCost( v, v.neighbors[ i ] );\n\n\t\t\t\tif ( ! v.collapseNeighbor ) {\n\n\t\t\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\t\t\tv.collapseCost = collapseCost;\n\t\t\t\t\tv.minCost = collapseCost;\n\t\t\t\t\tv.totalCost = 0;\n\t\t\t\t\tv.costCount = 0;\n\n\t\t\t\t}\n\n\t\t\t\tv.costCount ++;\n\t\t\t\tv.totalCost += collapseCost;\n\n\t\t\t\tif ( collapseCost < v.minCost ) {\n\n\t\t\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\t\t\tv.minCost = collapseCost;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// we average the cost of collapsing at this vertex\n\t\t\tv.collapseCost = v.totalCost / v.costCount;\n\t\t\t// v.collapseCost = v.minCost;\n\n\t\t}\n\n\t\tfunction removeVertex( v, vertices ) {\n\n\t\t\tconsole.assert( v.faces.length === 0 );\n\n\t\t\twhile ( v.neighbors.length ) {\n\n\t\t\t\tvar n = v.neighbors.pop();\n\t\t\t\tremoveFromArray( n.neighbors, v );\n\n\t\t\t}\n\n\t\t\tremoveFromArray( vertices, v );\n\n\t\t}\n\n\t\tfunction removeFace( f, faces ) {\n\n\t\t\tremoveFromArray( faces, f );\n\n\t\t\tif ( f.v1 ) removeFromArray( f.v1.faces, f );\n\t\t\tif ( f.v2 ) removeFromArray( f.v2.faces, f );\n\t\t\tif ( f.v3 ) removeFromArray( f.v3.faces, f );\n\n\t\t\t// TODO optimize this!\n\t\t\tvar vs = [ f.v1, f.v2, f.v3 ];\n\t\t\tvar v1, v2;\n\n\t\t\tfor ( var i = 0; i < 3; i ++ ) {\n\n\t\t\t\tv1 = vs[ i ];\n\t\t\t\tv2 = vs[ ( i + 1 ) % 3 ];\n\n\t\t\t\tif ( ! v1 || ! v2 ) continue;\n\n\t\t\t\tv1.removeIfNonNeighbor( v2 );\n\t\t\t\tv2.removeIfNonNeighbor( v1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction collapse( vertices, faces, u, v ) { // u and v are pointers to vertices of an edge\n\n\t\t\t// Collapse the edge uv by moving vertex u onto v\n\n\t\t\tif ( ! v ) {\n\n\t\t\t\t// u is a vertex all by itself so just delete it..\n\t\t\t\tremoveVertex( u, vertices );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar i;\n\t\t\tvar tmpVertices = [];\n\n\t\t\tfor ( i = 0; i < u.neighbors.length; i ++ ) {\n\n\t\t\t\ttmpVertices.push( u.neighbors[ i ] );\n\n\t\t\t}\n\n\n\t\t\t// delete triangles on edge uv:\n\t\t\tfor ( i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tif ( u.faces[ i ].hasVertex( v ) ) {\n\n\t\t\t\t\tremoveFace( u.faces[ i ], faces );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update remaining triangles to have v instead of u\n\t\t\tfor ( i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tu.faces[ i ].replaceVertex( u, v );\n\n\t\t\t}\n\n\n\t\t\tremoveVertex( u, vertices );\n\n\t\t\t// recompute the edge collapse costs in neighborhood\n\t\t\tfor ( i = 0; i < tmpVertices.length; i ++ ) {\n\n\t\t\t\tcomputeEdgeCostAtVertex( tmpVertices[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\n\n\t\tfunction minimumCostEdge( vertices ) {\n\n\t\t\t// O(n * n) approach. TODO optimize this\n\n\t\t\tvar least = vertices[ 0 ];\n\n\t\t\tfor ( var i = 0; i < vertices.length; i ++ ) {\n\n\t\t\t\tif ( vertices[ i ].collapseCost < least.collapseCost ) {\n\n\t\t\t\t\tleast = vertices[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn least;\n\n\t\t}\n\n\t\t// we use a triangle class to represent structure of face slightly differently\n\n\t\tfunction Triangle( v1, v2, v3, a, b, c ) {\n\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\n\t\t\tthis.normal = new THREE.Vector3();\n\n\t\t\tthis.computeNormal();\n\n\t\t\tv1.faces.push( this );\n\t\t\tv1.addUniqueNeighbor( v2 );\n\t\t\tv1.addUniqueNeighbor( v3 );\n\n\t\t\tv2.faces.push( this );\n\t\t\tv2.addUniqueNeighbor( v1 );\n\t\t\tv2.addUniqueNeighbor( v3 );\n\n\n\t\t\tv3.faces.push( this );\n\t\t\tv3.addUniqueNeighbor( v1 );\n\t\t\tv3.addUniqueNeighbor( v2 );\n\n\t\t}\n\n\t\tTriangle.prototype.computeNormal = function () {\n\n\t\t\tvar vA = this.v1.position;\n\t\t\tvar vB = this.v2.position;\n\t\t\tvar vC = this.v3.position;\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab ).normalize();\n\n\t\t\tthis.normal.copy( cb );\n\n\t\t};\n\n\t\tTriangle.prototype.hasVertex = function ( v ) {\n\n\t\t\treturn v === this.v1 || v === this.v2 || v === this.v3;\n\n\t\t};\n\n\t\tTriangle.prototype.replaceVertex = function ( oldv, newv ) {\n\n\t\t\tif ( oldv === this.v1 ) this.v1 = newv;\n\t\t\telse if ( oldv === this.v2 ) this.v2 = newv;\n\t\t\telse if ( oldv === this.v3 ) this.v3 = newv;\n\n\t\t\tremoveFromArray( oldv.faces, this );\n\t\t\tnewv.faces.push( this );\n\n\n\t\t\toldv.removeIfNonNeighbor( this.v1 );\n\t\t\tthis.v1.removeIfNonNeighbor( oldv );\n\n\t\t\toldv.removeIfNonNeighbor( this.v2 );\n\t\t\tthis.v2.removeIfNonNeighbor( oldv );\n\n\t\t\toldv.removeIfNonNeighbor( this.v3 );\n\t\t\tthis.v3.removeIfNonNeighbor( oldv );\n\n\t\t\tthis.v1.addUniqueNeighbor( this.v2 );\n\t\t\tthis.v1.addUniqueNeighbor( this.v3 );\n\n\t\t\tthis.v2.addUniqueNeighbor( this.v1 );\n\t\t\tthis.v2.addUniqueNeighbor( this.v3 );\n\n\t\t\tthis.v3.addUniqueNeighbor( this.v1 );\n\t\t\tthis.v3.addUniqueNeighbor( this.v2 );\n\n\t\t\tthis.computeNormal();\n\n\t\t};\n\n\t\tfunction Vertex( v, id ) {\n\n\t\t\tthis.position = v;\n\n\t\t\tthis.id = id; // old index id\n\n\t\t\tthis.faces = []; // faces vertex is connected\n\t\t\tthis.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n\n\t\t\t// these will be computed in computeEdgeCostAtVertex()\n\t\t\tthis.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\t\t\tthis.collapseNeighbor = null; // best candinate for collapsing\n\n\t\t}\n\n\t\tVertex.prototype.addUniqueNeighbor = function ( vertex ) {\n\n\t\t\tpushIfUnique( this.neighbors, vertex );\n\n\t\t};\n\n\t\tVertex.prototype.removeIfNonNeighbor = function ( n ) {\n\n\t\t\tvar neighbors = this.neighbors;\n\t\t\tvar faces = this.faces;\n\n\t\t\tvar offset = neighbors.indexOf( n );\n\t\t\tif ( offset === - 1 ) return;\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tif ( faces[ i ].hasVertex( n ) ) return;\n\n\t\t\t}\n\n\t\t\tneighbors.splice( offset, 1 );\n\n\t\t};\n\n\t\tTHREE.SimplifyModifier.prototype.modify = function ( geometry, count ) {\n\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry( geometry );\n\n\t\t\t}\n\n\t\t\tgeometry.mergeVertices();\n\n\t\t\tvar oldVertices = geometry.vertices; // Three Position\n\t\t\tvar oldFaces = geometry.faces; // Three Face\n\n\t\t\t// conversion\n\t\t\tvar vertices = [];\n\t\t\tvar faces = [];\n\n\t\t\tvar i, il;\n\n\t\t\t//\n\t\t\t// put data of original geometry in different data structures\n\t\t\t//\n\n\t\t\t// add vertices\n\n\t\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\n\n\t\t\t\tvar vertex = new Vertex( oldVertices[ i ], i );\n\t\t\t\tvertices.push( vertex );\n\n\t\t\t}\n\n\t\t\t// add faces\n\n\t\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = oldFaces[ i ];\n\n\t\t\t\tvar a = face.a;\n\t\t\t\tvar b = face.b;\n\t\t\t\tvar c = face.c;\n\n\t\t\t\tvar triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\n\t\t\t\tfaces.push( triangle );\n\n\t\t\t}\n\n\t\t\t// compute all edge collapse costs\n\n\t\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tcomputeEdgeCostAtVertex( vertices[ i ] );\n\n\t\t\t}\n\n\t\t\tvar nextVertex;\n\n\t\t\tvar z = count;\n\n\t\t\twhile ( z -- ) {\n\n\t\t\t\tnextVertex = minimumCostEdge( vertices );\n\n\t\t\t\tif ( ! nextVertex ) {\n\n\t\t\t\t\tconsole.log( 'THREE.SimplifyModifier: No next vertex' );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcollapse( vertices, faces, nextVertex, nextVertex.collapseNeighbor );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar simplifiedGeometry = new THREE.BufferGeometry();\n\t\t\tvar position = [];\n\t\t\tvar index = [];\n\n\t\t\t//\n\n\t\t\tfor ( i = 0; i < vertices.length; i ++ ) {\n\n\t\t\t\tvar vertex = vertices[ i ].position;\n\t\t\t\tposition.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfor ( i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tvar a = vertices.indexOf( face.v1 );\n\t\t\t\tvar b = vertices.indexOf( face.v2 );\n\t\t\t\tvar c = vertices.indexOf( face.v3 );\n\n\t\t\t\tindex.push( a, b, c );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tsimplifiedGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( position, 3 ) );\n\t\t\tsimplifiedGeometry.setIndex( index );\n\n\t\t\treturn simplifiedGeometry;\n\n\t\t};\n\n\t} )();\n\t\n\treturn THREE.SimplifyModifier;\n});\n\ndefine('skylark-threejs-ex/modifiers/SubdivisionModifier',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n\t *\t@author centerionware / http://www.centerionware.com\n\t *\n\t *\tSubdivision Geometry Modifier\n\t *\t\tusing Loop Subdivision Scheme\n\t *\n\t *\tReferences:\n\t *\t\thttp://graphics.stanford.edu/~mdfisher/subdivision.html\n\t *\t\thttp://www.holmes3d.net/graphics/subdivision/\n\t *\t\thttp://www.cs.rutgers.edu/~decarlo/readings/subdiv-sg00c.pdf\n\t *\n\t *\tKnown Issues:\n\t *\t\t- currently doesn't handle \"Sharp Edges\"\n\t */\n\n\tTHREE.SubdivisionModifier = function ( subdivisions ) {\n\n\t\tthis.subdivisions = ( subdivisions === undefined ) ? 1 : subdivisions;\n\n\t};\n\n\t// Applies the \"modify\" pattern\n\tTHREE.SubdivisionModifier.prototype.modify = function ( geometry ) {\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry( geometry );\n\n\t\t} else {\n\n\t\t\tgeometry = geometry.clone();\n\n\t\t}\n\n\t\tgeometry.mergeVertices();\n\n\t\tvar repeats = this.subdivisions;\n\n\t\twhile ( repeats -- > 0 ) {\n\n\t\t\tthis.smooth( geometry );\n\n\t\t}\n\n\t\tgeometry.computeFaceNormals();\n\t\tgeometry.computeVertexNormals();\n\n\t\treturn geometry;\n\n\t};\n\n\t( function () {\n\n\t\t// Some constants\n\t\tvar ABC = [ 'a', 'b', 'c' ];\n\n\n\t\tfunction getEdge( a, b, map ) {\n\n\t\t\tvar vertexIndexA = Math.min( a, b );\n\t\t\tvar vertexIndexB = Math.max( a, b );\n\n\t\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\n\n\t\t\treturn map[ key ];\n\n\t\t}\n\n\n\t\tfunction processEdge( a, b, vertices, map, face, metaVertices ) {\n\n\t\t\tvar vertexIndexA = Math.min( a, b );\n\t\t\tvar vertexIndexB = Math.max( a, b );\n\n\t\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\n\n\t\t\tvar edge;\n\n\t\t\tif ( key in map ) {\n\n\t\t\t\tedge = map[ key ];\n\n\t\t\t} else {\n\n\t\t\t\tvar vertexA = vertices[ vertexIndexA ];\n\t\t\t\tvar vertexB = vertices[ vertexIndexB ];\n\n\t\t\t\tedge = {\n\n\t\t\t\t\ta: vertexA, // pointer reference\n\t\t\t\t\tb: vertexB,\n\t\t\t\t\tnewEdge: null,\n\t\t\t\t\t// aIndex: a, // numbered reference\n\t\t\t\t\t// bIndex: b,\n\t\t\t\t\tfaces: [] // pointers to face\n\n\t\t\t\t};\n\n\t\t\t\tmap[ key ] = edge;\n\n\t\t\t}\n\n\t\t\tedge.faces.push( face );\n\n\t\t\tmetaVertices[ a ].edges.push( edge );\n\t\t\tmetaVertices[ b ].edges.push( edge );\n\n\n\t\t}\n\n\t\tfunction generateLookups( vertices, faces, metaVertices, edges ) {\n\n\t\t\tvar i, il, face;\n\n\t\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tmetaVertices[ i ] = { edges: [] };\n\n\t\t\t}\n\n\t\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\n\t\t\t\tprocessEdge( face.a, face.b, vertices, edges, face, metaVertices );\n\t\t\t\tprocessEdge( face.b, face.c, vertices, edges, face, metaVertices );\n\t\t\t\tprocessEdge( face.c, face.a, vertices, edges, face, metaVertices );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction newFace( newFaces, a, b, c, materialIndex ) {\n\n\t\t\tnewFaces.push( new THREE.Face3( a, b, c, undefined, undefined, materialIndex ) );\n\n\t\t}\n\n\t\tfunction midpoint( a, b ) {\n\n\t\t\treturn ( Math.abs( b - a ) / 2 ) + Math.min( a, b );\n\n\t\t}\n\n\t\tfunction newUv( newUvs, a, b, c ) {\n\n\t\t\tnewUvs.push( [ a.clone(), b.clone(), c.clone() ] );\n\n\t\t}\n\n\t\t/////////////////////////////\n\n\t\t// Performs one iteration of Subdivision\n\t\tTHREE.SubdivisionModifier.prototype.smooth = function ( geometry ) {\n\n\t\t\tvar tmp = new THREE.Vector3();\n\n\t\t\tvar oldVertices, oldFaces, oldUvs;\n\t\t\tvar newVertices, newFaces, newUVs = [];\n\n\t\t\tvar n, i, il, j, k;\n\t\t\tvar metaVertices, sourceEdges;\n\n\t\t\t// new stuff.\n\t\t\tvar sourceEdges, newEdgeVertices, newSourceVertices;\n\n\t\t\toldVertices = geometry.vertices; // { x, y, z}\n\t\t\toldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }\n\t\t\toldUvs = geometry.faceVertexUvs;\n\n\t\t\tvar hasUvs = oldUvs[ 0 ] !== undefined && oldUvs[ 0 ].length > 0;\n\n\t\t\tif ( hasUvs ) {\n\n\t\t\t\tfor ( var j = 0; j < oldUvs.length; j ++ ) {\n\n\t\t\t\t\tnewUVs.push( [] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/******************************************************\n\t\t\t *\n\t\t\t * Step 0: Preprocess Geometry to Generate edges Lookup\n\t\t\t *\n\t\t\t *******************************************************/\n\n\t\t\tmetaVertices = new Array( oldVertices.length );\n\t\t\tsourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }\n\n\t\t\tgenerateLookups( oldVertices, oldFaces, metaVertices, sourceEdges );\n\n\n\t\t\t/******************************************************\n\t\t\t *\n\t\t\t *\tStep 1.\n\t\t\t *\tFor each edge, create a new Edge Vertex,\n\t\t\t *\tthen position it.\n\t\t\t *\n\t\t\t *******************************************************/\n\n\t\t\tnewEdgeVertices = [];\n\t\t\tvar other, currentEdge, newEdge, face;\n\t\t\tvar edgeVertexWeight, adjacentVertexWeight, connectedFaces;\n\n\t\t\tfor ( i in sourceEdges ) {\n\n\t\t\t\tcurrentEdge = sourceEdges[ i ];\n\t\t\t\tnewEdge = new THREE.Vector3();\n\n\t\t\t\tedgeVertexWeight = 3 / 8;\n\t\t\t\tadjacentVertexWeight = 1 / 8;\n\n\t\t\t\tconnectedFaces = currentEdge.faces.length;\n\n\t\t\t\t// check how many linked faces. 2 should be correct.\n\t\t\t\tif ( connectedFaces != 2 ) {\n\n\t\t\t\t\t// if length is not 2, handle condition\n\t\t\t\t\tedgeVertexWeight = 0.5;\n\t\t\t\t\tadjacentVertexWeight = 0;\n\n\t\t\t\t\tif ( connectedFaces != 1 ) {\n\n\t\t\t\t\t\t// console.warn( 'Subdivision Modifier: Number of connected faces != 2, is: ', connectedFaces, currentEdge );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnewEdge.addVectors( currentEdge.a, currentEdge.b ).multiplyScalar( edgeVertexWeight );\n\n\t\t\t\ttmp.set( 0, 0, 0 );\n\n\t\t\t\tfor ( j = 0; j < connectedFaces; j ++ ) {\n\n\t\t\t\t\tface = currentEdge.faces[ j ];\n\n\t\t\t\t\tfor ( k = 0; k < 3; k ++ ) {\n\n\t\t\t\t\t\tother = oldVertices[ face[ ABC[ k ] ] ];\n\t\t\t\t\t\tif ( other !== currentEdge.a && other !== currentEdge.b ) break;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttmp.add( other );\n\n\t\t\t\t}\n\n\t\t\t\ttmp.multiplyScalar( adjacentVertexWeight );\n\t\t\t\tnewEdge.add( tmp );\n\n\t\t\t\tcurrentEdge.newEdge = newEdgeVertices.length;\n\t\t\t\tnewEdgeVertices.push( newEdge );\n\n\t\t\t\t// console.log(currentEdge, newEdge);\n\n\t\t\t}\n\n\t\t\t/******************************************************\n\t\t\t *\n\t\t\t *\tStep 2.\n\t\t\t *\tReposition each source vertices.\n\t\t\t *\n\t\t\t *******************************************************/\n\n\t\t\tvar beta, sourceVertexWeight, connectingVertexWeight;\n\t\t\tvar connectingEdge, connectingEdges, oldVertex, newSourceVertex;\n\t\t\tnewSourceVertices = [];\n\n\t\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\n\n\t\t\t\toldVertex = oldVertices[ i ];\n\n\t\t\t\t// find all connecting edges (using lookupTable)\n\t\t\t\tconnectingEdges = metaVertices[ i ].edges;\n\t\t\t\tn = connectingEdges.length;\n\n\t\t\t\tif ( n == 3 ) {\n\n\t\t\t\t\tbeta = 3 / 16;\n\n\t\t\t\t} else if ( n > 3 ) {\n\n\t\t\t\t\tbeta = 3 / ( 8 * n ); // Warren's modified formula\n\n\t\t\t\t}\n\n\t\t\t\t// Loop's original beta formula\n\t\t\t\t// beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );\n\n\t\t\t\tsourceVertexWeight = 1 - n * beta;\n\t\t\t\tconnectingVertexWeight = beta;\n\n\t\t\t\tif ( n <= 2 ) {\n\n\t\t\t\t\t// crease and boundary rules\n\t\t\t\t\t// console.warn('crease and boundary rules');\n\n\t\t\t\t\tif ( n == 2 ) {\n\n\t\t\t\t\t\t// console.warn( '2 connecting edges', connectingEdges );\n\t\t\t\t\t\tsourceVertexWeight = 3 / 4;\n\t\t\t\t\t\tconnectingVertexWeight = 1 / 8;\n\n\t\t\t\t\t\t// sourceVertexWeight = 1;\n\t\t\t\t\t\t// connectingVertexWeight = 0;\n\n\t\t\t\t\t} else if ( n == 1 ) {\n\n\t\t\t\t\t\t// console.warn( 'only 1 connecting edge' );\n\n\t\t\t\t\t} else if ( n == 0 ) {\n\n\t\t\t\t\t\t// console.warn( '0 connecting edges' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnewSourceVertex = oldVertex.clone().multiplyScalar( sourceVertexWeight );\n\n\t\t\t\ttmp.set( 0, 0, 0 );\n\n\t\t\t\tfor ( j = 0; j < n; j ++ ) {\n\n\t\t\t\t\tconnectingEdge = connectingEdges[ j ];\n\t\t\t\t\tother = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\n\t\t\t\t\ttmp.add( other );\n\n\t\t\t\t}\n\n\t\t\t\ttmp.multiplyScalar( connectingVertexWeight );\n\t\t\t\tnewSourceVertex.add( tmp );\n\n\t\t\t\tnewSourceVertices.push( newSourceVertex );\n\n\t\t\t}\n\n\n\t\t\t/******************************************************\n\t\t\t *\n\t\t\t *\tStep 3.\n\t\t\t *\tGenerate Faces between source vertices\n\t\t\t *\tand edge vertices.\n\t\t\t *\n\t\t\t *******************************************************/\n\n\t\t\tnewVertices = newSourceVertices.concat( newEdgeVertices );\n\t\t\tvar sl = newSourceVertices.length, edge1, edge2, edge3;\n\t\t\tnewFaces = [];\n\n\t\t\tvar uv, x0, x1, x2;\n\t\t\tvar x3 = new THREE.Vector2();\n\t\t\tvar x4 = new THREE.Vector2();\n\t\t\tvar x5 = new THREE.Vector2();\n\n\t\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\n\n\t\t\t\tface = oldFaces[ i ];\n\n\t\t\t\t// find the 3 new edges vertex of each old face\n\n\t\t\t\tedge1 = getEdge( face.a, face.b, sourceEdges ).newEdge + sl;\n\t\t\t\tedge2 = getEdge( face.b, face.c, sourceEdges ).newEdge + sl;\n\t\t\t\tedge3 = getEdge( face.c, face.a, sourceEdges ).newEdge + sl;\n\n\t\t\t\t// create 4 faces.\n\n\t\t\t\tnewFace( newFaces, edge1, edge2, edge3, face.materialIndex );\n\t\t\t\tnewFace( newFaces, face.a, edge1, edge3, face.materialIndex );\n\t\t\t\tnewFace( newFaces, face.b, edge2, edge1, face.materialIndex );\n\t\t\t\tnewFace( newFaces, face.c, edge3, edge2, face.materialIndex );\n\n\t\t\t\t// create 4 new uv's\n\n\t\t\t\tif ( hasUvs ) {\n\n\t\t\t\t\tfor ( var j = 0; j < oldUvs.length; j ++ ) {\n\n\t\t\t\t\t\tuv = oldUvs[ j ][ i ];\n\n\t\t\t\t\t\tx0 = uv[ 0 ];\n\t\t\t\t\t\tx1 = uv[ 1 ];\n\t\t\t\t\t\tx2 = uv[ 2 ];\n\n\t\t\t\t\t\tx3.set( midpoint( x0.x, x1.x ), midpoint( x0.y, x1.y ) );\n\t\t\t\t\t\tx4.set( midpoint( x1.x, x2.x ), midpoint( x1.y, x2.y ) );\n\t\t\t\t\t\tx5.set( midpoint( x0.x, x2.x ), midpoint( x0.y, x2.y ) );\n\n\t\t\t\t\t\tnewUv( newUVs[ j ], x3, x4, x5 );\n\t\t\t\t\t\tnewUv( newUVs[ j ], x0, x3, x5 );\n\n\t\t\t\t\t\tnewUv( newUVs[ j ], x1, x4, x3 );\n\t\t\t\t\t\tnewUv( newUVs[ j ], x2, x5, x4 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Overwrite old arrays\n\t\t\tgeometry.vertices = newVertices;\n\t\t\tgeometry.faces = newFaces;\n\t\t\tif ( hasUvs ) geometry.faceVertexUvs = newUVs;\n\n\t\t\t// console.log('done');\n\n\t\t};\n\n\t} )();\n\t\n\treturn THREE.SubdivisionModifier;\n});\n\ndefine('skylark-threejs-ex/exporters/DRACOExporter',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * Export draco compressed files from threejs geometry objects.\n\t *\n\t * Draco files are compressed and usually are smaller than conventional 3D file formats.\n\t *\n\t * The exporter receives a options object containing\n\t *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\n\t *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\n\t *  - encoderMethod\n\t *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\n\t *  - exportUvs\n\t *  - exportNormals\n\t *\n\t * @class DRACOExporter\n\t * @author tentone\n\t */\n\n\t/* global DracoEncoderModule */\n\n\tTHREE.DRACOExporter = function () {};\n\n\tTHREE.DRACOExporter.prototype = {\n\n\t\tconstructor: THREE.DRACOExporter,\n\n\t\tparse: function ( geometry, options ) {\n\n\n\t\t\tif ( DracoEncoderModule === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.DRACOExporter: required the draco_decoder to work.' );\n\n\t\t\t}\n\n\t\t\tif ( options === undefined ) {\n\n\t\t\t\toptions = {\n\n\t\t\t\t\tdecodeSpeed: 5,\n\t\t\t\t\tencodeSpeed: 5,\n\t\t\t\t\tencoderMethod: THREE.DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n\t\t\t\t\tquantization: [ 16, 8, 8, 8, 8 ],\n\t\t\t\t\texportUvs: true,\n\t\t\t\t\texportNormals: true,\n\t\t\t\t\texportColor: false,\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar dracoEncoder = DracoEncoderModule();\n\t\t\tvar encoder = new dracoEncoder.Encoder();\n\t\t\tvar builder = new dracoEncoder.MeshBuilder();\n\t\t\tvar mesh = new dracoEncoder.Mesh();\n\n\t\t\tif ( geometry.isGeometry === true ) {\n\n\t\t\t\tvar bufferGeometry = new THREE.BufferGeometry();\n\t\t\t\tbufferGeometry.fromGeometry( geometry );\n\t\t\t\tgeometry = bufferGeometry;\n\n\t\t\t}\n\n\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.Geometry or THREE.BufferGeometry instance.' );\n\n\t\t\t}\n\n\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\t\t\tbuilder.AddFloatAttributeToMesh( mesh, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array );\n\n\t\t\tvar faces = geometry.getIndex();\n\n\t\t\tif ( faces !== null ) {\n\n\t\t\t\tbuilder.AddFacesToMesh( mesh, faces.count, faces.array );\n\n\t\t\t} else {\n\n\t\t\t\tvar faces = new ( vertices.count > 65535 ? Uint32Array : Uint16Array )( vertices.count );\n\n\t\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\t\tfaces[ i ] = i;\n\n\t\t\t\t}\n\n\t\t\t\tbuilder.AddFacesToMesh( mesh, vertices.count, faces );\n\n\t\t\t}\n\n\t\t\tif ( options.exportNormals === true ) {\n\n\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\n\n\t\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\t\tbuilder.AddFloatAttributeToMesh( mesh, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.exportUvs === true ) {\n\n\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\tbuilder.AddFloatAttributeToMesh( mesh, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.exportColor === true ) {\n\n\t\t\t\tvar colors = geometry.getAttribute( 'color' );\n\n\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\tbuilder.AddFloatAttributeToMesh( mesh, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//Compress using draco encoder\n\n\t\t\tvar encodedData = new dracoEncoder.DracoInt8Array();\n\n\t\t\t//Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n\t\t\tencoder.SetSpeedOptions( options.encodeSpeed || 5, options.decodeSpeed || 5 );\n\n\t\t\t// Sets the desired encoding method for a given geometry.\n\n\t\t\tif ( options.encoderMethod !== undefined ) {\n\n\t\t\t\tencoder.SetEncodingMethod( options.encoderMethod );\n\n\t\t\t}\n\n\t\t\t// Sets the quantization (number of bits used to represent) compression options for a named attribute.\n\t\t\t// The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n\t\t\tif ( options.quantization !== undefined ) {\n\n\t\t\t\tfor ( var i = 0; i < 5; i ++ ) {\n\n\t\t\t\t\tif ( options.quantization[ i ] !== undefined ) {\n\n\t\t\t\t\t\tencoder.SetAttributeQuantization( i, options.quantization[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar length = encoder.EncodeMeshToDracoBuffer( mesh, encodedData );\n\t\t\tdracoEncoder.destroy( mesh );\n\n\t\t\tif ( length === 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.DRACOExporter: Draco encoding failed.' );\n\n\t\t\t}\n\n\t\t\t//Copy encoded data to buffer.\n\t\t\tvar outputData = new Int8Array( new ArrayBuffer( length ) );\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\toutputData[ i ] = encodedData.GetValue( i );\n\n\t\t\t}\n\n\t\t\tdracoEncoder.destroy( encodedData );\n\t\t\tdracoEncoder.destroy( encoder );\n\t\t\tdracoEncoder.destroy( builder );\n\n\t\t\treturn outputData;\n\n\t\t}\n\n\t};\n\n\t// Encoder methods\n\n\tTHREE.DRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;\n\tTHREE.DRACOExporter.MESH_SEQUENTIAL_ENCODING = 0;\n\n\t// Geometry type\n\n\tTHREE.DRACOExporter.POINT_CLOUD = 0;\n\tTHREE.DRACOExporter.TRIANGULAR_MESH = 1;\n\n\t// Attribute type\n\n\tTHREE.DRACOExporter.INVALID = - 1;\n\tTHREE.DRACOExporter.POSITION = 0;\n\tTHREE.DRACOExporter.NORMAL = 1;\n\tTHREE.DRACOExporter.COLOR = 2;\n\tTHREE.DRACOExporter.TEX_COORD = 3;\n\tTHREE.DRACOExporter.GENERIC = 4;\n\t\n\treturn THREE.DRACOExporter;\n});\n\ndefine('skylark-threejs-ex/exporters/OBJExporter',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tTHREE.OBJExporter = function () {};\n\n\tTHREE.OBJExporter.prototype = {\n\n\t\tconstructor: THREE.OBJExporter,\n\n\t\tparse: function ( object ) {\n\n\t\t\tvar output = '';\n\n\t\t\tvar indexVertex = 0;\n\t\t\tvar indexVertexUvs = 0;\n\t\t\tvar indexNormals = 0;\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvar normal = new THREE.Vector3();\n\t\t\tvar uv = new THREE.Vector2();\n\n\t\t\tvar i, j, k, l, m, face = [];\n\n\t\t\tvar parseMesh = function ( mesh ) {\n\n\t\t\t\tvar nbVertex = 0;\n\t\t\t\tvar nbNormals = 0;\n\t\t\t\tvar nbVertexUvs = 0;\n\n\t\t\t\tvar geometry = mesh.geometry;\n\n\t\t\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\n\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\tgeometry = new THREE.BufferGeometry().setFromObject( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t// shortcuts\n\t\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\t\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\n\t\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\n\t\t\t\t\tvar indices = geometry.getIndex();\n\n\t\t\t\t\t// name of the mesh object\n\t\t\t\t\toutput += 'o ' + mesh.name + '\\n';\n\n\t\t\t\t\t// name of the mesh material\n\t\t\t\t\tif ( mesh.material && mesh.material.name ) {\n\n\t\t\t\t\t\toutput += 'usemtl ' + mesh.material.name + '\\n';\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// vertices\n\n\t\t\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\t\t\tfor ( i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\t\t\t// transfrom the vertex to world space\n\t\t\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\t\tfor ( i = 0, l = uvs.count; i < l; i ++, nbVertexUvs ++ ) {\n\n\t\t\t\t\t\t\tuv.x = uvs.getX( i );\n\t\t\t\t\t\t\tuv.y = uvs.getY( i );\n\n\t\t\t\t\t\t\t// transform the uv to export format\n\t\t\t\t\t\t\toutput += 'vt ' + uv.x + ' ' + uv.y + '\\n';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// normals\n\n\t\t\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\t\t\tfor ( i = 0, l = normals.count; i < l; i ++, nbNormals ++ ) {\n\n\t\t\t\t\t\t\tnormal.x = normals.getX( i );\n\t\t\t\t\t\t\tnormal.y = normals.getY( i );\n\t\t\t\t\t\t\tnormal.z = normals.getZ( i );\n\n\t\t\t\t\t\t\t// transfrom the normal to world space\n\t\t\t\t\t\t\tnormal.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\t// transform the normal to export format\n\t\t\t\t\t\t\toutput += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\tfor ( i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tfor ( m = 0; m < 3; m ++ ) {\n\n\t\t\t\t\t\t\t\tj = indices.getX( i + m ) + 1;\n\n\t\t\t\t\t\t\t\tface[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// transform the face to export format\n\t\t\t\t\t\t\toutput += 'f ' + face.join( ' ' ) + \"\\n\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tfor ( m = 0; m < 3; m ++ ) {\n\n\t\t\t\t\t\t\t\tj = i + m + 1;\n\n\t\t\t\t\t\t\t\tface[ m ] = ( indexVertex + j ) + ( normals || uvs ? '/' + ( uvs ? ( indexVertexUvs + j ) : '' ) + ( normals ? '/' + ( indexNormals + j ) : '' ) : '' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// transform the face to export format\n\t\t\t\t\t\t\toutput += 'f ' + face.join( ' ' ) + \"\\n\";\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.OBJExporter.parseMesh(): geometry type unsupported', geometry );\n\n\t\t\t\t}\n\n\t\t\t\t// update index\n\t\t\t\tindexVertex += nbVertex;\n\t\t\t\tindexVertexUvs += nbVertexUvs;\n\t\t\t\tindexNormals += nbNormals;\n\n\t\t\t};\n\n\t\t\tvar parseLine = function ( line ) {\n\n\t\t\t\tvar nbVertex = 0;\n\n\t\t\t\tvar geometry = line.geometry;\n\t\t\t\tvar type = line.type;\n\n\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\tgeometry = new THREE.BufferGeometry().setFromObject( line );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t// shortcuts\n\t\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\n\t\t\t\t\t// name of the line object\n\t\t\t\t\toutput += 'o ' + line.name + '\\n';\n\n\t\t\t\t\tif ( vertices !== undefined ) {\n\n\t\t\t\t\t\tfor ( i = 0, l = vertices.count; i < l; i ++, nbVertex ++ ) {\n\n\t\t\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\t\t\t// transfrom the vertex to world space\n\t\t\t\t\t\t\tvertex.applyMatrix4( line.matrixWorld );\n\n\t\t\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( type === 'Line' ) {\n\n\t\t\t\t\t\toutput += 'l ';\n\n\t\t\t\t\t\tfor ( j = 1, l = vertices.count; j <= l; j ++ ) {\n\n\t\t\t\t\t\t\toutput += ( indexVertex + j ) + ' ';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toutput += '\\n';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( type === 'LineSegments' ) {\n\n\t\t\t\t\t\tfor ( j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1 ) {\n\n\t\t\t\t\t\t\toutput += 'l ' + ( indexVertex + j ) + ' ' + ( indexVertex + k ) + '\\n';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.OBJExporter.parseLine(): geometry type unsupported', geometry );\n\n\t\t\t\t}\n\n\t\t\t\t// update index\n\t\t\t\tindexVertex += nbVertex;\n\n\t\t\t};\n\n\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\tif ( child instanceof THREE.Mesh ) {\n\n\t\t\t\t\tparseMesh( child );\n\n\t\t\t\t}\n\n\t\t\t\tif ( child instanceof THREE.Line ) {\n\n\t\t\t\t\tparseLine( child );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn output;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.OBJExporter;\n});\n\ndefine('skylark-threejs-ex/exporters/STLExporter',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author kovacsv / http://kovacsv.hu/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mudcube / http://mudcu.be/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Usage:\n\t *  var exporter = new THREE.STLExporter();\n\t *\n\t *  // second argument is a list of options\n\t *  var data = exporter.parse( mesh, { binary: true } );\n\t *\n\t */\n\n\tTHREE.STLExporter = function () {};\n\n\tTHREE.STLExporter.prototype = {\n\n\t\tconstructor: THREE.STLExporter,\n\n\t\tparse: ( function () {\n\n\t\t\tvar vector = new THREE.Vector3();\n\t\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\n\t\t\treturn function parse( scene, options ) {\n\n\t\t\t\tif ( options === undefined ) options = {};\n\n\t\t\t\tvar binary = options.binary !== undefined ? options.binary : false;\n\n\t\t\t\t//\n\n\t\t\t\tvar objects = [];\n\t\t\t\tvar triangles = 0;\t\n\n\t\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.isMesh ) {\n\n\t\t\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry( geometry );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\t\t\t\ttriangles += geometry.faces.length;\n\n\t\t\t\t\t\t\tobjects.push( {\n\n\t\t\t\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\t\t\t\tmatrixWorld: object.matrixWorld\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tif ( binary ) {\n\n\t\t\t\t\tvar offset = 80; // skip header\n\t\t\t\t\tvar bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n\t\t\t\t\tvar arrayBuffer = new ArrayBuffer( bufferLength );\n\t\t\t\t\tvar output = new DataView( arrayBuffer );\n\t\t\t\t\toutput.setUint32( offset, triangles, true ); offset += 4;\n\n\t\t\t\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar object = objects[ i ];\n\n\t\t\t\t\t\tvar vertices = object.geometry.vertices;\n\t\t\t\t\t\tvar faces = object.geometry.faces;\n\t\t\t\t\t\tvar matrixWorld = object.matrixWorld;\n\n\t\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( matrixWorld );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = faces.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar face = faces[ j ];\n\n\t\t\t\t\t\t\tvector.copy( face.normal ).applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\toutput.setFloat32( offset, vector.x, true ); offset += 4; // normal\n\t\t\t\t\t\t\toutput.setFloat32( offset, vector.y, true ); offset += 4;\n\t\t\t\t\t\t\toutput.setFloat32( offset, vector.z, true ); offset += 4;\n\n\t\t\t\t\t\t\tvar indices = [ face.a, face.b, face.c ];\n\n\t\t\t\t\t\t\tfor ( var k = 0; k < 3; k ++ ) {\n\n\t\t\t\t\t\t\t\tvector.copy( vertices[ indices[ k ] ] ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\t\t\toutput.setFloat32( offset, vector.x, true ); offset += 4; // vertices\n\t\t\t\t\t\t\t\toutput.setFloat32( offset, vector.y, true ); offset += 4;\n\t\t\t\t\t\t\t\toutput.setFloat32( offset, vector.z, true ); offset += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutput.setUint16( offset, 0, true ); offset += 2; // attribute byte count\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn output;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar output = '';\n\n\t\t\t\t\toutput += 'solid exported\\n';\n\n\t\t\t\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar object = objects[ i ];\n\n\t\t\t\t\t\tvar vertices = object.geometry.vertices;\n\t\t\t\t\t\tvar faces = object.geometry.faces;\n\t\t\t\t\t\tvar matrixWorld = object.matrixWorld;\n\n\t\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( matrixWorld );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = faces.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar face = faces[ j ];\n\n\t\t\t\t\t\t\tvector.copy( face.normal ).applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\toutput += '\\tfacet normal ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\\n';\n\t\t\t\t\t\t\toutput += '\\t\\touter loop\\n';\n\n\t\t\t\t\t\t\tvar indices = [ face.a, face.b, face.c ];\n\n\t\t\t\t\t\t\tfor ( var k = 0; k < 3; k ++ ) {\n\n\t\t\t\t\t\t\t\tvector.copy( vertices[ indices[ k ] ] ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\t\t\toutput += '\\t\\t\\tvertex ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\\n';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutput += '\\t\\tendloop\\n';\n\t\t\t\t\t\t\toutput += '\\tendfacet\\n';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutput += 'endsolid exported\\n';\n\n\t\t\t\t\treturn output;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() )\n\n\t};\n\t\n\treturn THREE.STLExporter;\n});\n\ndefine('skylark-threejs-ex/exporters/GLTFExporter',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author fernandojsg / http://fernandojsg.com\n\t * @author Don McCurdy / https://www.donmccurdy.com\n\t * @author Takahiro / https://github.com/takahirox\n\t */\n\n\t//------------------------------------------------------------------------------\n\t// Constants\n\t//------------------------------------------------------------------------------\n\tvar WEBGL_CONSTANTS = {\n\t\tPOINTS: 0x0000,\n\t\tLINES: 0x0001,\n\t\tLINE_LOOP: 0x0002,\n\t\tLINE_STRIP: 0x0003,\n\t\tTRIANGLES: 0x0004,\n\t\tTRIANGLE_STRIP: 0x0005,\n\t\tTRIANGLE_FAN: 0x0006,\n\n\t\tUNSIGNED_BYTE: 0x1401,\n\t\tUNSIGNED_SHORT: 0x1403,\n\t\tFLOAT: 0x1406,\n\t\tUNSIGNED_INT: 0x1405,\n\t\tARRAY_BUFFER: 0x8892,\n\t\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\t\tNEAREST: 0x2600,\n\t\tLINEAR: 0x2601,\n\t\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\t\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\t\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\t\tLINEAR_MIPMAP_LINEAR: 0x2703,\n\n\t\tCLAMP_TO_EDGE: 33071,\n\t\tMIRRORED_REPEAT: 33648,\n\t\tREPEAT: 10497\n\t};\n\n\tvar THREE_TO_WEBGL = {};\n\n\tTHREE_TO_WEBGL[ THREE.NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\n\tTHREE_TO_WEBGL[ THREE.NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\n\tTHREE_TO_WEBGL[ THREE.NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\n\tTHREE_TO_WEBGL[ THREE.LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\n\tTHREE_TO_WEBGL[ THREE.LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\n\tTHREE_TO_WEBGL[ THREE.LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\n\tTHREE_TO_WEBGL[ THREE.ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\n\tTHREE_TO_WEBGL[ THREE.RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\n\tTHREE_TO_WEBGL[ THREE.MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\n\tvar PATH_PROPERTIES = {\n\t\tscale: 'scale',\n\t\tposition: 'translation',\n\t\tquaternion: 'rotation',\n\t\tmorphTargetInfluences: 'weights'\n\t};\n\n\t//------------------------------------------------------------------------------\n\t// GLTF Exporter\n\t//------------------------------------------------------------------------------\n\tTHREE.GLTFExporter = function () {};\n\n\tTHREE.GLTFExporter.prototype = {\n\n\t\tconstructor: THREE.GLTFExporter,\n\n\t\t/**\n\t\t * Parse scenes and generate GLTF output\n\t\t * @param  {THREE.Scene or [THREE.Scenes]} input   THREE.Scene or Array of THREE.Scenes\n\t\t * @param  {Function} onDone  Callback on completed\n\t\t * @param  {Object} options options\n\t\t */\n\t\tparse: function ( input, onDone, options ) {\n\n\t\t\tvar DEFAULT_OPTIONS = {\n\t\t\t\tbinary: false,\n\t\t\t\ttrs: false,\n\t\t\t\tonlyVisible: true,\n\t\t\t\ttruncateDrawRange: true,\n\t\t\t\tembedImages: true,\n\t\t\t\tmaxTextureSize: Infinity,\n\t\t\t\tanimations: [],\n\t\t\t\tforceIndices: false,\n\t\t\t\tforcePowerOfTwoTextures: false,\n\t\t\t\tincludeCustomExtensions: false\n\t\t\t};\n\n\t\t\toptions = Object.assign( {}, DEFAULT_OPTIONS, options );\n\n\t\t\tif ( options.animations.length > 0 ) {\n\n\t\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\t\toptions.trs = true;\n\n\t\t\t}\n\n\t\t\tvar outputJSON = {\n\n\t\t\t\tasset: {\n\n\t\t\t\t\tversion: \"2.0\",\n\t\t\t\t\tgenerator: \"THREE.GLTFExporter\"\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tvar byteOffset = 0;\n\t\t\tvar buffers = [];\n\t\t\tvar pending = [];\n\t\t\tvar nodeMap = new Map();\n\t\t\tvar skins = [];\n\t\t\tvar extensionsUsed = {};\n\t\t\tvar cachedData = {\n\n\t\t\t\tmeshes: new Map(),\n\t\t\t\tattributes: new Map(),\n\t\t\t\tattributesNormalized: new Map(),\n\t\t\t\tmaterials: new Map(),\n\t\t\t\ttextures: new Map(),\n\t\t\t\timages: new Map()\n\n\t\t\t};\n\n\t\t\tvar cachedCanvas;\n\n\t\t\tvar uids = new Map();\n\t\t\tvar uid = 0;\n\n\t\t\t/**\n\t\t\t * Assign and return a temporal unique id for an object\n\t\t\t * especially which doesn't have .uuid\n\t\t\t * @param  {Object} object\n\t\t\t * @return {Integer}\n\t\t\t */\n\t\t\tfunction getUID( object ) {\n\n\t\t\t\tif ( ! uids.has( object ) ) uids.set( object, uid ++ );\n\n\t\t\t\treturn uids.get( object );\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Compare two arrays\n\t\t\t * @param  {Array} array1 Array 1 to compare\n\t\t\t * @param  {Array} array2 Array 2 to compare\n\t\t\t * @return {Boolean}        Returns true if both arrays are equal\n\t\t\t */\n\t\t\tfunction equalArray( array1, array2 ) {\n\n\t\t\t\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\t\t\t\treturn element === array2[ index ];\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Converts a string to an ArrayBuffer.\n\t\t\t * @param  {string} text\n\t\t\t * @return {ArrayBuffer}\n\t\t\t */\n\t\t\tfunction stringToArrayBuffer( text ) {\n\n\t\t\t\tif ( window.TextEncoder !== undefined ) {\n\n\t\t\t\t\treturn new TextEncoder().encode( text ).buffer;\n\n\t\t\t\t}\n\n\t\t\t\tvar array = new Uint8Array( new ArrayBuffer( text.length ) );\n\n\t\t\t\tfor ( var i = 0, il = text.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar value = text.charCodeAt( i );\n\n\t\t\t\t\t// Replacing multi-byte character with space(0x20).\n\t\t\t\t\tarray[ i ] = value > 0xFF ? 0x20 : value;\n\n\t\t\t\t}\n\n\t\t\t\treturn array.buffer;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Get the min and max vectors from the given attribute\n\t\t\t * @param  {THREE.BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n\t\t\t * @param  {Integer} start\n\t\t\t * @param  {Integer} count\n\t\t\t * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n\t\t\t */\n\t\t\tfunction getMinMax( attribute, start, count ) {\n\n\t\t\t\tvar output = {\n\n\t\t\t\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\t\t\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = start; i < start + count; i ++ ) {\n\n\t\t\t\t\tfor ( var a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\t\tvar value = attribute.array[ i * attribute.itemSize + a ];\n\t\t\t\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\t\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn output;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Checks if image size is POT.\n\t\t\t *\n\t\t\t * @param {Image} image The image to be checked.\n\t\t\t * @returns {Boolean} Returns true if image size is POT.\n\t\t\t *\n\t\t\t */\n\t\t\tfunction isPowerOfTwo( image ) {\n\n\t\t\t\treturn THREE.MathUtils.isPowerOfTwo( image.width ) && THREE.MathUtils.isPowerOfTwo( image.height );\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Checks if normal attribute values are normalized.\n\t\t\t *\n\t\t\t * @param {THREE.BufferAttribute} normal\n\t\t\t * @returns {Boolean}\n\t\t\t *\n\t\t\t */\n\t\t\tfunction isNormalizedNormalAttribute( normal ) {\n\n\t\t\t\tif ( cachedData.attributesNormalized.has( normal ) ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tvar v = new THREE.Vector3();\n\n\t\t\t\tfor ( var i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t\t\t// 0.0005 is from glTF-validator\n\t\t\t\t\tif ( Math.abs( v.fromArray( normal.array, i * 3 ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Creates normalized normal buffer attribute.\n\t\t\t *\n\t\t\t * @param {THREE.BufferAttribute} normal\n\t\t\t * @returns {THREE.BufferAttribute}\n\t\t\t *\n\t\t\t */\n\t\t\tfunction createNormalizedNormalAttribute( normal ) {\n\n\t\t\t\tif ( cachedData.attributesNormalized.has( normal ) ) {\n\n\t\t\t\t\treturn cachedData.attributesNormalized.get( normal );\n\n\t\t\t\t}\n\n\t\t\t\tvar attribute = normal.clone();\n\n\t\t\t\tvar v = new THREE.Vector3();\n\n\t\t\t\tfor ( var i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tv.fromArray( attribute.array, i * 3 );\n\n\t\t\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\t\t\tv.setX( 1.0 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv.normalize();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tv.toArray( attribute.array, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tcachedData.attributesNormalized.set( normal, attribute );\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n\t\t\t * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n\t\t\t *\n\t\t\t * @param {Integer} bufferSize The size the original buffer.\n\t\t\t * @returns {Integer} new buffer size with required padding.\n\t\t\t *\n\t\t\t */\n\t\t\tfunction getPaddedBufferSize( bufferSize ) {\n\n\t\t\t\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Returns a buffer aligned to 4-byte boundary.\n\t\t\t *\n\t\t\t * @param {ArrayBuffer} arrayBuffer Buffer to pad\n\t\t\t * @param {Integer} paddingByte (Optional)\n\t\t\t * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n\t\t\t */\n\t\t\tfunction getPaddedArrayBuffer( arrayBuffer, paddingByte ) {\n\n\t\t\t\tpaddingByte = paddingByte || 0;\n\n\t\t\t\tvar paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\t\t\t\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\t\t\t\tvar array = new Uint8Array( paddedLength );\n\t\t\t\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\t\t\t\tif ( paddingByte !== 0 ) {\n\n\t\t\t\t\t\tfor ( var i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn array.buffer;\n\n\t\t\t\t}\n\n\t\t\t\treturn arrayBuffer;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Serializes a userData.\n\t\t\t *\n\t\t\t * @param {THREE.Object3D|THREE.Material} object\n\t\t\t * @param {Object} gltfProperty\n\t\t\t */\n\t\t\tfunction serializeUserData( object, gltfProperty ) {\n\n\t\t\t\tif ( Object.keys( object.userData ).length === 0 ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar json = JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\n\n\t\t\t\t\t\tif ( gltfProperty.extensions === undefined ) {\n\n\t\t\t\t\t\t\tgltfProperty.extensions = {};\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( var extensionName in json.gltfExtensions ) {\n\n\t\t\t\t\t\t\tgltfProperty.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\n\t\t\t\t\t\t\textensionsUsed[ extensionName ] = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete json.gltfExtensions;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Object.keys( json ).length > 0 ) {\n\n\t\t\t\t\t\tgltfProperty.extras = json;\n\n\t\t\t\t\t}\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Applies a texture transform, if present, to the map definition. Requires\n\t\t\t * the KHR_texture_transform extension.\n\t\t\t */\n\t\t\tfunction applyTextureTransform( mapDef, texture ) {\n\n\t\t\t\tvar didTransform = false;\n\t\t\t\tvar transformDef = {};\n\n\t\t\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\n\n\t\t\t\t\ttransformDef.offset = texture.offset.toArray();\n\t\t\t\t\tdidTransform = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.rotation !== 0 ) {\n\n\t\t\t\t\ttransformDef.rotation = texture.rotation;\n\t\t\t\t\tdidTransform = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\n\n\t\t\t\t\ttransformDef.scale = texture.repeat.toArray();\n\t\t\t\t\tdidTransform = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( didTransform ) {\n\n\t\t\t\t\tmapDef.extensions = mapDef.extensions || {};\n\t\t\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\n\t\t\t\t\textensionsUsed[ 'KHR_texture_transform' ] = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process a buffer to append to the default one.\n\t\t\t * @param  {ArrayBuffer} buffer\n\t\t\t * @return {Integer}\n\t\t\t */\n\t\t\tfunction processBuffer( buffer ) {\n\n\t\t\t\tif ( ! outputJSON.buffers ) {\n\n\t\t\t\t\toutputJSON.buffers = [ { byteLength: 0 } ];\n\n\t\t\t\t}\n\n\t\t\t\t// All buffers are merged before export.\n\t\t\t\tbuffers.push( buffer );\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process and generate a BufferView\n\t\t\t * @param  {THREE.BufferAttribute} attribute\n\t\t\t * @param  {number} componentType\n\t\t\t * @param  {number} start\n\t\t\t * @param  {number} count\n\t\t\t * @param  {number} target (Optional) Target usage of the BufferView\n\t\t\t * @return {Object}\n\t\t\t */\n\t\t\tfunction processBufferView( attribute, componentType, start, count, target ) {\n\n\t\t\t\tif ( ! outputJSON.bufferViews ) {\n\n\t\t\t\t\toutputJSON.bufferViews = [];\n\n\t\t\t\t}\n\n\t\t\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\t\t\tvar componentSize;\n\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\tcomponentSize = 1;\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\tcomponentSize = 2;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcomponentSize = 4;\n\n\t\t\t\t}\n\n\t\t\t\tvar byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );\n\t\t\t\tvar dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\t\t\tvar offset = 0;\n\n\t\t\t\tfor ( var i = start; i < start + count; i ++ ) {\n\n\t\t\t\t\tfor ( var a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\t\t// @TODO Fails on InterleavedBufferAttribute, and could probably be\n\t\t\t\t\t\t// optimized for normal BufferAttribute.\n\t\t\t\t\t\tvar value = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toffset += componentSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfBufferView = {\n\n\t\t\t\t\tbuffer: processBuffer( dataView.buffer ),\n\t\t\t\t\tbyteOffset: byteOffset,\n\t\t\t\t\tbyteLength: byteLength\n\n\t\t\t\t};\n\n\t\t\t\tif ( target !== undefined ) gltfBufferView.target = target;\n\n\t\t\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t\t\t// Only define byteStride for vertex attributes.\n\t\t\t\t\tgltfBufferView.byteStride = attribute.itemSize * componentSize;\n\n\t\t\t\t}\n\n\t\t\t\tbyteOffset += byteLength;\n\n\t\t\t\toutputJSON.bufferViews.push( gltfBufferView );\n\n\t\t\t\t// @TODO Merge bufferViews where possible.\n\t\t\t\tvar output = {\n\n\t\t\t\t\tid: outputJSON.bufferViews.length - 1,\n\t\t\t\t\tbyteLength: 0\n\n\t\t\t\t};\n\n\t\t\t\treturn output;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process and generate a BufferView from an image Blob.\n\t\t\t * @param {Blob} blob\n\t\t\t * @return {Promise<Integer>}\n\t\t\t */\n\t\t\tfunction processBufferViewImage( blob ) {\n\n\t\t\t\tif ( ! outputJSON.bufferViews ) {\n\n\t\t\t\t\toutputJSON.bufferViews = [];\n\n\t\t\t\t}\n\n\t\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\t\tvar reader = new window.FileReader();\n\t\t\t\t\treader.readAsArrayBuffer( blob );\n\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\tvar buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\t\t\tvar bufferView = {\n\t\t\t\t\t\t\tbuffer: processBuffer( buffer ),\n\t\t\t\t\t\t\tbyteOffset: byteOffset,\n\t\t\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t\t\t\t\toutputJSON.bufferViews.push( bufferView );\n\n\t\t\t\t\t\tresolve( outputJSON.bufferViews.length - 1 );\n\n\t\t\t\t\t};\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process attribute to generate an accessor\n\t\t\t * @param  {THREE.BufferAttribute} attribute Attribute to process\n\t\t\t * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n\t\t\t * @param  {Integer} start (Optional)\n\t\t\t * @param  {Integer} count (Optional)\n\t\t\t * @return {Integer}           Index of the processed accessor on the \"accessors\" array\n\t\t\t */\n\t\t\tfunction processAccessor( attribute, geometry, start, count ) {\n\n\t\t\t\tvar types = {\n\n\t\t\t\t\t1: 'SCALAR',\n\t\t\t\t\t2: 'VEC2',\n\t\t\t\t\t3: 'VEC3',\n\t\t\t\t\t4: 'VEC4',\n\t\t\t\t\t16: 'MAT4'\n\n\t\t\t\t};\n\n\t\t\t\tvar componentType;\n\n\t\t\t\t// Detect the component type of the attribute array (float, uint or ushort)\n\t\t\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( start === undefined ) start = 0;\n\t\t\t\tif ( count === undefined ) count = attribute.count;\n\n\t\t\t\t// @TODO Indexed buffer geometry with drawRange not supported yet\n\t\t\t\tif ( options.truncateDrawRange && geometry !== undefined && geometry.index === null ) {\n\n\t\t\t\t\tvar end = start + count;\n\t\t\t\t\tvar end2 = geometry.drawRange.count === Infinity\n\t\t\t\t\t\t? attribute.count\n\t\t\t\t\t\t: geometry.drawRange.start + geometry.drawRange.count;\n\n\t\t\t\t\tstart = Math.max( start, geometry.drawRange.start );\n\t\t\t\t\tcount = Math.min( end, end2 ) - start;\n\n\t\t\t\t\tif ( count < 0 ) count = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\t\t\tif ( count === 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tvar minMax = getMinMax( attribute, start, count );\n\n\t\t\t\tvar bufferViewTarget;\n\n\t\t\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t\t\t// animation samplers, target must not be set.\n\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t\t\t}\n\n\t\t\t\tvar bufferView = processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\t\t\tvar gltfAccessor = {\n\n\t\t\t\t\tbufferView: bufferView.id,\n\t\t\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\t\t\tcomponentType: componentType,\n\t\t\t\t\tcount: count,\n\t\t\t\t\tmax: minMax.max,\n\t\t\t\t\tmin: minMax.min,\n\t\t\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t\t\t};\n\n\t\t\t\tif ( ! outputJSON.accessors ) {\n\n\t\t\t\t\toutputJSON.accessors = [];\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.accessors.push( gltfAccessor );\n\n\t\t\t\treturn outputJSON.accessors.length - 1;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process image\n\t\t\t * @param  {Image} image to process\n\t\t\t * @param  {Integer} format of the image (e.g. THREE.RGBFormat, THREE.RGBAFormat etc)\n\t\t\t * @param  {Boolean} flipY before writing out the image\n\t\t\t * @return {Integer}     Index of the processed texture in the \"images\" array\n\t\t\t */\n\t\t\tfunction processImage( image, format, flipY ) {\n\n\t\t\t\tif ( ! cachedData.images.has( image ) ) {\n\n\t\t\t\t\tcachedData.images.set( image, {} );\n\n\t\t\t\t}\n\n\t\t\t\tvar cachedImages = cachedData.images.get( image );\n\t\t\t\tvar mimeType = format === THREE.RGBAFormat ? 'image/png' : 'image/jpeg';\n\t\t\t\tvar key = mimeType + \":flipY/\" + flipY.toString();\n\n\t\t\t\tif ( cachedImages[ key ] !== undefined ) {\n\n\t\t\t\t\treturn cachedImages[ key ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! outputJSON.images ) {\n\n\t\t\t\t\toutputJSON.images = [];\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfImage = { mimeType: mimeType };\n\n\t\t\t\tif ( options.embedImages ) {\n\n\t\t\t\t\tvar canvas = cachedCanvas = cachedCanvas || document.createElement( 'canvas' );\n\n\t\t\t\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\n\t\t\t\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\n\n\t\t\t\t\tif ( options.forcePowerOfTwoTextures && ! isPowerOfTwo( canvas ) ) {\n\n\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Resized non-power-of-two image.', image );\n\n\t\t\t\t\t\tcanvas.width = THREE.MathUtils.floorPowerOfTwo( canvas.width );\n\t\t\t\t\t\tcanvas.height = THREE.MathUtils.floorPowerOfTwo( canvas.height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar ctx = canvas.getContext( '2d' );\n\n\t\t\t\t\tif ( flipY === true ) {\n\n\t\t\t\t\t\tctx.translate( 0, canvas.height );\n\t\t\t\t\t\tctx.scale( 1, - 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\t\tif ( options.binary === true ) {\n\n\t\t\t\t\t\tpending.push( new Promise( function ( resolve ) {\n\n\t\t\t\t\t\t\tcanvas.toBlob( function ( blob ) {\n\n\t\t\t\t\t\t\t\tprocessBufferViewImage( blob ).then( function ( bufferViewIndex ) {\n\n\t\t\t\t\t\t\t\t\tgltfImage.bufferView = bufferViewIndex;\n\n\t\t\t\t\t\t\t\t\tresolve();\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}, mimeType );\n\n\t\t\t\t\t\t} ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgltfImage.uri = canvas.toDataURL( mimeType );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgltfImage.uri = image.src;\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.images.push( gltfImage );\n\n\t\t\t\tvar index = outputJSON.images.length - 1;\n\t\t\t\tcachedImages[ key ] = index;\n\n\t\t\t\treturn index;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process sampler\n\t\t\t * @param  {Texture} map Texture to process\n\t\t\t * @return {Integer}     Index of the processed texture in the \"samplers\" array\n\t\t\t */\n\t\t\tfunction processSampler( map ) {\n\n\t\t\t\tif ( ! outputJSON.samplers ) {\n\n\t\t\t\t\toutputJSON.samplers = [];\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfSampler = {\n\n\t\t\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\n\t\t\t\t};\n\n\t\t\t\toutputJSON.samplers.push( gltfSampler );\n\n\t\t\t\treturn outputJSON.samplers.length - 1;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process texture\n\t\t\t * @param  {Texture} map Map to process\n\t\t\t * @return {Integer}     Index of the processed texture in the \"textures\" array\n\t\t\t */\n\t\t\tfunction processTexture( map ) {\n\n\t\t\t\tif ( cachedData.textures.has( map ) ) {\n\n\t\t\t\t\treturn cachedData.textures.get( map );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! outputJSON.textures ) {\n\n\t\t\t\t\toutputJSON.textures = [];\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfTexture = {\n\n\t\t\t\t\tsampler: processSampler( map ),\n\t\t\t\t\tsource: processImage( map.image, map.format, map.flipY )\n\n\t\t\t\t};\n\n\t\t\t\tif ( map.name ) {\n\n\t\t\t\t\tgltfTexture.name = map.name;\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.textures.push( gltfTexture );\n\n\t\t\t\tvar index = outputJSON.textures.length - 1;\n\t\t\t\tcachedData.textures.set( map, index );\n\n\t\t\t\treturn index;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process material\n\t\t\t * @param  {THREE.Material} material Material to process\n\t\t\t * @return {Integer}      Index of the processed material in the \"materials\" array\n\t\t\t */\n\t\t\tfunction processMaterial( material ) {\n\n\t\t\t\tif ( cachedData.materials.has( material ) ) {\n\n\t\t\t\t\treturn cachedData.materials.get( material );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isShaderMaterial ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! outputJSON.materials ) {\n\n\t\t\t\t\toutputJSON.materials = [];\n\n\t\t\t\t}\n\n\t\t\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\t\t\tvar gltfMaterial = {\n\n\t\t\t\t\tpbrMetallicRoughness: {}\n\n\t\t\t\t};\n\n\t\t\t\tif ( material.isMeshBasicMaterial ) {\n\n\t\t\t\t\tgltfMaterial.extensions = { KHR_materials_unlit: {} };\n\n\t\t\t\t\textensionsUsed[ 'KHR_materials_unlit' ] = true;\n\n\t\t\t\t} else if ( material.isGLTFSpecularGlossinessMaterial ) {\n\n\t\t\t\t\tgltfMaterial.extensions = { KHR_materials_pbrSpecularGlossiness: {} };\n\n\t\t\t\t\textensionsUsed[ 'KHR_materials_pbrSpecularGlossiness' ] = true;\n\n\t\t\t\t} else if ( ! material.isMeshStandardMaterial ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t\t\t}\n\n\t\t\t\t// pbrMetallicRoughness.baseColorFactor\n\t\t\t\tvar color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\t\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t\t\t} else if ( material.isMeshBasicMaterial ) {\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = 0.5;\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.5;\n\n\t\t\t\t}\n\n\t\t\t\t// pbrSpecularGlossiness diffuse, specular and glossiness factor\n\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) {\n\n\t\t\t\t\tif ( gltfMaterial.pbrMetallicRoughness.baseColorFactor ) {\n\n\t\t\t\t\t\tgltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor = gltfMaterial.pbrMetallicRoughness.baseColorFactor;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar specularFactor = [ 1, 1, 1 ];\n\t\t\t\t\tmaterial.specular.toArray( specularFactor, 0 );\n\t\t\t\t\tgltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor = specularFactor;\n\n\t\t\t\t\tgltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor = material.glossiness;\n\n\t\t\t\t}\n\n\t\t\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\t\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\t\t\tif ( material.metalnessMap === material.roughnessMap ) {\n\n\t\t\t\t\t\tvar metalRoughMapDef = { index: processTexture( material.metalnessMap ) };\n\t\t\t\t\t\tapplyTextureTransform( metalRoughMapDef, material.metalnessMap );\n\t\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\tvar baseColorMapDef = { index: processTexture( material.map ) };\n\t\t\t\t\tapplyTextureTransform( baseColorMapDef, material.map );\n\n\t\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) {\n\n\t\t\t\t\t\tgltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.diffuseTexture = baseColorMapDef;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n\n\t\t\t\t}\n\n\t\t\t\t// pbrSpecularGlossiness specular map\n\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial && material.specularMap ) {\n\n\t\t\t\t\tvar specularMapDef = { index: processTexture( material.specularMap ) };\n\t\t\t\t\tapplyTextureTransform( specularMapDef, material.specularMap );\n\t\t\t\t\tgltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.specularGlossinessTexture = specularMapDef;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.emissive ) {\n\n\t\t\t\t\t// emissiveFactor\n\t\t\t\t\tvar emissive = material.emissive.clone().multiplyScalar( material.emissiveIntensity ).toArray();\n\n\t\t\t\t\tif ( ! equalArray( emissive, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\t\t\tgltfMaterial.emissiveFactor = emissive;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// emissiveTexture\n\t\t\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\t\t\tvar emissiveMapDef = { index: processTexture( material.emissiveMap ) };\n\t\t\t\t\t\tapplyTextureTransform( emissiveMapDef, material.emissiveMap );\n\t\t\t\t\t\tgltfMaterial.emissiveTexture = emissiveMapDef;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// normalTexture\n\t\t\t\tif ( material.normalMap ) {\n\n\t\t\t\t\tvar normalMapDef = { index: processTexture( material.normalMap ) };\n\n\t\t\t\t\tif ( material.normalScale && material.normalScale.x !== - 1 ) {\n\n\t\t\t\t\t\tif ( material.normalScale.x !== material.normalScale.y ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormalMapDef.scale = material.normalScale.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tapplyTextureTransform( normalMapDef, material.normalMap );\n\n\t\t\t\t\tgltfMaterial.normalTexture = normalMapDef;\n\n\t\t\t\t}\n\n\t\t\t\t// occlusionTexture\n\t\t\t\tif ( material.aoMap ) {\n\n\t\t\t\t\tvar occlusionMapDef = {\n\t\t\t\t\t\tindex: processTexture( material.aoMap ),\n\t\t\t\t\t\ttexCoord: 1\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tapplyTextureTransform( occlusionMapDef, material.aoMap );\n\n\t\t\t\t\tgltfMaterial.occlusionTexture = occlusionMapDef;\n\n\t\t\t\t}\n\n\t\t\t\t// alphaMode\n\t\t\t\tif ( material.transparent ) {\n\n\t\t\t\t\tgltfMaterial.alphaMode = 'BLEND';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( material.alphaTest > 0.0 ) {\n\n\t\t\t\t\t\tgltfMaterial.alphaMode = 'MASK';\n\t\t\t\t\t\tgltfMaterial.alphaCutoff = material.alphaTest;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// doubleSided\n\t\t\t\tif ( material.side === THREE.DoubleSide ) {\n\n\t\t\t\t\tgltfMaterial.doubleSided = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.name !== '' ) {\n\n\t\t\t\t\tgltfMaterial.name = material.name;\n\n\t\t\t\t}\n\n\t\t\t\tserializeUserData( material, gltfMaterial );\n\n\t\t\t\toutputJSON.materials.push( gltfMaterial );\n\n\t\t\t\tvar index = outputJSON.materials.length - 1;\n\t\t\t\tcachedData.materials.set( material, index );\n\n\t\t\t\treturn index;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process mesh\n\t\t\t * @param  {THREE.Mesh} mesh Mesh to process\n\t\t\t * @return {Integer}      Index of the processed mesh in the \"meshes\" array\n\t\t\t */\n\t\t\tfunction processMesh( mesh ) {\n\n\t\t\t\tvar meshCacheKeyParts = [ mesh.geometry.uuid ];\n\t\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\t\tfor ( var i = 0, l = mesh.material.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tvar meshCacheKey = meshCacheKeyParts.join( ':' );\n\t\t\t\tif ( cachedData.meshes.has( meshCacheKey ) ) {\n\n\t\t\t\t\treturn cachedData.meshes.get( meshCacheKey );\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = mesh.geometry;\n\n\t\t\t\tvar mode;\n\n\t\t\t\t// Use the correct mode\n\t\t\t\tif ( mesh.isLineSegments ) {\n\n\t\t\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t\t\t} else if ( mesh.isLine ) {\n\n\t\t\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t\t\t} else if ( mesh.isPoints ) {\n\n\t\t\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Exporting THREE.Geometry will increase file size. Use THREE.BufferGeometry instead.' );\n\t\t\t\t\tgeometry = new THREE.BufferGeometry().setFromObject( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfMesh = {};\n\n\t\t\t\tvar attributes = {};\n\t\t\t\tvar primitives = [];\n\t\t\t\tvar targets = [];\n\n\t\t\t\t// Conversion between attributes names in threejs and gltf spec\n\t\t\t\tvar nameConversion = {\n\n\t\t\t\t\tuv: 'TEXCOORD_0',\n\t\t\t\t\tuv2: 'TEXCOORD_1',\n\t\t\t\t\tcolor: 'COLOR_0',\n\t\t\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\t\t\tskinIndex: 'JOINTS_0'\n\n\t\t\t\t};\n\n\t\t\t\tvar originalNormal = geometry.getAttribute( 'normal' );\n\n\t\t\t\tif ( originalNormal !== undefined && ! isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t\t\t}\n\n\t\t\t\t// @QUESTION Detect if .vertexColors = true?\n\t\t\t\t// For every attribute create an accessor\n\t\t\t\tvar modifiedAttribute = null;\n\t\t\t\tfor ( var attributeName in geometry.attributes ) {\n\n\t\t\t\t\t// Ignore morph target attributes, which are exported later.\n\t\t\t\t\tif ( attributeName.substr( 0, 5 ) === 'morph' ) continue;\n\n\t\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t\t\t// Prefix all geometry attributes except the ones specifically\n\t\t\t\t\t// listed in the spec; non-spec attributes are considered custom.\n\t\t\t\t\tvar validVertexAttributes =\n\t\t\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\t\t\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) {\n\n\t\t\t\t\t\tattributeName = '_' + attributeName;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cachedData.attributes.has( getUID( attribute ) ) ) {\n\n\t\t\t\t\t\tattributes[ attributeName ] = cachedData.attributes.get( getUID( attribute ) );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\t\t\t\t\tmodifiedAttribute = null;\n\t\t\t\t\tvar array = attribute.array;\n\t\t\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\t\t\tmodifiedAttribute = new THREE.BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar accessor = processAccessor( modifiedAttribute || attribute, geometry );\n\t\t\t\t\tif ( accessor !== null ) {\n\n\t\t\t\t\t\tattributes[ attributeName ] = accessor;\n\t\t\t\t\t\tcachedData.attributes.set( getUID( attribute ), accessor );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\n\n\t\t\t\t// Skip if no exportable attributes found\n\t\t\t\tif ( Object.keys( attributes ).length === 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// Morph targets\n\t\t\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\t\t\tvar weights = [];\n\t\t\t\t\tvar targetNames = [];\n\t\t\t\t\tvar reverseDictionary = {};\n\n\t\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\t\t\tfor ( var key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\t\t\tvar target = {};\n\n\t\t\t\t\t\tvar warned = false;\n\n\t\t\t\t\t\tfor ( var attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar attribute = geometry.morphAttributes[ attributeName ][ i ];\n\t\t\t\t\t\t\tvar gltfAttributeName = attributeName.toUpperCase();\n\n\t\t\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\t\t\tvar baseAttribute = geometry.attributes[ attributeName ];\n\n\t\t\t\t\t\t\tif ( cachedData.attributes.has( getUID( attribute ) ) ) {\n\n\t\t\t\t\t\t\t\ttarget[ gltfAttributeName ] = cachedData.attributes.get( getUID( attribute ) );\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\t\t\tvar relativeAttribute = attribute.clone();\n\n\t\t\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t\tfor ( var j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\t\trelativeAttribute.setXYZ(\n\t\t\t\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\t\t\t\tattribute.getX( j ) - baseAttribute.getX( j ),\n\t\t\t\t\t\t\t\t\t\tattribute.getY( j ) - baseAttribute.getY( j ),\n\t\t\t\t\t\t\t\t\t\tattribute.getZ( j ) - baseAttribute.getZ( j )\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttarget[ gltfAttributeName ] = processAccessor( relativeAttribute, geometry );\n\t\t\t\t\t\t\tcachedData.attributes.set( getUID( baseAttribute ), target[ gltfAttributeName ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargets.push( target );\n\n\t\t\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\t\t\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgltfMesh.weights = weights;\n\n\t\t\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\t\t\tgltfMesh.extras = {};\n\t\t\t\t\t\tgltfMesh.extras.targetNames = targetNames;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar forceIndices = options.forceIndices;\n\t\t\t\tvar isMultiMaterial = Array.isArray( mesh.material );\n\n\t\t\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\t\t\tif ( ! forceIndices && geometry.index === null && isMultiMaterial ) {\n\n\t\t\t\t\t// temporal workaround.\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating index for non-indexed multi-material mesh.' );\n\t\t\t\t\tforceIndices = true;\n\n\t\t\t\t}\n\n\t\t\t\tvar didForceIndices = false;\n\n\t\t\t\tif ( geometry.index === null && forceIndices ) {\n\n\t\t\t\t\tvar indices = [];\n\n\t\t\t\t\tfor ( var i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {\n\n\t\t\t\t\t\tindices[ i ] = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setIndex( indices );\n\n\t\t\t\t\tdidForceIndices = true;\n\n\t\t\t\t}\n\n\t\t\t\tvar materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\t\t\tvar groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\t\t\tfor ( var i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar primitive = {\n\t\t\t\t\t\tmode: mode,\n\t\t\t\t\t\tattributes: attributes,\n\t\t\t\t\t};\n\n\t\t\t\t\tserializeUserData( geometry, primitive );\n\n\t\t\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t\t\tvar cacheKey = getUID( geometry.index );\n\n\t\t\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\n\n\t\t\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( cachedData.attributes.has( cacheKey ) ) {\n\n\t\t\t\t\t\t\tprimitive.indices = cachedData.attributes.get( cacheKey );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tprimitive.indices = processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\t\t\t\t\t\t\tcachedData.attributes.set( cacheKey, primitive.indices );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar material = processMaterial( materials[ groups[ i ].materialIndex ] );\n\n\t\t\t\t\tif ( material !== null ) {\n\n\t\t\t\t\t\tprimitive.material = material;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tprimitives.push( primitive );\n\n\t\t\t\t}\n\n\t\t\t\tif ( didForceIndices ) {\n\n\t\t\t\t\tgeometry.setIndex( null );\n\n\t\t\t\t}\n\n\t\t\t\tgltfMesh.primitives = primitives;\n\n\t\t\t\tif ( ! outputJSON.meshes ) {\n\n\t\t\t\t\toutputJSON.meshes = [];\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.meshes.push( gltfMesh );\n\n\t\t\t\tvar index = outputJSON.meshes.length - 1;\n\t\t\t\tcachedData.meshes.set( meshCacheKey, index );\n\n\t\t\t\treturn index;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process camera\n\t\t\t * @param  {THREE.Camera} camera Camera to process\n\t\t\t * @return {Integer}      Index of the processed mesh in the \"camera\" array\n\t\t\t */\n\t\t\tfunction processCamera( camera ) {\n\n\t\t\t\tif ( ! outputJSON.cameras ) {\n\n\t\t\t\t\toutputJSON.cameras = [];\n\n\t\t\t\t}\n\n\t\t\t\tvar isOrtho = camera.isOrthographicCamera;\n\n\t\t\t\tvar gltfCamera = {\n\n\t\t\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\n\t\t\t\t};\n\n\t\t\t\tif ( isOrtho ) {\n\n\t\t\t\t\tgltfCamera.orthographic = {\n\n\t\t\t\t\t\txmag: camera.right * 2,\n\t\t\t\t\t\tymag: camera.top * 2,\n\t\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgltfCamera.perspective = {\n\n\t\t\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\t\t\tyfov: THREE.MathUtils.degToRad( camera.fov ),\n\t\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tif ( camera.name !== '' ) {\n\n\t\t\t\t\tgltfCamera.name = camera.type;\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.cameras.push( gltfCamera );\n\n\t\t\t\treturn outputJSON.cameras.length - 1;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Creates glTF animation entry from AnimationClip object.\n\t\t\t *\n\t\t\t * Status:\n\t\t\t * - Only properties listed in PATH_PROPERTIES may be animated.\n\t\t\t *\n\t\t\t * @param {THREE.AnimationClip} clip\n\t\t\t * @param {THREE.Object3D} root\n\t\t\t * @return {number}\n\t\t\t */\n\t\t\tfunction processAnimation( clip, root ) {\n\n\t\t\t\tif ( ! outputJSON.animations ) {\n\n\t\t\t\t\toutputJSON.animations = [];\n\n\t\t\t\t}\n\n\t\t\t\tclip = THREE.GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\n\n\t\t\t\tvar tracks = clip.tracks;\n\t\t\t\tvar channels = [];\n\t\t\t\tvar samplers = [];\n\n\t\t\t\tfor ( var i = 0; i < tracks.length; ++ i ) {\n\n\t\t\t\t\tvar track = tracks[ i ];\n\t\t\t\t\tvar trackBinding = THREE.PropertyBinding.parseTrackName( track.name );\n\t\t\t\t\tvar trackNode = THREE.PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\t\t\tvar trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar inputItemSize = 1;\n\t\t\t\t\tvar outputItemSize = track.values.length / track.times.length;\n\n\t\t\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar interpolation;\n\n\t\t\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t\t\t// valid value from .getInterpolation().\n\t\t\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\t\t\toutputItemSize /= 3;\n\n\t\t\t\t\t} else if ( track.getInterpolation() === THREE.InterpolateDiscrete ) {\n\n\t\t\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsamplers.push( {\n\n\t\t\t\t\t\tinput: processAccessor( new THREE.BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\t\t\toutput: processAccessor( new THREE.BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\t\t\tinterpolation: interpolation\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tchannels.push( {\n\n\t\t\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\t\t\ttarget: {\n\t\t\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\t\t\tpath: trackProperty\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.animations.push( {\n\n\t\t\t\t\tname: clip.name || 'clip_' + outputJSON.animations.length,\n\t\t\t\t\tsamplers: samplers,\n\t\t\t\t\tchannels: channels\n\n\t\t\t\t} );\n\n\t\t\t\treturn outputJSON.animations.length - 1;\n\n\t\t\t}\n\n\t\t\tfunction processSkin( object ) {\n\n\t\t\t\tvar node = outputJSON.nodes[ nodeMap.get( object ) ];\n\n\t\t\t\tvar skeleton = object.skeleton;\n\n\t\t\t\tif ( skeleton === undefined ) return null;\n\n\t\t\t\tvar rootJoint = object.skeleton.bones[ 0 ];\n\n\t\t\t\tif ( rootJoint === undefined ) return null;\n\n\t\t\t\tvar joints = [];\n\t\t\t\tvar inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\n\t\t\t\tfor ( var i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\n\t\t\t\t\tskeleton.boneInverses[ i ].toArray( inverseBindMatrices, i * 16 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( outputJSON.skins === undefined ) {\n\n\t\t\t\t\toutputJSON.skins = [];\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.skins.push( {\n\n\t\t\t\t\tinverseBindMatrices: processAccessor( new THREE.BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\t\t\tjoints: joints,\n\t\t\t\t\tskeleton: nodeMap.get( rootJoint )\n\n\t\t\t\t} );\n\n\t\t\t\tvar skinIndex = node.skin = outputJSON.skins.length - 1;\n\n\t\t\t\treturn skinIndex;\n\n\t\t\t}\n\n\t\t\tfunction processLight( light ) {\n\n\t\t\t\tvar lightDef = {};\n\n\t\t\t\tif ( light.name ) lightDef.name = light.name;\n\n\t\t\t\tlightDef.color = light.color.toArray();\n\n\t\t\t\tlightDef.intensity = light.intensity;\n\n\t\t\t\tif ( light.isDirectionalLight ) {\n\n\t\t\t\t\tlightDef.type = 'directional';\n\n\t\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\t\tlightDef.type = 'point';\n\t\t\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\t\tlightDef.type = 'spot';\n\t\t\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\t\t\t\t\tlightDef.spot = {};\n\t\t\t\t\tlightDef.spot.innerConeAngle = ( light.penumbra - 1.0 ) * light.angle * - 1.0;\n\t\t\t\t\tlightDef.spot.outerConeAngle = light.angle;\n\n\t\t\t\t}\n\n\t\t\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\n\t\t\t\t\t\t+ 'and expects light.decay=2.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( light.target\n\t\t\t\t\t\t&& ( light.target.parent !== light\n\t\t\t\t\t\t || light.target.position.x !== 0\n\t\t\t\t\t\t || light.target.position.y !== 0\n\t\t\t\t\t\t || light.target.position.z !== - 1 ) ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\n\t\t\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\n\n\t\t\t\t}\n\n\t\t\t\tvar lights = outputJSON.extensions[ 'KHR_lights_punctual' ].lights;\n\t\t\t\tlights.push( lightDef );\n\t\t\t\treturn lights.length - 1;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process Object3D node\n\t\t\t * @param  {THREE.Object3D} node Object3D to processNode\n\t\t\t * @return {Integer}      Index of the node in the nodes list\n\t\t\t */\n\t\t\tfunction processNode( object ) {\n\n\t\t\t\tif ( ! outputJSON.nodes ) {\n\n\t\t\t\t\toutputJSON.nodes = [];\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfNode = {};\n\n\t\t\t\tif ( options.trs ) {\n\n\t\t\t\t\tvar rotation = object.quaternion.toArray();\n\t\t\t\t\tvar position = object.position.toArray();\n\t\t\t\t\tvar scale = object.scale.toArray();\n\n\t\t\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\t\t\tgltfNode.rotation = rotation;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\t\t\tgltfNode.translation = position;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\t\t\tgltfNode.scale = scale;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\t\t\tobject.updateMatrix();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! equalArray( object.matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\t\t\tgltfNode.matrix = object.matrix.elements;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\t\t\tif ( object.name !== '' ) {\n\n\t\t\t\t\tgltfNode.name = String( object.name );\n\n\t\t\t\t}\n\n\t\t\t\tserializeUserData( object, gltfNode );\n\n\t\t\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\t\tvar mesh = processMesh( object );\n\n\t\t\t\t\tif ( mesh !== null ) {\n\n\t\t\t\t\t\tgltfNode.mesh = mesh;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isCamera ) {\n\n\t\t\t\t\tgltfNode.camera = processCamera( object );\n\n\t\t\t\t} else if ( object.isDirectionalLight || object.isPointLight || object.isSpotLight ) {\n\n\t\t\t\t\tif ( ! extensionsUsed[ 'KHR_lights_punctual' ] ) {\n\n\t\t\t\t\t\toutputJSON.extensions = outputJSON.extensions || {};\n\t\t\t\t\t\toutputJSON.extensions[ 'KHR_lights_punctual' ] = { lights: [] };\n\t\t\t\t\t\textensionsUsed[ 'KHR_lights_punctual' ] = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgltfNode.extensions = gltfNode.extensions || {};\n\t\t\t\t\tgltfNode.extensions[ 'KHR_lights_punctual' ] = { light: processLight( object ) };\n\n\t\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', object );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\tskins.push( object );\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.children.length > 0 ) {\n\n\t\t\t\t\tvar children = [];\n\n\t\t\t\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar child = object.children[ i ];\n\n\t\t\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\t\t\tvar node = processNode( child );\n\n\t\t\t\t\t\t\tif ( node !== null ) {\n\n\t\t\t\t\t\t\t\tchildren.push( node );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( children.length > 0 ) {\n\n\t\t\t\t\t\tgltfNode.children = children;\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.nodes.push( gltfNode );\n\n\t\t\t\tvar nodeIndex = outputJSON.nodes.length - 1;\n\t\t\t\tnodeMap.set( object, nodeIndex );\n\n\t\t\t\treturn nodeIndex;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process Scene\n\t\t\t * @param  {THREE.Scene} node Scene to process\n\t\t\t */\n\t\t\tfunction processScene( scene ) {\n\n\t\t\t\tif ( ! outputJSON.scenes ) {\n\n\t\t\t\t\toutputJSON.scenes = [];\n\t\t\t\t\toutputJSON.scene = 0;\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfScene = {};\n\n\t\t\t\tif ( scene.name !== '' ) {\n\n\t\t\t\t\tgltfScene.name = scene.name;\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.scenes.push( gltfScene );\n\n\t\t\t\tvar nodes = [];\n\n\t\t\t\tfor ( var i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = scene.children[ i ];\n\n\t\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\t\tvar node = processNode( child );\n\n\t\t\t\t\t\tif ( node !== null ) {\n\n\t\t\t\t\t\t\tnodes.push( node );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodes.length > 0 ) {\n\n\t\t\t\t\tgltfScene.nodes = nodes;\n\n\t\t\t\t}\n\n\t\t\t\tserializeUserData( scene, gltfScene );\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Creates a THREE.Scene to hold a list of objects and parse it\n\t\t\t * @param  {Array} objects List of objects to process\n\t\t\t */\n\t\t\tfunction processObjects( objects ) {\n\n\t\t\t\tvar scene = new THREE.Scene();\n\t\t\t\tscene.name = 'AuxScene';\n\n\t\t\t\tfor ( var i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\t\t\tscene.children.push( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tprocessScene( scene );\n\n\t\t\t}\n\n\t\t\tfunction processInput( input ) {\n\n\t\t\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\t\t\tvar objectsWithoutScene = [];\n\n\t\t\t\tfor ( var i = 0; i < input.length; i ++ ) {\n\n\t\t\t\t\tif ( input[ i ] instanceof THREE.Scene ) {\n\n\t\t\t\t\t\tprocessScene( input[ i ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( objectsWithoutScene.length > 0 ) {\n\n\t\t\t\t\tprocessObjects( objectsWithoutScene );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < skins.length; ++ i ) {\n\n\t\t\t\t\tprocessSkin( skins[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\t\t\tprocessAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprocessInput( input );\n\n\t\t\tPromise.all( pending ).then( function () {\n\n\t\t\t\t// Merge buffers.\n\t\t\t\tvar blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t\t\t// Declare extensions.\n\t\t\t\tvar extensionsUsedList = Object.keys( extensionsUsed );\n\t\t\t\tif ( extensionsUsedList.length > 0 ) outputJSON.extensionsUsed = extensionsUsedList;\n\n\t\t\t\t// Update bytelength of the single buffer.\n\t\t\t\tif ( outputJSON.buffers && outputJSON.buffers.length > 0 ) outputJSON.buffers[ 0 ].byteLength = blob.size;\n\n\t\t\t\tif ( options.binary === true ) {\n\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\t\t\tvar GLB_HEADER_BYTES = 12;\n\t\t\t\t\tvar GLB_HEADER_MAGIC = 0x46546C67;\n\t\t\t\t\tvar GLB_VERSION = 2;\n\n\t\t\t\t\tvar GLB_CHUNK_PREFIX_BYTES = 8;\n\t\t\t\t\tvar GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\n\t\t\t\t\tvar GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n\t\t\t\t\tvar reader = new window.FileReader();\n\t\t\t\t\treader.readAsArrayBuffer( blob );\n\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\t// Binary chunk.\n\t\t\t\t\t\tvar binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\t\t\tvar binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t\t\t// JSON chunk.\n\t\t\t\t\t\tvar jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( outputJSON ) ), 0x20 );\n\t\t\t\t\t\tvar jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t\t\t// GLB header.\n\t\t\t\t\t\tvar header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\t\t\tvar headerView = new DataView( header );\n\t\t\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\t\t\tvar totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\t\t\tvar glbBlob = new Blob( [\n\t\t\t\t\t\t\theader,\n\t\t\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\t\t\tjsonChunk,\n\t\t\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\t\t\tbinaryChunk\n\t\t\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\t\t\tvar glbReader = new window.FileReader();\n\t\t\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( outputJSON.buffers && outputJSON.buffers.length > 0 ) {\n\n\t\t\t\t\t\tvar reader = new window.FileReader();\n\t\t\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\t\tvar base64data = reader.result;\n\t\t\t\t\t\t\toutputJSON.buffers[ 0 ].uri = base64data;\n\t\t\t\t\t\t\tonDone( outputJSON );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tonDone( outputJSON );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t};\n\n\tTHREE.GLTFExporter.Utils = {\n\n\t\tinsertKeyframe: function ( track, time ) {\n\n\t\t\tvar tolerance = 0.001; // 1ms\n\t\t\tvar valueSize = track.getValueSize();\n\n\t\t\tvar times = new track.TimeBufferType( track.times.length + 1 );\n\t\t\tvar values = new track.ValueBufferType( track.values.length + valueSize );\n\t\t\tvar interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\n\n\t\t\tvar index;\n\n\t\t\tif ( track.times.length === 0 ) {\n\n\t\t\t\ttimes[ 0 ] = time;\n\n\t\t\t\tfor ( var i = 0; i < valueSize; i ++ ) {\n\n\t\t\t\t\tvalues[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tindex = 0;\n\n\t\t\t} else if ( time < track.times[ 0 ] ) {\n\n\t\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\n\n\t\t\t\ttimes[ 0 ] = time;\n\t\t\t\ttimes.set( track.times, 1 );\n\n\t\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\n\t\t\t\tvalues.set( track.values, valueSize );\n\n\t\t\t\tindex = 0;\n\n\t\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\n\n\t\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\n\n\t\t\t\t\treturn track.times.length - 1;\n\n\t\t\t\t}\n\n\t\t\t\ttimes[ times.length - 1 ] = time;\n\t\t\t\ttimes.set( track.times, 0 );\n\n\t\t\t\tvalues.set( track.values, 0 );\n\t\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\n\n\t\t\t\tindex = times.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < track.times.length; i ++ ) {\n\n\t\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\n\n\t\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\n\n\t\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\n\t\t\t\t\t\ttimes[ i + 1 ] = time;\n\t\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\n\n\t\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\n\t\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\n\t\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\n\n\t\t\t\t\t\tindex = i + 1;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttrack.times = times;\n\t\t\ttrack.values = values;\n\n\t\t\treturn index;\n\n\t\t},\n\n\t\tmergeMorphTargetTracks: function ( clip, root ) {\n\n\t\t\tvar tracks = [];\n\t\t\tvar mergedTracks = {};\n\t\t\tvar sourceTracks = clip.tracks;\n\n\t\t\tfor ( var i = 0; i < sourceTracks.length; ++ i ) {\n\n\t\t\t\tvar sourceTrack = sourceTracks[ i ];\n\t\t\t\tvar sourceTrackBinding = THREE.PropertyBinding.parseTrackName( sourceTrack.name );\n\t\t\t\tvar sourceTrackNode = THREE.PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\n\n\t\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\n\n\t\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n\t\t\t\t\ttracks.push( sourceTrack );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\n\t\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\n\n\t\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\t\t\t// This should never happen, because glTF morph target animations\n\t\t\t\t\t\t// affect all targets already.\n\t\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\n\n\t\t\t\t\tsourceTrack = sourceTrack.clone();\n\t\t\t\t\tsourceTrack.setInterpolation( THREE.InterpolateLinear );\n\n\t\t\t\t}\n\n\t\t\t\tvar targetCount = sourceTrackNode.morphTargetInfluences.length;\n\t\t\t\tvar targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\n\n\t\t\t\tif ( targetIndex === undefined ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\n\n\t\t\t\t}\n\n\t\t\t\tvar mergedTrack;\n\n\t\t\t\t// If this is the first time we've seen this object, create a new\n\t\t\t\t// track to store merged keyframe data for each morph target.\n\t\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\n\n\t\t\t\t\tmergedTrack = sourceTrack.clone();\n\n\t\t\t\t\tvar values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\n\n\t\t\t\t\tfor ( var j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmergedTrack.name = '.morphTargetInfluences';\n\t\t\t\t\tmergedTrack.values = values;\n\n\t\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\n\t\t\t\t\ttracks.push( mergedTrack );\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\n\n\t\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\n\n\t\t\t\t// For every existing keyframe of the merged track, write a (possibly\n\t\t\t\t// interpolated) value from the source track.\n\t\t\t\tfor ( var j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\n\n\t\t\t\t}\n\n\t\t\t\t// For every existing keyframe of the source track, write a (possibly\n\t\t\t\t// new) keyframe to the merged track. Values from the previous loop may\n\t\t\t\t// be written again, but keyframes are de-duplicated.\n\t\t\t\tfor ( var j = 0; j < sourceTrack.times.length; j ++ ) {\n\n\t\t\t\t\tvar keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\n\t\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tclip.tracks = tracks;\n\n\t\t\treturn clip;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.GLTFExporter;\n});\n\ndefine('skylark-threejs-ex/exporters/ColladaExporter',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Garrett Johnson / http://gkjohnson.github.io/\n\t * https://github.com/gkjohnson/collada-exporter-js\n\t *\n\t * Usage:\n\t *  var exporter = new THREE.ColladaExporter();\n\t *\n\t *  var data = exporter.parse(mesh);\n\t *\n\t * Format Definition:\n\t *  https://www.khronos.org/collada/\n\t */\n\n\tTHREE.ColladaExporter = function () {};\n\n\tTHREE.ColladaExporter.prototype = {\n\n\t\tconstructor: THREE.ColladaExporter,\n\n\t\tparse: function ( object, onDone, options ) {\n\n\t\t\toptions = options || {};\n\n\t\t\toptions = Object.assign( {\n\t\t\t\tversion: '1.4.1',\n\t\t\t\tauthor: null,\n\t\t\t\ttextureDirectory: '',\n\t\t\t}, options );\n\n\t\t\tif ( options.textureDirectory !== '' ) {\n\n\t\t\t\toptions.textureDirectory = `${ options.textureDirectory }/`\n\t\t\t\t\t.replace( /\\\\/g, '/' )\n\t\t\t\t\t.replace( /\\/+/g, '/' );\n\n\t\t\t}\n\n\t\t\tvar version = options.version;\n\t\t\tif ( version !== '1.4.1' && version !== '1.5.0' ) {\n\n\t\t\t\tconsole.warn( `ColladaExporter : Version ${ version } not supported for export. Only 1.4.1 and 1.5.0.` );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Convert the urdf xml into a well-formatted, indented format\n\t\t\tfunction format( urdf ) {\n\n\t\t\t\tvar IS_END_TAG = /^<\\//;\n\t\t\t\tvar IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n\t\t\t\tvar HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n\n\t\t\t\tvar pad = ( ch, num ) => ( num > 0 ? ch + pad( ch, num - 1 ) : '' );\n\n\t\t\t\tvar tagnum = 0;\n\t\t\t\treturn urdf\n\t\t\t\t\t.match( /(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g )\n\t\t\t\t\t.map( tag => {\n\n\t\t\t\t\t\tif ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && IS_END_TAG.test( tag ) ) {\n\n\t\t\t\t\t\t\ttagnum --;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar res = `${ pad( '  ', tagnum ) }${ tag }`;\n\n\t\t\t\t\t\tif ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && ! IS_END_TAG.test( tag ) ) {\n\n\t\t\t\t\t\t\ttagnum ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn res;\n\n\t\t\t\t\t} )\n\t\t\t\t\t.join( '\\n' );\n\n\t\t\t}\n\n\t\t\t// Convert an image into a png format for saving\n\t\t\tfunction base64ToBuffer( str ) {\n\n\t\t\t\tvar b = atob( str );\n\t\t\t\tvar buf = new Uint8Array( b.length );\n\n\t\t\t\tfor ( var i = 0, l = buf.length; i < l; i ++ ) {\n\n\t\t\t\t\tbuf[ i ] = b.charCodeAt( i );\n\n\t\t\t\t}\n\n\t\t\t\treturn buf;\n\n\t\t\t}\n\n\t\t\tvar canvas, ctx;\n\t\t\tfunction imageToData( image, ext ) {\n\n\t\t\t\tcanvas = canvas || document.createElement( 'canvas' );\n\t\t\t\tctx = ctx || canvas.getContext( '2d' );\n\n\t\t\t\tcanvas.width = image.naturalWidth;\n\t\t\t\tcanvas.height = image.naturalHeight;\n\n\t\t\t\tctx.drawImage( image, 0, 0 );\n\n\t\t\t\t// Get the base64 encoded data\n\t\t\t\tvar base64data = canvas\n\t\t\t\t\t.toDataURL( `image/${ ext }`, 1 )\n\t\t\t\t\t.replace( /^data:image\\/(png|jpg);base64,/, '' );\n\n\t\t\t\t// Convert to a uint8 array\n\t\t\t\treturn base64ToBuffer( base64data );\n\n\t\t\t}\n\n\t\t\t// gets the attribute array. Generate a new array if the attribute is interleaved\n\t\t\tvar getFuncs = [ 'getX', 'getY', 'getZ', 'getW' ];\n\t\t\tfunction attrBufferToArray( attr ) {\n\n\t\t\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t// use the typed array constructor to save on memory\n\t\t\t\t\tvar arr = new attr.array.constructor( attr.count * attr.itemSize );\n\t\t\t\t\tvar size = attr.itemSize;\n\t\t\t\t\tfor ( var i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tfor ( var j = 0; j < size; j ++ ) {\n\n\t\t\t\t\t\t\tarr[ i * size + j ] = attr[ getFuncs[ j ] ]( i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn arr;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn attr.array;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Returns an array of the same type starting at the `st` index,\n\t\t\t// and `ct` length\n\t\t\tfunction subArray( arr, st, ct ) {\n\n\t\t\t\tif ( Array.isArray( arr ) ) return arr.slice( st, st + ct );\n\t\t\t\telse return new arr.constructor( arr.buffer, st * arr.BYTES_PER_ELEMENT, ct );\n\n\t\t\t}\n\n\t\t\t// Returns the string for a geometry's attribute\n\t\t\tfunction getAttribute( attr, name, params, type ) {\n\n\t\t\t\tvar array = attrBufferToArray( attr );\n\t\t\t\tvar res =\n\t\t\t\t\t\t`<source id=\"${ name }\">` +\n\n\t\t\t\t\t\t`<float_array id=\"${ name }-array\" count=\"${ array.length }\">` +\n\t\t\t\t\t\tarray.join( ' ' ) +\n\t\t\t\t\t\t'</float_array>' +\n\n\t\t\t\t\t\t'<technique_common>' +\n\t\t\t\t\t\t`<accessor source=\"#${ name }-array\" count=\"${ Math.floor( array.length / attr.itemSize ) }\" stride=\"${ attr.itemSize }\">` +\n\n\t\t\t\t\t\tparams.map( n => `<param name=\"${ n }\" type=\"${ type }\" />` ).join( '' ) +\n\n\t\t\t\t\t\t'</accessor>' +\n\t\t\t\t\t\t'</technique_common>' +\n\t\t\t\t\t\t'</source>';\n\n\t\t\t\treturn res;\n\n\t\t\t}\n\n\t\t\t// Returns the string for a node's transform information\n\t\t\tvar transMat;\n\t\t\tfunction getTransform( o ) {\n\n\t\t\t\t// ensure the object's matrix is up to date\n\t\t\t\t// before saving the transform\n\t\t\t\to.updateMatrix();\n\n\t\t\t\ttransMat = transMat || new THREE.Matrix4();\n\t\t\t\ttransMat.copy( o.matrix );\n\t\t\t\ttransMat.transpose();\n\t\t\t\treturn `<matrix>${ transMat.toArray().join( ' ' ) }</matrix>`;\n\n\t\t\t}\n\n\t\t\t// Process the given piece of geometry into the geometry library\n\t\t\t// Returns the mesh id\n\t\t\tfunction processGeometry( g ) {\n\n\t\t\t\tvar info = geometryInfo.get( g );\n\n\t\t\t\tif ( ! info ) {\n\n\t\t\t\t\t// convert the geometry to bufferGeometry if it isn't already\n\t\t\t\t\tvar bufferGeometry = g;\n\t\t\t\t\tif ( bufferGeometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\t\tbufferGeometry = ( new THREE.BufferGeometry() ).fromGeometry( bufferGeometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meshid = `Mesh${ libraryGeometries.length + 1 }`;\n\n\t\t\t\t\tvar indexCount =\n\t\t\t\t\t\tbufferGeometry.index ?\n\t\t\t\t\t\t\tbufferGeometry.index.count * bufferGeometry.index.itemSize :\n\t\t\t\t\t\t\tbufferGeometry.attributes.position.count;\n\n\t\t\t\t\tvar groups =\n\t\t\t\t\t\tbufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ?\n\t\t\t\t\t\t\tbufferGeometry.groups :\n\t\t\t\t\t\t\t[ { start: 0, count: indexCount, materialIndex: 0 } ];\n\n\n\t\t\t\t\tvar gname = g.name ? ` name=\"${ g.name }\"` : '';\n\t\t\t\t\tvar gnode = `<geometry id=\"${ meshid }\"${ gname }><mesh>`;\n\n\t\t\t\t\t// define the geometry node and the vertices for the geometry\n\t\t\t\t\tvar posName = `${ meshid }-position`;\n\t\t\t\t\tvar vertName = `${ meshid }-vertices`;\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.position, posName, [ 'X', 'Y', 'Z' ], 'float' );\n\t\t\t\t\tgnode += `<vertices id=\"${ vertName }\"><input semantic=\"POSITION\" source=\"#${ posName }\" /></vertices>`;\n\n\t\t\t\t\t// NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n\t\t\t\t\t// can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n\t\t\t\t\t// models with attributes that share an offset.\n\t\t\t\t\t// MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n\n\t\t\t\t\t// serialize normals\n\t\t\t\t\tvar triangleInputs = `<input semantic=\"VERTEX\" source=\"#${ vertName }\" offset=\"0\" />`;\n\t\t\t\t\tif ( 'normal' in bufferGeometry.attributes ) {\n\n\t\t\t\t\t\tvar normName = `${ meshid }-normal`;\n\t\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.normal, normName, [ 'X', 'Y', 'Z' ], 'float' );\n\t\t\t\t\t\ttriangleInputs += `<input semantic=\"NORMAL\" source=\"#${ normName }\" offset=\"0\" />`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// serialize uvs\n\t\t\t\t\tif ( 'uv' in bufferGeometry.attributes ) {\n\n\t\t\t\t\t\tvar uvName = `${ meshid }-texcoord`;\n\t\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.uv, uvName, [ 'S', 'T' ], 'float' );\n\t\t\t\t\t\ttriangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${ uvName }\" offset=\"0\" set=\"0\" />`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// serialize colors\n\t\t\t\t\tif ( 'color' in bufferGeometry.attributes ) {\n\n\t\t\t\t\t\tvar colName = `${ meshid }-color`;\n\t\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.color, colName, [ 'X', 'Y', 'Z' ], 'uint8' );\n\t\t\t\t\t\ttriangleInputs += `<input semantic=\"COLOR\" source=\"#${ colName }\" offset=\"0\" />`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar indexArray = null;\n\t\t\t\t\tif ( bufferGeometry.index ) {\n\n\t\t\t\t\t\tindexArray = attrBufferToArray( bufferGeometry.index );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tindexArray = new Array( indexCount );\n\t\t\t\t\t\tfor ( var i = 0, l = indexArray.length; i < l; i ++ ) indexArray[ i ] = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\tvar subarr = subArray( indexArray, group.start, group.count );\n\t\t\t\t\t\tvar polycount = subarr.length / 3;\n\t\t\t\t\t\tgnode += `<triangles material=\"MESH_MATERIAL_${ group.materialIndex }\" count=\"${ polycount }\">`;\n\t\t\t\t\t\tgnode += triangleInputs;\n\n\t\t\t\t\t\tgnode += `<p>${ subarr.join( ' ' ) }</p>`;\n\t\t\t\t\t\tgnode += '</triangles>';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgnode += `</mesh></geometry>`;\n\n\t\t\t\t\tlibraryGeometries.push( gnode );\n\n\t\t\t\t\tinfo = { meshid: meshid, bufferGeometry: bufferGeometry };\n\t\t\t\t\tgeometryInfo.set( g, info );\n\n\t\t\t\t}\n\n\t\t\t\treturn info;\n\n\t\t\t}\n\n\t\t\t// Process the given texture into the image library\n\t\t\t// Returns the image library\n\t\t\tfunction processTexture( tex ) {\n\n\t\t\t\tvar texid = imageMap.get( tex );\n\t\t\t\tif ( texid == null ) {\n\n\t\t\t\t\ttexid = `image-${ libraryImages.length + 1 }`;\n\n\t\t\t\t\tvar ext = 'png';\n\t\t\t\t\tvar name = tex.name || texid;\n\t\t\t\t\tvar imageNode = `<image id=\"${ texid }\" name=\"${ name }\">`;\n\n\t\t\t\t\tif ( version === '1.5.0' ) {\n\n\t\t\t\t\t\timageNode += `<init_from><ref>${ options.textureDirectory }${ name }.${ ext }</ref></init_from>`;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// version image node 1.4.1\n\t\t\t\t\t\timageNode += `<init_from>${ options.textureDirectory }${ name }.${ ext }</init_from>`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\timageNode += '</image>';\n\n\t\t\t\t\tlibraryImages.push( imageNode );\n\t\t\t\t\timageMap.set( tex, texid );\n\t\t\t\t\ttextures.push( {\n\t\t\t\t\t\tdirectory: options.textureDirectory,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\text,\n\t\t\t\t\t\tdata: imageToData( tex.image, ext ),\n\t\t\t\t\t\toriginal: tex\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\treturn texid;\n\n\t\t\t}\n\n\t\t\t// Process the given material into the material and effect libraries\n\t\t\t// Returns the material id\n\t\t\tfunction processMaterial( m ) {\n\n\t\t\t\tvar matid = materialMap.get( m );\n\n\t\t\t\tif ( matid == null ) {\n\n\t\t\t\t\tmatid = `Mat${ libraryEffects.length + 1 }`;\n\n\t\t\t\t\tvar type = 'phong';\n\n\t\t\t\t\tif ( m instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\t\t\t\ttype = 'lambert';\n\n\t\t\t\t\t} else if ( m instanceof THREE.MeshBasicMaterial ) {\n\n\t\t\t\t\t\ttype = 'constant';\n\n\t\t\t\t\t\tif ( m.map !== null ) {\n\n\t\t\t\t\t\t\t// The Collada spec does not support diffuse texture maps with the\n\t\t\t\t\t\t\t// constant shader type.\n\t\t\t\t\t\t\t// mrdoob/three.js#15469\n\t\t\t\t\t\t\tconsole.warn( 'ColladaExporter: Texture maps not supported with MeshBasicMaterial.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar emissive = m.emissive ? m.emissive : new THREE.Color( 0, 0, 0 );\n\t\t\t\t\tvar diffuse = m.color ? m.color : new THREE.Color( 0, 0, 0 );\n\t\t\t\t\tvar specular = m.specular ? m.specular : new THREE.Color( 1, 1, 1 );\n\t\t\t\t\tvar shininess = m.shininess || 0;\n\t\t\t\t\tvar reflectivity = m.reflectivity || 0;\n\n\t\t\t\t\t// Do not export and alpha map for the reasons mentioned in issue (#13792)\n\t\t\t\t\t// in three.js alpha maps are black and white, but collada expects the alpha\n\t\t\t\t\t// channel to specify the transparency\n\t\t\t\t\tvar transparencyNode = '';\n\t\t\t\t\tif ( m.transparent === true ) {\n\n\t\t\t\t\t\ttransparencyNode +=\n\t\t\t\t\t\t\t`<transparent>` +\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t\t\t`<texture texture=\"diffuse-sampler\"></texture>` :\n\t\t\t\t\t\t\t\t\t'<float>1</float>'\n\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t'</transparent>';\n\n\t\t\t\t\t\tif ( m.opacity < 1 ) {\n\n\t\t\t\t\t\t\ttransparencyNode += `<transparency><float>${ m.opacity }</float></transparency>`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar techniqueNode = `<technique sid=\"common\"><${ type }>` +\n\n\t\t\t\t\t\t'<emission>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.emissiveMap ?\n\t\t\t\t\t\t\t\t'<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t\t`<color sid=\"emission\">${ emissive.r } ${ emissive.g } ${ emissive.b } 1</color>`\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t'</emission>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\ttype !== 'constant' ?\n\t\t\t\t\t\t\t\t'<diffuse>' +\n\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t\t\t'<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t\t\t`<color sid=\"diffuse\">${ diffuse.r } ${ diffuse.g } ${ diffuse.b } 1</color>`\n\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t'</diffuse>'\n\t\t\t\t\t\t\t\t: ''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\ttype !== 'constant' ?\n\t\t\t\t\t\t\t\t'<bump>' +\n\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tm.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''\n\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t'</bump>'\n\t\t\t\t\t\t\t\t: ''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\ttype === 'phong' ?\n\t\t\t\t\t\t\t\t`<specular><color sid=\"specular\">${ specular.r } ${ specular.g } ${ specular.b } 1</color></specular>` +\n\n\t\t\t\t\t\t\t'<shininess>' +\n\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tm.specularMap ?\n\t\t\t\t\t\t\t\t\t'<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t\t\t`<float sid=\"shininess\">${ shininess }</float>`\n\t\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t\t'</shininess>'\n\t\t\t\t\t\t\t\t: ''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t`<reflective><color>${ diffuse.r } ${ diffuse.g } ${ diffuse.b } 1</color></reflective>` +\n\n\t\t\t\t\t\t`<reflectivity><float>${ reflectivity }</float></reflectivity>` +\n\n\t\t\t\t\t\ttransparencyNode +\n\n\t\t\t\t\t\t`</${ type }></technique>`;\n\n\t\t\t\t\tvar effectnode =\n\t\t\t\t\t\t`<effect id=\"${ matid }-effect\">` +\n\t\t\t\t\t\t'<profile_COMMON>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t\t'<newparam sid=\"diffuse-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t\t`<init_from>${ processTexture( m.map ) }</init_from>` +\n\t\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t\t'<newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.specularMap ?\n\t\t\t\t\t\t\t\t'<newparam sid=\"specular-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t\t`<init_from>${ processTexture( m.specularMap ) }</init_from>` +\n\t\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t\t'<newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.emissiveMap ?\n\t\t\t\t\t\t\t\t'<newparam sid=\"emissive-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t\t`<init_from>${ processTexture( m.emissiveMap ) }</init_from>` +\n\t\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t\t'<newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.normalMap ?\n\t\t\t\t\t\t\t\t'<newparam sid=\"bump-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t\t`<init_from>${ processTexture( m.normalMap ) }</init_from>` +\n\t\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t\t'<newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\ttechniqueNode +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.side === THREE.DoubleSide ?\n\t\t\t\t\t\t\t\t`<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>` :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t'</profile_COMMON>' +\n\n\t\t\t\t\t\t'</effect>';\n\n\t\t\t\t\tvar materialName = m.name ? ` name=\"${ m.name }\"` : '';\n\t\t\t\t\tvar materialNode = `<material id=\"${ matid }\"${ materialName }><instance_effect url=\"#${ matid }-effect\" /></material>`;\n\n\t\t\t\t\tlibraryMaterials.push( materialNode );\n\t\t\t\t\tlibraryEffects.push( effectnode );\n\t\t\t\t\tmaterialMap.set( m, matid );\n\n\t\t\t\t}\n\n\t\t\t\treturn matid;\n\n\t\t\t}\n\n\t\t\t// Recursively process the object into a scene\n\t\t\tfunction processObject( o ) {\n\n\t\t\t\tvar node = `<node name=\"${ o.name }\">`;\n\n\t\t\t\tnode += getTransform( o );\n\n\t\t\t\tif ( o instanceof THREE.Mesh && o.geometry != null ) {\n\n\t\t\t\t\t// function returns the id associated with the mesh and a \"BufferGeometry\" version\n\t\t\t\t\t// of the geometry in case it's not a geometry.\n\t\t\t\t\tvar geomInfo = processGeometry( o.geometry );\n\t\t\t\t\tvar meshid = geomInfo.meshid;\n\t\t\t\t\tvar geometry = geomInfo.bufferGeometry;\n\n\t\t\t\t\t// ids of the materials to bind to the geometry\n\t\t\t\t\tvar matids = null;\n\t\t\t\t\tvar matidsArray = [];\n\n\t\t\t\t\t// get a list of materials to bind to the sub groups of the geometry.\n\t\t\t\t\t// If the amount of subgroups is greater than the materials, than reuse\n\t\t\t\t\t// the materials.\n\t\t\t\t\tvar mat = o.material || new THREE.MeshBasicMaterial();\n\t\t\t\t\tvar materials = Array.isArray( mat ) ? mat : [ mat ];\n\n\t\t\t\t\tif ( geometry.groups.length > materials.length ) {\n\n\t\t\t\t\t\tmatidsArray = new Array( geometry.groups.length );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmatidsArray = new Array( materials.length );\n\n\t\t\t\t\t}\n\t\t\t\t\tmatids = matidsArray.fill()\n\t\t\t\t\t\t.map( ( v, i ) => processMaterial( materials[ i % materials.length ] ) );\n\n\t\t\t\t\tnode +=\n\t\t\t\t\t\t`<instance_geometry url=\"#${ meshid }\">` +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tmatids != null ?\n\t\t\t\t\t\t\t\t'<bind_material><technique_common>' +\n\t\t\t\t\t\t\t\tmatids.map( ( id, i ) =>\n\n\t\t\t\t\t\t\t\t\t`<instance_material symbol=\"MESH_MATERIAL_${ i }\" target=\"#${ id }\" >` +\n\n\t\t\t\t\t\t\t\t\t'<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" />' +\n\n\t\t\t\t\t\t\t\t\t'</instance_material>'\n\t\t\t\t\t\t\t\t).join( '' ) +\n\t\t\t\t\t\t\t\t'</technique_common></bind_material>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t'</instance_geometry>';\n\n\t\t\t\t}\n\n\t\t\t\to.children.forEach( c => node += processObject( c ) );\n\n\t\t\t\tnode += '</node>';\n\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t\tvar geometryInfo = new WeakMap();\n\t\t\tvar materialMap = new WeakMap();\n\t\t\tvar imageMap = new WeakMap();\n\t\t\tvar textures = [];\n\n\t\t\tvar libraryImages = [];\n\t\t\tvar libraryGeometries = [];\n\t\t\tvar libraryEffects = [];\n\t\t\tvar libraryMaterials = [];\n\t\t\tvar libraryVisualScenes = processObject( object );\n\n\t\t\tvar specLink = version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n\t\t\tvar dae =\n\t\t\t\t'<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>' +\n\t\t\t\t`<COLLADA xmlns=\"${ specLink }\" version=\"${ version }\">` +\n\t\t\t\t'<asset>' +\n\t\t\t\t(\n\t\t\t\t\t'<contributor>' +\n\t\t\t\t\t'<authoring_tool>three.js Collada Exporter</authoring_tool>' +\n\t\t\t\t\t( options.author !== null ? `<author>${ options.author }</author>` : '' ) +\n\t\t\t\t\t'</contributor>' +\n\t\t\t\t\t`<created>${ ( new Date() ).toISOString() }</created>` +\n\t\t\t\t\t`<modified>${ ( new Date() ).toISOString() }</modified>` +\n\t\t\t\t\t'<up_axis>Y_UP</up_axis>'\n\t\t\t\t) +\n\t\t\t\t'</asset>';\n\n\t\t\tdae += `<library_images>${ libraryImages.join( '' ) }</library_images>`;\n\n\t\t\tdae += `<library_effects>${ libraryEffects.join( '' ) }</library_effects>`;\n\n\t\t\tdae += `<library_materials>${ libraryMaterials.join( '' ) }</library_materials>`;\n\n\t\t\tdae += `<library_geometries>${ libraryGeometries.join( '' ) }</library_geometries>`;\n\n\t\t\tdae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${ libraryVisualScenes }</visual_scene></library_visual_scenes>`;\n\n\t\t\tdae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n\n\t\t\tdae += '</COLLADA>';\n\n\t\t\tvar res = {\n\t\t\t\tdata: format( dae ),\n\t\t\t\ttextures\n\t\t\t};\n\n\t\t\tif ( typeof onDone === 'function' ) {\n\n\t\t\t\trequestAnimationFrame( () => onDone( res ) );\n\n\t\t\t}\n\n\t\t\treturn res;\n\n\t\t}\n\n\t};\n\n\treturn THREE.ColladaExporter;\n});\n\ndefine('skylark-threejs-ex/exporters/PLYExporter',[\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Garrett Johnson / http://gkjohnson.github.io/\n\t * https://github.com/gkjohnson/ply-exporter-js\n\t *\n\t * Usage:\n\t *  var exporter = new THREE.PLYExporter();\n\t *\n\t *  // second argument is a list of options\n\t *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\n\t *\n\t * Format Definition:\n\t * http://paulbourke.net/dataformats/ply/\n\t */\n\n\tTHREE.PLYExporter = function () {};\n\n\tTHREE.PLYExporter.prototype = {\n\n\t\tconstructor: THREE.PLYExporter,\n\n\t\tparse: function ( object, onDone, options ) {\n\n\t\t\tif ( onDone && typeof onDone === 'object' ) {\n\n\t\t\t\tconsole.warn( 'THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.' );\n\t\t\t\toptions = onDone;\n\t\t\t\tonDone = undefined;\n\n\t\t\t}\n\n\t\t\t// Iterate over the valid meshes in the object\n\t\t\tfunction traverseMeshes( cb ) {\n\n\t\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\t\t\tvar mesh = child;\n\t\t\t\t\t\tvar geometry = mesh.geometry;\n\n\t\t\t\t\t\tif ( geometry.isGeometry === true ) {\n\n\t\t\t\t\t\t\tgeometry = geomToBufferGeom.get( geometry );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( geometry.isBufferGeometry === true ) {\n\n\t\t\t\t\t\t\tif ( geometry.getAttribute( 'position' ) !== undefined ) {\n\n\t\t\t\t\t\t\t\tcb( mesh, geometry );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// Default options\n\t\t\tvar defaultOptions = {\n\t\t\t\tbinary: false,\n\t\t\t\texcludeAttributes: [], // normal, uv, color, index\n\t\t\t\tlittleEndian: false\n\t\t\t};\n\n\t\t\toptions = Object.assign( defaultOptions, options );\n\n\t\t\tvar excludeAttributes = options.excludeAttributes;\n\t\t\tvar geomToBufferGeom = new WeakMap();\n\t\t\tvar includeNormals = false;\n\t\t\tvar includeColors = false;\n\t\t\tvar includeUVs = false;\n\n\t\t\t// count the vertices, check which properties are used,\n\t\t\t// and cache the BufferGeometry\n\t\t\tvar vertexCount = 0;\n\t\t\tvar faceCount = 0;\n\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\t\tvar mesh = child;\n\t\t\t\t\tvar geometry = mesh.geometry;\n\n\t\t\t\t\tif ( geometry.isGeometry === true ) {\n\n\t\t\t\t\t\tvar bufferGeometry = geomToBufferGeom.get( geometry ) || new THREE.BufferGeometry().setFromObject( mesh );\n\t\t\t\t\t\tgeomToBufferGeom.set( geometry, bufferGeometry );\n\t\t\t\t\t\tgeometry = bufferGeometry;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.isBufferGeometry === true ) {\n\n\t\t\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\t\t\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\n\t\t\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\n\t\t\t\t\t\tvar colors = geometry.getAttribute( 'color' );\n\t\t\t\t\t\tvar indices = geometry.getIndex();\n\n\t\t\t\t\t\tif ( vertices === undefined ) {\n\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvertexCount += vertices.count;\n\t\t\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\n\t\t\t\t\t\tif ( normals !== undefined ) includeNormals = true;\n\n\t\t\t\t\t\tif ( uvs !== undefined ) includeUVs = true;\n\n\t\t\t\t\t\tif ( colors !== undefined ) includeColors = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tvar includeIndices = excludeAttributes.indexOf( 'index' ) === - 1;\n\t\t\tincludeNormals = includeNormals && excludeAttributes.indexOf( 'normal' ) === - 1;\n\t\t\tincludeColors = includeColors && excludeAttributes.indexOf( 'color' ) === - 1;\n\t\t\tincludeUVs = includeUVs && excludeAttributes.indexOf( 'uv' ) === - 1;\n\n\n\t\t\tif ( includeIndices && faceCount !== Math.floor( faceCount ) ) {\n\n\t\t\t\t// point cloud meshes will not have an index array and may not have a\n\t\t\t\t// number of vertices that is divisble by 3 (and therefore representable\n\t\t\t\t// as triangles)\n\t\t\t\tconsole.error(\n\n\t\t\t\t\t'PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' +\n\t\t\t\t\t'number of indices is not divisible by 3.'\n\n\t\t\t\t);\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar indexByteCount = 4;\n\n\t\t\tvar header =\n\t\t\t\t'ply\\n' +\n\t\t\t\t`format ${ options.binary ? ( options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' ) : 'ascii' } 1.0\\n` +\n\t\t\t\t`element vertex ${vertexCount}\\n` +\n\n\t\t\t\t// position\n\t\t\t\t'property float x\\n' +\n\t\t\t\t'property float y\\n' +\n\t\t\t\t'property float z\\n';\n\n\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t// normal\n\t\t\t\theader +=\n\t\t\t\t\t'property float nx\\n' +\n\t\t\t\t\t'property float ny\\n' +\n\t\t\t\t\t'property float nz\\n';\n\n\t\t\t}\n\n\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t// uvs\n\t\t\t\theader +=\n\t\t\t\t\t'property float s\\n' +\n\t\t\t\t\t'property float t\\n';\n\n\t\t\t}\n\n\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t// colors\n\t\t\t\theader +=\n\t\t\t\t\t'property uchar red\\n' +\n\t\t\t\t\t'property uchar green\\n' +\n\t\t\t\t\t'property uchar blue\\n';\n\n\t\t\t}\n\n\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t// faces\n\t\t\t\theader +=\n\t\t\t\t\t`element face ${faceCount}\\n` +\n\t\t\t\t\t`property list uchar int vertex_index\\n`;\n\n\t\t\t}\n\n\t\t\theader += 'end_header\\n';\n\n\n\t\t\t// Generate attribute data\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\t\t\tvar result = null;\n\n\t\t\tif ( options.binary === true ) {\n\n\t\t\t\t// Binary File Generation\n\t\t\t\tvar headerBin = new TextEncoder().encode( header );\n\n\t\t\t\t// 3 position values at 4 bytes\n\t\t\t\t// 3 normal values at 4 bytes\n\t\t\t\t// 3 color channels with 1 byte\n\t\t\t\t// 2 uv values at 4 bytes\n\t\t\t\tvar vertexListLength = vertexCount * ( 4 * 3 + ( includeNormals ? 4 * 3 : 0 ) + ( includeColors ? 3 : 0 ) + ( includeUVs ? 4 * 2 : 0 ) );\n\n\t\t\t\t// 1 byte shape desciptor\n\t\t\t\t// 3 vertex indices at ${indexByteCount} bytes\n\t\t\t\tvar faceListLength = includeIndices ? faceCount * ( indexByteCount * 3 + 1 ) : 0;\n\t\t\t\tvar output = new DataView( new ArrayBuffer( headerBin.length + vertexListLength + faceListLength ) );\n\t\t\t\tnew Uint8Array( output.buffer ).set( headerBin, 0 );\n\n\n\t\t\t\tvar vOffset = headerBin.length;\n\t\t\t\tvar fOffset = headerBin.length + vertexListLength;\n\t\t\t\tvar writtenVertices = 0;\n\t\t\t\ttraverseMeshes( function ( mesh, geometry ) {\n\n\t\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\t\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\n\t\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\n\t\t\t\t\tvar colors = geometry.getAttribute( 'color' );\n\t\t\t\t\tvar indices = geometry.getIndex();\n\n\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\n\t\t\t\t\t\t// Position information\n\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.x, options.littleEndian );\n\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.y, options.littleEndian );\n\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.z, options.littleEndian );\n\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t// Normal information\n\t\t\t\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t\t\t\tif ( normals != null ) {\n\n\t\t\t\t\t\t\t\tvertex.x = normals.getX( i );\n\t\t\t\t\t\t\t\tvertex.y = normals.getY( i );\n\t\t\t\t\t\t\t\tvertex.z = normals.getZ( i );\n\n\t\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.x, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.y, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.z, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// UV information\n\t\t\t\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t\t\t\tif ( uvs != null ) {\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getX( i ), options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getY( i ), options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t} else if ( includeUVs !== false ) {\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Color information\n\t\t\t\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t\t\t\tif ( colors != null ) {\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getX( i ) * 255 ) );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getY( i ) * 255 ) );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getZ( i ) * 255 ) );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t\t\t// Create the face list\n\n\t\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\n\t\t\t\t\t\t\t\tfOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 0 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 1 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 2 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\n\t\t\t\t\t\t\t\tfOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i + 1, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i + 2, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// Save the amount of verts we've already written so we can offset\n\t\t\t\t\t// the face index on the next mesh\n\t\t\t\t\twrittenVertices += vertices.count;\n\n\t\t\t\t} );\n\n\t\t\t\tresult = output.buffer;\n\n\t\t\t} else {\n\n\t\t\t\t// Ascii File Generation\n\t\t\t\t// count the number of vertices\n\t\t\t\tvar writtenVertices = 0;\n\t\t\t\tvar vertexList = '';\n\t\t\t\tvar faceList = '';\n\n\t\t\t\ttraverseMeshes( function ( mesh, geometry ) {\n\n\t\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\t\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\n\t\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\n\t\t\t\t\tvar colors = geometry.getAttribute( 'color' );\n\t\t\t\t\tvar indices = geometry.getIndex();\n\n\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\t\t// form each line\n\t\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\n\t\t\t\t\t\t// Position information\n\t\t\t\t\t\tvar line =\n\t\t\t\t\t\t\tvertex.x + ' ' +\n\t\t\t\t\t\t\tvertex.y + ' ' +\n\t\t\t\t\t\t\tvertex.z;\n\n\t\t\t\t\t\t// Normal information\n\t\t\t\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t\t\t\tif ( normals != null ) {\n\n\t\t\t\t\t\t\t\tvertex.x = normals.getX( i );\n\t\t\t\t\t\t\t\tvertex.y = normals.getY( i );\n\t\t\t\t\t\t\t\tvertex.z = normals.getZ( i );\n\n\t\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\t\tvertex.x + ' ' +\n\t\t\t\t\t\t\t\t\tvertex.y + ' ' +\n\t\t\t\t\t\t\t\t\tvertex.z;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tline += ' 0 0 0';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// UV information\n\t\t\t\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t\t\t\tif ( uvs != null ) {\n\n\t\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\t\tuvs.getX( i ) + ' ' +\n\t\t\t\t\t\t\t\t\tuvs.getY( i );\n\n\t\t\t\t\t\t\t} else if ( includeUVs !== false ) {\n\n\t\t\t\t\t\t\t\tline += ' 0 0';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Color information\n\t\t\t\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t\t\t\tif ( colors != null ) {\n\n\t\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\t\tMath.floor( colors.getX( i ) * 255 ) + ' ' +\n\t\t\t\t\t\t\t\t\tMath.floor( colors.getY( i ) * 255 ) + ' ' +\n\t\t\t\t\t\t\t\t\tMath.floor( colors.getZ( i ) * 255 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tline += ' 255 255 255';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvertexList += line + '\\n';\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create the face list\n\t\t\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\tfaceList += `3 ${ indices.getX( i + 0 ) + writtenVertices }`;\n\t\t\t\t\t\t\t\tfaceList += ` ${ indices.getX( i + 1 ) + writtenVertices }`;\n\t\t\t\t\t\t\t\tfaceList += ` ${ indices.getX( i + 2 ) + writtenVertices }\\n`;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\tfaceList += `3 ${ writtenVertices + i } ${ writtenVertices + i + 1 } ${ writtenVertices + i + 2 }\\n`;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\twrittenVertices += vertices.count;\n\n\t\t\t\t} );\n\n\t\t\t\tresult = `${ header }${vertexList}${ includeIndices ? `${faceList}\\n` : '\\n' }`;\n\n\t\t\t}\n\n\t\t\tif ( typeof onDone === 'function' ) requestAnimationFrame( () => onDone( result ) );\n\t\t\treturn result;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.PLYExporter;\n});\n\ndefine('skylark-threejs-ex/main',[\r\n\t\"skylark-threejs\",\r\n\r\n\t\"./shaders/CopyShader\",\r\n\t\"./shaders/BokehShader\",\r\n\t\"./shaders/SAOShader\",\r\n\t\"./shaders/DepthLimitedBlurShader\",\r\n\t\"./shaders/UnpackDepthRGBAShader\",\r\n\t\"./shaders/ConvolutionShader\",\r\n\t\"./shaders/LuminosityHighPassShader\",\r\n\t\"./shaders/FXAAShader\",\r\n\t\"./shaders/SSAOShader\",\r\n\t\"./shaders/FilmShader\",\r\n\t\"./shaders/DotScreenShader\",\r\n\t\"./shaders/LuminosityShader\",\r\n\t\"./shaders/SobelOperatorShader\",\r\n\t\"./shaders/ColorifyShader\",\r\n\t\"./shaders/ToneMapShader\",\r\n\t\"./shaders/TechnicolorShader\",\r\n\t\"./shaders/HueSaturationShader\",\r\n\r\n\t\"./postprocessing/EffectComposer\",\r\n\t\"./postprocessing/RenderPass\",\r\n\t\"./postprocessing/ShaderPass\",\r\n\t\"./postprocessing/MaskPass\",\r\n\r\n\t\"./curves/NURBSCurve\",\r\n\t\"./curves/NURBSSurface\",\r\n\t\"./curves/NURBSUtils\",\r\n\r\n\t\"./objects/Lensflare\",\r\n\t\"./objects/Reflector\",\r\n\t\"./objects/Refractor\",\r\n\r\n\t\"./loaders/TTFLoader\",\r\n//\t\"./loaders/LoaderSupport\",\r\n\t\"./loaders/3MFLoader\",\r\n\t\"./loaders/AMFLoader\",\r\n//\t\"./loaders/AssimpJSONLoader\",\r\n\t\"./loaders/AssimpLoader\",\r\n//\t\"./loaders/AWDLoader\",\r\n//\t\"./loaders/BabylonLoader\",\r\n\t\"./loaders/ColladaLoader\",\r\n\t\"./loaders/DRACOLoader\",\r\n\t\"./loaders/FBXLoader\",\r\n\t\"./loaders/GCodeLoader\",\r\n\t\"./loaders/GLTFLoader\",\r\n\t\"./loaders/MTLLoader\",\r\n\t\"./loaders/OBJLoader\",\r\n//\t\"./loaders/OBJLoader2\",\r\n\t\"./loaders/PCDLoader\",\r\n\t\"./loaders/PLYLoader\",\r\n\t\"./loaders/PRWMLoader\",\r\n\t\"./loaders/STLLoader\",\r\n\t\"./loaders/SVGLoader\",\r\n\t\"./loaders/TDSLoader\",\r\n//\t\"./loaders/VRMLLoader\",\r\n\t\"./loaders/VTKLoader\",\r\n\t\"./loaders/XLoader\",\r\n\t\"./loaders/DDSLoader\",\r\n\t\"./loaders/PVRLoader\",\r\n\t\"./loaders/TGALoader\",\r\n\t\"./loaders/KTXLoader\",\r\n\r\n\t\"./modifiers/SimplifyModifier\",\r\n\t\"./modifiers/SubdivisionModifier\",\r\n\r\n\t\"./exporters/DRACOExporter\",\r\n\t\"./exporters/OBJExporter\",\r\n\t\"./exporters/STLExporter\",\r\n\t\"./exporters/GLTFExporter\",\r\n\t\"./exporters/ColladaExporter\",\r\n\t\"./exporters/PLYExporter\"\r\n\r\n],function(THREE){\r\n\treturn THREE;\r\n});\ndefine('skylark-threejs-ex', ['skylark-threejs-ex/main'], function (main) { return main; });\n\n"]}