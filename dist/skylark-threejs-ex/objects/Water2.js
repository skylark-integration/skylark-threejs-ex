/**
 * skylark-threejs-ex - A version of threejs extentions library that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-threejs-ex/
 * @license MIT
 */
define(["skylark-threejs","../threex","../objects/Reflector","../objects/Refractor"],function(e,t,o,r){"use strict";var a=function(t,i){e.Mesh.call(this,t),this.type="Water";var l=this,n=void 0!==(i=i||{}).color?new e.Color(i.color):new e.Color(16777215),f=i.textureWidth||512,c=i.textureHeight||512,v=i.clipBias||0,u=i.flowDirection||new e.Vector2(1,0),m=i.flowSpeed||.03,s=i.reflectivity||.02,p=i.scale||1,d=i.shader||a.WaterShader,g=void 0!==i.encoding?i.encoding:e.LinearEncoding,x=new e.TextureLoader,y=i.flowMap||void 0,h=i.normalMap0||x.load("textures/water/Water_1_M_Normal.jpg"),w=i.normalMap1||x.load("textures/water/Water_2_M_Normal.jpg"),M=.15,_=.5*M,C=new e.Matrix4,R=new e.Clock;if(void 0!==o)if(void 0!==r){var W=new o(t,{textureWidth:f,textureHeight:c,clipBias:v,encoding:g}),D=new r(t,{textureWidth:f,textureHeight:c,clipBias:v,encoding:g});W.matrixAutoUpdate=!1,D.matrixAutoUpdate=!1,this.material=new e.ShaderMaterial({uniforms:e.UniformsUtils.merge([e.UniformsLib.fog,d.uniforms]),vertexShader:d.vertexShader,fragmentShader:d.fragmentShader,transparent:!0,fog:!0}),void 0!==y?(this.material.defines.USE_FLOWMAP="",this.material.uniforms.tFlowMap={type:"t",value:y}):this.material.uniforms.flowDirection={type:"v2",value:u},h.wrapS=h.wrapT=e.RepeatWrapping,w.wrapS=w.wrapT=e.RepeatWrapping,this.material.uniforms.tReflectionMap.value=W.getRenderTarget().texture,this.material.uniforms.tRefractionMap.value=D.getRenderTarget().texture,this.material.uniforms.tNormalMap0.value=h,this.material.uniforms.tNormalMap1.value=w,this.material.uniforms.color.value=n,this.material.uniforms.reflectivity.value=s,this.material.uniforms.textureMatrix.value=C,this.material.uniforms.config.value.x=0,this.material.uniforms.config.value.y=_,this.material.uniforms.config.value.z=_,this.material.uniforms.config.value.w=p,this.onBeforeRender=function(e,t,o){var r,a;!function(e){C.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),C.multiply(e.projectionMatrix),C.multiply(e.matrixWorldInverse),C.multiply(l.matrixWorld)}(o),r=R.getDelta(),(a=l.material.uniforms.config).value.x+=m*r,a.value.y=a.value.x+_,a.value.x>=M?(a.value.x=0,a.value.y=_):a.value.y>=M&&(a.value.y=a.value.y-M),l.visible=!1,W.matrixWorld.copy(l.matrixWorld),D.matrixWorld.copy(l.matrixWorld),W.onBeforeRender(e,t,o),D.onBeforeRender(e,t,o),l.visible=!0}}else console.error("THREE.Water: Required component Refractor not found.");else console.error("THREE.Water: Required component Reflector not found.")};return a.prototype=Object.create(e.Mesh.prototype),a.prototype.constructor=a,a.WaterShader={uniforms:{color:{type:"c",value:null},reflectivity:{type:"f",value:0},tReflectionMap:{type:"t",value:null},tRefractionMap:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},textureMatrix:{type:"m4",value:null},config:{type:"v4",value:new e.Vector4}},vertexShader:["#include <common>","#include <fog_pars_vertex>","#include <logdepthbuf_pars_vertex>","uniform mat4 textureMatrix;","varying vec4 vCoord;","varying vec2 vUv;","varying vec3 vToEye;","void main() {","\tvUv = uv;","\tvCoord = textureMatrix * vec4( position, 1.0 );","\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );","\tvToEye = cameraPosition - worldPosition.xyz;","\tvec4 mvPosition =  viewMatrix * worldPosition;","\tgl_Position = projectionMatrix * mvPosition;","\t#include <logdepthbuf_vertex>","\t#include <fog_vertex>","}"].join("\n"),fragmentShader:["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","uniform sampler2D tReflectionMap;","uniform sampler2D tRefractionMap;","uniform sampler2D tNormalMap0;","uniform sampler2D tNormalMap1;","#ifdef USE_FLOWMAP","\tuniform sampler2D tFlowMap;","#else","\tuniform vec2 flowDirection;","#endif","uniform vec3 color;","uniform float reflectivity;","uniform vec4 config;","varying vec4 vCoord;","varying vec2 vUv;","varying vec3 vToEye;","void main() {","\t#include <logdepthbuf_fragment>","\tfloat flowMapOffset0 = config.x;","\tfloat flowMapOffset1 = config.y;","\tfloat halfCycle = config.z;","\tfloat scale = config.w;","\tvec3 toEye = normalize( vToEye );","\tvec2 flow;","\t#ifdef USE_FLOWMAP","\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;","\t#else","\t\tflow = flowDirection;","\t#endif","\tflow.x *= - 1.0;","\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );","\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );","\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;","\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );","\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );","\tfloat theta = max( dot( toEye, normal ), 0.0 );","\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );","\tvec3 coord = vCoord.xyz / vCoord.w;","\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;","\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );","\tvec4 refractColor = texture2D( tRefractionMap, uv );","\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );","\t#include <tonemapping_fragment>","\t#include <encodings_fragment>","\t#include <fog_fragment>","}"].join("\n")},t.objects.Water2=a});
//# sourceMappingURL=../sourcemaps/objects/Water2.js.map
