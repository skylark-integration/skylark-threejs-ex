/**
 * skylark-threejs-ex - A version of threejs extentions library that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-threejs-ex/
 * @license MIT
 */
define(["skylark-threejs","../threex"],function(e,r){"use strict";var t=function(r,a){e.Mesh.call(this,r),this.type="Reflector";var o=this,n=void 0!==(a=a||{}).color?new e.Color(a.color):new e.Color(8355711),i=a.textureWidth||512,l=a.textureHeight||512,s=a.clipBias||0,c=a.shader||t.ReflectorShader,d=void 0!==a.recursion?a.recursion:0,u=void 0!==a.encoding?a.encoding:e.LinearEncoding,v=new e.Plane,m=new e.Vector3,x=new e.Vector3,f=new e.Vector3,p=new e.Matrix4,b=new e.Vector3(0,0,-1),M=new e.Vector4,g=new e.Vector3,h=new e.Vector3,w=new e.Vector4,y=new e.Matrix4,R=new e.PerspectiveCamera,j={minFilter:e.LinearFilter,magFilter:e.LinearFilter,format:e.RGBFormat,stencilBuffer:!1,encoding:u},U=new e.WebGLRenderTarget(i,l,j);e.MathUtils.isPowerOfTwo(i)&&e.MathUtils.isPowerOfTwo(l)||(U.texture.generateMipmaps=!1);var V=new e.ShaderMaterial({uniforms:e.UniformsUtils.clone(c.uniforms),fragmentShader:c.fragmentShader,vertexShader:c.vertexShader});V.uniforms.tDiffuse.value=U.texture,V.uniforms.color.value=n,V.uniforms.textureMatrix.value=y,this.material=V,this.onBeforeRender=function(e,r,t){if("recursion"in t.userData){if(t.userData.recursion===d)return;t.userData.recursion++}if(x.setFromMatrixPosition(o.matrixWorld),f.setFromMatrixPosition(t.matrixWorld),p.extractRotation(o.matrixWorld),m.set(0,0,1),m.applyMatrix4(p),g.subVectors(x,f),!(g.dot(m)>0)){g.reflect(m).negate(),g.add(x),p.extractRotation(t.matrixWorld),b.set(0,0,-1),b.applyMatrix4(p),b.add(f),h.subVectors(x,b),h.reflect(m).negate(),h.add(x),R.position.copy(g),R.up.set(0,1,0),R.up.applyMatrix4(p),R.up.reflect(m),R.lookAt(h),R.far=t.far,R.updateMatrixWorld(),R.projectionMatrix.copy(t.projectionMatrix),R.userData.recursion=0,y.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),y.multiply(R.projectionMatrix),y.multiply(R.matrixWorldInverse),y.multiply(o.matrixWorld),v.setFromNormalAndCoplanarPoint(m,x),v.applyMatrix4(R.matrixWorldInverse),M.set(v.normal.x,v.normal.y,v.normal.z,v.constant);var a=R.projectionMatrix;w.x=(Math.sign(M.x)+a.elements[8])/a.elements[0],w.y=(Math.sign(M.y)+a.elements[9])/a.elements[5],w.z=-1,w.w=(1+a.elements[10])/a.elements[14],M.multiplyScalar(2/M.dot(w)),a.elements[2]=M.x,a.elements[6]=M.y,a.elements[10]=M.z+1-s,a.elements[14]=M.w,o.visible=!1;var n=e.getRenderTarget(),i=e.xr.enabled,l=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(U),!1===e.autoClear&&e.clear(),e.render(r,R),e.xr.enabled=i,e.shadowMap.autoUpdate=l,e.setRenderTarget(n);var c=t.viewport;void 0!==c&&e.state.viewport(c),o.visible=!0}},this.getRenderTarget=function(){return U}};return t.prototype=Object.create(e.Mesh.prototype),t.prototype.constructor=t,t.ReflectorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:["uniform mat4 textureMatrix;","varying vec4 vUv;","void main() {","\tvUv = textureMatrix * vec4( position, 1.0 );","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec3 color;","uniform sampler2D tDiffuse;","varying vec4 vUv;","float blendOverlay( float base, float blend ) {","\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );","}","vec3 blendOverlay( vec3 base, vec3 blend ) {","\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );","}","void main() {","\tvec4 base = texture2DProj( tDiffuse, vUv );","\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );","}"].join("\n")},r.objects.Reflector=t});
//# sourceMappingURL=../sourcemaps/objects/Reflector.js.map
