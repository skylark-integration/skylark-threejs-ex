/**
 * skylark-threejs-ex - A version of threejs extentions library that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-threejs-ex/
 * @license MIT
 */
define(["skylark-threejs"],function(e){var t={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123,FLOAT:5126,UNSIGNED_INT:5125,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},r={};r[e.NearestFilter]=t.NEAREST,r[e.NearestMipmapNearestFilter]=t.NEAREST_MIPMAP_NEAREST,r[e.NearestMipmapLinearFilter]=t.NEAREST_MIPMAP_LINEAR,r[e.LinearFilter]=t.LINEAR,r[e.LinearMipmapNearestFilter]=t.LINEAR_MIPMAP_NEAREST,r[e.LinearMipmapLinearFilter]=t.LINEAR_MIPMAP_LINEAR,r[e.ClampToEdgeWrapping]=t.CLAMP_TO_EDGE,r[e.RepeatWrapping]=t.REPEAT,r[e.MirroredRepeatWrapping]=t.MIRRORED_REPEAT;var a={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"};return e.GLTFExporter=function(){},e.GLTFExporter.prototype={constructor:e.GLTFExporter,parse:function(n,s,i){var o={binary:!1,trs:!1,onlyVisible:!0,truncateDrawRange:!0,embedImages:!0,maxTextureSize:1/0,animations:[],forceIndices:!1,forcePowerOfTwoTextures:!1,includeCustomExtensions:!1};(i=Object.assign({},o,i)).animations.length>0&&(i.trs=!0);var l,u={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},p=0,f=[],c=[],m=new Map,h=[],g={},d={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map},v=new Map,E=0;function T(e){return v.has(e)||v.set(e,E++),v.get(e)}function y(e,t){return e.length===t.length&&e.every(function(e,r){return e===t[r]})}function b(e){return 4*Math.ceil(e/4)}function x(e,t){t=t||0;var r=b(e.byteLength);if(r!==e.byteLength){var a=new Uint8Array(r);if(a.set(new Uint8Array(e)),0!==t)for(var n=e.byteLength;n<r;n++)a[n]=t;return a.buffer}return e}function R(e,t){if(0!==Object.keys(e.userData).length)try{var r=JSON.parse(JSON.stringify(e.userData));if(i.includeCustomExtensions&&r.gltfExtensions){for(var a in void 0===t.extensions&&(t.extensions={}),r.gltfExtensions)t.extensions[a]=r.gltfExtensions[a],g[a]=!0;delete r.gltfExtensions}Object.keys(r).length>0&&(t.extras=r)}catch(t){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+t.message)}}function w(e,t){var r=!1,a={};0===t.offset.x&&0===t.offset.y||(a.offset=t.offset.toArray(),r=!0),0!==t.rotation&&(a.rotation=t.rotation,r=!0),1===t.repeat.x&&1===t.repeat.y||(a.scale=t.repeat.toArray(),r=!0),r&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=a,g.KHR_texture_transform=!0)}function A(e){return u.buffers||(u.buffers=[{byteLength:0}]),f.push(e),0}function M(e,r,a,n){var s;if(e.array.constructor===Float32Array)s=t.FLOAT;else if(e.array.constructor===Uint32Array)s=t.UNSIGNED_INT;else if(e.array.constructor===Uint16Array)s=t.UNSIGNED_SHORT;else{if(e.array.constructor!==Uint8Array)throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");s=t.UNSIGNED_BYTE}if(void 0===a&&(a=0),void 0===n&&(n=e.count),i.truncateDrawRange&&void 0!==r&&null===r.index){var o=a+n,l=r.drawRange.count===1/0?e.count:r.drawRange.start+r.drawRange.count;a=Math.max(a,r.drawRange.start),(n=Math.min(o,l)-a)<0&&(n=0)}if(0===n)return null;var f,c=function(e,t,r){for(var a={min:new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)},n=t;n<t+r;n++)for(var s=0;s<e.itemSize;s++){var i=e.array[n*e.itemSize+s];a.min[s]=Math.min(a.min[s],i),a.max[s]=Math.max(a.max[s],i)}return a}(e,a,n);void 0!==r&&(f=e===r.index?t.ELEMENT_ARRAY_BUFFER:t.ARRAY_BUFFER);var m=function(e,r,a,n,s){var i;u.bufferViews||(u.bufferViews=[]),i=r===t.UNSIGNED_BYTE?1:r===t.UNSIGNED_SHORT?2:4;for(var o=b(n*e.itemSize*i),l=new DataView(new ArrayBuffer(o)),f=0,c=a;c<a+n;c++)for(var m=0;m<e.itemSize;m++){var h=e.array[c*e.itemSize+m];r===t.FLOAT?l.setFloat32(f,h,!0):r===t.UNSIGNED_INT?l.setUint32(f,h,!0):r===t.UNSIGNED_SHORT?l.setUint16(f,h,!0):r===t.UNSIGNED_BYTE&&l.setUint8(f,h),f+=i}var g={buffer:A(l.buffer),byteOffset:p,byteLength:o};return void 0!==s&&(g.target=s),s===t.ARRAY_BUFFER&&(g.byteStride=e.itemSize*i),p+=o,u.bufferViews.push(g),{id:u.bufferViews.length-1,byteLength:0}}(e,s,a,n,f),h={bufferView:m.id,byteOffset:m.byteOffset,componentType:s,count:n,max:c.max,min:c.min,type:{1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",16:"MAT4"}[e.itemSize]};return u.accessors||(u.accessors=[]),u.accessors.push(h),u.accessors.length-1}function I(t,r,a){d.images.has(t)||d.images.set(t,{});var n=d.images.get(t),s=r===e.RGBAFormat?"image/png":"image/jpeg",o=s+":flipY/"+a.toString();if(void 0!==n[o])return n[o];u.images||(u.images=[]);var f={mimeType:s};if(i.embedImages){var m=l=l||document.createElement("canvas");m.width=Math.min(t.width,i.maxTextureSize),m.height=Math.min(t.height,i.maxTextureSize),i.forcePowerOfTwoTextures&&!function(t){return e.MathUtils.isPowerOfTwo(t.width)&&e.MathUtils.isPowerOfTwo(t.height)}(m)&&(console.warn("GLTFExporter: Resized non-power-of-two image.",t),m.width=e.MathUtils.floorPowerOfTwo(m.width),m.height=e.MathUtils.floorPowerOfTwo(m.height));var h=m.getContext("2d");!0===a&&(h.translate(0,m.height),h.scale(1,-1)),h.drawImage(t,0,0,m.width,m.height),!0===i.binary?c.push(new Promise(function(e){m.toBlob(function(t){(function(e){return u.bufferViews||(u.bufferViews=[]),new Promise(function(t){var r=new window.FileReader;r.readAsArrayBuffer(e),r.onloadend=function(){var e=x(r.result),a={buffer:A(e),byteOffset:p,byteLength:e.byteLength};p+=e.byteLength,u.bufferViews.push(a),t(u.bufferViews.length-1)}})})(t).then(function(t){f.bufferView=t,e()})},s)})):f.uri=m.toDataURL(s)}else f.uri=t.src;u.images.push(f);var g=u.images.length-1;return n[o]=g,g}function L(e){if(d.textures.has(e))return d.textures.get(e);u.textures||(u.textures=[]);var t={sampler:function(e){u.samplers||(u.samplers=[]);var t={magFilter:r[e.magFilter],minFilter:r[e.minFilter],wrapS:r[e.wrapS],wrapT:r[e.wrapT]};return u.samplers.push(t),u.samplers.length-1}(e),source:I(e.image,e.format,e.flipY)};e.name&&(t.name=e.name),u.textures.push(t);var a=u.textures.length-1;return d.textures.set(e,a),a}function N(t){if(d.materials.has(t))return d.materials.get(t);if(t.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;u.materials||(u.materials=[]);var r={pbrMetallicRoughness:{}};t.isMeshBasicMaterial?(r.extensions={KHR_materials_unlit:{}},g.KHR_materials_unlit=!0):t.isGLTFSpecularGlossinessMaterial?(r.extensions={KHR_materials_pbrSpecularGlossiness:{}},g.KHR_materials_pbrSpecularGlossiness=!0):t.isMeshStandardMaterial||console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");var a=t.color.toArray().concat([t.opacity]);if(y(a,[1,1,1,1])||(r.pbrMetallicRoughness.baseColorFactor=a),t.isMeshStandardMaterial?(r.pbrMetallicRoughness.metallicFactor=t.metalness,r.pbrMetallicRoughness.roughnessFactor=t.roughness):t.isMeshBasicMaterial?(r.pbrMetallicRoughness.metallicFactor=0,r.pbrMetallicRoughness.roughnessFactor=.9):(r.pbrMetallicRoughness.metallicFactor=.5,r.pbrMetallicRoughness.roughnessFactor=.5),t.isGLTFSpecularGlossinessMaterial){r.pbrMetallicRoughness.baseColorFactor&&(r.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor=r.pbrMetallicRoughness.baseColorFactor);var n=[1,1,1];t.specular.toArray(n,0),r.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor=n,r.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor=t.glossiness}if(t.metalnessMap||t.roughnessMap)if(t.metalnessMap===t.roughnessMap){var s={index:L(t.metalnessMap)};w(s,t.metalnessMap),r.pbrMetallicRoughness.metallicRoughnessTexture=s}else console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");if(t.map){var i={index:L(t.map)};w(i,t.map),t.isGLTFSpecularGlossinessMaterial&&(r.extensions.KHR_materials_pbrSpecularGlossiness.diffuseTexture=i),r.pbrMetallicRoughness.baseColorTexture=i}if(t.isGLTFSpecularGlossinessMaterial&&t.specularMap){var o={index:L(t.specularMap)};w(o,t.specularMap),r.extensions.KHR_materials_pbrSpecularGlossiness.specularGlossinessTexture=o}if(t.emissive){var l=t.emissive.clone().multiplyScalar(t.emissiveIntensity).toArray();if(y(l,[0,0,0])||(r.emissiveFactor=l),t.emissiveMap){var p={index:L(t.emissiveMap)};w(p,t.emissiveMap),r.emissiveTexture=p}}if(t.normalMap){var f={index:L(t.normalMap)};t.normalScale&&-1!==t.normalScale.x&&(t.normalScale.x!==t.normalScale.y&&console.warn("THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X."),f.scale=t.normalScale.x),w(f,t.normalMap),r.normalTexture=f}if(t.aoMap){var c={index:L(t.aoMap),texCoord:1};1!==t.aoMapIntensity&&(c.strength=t.aoMapIntensity),w(c,t.aoMap),r.occlusionTexture=c}t.transparent?r.alphaMode="BLEND":t.alphaTest>0&&(r.alphaMode="MASK",r.alphaCutoff=t.alphaTest),t.side===e.DoubleSide&&(r.doubleSided=!0),""!==t.name&&(r.name=t.name),R(t,r),u.materials.push(r);var m=u.materials.length-1;return d.materials.set(t,m),m}function S(r){var a=[r.geometry.uuid];if(Array.isArray(r.material))for(var n=0,s=r.material.length;n<s;n++)a.push(r.material[n].uuid);else a.push(r.material.uuid);var o=a.join(":");if(d.meshes.has(o))return d.meshes.get(o);var l,p=r.geometry;l=r.isLineSegments?t.LINES:r.isLineLoop?t.LINE_LOOP:r.isLine?t.LINE_STRIP:r.isPoints?t.POINTS:r.material.wireframe?t.LINES:t.TRIANGLES,p.isBufferGeometry||(console.warn("GLTFExporter: Exporting THREE.Geometry will increase file size. Use THREE.BufferGeometry instead."),p=(new e.BufferGeometry).setFromObject(r));var f={},c={},m=[],h=[],g={uv:"TEXCOORD_0",uv2:"TEXCOORD_1",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},v=p.getAttribute("normal");void 0===v||function(t){if(d.attributesNormalized.has(t))return!1;for(var r=new e.Vector3,a=0,n=t.count;a<n;a++)if(Math.abs(r.fromArray(t.array,3*a).length()-1)>5e-4)return!1;return!0}(v)||(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),p.setAttribute("normal",function(t){if(d.attributesNormalized.has(t))return d.attributesNormalized.get(t);for(var r=t.clone(),a=new e.Vector3,n=0,s=r.count;n<s;n++)a.fromArray(r.array,3*n),0===a.x&&0===a.y&&0===a.z?a.setX(1):a.normalize(),a.toArray(r.array,3*n);return d.attributesNormalized.set(t,r),r}(v)));var E=null;for(var y in p.attributes)if("morph"!==y.substr(0,5)){var b=p.attributes[y];y=g[y]||y.toUpperCase();if(/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(y)||(y="_"+y),d.attributes.has(T(b)))c[y]=d.attributes.get(T(b));else{E=null;var x=b.array;"JOINTS_0"!==y||x instanceof Uint16Array||x instanceof Uint8Array||(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),E=new e.BufferAttribute(new Uint16Array(x),b.itemSize,b.normalized));var w=M(E||b,p);null!==w&&(c[y]=w,d.attributes.set(T(b),w))}}if(void 0!==v&&p.setAttribute("normal",v),0===Object.keys(c).length)return null;if(void 0!==r.morphTargetInfluences&&r.morphTargetInfluences.length>0){var A=[],I=[],L={};if(void 0!==r.morphTargetDictionary)for(var S in r.morphTargetDictionary)L[r.morphTargetDictionary[S]]=S;for(n=0;n<r.morphTargetInfluences.length;++n){var _={},F=!1;for(var y in p.morphAttributes)if("position"===y||"normal"===y){b=p.morphAttributes[y][n];var G=y.toUpperCase(),O=p.attributes[y];if(d.attributes.has(T(b)))_[G]=d.attributes.get(T(b));else{var U=b.clone();if(!p.morphTargetsRelative)for(var P=0,B=b.count;P<B;P++)U.setXYZ(P,b.getX(P)-O.getX(P),b.getY(P)-O.getY(P),b.getZ(P)-O.getZ(P));_[G]=M(U,p),d.attributes.set(T(O),_[G])}}else F||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),F=!0);h.push(_),A.push(r.morphTargetInfluences[n]),void 0!==r.morphTargetDictionary&&I.push(L[n])}f.weights=A,I.length>0&&(f.extras={},f.extras.targetNames=I)}var D=i.forceIndices,H=Array.isArray(r.material);if(H&&0===p.groups.length)return null;!D&&null===p.index&&H&&(console.warn("THREE.GLTFExporter: Creating index for non-indexed multi-material mesh."),D=!0);var C=!1;if(null===p.index&&D){for(var z=[],k=(n=0,p.attributes.position.count);n<k;n++)z[n]=n;p.setIndex(z),C=!0}var V=H?r.material:[r.material],K=H?p.groups:[{materialIndex:0,start:void 0,count:void 0}];for(n=0,k=K.length;n<k;n++){var Y={mode:l,attributes:c};if(R(p,Y),h.length>0&&(Y.targets=h),null!==p.index){var j=T(p.index);void 0===K[n].start&&void 0===K[n].count||(j+=":"+K[n].start+":"+K[n].count),d.attributes.has(j)?Y.indices=d.attributes.get(j):(Y.indices=M(p.index,p,K[n].start,K[n].count),d.attributes.set(j,Y.indices)),null===Y.indices&&delete Y.indices}var X=N(V[K[n].materialIndex]);null!==X&&(Y.material=X),m.push(Y)}C&&p.setIndex(null),f.primitives=m,u.meshes||(u.meshes=[]),u.meshes.push(f);var J=u.meshes.length-1;return d.meshes.set(o,J),J}function _(t,r){u.animations||(u.animations=[]);for(var n=(t=e.GLTFExporter.Utils.mergeMorphTargetTracks(t.clone(),r)).tracks,s=[],i=[],o=0;o<n.length;++o){var l=n[o],p=e.PropertyBinding.parseTrackName(l.name),f=e.PropertyBinding.findNode(r,p.nodeName),c=a[p.propertyName];if("bones"===p.objectName&&(f=!0===f.isSkinnedMesh?f.skeleton.getBoneByName(p.objectIndex):void 0),!f||!c)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',l.name),null;var h,g=l.values.length/l.times.length;c===a.morphTargetInfluences&&(g/=f.morphTargetInfluences.length),!0===l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline?(h="CUBICSPLINE",g/=3):h=l.getInterpolation()===e.InterpolateDiscrete?"STEP":"LINEAR",i.push({input:M(new e.BufferAttribute(l.times,1)),output:M(new e.BufferAttribute(l.values,g)),interpolation:h}),s.push({sampler:i.length-1,target:{node:m.get(f),path:c}})}return u.animations.push({name:t.name||"clip_"+u.animations.length,samplers:i,channels:s}),u.animations.length-1}function F(t){var r=u.nodes[m.get(t)],a=t.skeleton;if(void 0===a)return null;var n=t.skeleton.bones[0];if(void 0===n)return null;for(var s=[],i=new Float32Array(16*a.bones.length),o=0;o<a.bones.length;++o)s.push(m.get(a.bones[o])),a.boneInverses[o].toArray(i,16*o);return void 0===u.skins&&(u.skins=[]),u.skins.push({inverseBindMatrices:M(new e.BufferAttribute(i,16)),joints:s,skeleton:m.get(n)}),r.skin=u.skins.length-1}function G(t){u.nodes||(u.nodes=[]);var r={};if(i.trs){var a=t.quaternion.toArray(),n=t.position.toArray(),s=t.scale.toArray();y(a,[0,0,0,1])||(r.rotation=a),y(n,[0,0,0])||(r.translation=n),y(s,[1,1,1])||(r.scale=s)}else t.matrixAutoUpdate&&t.updateMatrix(),y(t.matrix.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])||(r.matrix=t.matrix.elements);if(""!==t.name&&(r.name=String(t.name)),R(t,r),t.isMesh||t.isLine||t.isPoints){var o=S(t);null!==o&&(r.mesh=o)}else if(t.isCamera)r.camera=function(t){u.cameras||(u.cameras=[]);var r=t.isOrthographicCamera,a={type:r?"orthographic":"perspective"};return r?a.orthographic={xmag:2*t.right,ymag:2*t.top,zfar:t.far<=0?.001:t.far,znear:t.near<0?0:t.near}:a.perspective={aspectRatio:t.aspect,yfov:e.MathUtils.degToRad(t.fov),zfar:t.far<=0?.001:t.far,znear:t.near<0?0:t.near},""!==t.name&&(a.name=t.type),u.cameras.push(a),u.cameras.length-1}(t);else if(t.isDirectionalLight||t.isPointLight||t.isSpotLight)g.KHR_lights_punctual||(u.extensions=u.extensions||{},u.extensions.KHR_lights_punctual={lights:[]},g.KHR_lights_punctual=!0),r.extensions=r.extensions||{},r.extensions.KHR_lights_punctual={light:function(e){var t={};e.name&&(t.name=e.name),t.color=e.color.toArray(),t.intensity=e.intensity,e.isDirectionalLight?t.type="directional":e.isPointLight?(t.type="point",e.distance>0&&(t.range=e.distance)):e.isSpotLight&&(t.type="spot",e.distance>0&&(t.range=e.distance),t.spot={},t.spot.innerConeAngle=(e.penumbra-1)*e.angle*-1,t.spot.outerConeAngle=e.angle),void 0!==e.decay&&2!==e.decay&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),!e.target||e.target.parent===e&&0===e.target.position.x&&0===e.target.position.y&&-1===e.target.position.z||console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.");var r=u.extensions.KHR_lights_punctual.lights;return r.push(t),r.length-1}(t)};else if(t.isLight)return console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",t),null;if(t.isSkinnedMesh&&h.push(t),t.children.length>0){for(var l=[],p=0,f=t.children.length;p<f;p++){var c=t.children[p];if(c.visible||!1===i.onlyVisible){var d=G(c);null!==d&&l.push(d)}}l.length>0&&(r.children=l)}u.nodes.push(r);var v=u.nodes.length-1;return m.set(t,v),v}function O(e){u.scenes||(u.scenes=[],u.scene=0);var t={};""!==e.name&&(t.name=e.name),u.scenes.push(t);for(var r=[],a=0,n=e.children.length;a<n;a++){var s=e.children[a];if(s.visible||!1===i.onlyVisible){var o=G(s);null!==o&&r.push(o)}}r.length>0&&(t.nodes=r),R(e,t)}!function(t){t=t instanceof Array?t:[t];for(var r=[],a=0;a<t.length;a++)t[a]instanceof e.Scene?O(t[a]):r.push(t[a]);for(r.length>0&&function(t){var r=new e.Scene;r.name="AuxScene";for(var a=0;a<t.length;a++)r.children.push(t[a]);O(r)}(r),a=0;a<h.length;++a)F(h[a]);for(a=0;a<i.animations.length;++a)_(i.animations[a],t[0])}(n),Promise.all(c).then(function(){var e=new Blob(f,{type:"application/octet-stream"}),t=Object.keys(g);if(t.length>0&&(u.extensionsUsed=t),u.buffers&&u.buffers.length>0&&(u.buffers[0].byteLength=e.size),!0===i.binary){(r=new window.FileReader).readAsArrayBuffer(e),r.onloadend=function(){var e=x(r.result),t=new DataView(new ArrayBuffer(8));t.setUint32(0,e.byteLength,!0),t.setUint32(4,5130562,!0);var a=x(function(e){if(void 0!==window.TextEncoder)return(new TextEncoder).encode(e).buffer;for(var t=new Uint8Array(new ArrayBuffer(e.length)),r=0,a=e.length;r<a;r++){var n=e.charCodeAt(r);t[r]=n>255?32:n}return t.buffer}(JSON.stringify(u)),32),n=new DataView(new ArrayBuffer(8));n.setUint32(0,a.byteLength,!0),n.setUint32(4,1313821514,!0);var i=new ArrayBuffer(12),o=new DataView(i);o.setUint32(0,1179937895,!0),o.setUint32(4,2,!0);var l=12+n.byteLength+a.byteLength+t.byteLength+e.byteLength;o.setUint32(8,l,!0);var p=new Blob([i,n,a,t,e],{type:"application/octet-stream"}),f=new window.FileReader;f.readAsArrayBuffer(p),f.onloadend=function(){s(f.result)}}}else{var r;if(u.buffers&&u.buffers.length>0)(r=new window.FileReader).readAsDataURL(e),r.onloadend=function(){var e=r.result;u.buffers[0].uri=e,s(u)};else s(u)}})}},e.GLTFExporter.Utils={insertKeyframe:function(e,t){var r,a=e.getValueSize(),n=new e.TimeBufferType(e.times.length+1),s=new e.ValueBufferType(e.values.length+a),i=e.createInterpolant(new e.ValueBufferType(a));if(0===e.times.length){n[0]=t;for(var o=0;o<a;o++)s[o]=0;r=0}else if(t<e.times[0]){if(Math.abs(e.times[0]-t)<.001)return 0;n[0]=t,n.set(e.times,1),s.set(i.evaluate(t),0),s.set(e.values,a),r=0}else if(t>e.times[e.times.length-1]){if(Math.abs(e.times[e.times.length-1]-t)<.001)return e.times.length-1;n[n.length-1]=t,n.set(e.times,0),s.set(e.values,0),s.set(i.evaluate(t),e.values.length),r=n.length-1}else for(o=0;o<e.times.length;o++){if(Math.abs(e.times[o]-t)<.001)return o;if(e.times[o]<t&&e.times[o+1]>t){n.set(e.times.slice(0,o+1),0),n[o+1]=t,n.set(e.times.slice(o+1),o+2),s.set(e.values.slice(0,(o+1)*a),0),s.set(i.evaluate(t),(o+1)*a),s.set(e.values.slice((o+1)*a),(o+2)*a),r=o+1;break}}return e.times=n,e.values=s,r},mergeMorphTargetTracks:function(t,r){for(var a=[],n={},s=t.tracks,i=0;i<s.length;++i){var o=s[i],l=e.PropertyBinding.parseTrackName(o.name),u=e.PropertyBinding.findNode(r,l.nodeName);if("morphTargetInfluences"===l.propertyName&&void 0!==l.propertyIndex){if(o.createInterpolant!==o.InterpolantFactoryMethodDiscrete&&o.createInterpolant!==o.InterpolantFactoryMethodLinear){if(o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),(o=o.clone()).setInterpolation(e.InterpolateLinear)}var p,f=u.morphTargetInfluences.length,c=u.morphTargetDictionary[l.propertyIndex];if(void 0===c)throw new Error("THREE.GLTFExporter: Morph target name not found: "+l.propertyIndex);if(void 0!==n[u.uuid]){var m=o.createInterpolant(new o.ValueBufferType(1));p=n[u.uuid];for(d=0;d<p.times.length;d++)p.values[d*f+c]=m.evaluate(p.times[d]);for(d=0;d<o.times.length;d++){var h=this.insertKeyframe(p,o.times[d]);p.values[h*f+c]=o.values[d]}}else{for(var g=new((p=o.clone()).ValueBufferType)(f*p.times.length),d=0;d<p.times.length;d++)g[d*f+c]=p.values[d];p.name=".morphTargetInfluences",p.values=g,n[u.uuid]=p,a.push(p)}}else a.push(o)}return t.tracks=a,t}},e.GLTFExporter});
//# sourceMappingURL=../sourcemaps/exporters/GLTFExporter.js.map
