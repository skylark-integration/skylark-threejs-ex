/**
 * skylark-threejs-ex - A version of threejs extentions library that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-threejs-ex/
 * @license MIT
 */
define(["skylark-threejs"],function(e){"use strict";var r=function(){};return r.prototype={constructor:r,parse:function(r,t,a){a=a||{},""!==(a=Object.assign({version:"1.4.1",author:null,textureDirectory:""},a)).textureDirectory&&(a.textureDirectory=`${a.textureDirectory}/`.replace(/\\/g,"/").replace(/\/+/g,"/"));var i,n,s=a.version;if("1.4.1"!==s&&"1.5.0"!==s)return console.warn(`ColladaExporter : Version ${s} not supported for export. Only 1.4.1 and 1.5.0.`),null;function o(e,r){return i=i||document.createElement("canvas"),n=n||i.getContext("2d"),i.width=e.naturalWidth,i.height=e.naturalHeight,n.drawImage(e,0,0),function(e){for(var r=atob(e),t=new Uint8Array(r.length),a=0,i=t.length;a<i;a++)t[a]=r.charCodeAt(a);return t}(i.toDataURL(`image/${r}`,1).replace(/^data:image\/(png|jpg);base64,/,""))}var u,c=["getX","getY","getZ","getW"];function l(e){if(e.isInterleavedBufferAttribute){for(var r=new e.array.constructor(e.count*e.itemSize),t=e.itemSize,a=0,i=e.count;a<i;a++)for(var n=0;n<t;n++)r[a*t+n]=e[c[n]](a);return r}return e.array}function m(e,r,t,a){var i=l(e);return`<source id="${r}">`+`<float_array id="${r}-array" count="${i.length}">`+i.join(" ")+"</float_array><technique_common>"+`<accessor source="#${r}-array" count="${Math.floor(i.length/e.itemSize)}" stride="${e.itemSize}">`+t.map(e=>`<param name="${e}" type="${a}" />`).join("")+"</accessor></technique_common></source>"}function p(e){var r=$.get(e);if(null==r){r=`image-${h.length+1}`;var t=e.name||r,i=`<image id="${r}" name="${t}">`;i+="1.5.0"===s?`<init_from><ref>${a.textureDirectory}${t}.png</ref></init_from>`:`<init_from>${a.textureDirectory}${t}.png</init_from>`,i+="</image>",h.push(i),$.set(e,r),g.push({directory:a.textureDirectory,name:t,ext:"png",data:o(e.image,"png"),original:e})}return r}var f=new WeakMap,d=new WeakMap,$=new WeakMap,g=[],h=[],y=[],_=[],v=[],x=function r(t){var a=`<node name="${t.name}">`;if(a+=function(r){return r.updateMatrix(),(u=u||new e.Matrix4).copy(r.matrix),u.transpose(),`<matrix>${u.toArray().join(" ")}</matrix>`}(t),t instanceof e.Mesh&&null!=t.geometry){var i=function(r){var t,a,i,n=f.get(r);if(!n){var s=r;s instanceof e.Geometry&&(s=(new e.BufferGeometry).fromGeometry(s));var o=`Mesh${y.length+1}`,u=s.index?s.index.count*s.index.itemSize:s.attributes.position.count,c=null!=s.groups&&0!==s.groups.length?s.groups:[{start:0,count:u,materialIndex:0}],p=`<geometry id="${o}"${r.name?` name="${r.name}"`:""}><mesh>`,d=`${o}-position`,$=`${o}-vertices`;p+=m(s.attributes.position,d,["X","Y","Z"],"float"),p+=`<vertices id="${$}"><input semantic="POSITION" source="#${d}" /></vertices>`;var g=`<input semantic="VERTEX" source="#${$}" offset="0" />`;if("normal"in s.attributes){var h=`${o}-normal`;p+=m(s.attributes.normal,h,["X","Y","Z"],"float"),g+=`<input semantic="NORMAL" source="#${h}" offset="0" />`}if("uv"in s.attributes){var _=`${o}-texcoord`;p+=m(s.attributes.uv,_,["S","T"],"float"),g+=`<input semantic="TEXCOORD" source="#${_}" offset="0" set="0" />`}if("color"in s.attributes){var v=`${o}-color`;p+=m(s.attributes.color,v,["X","Y","Z"],"uint8"),g+=`<input semantic="COLOR" source="#${v}" offset="0" />`}var x=null;if(s.index)x=l(s.index);else for(var b=0,w=(x=new Array(u)).length;b<w;b++)x[b]=b;for(b=0,w=c.length;b<w;b++){var M=c[b],D=(t=x,a=M.start,i=M.count,Array.isArray(t)?t.slice(a,a+i):new t.constructor(t.buffer,a*t.BYTES_PER_ELEMENT,i)),O=D.length/3;p+=`<triangles material="MESH_MATERIAL_${M.materialIndex}" count="${O}">`,p+=g,p+=`<p>${D.join(" ")}</p>`,p+="</triangles>"}p+="</mesh></geometry>",y.push(p),n={meshid:o,bufferGeometry:s},f.set(r,n)}return n}(t.geometry),n=i.meshid,s=i.bufferGeometry,o=null,c=t.material||new e.MeshBasicMaterial,$=Array.isArray(c)?c:[c];o=(s.groups.length>$.length?new Array(s.groups.length):new Array($.length)).fill().map((r,t)=>(function(r){var t=d.get(r);if(null==t){t=`Mat${_.length+1}`;var a="phong";r instanceof e.MeshLambertMaterial?a="lambert":r instanceof e.MeshBasicMaterial&&(a="constant",null!==r.map&&console.warn("ColladaExporter: Texture maps not supported with MeshBasicMaterial."));var i=r.emissive?r.emissive:new e.Color(0,0,0),n=r.color?r.color:new e.Color(0,0,0),s=r.specular?r.specular:new e.Color(1,1,1),o=r.shininess||0,u=r.reflectivity||0,c="";!0===r.transparent&&(c+="<transparent>"+(r.map?'<texture texture="diffuse-sampler"></texture>':"<float>1</float>")+"</transparent>",r.opacity<1&&(c+=`<transparency><float>${r.opacity}</float></transparency>`));var l=`<technique sid="common"><${a}>`+"<emission>"+(r.emissiveMap?'<texture texture="emissive-sampler" texcoord="TEXCOORD" />':`<color sid="emission">${i.r} ${i.g} ${i.b} 1</color>`)+"</emission>"+("constant"!==a?"<diffuse>"+(r.map?'<texture texture="diffuse-sampler" texcoord="TEXCOORD" />':`<color sid="diffuse">${n.r} ${n.g} ${n.b} 1</color>`)+"</diffuse>":"")+("constant"!==a?"<bump>"+(r.normalMap?'<texture texture="bump-sampler" texcoord="TEXCOORD" />':"")+"</bump>":"")+("phong"===a?`<specular><color sid="specular">${s.r} ${s.g} ${s.b} 1</color></specular>`+"<shininess>"+(r.specularMap?'<texture texture="specular-sampler" texcoord="TEXCOORD" />':`<float sid="shininess">${o}</float>`)+"</shininess>":"")+`<reflective><color>${n.r} ${n.g} ${n.b} 1</color></reflective>`+`<reflectivity><float>${u}</float></reflectivity>`+c+`</${a}></technique>`,m=`<effect id="${t}-effect">`+"<profile_COMMON>"+(r.map?'<newparam sid="diffuse-surface"><surface type="2D">'+`<init_from>${p(r.map)}</init_from>`+'</surface></newparam><newparam sid="diffuse-sampler"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>':"")+(r.specularMap?'<newparam sid="specular-surface"><surface type="2D">'+`<init_from>${p(r.specularMap)}</init_from>`+'</surface></newparam><newparam sid="specular-sampler"><sampler2D><source>specular-surface</source></sampler2D></newparam>':"")+(r.emissiveMap?'<newparam sid="emissive-surface"><surface type="2D">'+`<init_from>${p(r.emissiveMap)}</init_from>`+'</surface></newparam><newparam sid="emissive-sampler"><sampler2D><source>emissive-surface</source></sampler2D></newparam>':"")+(r.normalMap?'<newparam sid="bump-surface"><surface type="2D">'+`<init_from>${p(r.normalMap)}</init_from>`+'</surface></newparam><newparam sid="bump-sampler"><sampler2D><source>bump-surface</source></sampler2D></newparam>':"")+l+(r.side===e.DoubleSide?'<extra><technique profile="THREEJS"><double_sided sid="double_sided" type="int">1</double_sided></technique></extra>':"")+"</profile_COMMON></effect>",f=`<material id="${t}"${r.name?` name="${r.name}"`:""}><instance_effect url="#${t}-effect" /></material>`;v.push(f),_.push(m),d.set(r,t)}return t})($[t%$.length])),a+=`<instance_geometry url="#${n}">`+(null!=o?"<bind_material><technique_common>"+o.map((e,r)=>`<instance_material symbol="MESH_MATERIAL_${r}" target="#${e}" >`+'<bind_vertex_input semantic="TEXCOORD" input_semantic="TEXCOORD" input_set="0" /></instance_material>').join("")+"</technique_common></bind_material>":"")+"</instance_geometry>"}return t.children.forEach(e=>a+=r(e)),a+="</node>"}(r),b='<?xml version="1.0" encoding="UTF-8" standalone="no" ?>'+`<COLLADA xmlns="${"1.4.1"===s?"http://www.collada.org/2005/11/COLLADASchema":"https://www.khronos.org/collada/"}" version="${s}">`+"<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>"+(null!==a.author?`<author>${a.author}</author>`:"")+"</contributor>"+`<created>${(new Date).toISOString()}</created>`+`<modified>${(new Date).toISOString()}</modified>`+"<up_axis>Y_UP</up_axis></asset>";b+=`<library_images>${h.join("")}</library_images>`,b+=`<library_effects>${_.join("")}</library_effects>`,b+=`<library_materials>${v.join("")}</library_materials>`,b+=`<library_geometries>${y.join("")}</library_geometries>`,b+=`<library_visual_scenes><visual_scene id="Scene" name="scene">${x}</visual_scene></library_visual_scenes>`,b+='<scene><instance_visual_scene url="#Scene"/></scene>';var w,M,D,O,E,A,C={data:(w=b+="</COLLADA>",M=/^<\//,D=/(\?>$)|(\/>$)/,O=/<[^>]+>[^<]*<\/[^<]+>/,E=((e,r)=>r>0?e+E(e,r-1):""),A=0,w.match(/(<[^>]+>[^<]+<\/[^<]+>)|(<[^>]+>)/g).map(e=>{O.test(e)||D.test(e)||!M.test(e)||A--;var r=`${E("  ",A)}${e}`;return O.test(e)||D.test(e)||M.test(e)||A++,r}).join("\n")),textures:g};return"function"==typeof t&&requestAnimationFrame(()=>t(C)),C}},r});
//# sourceMappingURL=../sourcemaps/exporters/ColladaExporter.js.map
