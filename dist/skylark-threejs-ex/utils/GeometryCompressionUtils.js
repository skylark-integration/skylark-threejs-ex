/**
 * skylark-threejs-ex - A version of threejs extentions library that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-threejs-ex/
 * @license MIT
 */
define(["skylark-threejs","../threex"],function(e,t){"use strict";var n={compressNormals:function(t,n){t.geometry||console.error("Mesh must contain geometry. ");let a=t.geometry.attributes.normal;if(a||console.error("Geometry must contain normal attribute. "),a.isPacked)return;3!=a.itemSize&&console.error("normal.itemSize is not 3, which cannot be encoded. ");let i,o=a.array,h=a.count;if("DEFAULT"==n){i=new Uint8Array(3*h);for(let e=0;e<o.length;e+=3){let t;t=this.EncodingFuncs.defaultEncode(o[e],o[e+1],o[e+2],1),i[e+0]=t[0],i[e+1]=t[1],i[e+2]=t[2]}t.geometry.setAttribute("normal",new e.BufferAttribute(i,3,!0)),t.geometry.attributes.normal.bytes=1*i.length}else if("OCT1Byte"==n){i=new Int8Array(2*h);for(let e=0;e<o.length;e+=3){let t;t=this.EncodingFuncs.octEncodeBest(o[e],o[e+1],o[e+2],1),i[e/3*2+0]=t[0],i[e/3*2+1]=t[1]}t.geometry.setAttribute("normal",new e.BufferAttribute(i,2,!0)),t.geometry.attributes.normal.bytes=1*i.length}else if("OCT2Byte"==n){i=new Int16Array(2*h);for(let e=0;e<o.length;e+=3){let t;t=this.EncodingFuncs.octEncodeBest(o[e],o[e+1],o[e+2],2),i[e/3*2+0]=t[0],i[e/3*2+1]=t[1]}t.geometry.setAttribute("normal",new e.BufferAttribute(i,2,!0)),t.geometry.attributes.normal.bytes=2*i.length}else if("ANGLES"==n){i=new Uint16Array(2*h);for(let e=0;e<o.length;e+=3){let t;t=this.EncodingFuncs.anglesEncode(o[e],o[e+1],o[e+2]),i[e/3*2+0]=t[0],i[e/3*2+1]=t[1]}t.geometry.setAttribute("normal",new e.BufferAttribute(i,2,!0)),t.geometry.attributes.normal.bytes=2*i.length}else console.error("Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ");t.geometry.attributes.normal.needsUpdate=!0,t.geometry.attributes.normal.isPacked=!0,t.geometry.attributes.normal.packingMethod=n,t.material instanceof r||(t.material=(new r).copy(t.material)),"ANGLES"==n&&(t.material.defines.USE_PACKED_NORMAL=0),"OCT1Byte"==n&&(t.material.defines.USE_PACKED_NORMAL=1),"OCT2Byte"==n&&(t.material.defines.USE_PACKED_NORMAL=1),"DEFAULT"==n&&(t.material.defines.USE_PACKED_NORMAL=2)},compressPositions:function(t){t.geometry||console.error("Mesh must contain geometry. ");let n=t.geometry.attributes.position;if(n||console.error("Geometry must contain position attribute. "),n.isPacked)return;3!=n.itemSize&&console.error("position.itemSize is not 3, which cannot be packed. ");let a=n.array,i=this.EncodingFuncs.quantizedEncode(a,2),o=i.quantized,h=i.decodeMat;null==t.geometry.boundingBox&&t.geometry.computeBoundingBox(),null==t.geometry.boundingSphere&&t.geometry.computeBoundingSphere(),t.geometry.setAttribute("position",new e.BufferAttribute(o,3)),t.geometry.attributes.position.isPacked=!0,t.geometry.attributes.position.needsUpdate=!0,t.geometry.attributes.position.bytes=2*o.length,t.material instanceof r||(t.material=(new r).copy(t.material)),t.material.defines.USE_PACKED_POSITION=0,t.material.uniforms.quantizeMatPos.value=h,t.material.uniforms.quantizeMatPos.needsUpdate=!0},compressUvs:function(t){t.geometry||console.error("Mesh must contain geometry property. ");let n=t.geometry.attributes.uv;if(n||console.error("Geometry must contain uv attribute. "),n.isPacked)return;let a,i={min:1/0,max:-1/0},o=n.array;for(let e=0;e<o.length;e++)i.min=Math.min(i.min,o[e]),i.max=Math.max(i.max,o[e]);if(i.min>=-1&&i.max<=1){a=new Uint16Array(o.length);for(let e=0;e<o.length;e+=2){let t=this.EncodingFuncs.defaultEncode(o[e],o[e+1],0,2);a[e]=t[0],a[e+1]=t[1]}t.geometry.setAttribute("uv",new e.BufferAttribute(a,2,!0)),t.geometry.attributes.uv.isPacked=!0,t.geometry.attributes.uv.needsUpdate=!0,t.geometry.attributes.uv.bytes=2*a.length,t.material instanceof r||(t.material=(new r).copy(t.material)),t.material.defines.USE_PACKED_UV=0}else a=this.EncodingFuncs.quantizedEncodeUV(o,2),t.geometry.setAttribute("uv",new e.BufferAttribute(a.quantized,2)),t.geometry.attributes.uv.isPacked=!0,t.geometry.attributes.uv.needsUpdate=!0,t.geometry.attributes.uv.bytes=2*a.quantized.length,t.material instanceof r||(t.material=(new r).copy(t.material)),t.material.defines.USE_PACKED_UV=1,t.material.uniforms.quantizeMatUV.value=a.decodeMat,t.material.uniforms.quantizeMatUV.needsUpdate=!0},EncodingFuncs:{defaultEncode:function(e,t,n,r){if(1==r){let r=Math.round(.5*(e+1)*255),a=Math.round(.5*(t+1)*255),i=Math.round(.5*(n+1)*255);return new Uint8Array([r,a,i])}if(2==r){let r=Math.round(.5*(e+1)*65535),a=Math.round(.5*(t+1)*65535),i=Math.round(.5*(n+1)*65535);return new Uint16Array([r,a,i])}console.error("number of bytes must be 1 or 2")},defaultDecode:function(e,t){return 1==t?[e[0]/255*2-1,e[1]/255*2-1,e[2]/255*2-1]:2==t?[e[0]/65535*2-1,e[1]/65535*2-1,e[2]/65535*2-1]:void console.error("number of bytes must be 1 or 2")},anglesEncode:function(e,t,n){let r=parseInt(.5*(1+Math.atan2(t,e)/Math.PI)*65535),a=parseInt(.5*(1+n)*65535);return new Uint16Array([r,a])},octEncodeBest:function(e,t,n,r){var a,i,o,h,s;return o=a=u(e,t,n,"floor","floor"),i=d(a),s=m(e,t,n,i),i=d(a=u(e,t,n,"ceil","floor")),(h=m(e,t,n,i))>s&&(o=a,s=h),i=d(a=u(e,t,n,"floor","ceil")),(h=m(e,t,n,i))>s&&(o=a,s=h),i=d(a=u(e,t,n,"ceil","ceil")),(h=m(e,t,n,i))>s&&(o=a),o;function u(e,t,a,i,o){var h=e/(Math.abs(e)+Math.abs(t)+Math.abs(a)),s=t/(Math.abs(e)+Math.abs(t)+Math.abs(a));if(n<0){var u=(1-Math.abs(s))*(h>=0?1:-1),d=(1-Math.abs(h))*(s>=0?1:-1);h=u,s=d;var m=1-Math.abs(h)-Math.abs(s);m>0&&(m+=.001,h+=h>0?m/2:-m/2,s+=s>0?m/2:-m/2)}return 1==r?new Int8Array([Math[i](127.5*h+(h<0?1:0)),Math[o](127.5*s+(s<0?1:0))]):2==r?new Int16Array([Math[i](32767.5*h+(h<0?1:0)),Math[o](32767.5*s+(s<0?1:0))]):void 0}function d(e){var t=e[0],n=e[1];1==r?(t/=t<0?127:128,n/=n<0?127:128):2==r&&(t/=t<0?32767:32768,n/=n<0?32767:32768);var a=1-Math.abs(t)-Math.abs(n);if(a<0){var i=t;t=(1-Math.abs(n))*(t>=0?1:-1),n=(1-Math.abs(i))*(n>=0?1:-1)}var o=Math.sqrt(t*t+n*n+a*a);return[t/o,n/o,a/o]}function m(e,t,n,r){return e*r[0]+t*r[1]+n*r[2]}},quantizedEncode:function(t,n){let r,a;1==n?(r=new Uint8Array(t.length),a=255):2==n?(r=new Uint16Array(t.length),a=65535):console.error("number of bytes error! ");let i=new e.Matrix4,o=new Float32Array(3),h=new Float32Array(3);o[0]=o[1]=o[2]=Number.MAX_VALUE,h[0]=h[1]=h[2]=-Number.MAX_VALUE;for(let e=0;e<t.length;e+=3)o[0]=Math.min(o[0],t[e+0]),o[1]=Math.min(o[1],t[e+1]),o[2]=Math.min(o[2],t[e+2]),h[0]=Math.max(h[0],t[e+0]),h[1]=Math.max(h[1],t[e+1]),h[2]=Math.max(h[2],t[e+2]);i.scale(new e.Vector3((h[0]-o[0])/a,(h[1]-o[1])/a,(h[2]-o[2])/a)),i.elements[12]=o[0],i.elements[13]=o[1],i.elements[14]=o[2],i.transpose();let s=new Float32Array([h[0]!==o[0]?a/(h[0]-o[0]):0,h[1]!==o[1]?a/(h[1]-o[1]):0,h[2]!==o[2]?a/(h[2]-o[2]):0]);for(let e=0;e<t.length;e+=3)r[e+0]=Math.floor((t[e+0]-o[0])*s[0]),r[e+1]=Math.floor((t[e+1]-o[1])*s[1]),r[e+2]=Math.floor((t[e+2]-o[2])*s[2]);return{quantized:r,decodeMat:i}},quantizedEncodeUV:function(t,n){let r,a;1==n?(r=new Uint8Array(t.length),a=255):2==n?(r=new Uint16Array(t.length),a=65535):console.error("number of bytes error! ");let i=new e.Matrix3,o=new Float32Array(2),h=new Float32Array(2);o[0]=o[1]=Number.MAX_VALUE,h[0]=h[1]=-Number.MAX_VALUE;for(let e=0;e<t.length;e+=2)o[0]=Math.min(o[0],t[e+0]),o[1]=Math.min(o[1],t[e+1]),h[0]=Math.max(h[0],t[e+0]),h[1]=Math.max(h[1],t[e+1]);i.scale((h[0]-o[0])/a,(h[1]-o[1])/a),i.elements[6]=o[0],i.elements[7]=o[1],i.transpose();let s=new Float32Array([h[0]!==o[0]?a/(h[0]-o[0]):0,h[1]!==o[1]?a/(h[1]-o[1]):0]);for(let e=0;e<t.length;e+=2)r[e+0]=Math.floor((t[e+0]-o[0])*s[0]),r[e+1]=Math.floor((t[e+1]-o[1])*s[1]);return{quantized:r,decodeMat:i}}}};function r(t){e.MeshPhongMaterial.call(this),this.defines={},this.type="PackedPhongMaterial",this.uniforms=e.UniformsUtils.merge([e.ShaderLib.phong.uniforms,{quantizeMatPos:{value:null},quantizeMatUV:{value:null}}]),this.vertexShader=["#define PHONG","varying vec3 vViewPosition;","#ifndef FLAT_SHADED","varying vec3 vNormal;","#endif",e.ShaderChunk.common,e.ShaderChunk.uv_pars_vertex,e.ShaderChunk.uv2_pars_vertex,e.ShaderChunk.displacementmap_pars_vertex,e.ShaderChunk.envmap_pars_vertex,e.ShaderChunk.color_pars_vertex,e.ShaderChunk.fog_pars_vertex,e.ShaderChunk.morphtarget_pars_vertex,e.ShaderChunk.skinning_pars_vertex,e.ShaderChunk.shadowmap_pars_vertex,e.ShaderChunk.logdepthbuf_pars_vertex,e.ShaderChunk.clipping_planes_pars_vertex,"#ifdef USE_PACKED_NORMAL\n\t\t\t#if USE_PACKED_NORMAL == 0\n\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t{\n\t\t\t\t\tfloat x = packedNormal.x * 2.0 - 1.0;\n\t\t\t\t\tfloat y = packedNormal.y * 2.0 - 1.0;\n\t\t\t\t\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\n\t\t\t\t\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\n\t\t\t\t\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t#if USE_PACKED_NORMAL == 1\n\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t{\n\t\t\t\t\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\n\t\t\t\t\tif (v.z < 0.0)\n\t\t\t\t\t{\n\t\t\t\t\t\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n\t\t\t\t\t}\n\t\t\t\t\treturn normalize(v);\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t#if USE_PACKED_NORMAL == 2\n\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t{\n\t\t\t\t\tvec3 v = (packedNormal * 2.0) - 1.0;\n\t\t\t\t\treturn normalize(v);\n\t\t\t\t}\n\t\t\t#endif\n\t\t#endif","#ifdef USE_PACKED_POSITION\n\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\tuniform mat4 quantizeMatPos;\n\t\t\t#endif\n\t\t#endif","#ifdef USE_PACKED_UV\n\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\tuniform mat3 quantizeMatUV;\n\t\t\t#endif\n\t\t#endif","#ifdef USE_PACKED_UV\n\t\t\t#if USE_PACKED_UV == 0\n\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t{\n\t\t\t\t\tvec2 uv = (packedUV * 2.0) - 1.0;\n\t\t\t\t\treturn uv;\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t{\n\t\t\t\t\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\n\t\t\t\t\treturn uv;\n\t\t\t\t}\n\t\t\t#endif\n\t\t#endif","void main() {",e.ShaderChunk.uv_vertex,"#ifdef USE_UV\n\t\t\t#ifdef USE_PACKED_UV\n\t\t\t\tvUv = decodeUV(vUv);\n\t\t\t#endif\n\t\t#endif",e.ShaderChunk.uv2_vertex,e.ShaderChunk.color_vertex,e.ShaderChunk.beginnormal_vertex,"#ifdef USE_PACKED_NORMAL\n\t\t\tobjectNormal = decodeNormal(objectNormal);\n\t\t#endif\n\n\t\t#ifdef USE_TANGENT\n\t\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t\t#endif\n\t\t",e.ShaderChunk.morphnormal_vertex,e.ShaderChunk.skinbase_vertex,e.ShaderChunk.skinnormal_vertex,e.ShaderChunk.defaultnormal_vertex,"#ifndef FLAT_SHADED","\tvNormal = normalize( transformedNormal );","#endif",e.ShaderChunk.begin_vertex,"#ifdef USE_PACKED_POSITION\n\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\n\t\t\t#endif\n\t\t#endif",e.ShaderChunk.morphtarget_vertex,e.ShaderChunk.skinning_vertex,e.ShaderChunk.displacementmap_vertex,e.ShaderChunk.project_vertex,e.ShaderChunk.logdepthbuf_vertex,e.ShaderChunk.clipping_planes_vertex,"vViewPosition = - mvPosition.xyz;",e.ShaderChunk.worldpos_vertex,e.ShaderChunk.envmap_vertex,e.ShaderChunk.shadowmap_vertex,e.ShaderChunk.fog_vertex,"}"].join("\n"),this.fragmentShader=["#define PHONG","uniform vec3 diffuse;","uniform vec3 emissive;","uniform vec3 specular;","uniform float shininess;","uniform float opacity;",e.ShaderChunk.common,e.ShaderChunk.packing,e.ShaderChunk.dithering_pars_fragment,e.ShaderChunk.color_pars_fragment,e.ShaderChunk.uv_pars_fragment,e.ShaderChunk.uv2_pars_fragment,e.ShaderChunk.map_pars_fragment,e.ShaderChunk.alphamap_pars_fragment,e.ShaderChunk.aomap_pars_fragment,e.ShaderChunk.lightmap_pars_fragment,e.ShaderChunk.emissivemap_pars_fragment,e.ShaderChunk.envmap_common_pars_fragment,e.ShaderChunk.envmap_pars_fragment,e.ShaderChunk.cube_uv_reflection_fragment,e.ShaderChunk.fog_pars_fragment,e.ShaderChunk.bsdfs,e.ShaderChunk.lights_pars_begin,e.ShaderChunk.lights_phong_pars_fragment,e.ShaderChunk.shadowmap_pars_fragment,e.ShaderChunk.bumpmap_pars_fragment,e.ShaderChunk.normalmap_pars_fragment,e.ShaderChunk.specularmap_pars_fragment,e.ShaderChunk.logdepthbuf_pars_fragment,e.ShaderChunk.clipping_planes_pars_fragment,"void main() {",e.ShaderChunk.clipping_planes_fragment,"vec4 diffuseColor = vec4( diffuse, opacity );","ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );","vec3 totalEmissiveRadiance = emissive;",e.ShaderChunk.logdepthbuf_fragment,e.ShaderChunk.map_fragment,e.ShaderChunk.color_fragment,e.ShaderChunk.alphamap_fragment,e.ShaderChunk.alphatest_fragment,e.ShaderChunk.specularmap_fragment,e.ShaderChunk.normal_fragment_begin,e.ShaderChunk.normal_fragment_maps,e.ShaderChunk.emissivemap_fragment,e.ShaderChunk.lights_phong_fragment,e.ShaderChunk.lights_fragment_begin,e.ShaderChunk.lights_fragment_maps,e.ShaderChunk.lights_fragment_end,e.ShaderChunk.aomap_fragment,"vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",e.ShaderChunk.envmap_fragment,"gl_FragColor = vec4( outgoingLight, diffuseColor.a );",e.ShaderChunk.tonemapping_fragment,e.ShaderChunk.encodings_fragment,e.ShaderChunk.fog_fragment,e.ShaderChunk.premultiplied_alpha_fragment,e.ShaderChunk.dithering_fragment,"}"].join("\n"),this.setValues(t)}return r.prototype=Object.create(e.MeshPhongMaterial.prototype),n.PackedPhongMaterial=r,t.utils.GeometryCompressionUtils=n});
//# sourceMappingURL=../sourcemaps/utils/GeometryCompressionUtils.js.map
