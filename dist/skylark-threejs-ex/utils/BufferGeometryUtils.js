/**
 * skylark-threejs-ex - A version of threejs extentions library that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-threejs-ex/
 * @license MIT
 */
define(["skylark-threejs"],function(r){"use strict";return{computeTangents:function(e){var t=e.index,n=e.attributes;if(null!==t&&void 0!==n.position&&void 0!==n.normal&&void 0!==n.uv){var o=t.array,a=n.position.array,i=n.normal.array,u=n.uv.array,s=a.length/3;void 0===n.tangent&&e.setAttribute("tangent",new r.BufferAttribute(new Float32Array(4*s),4));for(var l=n.tangent.array,f=[],c=[],g=0;g<s;g++)f[g]=new r.Vector3,c[g]=new r.Vector3;var d=new r.Vector3,v=new r.Vector3,m=new r.Vector3,h=new r.Vector2,p=new r.Vector2,b=new r.Vector2,y=new r.Vector3,w=new r.Vector3,A=e.groups;0===A.length&&(A=[{start:0,count:o.length}]);g=0;for(var S=A.length;g<S;++g)for(var B=G=(I=A[g]).start,T=G+I.count;B<T;B+=3)U(o[B+0],o[B+1],o[B+2]);var E,x,V,z=new r.Vector3,D=new r.Vector3,M=new r.Vector3,X=new r.Vector3;for(g=0,S=A.length;g<S;++g){var I,G;for(B=G=(I=A[g]).start,T=G+I.count;B<T;B+=3)R(o[B+0]),R(o[B+1]),R(o[B+2])}}else console.warn("THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");function U(r,e,t){d.fromArray(a,3*r),v.fromArray(a,3*e),m.fromArray(a,3*t),h.fromArray(u,2*r),p.fromArray(u,2*e),b.fromArray(u,2*t),v.sub(d),m.sub(d),p.sub(h),b.sub(h);var n=1/(p.x*b.y-b.x*p.y);isFinite(n)&&(y.copy(v).multiplyScalar(b.y).addScaledVector(m,-p.y).multiplyScalar(n),w.copy(m).multiplyScalar(p.x).addScaledVector(v,-b.x).multiplyScalar(n),f[r].add(y),f[e].add(y),f[t].add(y),c[r].add(w),c[e].add(w),c[t].add(w))}function R(r){M.fromArray(i,3*r),X.copy(M),x=f[r],z.copy(x),z.sub(M.multiplyScalar(M.dot(x))).normalize(),D.crossVectors(X,x),V=D.dot(c[r]),E=V<0?-1:1,l[4*r]=z.x,l[4*r+1]=z.y,l[4*r+2]=z.z,l[4*r+3]=E}},mergeBufferGeometries:function(e,t){for(var n=null!==e[0].index,o=new Set(Object.keys(e[0].attributes)),a=new Set(Object.keys(e[0].morphAttributes)),i={},u={},s=e[0].morphTargetsRelative,l=new r.BufferGeometry,f=0,c=0;c<e.length;++c){var g=e[c];if(n!==(null!==g.index))return null;for(var d in g.attributes){if(!o.has(d))return null;void 0===i[d]&&(i[d]=[]),i[d].push(g.attributes[d])}if(s!==g.morphTargetsRelative)return null;for(var d in g.morphAttributes){if(!a.has(d))return null;void 0===u[d]&&(u[d]=[]),u[d].push(g.morphAttributes[d])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(g.userData),t){var v;if(n)v=g.index.count;else{if(void 0===g.attributes.position)return null;v=g.attributes.position.count}l.addGroup(f,v,c),f+=v}}if(n){var m=0,h=[];for(c=0;c<e.length;++c){for(var p=e[c].index,b=0;b<p.count;++b)h.push(p.getX(b)+m);m+=e[c].attributes.position.count}l.setIndex(h)}for(var d in i){var y=this.mergeBufferAttributes(i[d]);if(!y)return null;l.setAttribute(d,y)}for(var d in u){var w=u[d][0].length;if(0===w)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[d]=[];for(c=0;c<w;++c){var A=[];for(b=0;b<u[d].length;++b)A.push(u[d][b][c]);var S=this.mergeBufferAttributes(A);if(!S)return null;l.morphAttributes[d].push(S)}}return l},mergeBufferAttributes:function(e){for(var t,n,o,a=0,i=0;i<e.length;++i){var u=e[i];if(u.isInterleavedBufferAttribute)return null;if(void 0===t&&(t=u.array.constructor),t!==u.array.constructor)return null;if(void 0===n&&(n=u.itemSize),n!==u.itemSize)return null;if(void 0===o&&(o=u.normalized),o!==u.normalized)return null;a+=u.array.length}var s=new t(a),l=0;for(i=0;i<e.length;++i)s.set(e[i].array,l),l+=e[i].array.length;return new r.BufferAttribute(s,n,o)},interleaveAttributes:function(e){for(var t,n=0,o=0,a=0,i=e.length;a<i;++a){var u=e[a];if(void 0===t&&(t=u.array.constructor),t!==u.array.constructor)return console.warn("AttributeBuffers of different types cannot be interleaved"),null;n+=u.array.length,o+=u.itemSize}var s=new r.InterleavedBuffer(new t(n),o),l=0,f=[],c=["getX","getY","getZ","getW"],g=["setX","setY","setZ","setW"],d=0;for(i=e.length;d<i;d++){var v=(u=e[d]).itemSize,m=u.count,h=new r.InterleavedBufferAttribute(s,v,l,u.normalized);f.push(h),l+=v;for(var p=0;p<m;p++)for(var b=0;b<v;b++)h[g[b]](p,u[c[b]](p))}return f},estimateBytesUsed:function(r){var e=0;for(var t in r.attributes){var n=r.getAttribute(t);e+=n.count*n.itemSize*n.array.BYTES_PER_ELEMENT}var o=r.getIndex();return e+=o?o.count*o.itemSize*o.array.BYTES_PER_ELEMENT:0},mergeVertices:function(e,t=1e-4){t=Math.max(t,Number.EPSILON);for(var n={},o=e.getIndex(),a=e.getAttribute("position"),i=o?o.count:a.count,u=0,s=Object.keys(e.attributes),l={},f={},c=[],g=["getX","getY","getZ","getW"],d=0,v=s.length;d<v;d++){l[w=s[d]]=[],(T=e.morphAttributes[w])&&(f[w]=new Array(T.length).fill().map(()=>[]))}var m=Math.log10(1/t),h=Math.pow(10,m);for(d=0;d<i;d++){var p=o?o.getX(d):d,b="",y=0;for(v=s.length;y<v;y++)for(var w=s[y],A=(B=e.getAttribute(w)).itemSize,S=0;S<A;S++)b+=`${~~(B[g[S]](p)*h)},`;if(b in n)c.push(n[b]);else{for(y=0,v=s.length;y<v;y++){w=s[y];var B=e.getAttribute(w),T=e.morphAttributes[w],E=(A=B.itemSize,l[w]),x=f[w];for(S=0;S<A;S++){var V=g[S];if(E.push(B[V](p)),T)for(var z=0,D=T.length;z<D;z++)x[z].push(T[z][V](p))}}n[b]=u,c.push(u),u++}}const M=e.clone();for(d=0,v=s.length;d<v;d++){w=s[d];var X=e.getAttribute(w),I=new X.array.constructor(l[w]);B=new r.BufferAttribute(I,X.itemSize,X.normalized);if(M.setAttribute(w,B),w in f)for(y=0;y<f[w].length;y++){var G=e.morphAttributes[w][y],U=(I=new G.array.constructor(f[w][y]),new r.BufferAttribute(I,G.itemSize,G.normalized));M.morphAttributes[w][y]=U}}return M.setIndex(c),M},toTrianglesDrawMode:function(e,t){if(t===r.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t===r.TriangleFanDrawMode||t===r.TriangleStripDrawMode){var n=e.getIndex();if(null===n){var o=[],a=e.getAttribute("position");if(void 0===a)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(var i=0;i<a.count;i++)o.push(i);e.setIndex(o),n=e.getIndex()}var u=n.count-2,s=[];if(t===r.TriangleFanDrawMode)for(i=1;i<=u;i++)s.push(n.getX(0)),s.push(n.getX(i)),s.push(n.getX(i+1));else for(i=0;i<u;i++)i%2==0?(s.push(n.getX(i)),s.push(n.getX(i+1)),s.push(n.getX(i+2))):(s.push(n.getX(i+2)),s.push(n.getX(i+1)),s.push(n.getX(i)));s.length/3!==u&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");var l=e.clone();return l.setIndex(s),l.clearGroups(),l}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e}}});
//# sourceMappingURL=../sourcemaps/utils/BufferGeometryUtils.js.map
