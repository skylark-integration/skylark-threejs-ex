/**
 * skylark-threejs-ex - A version of threejs extentions library that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-threejs-ex/
 * @license MIT
 */
define(["skylark-threejs","../threex"],function(r,e){"use strict";var t={computeTangents:function(e){var t=e.index,n=e.attributes;if(null!==t&&void 0!==n.position&&void 0!==n.normal&&void 0!==n.uv){var o=t.array,a=n.position.array,i=n.normal.array,u=n.uv.array,s=a.length/3;void 0===n.tangent&&e.setAttribute("tangent",new r.BufferAttribute(new Float32Array(4*s),4));for(var l=n.tangent.array,f=[],c=[],g=0;g<s;g++)f[g]=new r.Vector3,c[g]=new r.Vector3;var d=new r.Vector3,v=new r.Vector3,m=new r.Vector3,h=new r.Vector2,p=new r.Vector2,y=new r.Vector2,b=new r.Vector3,w=new r.Vector3,A=e.groups;0===A.length&&(A=[{start:0,count:o.length}]);g=0;for(var B=A.length;g<B;++g)for(var S=I=(G=A[g]).start,T=I+G.count;S<T;S+=3)U(o[S+0],o[S+1],o[S+2]);var x,E,V,z=new r.Vector3,D=new r.Vector3,M=new r.Vector3,X=new r.Vector3;for(g=0,B=A.length;g<B;++g){var G,I;for(S=I=(G=A[g]).start,T=I+G.count;S<T;S+=3)R(o[S+0]),R(o[S+1]),R(o[S+2])}}else console.warn("THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");function U(r,e,t){d.fromArray(a,3*r),v.fromArray(a,3*e),m.fromArray(a,3*t),h.fromArray(u,2*r),p.fromArray(u,2*e),y.fromArray(u,2*t),v.sub(d),m.sub(d),p.sub(h),y.sub(h);var n=1/(p.x*y.y-y.x*p.y);isFinite(n)&&(b.copy(v).multiplyScalar(y.y).addScaledVector(m,-p.y).multiplyScalar(n),w.copy(m).multiplyScalar(p.x).addScaledVector(v,-y.x).multiplyScalar(n),f[r].add(b),f[e].add(b),f[t].add(b),c[r].add(w),c[e].add(w),c[t].add(w))}function R(r){M.fromArray(i,3*r),X.copy(M),E=f[r],z.copy(E),z.sub(M.multiplyScalar(M.dot(E))).normalize(),D.crossVectors(X,E),V=D.dot(c[r]),x=V<0?-1:1,l[4*r]=z.x,l[4*r+1]=z.y,l[4*r+2]=z.z,l[4*r+3]=x}},mergeBufferGeometries:function(e,t){for(var n=null!==e[0].index,o=new Set(Object.keys(e[0].attributes)),a=new Set(Object.keys(e[0].morphAttributes)),i={},u={},s=e[0].morphTargetsRelative,l=new r.BufferGeometry,f=0,c=0;c<e.length;++c){var g=e[c];if(n!==(null!==g.index))return null;for(var d in g.attributes){if(!o.has(d))return null;void 0===i[d]&&(i[d]=[]),i[d].push(g.attributes[d])}if(s!==g.morphTargetsRelative)return null;for(var d in g.morphAttributes){if(!a.has(d))return null;void 0===u[d]&&(u[d]=[]),u[d].push(g.morphAttributes[d])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(g.userData),t){var v;if(n)v=g.index.count;else{if(void 0===g.attributes.position)return null;v=g.attributes.position.count}l.addGroup(f,v,c),f+=v}}if(n){var m=0,h=[];for(c=0;c<e.length;++c){for(var p=e[c].index,y=0;y<p.count;++y)h.push(p.getX(y)+m);m+=e[c].attributes.position.count}l.setIndex(h)}for(var d in i){var b=this.mergeBufferAttributes(i[d]);if(!b)return null;l.setAttribute(d,b)}for(var d in u){var w=u[d][0].length;if(0===w)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[d]=[];for(c=0;c<w;++c){var A=[];for(y=0;y<u[d].length;++y)A.push(u[d][y][c]);var B=this.mergeBufferAttributes(A);if(!B)return null;l.morphAttributes[d].push(B)}}return l},mergeBufferAttributes:function(e){for(var t,n,o,a=0,i=0;i<e.length;++i){var u=e[i];if(u.isInterleavedBufferAttribute)return null;if(void 0===t&&(t=u.array.constructor),t!==u.array.constructor)return null;if(void 0===n&&(n=u.itemSize),n!==u.itemSize)return null;if(void 0===o&&(o=u.normalized),o!==u.normalized)return null;a+=u.array.length}var s=new t(a),l=0;for(i=0;i<e.length;++i)s.set(e[i].array,l),l+=e[i].array.length;return new r.BufferAttribute(s,n,o)},interleaveAttributes:function(e){for(var t,n=0,o=0,a=0,i=e.length;a<i;++a){var u=e[a];if(void 0===t&&(t=u.array.constructor),t!==u.array.constructor)return console.warn("AttributeBuffers of different types cannot be interleaved"),null;n+=u.array.length,o+=u.itemSize}var s=new r.InterleavedBuffer(new t(n),o),l=0,f=[],c=["getX","getY","getZ","getW"],g=["setX","setY","setZ","setW"],d=0;for(i=e.length;d<i;d++){var v=(u=e[d]).itemSize,m=u.count,h=new r.InterleavedBufferAttribute(s,v,l,u.normalized);f.push(h),l+=v;for(var p=0;p<m;p++)for(var y=0;y<v;y++)h[g[y]](p,u[c[y]](p))}return f},estimateBytesUsed:function(r){var e=0;for(var t in r.attributes){var n=r.getAttribute(t);e+=n.count*n.itemSize*n.array.BYTES_PER_ELEMENT}var o=r.getIndex();return e+=o?o.count*o.itemSize*o.array.BYTES_PER_ELEMENT:0},mergeVertices:function(e,t=1e-4){t=Math.max(t,Number.EPSILON);for(var n={},o=e.getIndex(),a=e.getAttribute("position"),i=o?o.count:a.count,u=0,s=Object.keys(e.attributes),l={},f={},c=[],g=["getX","getY","getZ","getW"],d=0,v=s.length;d<v;d++){l[w=s[d]]=[],(T=e.morphAttributes[w])&&(f[w]=new Array(T.length).fill().map(()=>[]))}var m=Math.log10(1/t),h=Math.pow(10,m);for(d=0;d<i;d++){var p=o?o.getX(d):d,y="",b=0;for(v=s.length;b<v;b++)for(var w=s[b],A=(S=e.getAttribute(w)).itemSize,B=0;B<A;B++)y+=`${~~(S[g[B]](p)*h)},`;if(y in n)c.push(n[y]);else{for(b=0,v=s.length;b<v;b++){w=s[b];var S=e.getAttribute(w),T=e.morphAttributes[w],x=(A=S.itemSize,l[w]),E=f[w];for(B=0;B<A;B++){var V=g[B];if(x.push(S[V](p)),T)for(var z=0,D=T.length;z<D;z++)E[z].push(T[z][V](p))}}n[y]=u,c.push(u),u++}}const M=e.clone();for(d=0,v=s.length;d<v;d++){w=s[d];var X=e.getAttribute(w),G=new X.array.constructor(l[w]);S=new r.BufferAttribute(G,X.itemSize,X.normalized);if(M.setAttribute(w,S),w in f)for(b=0;b<f[w].length;b++){var I=e.morphAttributes[w][b],U=(G=new I.array.constructor(f[w][b]),new r.BufferAttribute(G,I.itemSize,I.normalized));M.morphAttributes[w][b]=U}}return M.setIndex(c),M},toTrianglesDrawMode:function(e,t){if(t===r.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t===r.TriangleFanDrawMode||t===r.TriangleStripDrawMode){var n=e.getIndex();if(null===n){var o=[],a=e.getAttribute("position");if(void 0===a)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(var i=0;i<a.count;i++)o.push(i);e.setIndex(o),n=e.getIndex()}var u=n.count-2,s=[];if(t===r.TriangleFanDrawMode)for(i=1;i<=u;i++)s.push(n.getX(0)),s.push(n.getX(i)),s.push(n.getX(i+1));else for(i=0;i<u;i++)i%2==0?(s.push(n.getX(i)),s.push(n.getX(i+1)),s.push(n.getX(i+2))):(s.push(n.getX(i+2)),s.push(n.getX(i+1)),s.push(n.getX(i)));s.length/3!==u&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");var l=e.clone();return l.setIndex(s),l.clearGroups(),l}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e}};return e.utils.BufferGeometryUtils=t});
//# sourceMappingURL=../sourcemaps/utils/BufferGeometryUtils.js.map
