/**
 * skylark-threejs-ex - A version of threejs extentions library that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-threejs-ex/
 * @license MIT
 */
define(["skylark-threejs"],function(e){return e.BufferGeometryUtils={computeTangents:function(r){var t=r.index,n=r.attributes;if(null!==t&&void 0!==n.position&&void 0!==n.normal&&void 0!==n.uv){var o=t.array,a=n.position.array,i=n.normal.array,u=n.uv.array,s=a.length/3;void 0===n.tangent&&r.setAttribute("tangent",new e.BufferAttribute(new Float32Array(4*s),4));for(var l=n.tangent.array,f=[],c=[],g=0;g<s;g++)f[g]=new e.Vector3,c[g]=new e.Vector3;var d=new e.Vector3,m=new e.Vector3,v=new e.Vector3,h=new e.Vector2,p=new e.Vector2,y=new e.Vector2,b=new e.Vector3,w=new e.Vector3,A=r.groups;0===A.length&&(A=[{start:0,count:o.length}]);g=0;for(var B=A.length;g<B;++g)for(var S=U=(G=A[g]).start,T=U+G.count;S<T;S+=3)I(o[S+0],o[S+1],o[S+2]);var E,x,V,z=new e.Vector3,D=new e.Vector3,M=new e.Vector3,X=new e.Vector3;for(g=0,B=A.length;g<B;++g){var G,U;for(S=U=(G=A[g]).start,T=U+G.count;S<T;S+=3)R(o[S+0]),R(o[S+1]),R(o[S+2])}}else console.warn("THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");function I(e,r,t){d.fromArray(a,3*e),m.fromArray(a,3*r),v.fromArray(a,3*t),h.fromArray(u,2*e),p.fromArray(u,2*r),y.fromArray(u,2*t),m.sub(d),v.sub(d),p.sub(h),y.sub(h);var n=1/(p.x*y.y-y.x*p.y);isFinite(n)&&(b.copy(m).multiplyScalar(y.y).addScaledVector(v,-p.y).multiplyScalar(n),w.copy(v).multiplyScalar(p.x).addScaledVector(m,-y.x).multiplyScalar(n),f[e].add(b),f[r].add(b),f[t].add(b),c[e].add(w),c[r].add(w),c[t].add(w))}function R(e){M.fromArray(i,3*e),X.copy(M),x=f[e],z.copy(x),z.sub(M.multiplyScalar(M.dot(x))).normalize(),D.crossVectors(X,x),V=D.dot(c[e]),E=V<0?-1:1,l[4*e]=z.x,l[4*e+1]=z.y,l[4*e+2]=z.z,l[4*e+3]=E}},mergeBufferGeometries:function(r,t){for(var n=null!==r[0].index,o=new Set(Object.keys(r[0].attributes)),a=new Set(Object.keys(r[0].morphAttributes)),i={},u={},s=r[0].morphTargetsRelative,l=new e.BufferGeometry,f=0,c=0;c<r.length;++c){var g=r[c];if(n!==(null!==g.index))return null;for(var d in g.attributes){if(!o.has(d))return null;void 0===i[d]&&(i[d]=[]),i[d].push(g.attributes[d])}if(s!==g.morphTargetsRelative)return null;for(var d in g.morphAttributes){if(!a.has(d))return null;void 0===u[d]&&(u[d]=[]),u[d].push(g.morphAttributes[d])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(g.userData),t){var m;if(n)m=g.index.count;else{if(void 0===g.attributes.position)return null;m=g.attributes.position.count}l.addGroup(f,m,c),f+=m}}if(n){var v=0,h=[];for(c=0;c<r.length;++c){for(var p=r[c].index,y=0;y<p.count;++y)h.push(p.getX(y)+v);v+=r[c].attributes.position.count}l.setIndex(h)}for(var d in i){var b=this.mergeBufferAttributes(i[d]);if(!b)return null;l.setAttribute(d,b)}for(var d in u){var w=u[d][0].length;if(0===w)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[d]=[];for(c=0;c<w;++c){var A=[];for(y=0;y<u[d].length;++y)A.push(u[d][y][c]);var B=this.mergeBufferAttributes(A);if(!B)return null;l.morphAttributes[d].push(B)}}return l},mergeBufferAttributes:function(r){for(var t,n,o,a=0,i=0;i<r.length;++i){var u=r[i];if(u.isInterleavedBufferAttribute)return null;if(void 0===t&&(t=u.array.constructor),t!==u.array.constructor)return null;if(void 0===n&&(n=u.itemSize),n!==u.itemSize)return null;if(void 0===o&&(o=u.normalized),o!==u.normalized)return null;a+=u.array.length}var s=new t(a),l=0;for(i=0;i<r.length;++i)s.set(r[i].array,l),l+=r[i].array.length;return new e.BufferAttribute(s,n,o)},interleaveAttributes:function(r){for(var t,n=0,o=0,a=0,i=r.length;a<i;++a){var u=r[a];if(void 0===t&&(t=u.array.constructor),t!==u.array.constructor)return console.warn("AttributeBuffers of different types cannot be interleaved"),null;n+=u.array.length,o+=u.itemSize}var s=new e.InterleavedBuffer(new t(n),o),l=0,f=[],c=["getX","getY","getZ","getW"],g=["setX","setY","setZ","setW"],d=0;for(i=r.length;d<i;d++){var m=(u=r[d]).itemSize,v=u.count,h=new e.InterleavedBufferAttribute(s,m,l,u.normalized);f.push(h),l+=m;for(var p=0;p<v;p++)for(var y=0;y<m;y++)h[g[y]](p,u[c[y]](p))}return f},estimateBytesUsed:function(e){var r=0;for(var t in e.attributes){var n=e.getAttribute(t);r+=n.count*n.itemSize*n.array.BYTES_PER_ELEMENT}var o=e.getIndex();return r+=o?o.count*o.itemSize*o.array.BYTES_PER_ELEMENT:0},mergeVertices:function(r,t=1e-4){t=Math.max(t,Number.EPSILON);for(var n={},o=r.getIndex(),a=r.getAttribute("position"),i=o?o.count:a.count,u=0,s=Object.keys(r.attributes),l={},f={},c=[],g=["getX","getY","getZ","getW"],d=0,m=s.length;d<m;d++){l[w=s[d]]=[],(T=r.morphAttributes[w])&&(f[w]=new Array(T.length).fill().map(()=>[]))}var v=Math.log10(1/t),h=Math.pow(10,v);for(d=0;d<i;d++){var p=o?o.getX(d):d,y="",b=0;for(m=s.length;b<m;b++)for(var w=s[b],A=(S=r.getAttribute(w)).itemSize,B=0;B<A;B++)y+=`${~~(S[g[B]](p)*h)},`;if(y in n)c.push(n[y]);else{for(b=0,m=s.length;b<m;b++){w=s[b];var S=r.getAttribute(w),T=r.morphAttributes[w],E=(A=S.itemSize,l[w]),x=f[w];for(B=0;B<A;B++){var V=g[B];if(E.push(S[V](p)),T)for(var z=0,D=T.length;z<D;z++)x[z].push(T[z][V](p))}}n[y]=u,c.push(u),u++}}const M=r.clone();for(d=0,m=s.length;d<m;d++){w=s[d];var X=r.getAttribute(w),G=new X.array.constructor(l[w]);S=new e.BufferAttribute(G,X.itemSize,X.normalized);if(M.setAttribute(w,S),w in f)for(b=0;b<f[w].length;b++){var U=r.morphAttributes[w][b],I=(G=new U.array.constructor(f[w][b]),new e.BufferAttribute(G,U.itemSize,U.normalized));M.morphAttributes[w][b]=I}}return M.setIndex(c),M},toTrianglesDrawMode:function(r,t){if(t===e.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),r;if(t===e.TriangleFanDrawMode||t===e.TriangleStripDrawMode){var n=r.getIndex();if(null===n){var o=[],a=r.getAttribute("position");if(void 0===a)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),r;for(var i=0;i<a.count;i++)o.push(i);r.setIndex(o),n=r.getIndex()}var u=n.count-2,s=[];if(t===e.TriangleFanDrawMode)for(i=1;i<=u;i++)s.push(n.getX(0)),s.push(n.getX(i)),s.push(n.getX(i+1));else for(i=0;i<u;i++)i%2==0?(s.push(n.getX(i)),s.push(n.getX(i+1)),s.push(n.getX(i+2))):(s.push(n.getX(i+2)),s.push(n.getX(i+1)),s.push(n.getX(i)));s.length/3!==u&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");var l=r.clone();return l.setIndex(s),l.clearGroups(),l}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),r}},e.BufferGeometryUtils});
//# sourceMappingURL=../sourcemaps/utils/BufferGeometryUtils.js.map
