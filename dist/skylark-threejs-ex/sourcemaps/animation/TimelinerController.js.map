{"version":3,"sources":["animation/TimelinerController.js"],"names":["define","THREE","TimelinerController","scene","trackInfo","onUpdate","this","_scene","_trackInfo","_onUpdate","_mixer","AnimationMixer","_clip","_action","_tracks","_propRefs","_channelNames","prototype","constructor","init","tracks","i","n","length","spec","push","_addTrack","type","propertyPath","initialValue","interpolation","AnimationClip","clipAction","play","setDisplayTime","time","update","setDuration","duration","getChannelNames","getChannelKeyTimes","channelName","times","setKeyframe","track","index","Timeliner","binarySearch","values","stride","getValueSize","offset","nTimes","nValues","e","getValue","delKeyframe","pop","moveKeyframe","delta","moveRemaining","endAt","needsSort","_sort","serialize","result","channels","names","name","deserialize","structs","data","_setArray","order","AnimationUtils","getKeyframeOrder","sortedArray","dst","src","apply","prop","Array","slice","call","PropertyBinding"],"mappings":"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","file":"../../animation/TimelinerController.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * Controller class for the Timeliner GUI.\n\t *\n\t * Timeliner GUI library (required to use this class):\n\t *\n\t * \t\t../libs/timeliner_gui.min.js\n\t *\n\t * Source code:\n\t *\n\t * \t\thttps://github.com/tschw/timeliner_gui\n\t * \t\thttps://github.com/zz85/timeliner (fork's origin)\n\t *\n\t * @author tschw\n\t *\n\t */\n\n\tTHREE.TimelinerController = function TimelinerController( scene, trackInfo, onUpdate ) {\n\n\t\tthis._scene = scene;\n\t\tthis._trackInfo = trackInfo;\n\n\t\tthis._onUpdate = onUpdate;\n\n\t\tthis._mixer = new THREE.AnimationMixer( scene );\n\t\tthis._clip = null;\n\t\tthis._action = null;\n\n\t\tthis._tracks = {};\n\t\tthis._propRefs = {};\n\t\tthis._channelNames = [];\n\n\t};\n\n\tTHREE.TimelinerController.prototype = {\n\n\t\tconstructor: THREE.TimelinerController,\n\n\t\tinit: function () {\n\n\t\t\tvar tracks = [],\n\t\t\t\ttrackInfo = this._trackInfo;\n\n\t\t\tfor ( var i = 0, n = trackInfo.length; i !== n; ++ i ) {\n\n\t\t\t\tvar spec = trackInfo[ i ];\n\n\t\t\t\ttracks.push( this._addTrack( spec.type, spec.propertyPath, spec.initialValue, spec.interpolation ) );\n\n\t\t\t}\n\n\t\t\tthis._clip = new THREE.AnimationClip( 'editclip', 0, tracks );\n\t\t\tthis._action = this._mixer.clipAction( this._clip ).play();\n\n\t\t},\n\n\t\tsetDisplayTime: function ( time ) {\n\n\t\t\tthis._action.time = time;\n\t\t\tthis._mixer.update( 0 );\n\n\t\t\tthis._onUpdate();\n\n\t\t},\n\n\t\tsetDuration: function ( duration ) {\n\n\t\t\tthis._clip.duration = duration;\n\n\t\t},\n\n\t\tgetChannelNames: function () {\n\n\t\t\treturn this._channelNames;\n\n\t\t},\n\n\t\tgetChannelKeyTimes: function ( channelName ) {\n\n\t\t\treturn this._tracks[ channelName ].times;\n\n\t\t},\n\n\t\tsetKeyframe: function ( channelName, time ) {\n\n\t\t\tvar track = this._tracks[ channelName ],\n\t\t\t\ttimes = track.times,\n\t\t\t\tindex = Timeliner.binarySearch( times, time ),\n\t\t\t\tvalues = track.values,\n\t\t\t\tstride = track.getValueSize(),\n\t\t\t\toffset = index * stride;\n\n\t\t\tif ( index < 0 ) {\n\n\t\t\t\t// insert new keyframe\n\n\t\t\t\tindex = ~ index;\n\t\t\t\toffset = index * stride;\n\n\t\t\t\tvar nTimes = times.length + 1,\n\t\t\t\t\tnValues = values.length + stride;\n\n\t\t\t\tfor ( var i = nTimes - 1; i !== index; -- i ) {\n\n\t\t\t\t\ttimes[ i ] = times[ i - 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = nValues - 1, e = offset + stride - 1; i !== e; -- i ) {\n\n\t\t\t\t\tvalues[ i ] = values[ i - stride ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttimes[ index ] = time;\n\t\t\tthis._propRefs[ channelName ].getValue( values, offset );\n\n\t\t},\n\n\t\tdelKeyframe: function ( channelName, time ) {\n\n\t\t\tvar track = this._tracks[ channelName ],\n\t\t\t\ttimes = track.times,\n\t\t\t\tindex = Timeliner.binarySearch( times, time );\n\n\t\t\t// we disallow to remove the keyframe when it is the last one we have,\n\t\t\t// since the animation system is designed to always produce a defined\n\t\t\t// state\n\n\t\t\tif ( times.length > 1 && index >= 0 ) {\n\n\t\t\t\tvar nTimes = times.length - 1,\n\t\t\t\t\tvalues = track.values,\n\t\t\t\t\tstride = track.getValueSize(),\n\t\t\t\t\tnValues = values.length - stride;\n\n\t\t\t\t// note: no track.getValueSize when array sizes are out of sync\n\n\t\t\t\tfor ( var i = index; i !== nTimes; ++ i ) {\n\n\t\t\t\t\ttimes[ i ] = times[ i + 1 ];\n\n\t\t\t\t}\n\n\t\t\t\ttimes.pop();\n\n\t\t\t\tfor ( var offset = index * stride; offset !== nValues; ++ offset ) {\n\n\t\t\t\t\tvalues[ offset ] = values[ offset + stride ];\n\n\t\t\t\t}\n\n\t\t\t\tvalues.length = nValues;\n\n\t\t\t}\n\n\t\t},\n\n\t\tmoveKeyframe: function ( channelName, time, delta, moveRemaining ) {\n\n\t\t\tvar track = this._tracks[ channelName ],\n\t\t\t\ttimes = track.times,\n\t\t\t\tindex = Timeliner.binarySearch( times, time );\n\n\t\t\tif ( index >= 0 ) {\n\n\t\t\t\tvar endAt = moveRemaining ? times.length : index + 1,\n\t\t\t\t\tneedsSort = times[ index - 1 ] <= time ||\n\t\t\t\t\t\t! moveRemaining && time >= times[ index + 1 ];\n\n\t\t\t\twhile ( index !== endAt ) times[ index ++ ] += delta;\n\n\t\t\t\tif ( needsSort ) this._sort( track );\n\n\t\t\t}\n\n\t\t},\n\n\t\tserialize: function () {\n\n\t\t\tvar result = {\n\t\t\t\t\tduration: this._clip.duration,\n\t\t\t\t\tchannels: {}\n\t\t\t\t},\n\n\t\t\t\tnames = this._channelNames,\n\t\t\t\ttracks = this._tracks,\n\n\t\t\t\tchannels = result.channels;\n\n\t\t\tfor ( var i = 0, n = names.length; i !== n; ++ i ) {\n\n\t\t\t\tvar name = names[ i ],\n\t\t\t\t\ttrack = tracks[ name ];\n\n\t\t\t\tchannels[ name ] = {\n\n\t\t\t\t\ttimes: track.times,\n\t\t\t\t\tvalues: track.values\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\tdeserialize: function ( structs ) {\n\n\t\t\tvar names = this._channelNames,\n\t\t\t\ttracks = this._tracks,\n\n\t\t\t\tchannels = structs.channels;\n\n\t\t\tthis.setDuration( structs.duration );\n\n\t\t\tfor ( var i = 0, n = names.length; i !== n; ++ i ) {\n\n\t\t\t\tvar name = names[ i ],\n\t\t\t\t\ttrack = tracks[ name ],\n\t\t\t\t\tdata = channels[ name ];\n\n\t\t\t\tthis._setArray( track.times, data.times );\n\t\t\t\tthis._setArray( track.values, data.values );\n\n\t\t\t}\n\n\t\t\t// update display\n\t\t\tthis.setDisplayTime( this._mixer.time );\n\n\t\t},\n\n\t\t_sort: function ( track ) {\n\n\t\t\tvar times = track.times, order = THREE.AnimationUtils.getKeyframeOrder( times );\n\n\t\t\tthis._setArray( times, THREE.AnimationUtils.sortedArray( times, 1, order ) );\n\n\t\t\tvar values = track.values,\n\t\t\t\tstride = track.getValueSize();\n\n\t\t\tthis._setArray( values, THREE.AnimationUtils.sortedArray( values, stride, order ) );\n\n\t\t},\n\n\t\t_setArray: function ( dst, src ) {\n\n\t\t\tdst.length = 0;\n\t\t\tdst.push.apply( dst, src );\n\n\t\t},\n\n\t\t_addTrack: function ( type, prop, initialValue, interpolation ) {\n\n\t\t\tvar track = new type( prop, [ 0 ], initialValue, interpolation );\n\n\t\t\t// data must be in JS arrays so it can be resized\n\t\t\ttrack.times = Array.prototype.slice.call( track.times );\n\t\t\ttrack.values = Array.prototype.slice.call( track.values );\n\n\t\t\tthis._channelNames.push( prop );\n\t\t\tthis._tracks[ prop ] = track;\n\n\t\t\t// for recording the state:\n\t\t\tthis._propRefs[ prop ] =\n\t\t\t\t\tnew THREE.PropertyBinding( this._scene, prop );\n\n\t\t\treturn track;\n\n\t\t}\n\n\t};\n\n\treturn THREE.TimelinerController;\n});\n"]}