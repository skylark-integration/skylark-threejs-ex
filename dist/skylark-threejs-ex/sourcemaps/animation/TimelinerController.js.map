{"version":3,"sources":["animation/TimelinerController.js"],"names":["define","THREE","threex","TimelinerController","scene","trackInfo","onUpdate","this","_scene","_trackInfo","_onUpdate","_mixer","AnimationMixer","_clip","_action","_tracks","_propRefs","_channelNames","prototype","constructor","init","tracks","i","n","length","spec","push","_addTrack","type","propertyPath","initialValue","interpolation","AnimationClip","clipAction","play","setDisplayTime","time","update","setDuration","duration","getChannelNames","getChannelKeyTimes","channelName","times","setKeyframe","track","index","Timeliner","binarySearch","values","stride","getValueSize","offset","nTimes","nValues","e","getValue","delKeyframe","pop","moveKeyframe","delta","moveRemaining","endAt","needsSort","_sort","serialize","result","channels","names","name","deserialize","structs","data","_setArray","order","AnimationUtils","getKeyframeOrder","sortedArray","dst","src","apply","prop","Array","slice","call","PropertyBinding","animation"],"mappings":"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","file":"../../animation/TimelinerController.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var TimelinerController = function TimelinerController(scene, trackInfo, onUpdate) {\r\n        this._scene = scene;\r\n        this._trackInfo = trackInfo;\r\n        this._onUpdate = onUpdate;\r\n        this._mixer = new THREE.AnimationMixer(scene);\r\n        this._clip = null;\r\n        this._action = null;\r\n        this._tracks = {};\r\n        this._propRefs = {};\r\n        this._channelNames = [];\r\n    };\r\n    TimelinerController.prototype = {\r\n        constructor: TimelinerController,\r\n        init: function () {\r\n            var tracks = [], trackInfo = this._trackInfo;\r\n            for (var i = 0, n = trackInfo.length; i !== n; ++i) {\r\n                var spec = trackInfo[i];\r\n                tracks.push(this._addTrack(spec.type, spec.propertyPath, spec.initialValue, spec.interpolation));\r\n            }\r\n            this._clip = new THREE.AnimationClip('editclip', 0, tracks);\r\n            this._action = this._mixer.clipAction(this._clip).play();\r\n        },\r\n        setDisplayTime: function (time) {\r\n            this._action.time = time;\r\n            this._mixer.update(0);\r\n            this._onUpdate();\r\n        },\r\n        setDuration: function (duration) {\r\n            this._clip.duration = duration;\r\n        },\r\n        getChannelNames: function () {\r\n            return this._channelNames;\r\n        },\r\n        getChannelKeyTimes: function (channelName) {\r\n            return this._tracks[channelName].times;\r\n        },\r\n        setKeyframe: function (channelName, time) {\r\n            var track = this._tracks[channelName], times = track.times, index = Timeliner.binarySearch(times, time), values = track.values, stride = track.getValueSize(), offset = index * stride;\r\n            if (index < 0) {\r\n                index = ~index;\r\n                offset = index * stride;\r\n                var nTimes = times.length + 1, nValues = values.length + stride;\r\n                for (var i = nTimes - 1; i !== index; --i) {\r\n                    times[i] = times[i - 1];\r\n                }\r\n                for (var i = nValues - 1, e = offset + stride - 1; i !== e; --i) {\r\n                    values[i] = values[i - stride];\r\n                }\r\n            }\r\n            times[index] = time;\r\n            this._propRefs[channelName].getValue(values, offset);\r\n        },\r\n        delKeyframe: function (channelName, time) {\r\n            var track = this._tracks[channelName], times = track.times, index = Timeliner.binarySearch(times, time);\r\n            if (times.length > 1 && index >= 0) {\r\n                var nTimes = times.length - 1, values = track.values, stride = track.getValueSize(), nValues = values.length - stride;\r\n                for (var i = index; i !== nTimes; ++i) {\r\n                    times[i] = times[i + 1];\r\n                }\r\n                times.pop();\r\n                for (var offset = index * stride; offset !== nValues; ++offset) {\r\n                    values[offset] = values[offset + stride];\r\n                }\r\n                values.length = nValues;\r\n            }\r\n        },\r\n        moveKeyframe: function (channelName, time, delta, moveRemaining) {\r\n            var track = this._tracks[channelName], times = track.times, index = Timeliner.binarySearch(times, time);\r\n            if (index >= 0) {\r\n                var endAt = moveRemaining ? times.length : index + 1, needsSort = times[index - 1] <= time || !moveRemaining && time >= times[index + 1];\r\n                while (index !== endAt)\r\n                    times[index++] += delta;\r\n                if (needsSort)\r\n                    this._sort(track);\r\n            }\r\n        },\r\n        serialize: function () {\r\n            var result = {\r\n                    duration: this._clip.duration,\r\n                    channels: {}\r\n                }, names = this._channelNames, tracks = this._tracks, channels = result.channels;\r\n            for (var i = 0, n = names.length; i !== n; ++i) {\r\n                var name = names[i], track = tracks[name];\r\n                channels[name] = {\r\n                    times: track.times,\r\n                    values: track.values\r\n                };\r\n            }\r\n            return result;\r\n        },\r\n        deserialize: function (structs) {\r\n            var names = this._channelNames, tracks = this._tracks, channels = structs.channels;\r\n            this.setDuration(structs.duration);\r\n            for (var i = 0, n = names.length; i !== n; ++i) {\r\n                var name = names[i], track = tracks[name], data = channels[name];\r\n                this._setArray(track.times, data.times);\r\n                this._setArray(track.values, data.values);\r\n            }\r\n            this.setDisplayTime(this._mixer.time);\r\n        },\r\n        _sort: function (track) {\r\n            var times = track.times, order = THREE.AnimationUtils.getKeyframeOrder(times);\r\n            this._setArray(times, THREE.AnimationUtils.sortedArray(times, 1, order));\r\n            var values = track.values, stride = track.getValueSize();\r\n            this._setArray(values, THREE.AnimationUtils.sortedArray(values, stride, order));\r\n        },\r\n        _setArray: function (dst, src) {\r\n            dst.length = 0;\r\n            dst.push.apply(dst, src);\r\n        },\r\n        _addTrack: function (type, prop, initialValue, interpolation) {\r\n            var track = new type(prop, [0], initialValue, interpolation);\r\n            track.times = Array.prototype.slice.call(track.times);\r\n            track.values = Array.prototype.slice.call(track.values);\r\n            this._channelNames.push(prop);\r\n            this._tracks[prop] = track;\r\n            this._propRefs[prop] = new THREE.PropertyBinding(this._scene, prop);\r\n            return track;\r\n        }\r\n    };\r\n\r\n    return threex.animation.TimelinerController = TimelinerController;\r\n});"]}