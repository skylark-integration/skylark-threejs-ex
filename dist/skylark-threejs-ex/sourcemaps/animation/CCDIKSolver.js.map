{"version":3,"sources":["animation/CCDIKSolver.js"],"names":["define","THREE","CCDIKSolver","mesh","iks","this","_valid","q","targetPos","targetVec","effectorPos","effectorVec","linkPos","invLinkQ","linkScale","axis","vector","CCDIKHelper","Object3D","call","root","matrix","copy","matrixWorld","matrixAutoUpdate","sphereGeometry","SphereBufferGeometry","targetSphereMaterial","MeshBasicMaterial","color","Color","depthTest","depthWrite","transparent","effectorSphereMaterial","linkSphereMaterial","lineMaterial","LineBasicMaterial","_init","prototype","constructor","update","Quaternion","Vector3","bones","skeleton","math","Math","i","il","length","ik","effector","target","setFromMatrixPosition","links","iteration","undefined","j","rotated","k","kl","link","index","enabled","limitation","rotationMin","rotationMax","decompose","inverse","subVectors","applyQuaternion","normalize","angle","dot","acos","minAngle","maxAngle","crossVectors","setFromAxisAngle","quaternion","multiply","c","w","c2","sqrt","set","x","y","z","rotation","setFromVector3","toVector3","max","min","updateMatrixWorld","createHelper","geometry","userData","MMD","link0","link1","jl","parent","console","warn","name","Object","assign","create","Matrix4","getPosition","bone","matrixWorldInv","applyMatrix4","setPositionOfBoneToAttributeArray","array","v","force","visible","offset","getInverse","targetBone","effectorBone","targetMesh","children","effectorMesh","position","linkBone","line","attributes","needsUpdate","self","createLine","Line","BufferGeometry","vertices","Float32Array","setAttribute","BufferAttribute","createLineGeometry","add","Mesh"],"mappings":"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","file":"../../animation/CCDIKSolver.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author takahiro / https://github.com/takahirox\n\t *\n\t * CCD Algorithm\n\t *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\n\t *\n\t * // ik parameter example\n\t * //\n\t * // target, effector, index in links are bone index in skeleton.bones.\n\t * // the bones relation should be\n\t * // <-- parent                                  child -->\n\t * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\n\t * iks = [ {\n\t *\ttarget: 1,\n\t *\teffector: 2,\n\t *\tlinks: [ { index: 5, limitation: new THREE.Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\n\t *\titeration: 10,\n\t *\tminAngle: 0.0,\n\t *\tmaxAngle: 1.0,\n\t * } ];\n\t */\n\n\tTHREE.CCDIKSolver = ( function () {\n\n\t\t/**\n\t\t * @param {THREE.SkinnedMesh} mesh\n\t\t * @param {Array<Object>} iks\n\t\t */\n\t\tfunction CCDIKSolver( mesh, iks ) {\n\n\t\t\tthis.mesh = mesh;\n\t\t\tthis.iks = iks || [];\n\n\t\t\tthis._valid();\n\n\t\t}\n\n\t\tCCDIKSolver.prototype = {\n\n\t\t\tconstructor: CCDIKSolver,\n\n\t\t\t/**\n\t\t\t * Update IK bones.\n\t\t\t *\n\t\t\t * @return {THREE.CCDIKSolver}\n\t\t\t */\n\t\t\tupdate: function () {\n\n\t\t\t\tvar q = new THREE.Quaternion();\n\t\t\t\tvar targetPos = new THREE.Vector3();\n\t\t\t\tvar targetVec = new THREE.Vector3();\n\t\t\t\tvar effectorPos = new THREE.Vector3();\n\t\t\t\tvar effectorVec = new THREE.Vector3();\n\t\t\t\tvar linkPos = new THREE.Vector3();\n\t\t\t\tvar invLinkQ = new THREE.Quaternion();\n\t\t\t\tvar linkScale = new THREE.Vector3();\n\t\t\t\tvar axis = new THREE.Vector3();\n\t\t\t\tvar vector = new THREE.Vector3();\n\n\t\t\t\treturn function update() {\n\n\t\t\t\t\tvar bones = this.mesh.skeleton.bones;\n\t\t\t\t\tvar iks = this.iks;\n\n\t\t\t\t\t// for reference overhead reduction in loop\n\t\t\t\t\tvar math = Math;\n\n\t\t\t\t\tfor ( var i = 0, il = iks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar ik = iks[ i ];\n\t\t\t\t\t\tvar effector = bones[ ik.effector ];\n\t\t\t\t\t\tvar target = bones[ ik.target ];\n\n\t\t\t\t\t\t// don't use getWorldPosition() here for the performance\n\t\t\t\t\t\t// because it calls updateMatrixWorld( true ) inside.\n\t\t\t\t\t\ttargetPos.setFromMatrixPosition( target.matrixWorld );\n\n\t\t\t\t\t\tvar links = ik.links;\n\t\t\t\t\t\tvar iteration = ik.iteration !== undefined ? ik.iteration : 1;\n\n\t\t\t\t\t\tfor ( var j = 0; j < iteration; j ++ ) {\n\n\t\t\t\t\t\t\tvar rotated = false;\n\n\t\t\t\t\t\t\tfor ( var k = 0, kl = links.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\t\t\tvar link = bones[ links[ k ].index ];\n\n\t\t\t\t\t\t\t\t// skip this link and following links.\n\t\t\t\t\t\t\t\t// this skip is used for MMD performance optimization.\n\t\t\t\t\t\t\t\tif ( links[ k ].enabled === false ) break;\n\n\t\t\t\t\t\t\t\tvar limitation = links[ k ].limitation;\n\t\t\t\t\t\t\t\tvar rotationMin = links[ k ].rotationMin;\n\t\t\t\t\t\t\t\tvar rotationMax = links[ k ].rotationMax;\n\n\t\t\t\t\t\t\t\t// don't use getWorldPosition/Quaternion() here for the performance\n\t\t\t\t\t\t\t\t// because they call updateMatrixWorld( true ) inside.\n\t\t\t\t\t\t\t\tlink.matrixWorld.decompose( linkPos, invLinkQ, linkScale );\n\t\t\t\t\t\t\t\tinvLinkQ.inverse();\n\t\t\t\t\t\t\t\teffectorPos.setFromMatrixPosition( effector.matrixWorld );\n\n\t\t\t\t\t\t\t\t// work in link world\n\t\t\t\t\t\t\t\teffectorVec.subVectors( effectorPos, linkPos );\n\t\t\t\t\t\t\t\teffectorVec.applyQuaternion( invLinkQ );\n\t\t\t\t\t\t\t\teffectorVec.normalize();\n\n\t\t\t\t\t\t\t\ttargetVec.subVectors( targetPos, linkPos );\n\t\t\t\t\t\t\t\ttargetVec.applyQuaternion( invLinkQ );\n\t\t\t\t\t\t\t\ttargetVec.normalize();\n\n\t\t\t\t\t\t\t\tvar angle = targetVec.dot( effectorVec );\n\n\t\t\t\t\t\t\t\tif ( angle > 1.0 ) {\n\n\t\t\t\t\t\t\t\t\tangle = 1.0;\n\n\t\t\t\t\t\t\t\t} else if ( angle < - 1.0 ) {\n\n\t\t\t\t\t\t\t\t\tangle = - 1.0;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tangle = math.acos( angle );\n\n\t\t\t\t\t\t\t\t// skip if changing angle is too small to prevent vibration of bone\n\t\t\t\t\t\t\t\t// Refer to http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n\t\t\t\t\t\t\t\tif ( angle < 1e-5 ) continue;\n\n\t\t\t\t\t\t\t\tif ( ik.minAngle !== undefined && angle < ik.minAngle ) {\n\n\t\t\t\t\t\t\t\t\tangle = ik.minAngle;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( ik.maxAngle !== undefined && angle > ik.maxAngle ) {\n\n\t\t\t\t\t\t\t\t\tangle = ik.maxAngle;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\taxis.crossVectors( effectorVec, targetVec );\n\t\t\t\t\t\t\t\taxis.normalize();\n\n\t\t\t\t\t\t\t\tq.setFromAxisAngle( axis, angle );\n\t\t\t\t\t\t\t\tlink.quaternion.multiply( q );\n\n\t\t\t\t\t\t\t\t// TODO: re-consider the limitation specification\n\t\t\t\t\t\t\t\tif ( limitation !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tvar c = link.quaternion.w;\n\n\t\t\t\t\t\t\t\t\tif ( c > 1.0 ) c = 1.0;\n\n\t\t\t\t\t\t\t\t\tvar c2 = math.sqrt( 1 - c * c );\n\t\t\t\t\t\t\t\t\tlink.quaternion.set( limitation.x * c2,\n\t\t\t\t\t\t\t\t\t                     limitation.y * c2,\n\t\t\t\t\t\t\t\t\t                     limitation.z * c2,\n\t\t\t\t\t\t\t\t\t                     c );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( rotationMin !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tlink.rotation.setFromVector3(\n\t\t\t\t\t\t\t\t\t\tlink.rotation\n\t\t\t\t\t\t\t\t\t\t\t.toVector3( vector )\n\t\t\t\t\t\t\t\t\t\t\t.max( rotationMin ) );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( rotationMax !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tlink.rotation.setFromVector3(\n\t\t\t\t\t\t\t\t\t\tlink.rotation\n\t\t\t\t\t\t\t\t\t\t\t.toVector3( vector )\n\t\t\t\t\t\t\t\t\t\t\t.min( rotationMax ) );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tlink.updateMatrixWorld( true );\n\n\t\t\t\t\t\t\t\trotated = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( ! rotated ) break;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t};\n\n\t\t\t}(),\n\n\t\t\t/**\n\t\t\t * Creates Helper\n\t\t\t *\n\t\t\t * @return {CCDIKHelper}\n\t\t\t */\n\t\t\tcreateHelper: function () {\n\n\t\t\t\treturn new CCDIKHelper( this.mesh, this.mesh.geometry.userData.MMD.iks );\n\n\t\t\t},\n\n\t\t\t// private methods\n\n\t\t\t_valid: function () {\n\n\t\t\t\tvar iks = this.iks;\n\t\t\t\tvar bones = this.mesh.skeleton.bones;\n\n\t\t\t\tfor ( var i = 0, il = iks.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar ik = iks[ i ];\n\t\t\t\t\tvar effector = bones[ ik.effector ];\n\t\t\t\t\tvar links = ik.links;\n\t\t\t\t\tvar link0, link1;\n\n\t\t\t\t\tlink0 = effector;\n\n\t\t\t\t\tfor ( var j = 0, jl = links.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tlink1 = bones[ links[ j ].index ];\n\n\t\t\t\t\t\tif ( link0.parent !== link1 ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.CCDIKSolver: bone ' + link0.name + ' is not the child of bone ' + link1.name );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlink0 = link1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\t/**\n\t\t * Visualize IK bones\n\t\t *\n\t\t * @param {SkinnedMesh} mesh\n\t\t * @param {Array<Object>} iks\n\t\t */\n\t\tfunction CCDIKHelper( mesh, iks ) {\n\n\t\t\tTHREE.Object3D.call( this );\n\n\t\t\tthis.root = mesh;\n\t\t\tthis.iks = iks || [];\n\n\t\t\tthis.matrix.copy( mesh.matrixWorld );\n\t\t\tthis.matrixAutoUpdate = false;\n\n\t\t\tthis.sphereGeometry = new THREE.SphereBufferGeometry( 0.25, 16, 8 );\n\n\t\t\tthis.targetSphereMaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\tcolor: new THREE.Color( 0xff8888 ),\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\ttransparent: true\n\t\t\t} );\n\n\t\t\tthis.effectorSphereMaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\tcolor: new THREE.Color( 0x88ff88 ),\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\ttransparent: true\n\t\t\t} );\n\n\t\t\tthis.linkSphereMaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\tcolor: new THREE.Color( 0x8888ff ),\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\ttransparent: true\n\t\t\t} );\n\n\t\t\tthis.lineMaterial = new THREE.LineBasicMaterial( {\n\t\t\t\tcolor: new THREE.Color( 0xff0000 ),\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\ttransparent: true\n\t\t\t} );\n\n\t\t\tthis._init();\n\n\t\t}\n\n\t\tCCDIKHelper.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\t\t\tconstructor: CCDIKHelper,\n\n\t\t\t/**\n\t\t\t * Updates IK bones visualization.\n\t\t\t */\n\t\t\tupdateMatrixWorld: function () {\n\n\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\tvar vector = new THREE.Vector3();\n\n\t\t\t\tfunction getPosition( bone, matrixWorldInv ) {\n\n\t\t\t\t\treturn vector\n\t\t\t\t\t\t.setFromMatrixPosition( bone.matrixWorld )\n\t\t\t\t\t\t.applyMatrix4( matrixWorldInv );\n\n\t\t\t\t}\n\n\t\t\t\tfunction setPositionOfBoneToAttributeArray( array, index, bone, matrixWorldInv ) {\n\n\t\t\t\t\tvar v = getPosition( bone, matrixWorldInv );\n\n\t\t\t\t\tarray[ index * 3 + 0 ] = v.x;\n\t\t\t\t\tarray[ index * 3 + 1 ] = v.y;\n\t\t\t\t\tarray[ index * 3 + 2 ] = v.z;\n\n\t\t\t\t}\n\n\t\t\t\treturn function updateMatrixWorld( force ) {\n\n\t\t\t\t\tvar mesh = this.root;\n\n\t\t\t\t\tif ( this.visible ) {\n\n\t\t\t\t\t\tvar offset = 0;\n\n\t\t\t\t\t\tvar iks = this.iks;\n\t\t\t\t\t\tvar bones = mesh.skeleton.bones;\n\n\t\t\t\t\t\tmatrix.getInverse( mesh.matrixWorld );\n\n\t\t\t\t\t\tfor ( var i = 0, il = iks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tvar ik = iks[ i ];\n\n\t\t\t\t\t\t\tvar targetBone = bones[ ik.target ];\n\t\t\t\t\t\t\tvar effectorBone = bones[ ik.effector ];\n\n\t\t\t\t\t\t\tvar targetMesh = this.children[ offset ++ ];\n\t\t\t\t\t\t\tvar effectorMesh = this.children[ offset ++ ];\n\n\t\t\t\t\t\t\ttargetMesh.position.copy( getPosition( targetBone, matrix ) );\n\t\t\t\t\t\t\teffectorMesh.position.copy( getPosition( effectorBone, matrix ) );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = ik.links.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar link = ik.links[ j ];\n\t\t\t\t\t\t\t\tvar linkBone = bones[ link.index ];\n\n\t\t\t\t\t\t\t\tvar linkMesh = this.children[ offset ++ ];\n\n\t\t\t\t\t\t\t\tlinkMesh.position.copy( getPosition( linkBone, matrix ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar line = this.children[ offset ++ ];\n\t\t\t\t\t\t\tvar array = line.geometry.attributes.position.array;\n\n\t\t\t\t\t\t\tsetPositionOfBoneToAttributeArray( array, 0, targetBone, matrix );\n\t\t\t\t\t\t\tsetPositionOfBoneToAttributeArray( array, 1, effectorBone, matrix );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = ik.links.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar link = ik.links[ j ];\n\t\t\t\t\t\t\t\tvar linkBone = bones[ link.index ];\n\t\t\t\t\t\t\t\tsetPositionOfBoneToAttributeArray( array, j + 2, linkBone, matrix );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tline.geometry.attributes.position.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.matrix.copy( mesh.matrixWorld );\n\n\t\t\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\n\n\t\t\t\t};\n\n\t\t\t}(),\n\n\t\t\t// private method\n\n\t\t\t_init: function () {\n\n\t\t\t\tvar self = this;\n\t\t\t\tvar iks = this.iks;\n\n\t\t\t\tfunction createLineGeometry( ik ) {\n\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\t\tvar vertices = new Float32Array( ( 2 + ik.links.length ) * 3 );\n\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t\tfunction createTargetMesh() {\n\n\t\t\t\t\treturn new THREE.Mesh( self.sphereGeometry, self.targetSphereMaterial );\n\n\t\t\t\t}\n\n\t\t\t\tfunction createEffectorMesh() {\n\n\t\t\t\t\treturn new THREE.Mesh( self.sphereGeometry, self.effectorSphereMaterial );\n\n\t\t\t\t}\n\n\t\t\t\tfunction createLinkMesh() {\n\n\t\t\t\t\treturn new THREE.Mesh( self.sphereGeometry, self.linkSphereMaterial );\n\n\t\t\t\t}\n\n\t\t\t\tfunction createLine( ik ) {\n\n\t\t\t\t\treturn new THREE.Line( createLineGeometry( ik ), self.lineMaterial );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, il = iks.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar ik = iks[ i ];\n\n\t\t\t\t\tthis.add( createTargetMesh() );\n\t\t\t\t\tthis.add( createEffectorMesh() );\n\n\t\t\t\t\tfor ( var j = 0, jl = ik.links.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tthis.add( createLinkMesh() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.add( createLine( ik ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn CCDIKSolver;\n\n\t} )();\n\n\treturn THREE.CCDIKSolver;\n});\n"]}