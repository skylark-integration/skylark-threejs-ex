{"version":3,"sources":["physics/CannonPhysics.js"],"names":["define","THREE","threex","compose","position","quaternion","array","index","x","y","z","w","x2","y2","z2","xx","xy","xz","yy","yz","zz","wx","wy","wz","physics","CannonPhysics","frameRate","frameTime","world","CANNON","World","gravity","set","broadphase","SAPBroadphase","meshes","meshMap","WeakMap","lastTime","setInterval","time","performance","now","delta","step","i","l","length","mesh","isInstancedMesh","instanceMatrix","bodies","get","j","body","needsUpdate","isMesh","copy","addMesh","mass","shape","geometry","parameters","type","halfExtents","Vec3","undefined","width","height","depth","Box","Plane","radius","Sphere","getShape","count","Body","addBody","push","setUsage","handleInstancedMesh","Quaternion","handleMesh","setMeshPosition"],"mappings":"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","file":"../../physics/CannonPhysics.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    function compose(position, quaternion, array, index) {\n        var x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;\n        var x2 = x + x, y2 = y + y, z2 = z + z;\n        var xx = x * x2, xy = x * y2, xz = x * z2;\n        var yy = y * y2, yz = y * z2, zz = z * z2;\n        var wx = w * x2, wy = w * y2, wz = w * z2;\n        array[index + 0] = 1 - (yy + zz);\n        array[index + 1] = xy + wz;\n        array[index + 2] = xz - wy;\n        array[index + 3] = 0;\n        array[index + 4] = xy - wz;\n        array[index + 5] = 1 - (xx + zz);\n        array[index + 6] = yz + wx;\n        array[index + 7] = 0;\n        array[index + 8] = xz + wy;\n        array[index + 9] = yz - wx;\n        array[index + 10] = 1 - (xx + yy);\n        array[index + 11] = 0;\n        array[index + 12] = position.x;\n        array[index + 13] = position.y;\n        array[index + 14] = position.z;\n        array[index + 15] = 1;\n    }\n    function CannonPhysics() {\n        var frameRate = 60;\n        var frameTime = 1 / frameRate;\n        var world = new CANNON.World();\n        world.gravity.set(0, -9.8, 0);\n        world.broadphase = new CANNON.SAPBroadphase(world);\n        function getShape(geometry) {\n            var parameters = geometry.parameters;\n            switch (geometry.type) {\n            case 'BoxBufferGeometry':\n                var halfExtents = new CANNON.Vec3();\n                halfExtents.x = parameters.width !== undefined ? parameters.width / 2 : 0.5;\n                halfExtents.y = parameters.height !== undefined ? parameters.height / 2 : 0.5;\n                halfExtents.z = parameters.depth !== undefined ? parameters.depth / 2 : 0.5;\n                return new CANNON.Box(halfExtents);\n            case 'PlaneBufferGeometry':\n                return new CANNON.Plane();\n            case 'SphereBufferGeometry':\n                var radius = parameters.radius;\n                return new CANNON.Sphere(radius);\n            }\n            return null;\n        }\n        var meshes = [];\n        var meshMap = new WeakMap();\n        function addMesh(mesh, mass = 0) {\n            var shape = getShape(mesh.geometry);\n            if (shape !== null) {\n                if (mesh.isInstancedMesh) {\n                    handleInstancedMesh(mesh, mass, shape);\n                } else if (mesh.isMesh) {\n                    handleMesh(mesh, mass, shape);\n                }\n            }\n        }\n        function handleMesh(mesh, mass, shape) {\n            var position = new CANNON.Vec3();\n            position.copy(mesh.position);\n            var quaternion = new CANNON.Quaternion();\n            quaternion.copy(mesh.quaternion);\n            var body = new CANNON.Body({\n                position: position,\n                quaternion: quaternion,\n                mass: mass,\n                shape: shape\n            });\n            world.addBody(body);\n            if (mass > 0) {\n                meshes.push(mesh);\n                meshMap.set(mesh, body);\n            }\n        }\n        function handleInstancedMesh(mesh, mass, shape) {\n            var array = mesh.instanceMatrix.array;\n            var bodies = [];\n            for (var i = 0; i < mesh.count; i++) {\n                var index = i * 16;\n                var position = new CANNON.Vec3();\n                position.set(array[index + 12], array[index + 13], array[index + 14]);\n                var body = new CANNON.Body({\n                    position: position,\n                    mass: mass,\n                    shape: shape\n                });\n                world.addBody(body);\n                bodies.push(body);\n            }\n            if (mass > 0) {\n                mesh.instanceMatrix.setUsage(35048);\n                meshes.push(mesh);\n                meshMap.set(mesh, bodies);\n            }\n        }\n        function setMeshPosition(mesh, position, index = 0) {\n            if (mesh.isInstancedMesh) {\n                var bodies = meshMap.get(mesh);\n                bodies[index].position.copy(position);\n            } else if (mesh.isMesh) {\n                var body = meshMap.get(mesh);\n                body.position.copy(position);\n            }\n        }\n        var lastTime = 0;\n        function step() {\n            var time = performance.now();\n            if (lastTime > 0) {\n                var delta = (time - lastTime) / 1000;\n                world.step(frameTime, delta, frameRate);\n            }\n            lastTime = time;\n            for (var i = 0, l = meshes.length; i < l; i++) {\n                var mesh = meshes[i];\n                if (mesh.isInstancedMesh) {\n                    var array = mesh.instanceMatrix.array;\n                    var bodies = meshMap.get(mesh);\n                    for (var j = 0; j < bodies.length; j++) {\n                        var body = bodies[j];\n                        compose(body.position, body.quaternion, array, j * 16);\n                    }\n                    mesh.instanceMatrix.needsUpdate = true;\n                } else if (mesh.isMesh) {\n                    var body = meshMap.get(mesh);\n                    mesh.position.copy(body.position);\n                    mesh.quaternion.copy(body.quaternion);\n                }\n            }\n        }\n        setInterval(step, 1000 / frameRate);\n        return {\n            addMesh: addMesh,\n            setMeshPosition: setMeshPosition\n        };\n    }\n    return threex.physics.CannonPhysics = CannonPhysics;\n});"]}