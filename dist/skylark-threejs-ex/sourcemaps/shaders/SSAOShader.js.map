{"version":3,"sources":["shaders/SSAOShader.js"],"names":["define","THREE","threex","SSAOShader","defines","PERSPECTIVE_CAMERA","KERNEL_SIZE","uniforms","tDiffuse","value","tNormal","tDepth","tNoise","kernel","cameraNear","cameraFar","resolution","Vector2","cameraProjectionMatrix","Matrix4","cameraInverseProjectionMatrix","kernelRadius","minDistance","maxDistance","vertexShader","join","fragmentShader","shaders"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,GACAC,SACIC,mBAAsB,EACtBC,YAAe,IAEnBC,UACIC,UAAcC,MAAO,MACrBC,SAAaD,MAAO,MACpBE,QAAYF,MAAO,MACnBG,QAAYH,MAAO,MACnBI,QAAYJ,MAAO,MACnBK,YAAgBL,MAAO,MACvBM,WAAeN,MAAO,MACtBO,YAAgBP,MAAO,IAAIR,EAAMgB,SACjCC,wBAA4BT,MAAO,IAAIR,EAAMkB,SAC7CC,+BAAmCX,MAAO,IAAIR,EAAMkB,SACpDE,cAAkBZ,MAAO,GACzBa,aAAiBb,MAAO,MACxBc,aAAiBd,MAAO,MAE5Be,cACI,oBACA,gBACA,cACA,8EACA,KACFC,KAAK,MACPC,gBACI,8BACA,6BACA,4BACA,4BACA,sCACA,2BACA,4BACA,2BACA,uCACA,8CACA,8BACA,6BACA,6BACA,oBACA,qBACA,mDACA,kDACA,IACA,yDACA,gCACA,gEACA,kFACA,uEACA,UACA,iDACA,WACA,IACA,2CACA,gCACA,sEACA,UACA,uEACA,WACA,IACA,qGACA,uFACA,oFACA,4CACA,iEACA,IACA,uDACA,0EACA,IACA,gBACA,mCACA,qCACA,8DACA,4CACA,qEACA,6DACA,iFACA,mDACA,gEACA,0BACA,8CACA,sDACA,yEACA,+EACA,0CACA,0DACA,yDACA,4FACA,6CACA,0DACA,0BACA,QACA,MACA,qEACA,yDACA,KACFD,KAAK,OAGX,OAAOvB,EAAOyB,QAAQxB,WAAaA","file":"../../shaders/SSAOShader.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var SSAOShader = {\r\n        defines: {\r\n            'PERSPECTIVE_CAMERA': 1,\r\n            'KERNEL_SIZE': 32\r\n        },\r\n        uniforms: {\r\n            'tDiffuse': { value: null },\r\n            'tNormal': { value: null },\r\n            'tDepth': { value: null },\r\n            'tNoise': { value: null },\r\n            'kernel': { value: null },\r\n            'cameraNear': { value: null },\r\n            'cameraFar': { value: null },\r\n            'resolution': { value: new THREE.Vector2() },\r\n            'cameraProjectionMatrix': { value: new THREE.Matrix4() },\r\n            'cameraInverseProjectionMatrix': { value: new THREE.Matrix4() },\r\n            'kernelRadius': { value: 8 },\r\n            'minDistance': { value: 0.005 },\r\n            'maxDistance': { value: 0.05 }\r\n        },\r\n        vertexShader: [\r\n            'varying vec2 vUv;',\r\n            'void main() {',\r\n            '\\tvUv = uv;',\r\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            'uniform sampler2D tDiffuse;',\r\n            'uniform sampler2D tNormal;',\r\n            'uniform sampler2D tDepth;',\r\n            'uniform sampler2D tNoise;',\r\n            'uniform vec3 kernel[ KERNEL_SIZE ];',\r\n            'uniform vec2 resolution;',\r\n            'uniform float cameraNear;',\r\n            'uniform float cameraFar;',\r\n            'uniform mat4 cameraProjectionMatrix;',\r\n            'uniform mat4 cameraInverseProjectionMatrix;',\r\n            'uniform float kernelRadius;',\r\n            'uniform float minDistance;',\r\n            'uniform float maxDistance;',\r\n            'varying vec2 vUv;',\r\n            '#include <packing>',\r\n            'float getDepth( const in vec2 screenPosition ) {',\r\n            '\\treturn texture2D( tDepth, screenPosition ).x;',\r\n            '}',\r\n            'float getLinearDepth( const in vec2 screenPosition ) {',\r\n            '\\t#if PERSPECTIVE_CAMERA == 1',\r\n            '\\t\\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;',\r\n            '\\t\\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );',\r\n            '\\t\\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );',\r\n            '\\t#else',\r\n            '\\t\\treturn texture2D( depthSampler, coord ).x;',\r\n            '\\t#endif',\r\n            '}',\r\n            'float getViewZ( const in float depth ) {',\r\n            '\\t#if PERSPECTIVE_CAMERA == 1',\r\n            '\\t\\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );',\r\n            '\\t#else',\r\n            '\\t\\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );',\r\n            '\\t#endif',\r\n            '}',\r\n            'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {',\r\n            '\\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];',\r\n            '\\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );',\r\n            '\\tclipPosition *= clipW; // unprojection.',\r\n            '\\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;',\r\n            '}',\r\n            'vec3 getViewNormal( const in vec2 screenPosition ) {',\r\n            '\\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );',\r\n            '}',\r\n            'void main() {',\r\n            '\\tfloat depth = getDepth( vUv );',\r\n            '\\tfloat viewZ = getViewZ( depth );',\r\n            '\\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );',\r\n            '\\tvec3 viewNormal = getViewNormal( vUv );',\r\n            ' vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );',\r\n            '\\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;',\r\n            '\\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );',\r\n            '\\tvec3 bitangent = cross( viewNormal, tangent );',\r\n            '\\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );',\r\n            ' float occlusion = 0.0;',\r\n            ' for ( int i = 0; i < KERNEL_SIZE; i ++ ) {',\r\n            '\\t\\tvec3 sampleVector = kernelMatrix * kernel[ i ];',\r\n            '\\t\\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );',\r\n            '\\t\\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );',\r\n            '\\t\\tsamplePointNDC /= samplePointNDC.w;',\r\n            '\\t\\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;',\r\n            '\\t\\tfloat realDepth = getLinearDepth( samplePointUv );',\r\n            '\\t\\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );',\r\n            '\\t\\tfloat delta = sampleDepth - realDepth;',\r\n            '\\t\\tif ( delta > minDistance && delta < maxDistance ) {',\r\n            '\\t\\t\\tocclusion += 1.0;',\r\n            '\\t\\t}',\r\n            '\\t}',\r\n            '\\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );',\r\n            '\\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n\r\n    return threex.shaders.SSAOShader = SSAOShader;\r\n});"]}