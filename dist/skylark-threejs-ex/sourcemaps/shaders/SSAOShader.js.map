{"version":3,"sources":["shaders/SSAOShader.js"],"names":["define","THREE","SSAOShader","defines","PERSPECTIVE_CAMERA","KERNEL_SIZE","uniforms","tDiffuse","value","tNormal","tDepth","tNoise","kernel","cameraNear","cameraFar","resolution","Vector2","cameraProjectionMatrix","Matrix4","cameraInverseProjectionMatrix","kernelRadius","minDistance","maxDistance","vertexShader","join","fragmentShader","SSAODepthShader","SSAOBlurShader"],"mappings":";;;;;;;AAAAA,QACC,mBACC,SAASC,GAySV,OA/RAA,EAAMC,YAELC,SACCC,mBAAsB,EACtBC,YAAe,IAGhBC,UAECC,UAAcC,MAAO,MACrBC,SAAaD,MAAO,MACpBE,QAAYF,MAAO,MACnBG,QAAYH,MAAO,MACnBI,QAAYJ,MAAO,MACnBK,YAAgBL,MAAO,MACvBM,WAAeN,MAAO,MACtBO,YAAgBP,MAAO,IAAIP,EAAMe,SACjCC,wBAA4BT,MAAO,IAAIP,EAAMiB,SAC7CC,+BAAmCX,MAAO,IAAIP,EAAMiB,SACpDE,cAAkBZ,MAAO,GACzBa,aAAiBb,MAAO,MACxBc,aAAiBd,MAAO,MAIzBe,cAEC,oBAEA,gBAEA,cAEA,8EAEA,KAECC,KAAM,MAERC,gBAEC,8BACA,6BACA,4BACA,4BAEA,sCAEA,2BAEA,4BACA,2BACA,uCACA,8CAEA,8BACA,6BACA,6BAEA,oBAEA,qBAEA,mDAEA,kDAEA,IAEA,yDAEA,gCAEA,gEACA,kFACA,uEAEA,UAEA,iDAEA,WAEA,IAEA,2CAEA,gCAEA,sEAEA,UAEA,uEAEA,WAEA,IAEA,qGAEA,uFAEA,oFAEA,4CAEA,iEAEA,IAEA,uDAEA,0EAEA,IAEA,gBAEA,mCACA,qCAEA,8DACA,4CAEA,qEACA,6DAIA,iFACA,mDACA,gEAEA,0BAEA,8CAEA,sDACA,yEAEA,+EACA,0CAEA,0DAEA,yDACA,4FACA,6CAEA,0DAEA,0BAEA,QAEA,MAEA,qEAEA,yDAEA,KAECD,KAAM,OAITvB,EAAMyB,iBAELvB,SACCC,mBAAsB,GAGvBE,UAECI,QAAYF,MAAO,MACnBK,YAAgBL,MAAO,MACvBM,WAAeN,MAAO,OAIvBe,cAEC,oBAEA,gBAEA,cACA,8EAEA,KAECC,KAAM,MAERC,gBAEC,4BAEA,4BACA,2BAEA,oBAEA,qBAEA,yDAEA,gCAEA,gEACA,kFACA,uEAEA,UAEA,iDAEA,WAEA,IAEA,gBAEA,yCACA,qDAEA,KAECD,KAAM,OAITvB,EAAM0B,gBAELrB,UAECC,UAAcC,MAAO,MACrBO,YAAgBP,MAAO,IAAIP,EAAMe,UAIlCO,cAEC,oBAEA,gBAEA,cACA,8EAEA,KAECC,KAAM,MAERC,gBAEC,8BAEA,2BAEA,oBAEA,gBAEA,2CACA,wBAEA,wCAEA,0CAEA,sEACA,yDAEA,QAEA,MAEA,gEAEA,KAECD,KAAM,OAIFvB,EAAMC","file":"../../shaders/SSAOShader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * References:\n\t * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n\t * https://learnopengl.com/Advanced-Lighting/SSAO\n\t * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n\t */\n\n\tTHREE.SSAOShader = {\n\n\t\tdefines: {\n\t\t\t\"PERSPECTIVE_CAMERA\": 1,\n\t\t\t\"KERNEL_SIZE\": 32\n\t\t},\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"tNormal\": { value: null },\n\t\t\t\"tDepth\": { value: null },\n\t\t\t\"tNoise\": { value: null },\n\t\t\t\"kernel\": { value: null },\n\t\t\t\"cameraNear\": { value: null },\n\t\t\t\"cameraFar\": { value: null },\n\t\t\t\"resolution\": { value: new THREE.Vector2() },\n\t\t\t\"cameraProjectionMatrix\": { value: new THREE.Matrix4() },\n\t\t\t\"cameraInverseProjectionMatrix\": { value: new THREE.Matrix4() },\n\t\t\t\"kernelRadius\": { value: 8 },\n\t\t\t\"minDistance\": { value: 0.005 },\n\t\t\t\"maxDistance\": { value: 0.05 },\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform sampler2D tNormal;\",\n\t\t\t\"uniform sampler2D tDepth;\",\n\t\t\t\"uniform sampler2D tNoise;\",\n\n\t\t\t\"uniform vec3 kernel[ KERNEL_SIZE ];\",\n\n\t\t\t\"uniform vec2 resolution;\",\n\n\t\t\t\"uniform float cameraNear;\",\n\t\t\t\"uniform float cameraFar;\",\n\t\t\t\"uniform mat4 cameraProjectionMatrix;\",\n\t\t\t\"uniform mat4 cameraInverseProjectionMatrix;\",\n\n\t\t\t\"uniform float kernelRadius;\",\n\t\t\t\"uniform float minDistance;\", // avoid artifacts caused by neighbour fragments with minimal depth difference\n\t\t\t\"uniform float maxDistance;\", // avoid the influence of fragments which are too far away\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"#include <packing>\",\n\n\t\t\t\"float getDepth( const in vec2 screenPosition ) {\",\n\n\t\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"float getLinearDepth( const in vec2 screenPosition ) {\",\n\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\n\t\t\t\"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\",\n\t\t\t\"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\",\n\t\t\t\"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\",\n\n\t\t\t\"\t#else\",\n\n\t\t\t\"\t\treturn texture2D( depthSampler, coord ).x;\",\n\n\t\t\t\"\t#endif\",\n\n\t\t\t\"}\",\n\n\t\t\t\"float getViewZ( const in float depth ) {\",\n\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\n\t\t\t\"\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n\n\t\t\t\"\t#else\",\n\n\t\t\t\"\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n\n\t\t\t\"\t#endif\",\n\n\t\t\t\"}\",\n\n\t\t\t\"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\",\n\n\t\t\t\"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\",\n\n\t\t\t\"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\",\n\n\t\t\t\"\tclipPosition *= clipW; // unprojection.\",\n\n\t\t\t\"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"vec3 getViewNormal( const in vec2 screenPosition ) {\",\n\n\t\t\t\"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tfloat depth = getDepth( vUv );\",\n\t\t\t\"\tfloat viewZ = getViewZ( depth );\",\n\n\t\t\t\"\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\",\n\t\t\t\"\tvec3 viewNormal = getViewNormal( vUv );\",\n\n\t\t\t\" vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\",\n\t\t\t\"\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\",\n\n\t\t\t// compute matrix used to reorient a kernel vector\n\n\t\t\t\"\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\",\n\t\t\t\"\tvec3 bitangent = cross( viewNormal, tangent );\",\n\t\t\t\"\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\",\n\n\t\t\t\" float occlusion = 0.0;\",\n\n\t\t\t\" for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\",\n\n\t\t\t\"\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];\", // reorient sample vector in view space\n\t\t\t\"\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );\", // calculate sample point\n\n\t\t\t\"\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\", // project point and calculate NDC\n\t\t\t\"\t\tsamplePointNDC /= samplePointNDC.w;\",\n\n\t\t\t\"\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\", // compute uv coordinates\n\n\t\t\t\"\t\tfloat realDepth = getLinearDepth( samplePointUv );\", // get linear depth from depth texture\n\t\t\t\"\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\", // compute linear depth of the sample view Z value\n\t\t\t\"\t\tfloat delta = sampleDepth - realDepth;\",\n\n\t\t\t\"\t\tif ( delta > minDistance && delta < maxDistance ) {\", // if fragment is before sample point, increase occlusion\n\n\t\t\t\"\t\t\tocclusion += 1.0;\",\n\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\",\n\n\t\t\t\"\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n\tTHREE.SSAODepthShader = {\n\n\t\tdefines: {\n\t\t\t\"PERSPECTIVE_CAMERA\": 1\n\t\t},\n\n\t\tuniforms: {\n\n\t\t\t\"tDepth\": { value: null },\n\t\t\t\"cameraNear\": { value: null },\n\t\t\t\"cameraFar\": { value: null },\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\t\"uniform float cameraNear;\",\n\t\t\t\"uniform float cameraFar;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"#include <packing>\",\n\n\t\t\t\"float getLinearDepth( const in vec2 screenPosition ) {\",\n\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\n\t\t\t\"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\",\n\t\t\t\"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\",\n\t\t\t\"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\",\n\n\t\t\t\"\t#else\",\n\n\t\t\t\"\t\treturn texture2D( depthSampler, coord ).x;\",\n\n\t\t\t\"\t#endif\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tfloat depth = getLinearDepth( vUv );\",\n\t\t\t\"\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n\tTHREE.SSAOBlurShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"resolution\": { value: new THREE.Vector2() }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"uniform vec2 resolution;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec2 texelSize = ( 1.0 / resolution );\",\n\t\t\t\"\tfloat result = 0.0;\",\n\n\t\t\t\"\tfor ( int i = - 2; i <= 2; i ++ ) {\",\n\n\t\t\t\"\t\tfor ( int j = - 2; j <= 2; j ++ ) {\",\n\n\t\t\t\"\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\",\n\t\t\t\"\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\",\n\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.SSAOShader;\n});\n"]}