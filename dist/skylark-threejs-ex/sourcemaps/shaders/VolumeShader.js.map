{"version":3,"sources":["shaders/VolumeShader.js"],"names":["define","THREE","threex","VolumeRenderShader1","uniforms","u_size","value","Vector3","u_renderstyle","u_renderthreshold","u_clim","Vector2","u_data","u_cmdata","vertexShader","join","fragmentShader","shaders","VolumeShader"],"mappings":";;;;;;;AAAAA,QACM,kBACA,aACH,SACGC,EACAC,GAEF,aACA,IAAIC,GACAC,UACIC,QAAYC,MAAO,IAAIL,EAAMM,QAAQ,EAAG,EAAG,IAC3CC,eAAmBF,MAAO,GAC1BG,mBAAuBH,MAAO,IAC9BI,QAAYJ,MAAO,IAAIL,EAAMU,QAAQ,EAAG,IACxCC,QAAYN,MAAO,MACnBO,UAAcP,MAAO,OAEzBQ,cACI,8BACA,6BACA,+BACA,gCACA,gBACA,sEACA,sEACA,sEACA,sEACA,uCACA,uCACA,uCACA,uCACA,uCACA,uCACA,uCACA,uCACA,uCACA,uCACA,uCACA,uCACA,uFACA,mBACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,oDACA,QACA,oBACA,iDACA,6DACA,gDACA,wDACA,wCACA,mDACA,uCACA,kDACA,iCACA,iFACA,SACFC,KAAK,MACPC,gBACI,6BACA,mCACA,2BACA,iCACA,uCACA,2BACA,gCACA,kCACA,+BACA,8BACA,6BACA,oEACA,sCACA,4CACA,2DACA,2DACA,4DACA,oCACA,2EACA,2EACA,qCACA,sCACA,wEACA,oBACA,mDACA,sDACA,+DACA,gEACA,2EACA,sFACA,2EACA,sFACA,2EACA,sFACA,yDACA,kEACA,4BACA,uBACA,uEACA,2CACA,kCACA,2DACA,uCACA,2DACA,qCACA,uBACA,QACA,sCACA,8EACA,mDACA,QACA,uCACA,6DACA,sDACA,QACA,4EACA,gCACA,2BACA,gCACA,qDACA,kCACA,yBACA,wCACA,mCACA,iCACA,gCACA,gBACA,2BACA,YACA,+DACA,uDACA,mDACA,qDACA,6BACA,YACA,kDACA,QACA,4EACA,yDACA,mDACA,mEACA,gCACA,oFACA,qDACA,kCACA,yBACA,wCACA,yCACA,gDACA,+DACA,2DACA,2CACA,qDACA,mFACA,kCACA,wBACA,qCACA,oBACA,gBACA,2BACA,YACA,QACA,uEACA,QACA,wCACA,kBACA,4BACA,0DACA,0DACA,8BACA,2CACA,0DACA,0DACA,8BACA,2CACA,0DACA,0DACA,8BACA,2CACA,sDACA,4BACA,kDACA,gFACA,yDACA,yDACA,0DACA,kCACA,YACA,6DACA,6DACA,uDACA,8DACA,yDACA,wEACA,0CACA,wFACA,qDACA,uEACA,YACA,4BACA,4CACA,kFACA,mCACA,8BACA,SACFD,KAAK,OAEX,OAAOb,EAAOe,QAAQC,aAAef","file":"../../shaders/VolumeShader.js","sourcesContent":["define([\r\n      \"skylark-threejs\",\r\n      \"../threex\"   \r\n], function (\r\n      THREE,\r\n      threex\r\n) {\r\n    'use strict';\r\n    var VolumeRenderShader1 = {\r\n        uniforms: {\r\n            'u_size': { value: new THREE.Vector3(1, 1, 1) },\r\n            'u_renderstyle': { value: 0 },\r\n            'u_renderthreshold': { value: 0.5 },\r\n            'u_clim': { value: new THREE.Vector2(1, 1) },\r\n            'u_data': { value: null },\r\n            'u_cmdata': { value: null }\r\n        },\r\n        vertexShader: [\r\n            '\\t\\tvarying vec4 v_nearpos;',\r\n            '\\t\\tvarying vec4 v_farpos;',\r\n            '\\t\\tvarying vec3 v_position;',\r\n            '\\t\\tmat4 inversemat(mat4 m) {',\r\n            '\\t\\t\\t\\tfloat',\r\n            '\\t\\t\\t\\ta00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],',\r\n            '\\t\\t\\t\\ta10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],',\r\n            '\\t\\t\\t\\ta20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],',\r\n            '\\t\\t\\t\\ta30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],',\r\n            '\\t\\t\\t\\tb00 = a00 * a11 - a01 * a10,',\r\n            '\\t\\t\\t\\tb01 = a00 * a12 - a02 * a10,',\r\n            '\\t\\t\\t\\tb02 = a00 * a13 - a03 * a10,',\r\n            '\\t\\t\\t\\tb03 = a01 * a12 - a02 * a11,',\r\n            '\\t\\t\\t\\tb04 = a01 * a13 - a03 * a11,',\r\n            '\\t\\t\\t\\tb05 = a02 * a13 - a03 * a12,',\r\n            '\\t\\t\\t\\tb06 = a20 * a31 - a21 * a30,',\r\n            '\\t\\t\\t\\tb07 = a20 * a32 - a22 * a30,',\r\n            '\\t\\t\\t\\tb08 = a20 * a33 - a23 * a30,',\r\n            '\\t\\t\\t\\tb09 = a21 * a32 - a22 * a31,',\r\n            '\\t\\t\\t\\tb10 = a21 * a33 - a23 * a31,',\r\n            '\\t\\t\\t\\tb11 = a22 * a33 - a23 * a32,',\r\n            '\\t\\t\\t\\tdet = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;',\r\n            '\\t\\treturn mat4(',\r\n            '\\t\\t\\t\\ta11 * b11 - a12 * b10 + a13 * b09,',\r\n            '\\t\\t\\t\\ta02 * b10 - a01 * b11 - a03 * b09,',\r\n            '\\t\\t\\t\\ta31 * b05 - a32 * b04 + a33 * b03,',\r\n            '\\t\\t\\t\\ta22 * b04 - a21 * b05 - a23 * b03,',\r\n            '\\t\\t\\t\\ta12 * b08 - a10 * b11 - a13 * b07,',\r\n            '\\t\\t\\t\\ta00 * b11 - a02 * b08 + a03 * b07,',\r\n            '\\t\\t\\t\\ta32 * b02 - a30 * b05 - a33 * b01,',\r\n            '\\t\\t\\t\\ta20 * b05 - a22 * b02 + a23 * b01,',\r\n            '\\t\\t\\t\\ta10 * b10 - a11 * b08 + a13 * b06,',\r\n            '\\t\\t\\t\\ta01 * b08 - a00 * b10 - a03 * b06,',\r\n            '\\t\\t\\t\\ta30 * b04 - a31 * b02 + a33 * b00,',\r\n            '\\t\\t\\t\\ta21 * b02 - a20 * b04 - a23 * b00,',\r\n            '\\t\\t\\t\\ta11 * b07 - a10 * b09 - a12 * b06,',\r\n            '\\t\\t\\t\\ta00 * b09 - a01 * b07 + a02 * b06,',\r\n            '\\t\\t\\t\\ta31 * b01 - a30 * b03 - a32 * b00,',\r\n            '\\t\\t\\t\\ta20 * b03 - a21 * b01 + a22 * b00) / det;',\r\n            '\\t\\t}',\r\n            '\\t\\tvoid main() {',\r\n            '\\t\\t\\t\\tmat4 viewtransformf = modelViewMatrix;',\r\n            '\\t\\t\\t\\tmat4 viewtransformi = inversemat(modelViewMatrix);',\r\n            '\\t\\t\\t\\tvec4 position4 = vec4(position, 1.0);',\r\n            '\\t\\t\\t\\tvec4 pos_in_cam = viewtransformf * position4;',\r\n            '\\t\\t\\t\\tpos_in_cam.z = -pos_in_cam.w;',\r\n            '\\t\\t\\t\\tv_nearpos = viewtransformi * pos_in_cam;',\r\n            '\\t\\t\\t\\tpos_in_cam.z = pos_in_cam.w;',\r\n            '\\t\\t\\t\\tv_farpos = viewtransformi * pos_in_cam;',\r\n            '\\t\\t\\t\\tv_position = position;',\r\n            '\\t\\t\\t\\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;',\r\n            '\\t\\t}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            '\\t\\tprecision highp float;',\r\n            '\\t\\tprecision mediump sampler3D;',\r\n            '\\t\\tuniform vec3 u_size;',\r\n            '\\t\\tuniform int u_renderstyle;',\r\n            '\\t\\tuniform float u_renderthreshold;',\r\n            '\\t\\tuniform vec2 u_clim;',\r\n            '\\t\\tuniform sampler3D u_data;',\r\n            '\\t\\tuniform sampler2D u_cmdata;',\r\n            '\\t\\tvarying vec3 v_position;',\r\n            '\\t\\tvarying vec4 v_nearpos;',\r\n            '\\t\\tvarying vec4 v_farpos;',\r\n            '\\t\\tconst int MAX_STEPS = 887;\\t// 887 for 512^3, 1774 for 1024^3',\r\n            '\\t\\tconst int REFINEMENT_STEPS = 4;',\r\n            '\\t\\tconst float relative_step_size = 1.0;',\r\n            '\\t\\tconst vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);',\r\n            '\\t\\tconst vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);',\r\n            '\\t\\tconst vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);',\r\n            '\\t\\tconst float shininess = 40.0;',\r\n            '\\t\\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);',\r\n            '\\t\\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);',\r\n            '\\t\\tfloat sample1(vec3 texcoords);',\r\n            '\\t\\tvec4 apply_colormap(float val);',\r\n            '\\t\\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);',\r\n            '\\t\\tvoid main() {',\r\n            '\\t\\t\\t\\tvec3 farpos = v_farpos.xyz / v_farpos.w;',\r\n            '\\t\\t\\t\\tvec3 nearpos = v_nearpos.xyz / v_nearpos.w;',\r\n            '\\t\\t\\t\\tvec3 view_ray = normalize(nearpos.xyz - farpos.xyz);',\r\n            '\\t\\t\\t\\tfloat distance = dot(nearpos - v_position, view_ray);',\r\n            '\\t\\t\\t\\tdistance = max(distance, min((-0.5 - v_position.x) / view_ray.x,',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(u_size.x - 0.5 - v_position.x) / view_ray.x));',\r\n            '\\t\\t\\t\\tdistance = max(distance, min((-0.5 - v_position.y) / view_ray.y,',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(u_size.y - 0.5 - v_position.y) / view_ray.y));',\r\n            '\\t\\t\\t\\tdistance = max(distance, min((-0.5 - v_position.z) / view_ray.z,',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(u_size.z - 0.5 - v_position.z) / view_ray.z));',\r\n            '\\t\\t\\t\\tvec3 front = v_position + view_ray * distance;',\r\n            '\\t\\t\\t\\tint nsteps = int(-distance / relative_step_size + 0.5);',\r\n            '\\t\\t\\t\\tif ( nsteps < 1 )',\r\n            '\\t\\t\\t\\t\\t\\tdiscard;',\r\n            '\\t\\t\\t\\tvec3 step = ((v_position - front) / u_size) / float(nsteps);',\r\n            '\\t\\t\\t\\tvec3 start_loc = front / u_size;',\r\n            '\\t\\t\\t\\tif (u_renderstyle == 0)',\r\n            '\\t\\t\\t\\t\\t\\tcast_mip(start_loc, step, nsteps, view_ray);',\r\n            '\\t\\t\\t\\telse if (u_renderstyle == 1)',\r\n            '\\t\\t\\t\\t\\t\\tcast_iso(start_loc, step, nsteps, view_ray);',\r\n            '\\t\\t\\t\\tif (gl_FragColor.a < 0.05)',\r\n            '\\t\\t\\t\\t\\t\\tdiscard;',\r\n            '\\t\\t}',\r\n            '\\t\\tfloat sample1(vec3 texcoords) {',\r\n            '\\t\\t\\t\\t/* Sample float value from a 3D texture. Assumes intensity data. */',\r\n            '\\t\\t\\t\\treturn texture(u_data, texcoords.xyz).r;',\r\n            '\\t\\t}',\r\n            '\\t\\tvec4 apply_colormap(float val) {',\r\n            '\\t\\t\\t\\tval = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);',\r\n            '\\t\\t\\t\\treturn texture2D(u_cmdata, vec2(val, 0.5));',\r\n            '\\t\\t}',\r\n            '\\t\\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {',\r\n            '\\t\\t\\t\\tfloat max_val = -1e6;',\r\n            '\\t\\t\\t\\tint max_i = 100;',\r\n            '\\t\\t\\t\\tvec3 loc = start_loc;',\r\n            '\\t\\t\\t\\tfor (int iter=0; iter<MAX_STEPS; iter++) {',\r\n            '\\t\\t\\t\\t\\t\\tif (iter >= nsteps)',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\tbreak;',\r\n            '\\t\\t\\t\\t\\t\\tfloat val = sample1(loc);',\r\n            '\\t\\t\\t\\t\\t\\tif (val > max_val) {',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\tmax_val = val;',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\tmax_i = iter;',\r\n            '\\t\\t\\t\\t\\t\\t}',\r\n            '\\t\\t\\t\\t\\t\\tloc += step;',\r\n            '\\t\\t\\t\\t}',\r\n            '\\t\\t\\t\\tvec3 iloc = start_loc + step * (float(max_i) - 0.5);',\r\n            '\\t\\t\\t\\tvec3 istep = step / float(REFINEMENT_STEPS);',\r\n            '\\t\\t\\t\\tfor (int i=0; i<REFINEMENT_STEPS; i++) {',\r\n            '\\t\\t\\t\\t\\t\\tmax_val = max(max_val, sample1(iloc));',\r\n            '\\t\\t\\t\\t\\t\\tiloc += istep;',\r\n            '\\t\\t\\t\\t}',\r\n            '\\t\\t\\t\\tgl_FragColor = apply_colormap(max_val);',\r\n            '\\t\\t}',\r\n            '\\t\\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {',\r\n            '\\t\\t\\t\\tgl_FragColor = vec4(0.0);\\t// init transparent',\r\n            '\\t\\t\\t\\tvec4 color3 = vec4(0.0);\\t// final color',\r\n            '\\t\\t\\t\\tvec3 dstep = 1.5 / u_size;\\t// step to sample derivative',\r\n            '\\t\\t\\t\\tvec3 loc = start_loc;',\r\n            '\\t\\t\\t\\tfloat low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);',\r\n            '\\t\\t\\t\\tfor (int iter=0; iter<MAX_STEPS; iter++) {',\r\n            '\\t\\t\\t\\t\\t\\tif (iter >= nsteps)',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\tbreak;',\r\n            '\\t\\t\\t\\t\\t\\tfloat val = sample1(loc);',\r\n            '\\t\\t\\t\\t\\t\\tif (val > low_threshold) {',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\tvec3 iloc = loc - 0.5 * step;',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\tvec3 istep = step / float(REFINEMENT_STEPS);',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\tfor (int i=0; i<REFINEMENT_STEPS; i++) {',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tval = sample1(iloc);',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif (val > u_renderthreshold) {',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tgl_FragColor = add_lighting(val, iloc, dstep, view_ray);',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tiloc += istep;',\r\n            '\\t\\t\\t\\t\\t\\t\\t\\t}',\r\n            '\\t\\t\\t\\t\\t\\t}',\r\n            '\\t\\t\\t\\t\\t\\tloc += step;',\r\n            '\\t\\t\\t\\t}',\r\n            '\\t\\t}',\r\n            '\\t\\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)',\r\n            '\\t\\t{',\r\n            '\\t\\t\\t\\tvec3 V = normalize(view_ray);',\r\n            '\\t\\t\\t\\tvec3 N;',\r\n            '\\t\\t\\t\\tfloat val1, val2;',\r\n            '\\t\\t\\t\\tval1 = sample1(loc + vec3(-step[0], 0.0, 0.0));',\r\n            '\\t\\t\\t\\tval2 = sample1(loc + vec3(+step[0], 0.0, 0.0));',\r\n            '\\t\\t\\t\\tN[0] = val1 - val2;',\r\n            '\\t\\t\\t\\tval = max(max(val1, val2), val);',\r\n            '\\t\\t\\t\\tval1 = sample1(loc + vec3(0.0, -step[1], 0.0));',\r\n            '\\t\\t\\t\\tval2 = sample1(loc + vec3(0.0, +step[1], 0.0));',\r\n            '\\t\\t\\t\\tN[1] = val1 - val2;',\r\n            '\\t\\t\\t\\tval = max(max(val1, val2), val);',\r\n            '\\t\\t\\t\\tval1 = sample1(loc + vec3(0.0, 0.0, -step[2]));',\r\n            '\\t\\t\\t\\tval2 = sample1(loc + vec3(0.0, 0.0, +step[2]));',\r\n            '\\t\\t\\t\\tN[2] = val1 - val2;',\r\n            '\\t\\t\\t\\tval = max(max(val1, val2), val);',\r\n            '\\t\\t\\t\\tfloat gm = length(N); // gradient magnitude',\r\n            '\\t\\t\\t\\tN = normalize(N);',\r\n            '\\t\\t\\t\\tfloat Nselect = float(dot(N, V) > 0.0);',\r\n            '\\t\\t\\t\\tN = (2.0 * Nselect - 1.0) * N;\\t// ==\\tNselect * N - (1.0-Nselect)*N;',\r\n            '\\t\\t\\t\\tvec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);',\r\n            '\\t\\t\\t\\tvec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);',\r\n            '\\t\\t\\t\\tvec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);',\r\n            '\\t\\t\\t\\tfor (int i=0; i<1; i++)',\r\n            '\\t\\t\\t\\t{',\r\n            '\\t\\t\\t\\t\\t\\tvec3 L = normalize(view_ray);\\t//lightDirs[i];',\r\n            '\\t\\t\\t\\t\\t\\tfloat lightEnabled = float( length(L) > 0.0 );',\r\n            '\\t\\t\\t\\t\\t\\tL = normalize(L + (1.0 - lightEnabled));',\r\n            '\\t\\t\\t\\t\\t\\tfloat lambertTerm = clamp(dot(N, L), 0.0, 1.0);',\r\n            '\\t\\t\\t\\t\\t\\tvec3 H = normalize(L+V); // Halfway vector',\r\n            '\\t\\t\\t\\t\\t\\tfloat specularTerm = pow(max(dot(H, N), 0.0), shininess);',\r\n            '\\t\\t\\t\\t\\t\\tfloat mask1 = lightEnabled;',\r\n            '\\t\\t\\t\\t\\t\\tambient_color +=\\tmask1 * ambient_color;\\t// * gl_LightSource[i].ambient;',\r\n            '\\t\\t\\t\\t\\t\\tdiffuse_color +=\\tmask1 * lambertTerm;',\r\n            '\\t\\t\\t\\t\\t\\tspecular_color += mask1 * specularTerm * specular_color;',\r\n            '\\t\\t\\t\\t}',\r\n            '\\t\\t\\t\\tvec4 final_color;',\r\n            '\\t\\t\\t\\tvec4 color = apply_colormap(val);',\r\n            '\\t\\t\\t\\tfinal_color = color * (ambient_color + diffuse_color) + specular_color;',\r\n            '\\t\\t\\t\\tfinal_color.a = color.a;',\r\n            '\\t\\t\\t\\treturn final_color;',\r\n            '\\t\\t}'\r\n        ].join('\\n')\r\n    };\r\n    return threex.shaders.VolumeShader = VolumeRenderShader1;\r\n});"]}