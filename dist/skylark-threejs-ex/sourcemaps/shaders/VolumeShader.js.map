{"version":3,"sources":["shaders/VolumeShader.js"],"names":["define","THREE","VolumeRenderShader1","uniforms","u_size","value","Vector3","u_renderstyle","u_renderthreshold","u_clim","Vector2","u_data","u_cmdata","vertexShader","join","fragmentShader"],"mappings":";;;;;;;AAAAA,QACC,mBACC,SAASC,GAsUV,OA7TAA,EAAMC,qBACLC,UACCC,QAAYC,MAAO,IAAIJ,EAAMK,QAAS,EAAG,EAAG,IAC5CC,eAAmBF,MAAO,GAC1BG,mBAAuBH,MAAO,IAC9BI,QAAYJ,MAAO,IAAIJ,EAAMS,QAAS,EAAG,IACzCC,QAAYN,MAAO,MACnBO,UAAcP,MAAO,OAEtBQ,cACC,8BACA,6BACA,+BAEA,gCAGA,gBACA,sEACA,sEACA,sEACA,sEAEA,uCACA,uCACA,uCACA,uCACA,uCACA,uCACA,uCACA,uCACA,uCACA,uCACA,uCACA,uCAEA,uFAEA,mBACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,6CACA,oDACA,QAGA,oBAGA,iDACA,6DAMA,gDACA,wDAGA,wCACA,mDAGA,uCACA,kDAGA,iCACA,iFACA,SACCC,KAAM,MACRC,gBACC,6BACA,mCAEA,2BACA,iCACA,uCACA,2BAEA,gCACA,kCAEA,+BACA,8BACA,6BAGA,oEACA,sCACA,4CACA,2DACA,2DACA,4DACA,oCAEA,2EACA,2EAEA,qCACA,sCACA,wEAGA,oBAEA,mDACA,sDAGA,+DAKA,gEACA,2EACA,sFACA,2EACA,sFACA,2EACA,sFAGA,yDAGA,kEACA,4BACA,uBAGA,uEACA,2CAOA,kCACA,2DACA,uCACA,2DAEA,qCACA,uBACA,QAGA,sCACA,8EACA,mDACA,QAGA,uCACA,6DACA,sDACA,QAGA,4EAEA,gCACA,2BACA,gCAKA,qDACA,kCACA,yBAEA,wCAEA,mCACA,iCACA,gCACA,gBAEA,2BACA,YAGA,+DACA,uDACA,mDACA,qDACA,6BACA,YAGA,kDACA,QAGA,4EAEA,yDACA,mDACA,mEACA,gCAEA,oFAKA,qDACA,kCACA,yBAGA,wCAEA,yCAEA,gDACA,+DACA,2DACA,2CACA,qDACA,mFACA,kCACA,wBACA,qCACA,oBACA,gBAGA,2BACA,YACA,QAGA,uEACA,QAIA,wCAGA,kBACA,4BACA,0DACA,0DACA,8BACA,2CACA,0DACA,0DACA,8BACA,2CACA,0DACA,0DACA,8BACA,2CAEA,sDACA,4BAGA,kDACA,gFAGA,yDACA,yDACA,0DAGA,kCACA,YAEA,6DACA,6DACA,uDAGA,8DACA,yDACA,wEAGA,0CAGA,wFACA,qDACA,uEACA,YAGA,4BACA,4CACA,kFACA,mCACA,8BACA,SACCD,KAAM,OAGFb,EAAMC","file":"../../shaders/VolumeShader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Almar Klein / http://almarklein.org\n\t *\n\t * Shaders to render 3D volumes using raycasting.\n\t * The applied techniques are based on similar implementations in the Visvis and Vispy projects.\n\t * This is not the only approach, therefore it's marked 1.\n\t */\n\n\tTHREE.VolumeRenderShader1 = {\n\t\tuniforms: {\n\t\t\t\"u_size\": { value: new THREE.Vector3( 1, 1, 1 ) },\n\t\t\t\"u_renderstyle\": { value: 0 },\n\t\t\t\"u_renderthreshold\": { value: 0.5 },\n\t\t\t\"u_clim\": { value: new THREE.Vector2( 1, 1 ) },\n\t\t\t\"u_data\": { value: null },\n\t\t\t\"u_cmdata\": { value: null }\n\t\t},\n\t\tvertexShader: [\n\t\t\t\"\t\tvarying vec4 v_nearpos;\",\n\t\t\t\"\t\tvarying vec4 v_farpos;\",\n\t\t\t\"\t\tvarying vec3 v_position;\",\n\n\t\t\t\"\t\tmat4 inversemat(mat4 m) {\",\n\t\t\t// Taken from https://github.com/stackgl/glsl-inverse/blob/master/index.glsl\n\t\t\t// This function is licenced by the MIT license to Mikola Lysenko\n\t\t\t\"\t\t\t\tfloat\",\n\t\t\t\"\t\t\t\ta00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\",\n\t\t\t\"\t\t\t\ta10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\",\n\t\t\t\"\t\t\t\ta20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\",\n\t\t\t\"\t\t\t\ta30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\",\n\n\t\t\t\"\t\t\t\tb00 = a00 * a11 - a01 * a10,\",\n\t\t\t\"\t\t\t\tb01 = a00 * a12 - a02 * a10,\",\n\t\t\t\"\t\t\t\tb02 = a00 * a13 - a03 * a10,\",\n\t\t\t\"\t\t\t\tb03 = a01 * a12 - a02 * a11,\",\n\t\t\t\"\t\t\t\tb04 = a01 * a13 - a03 * a11,\",\n\t\t\t\"\t\t\t\tb05 = a02 * a13 - a03 * a12,\",\n\t\t\t\"\t\t\t\tb06 = a20 * a31 - a21 * a30,\",\n\t\t\t\"\t\t\t\tb07 = a20 * a32 - a22 * a30,\",\n\t\t\t\"\t\t\t\tb08 = a20 * a33 - a23 * a30,\",\n\t\t\t\"\t\t\t\tb09 = a21 * a32 - a22 * a31,\",\n\t\t\t\"\t\t\t\tb10 = a21 * a33 - a23 * a31,\",\n\t\t\t\"\t\t\t\tb11 = a22 * a33 - a23 * a32,\",\n\n\t\t\t\"\t\t\t\tdet = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\",\n\n\t\t\t\"\t\treturn mat4(\",\n\t\t\t\"\t\t\t\ta11 * b11 - a12 * b10 + a13 * b09,\",\n\t\t\t\"\t\t\t\ta02 * b10 - a01 * b11 - a03 * b09,\",\n\t\t\t\"\t\t\t\ta31 * b05 - a32 * b04 + a33 * b03,\",\n\t\t\t\"\t\t\t\ta22 * b04 - a21 * b05 - a23 * b03,\",\n\t\t\t\"\t\t\t\ta12 * b08 - a10 * b11 - a13 * b07,\",\n\t\t\t\"\t\t\t\ta00 * b11 - a02 * b08 + a03 * b07,\",\n\t\t\t\"\t\t\t\ta32 * b02 - a30 * b05 - a33 * b01,\",\n\t\t\t\"\t\t\t\ta20 * b05 - a22 * b02 + a23 * b01,\",\n\t\t\t\"\t\t\t\ta10 * b10 - a11 * b08 + a13 * b06,\",\n\t\t\t\"\t\t\t\ta01 * b08 - a00 * b10 - a03 * b06,\",\n\t\t\t\"\t\t\t\ta30 * b04 - a31 * b02 + a33 * b00,\",\n\t\t\t\"\t\t\t\ta21 * b02 - a20 * b04 - a23 * b00,\",\n\t\t\t\"\t\t\t\ta11 * b07 - a10 * b09 - a12 * b06,\",\n\t\t\t\"\t\t\t\ta00 * b09 - a01 * b07 + a02 * b06,\",\n\t\t\t\"\t\t\t\ta31 * b01 - a30 * b03 - a32 * b00,\",\n\t\t\t\"\t\t\t\ta20 * b03 - a21 * b01 + a22 * b00) / det;\",\n\t\t\t\"\t\t}\",\n\n\n\t\t\t\"\t\tvoid main() {\",\n\t\t\t// Prepare transforms to map to \"camera view\". See also:\n\t\t\t// https://threejs.org/docs/#api/renderers/webgl/WebGLProgram\n\t\t\t\"\t\t\t\tmat4 viewtransformf = modelViewMatrix;\",\n\t\t\t\"\t\t\t\tmat4 viewtransformi = inversemat(modelViewMatrix);\",\n\n\t\t\t// Project local vertex coordinate to camera position. Then do a step\n\t\t\t// backward (in cam coords) to the near clipping plane, and project back. Do\n\t\t\t// the same for the far clipping plane. This gives us all the information we\n\t\t\t// need to calculate the ray and truncate it to the viewing cone.\n\t\t\t\"\t\t\t\tvec4 position4 = vec4(position, 1.0);\",\n\t\t\t\"\t\t\t\tvec4 pos_in_cam = viewtransformf * position4;\",\n\n\t\t\t// Intersection of ray and near clipping plane (z = -1 in clip coords)\n\t\t\t\"\t\t\t\tpos_in_cam.z = -pos_in_cam.w;\",\n\t\t\t\"\t\t\t\tv_nearpos = viewtransformi * pos_in_cam;\",\n\n\t\t\t// Intersection of ray and far clipping plane (z = +1 in clip coords)\n\t\t\t\"\t\t\t\tpos_in_cam.z = pos_in_cam.w;\",\n\t\t\t\"\t\t\t\tv_farpos = viewtransformi * pos_in_cam;\",\n\n\t\t\t// Set varyings and output pos\n\t\t\t\"\t\t\t\tv_position = position;\",\n\t\t\t\"\t\t\t\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;\",\n\t\t\t\"\t\t}\",\n\t\t].join( \"\\n\" ),\n\t\tfragmentShader: [\n\t\t\t\"\t\tprecision highp float;\",\n\t\t\t\"\t\tprecision mediump sampler3D;\",\n\n\t\t\t\"\t\tuniform vec3 u_size;\",\n\t\t\t\"\t\tuniform int u_renderstyle;\",\n\t\t\t\"\t\tuniform float u_renderthreshold;\",\n\t\t\t\"\t\tuniform vec2 u_clim;\",\n\n\t\t\t\"\t\tuniform sampler3D u_data;\",\n\t\t\t\"\t\tuniform sampler2D u_cmdata;\",\n\n\t\t\t\"\t\tvarying vec3 v_position;\",\n\t\t\t\"\t\tvarying vec4 v_nearpos;\",\n\t\t\t\"\t\tvarying vec4 v_farpos;\",\n\n\t\t\t// The maximum distance through our rendering volume is sqrt(3).\n\t\t\t\"\t\tconst int MAX_STEPS = 887;\t// 887 for 512^3, 1774 for 1024^3\",\n\t\t\t\"\t\tconst int REFINEMENT_STEPS = 4;\",\n\t\t\t\"\t\tconst float relative_step_size = 1.0;\",\n\t\t\t\"\t\tconst vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);\",\n\t\t\t\"\t\tconst vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);\",\n\t\t\t\"\t\tconst vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);\",\n\t\t\t\"\t\tconst float shininess = 40.0;\",\n\n\t\t\t\"\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);\",\n\t\t\t\"\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);\",\n\n\t\t\t\"\t\tfloat sample1(vec3 texcoords);\",\n\t\t\t\"\t\tvec4 apply_colormap(float val);\",\n\t\t\t\"\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);\",\n\n\n\t\t\t\"\t\tvoid main() {\",\n\t\t\t// Normalize clipping plane info\n\t\t\t\"\t\t\t\tvec3 farpos = v_farpos.xyz / v_farpos.w;\",\n\t\t\t\"\t\t\t\tvec3 nearpos = v_nearpos.xyz / v_nearpos.w;\",\n\n\t\t\t// Calculate unit vector pointing in the view direction through this fragment.\n\t\t\t\"\t\t\t\tvec3 view_ray = normalize(nearpos.xyz - farpos.xyz);\",\n\n\t\t\t// Compute the (negative) distance to the front surface or near clipping plane.\n\t\t\t// v_position is the back face of the cuboid, so the initial distance calculated in the dot\n\t\t\t// product below is the distance from near clip plane to the back of the cuboid\n\t\t\t\"\t\t\t\tfloat distance = dot(nearpos - v_position, view_ray);\",\n\t\t\t\"\t\t\t\tdistance = max(distance, min((-0.5 - v_position.x) / view_ray.x,\",\n\t\t\t\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.x - 0.5 - v_position.x) / view_ray.x));\",\n\t\t\t\"\t\t\t\tdistance = max(distance, min((-0.5 - v_position.y) / view_ray.y,\",\n\t\t\t\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.y - 0.5 - v_position.y) / view_ray.y));\",\n\t\t\t\"\t\t\t\tdistance = max(distance, min((-0.5 - v_position.z) / view_ray.z,\",\n\t\t\t\"\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.z - 0.5 - v_position.z) / view_ray.z));\",\n\n\t\t\t// Now we have the starting position on the front surface\n\t\t\t\"\t\t\t\tvec3 front = v_position + view_ray * distance;\",\n\n\t\t\t// Decide how many steps to take\n\t\t\t\"\t\t\t\tint nsteps = int(-distance / relative_step_size + 0.5);\",\n\t\t\t\"\t\t\t\tif ( nsteps < 1 )\",\n\t\t\t\"\t\t\t\t\t\tdiscard;\",\n\n\t\t\t// Get starting location and step vector in texture coordinates\n\t\t\t\"\t\t\t\tvec3 step = ((v_position - front) / u_size) / float(nsteps);\",\n\t\t\t\"\t\t\t\tvec3 start_loc = front / u_size;\",\n\n\t\t\t// For testing: show the number of steps. This helps to establish\n\t\t\t// whether the rays are correctly oriented\n\t\t\t//'gl_FragColor = vec4(0.0, float(nsteps) / 1.0 / u_size.x, 1.0, 1.0);',\n\t\t\t//'return;',\n\n\t\t\t\"\t\t\t\tif (u_renderstyle == 0)\",\n\t\t\t\"\t\t\t\t\t\tcast_mip(start_loc, step, nsteps, view_ray);\",\n\t\t\t\"\t\t\t\telse if (u_renderstyle == 1)\",\n\t\t\t\"\t\t\t\t\t\tcast_iso(start_loc, step, nsteps, view_ray);\",\n\n\t\t\t\"\t\t\t\tif (gl_FragColor.a < 0.05)\",\n\t\t\t\"\t\t\t\t\t\tdiscard;\",\n\t\t\t\"\t\t}\",\n\n\n\t\t\t\"\t\tfloat sample1(vec3 texcoords) {\",\n\t\t\t\"\t\t\t\t/* Sample float value from a 3D texture. Assumes intensity data. */\",\n\t\t\t\"\t\t\t\treturn texture(u_data, texcoords.xyz).r;\",\n\t\t\t\"\t\t}\",\n\n\n\t\t\t\"\t\tvec4 apply_colormap(float val) {\",\n\t\t\t\"\t\t\t\tval = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);\",\n\t\t\t\"\t\t\t\treturn texture2D(u_cmdata, vec2(val, 0.5));\",\n\t\t\t\"\t\t}\",\n\n\n\t\t\t\"\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {\",\n\n\t\t\t\"\t\t\t\tfloat max_val = -1e6;\",\n\t\t\t\"\t\t\t\tint max_i = 100;\",\n\t\t\t\"\t\t\t\tvec3 loc = start_loc;\",\n\n\t\t\t// Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\n\t\t\t// non-constant expression. So we use a hard-coded max, and an additional condition\n\t\t\t// inside the loop.\n\t\t\t\"\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {\",\n\t\t\t\"\t\t\t\t\t\tif (iter >= nsteps)\",\n\t\t\t\"\t\t\t\t\t\t\t\tbreak;\",\n\t\t\t// Sample from the 3D texture\n\t\t\t\"\t\t\t\t\t\tfloat val = sample1(loc);\",\n\t\t\t// Apply MIP operation\n\t\t\t\"\t\t\t\t\t\tif (val > max_val) {\",\n\t\t\t\"\t\t\t\t\t\t\t\tmax_val = val;\",\n\t\t\t\"\t\t\t\t\t\t\t\tmax_i = iter;\",\n\t\t\t\"\t\t\t\t\t\t}\",\n\t\t\t// Advance location deeper into the volume\n\t\t\t\"\t\t\t\t\t\tloc += step;\",\n\t\t\t\"\t\t\t\t}\",\n\n\t\t\t// Refine location, gives crispier images\n\t\t\t\"\t\t\t\tvec3 iloc = start_loc + step * (float(max_i) - 0.5);\",\n\t\t\t\"\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);\",\n\t\t\t\"\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {\",\n\t\t\t\"\t\t\t\t\t\tmax_val = max(max_val, sample1(iloc));\",\n\t\t\t\"\t\t\t\t\t\tiloc += istep;\",\n\t\t\t\"\t\t\t\t}\",\n\n\t\t\t// Resolve final color\n\t\t\t\"\t\t\t\tgl_FragColor = apply_colormap(max_val);\",\n\t\t\t\"\t\t}\",\n\n\n\t\t\t\"\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {\",\n\n\t\t\t\"\t\t\t\tgl_FragColor = vec4(0.0);\t// init transparent\",\n\t\t\t\"\t\t\t\tvec4 color3 = vec4(0.0);\t// final color\",\n\t\t\t\"\t\t\t\tvec3 dstep = 1.5 / u_size;\t// step to sample derivative\",\n\t\t\t\"\t\t\t\tvec3 loc = start_loc;\",\n\n\t\t\t\"\t\t\t\tfloat low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);\",\n\n\t\t\t// Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\n\t\t\t// non-constant expression. So we use a hard-coded max, and an additional condition\n\t\t\t// inside the loop.\n\t\t\t\"\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {\",\n\t\t\t\"\t\t\t\t\t\tif (iter >= nsteps)\",\n\t\t\t\"\t\t\t\t\t\t\t\tbreak;\",\n\n\t\t\t// Sample from the 3D texture\n\t\t\t\"\t\t\t\t\t\tfloat val = sample1(loc);\",\n\n\t\t\t\"\t\t\t\t\t\tif (val > low_threshold) {\",\n\t\t\t// Take the last interval in smaller steps\n\t\t\t\"\t\t\t\t\t\t\t\tvec3 iloc = loc - 0.5 * step;\",\n\t\t\t\"\t\t\t\t\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);\",\n\t\t\t\"\t\t\t\t\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {\",\n\t\t\t\"\t\t\t\t\t\t\t\t\t\tval = sample1(iloc);\",\n\t\t\t\"\t\t\t\t\t\t\t\t\t\tif (val > u_renderthreshold) {\",\n\t\t\t\"\t\t\t\t\t\t\t\t\t\t\t\tgl_FragColor = add_lighting(val, iloc, dstep, view_ray);\",\n\t\t\t\"\t\t\t\t\t\t\t\t\t\t\t\treturn;\",\n\t\t\t\"\t\t\t\t\t\t\t\t\t\t}\",\n\t\t\t\"\t\t\t\t\t\t\t\t\t\tiloc += istep;\",\n\t\t\t\"\t\t\t\t\t\t\t\t}\",\n\t\t\t\"\t\t\t\t\t\t}\",\n\n\t\t\t// Advance location deeper into the volume\n\t\t\t\"\t\t\t\t\t\tloc += step;\",\n\t\t\t\"\t\t\t\t}\",\n\t\t\t\"\t\t}\",\n\n\n\t\t\t\"\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)\",\n\t\t\t\"\t\t{\",\n\t\t\t// Calculate color by incorporating lighting\n\n\t\t\t// View direction\n\t\t\t\"\t\t\t\tvec3 V = normalize(view_ray);\",\n\n\t\t\t// calculate normal vector from gradient\n\t\t\t\"\t\t\t\tvec3 N;\",\n\t\t\t\"\t\t\t\tfloat val1, val2;\",\n\t\t\t\"\t\t\t\tval1 = sample1(loc + vec3(-step[0], 0.0, 0.0));\",\n\t\t\t\"\t\t\t\tval2 = sample1(loc + vec3(+step[0], 0.0, 0.0));\",\n\t\t\t\"\t\t\t\tN[0] = val1 - val2;\",\n\t\t\t\"\t\t\t\tval = max(max(val1, val2), val);\",\n\t\t\t\"\t\t\t\tval1 = sample1(loc + vec3(0.0, -step[1], 0.0));\",\n\t\t\t\"\t\t\t\tval2 = sample1(loc + vec3(0.0, +step[1], 0.0));\",\n\t\t\t\"\t\t\t\tN[1] = val1 - val2;\",\n\t\t\t\"\t\t\t\tval = max(max(val1, val2), val);\",\n\t\t\t\"\t\t\t\tval1 = sample1(loc + vec3(0.0, 0.0, -step[2]));\",\n\t\t\t\"\t\t\t\tval2 = sample1(loc + vec3(0.0, 0.0, +step[2]));\",\n\t\t\t\"\t\t\t\tN[2] = val1 - val2;\",\n\t\t\t\"\t\t\t\tval = max(max(val1, val2), val);\",\n\n\t\t\t\"\t\t\t\tfloat gm = length(N); // gradient magnitude\",\n\t\t\t\"\t\t\t\tN = normalize(N);\",\n\n\t\t\t// Flip normal so it points towards viewer\n\t\t\t\"\t\t\t\tfloat Nselect = float(dot(N, V) > 0.0);\",\n\t\t\t\"\t\t\t\tN = (2.0 * Nselect - 1.0) * N;\t// ==\tNselect * N - (1.0-Nselect)*N;\",\n\n\t\t\t// Init colors\n\t\t\t\"\t\t\t\tvec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);\",\n\t\t\t\"\t\t\t\tvec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);\",\n\t\t\t\"\t\t\t\tvec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);\",\n\n\t\t\t// note: could allow multiple lights\n\t\t\t\"\t\t\t\tfor (int i=0; i<1; i++)\",\n\t\t\t\"\t\t\t\t{\",\n\t\t\t\t\t\t\t\t\t // Get light direction (make sure to prevent zero devision)\n\t\t\t\"\t\t\t\t\t\tvec3 L = normalize(view_ray);\t//lightDirs[i];\",\n\t\t\t\"\t\t\t\t\t\tfloat lightEnabled = float( length(L) > 0.0 );\",\n\t\t\t\"\t\t\t\t\t\tL = normalize(L + (1.0 - lightEnabled));\",\n\n\t\t\t// Calculate lighting properties\n\t\t\t\"\t\t\t\t\t\tfloat lambertTerm = clamp(dot(N, L), 0.0, 1.0);\",\n\t\t\t\"\t\t\t\t\t\tvec3 H = normalize(L+V); // Halfway vector\",\n\t\t\t\"\t\t\t\t\t\tfloat specularTerm = pow(max(dot(H, N), 0.0), shininess);\",\n\n\t\t\t// Calculate mask\n\t\t\t\"\t\t\t\t\t\tfloat mask1 = lightEnabled;\",\n\n\t\t\t// Calculate colors\n\t\t\t\"\t\t\t\t\t\tambient_color +=\tmask1 * ambient_color;\t// * gl_LightSource[i].ambient;\",\n\t\t\t\"\t\t\t\t\t\tdiffuse_color +=\tmask1 * lambertTerm;\",\n\t\t\t\"\t\t\t\t\t\tspecular_color += mask1 * specularTerm * specular_color;\",\n\t\t\t\"\t\t\t\t}\",\n\n\t\t\t// Calculate final color by componing different components\n\t\t\t\"\t\t\t\tvec4 final_color;\",\n\t\t\t\"\t\t\t\tvec4 color = apply_colormap(val);\",\n\t\t\t\"\t\t\t\tfinal_color = color * (ambient_color + diffuse_color) + specular_color;\",\n\t\t\t\"\t\t\t\tfinal_color.a = color.a;\",\n\t\t\t\"\t\t\t\treturn final_color;\",\n\t\t\t\"\t\t}\",\n\t\t].join( \"\\n\" )\n\t};\n\t\n\treturn THREE.VolumeRenderShader1;\n});\n"]}