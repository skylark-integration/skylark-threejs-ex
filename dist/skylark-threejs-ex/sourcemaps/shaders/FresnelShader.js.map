{"version":3,"sources":["shaders/FresnelShader.js"],"names":["define","THREE","FresnelShader","uniforms","mRefractionRatio","value","mFresnelBias","mFresnelPower","mFresnelScale","tCube","vertexShader","join","fragmentShader"],"mappings":";;;;;;;AAAAA,QACC,mBACC,SAASC,GA4EV,OArEAA,EAAMC,eAELC,UAECC,kBAAsBC,MAAO,MAC7BC,cAAkBD,MAAO,IACzBE,eAAmBF,MAAO,GAC1BG,eAAmBH,MAAO,GAC1BI,OAAWJ,MAAO,OAInBK,cAEC,kCACA,8BACA,+BACA,+BAEA,yBACA,4BACA,mCAEA,gBAEA,+DACA,8DAEA,iHAEA,iDAEA,0CACA,4EACA,mFACA,mFACA,uHAEA,iDAEA,KAECC,KAAM,MAERC,gBAEC,6BAEA,yBACA,4BACA,mCAEA,gBAEA,kFACA,uCAEA,uFACA,uFACA,uFAEA,gGAEA,KAECD,KAAM,OAIFV,EAAMC","file":"../../shaders/FresnelShader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Based on Nvidia Cg tutorial\n\t */\n\n\tTHREE.FresnelShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"mRefractionRatio\": { value: 1.02 },\n\t\t\t\"mFresnelBias\": { value: 0.1 },\n\t\t\t\"mFresnelPower\": { value: 2.0 },\n\t\t\t\"mFresnelScale\": { value: 1.0 },\n\t\t\t\"tCube\": { value: null }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform float mRefractionRatio;\",\n\t\t\t\"uniform float mFresnelBias;\",\n\t\t\t\"uniform float mFresnelScale;\",\n\t\t\t\"uniform float mFresnelPower;\",\n\n\t\t\t\"varying vec3 vReflect;\",\n\t\t\t\"varying vec3 vRefract[3];\",\n\t\t\t\"varying float vReflectionFactor;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\"\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\",\n\n\t\t\t\"\tvec3 I = worldPosition.xyz - cameraPosition;\",\n\n\t\t\t\"\tvReflect = reflect( I, worldNormal );\",\n\t\t\t\"\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\",\n\t\t\t\"\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\",\n\t\t\t\"\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\",\n\t\t\t\"\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform samplerCube tCube;\",\n\n\t\t\t\"varying vec3 vReflect;\",\n\t\t\t\"varying vec3 vRefract[3];\",\n\t\t\t\"varying float vReflectionFactor;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\n\t\t\t\"\tvec4 refractedColor = vec4( 1.0 );\",\n\n\t\t\t\"\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\",\n\t\t\t\"\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\",\n\t\t\t\"\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\",\n\n\t\t\t\"\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.FresnelShader;\n});\n"]}