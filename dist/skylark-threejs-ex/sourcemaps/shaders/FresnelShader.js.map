{"version":3,"sources":["shaders/FresnelShader.js"],"names":["define","threex","FresnelShader","uniforms","mRefractionRatio","value","mFresnelBias","mFresnelPower","mFresnelScale","tCube","vertexShader","join","fragmentShader","shaders"],"mappings":";;;;;;;AAAAA,QACI,aACF,SAAUC,GACR,aACA,IAAIC,GACAC,UACIC,kBAAsBC,MAAO,MAC7BC,cAAkBD,MAAO,IACzBE,eAAmBF,MAAO,GAC1BG,eAAmBH,MAAO,GAC1BI,OAAWJ,MAAO,OAEtBK,cACI,kCACA,8BACA,+BACA,+BACA,yBACA,4BACA,mCACA,gBACA,+DACA,8DACA,iHACA,iDACA,0CACA,4EACA,mFACA,mFACA,uHACA,iDACA,KACFC,KAAK,MACPC,gBACI,6BACA,yBACA,4BACA,mCACA,gBACA,kFACA,uCACA,uFACA,uFACA,uFACA,gGACA,KACFD,KAAK,OAEX,OAAOV,EAAOY,QAAQX,cAAgBA","file":"../../shaders/FresnelShader.js","sourcesContent":["define([\r\n    \"../threex\"\r\n],function (threex) {\r\n    'use strict';\r\n    var FresnelShader = {\r\n        uniforms: {\r\n            'mRefractionRatio': { value: 1.02 },\r\n            'mFresnelBias': { value: 0.1 },\r\n            'mFresnelPower': { value: 2 },\r\n            'mFresnelScale': { value: 1 },\r\n            'tCube': { value: null }\r\n        },\r\n        vertexShader: [\r\n            'uniform float mRefractionRatio;',\r\n            'uniform float mFresnelBias;',\r\n            'uniform float mFresnelScale;',\r\n            'uniform float mFresnelPower;',\r\n            'varying vec3 vReflect;',\r\n            'varying vec3 vRefract[3];',\r\n            'varying float vReflectionFactor;',\r\n            'void main() {',\r\n            '\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\r\n            '\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\r\n            '\\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );',\r\n            '\\tvec3 I = worldPosition.xyz - cameraPosition;',\r\n            '\\tvReflect = reflect( I, worldNormal );',\r\n            '\\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );',\r\n            '\\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );',\r\n            '\\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );',\r\n            '\\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );',\r\n            '\\tgl_Position = projectionMatrix * mvPosition;',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            'uniform samplerCube tCube;',\r\n            'varying vec3 vReflect;',\r\n            'varying vec3 vRefract[3];',\r\n            'varying float vReflectionFactor;',\r\n            'void main() {',\r\n            '\\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );',\r\n            '\\tvec4 refractedColor = vec4( 1.0 );',\r\n            '\\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;',\r\n            '\\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;',\r\n            '\\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;',\r\n            '\\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    return threex.shaders.FresnelShader = FresnelShader;\r\n});"]}