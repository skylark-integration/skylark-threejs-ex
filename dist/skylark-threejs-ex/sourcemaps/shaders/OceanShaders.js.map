{"version":3,"sources":["shaders/OceanShaders.js"],"names":["define","THREE","threex","OceanShaders","vertexShader","join","uniforms","u_input","value","u_transformSize","u_subtransformSize","fragmentShader","u_wind","Vector2","u_resolution","u_size","u_phases","u_deltaTime","u_choppiness","u_initialSpectrum","u_displacementMap","u_normalMap","u_geometrySize","u_projectionMatrix","u_viewMatrix","u_cameraPosition","u_skyColor","u_oceanColor","u_sunDirection","u_exposure","shaders"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,KAyRJ,OAxRAA,EAA+B,kBAC3BC,cACI,oBACA,qBACA,mCACA,wCACA,KACFC,KAAK,OAEXF,EAAiC,oBAC7BG,UACIC,SAAaC,MAAO,MACpBC,iBAAqBD,MAAO,KAC5BE,oBAAwBF,MAAO,MAEnCG,gBACI,yBACA,oBACA,6BACA,iCACA,oCACA,oBACA,0CACA,uEACA,IACA,qBACA,sBACA,iDACA,UACA,iDACA,WACA,6HACA,sBACA,kGACA,yHACA,UACA,kGACA,yHACA,WACA,sEACA,qEACA,+DACA,+DACA,2CACA,KACFN,KAAK,OAEXF,EAAqC,wBACjCG,UACIM,QAAYJ,MAAO,IAAIP,EAAMY,QAAQ,GAAI,KACzCC,cAAkBN,MAAO,KACzBO,QAAYP,MAAO,MAEvBJ,cACI,qBACA,uCACA,KACFC,KAAK,MACPM,gBACI,yBACA,oBACA,wBACA,0BACA,yBACA,uBACA,8BACA,wBACA,0BACA,+CACA,IACA,yBACA,yBACA,0DACA,IACA,SACA,qBACA,8CACA,mGACA,mGACA,+CACA,yBACA,mCACA,wBACA,yCACA,4BACA,+BACA,2CACA,uBACA,yDACA,sEACA,kCACA,2EACA,wCACA,2CACA,oEACA,kDACA,oGACA,gDACA,iDACA,+BACA,kCACA,6EACA,yDACA,6GACA,kCACA,kCACA,oCACA,eACA,MACA,2CACA,KACFN,KAAK,OAEXF,EAA0B,aACtBG,UACIU,UAAcR,MAAO,MACrBS,aAAiBT,MAAO,MACxBM,cAAkBN,MAAO,MACzBO,QAAYP,MAAO,OAEvBG,gBACI,yBACA,oBACA,wBACA,0BACA,oBACA,8BACA,6BACA,8BACA,wBACA,0BACA,kDACA,IACA,qBACA,kCACA,8CACA,mGACA,mGACA,wDACA,8CACA,gEACA,+CACA,+CACA,KACFN,KAAK,OAEXF,EAA6B,gBACzBG,UACIS,QAAYP,MAAO,MACnBM,cAAkBN,MAAO,MACzBU,cAAkBV,MAAO,MACzBQ,UAAcR,MAAO,MACrBW,mBAAuBX,MAAO,OAElCG,gBACI,yBACA,oBACA,wBACA,0BACA,oBACA,wBACA,8BACA,8BACA,8BACA,uCACA,0CACA,uEACA,IACA,8BACA,8BACA,IACA,0BACA,kDACA,IACA,qBACA,8CACA,mGACA,mGACA,wDACA,8CACA,qDACA,oDACA,yFACA,sBACA,8GACA,oFACA,oFACA,sDACA,qBACA,sBACA,sBACA,MACA,kDACA,KACFN,KAAK,OAEXF,EAA4B,eACxBG,UACIc,mBAAuBZ,MAAO,MAC9BM,cAAkBN,MAAO,MACzBO,QAAYP,MAAO,OAEvBG,gBACI,yBACA,oBACA,uCACA,8BACA,wBACA,qBACA,sCACA,6CACA,yDACA,gHACA,iHACA,gHACA,iHACA,uCACA,qCACA,2CACA,6CACA,wFACA,KACFN,KAAK,OAEXF,EAAyB,YACrBG,UACIc,mBAAuBZ,MAAO,MAC9Ba,aAAiBb,MAAO,MACxBc,gBAAoBd,MAAO,MAC3BO,QAAYP,MAAO,MACnBe,oBAAwBf,MAAO,MAC/BgB,cAAkBhB,MAAO,MACzBiB,kBAAsBjB,MAAO,MAC7BkB,YAAgBlB,MAAO,MACvBmB,cAAkBnB,MAAO,MACzBoB,gBAAoBpB,MAAO,MAC3BqB,YAAgBrB,MAAO,OAE3BJ,cACI,yBACA,qBACA,oBACA,mCACA,6BACA,wBACA,gCACA,uCACA,qBACA,+FACA,mBACA,cACA,yEACA,KACFC,KAAK,MACPM,gBACI,yBACA,qBACA,oBACA,uCACA,iCACA,iCACA,6BACA,2BACA,+BACA,4BACA,0CACA,yCACA,IACA,qBACA,mDACA,oDACA,qEACA,qCACA,6EACA,wEACA,8BACA,sDACA,KACFN,KAAK,OAEJH,EAAO4B,QAAQ3B,aAAeA","file":"../../shaders/OceanShaders.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var OceanShaders = {};\r\n    OceanShaders['ocean_sim_vertex'] = {\r\n        vertexShader: [\r\n            'varying vec2 vUV;',\r\n            'void main (void) {',\r\n            '\\tvUV = position.xy * 0.5 + 0.5;',\r\n            '\\tgl_Position = vec4(position, 1.0 );',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    OceanShaders['ocean_subtransform'] = {\r\n        uniforms: {\r\n            'u_input': { value: null },\r\n            'u_transformSize': { value: 512 },\r\n            'u_subtransformSize': { value: 250 }\r\n        },\r\n        fragmentShader: [\r\n            'precision highp float;',\r\n            '#include <common>',\r\n            'uniform sampler2D u_input;',\r\n            'uniform float u_transformSize;',\r\n            'uniform float u_subtransformSize;',\r\n            'varying vec2 vUV;',\r\n            'vec2 multiplyComplex (vec2 a, vec2 b) {',\r\n            '\\treturn vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);',\r\n            '}',\r\n            'void main (void) {',\r\n            '\\t#ifdef HORIZONTAL',\r\n            '\\tfloat index = vUV.x * u_transformSize - 0.5;',\r\n            '\\t#else',\r\n            '\\tfloat index = vUV.y * u_transformSize - 0.5;',\r\n            '\\t#endif',\r\n            '\\tfloat evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);',\r\n            '\\t#ifdef HORIZONTAL',\r\n            '\\tvec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;',\r\n            '\\tvec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;',\r\n            '\\t#else',\r\n            '\\tvec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;',\r\n            '\\tvec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;',\r\n            '\\t#endif',\r\n            '\\tfloat twiddleArgument = -2.0 * PI * (index / u_subtransformSize);',\r\n            '\\tvec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));',\r\n            '\\tvec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);',\r\n            '\\tvec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);',\r\n            '\\tgl_FragColor = vec4(outputA, outputB);',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    OceanShaders['ocean_initial_spectrum'] = {\r\n        uniforms: {\r\n            'u_wind': { value: new THREE.Vector2(10, 10) },\r\n            'u_resolution': { value: 512 },\r\n            'u_size': { value: 250 }\r\n        },\r\n        vertexShader: [\r\n            'void main (void) {',\r\n            '\\tgl_Position = vec4(position, 1.0);',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            'precision highp float;',\r\n            '#include <common>',\r\n            'const float G = 9.81;',\r\n            'const float KM = 370.0;',\r\n            'const float CM = 0.23;',\r\n            'uniform vec2 u_wind;',\r\n            'uniform float u_resolution;',\r\n            'uniform float u_size;',\r\n            'float omega (float k) {',\r\n            '\\treturn sqrt(G * k * (1.0 + pow2(k / KM)));',\r\n            '}',\r\n            '#if __VERSION__ == 100',\r\n            'float tanh (float x) {',\r\n            '\\treturn (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));',\r\n            '}',\r\n            '#endif',\r\n            'void main (void) {',\r\n            '\\tvec2 coordinates = gl_FragCoord.xy - 0.5;',\r\n            '\\tfloat n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',\r\n            '\\tfloat m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',\r\n            '\\tvec2 K = (2.0 * PI * vec2(n, m)) / u_size;',\r\n            '\\tfloat k = length(K);',\r\n            '\\tfloat l_wind = length(u_wind);',\r\n            '\\tfloat Omega = 0.84;',\r\n            '\\tfloat kp = G * pow2(Omega / l_wind);',\r\n            '\\tfloat c = omega(k) / k;',\r\n            '\\tfloat cp = omega(kp) / kp;',\r\n            '\\tfloat Lpm = exp(-1.25 * pow2(kp / k));',\r\n            '\\tfloat gamma = 1.7;',\r\n            '\\tfloat sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));',\r\n            '\\tfloat Gamma = exp(-pow2(sqrt(k / kp) - 1.0) / 2.0 * pow2(sigma));',\r\n            '\\tfloat Jp = pow(gamma, Gamma);',\r\n            '\\tfloat Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));',\r\n            '\\tfloat alphap = 0.006 * sqrt(Omega);',\r\n            '\\tfloat Bl = 0.5 * alphap * cp / c * Fp;',\r\n            '\\tfloat z0 = 0.000037 * pow2(l_wind) / G * pow(l_wind / cp, 0.9);',\r\n            '\\tfloat uStar = 0.41 * l_wind / log(10.0 / z0);',\r\n            '\\tfloat alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));',\r\n            '\\tfloat Fm = exp(-0.25 * pow2(k / KM - 1.0));',\r\n            '\\tfloat Bh = 0.5 * alpham * CM / c * Fm * Lpm;',\r\n            '\\tfloat a0 = log(2.0) / 4.0;',\r\n            '\\tfloat am = 0.13 * uStar / CM;',\r\n            '\\tfloat Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));',\r\n            '\\tfloat cosPhi = dot(normalize(u_wind), normalize(K));',\r\n            '\\tfloat S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));',\r\n            '\\tfloat dk = 2.0 * PI / u_size;',\r\n            '\\tfloat h = sqrt(S / 2.0) * dk;',\r\n            '\\tif (K.x == 0.0 && K.y == 0.0) {',\r\n            '\\t\\th = 0.0;',\r\n            '\\t}',\r\n            '\\tgl_FragColor = vec4(h, 0.0, 0.0, 0.0);',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    OceanShaders['ocean_phase'] = {\r\n        uniforms: {\r\n            'u_phases': { value: null },\r\n            'u_deltaTime': { value: null },\r\n            'u_resolution': { value: null },\r\n            'u_size': { value: null }\r\n        },\r\n        fragmentShader: [\r\n            'precision highp float;',\r\n            '#include <common>',\r\n            'const float G = 9.81;',\r\n            'const float KM = 370.0;',\r\n            'varying vec2 vUV;',\r\n            'uniform sampler2D u_phases;',\r\n            'uniform float u_deltaTime;',\r\n            'uniform float u_resolution;',\r\n            'uniform float u_size;',\r\n            'float omega (float k) {',\r\n            '\\treturn sqrt(G * k * (1.0 + k * k / KM * KM));',\r\n            '}',\r\n            'void main (void) {',\r\n            '\\tfloat deltaTime = 1.0 / 60.0;',\r\n            '\\tvec2 coordinates = gl_FragCoord.xy - 0.5;',\r\n            '\\tfloat n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',\r\n            '\\tfloat m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',\r\n            '\\tvec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;',\r\n            '\\tfloat phase = texture2D(u_phases, vUV).r;',\r\n            '\\tfloat deltaPhase = omega(length(waveVector)) * u_deltaTime;',\r\n            '\\tphase = mod(phase + deltaPhase, 2.0 * PI);',\r\n            '\\tgl_FragColor = vec4(phase, 0.0, 0.0, 0.0);',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    OceanShaders['ocean_spectrum'] = {\r\n        uniforms: {\r\n            'u_size': { value: null },\r\n            'u_resolution': { value: null },\r\n            'u_choppiness': { value: null },\r\n            'u_phases': { value: null },\r\n            'u_initialSpectrum': { value: null }\r\n        },\r\n        fragmentShader: [\r\n            'precision highp float;',\r\n            '#include <common>',\r\n            'const float G = 9.81;',\r\n            'const float KM = 370.0;',\r\n            'varying vec2 vUV;',\r\n            'uniform float u_size;',\r\n            'uniform float u_resolution;',\r\n            'uniform float u_choppiness;',\r\n            'uniform sampler2D u_phases;',\r\n            'uniform sampler2D u_initialSpectrum;',\r\n            'vec2 multiplyComplex (vec2 a, vec2 b) {',\r\n            '\\treturn vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);',\r\n            '}',\r\n            'vec2 multiplyByI (vec2 z) {',\r\n            '\\treturn vec2(-z[1], z[0]);',\r\n            '}',\r\n            'float omega (float k) {',\r\n            '\\treturn sqrt(G * k * (1.0 + k * k / KM * KM));',\r\n            '}',\r\n            'void main (void) {',\r\n            '\\tvec2 coordinates = gl_FragCoord.xy - 0.5;',\r\n            '\\tfloat n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;',\r\n            '\\tfloat m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;',\r\n            '\\tvec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;',\r\n            '\\tfloat phase = texture2D(u_phases, vUV).r;',\r\n            '\\tvec2 phaseVector = vec2(cos(phase), sin(phase));',\r\n            '\\tvec2 h0 = texture2D(u_initialSpectrum, vUV).rg;',\r\n            '\\tvec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;',\r\n            '\\th0Star.y *= -1.0;',\r\n            '\\tvec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));',\r\n            '\\tvec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;',\r\n            '\\tvec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;',\r\n            '\\tif (waveVector.x == 0.0 && waveVector.y == 0.0) {',\r\n            '\\t\\th = vec2(0.0);',\r\n            '\\t\\thX = vec2(0.0);',\r\n            '\\t\\thZ = vec2(0.0);',\r\n            '\\t}',\r\n            '\\tgl_FragColor = vec4(hX + multiplyByI(h), hZ);',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    OceanShaders['ocean_normals'] = {\r\n        uniforms: {\r\n            'u_displacementMap': { value: null },\r\n            'u_resolution': { value: null },\r\n            'u_size': { value: null }\r\n        },\r\n        fragmentShader: [\r\n            'precision highp float;',\r\n            'varying vec2 vUV;',\r\n            'uniform sampler2D u_displacementMap;',\r\n            'uniform float u_resolution;',\r\n            'uniform float u_size;',\r\n            'void main (void) {',\r\n            '\\tfloat texel = 1.0 / u_resolution;',\r\n            '\\tfloat texelSize = u_size / u_resolution;',\r\n            '\\tvec3 center = texture2D(u_displacementMap, vUV).rgb;',\r\n            '\\tvec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;',\r\n            '\\tvec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;',\r\n            '\\tvec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;',\r\n            '\\tvec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;',\r\n            '\\tvec3 topRight = cross(right, top);',\r\n            '\\tvec3 topLeft = cross(top, left);',\r\n            '\\tvec3 bottomLeft = cross(left, bottom);',\r\n            '\\tvec3 bottomRight = cross(bottom, right);',\r\n            '\\tgl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    OceanShaders['ocean_main'] = {\r\n        uniforms: {\r\n            'u_displacementMap': { value: null },\r\n            'u_normalMap': { value: null },\r\n            'u_geometrySize': { value: null },\r\n            'u_size': { value: null },\r\n            'u_projectionMatrix': { value: null },\r\n            'u_viewMatrix': { value: null },\r\n            'u_cameraPosition': { value: null },\r\n            'u_skyColor': { value: null },\r\n            'u_oceanColor': { value: null },\r\n            'u_sunDirection': { value: null },\r\n            'u_exposure': { value: null }\r\n        },\r\n        vertexShader: [\r\n            'precision highp float;',\r\n            'varying vec3 vPos;',\r\n            'varying vec2 vUV;',\r\n            'uniform mat4 u_projectionMatrix;',\r\n            'uniform mat4 u_viewMatrix;',\r\n            'uniform float u_size;',\r\n            'uniform float u_geometrySize;',\r\n            'uniform sampler2D u_displacementMap;',\r\n            'void main (void) {',\r\n            '\\tvec3 newPos = position + texture2D(u_displacementMap, uv).rgb * (u_geometrySize / u_size);',\r\n            '\\tvPos = newPos;',\r\n            '\\tvUV = uv;',\r\n            '\\tgl_Position = u_projectionMatrix * u_viewMatrix * vec4(newPos, 1.0);',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            'precision highp float;',\r\n            'varying vec3 vPos;',\r\n            'varying vec2 vUV;',\r\n            'uniform sampler2D u_displacementMap;',\r\n            'uniform sampler2D u_normalMap;',\r\n            'uniform vec3 u_cameraPosition;',\r\n            'uniform vec3 u_oceanColor;',\r\n            'uniform vec3 u_skyColor;',\r\n            'uniform vec3 u_sunDirection;',\r\n            'uniform float u_exposure;',\r\n            'vec3 hdr (vec3 color, float exposure) {',\r\n            '\\treturn 1.0 - exp(-color * exposure);',\r\n            '}',\r\n            'void main (void) {',\r\n            '\\tvec3 normal = texture2D(u_normalMap, vUV).rgb;',\r\n            '\\tvec3 view = normalize(u_cameraPosition - vPos);',\r\n            '\\tfloat fresnel = 0.02 + 0.98 * pow(1.0 - dot(normal, view), 5.0);',\r\n            '\\tvec3 sky = fresnel * u_skyColor;',\r\n            '\\tfloat diffuse = clamp(dot(normal, normalize(u_sunDirection)), 0.0, 1.0);',\r\n            '\\tvec3 water = (1.0 - fresnel) * u_oceanColor * u_skyColor * diffuse;',\r\n            '\\tvec3 color = sky + water;',\r\n            '\\tgl_FragColor = vec4(hdr(color, u_exposure), 1.0);',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    return threex.shaders.OceanShaders = OceanShaders;\r\n});"]}