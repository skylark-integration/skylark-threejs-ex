{"version":3,"sources":["shaders/OceanShaders.js"],"names":["define","THREE","OceanShaders","vertexShader","join","uniforms","u_input","value","u_transformSize","u_subtransformSize","fragmentShader","u_wind","Vector2","u_resolution","u_size","u_phases","u_deltaTime","u_choppiness","u_initialSpectrum","u_displacementMap","u_normalMap","u_geometrySize","u_projectionMatrix","u_viewMatrix","u_cameraPosition","u_skyColor","u_oceanColor","u_sunDirection","u_exposure"],"mappings":"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","file":"../../shaders/OceanShaders.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/* Author: Aleksandr Albert\n\t// Website: www.routter.co.tt\n\n\t// Description: A deep water ocean shader set\n\t// based on an implementation of a Tessendorf Waves\n\t// originally presented by David Li ( www.david.li/waves )\n\n\t// The general method is to apply shaders to simulation Framebuffers\n\t// and then sample these framebuffers when rendering the ocean mesh\n\n\t// The set uses 7 shaders:\n\n\t// -- Simulation shaders\n\t// [1] ocean_sim_vertex         -> Vertex shader used to set up a 2x2 simulation plane centered at (0,0)\n\t// [2] ocean_subtransform       -> Fragment shader used to subtransform the mesh (generates the displacement map)\n\t// [3] ocean_initial_spectrum   -> Fragment shader used to set intitial wave frequency at a texel coordinate\n\t// [4] ocean_phase              -> Fragment shader used to set wave phase at a texel coordinate\n\t// [5] ocean_spectrum           -> Fragment shader used to set current wave frequency at a texel coordinate\n\t// [6] ocean_normal             -> Fragment shader used to set face normals at a texel coordinate\n\n\t// -- Rendering Shader\n\t// [7] ocean_main               -> Vertex and Fragment shader used to create the final render\n\t*/\n\n\tTHREE.OceanShaders = {};\n\tTHREE.OceanShaders[ \"ocean_sim_vertex\" ] = {\n\t\tvertexShader: [\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"void main (void) {\",\n\t\t\t\"\tvUV = position.xy * 0.5 + 0.5;\",\n\t\t\t\"\tgl_Position = vec4(position, 1.0 );\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\t};\n\tTHREE.OceanShaders[ \"ocean_subtransform\" ] = {\n\t\tuniforms: {\n\t\t\t\"u_input\": { value: null },\n\t\t\t\"u_transformSize\": { value: 512.0 },\n\t\t\t\"u_subtransformSize\": { value: 250.0 }\n\t\t},\n\t\tfragmentShader: [\n\t\t\t//GPU FFT using a Stockham formulation\n\n\t\t\t\"precision highp float;\",\n\t\t\t\"#include <common>\",\n\n\t\t\t\"uniform sampler2D u_input;\",\n\t\t\t\"uniform float u_transformSize;\",\n\t\t\t\"uniform float u_subtransformSize;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"vec2 multiplyComplex (vec2 a, vec2 b) {\",\n\t\t\t\"\treturn vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);\",\n\t\t\t\"}\",\n\n\t\t\t\"void main (void) {\",\n\t\t\t\"\t#ifdef HORIZONTAL\",\n\t\t\t\"\tfloat index = vUV.x * u_transformSize - 0.5;\",\n\t\t\t\"\t#else\",\n\t\t\t\"\tfloat index = vUV.y * u_transformSize - 0.5;\",\n\t\t\t\"\t#endif\",\n\n\t\t\t\"\tfloat evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);\",\n\n\t\t\t//transform two complex sequences simultaneously\n\t\t\t\"\t#ifdef HORIZONTAL\",\n\t\t\t\"\tvec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;\",\n\t\t\t\"\tvec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;\",\n\t\t\t\"\t#else\",\n\t\t\t\"\tvec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;\",\n\t\t\t\"\tvec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;\",\n\t\t\t\"\t#endif\",\n\n\t\t\t\"\tfloat twiddleArgument = -2.0 * PI * (index / u_subtransformSize);\",\n\t\t\t\"\tvec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));\",\n\n\t\t\t\"\tvec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);\",\n\t\t\t\"\tvec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);\",\n\n\t\t\t\"\tgl_FragColor = vec4(outputA, outputB);\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\t};\n\tTHREE.OceanShaders[ \"ocean_initial_spectrum\" ] = {\n\t\tuniforms: {\n\t\t\t\"u_wind\": { value: new THREE.Vector2( 10.0, 10.0 ) },\n\t\t\t\"u_resolution\": { value: 512.0 },\n\t\t\t\"u_size\": { value: 250.0 }\n\t\t},\n\t\tvertexShader: [\n\t\t\t\"void main (void) {\",\n\t\t\t\"\tgl_Position = vec4(position, 1.0);\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" ),\n\t\tfragmentShader: [\n\t\t\t\"precision highp float;\",\n\t\t\t\"#include <common>\",\n\n\t\t\t\"const float G = 9.81;\",\n\t\t\t\"const float KM = 370.0;\",\n\t\t\t\"const float CM = 0.23;\",\n\n\t\t\t\"uniform vec2 u_wind;\",\n\t\t\t\"uniform float u_resolution;\",\n\t\t\t\"uniform float u_size;\",\n\n\t\t\t\"float omega (float k) {\",\n\t\t\t\"\treturn sqrt(G * k * (1.0 + pow2(k / KM)));\",\n\t\t\t\"}\",\n\n\t\t\t\"#if __VERSION__ == 100\",\n\t\t\t\"float tanh (float x) {\",\n\t\t\t\"\treturn (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));\",\n\t\t\t\"}\",\n\t\t\t\"#endif\",\n\n\t\t\t\"void main (void) {\",\n\t\t\t\"\tvec2 coordinates = gl_FragCoord.xy - 0.5;\",\n\n\t\t\t\"\tfloat n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;\",\n\t\t\t\"\tfloat m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;\",\n\n\t\t\t\"\tvec2 K = (2.0 * PI * vec2(n, m)) / u_size;\",\n\t\t\t\"\tfloat k = length(K);\",\n\n\t\t\t\"\tfloat l_wind = length(u_wind);\",\n\n\t\t\t\"\tfloat Omega = 0.84;\",\n\t\t\t\"\tfloat kp = G * pow2(Omega / l_wind);\",\n\n\t\t\t\"\tfloat c = omega(k) / k;\",\n\t\t\t\"\tfloat cp = omega(kp) / kp;\",\n\n\t\t\t\"\tfloat Lpm = exp(-1.25 * pow2(kp / k));\",\n\t\t\t\"\tfloat gamma = 1.7;\",\n\t\t\t\"\tfloat sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));\",\n\t\t\t\"\tfloat Gamma = exp(-pow2(sqrt(k / kp) - 1.0) / 2.0 * pow2(sigma));\",\n\t\t\t\"\tfloat Jp = pow(gamma, Gamma);\",\n\t\t\t\"\tfloat Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));\",\n\t\t\t\"\tfloat alphap = 0.006 * sqrt(Omega);\",\n\t\t\t\"\tfloat Bl = 0.5 * alphap * cp / c * Fp;\",\n\n\t\t\t\"\tfloat z0 = 0.000037 * pow2(l_wind) / G * pow(l_wind / cp, 0.9);\",\n\t\t\t\"\tfloat uStar = 0.41 * l_wind / log(10.0 / z0);\",\n\t\t\t\"\tfloat alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));\",\n\t\t\t\"\tfloat Fm = exp(-0.25 * pow2(k / KM - 1.0));\",\n\t\t\t\"\tfloat Bh = 0.5 * alpham * CM / c * Fm * Lpm;\",\n\n\t\t\t\"\tfloat a0 = log(2.0) / 4.0;\",\n\t\t\t\"\tfloat am = 0.13 * uStar / CM;\",\n\t\t\t\"\tfloat Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));\",\n\n\t\t\t\"\tfloat cosPhi = dot(normalize(u_wind), normalize(K));\",\n\n\t\t\t\"\tfloat S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));\",\n\n\t\t\t\"\tfloat dk = 2.0 * PI / u_size;\",\n\t\t\t\"\tfloat h = sqrt(S / 2.0) * dk;\",\n\n\t\t\t\"\tif (K.x == 0.0 && K.y == 0.0) {\",\n\t\t\t\"\t\th = 0.0;\", //no DC term\n\t\t\t\"\t}\",\n\t\t\t\"\tgl_FragColor = vec4(h, 0.0, 0.0, 0.0);\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\t};\n\tTHREE.OceanShaders[ \"ocean_phase\" ] = {\n\t\tuniforms: {\n\t\t\t\"u_phases\": { value: null },\n\t\t\t\"u_deltaTime\": { value: null },\n\t\t\t\"u_resolution\": { value: null },\n\t\t\t\"u_size\": { value: null }\n\t\t},\n\t\tfragmentShader: [\n\t\t\t\"precision highp float;\",\n\t\t\t\"#include <common>\",\n\n\t\t\t\"const float G = 9.81;\",\n\t\t\t\"const float KM = 370.0;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"uniform sampler2D u_phases;\",\n\t\t\t\"uniform float u_deltaTime;\",\n\t\t\t\"uniform float u_resolution;\",\n\t\t\t\"uniform float u_size;\",\n\n\t\t\t\"float omega (float k) {\",\n\t\t\t\"\treturn sqrt(G * k * (1.0 + k * k / KM * KM));\",\n\t\t\t\"}\",\n\n\t\t\t\"void main (void) {\",\n\t\t\t\"\tfloat deltaTime = 1.0 / 60.0;\",\n\t\t\t\"\tvec2 coordinates = gl_FragCoord.xy - 0.5;\",\n\t\t\t\"\tfloat n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;\",\n\t\t\t\"\tfloat m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;\",\n\t\t\t\"\tvec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;\",\n\n\t\t\t\"\tfloat phase = texture2D(u_phases, vUV).r;\",\n\t\t\t\"\tfloat deltaPhase = omega(length(waveVector)) * u_deltaTime;\",\n\t\t\t\"\tphase = mod(phase + deltaPhase, 2.0 * PI);\",\n\n\t\t\t\"\tgl_FragColor = vec4(phase, 0.0, 0.0, 0.0);\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\t};\n\tTHREE.OceanShaders[ \"ocean_spectrum\" ] = {\n\t\tuniforms: {\n\t\t\t\"u_size\": { value: null },\n\t\t\t\"u_resolution\": { value: null },\n\t\t\t\"u_choppiness\": { value: null },\n\t\t\t\"u_phases\": { value: null },\n\t\t\t\"u_initialSpectrum\": { value: null }\n\t\t},\n\t\tfragmentShader: [\n\t\t\t\"precision highp float;\",\n\t\t\t\"#include <common>\",\n\n\t\t\t\"const float G = 9.81;\",\n\t\t\t\"const float KM = 370.0;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"uniform float u_size;\",\n\t\t\t\"uniform float u_resolution;\",\n\t\t\t\"uniform float u_choppiness;\",\n\t\t\t\"uniform sampler2D u_phases;\",\n\t\t\t\"uniform sampler2D u_initialSpectrum;\",\n\n\t\t\t\"vec2 multiplyComplex (vec2 a, vec2 b) {\",\n\t\t\t\"\treturn vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);\",\n\t\t\t\"}\",\n\n\t\t\t\"vec2 multiplyByI (vec2 z) {\",\n\t\t\t\"\treturn vec2(-z[1], z[0]);\",\n\t\t\t\"}\",\n\n\t\t\t\"float omega (float k) {\",\n\t\t\t\"\treturn sqrt(G * k * (1.0 + k * k / KM * KM));\",\n\t\t\t\"}\",\n\n\t\t\t\"void main (void) {\",\n\t\t\t\"\tvec2 coordinates = gl_FragCoord.xy - 0.5;\",\n\t\t\t\"\tfloat n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;\",\n\t\t\t\"\tfloat m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;\",\n\t\t\t\"\tvec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;\",\n\n\t\t\t\"\tfloat phase = texture2D(u_phases, vUV).r;\",\n\t\t\t\"\tvec2 phaseVector = vec2(cos(phase), sin(phase));\",\n\n\t\t\t\"\tvec2 h0 = texture2D(u_initialSpectrum, vUV).rg;\",\n\t\t\t\"\tvec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;\",\n\t\t\t\"\th0Star.y *= -1.0;\",\n\n\t\t\t\"\tvec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));\",\n\n\t\t\t\"\tvec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;\",\n\t\t\t\"\tvec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;\",\n\n\t\t\t//no DC term\n\t\t\t\"\tif (waveVector.x == 0.0 && waveVector.y == 0.0) {\",\n\t\t\t\"\t\th = vec2(0.0);\",\n\t\t\t\"\t\thX = vec2(0.0);\",\n\t\t\t\"\t\thZ = vec2(0.0);\",\n\t\t\t\"\t}\",\n\n\t\t\t\"\tgl_FragColor = vec4(hX + multiplyByI(h), hZ);\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\t};\n\tTHREE.OceanShaders[ \"ocean_normals\" ] = {\n\t\tuniforms: {\n\t\t\t\"u_displacementMap\": { value: null },\n\t\t\t\"u_resolution\": { value: null },\n\t\t\t\"u_size\": { value: null }\n\t\t},\n\t\tfragmentShader: [\n\t\t\t\"precision highp float;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"uniform sampler2D u_displacementMap;\",\n\t\t\t\"uniform float u_resolution;\",\n\t\t\t\"uniform float u_size;\",\n\n\t\t\t\"void main (void) {\",\n\t\t\t\"\tfloat texel = 1.0 / u_resolution;\",\n\t\t\t\"\tfloat texelSize = u_size / u_resolution;\",\n\n\t\t\t\"\tvec3 center = texture2D(u_displacementMap, vUV).rgb;\",\n\t\t\t\"\tvec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;\",\n\t\t\t\"\tvec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;\",\n\t\t\t\"\tvec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;\",\n\t\t\t\"\tvec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;\",\n\n\t\t\t\"\tvec3 topRight = cross(right, top);\",\n\t\t\t\"\tvec3 topLeft = cross(top, left);\",\n\t\t\t\"\tvec3 bottomLeft = cross(left, bottom);\",\n\t\t\t\"\tvec3 bottomRight = cross(bottom, right);\",\n\n\t\t\t\"\tgl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\t};\n\tTHREE.OceanShaders[ \"ocean_main\" ] = {\n\t\tuniforms: {\n\t\t\t\"u_displacementMap\": { value: null },\n\t\t\t\"u_normalMap\": { value: null },\n\t\t\t\"u_geometrySize\": { value: null },\n\t\t\t\"u_size\": { value: null },\n\t\t\t\"u_projectionMatrix\": { value: null },\n\t\t\t\"u_viewMatrix\": { value: null },\n\t\t\t\"u_cameraPosition\": { value: null },\n\t\t\t\"u_skyColor\": { value: null },\n\t\t\t\"u_oceanColor\": { value: null },\n\t\t\t\"u_sunDirection\": { value: null },\n\t\t\t\"u_exposure\": { value: null }\n\t\t},\n\t\tvertexShader: [\n\t\t\t\"precision highp float;\",\n\n\t\t\t\"varying vec3 vPos;\",\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"uniform mat4 u_projectionMatrix;\",\n\t\t\t\"uniform mat4 u_viewMatrix;\",\n\t\t\t\"uniform float u_size;\",\n\t\t\t\"uniform float u_geometrySize;\",\n\t\t\t\"uniform sampler2D u_displacementMap;\",\n\n\t\t\t\"void main (void) {\",\n\t\t\t\"\tvec3 newPos = position + texture2D(u_displacementMap, uv).rgb * (u_geometrySize / u_size);\",\n\t\t\t\"\tvPos = newPos;\",\n\t\t\t\"\tvUV = uv;\",\n\t\t\t\"\tgl_Position = u_projectionMatrix * u_viewMatrix * vec4(newPos, 1.0);\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" ),\n\t\tfragmentShader: [\n\t\t\t\"precision highp float;\",\n\n\t\t\t\"varying vec3 vPos;\",\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"uniform sampler2D u_displacementMap;\",\n\t\t\t\"uniform sampler2D u_normalMap;\",\n\t\t\t\"uniform vec3 u_cameraPosition;\",\n\t\t\t\"uniform vec3 u_oceanColor;\",\n\t\t\t\"uniform vec3 u_skyColor;\",\n\t\t\t\"uniform vec3 u_sunDirection;\",\n\t\t\t\"uniform float u_exposure;\",\n\n\t\t\t\"vec3 hdr (vec3 color, float exposure) {\",\n\t\t\t\"\treturn 1.0 - exp(-color * exposure);\",\n\t\t\t\"}\",\n\n\t\t\t\"void main (void) {\",\n\t\t\t\"\tvec3 normal = texture2D(u_normalMap, vUV).rgb;\",\n\n\t\t\t\"\tvec3 view = normalize(u_cameraPosition - vPos);\",\n\t\t\t\"\tfloat fresnel = 0.02 + 0.98 * pow(1.0 - dot(normal, view), 5.0);\",\n\t\t\t\"\tvec3 sky = fresnel * u_skyColor;\",\n\n\t\t\t\"\tfloat diffuse = clamp(dot(normal, normalize(u_sunDirection)), 0.0, 1.0);\",\n\t\t\t\"\tvec3 water = (1.0 - fresnel) * u_oceanColor * u_skyColor * diffuse;\",\n\n\t\t\t\"\tvec3 color = sky + water;\",\n\n\t\t\t\"\tgl_FragColor = vec4(hdr(color, u_exposure), 1.0);\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\t};\n\t\n\treturn THREE.OceanShaders;\n});\n"]}