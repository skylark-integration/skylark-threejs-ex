{"version":3,"sources":["shaders/FreiChenShader.js"],"names":["define","THREE","FreiChenShader","uniforms","tDiffuse","value","aspect","Vector2","vertexShader","join","fragmentShader"],"mappings":";;;;;;;AAAAA,QACC,mBACC,SAASC,GAgGV,OAtFAA,EAAMC,gBAELC,UAECC,UAAcC,MAAO,MACrBC,QAAYD,MAAO,IAAIJ,EAAMM,QAAS,IAAK,OAG5CC,cAEC,oBAEA,gBAEA,cACA,8EAEA,KAECC,KAAM,MAERC,gBAEC,8BACA,oBAEA,uBAEA,qDAGA,aAIA,gIACA,gIACA,gIACA,gIACA,+DACA,+DACA,kNACA,kNACA,8MAEA,kBACA,IAEA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eAEA,YACA,kBACA,iBAGA,oCACA,sCACA,4EACA,4CACA,QACA,MAGA,8BACA,gFACA,0BACA,MAEA,qDACA,oEAEA,+CACA,KAECD,KAAM,OAIFR,EAAMC","file":"../../shaders/FreiChenShader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog\n\t *\n\t * Edge Detection Shader using Frei-Chen filter\n\t * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n\t *\n\t * aspect: vec2 of (1/width, 1/height)\n\t */\n\n\tTHREE.FreiChenShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"aspect\": { value: new THREE.Vector2( 512, 512 ) }\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform vec2 aspect;\",\n\n\t\t\t\"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\",\n\n\n\t\t\t\"mat3 G[9];\",\n\n\t\t\t// hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n\n\t\t\t\"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\",\n\t\t\t\"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\",\n\t\t\t\"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\",\n\t\t\t\"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\",\n\t\t\t\"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\",\n\t\t\t\"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\",\n\t\t\t\"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\",\n\t\t\t\"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\",\n\t\t\t\"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\",\n\n\t\t\t\"void main(void)\",\n\t\t\t\"{\",\n\n\t\t\t\"\tG[0] = g0,\",\n\t\t\t\"\tG[1] = g1,\",\n\t\t\t\"\tG[2] = g2,\",\n\t\t\t\"\tG[3] = g3,\",\n\t\t\t\"\tG[4] = g4,\",\n\t\t\t\"\tG[5] = g5,\",\n\t\t\t\"\tG[6] = g6,\",\n\t\t\t\"\tG[7] = g7,\",\n\t\t\t\"\tG[8] = g8;\",\n\n\t\t\t\"\tmat3 I;\",\n\t\t\t\"\tfloat cnv[9];\",\n\t\t\t\"\tvec3 sample;\",\n\n\t\t\t/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n\t\t\t\"\tfor (float i=0.0; i<3.0; i++) {\",\n\t\t\t\"\t\tfor (float j=0.0; j<3.0; j++) {\",\n\t\t\t\"\t\t\tsample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\",\n\t\t\t\"\t\t\tI[int(i)][int(j)] = length(sample);\",\n\t\t\t\"\t\t}\",\n\t\t\t\"\t}\",\n\n\t\t\t/* calculate the convolution values for all the masks */\n\t\t\t\"\tfor (int i=0; i<9; i++) {\",\n\t\t\t\"\t\tfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\",\n\t\t\t\"\t\tcnv[i] = dp3 * dp3;\",\n\t\t\t\"\t}\",\n\n\t\t\t\"\tfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\",\n\t\t\t\"\tfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\",\n\n\t\t\t\"\tgl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\",\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\t};\n\n\t\n\treturn THREE.FreiChenShader;\n});"]}