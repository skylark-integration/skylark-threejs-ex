{"version":3,"sources":["shaders/GodRaysShader.js"],"names":["define","THREE","GodRaysDepthMaskShader","uniforms","tInput","value","vertexShader","join","fragmentShader","GodRaysGenerateShader","fStepSize","vSunPositionScreenSpace","Vector2","GodRaysCombineShader","tColors","tGodRays","fGodRayIntensity","GodRaysFakeSunShader","fAspect","sunColor","Color","bgColor"],"mappings":";;;;;;;AAAAA,QACC,mBACC,SAASC,GA0UV,OArTAA,EAAMC,wBAELC,UAECC,QACCC,MAAO,OAKTC,cAEC,oBAEA,gBAEA,aACA,6EAEA,KAECC,KAAM,MAERC,gBAEC,oBAEA,4BAEA,gBAEA,2DAGA,KAECD,KAAM,OAoBTN,EAAMQ,uBAELN,UAECC,QACCC,MAAO,MAERK,WACCL,MAAO,GAERM,yBACCN,MAAO,IAAIJ,EAAMW,QAAS,GAAK,MAKjCN,cAEC,oBAEA,gBAEA,aACA,6EAEA,KAECC,KAAM,MAERC,gBAEC,4BAEA,oBAEA,4BAEA,wCACA,2BAEA,gBAIA,gDACA,kCAIA,2CAIA,kCAEA,sBACA,qBA2BA,wEACA,iBAEA,wEACA,iBAEA,wEACA,iBAEA,wEACA,iBAEA,wEACA,iBAEA,wEACA,iBASA,8CACA,0BAEA,KAECD,KAAM,OASTN,EAAMY,sBAELV,UAECW,SACCT,MAAO,MAGRU,UACCV,MAAO,MAGRW,kBACCX,MAAO,KAGRM,yBACCN,MAAO,IAAIJ,EAAMW,QAAS,GAAK,MAKjCN,cAEC,oBAEA,gBAEA,cACA,8EAEA,KAECC,KAAM,MAERC,gBAEC,oBAEA,6BACA,8BAEA,wCACA,kCAEA,gBAMA,8GACA,0BAEA,KAECD,KAAM,OAUTN,EAAMgB,sBAELd,UAECQ,yBACCN,MAAO,IAAIJ,EAAMW,QAAS,GAAK,KAGhCM,SACCb,MAAO,GAGRc,UACCd,MAAO,IAAIJ,EAAMmB,MAAO,WAGzBC,SACChB,MAAO,IAAIJ,EAAMmB,MAAO,KAK1Bd,cAEC,oBAEA,gBAEA,cACA,8EAEA,KAECC,KAAM,MAERC,gBAEC,oBAEA,wCACA,yBAEA,yBACA,wBAEA,gBAEA,+CAIA,uBAEA,0DACA,0CAEA,6DACA,0BAEA,KAECD,KAAM,OAIFN","file":"../../shaders/GodRaysShader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author huwb / http://huwbowles.com/\n\t *\n\t * God-rays (crepuscular rays)\n\t *\n\t * Similar implementation to the one used by Crytek for CryEngine 2 [Sousa2008].\n\t * Blurs a mask generated from the depth map along radial lines emanating from the light\n\t * source. The blur repeatedly applies a blur filter of increasing support but constant\n\t * sample count to produce a blur filter with large support.\n\t *\n\t * My implementation performs 3 passes, similar to the implementation from Sousa. I found\n\t * just 6 samples per pass produced acceptible results. The blur is applied three times,\n\t * with decreasing filter support. The result is equivalent to a single pass with\n\t * 6*6*6 = 216 samples.\n\t *\n\t * References:\n\t *\n\t * Sousa2008 - Crysis Next Gen Effects, GDC2008, http://www.crytek.com/sites/default/files/GDC08_SousaT_CrysisEffects.ppt\n\t */\n\n\tTHREE.GodRaysDepthMaskShader = {\n\n\t\tuniforms: {\n\n\t\t\ttInput: {\n\t\t\t\tvalue: null\n\t\t\t}\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\" vUv = uv;\",\n\t\t\t\" gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform sampler2D tInput;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );\",\n\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n\n\t/**\n\t * The god-ray generation shader.\n\t *\n\t * First pass:\n\t *\n\t * The depth map is blurred along radial lines towards the \"sun\". The\n\t * output is written to a temporary render target (I used a 1/4 sized\n\t * target).\n\t *\n\t * Pass two & three:\n\t *\n\t * The results of the previous pass are re-blurred, each time with a\n\t * decreased distance between samples.\n\t */\n\n\tTHREE.GodRaysGenerateShader = {\n\n\t\tuniforms: {\n\n\t\t\ttInput: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tfStepSize: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tvSunPositionScreenSpace: {\n\t\t\t\tvalue: new THREE.Vector2( 0.5, 0.5 )\n\t\t\t}\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\" vUv = uv;\",\n\t\t\t\" gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"#define TAPS_PER_PASS 6.0\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform sampler2D tInput;\",\n\n\t\t\t\"uniform vec2 vSunPositionScreenSpace;\",\n\t\t\t\"uniform float fStepSize;\", // filter step size\n\n\t\t\t\"void main() {\",\n\n\t\t\t// delta from current pixel to \"sun\" position\n\n\t\t\t\"\tvec2 delta = vSunPositionScreenSpace - vUv;\",\n\t\t\t\"\tfloat dist = length( delta );\",\n\n\t\t\t// Step vector (uv space)\n\n\t\t\t\"\tvec2 stepv = fStepSize * delta / dist;\",\n\n\t\t\t// Number of iterations between pixel and sun\n\n\t\t\t\"\tfloat iters = dist/fStepSize;\",\n\n\t\t\t\"\tvec2 uv = vUv.xy;\",\n\t\t\t\"\tfloat col = 0.0;\",\n\n\t\t\t// This breaks ANGLE in Chrome 22\n\t\t\t//\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n\n\t\t\t/*\n\t\t\t// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\n\t\t\t// so i've just left the loop\n\n\t\t\t\"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\",\n\n\t\t\t// Accumulate samples, making sure we dont walk past the light source.\n\n\t\t\t// The check for uv.y < 1 would not be necessary with \"border\" UV wrap\n\t\t\t// mode, with a black border color. I don't think this is currently\n\t\t\t// exposed by three.js. As a result there might be artifacts when the\n\t\t\t// sun is to the left, right or bottom of screen as these cases are\n\t\t\t// not specifically handled.\n\n\t\t\t\"\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\",\n\t\t\t\"\tuv += stepv;\",\n\n\t\t\t\"}\",\n\t\t\t*/\n\n\t\t\t// Unrolling loop manually makes it work in ANGLE\n\n\t\t\t\"\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\",\n\t\t\t\"\tuv += stepv;\",\n\n\t\t\t\"\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\",\n\t\t\t\"\tuv += stepv;\",\n\n\t\t\t\"\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\",\n\t\t\t\"\tuv += stepv;\",\n\n\t\t\t\"\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\",\n\t\t\t\"\tuv += stepv;\",\n\n\t\t\t\"\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\",\n\t\t\t\"\tuv += stepv;\",\n\n\t\t\t\"\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r;\",\n\t\t\t\"\tuv += stepv;\",\n\n\t\t\t// Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\n\t\t\t// objectionable artifacts, in particular near the sun position. The side\n\t\t\t// effect is that the result is darker than it should be around the sun, as\n\t\t\t// TAPS_PER_PASS is greater than the number of samples actually accumulated.\n\t\t\t// When the result is inverted (in the shader 'godrays_combine', this produces\n\t\t\t// a slight bright spot at the position of the sun, even when it is occluded.\n\n\t\t\t\"\tgl_FragColor = vec4( col/TAPS_PER_PASS );\",\n\t\t\t\"\tgl_FragColor.a = 1.0;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n\t/**\n\t * Additively applies god rays from texture tGodRays to a background (tColors).\n\t * fGodRayIntensity attenuates the god rays.\n\t */\n\n\tTHREE.GodRaysCombineShader = {\n\n\t\tuniforms: {\n\n\t\t\ttColors: {\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\ttGodRays: {\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\tfGodRayIntensity: {\n\t\t\t\tvalue: 0.69\n\t\t\t},\n\n\t\t\tvSunPositionScreenSpace: {\n\t\t\t\tvalue: new THREE.Vector2( 0.5, 0.5 )\n\t\t\t}\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform sampler2D tColors;\",\n\t\t\t\"uniform sampler2D tGodRays;\",\n\n\t\t\t\"uniform vec2 vSunPositionScreenSpace;\",\n\t\t\t\"uniform float fGodRayIntensity;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t// Since THREE.MeshDepthMaterial renders foreground objects white and background\n\t\t\t// objects black, the god-rays will be white streaks. Therefore value is inverted\n\t\t\t// before being combined with tColors\n\n\t\t\t\"\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\",\n\t\t\t\"\tgl_FragColor.a = 1.0;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n\n\t/**\n\t * A dodgy sun/sky shader. Makes a bright spot at the sun location. Would be\n\t * cheaper/faster/simpler to implement this as a simple sun sprite.\n\t */\n\n\tTHREE.GodRaysFakeSunShader = {\n\n\t\tuniforms: {\n\n\t\t\tvSunPositionScreenSpace: {\n\t\t\t\tvalue: new THREE.Vector2( 0.5, 0.5 )\n\t\t\t},\n\n\t\t\tfAspect: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\n\t\t\tsunColor: {\n\t\t\t\tvalue: new THREE.Color( 0xffee00 )\n\t\t\t},\n\n\t\t\tbgColor: {\n\t\t\t\tvalue: new THREE.Color( 0x000000 )\n\t\t\t}\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform vec2 vSunPositionScreenSpace;\",\n\t\t\t\"uniform float fAspect;\",\n\n\t\t\t\"uniform vec3 sunColor;\",\n\t\t\t\"uniform vec3 bgColor;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec2 diff = vUv - vSunPositionScreenSpace;\",\n\n\t\t\t// Correct for aspect ratio\n\n\t\t\t\"\tdiff.x *= fAspect;\",\n\n\t\t\t\"\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );\",\n\t\t\t\"\tprop = 0.35 * pow( 1.0 - prop, 3.0 );\",\n\n\t\t\t\"\tgl_FragColor.xyz = mix( sunColor, bgColor, 1.0 - prop );\",\n\t\t\t\"\tgl_FragColor.w = 1.0;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE;\n});\n"]}