{"version":3,"sources":["shaders/SMAAShader.js"],"names":["define","THREE","SMAAEdgesShader","defines","SMAA_THRESHOLD","uniforms","tDiffuse","value","resolution","Vector2","vertexShader","join","fragmentShader","SMAAWeightsShader","SMAA_MAX_SEARCH_STEPS","SMAA_AREATEX_MAX_DISTANCE","SMAA_AREATEX_PIXEL_SIZE","SMAA_AREATEX_SUBTEX_SIZE","tArea","tSearch","SMAABlendShader","tColor"],"mappings":";;;;;;;AAAAA,QACI,mBACD,SAAUC,GACT,aAyQA,OACIC,iBAxQAC,SAAWC,eAAkB,OAC7BC,UACIC,UAAcC,MAAO,MACrBC,YAAgBD,MAAO,IAAIN,EAAMQ,QAAQ,EAAI,KAAM,EAAI,OAE3DC,cACI,2BACA,oBACA,6BACA,8CACA,mFACA,mFACA,mFACA,IACA,gBACA,cACA,gCACA,8EACA,KACFC,KAAK,MACPC,gBACI,8BACA,oBACA,6BACA,uFACA,6DACA,gBACA,kDACA,0DACA,+BACA,2CACA,yDACA,yBACA,2CACA,8CACA,iDACA,eACA,2DACA,2BACA,2CACA,6DACA,4BACA,2CACA,8EACA,+DACA,8BACA,2CACA,4DACA,4BACA,2CACA,yDACA,kDACA,oCACA,IACA,gBACA,uEACA,KACFD,KAAK,OAgNPE,mBA7MAV,SACIW,sBAAyB,IACzBC,0BAA6B,KAC7BC,wBAA2B,iCAC3BC,yBAA4B,iBAEhCZ,UACIC,UAAcC,MAAO,MACrBW,OAAWX,MAAO,MAClBY,SAAaZ,MAAO,MACpBC,YAAgBD,MAAO,IAAIN,EAAMQ,QAAQ,EAAI,KAAM,EAAI,OAE3DC,cACI,2BACA,oBACA,6BACA,0BACA,0DACA,uCACA,wFACA,0FACA,+IACA,IACA,gBACA,cACA,4CACA,8EACA,KACFC,KAAK,MACPC,gBACI,sHACA,8BACA,2BACA,6BACA,2BACA,oBACA,2BACA,0BACA,yBACA,yBACA,gDACA,IACA,SACA,mFACA,8BACA,qDACA,IACA,+FACA,+BACA,yDACA,mDACA,iDACA,yEACA,MACA,uCACA,gCACA,sCACA,2EACA,uBACA,IACA,gGACA,+BACA,yDACA,mDACA,iDACA,yEACA,MACA,uCACA,gCACA,sCACA,6EACA,uBACA,IACA,6FACA,+BACA,yDACA,mDACA,iDACA,yEACA,MACA,uCACA,gCACA,sCACA,gFACA,uBACA,IACA,+FACA,+BACA,yDACA,mDACA,iDACA,yEACA,MACA,uCACA,gCACA,sCACA,gFACA,uBACA,IACA,oFACA,+FACA,uFACA,qDACA,mDACA,IACA,+KACA,+CACA,iDACA,uBACA,cACA,mBACA,wFACA,gCACA,sBACA,uDACA,yFACA,sBACA,yCACA,sCACA,sCACA,iFACA,qFACA,MACA,uBACA,cACA,mBACA,sFACA,gCACA,sBACA,uDACA,wFACA,sBACA,yCACA,sCACA,sCACA,iFACA,qFACA,MACA,oBACA,IACA,gBACA,uHACA,KACFD,KAAK,OA+DPS,iBA5DAf,UACIC,UAAcC,MAAO,MACrBc,QAAYd,MAAO,MACnBC,YAAgBD,MAAO,IAAIN,EAAMQ,QAAQ,EAAI,KAAM,EAAI,OAE3DC,cACI,2BACA,oBACA,6BACA,qDACA,kFACA,kFACA,IACA,gBACA,cACA,uCACA,8EACA,KACFC,KAAK,MACPC,gBACI,8BACA,4BACA,2BACA,oBACA,6BACA,+GACA,YACA,+CACA,mDACA,mDACA,uDACA,mDACA,aACA,mBACA,yCACA,yCACA,gDACA,wBACA,eACA,wBACA,QACA,qDACA,+CACA,uDACA,uFACA,qCACA,yCACA,mCACA,mDACA,oBACA,MACA,IACA,gBACA,iFACA,KACFD,KAAK","file":"../../shaders/SMAAShader.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var SMAAEdgesShader = {\n        defines: { 'SMAA_THRESHOLD': '0.1' },\n        uniforms: {\n            'tDiffuse': { value: null },\n            'resolution': { value: new THREE.Vector2(1 / 1024, 1 / 512) }\n        },\n        vertexShader: [\n            'uniform vec2 resolution;',\n            'varying vec2 vUv;',\n            'varying vec4 vOffset[ 3 ];',\n            'void SMAAEdgeDetectionVS( vec2 texcoord ) {',\n            '\\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );',\n            '\\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );',\n            '\\tvOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );',\n            '}',\n            'void main() {',\n            '\\tvUv = uv;',\n            '\\tSMAAEdgeDetectionVS( vUv );',\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n            '}'\n        ].join('\\n'),\n        fragmentShader: [\n            'uniform sampler2D tDiffuse;',\n            'varying vec2 vUv;',\n            'varying vec4 vOffset[ 3 ];',\n            'vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {',\n            '\\tvec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );',\n            '\\tvec4 delta;',\n            '\\tvec3 C = texture2D( colorTex, texcoord ).rgb;',\n            '\\tvec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;',\n            '\\tvec3 t = abs( C - Cleft );',\n            '\\tdelta.x = max( max( t.r, t.g ), t.b );',\n            '\\tvec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;',\n            '\\tt = abs( C - Ctop );',\n            '\\tdelta.y = max( max( t.r, t.g ), t.b );',\n            '\\tvec2 edges = step( threshold, delta.xy );',\n            '\\tif ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )',\n            '\\t\\tdiscard;',\n            '\\tvec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;',\n            '\\tt = abs( C - Cright );',\n            '\\tdelta.z = max( max( t.r, t.g ), t.b );',\n            '\\tvec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;',\n            '\\tt = abs( C - Cbottom );',\n            '\\tdelta.w = max( max( t.r, t.g ), t.b );',\n            '\\tfloat maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );',\n            '\\tvec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;',\n            '\\tt = abs( C - Cleftleft );',\n            '\\tdelta.z = max( max( t.r, t.g ), t.b );',\n            '\\tvec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;',\n            '\\tt = abs( C - Ctoptop );',\n            '\\tdelta.w = max( max( t.r, t.g ), t.b );',\n            '\\tmaxDelta = max( max( maxDelta, delta.z ), delta.w );',\n            '\\tedges.xy *= step( 0.5 * maxDelta, delta.xy );',\n            '\\treturn vec4( edges, 0.0, 0.0 );',\n            '}',\n            'void main() {',\n            '\\tgl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );',\n            '}'\n        ].join('\\n')\n    };\n    var SMAAWeightsShader = {\n        defines: {\n            'SMAA_MAX_SEARCH_STEPS': '8',\n            'SMAA_AREATEX_MAX_DISTANCE': '16',\n            'SMAA_AREATEX_PIXEL_SIZE': '( 1.0 / vec2( 160.0, 560.0 ) )',\n            'SMAA_AREATEX_SUBTEX_SIZE': '( 1.0 / 7.0 )'\n        },\n        uniforms: {\n            'tDiffuse': { value: null },\n            'tArea': { value: null },\n            'tSearch': { value: null },\n            'resolution': { value: new THREE.Vector2(1 / 1024, 1 / 512) }\n        },\n        vertexShader: [\n            'uniform vec2 resolution;',\n            'varying vec2 vUv;',\n            'varying vec4 vOffset[ 3 ];',\n            'varying vec2 vPixcoord;',\n            'void SMAABlendingWeightCalculationVS( vec2 texcoord ) {',\n            '\\tvPixcoord = texcoord / resolution;',\n            '\\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );',\n            '\\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );',\n            '\\tvOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );',\n            '}',\n            'void main() {',\n            '\\tvUv = uv;',\n            '\\tSMAABlendingWeightCalculationVS( vUv );',\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n            '}'\n        ].join('\\n'),\n        fragmentShader: [\n            '#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )',\n            'uniform sampler2D tDiffuse;',\n            'uniform sampler2D tArea;',\n            'uniform sampler2D tSearch;',\n            'uniform vec2 resolution;',\n            'varying vec2 vUv;',\n            'varying vec4 vOffset[3];',\n            'varying vec2 vPixcoord;',\n            '#if __VERSION__ == 100',\n            'vec2 round( vec2 x ) {',\n            '\\treturn sign( x ) * floor( abs( x ) + 0.5 );',\n            '}',\n            '#endif',\n            'float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {',\n            '\\te.r = bias + e.r * scale;',\n            '\\treturn 255.0 * texture2D( searchTex, e, 0.0 ).r;',\n            '}',\n            'float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {',\n            '\\tvec2 e = vec2( 0.0, 1.0 );',\n            '\\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {',\n            '\\t\\te = texture2D( edgesTex, texcoord, 0.0 ).rg;',\n            '\\t\\ttexcoord -= vec2( 2.0, 0.0 ) * resolution;',\n            '\\t\\tif ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;',\n            '\\t}',\n            '\\ttexcoord.x += 0.25 * resolution.x;',\n            '\\ttexcoord.x += resolution.x;',\n            '\\ttexcoord.x += 2.0 * resolution.x;',\n            '\\ttexcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);',\n            '\\treturn texcoord.x;',\n            '}',\n            'float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {',\n            '\\tvec2 e = vec2( 0.0, 1.0 );',\n            '\\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {',\n            '\\t\\te = texture2D( edgesTex, texcoord, 0.0 ).rg;',\n            '\\t\\ttexcoord += vec2( 2.0, 0.0 ) * resolution;',\n            '\\t\\tif ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;',\n            '\\t}',\n            '\\ttexcoord.x -= 0.25 * resolution.x;',\n            '\\ttexcoord.x -= resolution.x;',\n            '\\ttexcoord.x -= 2.0 * resolution.x;',\n            '\\ttexcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );',\n            '\\treturn texcoord.x;',\n            '}',\n            'float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {',\n            '\\tvec2 e = vec2( 1.0, 0.0 );',\n            '\\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {',\n            '\\t\\te = texture2D( edgesTex, texcoord, 0.0 ).rg;',\n            '\\t\\ttexcoord += vec2( 0.0, 2.0 ) * resolution;',\n            '\\t\\tif ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;',\n            '\\t}',\n            '\\ttexcoord.y -= 0.25 * resolution.y;',\n            '\\ttexcoord.y -= resolution.y;',\n            '\\ttexcoord.y -= 2.0 * resolution.y;',\n            '\\ttexcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );',\n            '\\treturn texcoord.y;',\n            '}',\n            'float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {',\n            '\\tvec2 e = vec2( 1.0, 0.0 );',\n            '\\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {',\n            '\\t\\te = texture2D( edgesTex, texcoord, 0.0 ).rg;',\n            '\\t\\ttexcoord -= vec2( 0.0, 2.0 ) * resolution;',\n            '\\t\\tif ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;',\n            '\\t}',\n            '\\ttexcoord.y += 0.25 * resolution.y;',\n            '\\ttexcoord.y += resolution.y;',\n            '\\ttexcoord.y += 2.0 * resolution.y;',\n            '\\ttexcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );',\n            '\\treturn texcoord.y;',\n            '}',\n            'vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {',\n            '\\tvec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;',\n            '\\ttexcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );',\n            '\\ttexcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;',\n            '\\treturn texture2D( areaTex, texcoord, 0.0 ).rg;',\n            '}',\n            'vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {',\n            '\\tvec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );',\n            '\\tvec2 e = texture2D( edgesTex, texcoord ).rg;',\n            '\\tif ( e.g > 0.0 ) {',\n            '\\t\\tvec2 d;',\n            '\\t\\tvec2 coords;',\n            '\\t\\tcoords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );',\n            '\\t\\tcoords.y = offset[ 1 ].y;',\n            '\\t\\td.x = coords.x;',\n            '\\t\\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).r;',\n            '\\t\\tcoords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );',\n            '\\t\\td.y = coords.x;',\n            '\\t\\td = d / resolution.x - pixcoord.x;',\n            '\\t\\tvec2 sqrt_d = sqrt( abs( d ) );',\n            '\\t\\tcoords.y -= 1.0 * resolution.y;',\n            '\\t\\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;',\n            '\\t\\tweights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );',\n            '\\t}',\n            '\\tif ( e.r > 0.0 ) {',\n            '\\t\\tvec2 d;',\n            '\\t\\tvec2 coords;',\n            '\\t\\tcoords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );',\n            '\\t\\tcoords.x = offset[ 0 ].x;',\n            '\\t\\td.x = coords.y;',\n            '\\t\\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).g;',\n            '\\t\\tcoords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );',\n            '\\t\\td.y = coords.y;',\n            '\\t\\td = d / resolution.y - pixcoord.y;',\n            '\\t\\tvec2 sqrt_d = sqrt( abs( d ) );',\n            '\\t\\tcoords.y -= 1.0 * resolution.y;',\n            '\\t\\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;',\n            '\\t\\tweights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );',\n            '\\t}',\n            '\\treturn weights;',\n            '}',\n            'void main() {',\n            '\\tgl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );',\n            '}'\n        ].join('\\n')\n    };\n    var SMAABlendShader = {\n        uniforms: {\n            'tDiffuse': { value: null },\n            'tColor': { value: null },\n            'resolution': { value: new THREE.Vector2(1 / 1024, 1 / 512) }\n        },\n        vertexShader: [\n            'uniform vec2 resolution;',\n            'varying vec2 vUv;',\n            'varying vec4 vOffset[ 2 ];',\n            'void SMAANeighborhoodBlendingVS( vec2 texcoord ) {',\n            '\\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );',\n            '\\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );',\n            '}',\n            'void main() {',\n            '\\tvUv = uv;',\n            '\\tSMAANeighborhoodBlendingVS( vUv );',\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n            '}'\n        ].join('\\n'),\n        fragmentShader: [\n            'uniform sampler2D tDiffuse;',\n            'uniform sampler2D tColor;',\n            'uniform vec2 resolution;',\n            'varying vec2 vUv;',\n            'varying vec4 vOffset[ 2 ];',\n            'vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {',\n            '\\tvec4 a;',\n            '\\ta.xz = texture2D( blendTex, texcoord ).xz;',\n            '\\ta.y = texture2D( blendTex, offset[ 1 ].zw ).g;',\n            '\\ta.w = texture2D( blendTex, offset[ 1 ].xy ).a;',\n            '\\tif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {',\n            '\\t\\treturn texture2D( colorTex, texcoord, 0.0 );',\n            '\\t} else {',\n            '\\t\\tvec2 offset;',\n            '\\t\\toffset.x = a.a > a.b ? a.a : -a.b;',\n            '\\t\\toffset.y = a.g > a.r ? -a.g : a.r;',\n            '\\t\\tif ( abs( offset.x ) > abs( offset.y )) {',\n            '\\t\\t\\toffset.y = 0.0;',\n            '\\t\\t} else {',\n            '\\t\\t\\toffset.x = 0.0;',\n            '\\t\\t}',\n            '\\t\\tvec4 C = texture2D( colorTex, texcoord, 0.0 );',\n            '\\t\\ttexcoord += sign( offset ) * resolution;',\n            '\\t\\tvec4 Cop = texture2D( colorTex, texcoord, 0.0 );',\n            '\\t\\tfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );',\n            '\\t\\tC.xyz = pow(C.xyz, vec3(2.2));',\n            '\\t\\tCop.xyz = pow(Cop.xyz, vec3(2.2));',\n            '\\t\\tvec4 mixed = mix(C, Cop, s);',\n            '\\t\\tmixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));',\n            '\\t\\treturn mixed;',\n            '\\t}',\n            '}',\n            'void main() {',\n            '\\tgl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );',\n            '}'\n        ].join('\\n')\n    };\n    return {\n        SMAAEdgesShader,\n        SMAAWeightsShader,\n        SMAABlendShader\n    };\n});"]}