{"version":3,"sources":["shaders/SMAAShader.js"],"names":["define","THREE","threex","SMAAEdgesShader","defines","SMAA_THRESHOLD","uniforms","tDiffuse","value","resolution","Vector2","vertexShader","join","fragmentShader","SMAAWeightsShader","SMAA_MAX_SEARCH_STEPS","SMAA_AREATEX_MAX_DISTANCE","SMAA_AREATEX_PIXEL_SIZE","SMAA_AREATEX_SUBTEX_SIZE","tArea","tSearch","SMAABlendShader","tColor","shaders","SMAAShader"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,GACAC,SAAWC,eAAkB,OAC7BC,UACIC,UAAcC,MAAO,MACrBC,YAAgBD,MAAO,IAAIP,EAAMS,QAAQ,EAAI,KAAM,EAAI,OAE3DC,cACI,2BACA,oBACA,6BACA,8CACA,mFACA,mFACA,mFACA,IACA,gBACA,cACA,gCACA,8EACA,KACFC,KAAK,MACPC,gBACI,8BACA,oBACA,6BACA,uFACA,6DACA,gBACA,kDACA,0DACA,+BACA,2CACA,yDACA,yBACA,2CACA,8CACA,iDACA,eACA,2DACA,2BACA,2CACA,6DACA,4BACA,2CACA,8EACA,+DACA,8BACA,2CACA,4DACA,4BACA,2CACA,yDACA,kDACA,oCACA,IACA,gBACA,uEACA,KACFD,KAAK,OAEPE,GACAV,SACIW,sBAAyB,IACzBC,0BAA6B,KAC7BC,wBAA2B,iCAC3BC,yBAA4B,iBAEhCZ,UACIC,UAAcC,MAAO,MACrBW,OAAWX,MAAO,MAClBY,SAAaZ,MAAO,MACpBC,YAAgBD,MAAO,IAAIP,EAAMS,QAAQ,EAAI,KAAM,EAAI,OAE3DC,cACI,2BACA,oBACA,6BACA,0BACA,0DACA,uCACA,wFACA,0FACA,+IACA,IACA,gBACA,cACA,4CACA,8EACA,KACFC,KAAK,MACPC,gBACI,sHACA,8BACA,2BACA,6BACA,2BACA,oBACA,2BACA,0BACA,yBACA,yBACA,gDACA,IACA,SACA,mFACA,8BACA,qDACA,IACA,+FACA,+BACA,yDACA,mDACA,iDACA,yEACA,MACA,uCACA,gCACA,sCACA,2EACA,uBACA,IACA,gGACA,+BACA,yDACA,mDACA,iDACA,yEACA,MACA,uCACA,gCACA,sCACA,6EACA,uBACA,IACA,6FACA,+BACA,yDACA,mDACA,iDACA,yEACA,MACA,uCACA,gCACA,sCACA,gFACA,uBACA,IACA,+FACA,+BACA,yDACA,mDACA,iDACA,yEACA,MACA,uCACA,gCACA,sCACA,gFACA,uBACA,IACA,oFACA,+FACA,uFACA,qDACA,mDACA,IACA,+KACA,+CACA,iDACA,uBACA,cACA,mBACA,wFACA,gCACA,sBACA,uDACA,yFACA,sBACA,yCACA,sCACA,sCACA,iFACA,qFACA,MACA,uBACA,cACA,mBACA,sFACA,gCACA,sBACA,uDACA,wFACA,sBACA,yCACA,sCACA,sCACA,iFACA,qFACA,MACA,oBACA,IACA,gBACA,uHACA,KACFD,KAAK,OAEPS,GACAf,UACIC,UAAcC,MAAO,MACrBc,QAAYd,MAAO,MACnBC,YAAgBD,MAAO,IAAIP,EAAMS,QAAQ,EAAI,KAAM,EAAI,OAE3DC,cACI,2BACA,oBACA,6BACA,qDACA,kFACA,kFACA,IACA,gBACA,cACA,uCACA,8EACA,KACFC,KAAK,MACPC,gBACI,8BACA,4BACA,2BACA,oBACA,6BACA,+GACA,YACA,+CACA,mDACA,mDACA,uDACA,mDACA,aACA,mBACA,yCACA,yCACA,gDACA,wBACA,eACA,wBACA,QACA,qDACA,+CACA,uDACA,uFACA,qCACA,yCACA,mCACA,mDACA,oBACA,MACA,IACA,gBACA,iFACA,KACFD,KAAK,OAEX,OAAOV,EAAOqB,QAAQC,YAClBrB,gBAAAA,EACAW,kBAAAA,EACAO,gBAAAA","file":"../../shaders/SMAAShader.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var SMAAEdgesShader = {\r\n        defines: { 'SMAA_THRESHOLD': '0.1' },\r\n        uniforms: {\r\n            'tDiffuse': { value: null },\r\n            'resolution': { value: new THREE.Vector2(1 / 1024, 1 / 512) }\r\n        },\r\n        vertexShader: [\r\n            'uniform vec2 resolution;',\r\n            'varying vec2 vUv;',\r\n            'varying vec4 vOffset[ 3 ];',\r\n            'void SMAAEdgeDetectionVS( vec2 texcoord ) {',\r\n            '\\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );',\r\n            '\\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );',\r\n            '\\tvOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );',\r\n            '}',\r\n            'void main() {',\r\n            '\\tvUv = uv;',\r\n            '\\tSMAAEdgeDetectionVS( vUv );',\r\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            'uniform sampler2D tDiffuse;',\r\n            'varying vec2 vUv;',\r\n            'varying vec4 vOffset[ 3 ];',\r\n            'vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {',\r\n            '\\tvec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );',\r\n            '\\tvec4 delta;',\r\n            '\\tvec3 C = texture2D( colorTex, texcoord ).rgb;',\r\n            '\\tvec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;',\r\n            '\\tvec3 t = abs( C - Cleft );',\r\n            '\\tdelta.x = max( max( t.r, t.g ), t.b );',\r\n            '\\tvec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;',\r\n            '\\tt = abs( C - Ctop );',\r\n            '\\tdelta.y = max( max( t.r, t.g ), t.b );',\r\n            '\\tvec2 edges = step( threshold, delta.xy );',\r\n            '\\tif ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )',\r\n            '\\t\\tdiscard;',\r\n            '\\tvec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;',\r\n            '\\tt = abs( C - Cright );',\r\n            '\\tdelta.z = max( max( t.r, t.g ), t.b );',\r\n            '\\tvec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;',\r\n            '\\tt = abs( C - Cbottom );',\r\n            '\\tdelta.w = max( max( t.r, t.g ), t.b );',\r\n            '\\tfloat maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );',\r\n            '\\tvec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;',\r\n            '\\tt = abs( C - Cleftleft );',\r\n            '\\tdelta.z = max( max( t.r, t.g ), t.b );',\r\n            '\\tvec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;',\r\n            '\\tt = abs( C - Ctoptop );',\r\n            '\\tdelta.w = max( max( t.r, t.g ), t.b );',\r\n            '\\tmaxDelta = max( max( maxDelta, delta.z ), delta.w );',\r\n            '\\tedges.xy *= step( 0.5 * maxDelta, delta.xy );',\r\n            '\\treturn vec4( edges, 0.0, 0.0 );',\r\n            '}',\r\n            'void main() {',\r\n            '\\tgl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    var SMAAWeightsShader = {\r\n        defines: {\r\n            'SMAA_MAX_SEARCH_STEPS': '8',\r\n            'SMAA_AREATEX_MAX_DISTANCE': '16',\r\n            'SMAA_AREATEX_PIXEL_SIZE': '( 1.0 / vec2( 160.0, 560.0 ) )',\r\n            'SMAA_AREATEX_SUBTEX_SIZE': '( 1.0 / 7.0 )'\r\n        },\r\n        uniforms: {\r\n            'tDiffuse': { value: null },\r\n            'tArea': { value: null },\r\n            'tSearch': { value: null },\r\n            'resolution': { value: new THREE.Vector2(1 / 1024, 1 / 512) }\r\n        },\r\n        vertexShader: [\r\n            'uniform vec2 resolution;',\r\n            'varying vec2 vUv;',\r\n            'varying vec4 vOffset[ 3 ];',\r\n            'varying vec2 vPixcoord;',\r\n            'void SMAABlendingWeightCalculationVS( vec2 texcoord ) {',\r\n            '\\tvPixcoord = texcoord / resolution;',\r\n            '\\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );',\r\n            '\\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );',\r\n            '\\tvOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );',\r\n            '}',\r\n            'void main() {',\r\n            '\\tvUv = uv;',\r\n            '\\tSMAABlendingWeightCalculationVS( vUv );',\r\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            '#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )',\r\n            'uniform sampler2D tDiffuse;',\r\n            'uniform sampler2D tArea;',\r\n            'uniform sampler2D tSearch;',\r\n            'uniform vec2 resolution;',\r\n            'varying vec2 vUv;',\r\n            'varying vec4 vOffset[3];',\r\n            'varying vec2 vPixcoord;',\r\n            '#if __VERSION__ == 100',\r\n            'vec2 round( vec2 x ) {',\r\n            '\\treturn sign( x ) * floor( abs( x ) + 0.5 );',\r\n            '}',\r\n            '#endif',\r\n            'float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {',\r\n            '\\te.r = bias + e.r * scale;',\r\n            '\\treturn 255.0 * texture2D( searchTex, e, 0.0 ).r;',\r\n            '}',\r\n            'float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {',\r\n            '\\tvec2 e = vec2( 0.0, 1.0 );',\r\n            '\\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {',\r\n            '\\t\\te = texture2D( edgesTex, texcoord, 0.0 ).rg;',\r\n            '\\t\\ttexcoord -= vec2( 2.0, 0.0 ) * resolution;',\r\n            '\\t\\tif ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;',\r\n            '\\t}',\r\n            '\\ttexcoord.x += 0.25 * resolution.x;',\r\n            '\\ttexcoord.x += resolution.x;',\r\n            '\\ttexcoord.x += 2.0 * resolution.x;',\r\n            '\\ttexcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);',\r\n            '\\treturn texcoord.x;',\r\n            '}',\r\n            'float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {',\r\n            '\\tvec2 e = vec2( 0.0, 1.0 );',\r\n            '\\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {',\r\n            '\\t\\te = texture2D( edgesTex, texcoord, 0.0 ).rg;',\r\n            '\\t\\ttexcoord += vec2( 2.0, 0.0 ) * resolution;',\r\n            '\\t\\tif ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;',\r\n            '\\t}',\r\n            '\\ttexcoord.x -= 0.25 * resolution.x;',\r\n            '\\ttexcoord.x -= resolution.x;',\r\n            '\\ttexcoord.x -= 2.0 * resolution.x;',\r\n            '\\ttexcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );',\r\n            '\\treturn texcoord.x;',\r\n            '}',\r\n            'float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {',\r\n            '\\tvec2 e = vec2( 1.0, 0.0 );',\r\n            '\\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {',\r\n            '\\t\\te = texture2D( edgesTex, texcoord, 0.0 ).rg;',\r\n            '\\t\\ttexcoord += vec2( 0.0, 2.0 ) * resolution;',\r\n            '\\t\\tif ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;',\r\n            '\\t}',\r\n            '\\ttexcoord.y -= 0.25 * resolution.y;',\r\n            '\\ttexcoord.y -= resolution.y;',\r\n            '\\ttexcoord.y -= 2.0 * resolution.y;',\r\n            '\\ttexcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );',\r\n            '\\treturn texcoord.y;',\r\n            '}',\r\n            'float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {',\r\n            '\\tvec2 e = vec2( 1.0, 0.0 );',\r\n            '\\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {',\r\n            '\\t\\te = texture2D( edgesTex, texcoord, 0.0 ).rg;',\r\n            '\\t\\ttexcoord -= vec2( 0.0, 2.0 ) * resolution;',\r\n            '\\t\\tif ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;',\r\n            '\\t}',\r\n            '\\ttexcoord.y += 0.25 * resolution.y;',\r\n            '\\ttexcoord.y += resolution.y;',\r\n            '\\ttexcoord.y += 2.0 * resolution.y;',\r\n            '\\ttexcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );',\r\n            '\\treturn texcoord.y;',\r\n            '}',\r\n            'vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {',\r\n            '\\tvec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;',\r\n            '\\ttexcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );',\r\n            '\\ttexcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;',\r\n            '\\treturn texture2D( areaTex, texcoord, 0.0 ).rg;',\r\n            '}',\r\n            'vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {',\r\n            '\\tvec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );',\r\n            '\\tvec2 e = texture2D( edgesTex, texcoord ).rg;',\r\n            '\\tif ( e.g > 0.0 ) {',\r\n            '\\t\\tvec2 d;',\r\n            '\\t\\tvec2 coords;',\r\n            '\\t\\tcoords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );',\r\n            '\\t\\tcoords.y = offset[ 1 ].y;',\r\n            '\\t\\td.x = coords.x;',\r\n            '\\t\\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).r;',\r\n            '\\t\\tcoords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );',\r\n            '\\t\\td.y = coords.x;',\r\n            '\\t\\td = d / resolution.x - pixcoord.x;',\r\n            '\\t\\tvec2 sqrt_d = sqrt( abs( d ) );',\r\n            '\\t\\tcoords.y -= 1.0 * resolution.y;',\r\n            '\\t\\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;',\r\n            '\\t\\tweights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );',\r\n            '\\t}',\r\n            '\\tif ( e.r > 0.0 ) {',\r\n            '\\t\\tvec2 d;',\r\n            '\\t\\tvec2 coords;',\r\n            '\\t\\tcoords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );',\r\n            '\\t\\tcoords.x = offset[ 0 ].x;',\r\n            '\\t\\td.x = coords.y;',\r\n            '\\t\\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).g;',\r\n            '\\t\\tcoords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );',\r\n            '\\t\\td.y = coords.y;',\r\n            '\\t\\td = d / resolution.y - pixcoord.y;',\r\n            '\\t\\tvec2 sqrt_d = sqrt( abs( d ) );',\r\n            '\\t\\tcoords.y -= 1.0 * resolution.y;',\r\n            '\\t\\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;',\r\n            '\\t\\tweights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );',\r\n            '\\t}',\r\n            '\\treturn weights;',\r\n            '}',\r\n            'void main() {',\r\n            '\\tgl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    var SMAABlendShader = {\r\n        uniforms: {\r\n            'tDiffuse': { value: null },\r\n            'tColor': { value: null },\r\n            'resolution': { value: new THREE.Vector2(1 / 1024, 1 / 512) }\r\n        },\r\n        vertexShader: [\r\n            'uniform vec2 resolution;',\r\n            'varying vec2 vUv;',\r\n            'varying vec4 vOffset[ 2 ];',\r\n            'void SMAANeighborhoodBlendingVS( vec2 texcoord ) {',\r\n            '\\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );',\r\n            '\\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );',\r\n            '}',\r\n            'void main() {',\r\n            '\\tvUv = uv;',\r\n            '\\tSMAANeighborhoodBlendingVS( vUv );',\r\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            'uniform sampler2D tDiffuse;',\r\n            'uniform sampler2D tColor;',\r\n            'uniform vec2 resolution;',\r\n            'varying vec2 vUv;',\r\n            'varying vec4 vOffset[ 2 ];',\r\n            'vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {',\r\n            '\\tvec4 a;',\r\n            '\\ta.xz = texture2D( blendTex, texcoord ).xz;',\r\n            '\\ta.y = texture2D( blendTex, offset[ 1 ].zw ).g;',\r\n            '\\ta.w = texture2D( blendTex, offset[ 1 ].xy ).a;',\r\n            '\\tif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {',\r\n            '\\t\\treturn texture2D( colorTex, texcoord, 0.0 );',\r\n            '\\t} else {',\r\n            '\\t\\tvec2 offset;',\r\n            '\\t\\toffset.x = a.a > a.b ? a.a : -a.b;',\r\n            '\\t\\toffset.y = a.g > a.r ? -a.g : a.r;',\r\n            '\\t\\tif ( abs( offset.x ) > abs( offset.y )) {',\r\n            '\\t\\t\\toffset.y = 0.0;',\r\n            '\\t\\t} else {',\r\n            '\\t\\t\\toffset.x = 0.0;',\r\n            '\\t\\t}',\r\n            '\\t\\tvec4 C = texture2D( colorTex, texcoord, 0.0 );',\r\n            '\\t\\ttexcoord += sign( offset ) * resolution;',\r\n            '\\t\\tvec4 Cop = texture2D( colorTex, texcoord, 0.0 );',\r\n            '\\t\\tfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );',\r\n            '\\t\\tC.xyz = pow(C.xyz, vec3(2.2));',\r\n            '\\t\\tCop.xyz = pow(Cop.xyz, vec3(2.2));',\r\n            '\\t\\tvec4 mixed = mix(C, Cop, s);',\r\n            '\\t\\tmixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));',\r\n            '\\t\\treturn mixed;',\r\n            '\\t}',\r\n            '}',\r\n            'void main() {',\r\n            '\\tgl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    return threex.shaders.SMAAShader = {\r\n        SMAAEdgesShader,\r\n        SMAAWeightsShader,\r\n        SMAABlendShader\r\n    };\r\n});"]}