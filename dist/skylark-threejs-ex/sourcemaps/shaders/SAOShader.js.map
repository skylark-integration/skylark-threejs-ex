{"version":3,"sources":["shaders/SAOShader.js"],"names":["define","THREE","threex","SAOShader","defines","NUM_SAMPLES","NUM_RINGS","NORMAL_TEXTURE","DIFFUSE_TEXTURE","DEPTH_PACKING","PERSPECTIVE_CAMERA","uniforms","tDepth","value","tDiffuse","tNormal","size","Vector2","cameraNear","cameraFar","cameraProjectionMatrix","Matrix4","cameraInverseProjectionMatrix","scale","intensity","bias","minResolution","kernelRadius","randomSeed","vertexShader","join","fragmentShader","shaders"],"mappings":";;;;;;;AAAAA,QACM,kBACA,aACH,SACGC,EACAC,GAEF,aACA,IAAIC,GACAC,SACIC,YAAe,EACfC,UAAa,EACbC,eAAkB,EAClBC,gBAAmB,EACnBC,cAAiB,EACjBC,mBAAsB,GAE1BC,UACIC,QAAYC,MAAO,MACnBC,UAAcD,MAAO,MACrBE,SAAaF,MAAO,MACpBG,MAAUH,MAAO,IAAIZ,EAAMgB,QAAQ,IAAK,MACxCC,YAAgBL,MAAO,GACvBM,WAAeN,MAAO,KACtBO,wBAA4BP,MAAO,IAAIZ,EAAMoB,SAC7CC,+BAAmCT,MAAO,IAAIZ,EAAMoB,SACpDE,OAAWV,MAAO,GAClBW,WAAeX,MAAO,IACtBY,MAAUZ,MAAO,IACjBa,eAAmBb,MAAO,GAC1Bc,cAAkBd,MAAO,KACzBe,YAAgBf,MAAO,IAE3BgB,cACI,oBACA,gBACA,cACA,8EACA,KACFC,KAAK,MACPC,gBACI,oBACA,oBACA,2BACA,8BACA,SACA,4BACA,0BACA,6BACA,SACA,4BACA,2BACA,uCACA,8CACA,uBACA,2BACA,sBACA,8BACA,+BACA,qBACA,4BACA,gBACA,qBACA,yDACA,6BACA,uCACA,UACA,wBACA,WACA,IACA,mDACA,2BACA,qEACA,UACA,kDACA,WACA,IACA,2CACA,gCACA,oEACA,UACA,qEACA,WACA,IACA,qGACA,uFACA,oFACA,4CACA,iEACA,IACA,mFACA,4BACA,0EACA,UACA,6EACA,WACA,IACA,iCACA,4CACA,6HACA,8DACA,8CACA,yEACA,oKACA,IACA,uCACA,4EACA,4DACA,kEACA,0DACA,iDACA,oEACA,sEACA,0EACA,kDACA,iEACA,8BACA,8BACA,2BACA,8CACA,yEACA,4BACA,2BACA,gDACA,+CACA,kBACA,QACA,mDACA,uFACA,gGACA,wBACA,MACA,oCACA,qDACA,IACA,gBACA,yCACA,6CACA,eACA,MACA,iDACA,0EACA,kEACA,2CACA,iDACA,KACFD,KAAK,OAEX,OAAO5B,EAAO8B,QAAQ7B,UAAYA","file":"../../shaders/SAOShader.js","sourcesContent":["define([\r\n      \"skylark-threejs\",\r\n      \"../threex\"   \r\n], function (\r\n      THREE,\r\n      threex\r\n) {\r\n    'use strict';\r\n    var SAOShader = {\r\n        defines: {\r\n            'NUM_SAMPLES': 7,\r\n            'NUM_RINGS': 4,\r\n            'NORMAL_TEXTURE': 0,\r\n            'DIFFUSE_TEXTURE': 0,\r\n            'DEPTH_PACKING': 1,\r\n            'PERSPECTIVE_CAMERA': 1\r\n        },\r\n        uniforms: {\r\n            'tDepth': { value: null },\r\n            'tDiffuse': { value: null },\r\n            'tNormal': { value: null },\r\n            'size': { value: new THREE.Vector2(512, 512) },\r\n            'cameraNear': { value: 1 },\r\n            'cameraFar': { value: 100 },\r\n            'cameraProjectionMatrix': { value: new THREE.Matrix4() },\r\n            'cameraInverseProjectionMatrix': { value: new THREE.Matrix4() },\r\n            'scale': { value: 1 },\r\n            'intensity': { value: 0.1 },\r\n            'bias': { value: 0.5 },\r\n            'minResolution': { value: 0 },\r\n            'kernelRadius': { value: 100 },\r\n            'randomSeed': { value: 0 }\r\n        },\r\n        vertexShader: [\r\n            'varying vec2 vUv;',\r\n            'void main() {',\r\n            '\\tvUv = uv;',\r\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            '#include <common>',\r\n            'varying vec2 vUv;',\r\n            '#if DIFFUSE_TEXTURE == 1',\r\n            'uniform sampler2D tDiffuse;',\r\n            '#endif',\r\n            'uniform sampler2D tDepth;',\r\n            '#if NORMAL_TEXTURE == 1',\r\n            'uniform sampler2D tNormal;',\r\n            '#endif',\r\n            'uniform float cameraNear;',\r\n            'uniform float cameraFar;',\r\n            'uniform mat4 cameraProjectionMatrix;',\r\n            'uniform mat4 cameraInverseProjectionMatrix;',\r\n            'uniform float scale;',\r\n            'uniform float intensity;',\r\n            'uniform float bias;',\r\n            'uniform float kernelRadius;',\r\n            'uniform float minResolution;',\r\n            'uniform vec2 size;',\r\n            'uniform float randomSeed;',\r\n            '// RGBA depth',\r\n            '#include <packing>',\r\n            'vec4 getDefaultColor( const in vec2 screenPosition ) {',\r\n            '\\t#if DIFFUSE_TEXTURE == 1',\r\n            '\\treturn texture2D( tDiffuse, vUv );',\r\n            '\\t#else',\r\n            '\\treturn vec4( 1.0 );',\r\n            '\\t#endif',\r\n            '}',\r\n            'float getDepth( const in vec2 screenPosition ) {',\r\n            '\\t#if DEPTH_PACKING == 1',\r\n            '\\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );',\r\n            '\\t#else',\r\n            '\\treturn texture2D( tDepth, screenPosition ).x;',\r\n            '\\t#endif',\r\n            '}',\r\n            'float getViewZ( const in float depth ) {',\r\n            '\\t#if PERSPECTIVE_CAMERA == 1',\r\n            '\\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );',\r\n            '\\t#else',\r\n            '\\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );',\r\n            '\\t#endif',\r\n            '}',\r\n            'vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {',\r\n            '\\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];',\r\n            '\\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );',\r\n            '\\tclipPosition *= clipW; // unprojection.',\r\n            '\\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;',\r\n            '}',\r\n            'vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {',\r\n            '\\t#if NORMAL_TEXTURE == 1',\r\n            '\\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );',\r\n            '\\t#else',\r\n            '\\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );',\r\n            '\\t#endif',\r\n            '}',\r\n            'float scaleDividedByCameraFar;',\r\n            'float minResolutionMultipliedByCameraFar;',\r\n            'float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {',\r\n            '\\tvec3 viewDelta = sampleViewPosition - centerViewPosition;',\r\n            '\\tfloat viewDistance = length( viewDelta );',\r\n            '\\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;',\r\n            '\\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );',\r\n            '}',\r\n            '// moving costly divides into consts',\r\n            'const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );',\r\n            'const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );',\r\n            'float getAmbientOcclusion( const in vec3 centerViewPosition ) {',\r\n            '\\t// precompute some variables require in getOcclusion.',\r\n            '\\tscaleDividedByCameraFar = scale / cameraFar;',\r\n            '\\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;',\r\n            '\\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );',\r\n            '\\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/',\r\n            '\\tfloat angle = rand( vUv + randomSeed ) * PI2;',\r\n            '\\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;',\r\n            '\\tvec2 radiusStep = radius;',\r\n            '\\tfloat occlusionSum = 0.0;',\r\n            '\\tfloat weightSum = 0.0;',\r\n            '\\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {',\r\n            '\\t\\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;',\r\n            '\\t\\tradius += radiusStep;',\r\n            '\\t\\tangle += ANGLE_STEP;',\r\n            '\\t\\tfloat sampleDepth = getDepth( sampleUv );',\r\n            '\\t\\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {',\r\n            '\\t\\t\\tcontinue;',\r\n            '\\t\\t}',\r\n            '\\t\\tfloat sampleViewZ = getViewZ( sampleDepth );',\r\n            '\\t\\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );',\r\n            '\\t\\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );',\r\n            '\\t\\tweightSum += 1.0;',\r\n            '\\t}',\r\n            '\\tif( weightSum == 0.0 ) discard;',\r\n            '\\treturn occlusionSum * ( intensity / weightSum );',\r\n            '}',\r\n            'void main() {',\r\n            '\\tfloat centerDepth = getDepth( vUv );',\r\n            '\\tif( centerDepth >= ( 1.0 - EPSILON ) ) {',\r\n            '\\t\\tdiscard;',\r\n            '\\t}',\r\n            '\\tfloat centerViewZ = getViewZ( centerDepth );',\r\n            '\\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );',\r\n            '\\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );',\r\n            '\\tgl_FragColor = getDefaultColor( vUv );',\r\n            '\\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    return threex.shaders.SAOShader = SAOShader;\r\n});"]}