{"version":3,"sources":["shaders/ConvolutionShader.js"],"names":["define","THREE","threex","ConvolutionShader","defines","KERNEL_SIZE_FLOAT","KERNEL_SIZE_INT","uniforms","tDiffuse","value","uImageIncrement","Vector2","cKernel","vertexShader","join","fragmentShader","buildKernel","sigma","gauss","x","Math","exp","i","values","sum","halfWidth","kernelSize","ceil","Array","shaders"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,GACAC,SACIC,kBAAqB,OACrBC,gBAAmB,MAEvBC,UACIC,UAAcC,MAAO,MACrBC,iBAAqBD,MAAO,IAAIR,EAAMU,QAAQ,WAAa,IAC3DC,SAAaH,WAEjBI,cACI,gCACA,oBACA,gBACA,wEACA,8EACA,KACFC,KAAK,MACPC,gBACI,4CACA,8BACA,gCACA,oBACA,gBACA,2BACA,2CACA,kDACA,+DACA,qCACA,MACA,wBACA,KACFD,KAAK,MACPE,YAAa,SAAUC,GACnB,SAASC,EAAMC,EAAGF,GACd,OAAOG,KAAKC,KAAMF,EAAIA,GAAM,EAAIF,EAAQA,IAE5C,IAAIK,EAAGC,EAAQC,EAAKC,EAAgCC,EAAa,EAAIN,KAAKO,KAAa,EAARV,GAAa,EAM5F,IALIS,EAD4C,KAE5CA,EAF4C,IAGhDD,EAA+B,IAAlBC,EAAa,GAC1BH,EAAS,IAAIK,MAAMF,GACnBF,EAAM,EACDF,EAAI,EAAGA,EAAII,IAAcJ,EAC1BC,EAAOD,GAAKJ,EAAMI,EAAIG,EAAWR,GACjCO,GAAOD,EAAOD,GAElB,IAAKA,EAAI,EAAGA,EAAII,IAAcJ,EAC1BC,EAAOD,IAAME,EACjB,OAAOD,IAIf,OAAOrB,EAAO2B,QAAQ1B,kBAAoBA","file":"../../shaders/ConvolutionShader.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var ConvolutionShader = {\r\n        defines: {\r\n            'KERNEL_SIZE_FLOAT': '25.0',\r\n            'KERNEL_SIZE_INT': '25'\r\n        },\r\n        uniforms: {\r\n            'tDiffuse': { value: null },\r\n            'uImageIncrement': { value: new THREE.Vector2(0.001953125, 0) },\r\n            'cKernel': { value: [] }\r\n        },\r\n        vertexShader: [\r\n            'uniform vec2 uImageIncrement;',\r\n            'varying vec2 vUv;',\r\n            'void main() {',\r\n            '\\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;',\r\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            'uniform float cKernel[ KERNEL_SIZE_INT ];',\r\n            'uniform sampler2D tDiffuse;',\r\n            'uniform vec2 uImageIncrement;',\r\n            'varying vec2 vUv;',\r\n            'void main() {',\r\n            '\\tvec2 imageCoord = vUv;',\r\n            '\\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );',\r\n            '\\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {',\r\n            '\\t\\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];',\r\n            '\\t\\timageCoord += uImageIncrement;',\r\n            '\\t}',\r\n            '\\tgl_FragColor = sum;',\r\n            '}'\r\n        ].join('\\n'),\r\n        buildKernel: function (sigma) {\r\n            function gauss(x, sigma) {\r\n                return Math.exp(-(x * x) / (2 * sigma * sigma));\r\n            }\r\n            var i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil(sigma * 3) + 1;\r\n            if (kernelSize > kMaxKernelSize)\r\n                kernelSize = kMaxKernelSize;\r\n            halfWidth = (kernelSize - 1) * 0.5;\r\n            values = new Array(kernelSize);\r\n            sum = 0;\r\n            for (i = 0; i < kernelSize; ++i) {\r\n                values[i] = gauss(i - halfWidth, sigma);\r\n                sum += values[i];\r\n            }\r\n            for (i = 0; i < kernelSize; ++i)\r\n                values[i] /= sum;\r\n            return values;\r\n        }\r\n    };\r\n\r\n    return threex.shaders.ConvolutionShader = ConvolutionShader;\r\n});"]}