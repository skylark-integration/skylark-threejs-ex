{"version":3,"sources":["shaders/ConvolutionShader.js"],"names":["define","THREE","threex","ConvolutionShader","defines","KERNEL_SIZE_FLOAT","KERNEL_SIZE_INT","uniforms","tDiffuse","value","uImageIncrement","Vector2","cKernel","vertexShader","join","fragmentShader","buildKernel","sigma","gauss","x","Math","exp","i","values","sum","halfWidth","kernelSize","ceil","Array","shaders"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,GACAC,SACIC,kBAAqB,OACrBC,gBAAmB,MAEvBC,UACIC,UAAcC,MAAO,MACrBC,iBAAqBD,MAAO,IAAIR,EAAMU,QAAQ,WAAa,IAC3DC,SAAaH,WAEjBI,cACI,gCACA,oBACA,gBACA,wEACA,8EACA,KACFC,KAAK,MACPC,gBACI,4CACA,8BACA,gCACA,oBACA,gBACA,2BACA,2CACA,kDACA,+DACA,qCACA,MACA,wBACA,KACFD,KAAK,MACPE,YAAa,SAAUC,GACnB,SAASC,EAAMC,EAAGF,GACd,OAAOG,KAAKC,KAAMF,EAAIA,GAAM,EAAIF,EAAQA,IAE5C,IAAIK,EAAGC,EAAQC,EAAKC,EAAgCC,EAAa,EAAIN,KAAKO,KAAa,EAARV,GAAa,EAM5F,IALIS,EAD4C,KAE5CA,EAF4C,IAGhDD,EAA+B,IAAlBC,EAAa,GAC1BH,EAAS,IAAIK,MAAMF,GACnBF,EAAM,EACDF,EAAI,EAAGA,EAAII,IAAcJ,EAC1BC,EAAOD,GAAKJ,EAAMI,EAAIG,EAAWR,GACjCO,GAAOD,EAAOD,GAElB,IAAKA,EAAI,EAAGA,EAAII,IAAcJ,EAC1BC,EAAOD,IAAME,EACjB,OAAOD,IAIf,OAAOrB,EAAO2B,QAAQ1B,kBAAoBA","file":"../../shaders/ConvolutionShader.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    var ConvolutionShader = {\n        defines: {\n            'KERNEL_SIZE_FLOAT': '25.0',\n            'KERNEL_SIZE_INT': '25'\n        },\n        uniforms: {\n            'tDiffuse': { value: null },\n            'uImageIncrement': { value: new THREE.Vector2(0.001953125, 0) },\n            'cKernel': { value: [] }\n        },\n        vertexShader: [\n            'uniform vec2 uImageIncrement;',\n            'varying vec2 vUv;',\n            'void main() {',\n            '\\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;',\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n            '}'\n        ].join('\\n'),\n        fragmentShader: [\n            'uniform float cKernel[ KERNEL_SIZE_INT ];',\n            'uniform sampler2D tDiffuse;',\n            'uniform vec2 uImageIncrement;',\n            'varying vec2 vUv;',\n            'void main() {',\n            '\\tvec2 imageCoord = vUv;',\n            '\\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );',\n            '\\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {',\n            '\\t\\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];',\n            '\\t\\timageCoord += uImageIncrement;',\n            '\\t}',\n            '\\tgl_FragColor = sum;',\n            '}'\n        ].join('\\n'),\n        buildKernel: function (sigma) {\n            function gauss(x, sigma) {\n                return Math.exp(-(x * x) / (2 * sigma * sigma));\n            }\n            var i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil(sigma * 3) + 1;\n            if (kernelSize > kMaxKernelSize)\n                kernelSize = kMaxKernelSize;\n            halfWidth = (kernelSize - 1) * 0.5;\n            values = new Array(kernelSize);\n            sum = 0;\n            for (i = 0; i < kernelSize; ++i) {\n                values[i] = gauss(i - halfWidth, sigma);\n                sum += values[i];\n            }\n            for (i = 0; i < kernelSize; ++i)\n                values[i] /= sum;\n            return values;\n        }\n    };\n\n    return threex.shaders.ConvolutionShader = ConvolutionShader;\n});"]}