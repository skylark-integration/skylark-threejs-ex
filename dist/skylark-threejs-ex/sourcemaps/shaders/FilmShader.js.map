{"version":3,"sources":["shaders/FilmShader.js"],"names":["define","THREE","FilmShader","uniforms","tDiffuse","value","time","nIntensity","sIntensity","sCount","grayscale","vertexShader","join","fragmentShader"],"mappings":";;;;;;;AAAAA,QACC,mBACC,SAASC,GA0GV,OAnFAA,EAAMC,YAELC,UAECC,UAAcC,MAAO,MACrBC,MAAUD,MAAO,GACjBE,YAAgBF,MAAO,IACvBG,YAAgBH,MAAO,KACvBI,QAAYJ,MAAO,MACnBK,WAAeL,MAAO,IAIvBM,cAEC,oBAEA,gBAEA,cACA,8EAEA,KAECC,KAAM,MAERC,gBAEC,oBAGA,sBAEA,0BAGA,4BAGA,4BAGA,wBAEA,8BAEA,oBAEA,gBAGA,sDAGA,mCAGA,0FAGA,oEAGA,2EAGA,oGAGA,sBAEA,+EAEA,MAEA,uDAEA,KAECD,KAAM,OAIFX,EAAMC","file":"../../shaders/FilmShader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Film grain & scanlines shader\n\t *\n\t * - ported from HLSL to WebGL / GLSL\n\t * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n\t *\n\t * Screen Space Static Postprocessor\n\t *\n\t * Produces an analogue noise overlay similar to a film grain / TV static\n\t *\n\t * Original implementation and noise algorithm\n\t * Pat 'Hawthorne' Shearon\n\t *\n\t * Optimized scanlines + noise version with intensity scaling\n\t * Georg 'Leviathan' Steinrohder\n\t *\n\t * This version is provided under a Creative Commons Attribution 3.0 License\n\t * http://creativecommons.org/licenses/by/3.0/\n\t */\n\n\tTHREE.FilmShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"time\": { value: 0.0 },\n\t\t\t\"nIntensity\": { value: 0.5 },\n\t\t\t\"sIntensity\": { value: 0.05 },\n\t\t\t\"sCount\": { value: 4096 },\n\t\t\t\"grayscale\": { value: 1 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"#include <common>\",\n\n\t\t\t// control parameter\n\t\t\t\"uniform float time;\",\n\n\t\t\t\"uniform bool grayscale;\",\n\n\t\t\t// noise effect intensity value (0 = no effect, 1 = full effect)\n\t\t\t\"uniform float nIntensity;\",\n\n\t\t\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\n\t\t\t\"uniform float sIntensity;\",\n\n\t\t\t// scanlines effect count value (0 = no effect, 4096 = full effect)\n\t\t\t\"uniform float sCount;\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t// sample the source\n\t\t\t\"\tvec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\n\n\t\t\t// make some noise\n\t\t\t\"\tfloat dx = rand( vUv + time );\",\n\n\t\t\t// add noise\n\t\t\t\"\tvec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\",\n\n\t\t\t// get us a sine and cosine\n\t\t\t\"\tvec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\",\n\n\t\t\t// add scanlines\n\t\t\t\"\tcResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\",\n\n\t\t\t// interpolate between source and result by intensity\n\t\t\t\"\tcResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\",\n\n\t\t\t// convert to grayscale if desired\n\t\t\t\"\tif( grayscale ) {\",\n\n\t\t\t\"\t\tcResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\tgl_FragColor =  vec4( cResult, cTextureScreen.a );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.FilmShader;\n});\n"]}