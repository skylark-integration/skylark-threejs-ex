{"version":3,"sources":["shaders/DepthLimitedBlurShader.js"],"names":["define","THREE","threex","DepthLimitedBlurShader","defines","KERNEL_RADIUS","DEPTH_PACKING","PERSPECTIVE_CAMERA","uniforms","tDiffuse","value","size","Vector2","sampleUvOffsets","sampleWeights","tDepth","cameraNear","cameraFar","depthCutoff","vertexShader","join","fragmentShader","BlurShaderUtils","createSampleWeights","kernelRadius","stdDev","gaussian","x","Math","exp","sqrt","PI","weights","i","push","createSampleOffsets","uvIncrement","offsets","clone","multiplyScalar","configure","material","needsUpdate","shaders"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,GACAC,SACIC,cAAiB,EACjBC,cAAiB,EACjBC,mBAAsB,GAE1BC,UACIC,UAAcC,MAAO,MACrBC,MAAUD,MAAO,IAAIT,EAAMW,QAAQ,IAAK,MACxCC,iBAAqBH,OAAQ,IAAIT,EAAMW,QAAQ,EAAG,KAClDE,eAAmBJ,OAAQ,IAC3BK,QAAYL,MAAO,MACnBM,YAAgBN,MAAO,IACvBO,WAAeP,MAAO,KACtBQ,aAAiBR,MAAO,KAE5BS,cACI,oBACA,qBACA,oBACA,yBACA,gBACA,cACA,2BACA,8EACA,KACFC,KAAK,MACPC,gBACI,oBACA,qBACA,8BACA,4BACA,4BACA,2BACA,6BACA,qDACA,oDACA,oBACA,yBACA,mDACA,2BACA,qEACA,UACA,kDACA,WACA,IACA,2CACA,gCACA,oEACA,UACA,qEACA,WACA,IACA,gBACA,mCACA,uCACA,eACA,MACA,4CACA,yCACA,wCACA,8DACA,iDACA,6CACA,2DACA,4CACA,uDACA,oEACA,uBACA,sEACA,mCACA,QACA,uCACA,iDACA,oEACA,uBACA,sEACA,mCACA,QACA,MACA,2CACA,KACFD,KAAK,OAEPE,EAAkBnB,EAAuBmB,iBACzCC,oBAAqB,SAAUC,EAAcC,GAKzC,IAJA,IAAIC,EAAW,SAAUC,EAAGF,GACxB,OAAOG,KAAKC,KAAMF,EAAIA,GAAWF,EAASA,EAAd,KAA2BG,KAAKE,KAAK,EAAIF,KAAKG,IAAMN,IAEhFO,KACKC,EAAI,EAAGA,GAAKT,EAAcS,IAC/BD,EAAQE,KAAKR,EAASO,EAAGR,IAE7B,OAAOO,GAEXG,oBAAqB,SAAUX,EAAcY,GAEzC,IADA,IAAIC,KACKJ,EAAI,EAAGA,GAAKT,EAAcS,IAC/BI,EAAQH,KAAKE,EAAYE,QAAQC,eAAeN,IAEpD,OAAOI,GAEXG,UAAW,SAAUC,EAAUjB,EAAcC,EAAQW,GACjDK,EAASrC,QAAuB,cAAIoB,EACpCiB,EAASjC,SAA0B,gBAAEE,MAAQY,EAAgBa,oBAAoBX,EAAcY,GAC/FK,EAASjC,SAAwB,cAAEE,MAAQY,EAAgBC,oBAAoBC,EAAcC,GAC7FgB,EAASC,aAAc,IAI/B,OAAOxC,EAAOyC,QAAQxC,uBAAyBA","file":"../../shaders/DepthLimitedBlurShader.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    var DepthLimitedBlurShader = {\n        defines: {\n            'KERNEL_RADIUS': 4,\n            'DEPTH_PACKING': 1,\n            'PERSPECTIVE_CAMERA': 1\n        },\n        uniforms: {\n            'tDiffuse': { value: null },\n            'size': { value: new THREE.Vector2(512, 512) },\n            'sampleUvOffsets': { value: [new THREE.Vector2(0, 0)] },\n            'sampleWeights': { value: [1] },\n            'tDepth': { value: null },\n            'cameraNear': { value: 10 },\n            'cameraFar': { value: 1000 },\n            'depthCutoff': { value: 10 }\n        },\n        vertexShader: [\n            '#include <common>',\n            'uniform vec2 size;',\n            'varying vec2 vUv;',\n            'varying vec2 vInvSize;',\n            'void main() {',\n            '\\tvUv = uv;',\n            '\\tvInvSize = 1.0 / size;',\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n            '}'\n        ].join('\\n'),\n        fragmentShader: [\n            '#include <common>',\n            '#include <packing>',\n            'uniform sampler2D tDiffuse;',\n            'uniform sampler2D tDepth;',\n            'uniform float cameraNear;',\n            'uniform float cameraFar;',\n            'uniform float depthCutoff;',\n            'uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];',\n            'uniform float sampleWeights[ KERNEL_RADIUS + 1 ];',\n            'varying vec2 vUv;',\n            'varying vec2 vInvSize;',\n            'float getDepth( const in vec2 screenPosition ) {',\n            '\\t#if DEPTH_PACKING == 1',\n            '\\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );',\n            '\\t#else',\n            '\\treturn texture2D( tDepth, screenPosition ).x;',\n            '\\t#endif',\n            '}',\n            'float getViewZ( const in float depth ) {',\n            '\\t#if PERSPECTIVE_CAMERA == 1',\n            '\\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );',\n            '\\t#else',\n            '\\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );',\n            '\\t#endif',\n            '}',\n            'void main() {',\n            '\\tfloat depth = getDepth( vUv );',\n            '\\tif( depth >= ( 1.0 - EPSILON ) ) {',\n            '\\t\\tdiscard;',\n            '\\t}',\n            '\\tfloat centerViewZ = -getViewZ( depth );',\n            '\\tbool rBreak = false, lBreak = false;',\n            '\\tfloat weightSum = sampleWeights[0];',\n            '\\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;',\n            '\\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {',\n            '\\t\\tfloat sampleWeight = sampleWeights[i];',\n            '\\t\\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;',\n            '\\t\\tvec2 sampleUv = vUv + sampleUvOffset;',\n            '\\t\\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );',\n            '\\t\\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;',\n            '\\t\\tif( ! rBreak ) {',\n            '\\t\\t\\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;',\n            '\\t\\t\\tweightSum += sampleWeight;',\n            '\\t\\t}',\n            '\\t\\tsampleUv = vUv - sampleUvOffset;',\n            '\\t\\tviewZ = -getViewZ( getDepth( sampleUv ) );',\n            '\\t\\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;',\n            '\\t\\tif( ! lBreak ) {',\n            '\\t\\t\\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;',\n            '\\t\\t\\tweightSum += sampleWeight;',\n            '\\t\\t}',\n            '\\t}',\n            '\\tgl_FragColor = diffuseSum / weightSum;',\n            '}'\n        ].join('\\n')\n    };\n    var BlurShaderUtils = DepthLimitedBlurShader.BlurShaderUtils = {\n        createSampleWeights: function (kernelRadius, stdDev) {\n            var gaussian = function (x, stdDev) {\n                return Math.exp(-(x * x) / (2 * (stdDev * stdDev))) / (Math.sqrt(2 * Math.PI) * stdDev);\n            };\n            var weights = [];\n            for (var i = 0; i <= kernelRadius; i++) {\n                weights.push(gaussian(i, stdDev));\n            }\n            return weights;\n        },\n        createSampleOffsets: function (kernelRadius, uvIncrement) {\n            var offsets = [];\n            for (var i = 0; i <= kernelRadius; i++) {\n                offsets.push(uvIncrement.clone().multiplyScalar(i));\n            }\n            return offsets;\n        },\n        configure: function (material, kernelRadius, stdDev, uvIncrement) {\n            material.defines['KERNEL_RADIUS'] = kernelRadius;\n            material.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n            material.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n            material.needsUpdate = true;\n        }\n    };\n\n    return threex.shaders.DepthLimitedBlurShader = DepthLimitedBlurShader;\n    \n});"]}