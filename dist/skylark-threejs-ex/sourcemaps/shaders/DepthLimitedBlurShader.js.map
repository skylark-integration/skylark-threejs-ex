{"version":3,"sources":["shaders/DepthLimitedBlurShader.js"],"names":["define","THREE","threex","DepthLimitedBlurShader","defines","KERNEL_RADIUS","DEPTH_PACKING","PERSPECTIVE_CAMERA","uniforms","tDiffuse","value","size","Vector2","sampleUvOffsets","sampleWeights","tDepth","cameraNear","cameraFar","depthCutoff","vertexShader","join","fragmentShader","BlurShaderUtils","createSampleWeights","kernelRadius","stdDev","gaussian","x","Math","exp","sqrt","PI","weights","i","push","createSampleOffsets","uvIncrement","offsets","clone","multiplyScalar","configure","material","needsUpdate","shaders"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,GACAC,SACIC,cAAiB,EACjBC,cAAiB,EACjBC,mBAAsB,GAE1BC,UACIC,UAAcC,MAAO,MACrBC,MAAUD,MAAO,IAAIT,EAAMW,QAAQ,IAAK,MACxCC,iBAAqBH,OAAQ,IAAIT,EAAMW,QAAQ,EAAG,KAClDE,eAAmBJ,OAAQ,IAC3BK,QAAYL,MAAO,MACnBM,YAAgBN,MAAO,IACvBO,WAAeP,MAAO,KACtBQ,aAAiBR,MAAO,KAE5BS,cACI,oBACA,qBACA,oBACA,yBACA,gBACA,cACA,2BACA,8EACA,KACFC,KAAK,MACPC,gBACI,oBACA,qBACA,8BACA,4BACA,4BACA,2BACA,6BACA,qDACA,oDACA,oBACA,yBACA,mDACA,2BACA,qEACA,UACA,kDACA,WACA,IACA,2CACA,gCACA,oEACA,UACA,qEACA,WACA,IACA,gBACA,mCACA,uCACA,eACA,MACA,4CACA,yCACA,wCACA,8DACA,iDACA,6CACA,2DACA,4CACA,uDACA,oEACA,uBACA,sEACA,mCACA,QACA,uCACA,iDACA,oEACA,uBACA,sEACA,mCACA,QACA,MACA,2CACA,KACFD,KAAK,OAEPE,EAAkBnB,EAAuBmB,iBACzCC,oBAAqB,SAAUC,EAAcC,GAKzC,IAJA,IAAIC,EAAW,SAAUC,EAAGF,GACxB,OAAOG,KAAKC,KAAMF,EAAIA,GAAWF,EAASA,EAAd,KAA2BG,KAAKE,KAAK,EAAIF,KAAKG,IAAMN,IAEhFO,KACKC,EAAI,EAAGA,GAAKT,EAAcS,IAC/BD,EAAQE,KAAKR,EAASO,EAAGR,IAE7B,OAAOO,GAEXG,oBAAqB,SAAUX,EAAcY,GAEzC,IADA,IAAIC,KACKJ,EAAI,EAAGA,GAAKT,EAAcS,IAC/BI,EAAQH,KAAKE,EAAYE,QAAQC,eAAeN,IAEpD,OAAOI,GAEXG,UAAW,SAAUC,EAAUjB,EAAcC,EAAQW,GACjDK,EAASrC,QAAuB,cAAIoB,EACpCiB,EAASjC,SAA0B,gBAAEE,MAAQY,EAAgBa,oBAAoBX,EAAcY,GAC/FK,EAASjC,SAAwB,cAAEE,MAAQY,EAAgBC,oBAAoBC,EAAcC,GAC7FgB,EAASC,aAAc,IAI/B,OAAOxC,EAAOyC,QAAQxC,uBAAyBA","file":"../../shaders/DepthLimitedBlurShader.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var DepthLimitedBlurShader = {\r\n        defines: {\r\n            'KERNEL_RADIUS': 4,\r\n            'DEPTH_PACKING': 1,\r\n            'PERSPECTIVE_CAMERA': 1\r\n        },\r\n        uniforms: {\r\n            'tDiffuse': { value: null },\r\n            'size': { value: new THREE.Vector2(512, 512) },\r\n            'sampleUvOffsets': { value: [new THREE.Vector2(0, 0)] },\r\n            'sampleWeights': { value: [1] },\r\n            'tDepth': { value: null },\r\n            'cameraNear': { value: 10 },\r\n            'cameraFar': { value: 1000 },\r\n            'depthCutoff': { value: 10 }\r\n        },\r\n        vertexShader: [\r\n            '#include <common>',\r\n            'uniform vec2 size;',\r\n            'varying vec2 vUv;',\r\n            'varying vec2 vInvSize;',\r\n            'void main() {',\r\n            '\\tvUv = uv;',\r\n            '\\tvInvSize = 1.0 / size;',\r\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            '#include <common>',\r\n            '#include <packing>',\r\n            'uniform sampler2D tDiffuse;',\r\n            'uniform sampler2D tDepth;',\r\n            'uniform float cameraNear;',\r\n            'uniform float cameraFar;',\r\n            'uniform float depthCutoff;',\r\n            'uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];',\r\n            'uniform float sampleWeights[ KERNEL_RADIUS + 1 ];',\r\n            'varying vec2 vUv;',\r\n            'varying vec2 vInvSize;',\r\n            'float getDepth( const in vec2 screenPosition ) {',\r\n            '\\t#if DEPTH_PACKING == 1',\r\n            '\\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );',\r\n            '\\t#else',\r\n            '\\treturn texture2D( tDepth, screenPosition ).x;',\r\n            '\\t#endif',\r\n            '}',\r\n            'float getViewZ( const in float depth ) {',\r\n            '\\t#if PERSPECTIVE_CAMERA == 1',\r\n            '\\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );',\r\n            '\\t#else',\r\n            '\\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );',\r\n            '\\t#endif',\r\n            '}',\r\n            'void main() {',\r\n            '\\tfloat depth = getDepth( vUv );',\r\n            '\\tif( depth >= ( 1.0 - EPSILON ) ) {',\r\n            '\\t\\tdiscard;',\r\n            '\\t}',\r\n            '\\tfloat centerViewZ = -getViewZ( depth );',\r\n            '\\tbool rBreak = false, lBreak = false;',\r\n            '\\tfloat weightSum = sampleWeights[0];',\r\n            '\\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;',\r\n            '\\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {',\r\n            '\\t\\tfloat sampleWeight = sampleWeights[i];',\r\n            '\\t\\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;',\r\n            '\\t\\tvec2 sampleUv = vUv + sampleUvOffset;',\r\n            '\\t\\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );',\r\n            '\\t\\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;',\r\n            '\\t\\tif( ! rBreak ) {',\r\n            '\\t\\t\\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;',\r\n            '\\t\\t\\tweightSum += sampleWeight;',\r\n            '\\t\\t}',\r\n            '\\t\\tsampleUv = vUv - sampleUvOffset;',\r\n            '\\t\\tviewZ = -getViewZ( getDepth( sampleUv ) );',\r\n            '\\t\\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;',\r\n            '\\t\\tif( ! lBreak ) {',\r\n            '\\t\\t\\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;',\r\n            '\\t\\t\\tweightSum += sampleWeight;',\r\n            '\\t\\t}',\r\n            '\\t}',\r\n            '\\tgl_FragColor = diffuseSum / weightSum;',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    var BlurShaderUtils = DepthLimitedBlurShader.BlurShaderUtils = {\r\n        createSampleWeights: function (kernelRadius, stdDev) {\r\n            var gaussian = function (x, stdDev) {\r\n                return Math.exp(-(x * x) / (2 * (stdDev * stdDev))) / (Math.sqrt(2 * Math.PI) * stdDev);\r\n            };\r\n            var weights = [];\r\n            for (var i = 0; i <= kernelRadius; i++) {\r\n                weights.push(gaussian(i, stdDev));\r\n            }\r\n            return weights;\r\n        },\r\n        createSampleOffsets: function (kernelRadius, uvIncrement) {\r\n            var offsets = [];\r\n            for (var i = 0; i <= kernelRadius; i++) {\r\n                offsets.push(uvIncrement.clone().multiplyScalar(i));\r\n            }\r\n            return offsets;\r\n        },\r\n        configure: function (material, kernelRadius, stdDev, uvIncrement) {\r\n            material.defines['KERNEL_RADIUS'] = kernelRadius;\r\n            material.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\r\n            material.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\r\n            material.needsUpdate = true;\r\n        }\r\n    };\r\n\r\n    return threex.shaders.DepthLimitedBlurShader = DepthLimitedBlurShader;\r\n    \r\n});"]}