{"version":3,"sources":["shaders/DepthLimitedBlurShader.js"],"names":["define","THREE","DepthLimitedBlurShader","defines","KERNEL_RADIUS","DEPTH_PACKING","PERSPECTIVE_CAMERA","uniforms","tDiffuse","value","size","Vector2","sampleUvOffsets","sampleWeights","tDepth","cameraNear","cameraFar","depthCutoff","vertexShader","join","fragmentShader","BlurShaderUtils","createSampleWeights","kernelRadius","stdDev","gaussian","x","Math","exp","sqrt","PI","weights","i","push","createSampleOffsets","uvIncrement","offsets","clone","multiplyScalar","configure","material","needsUpdate"],"mappings":";;;;;;;AAAAA,QACC,mBACC,SAASC,GAiKV,OA5JAA,EAAMC,wBACLC,SACCC,cAAiB,EACjBC,cAAiB,EACjBC,mBAAsB,GAEvBC,UACCC,UAAcC,MAAO,MACrBC,MAAUD,MAAO,IAAIR,EAAMU,QAAS,IAAK,MACzCC,iBAAqBH,OAAS,IAAIR,EAAMU,QAAS,EAAG,KACpDE,eAAmBJ,OAAS,IAC5BK,QAAYL,MAAO,MACnBM,YAAgBN,MAAO,IACvBO,WAAeP,MAAO,KACtBQ,aAAiBR,MAAO,KAEzBS,cACC,oBAEA,qBAEA,oBACA,yBAEA,gBACA,cACA,2BAEA,8EACA,KAECC,KAAM,MACRC,gBACC,oBACA,qBAEA,8BACA,4BAEA,4BACA,2BACA,6BAEA,qDACA,oDAEA,oBACA,yBAEA,mDACA,2BACA,qEACA,UACA,kDACA,WACA,IAEA,2CACA,gCACA,oEACA,UACA,qEACA,WACA,IAEA,gBACA,mCACA,uCACA,eACA,MAEA,4CACA,yCAEA,wCACA,8DAEA,iDAEA,6CACA,2DAEA,4CACA,uDAEA,oEAEA,uBACA,sEACA,mCACA,QAEA,uCACA,iDAEA,oEAEA,uBACA,sEACA,mCACA,QAEA,MAEA,2CACA,KACCD,KAAM,OAGTlB,EAAMoB,iBAELC,oBAAqB,SAAWC,EAAcC,GAU7C,IARA,IAAIC,EAAW,SAAWC,EAAGF,GAE5B,OAAOG,KAAKC,KAASF,EAAIA,GAAgBF,EAASA,EAAjB,KAAkCG,KAAKE,KAAM,EAAMF,KAAKG,IAAON,IAI7FO,KAEMC,EAAI,EAAGA,GAAKT,EAAcS,IAEnCD,EAAQE,KAAMR,EAAUO,EAAGR,IAI5B,OAAOO,GAIRG,oBAAqB,SAAWX,EAAcY,GAI7C,IAFA,IAAIC,KAEMJ,EAAI,EAAGA,GAAKT,EAAcS,IAEnCI,EAAQH,KAAME,EAAYE,QAAQC,eAAgBN,IAInD,OAAOI,GAIRG,UAAW,SAAWC,EAAUjB,EAAcC,EAAQW,GAErDK,EAASrC,QAAyB,cAAIoB,EACtCiB,EAASjC,SAA4B,gBAAEE,MAAQR,EAAMoB,gBAAgBa,oBAAqBX,EAAcY,GACxGK,EAASjC,SAA0B,cAAEE,MAAQR,EAAMoB,gBAAgBC,oBAAqBC,EAAcC,GACtGgB,EAASC,aAAc,IAMlBxC,EAAMC","file":"../../shaders/DepthLimitedBlurShader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * TODO\n\t */\n\n\tTHREE.DepthLimitedBlurShader = {\n\t\tdefines: {\n\t\t\t\"KERNEL_RADIUS\": 4,\n\t\t\t\"DEPTH_PACKING\": 1,\n\t\t\t\"PERSPECTIVE_CAMERA\": 1\n\t\t},\n\t\tuniforms: {\n\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\"size\": { value: new THREE.Vector2( 512, 512 ) },\n\t\t\t\"sampleUvOffsets\": { value: [ new THREE.Vector2( 0, 0 ) ] },\n\t\t\t\"sampleWeights\": { value: [ 1.0 ] },\n\t\t\t\"tDepth\": { value: null },\n\t\t\t\"cameraNear\": { value: 10 },\n\t\t\t\"cameraFar\": { value: 1000 },\n\t\t\t\"depthCutoff\": { value: 10 },\n\t\t},\n\t\tvertexShader: [\n\t\t\t\"#include <common>\",\n\n\t\t\t\"uniform vec2 size;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"varying vec2 vInvSize;\",\n\n\t\t\t\"void main() {\",\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tvInvSize = 1.0 / size;\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\t\tfragmentShader: [\n\t\t\t\"#include <common>\",\n\t\t\t\"#include <packing>\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\t\"uniform float cameraNear;\",\n\t\t\t\"uniform float cameraFar;\",\n\t\t\t\"uniform float depthCutoff;\",\n\n\t\t\t\"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\",\n\t\t\t\"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\",\n\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"varying vec2 vInvSize;\",\n\n\t\t\t\"float getDepth( const in vec2 screenPosition ) {\",\n\t\t\t\"\t#if DEPTH_PACKING == 1\",\n\t\t\t\"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"float getViewZ( const in float depth ) {\",\n\t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\t\t\t\"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\t\"\t#else\",\n\t\t\t\"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\t\"\t#endif\",\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\t\t\t\"\tfloat depth = getDepth( vUv );\",\n\t\t\t\"\tif( depth >= ( 1.0 - EPSILON ) ) {\",\n\t\t\t\"\t\tdiscard;\",\n\t\t\t\"\t}\",\n\n\t\t\t\"\tfloat centerViewZ = -getViewZ( depth );\",\n\t\t\t\"\tbool rBreak = false, lBreak = false;\",\n\n\t\t\t\"\tfloat weightSum = sampleWeights[0];\",\n\t\t\t\"\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\",\n\n\t\t\t\"\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\",\n\n\t\t\t\"\t\tfloat sampleWeight = sampleWeights[i];\",\n\t\t\t\"\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\",\n\n\t\t\t\"\t\tvec2 sampleUv = vUv + sampleUvOffset;\",\n\t\t\t\"\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\",\n\n\t\t\t\"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\",\n\n\t\t\t\"\t\tif( ! rBreak ) {\",\n\t\t\t\"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\",\n\t\t\t\"\t\t\tweightSum += sampleWeight;\",\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t\tsampleUv = vUv - sampleUvOffset;\",\n\t\t\t\"\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\",\n\n\t\t\t\"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\",\n\n\t\t\t\"\t\tif( ! lBreak ) {\",\n\t\t\t\"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\",\n\t\t\t\"\t\t\tweightSum += sampleWeight;\",\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\tgl_FragColor = diffuseSum / weightSum;\",\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\t};\n\n\tTHREE.BlurShaderUtils = {\n\n\t\tcreateSampleWeights: function ( kernelRadius, stdDev ) {\n\n\t\t\tvar gaussian = function ( x, stdDev ) {\n\n\t\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * ( stdDev * stdDev ) ) ) / ( Math.sqrt( 2.0 * Math.PI ) * stdDev );\n\n\t\t\t};\n\n\t\t\tvar weights = [];\n\n\t\t\tfor ( var i = 0; i <= kernelRadius; i ++ ) {\n\n\t\t\t\tweights.push( gaussian( i, stdDev ) );\n\n\t\t\t}\n\n\t\t\treturn weights;\n\n\t\t},\n\n\t\tcreateSampleOffsets: function ( kernelRadius, uvIncrement ) {\n\n\t\t\tvar offsets = [];\n\n\t\t\tfor ( var i = 0; i <= kernelRadius; i ++ ) {\n\n\t\t\t\toffsets.push( uvIncrement.clone().multiplyScalar( i ) );\n\n\t\t\t}\n\n\t\t\treturn offsets;\n\n\t\t},\n\n\t\tconfigure: function ( material, kernelRadius, stdDev, uvIncrement ) {\n\n\t\t\tmaterial.defines[ \"KERNEL_RADIUS\" ] = kernelRadius;\n\t\t\tmaterial.uniforms[ \"sampleUvOffsets\" ].value = THREE.BlurShaderUtils.createSampleOffsets( kernelRadius, uvIncrement );\n\t\t\tmaterial.uniforms[ \"sampleWeights\" ].value = THREE.BlurShaderUtils.createSampleWeights( kernelRadius, stdDev );\n\t\t\tmaterial.needsUpdate = true;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.DepthLimitedBlurShader;\n});\n"]}