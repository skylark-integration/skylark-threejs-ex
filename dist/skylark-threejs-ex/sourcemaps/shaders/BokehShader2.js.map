{"version":3,"sources":["shaders/BokehShader2.js"],"names":["define","THREE","BokehShader","uniforms","textureWidth","value","textureHeight","focalDepth","focalLength","fstop","tColor","tDepth","maxblur","showFocus","manualdof","vignetting","depthblur","threshold","gain","bias","fringe","znear","zfar","noise","dithering","pentagon","shaderFocus","focusCoords","Vector2","vertexShader","join","fragmentShader","BokehDepthShader","mNear","mFar"],"mappings":";;;;;;;AAAAA,QAAQ,mBAAoB,SAAUC,GAClC,aACA,IAAIC,GACAC,UACIC,cAAkBC,MAAO,GACzBC,eAAmBD,MAAO,GAC1BE,YAAgBF,MAAO,GACvBG,aAAiBH,MAAO,IACxBI,OAAWJ,MAAO,IAClBK,QAAYL,MAAO,MACnBM,QAAYN,MAAO,MACnBO,SAAaP,MAAO,GACpBQ,WAAeR,MAAO,GACtBS,WAAeT,MAAO,GACtBU,YAAgBV,MAAO,GACvBW,WAAeX,MAAO,GACtBY,WAAeZ,MAAO,IACtBa,MAAUb,MAAO,GACjBc,MAAUd,MAAO,IACjBe,QAAYf,MAAO,IACnBgB,OAAWhB,MAAO,IAClBiB,MAAUjB,MAAO,KACjBkB,OAAWlB,MAAO,GAClBmB,WAAenB,MAAO,MACtBoB,UAAcpB,MAAO,GACrBqB,aAAiBrB,MAAO,GACxBsB,aAAiBtB,MAAO,IAAIJ,EAAM2B,UAEtCC,cACI,oBACA,gBACA,cACA,8EACA,KACFC,KAAK,MACPC,gBACI,oBACA,oBACA,4BACA,4BACA,8BACA,+BACA,sGACA,kDACA,sCACA,4GACA,KACA,mGACA,KACA,gDACA,6CACA,+CACA,mBACA,2DACA,wCACA,8CACA,oDACA,gDACA,0DACA,+CACA,yDACA,0EACA,0DACA,kDACA,iDACA,uDACA,4BACA,kDACA,4BACA,oFACA,6CACA,yBACA,yDACA,mDACA,yCACA,yCACA,iEACA,0EACA,2BACA,mDACA,0CACA,KACA,4BACA,oDACA,kDACA,KACA,wDACA,gDACA,+CACA,6BACA,uBACA,sCACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,6BACA,gDACA,2BACA,0BACA,4BACA,4BACA,4BACA,4BACA,kDACA,iCACA,4BACA,iCACA,kDACA,uBACA,uCACA,IACA,8BACA,yBACA,mBACA,qBACA,oBACA,iEACA,mCACA,mCACA,mCACA,mCACA,mCACA,mCACA,mCACA,mCACA,mCACA,0EACA,0EACA,0EACA,+BACA,2DACA,4BACA,MACA,cACA,IACA,uCACA,4BACA,0BACA,2DACA,0EACA,8EACA,6EACA,6CACA,wCACA,mDACA,+CACA,IACA,uDACA,8DACA,wDACA,4DACA,kDACA,4DACA,gBACA,IACA,iCACA,4DACA,IACA,qBACA,kDACA,gFACA,gCACA,IACA,kGACA,iCACA,8CACA,8BACA,8BACA,mBACA,oBACA,8BACA,MACA,iFACA,gDACA,IACA,gBACA,8BACA,yDACA,mBACA,uBACA,yCACA,MACA,8BACA,+BACA,uBACA,2DACA,MACA,mCACA,sBACA,qBACA,6CACA,mDACA,qDACA,8BACA,aACA,mDACA,oDACA,6CACA,6BACA,6BACA,qCACA,yBACA,MACA,gCACA,4CACA,wFACA,wCACA,uDACA,wDACA,kCACA,0BACA,sBACA,iCACA,2CACA,aACA,2CACA,qBACA,uBACA,yCACA,uBACA,mCACA,qDACA,uCACA,yEACA,UACA,qBACA,QACA,yCACA,MACA,qBACA,0CACA,MACA,sBACA,yBACA,MACA,4BACA,0BACA,MACFD,KAAK,OAEY5B,EAAY8B,kBAC/B7B,UACI8B,OAAW5B,MAAO,GAClB6B,MAAU7B,MAAO,MAErBwB,cACI,6BACA,gBACA,4BACA,8BACA,kCACA,KACFC,KAAK,MACPC,gBACI,uBACA,sBACA,6BACA,gBACA,gEACA,+CACA,MACFD,KAAK,OAGX,OAAQ5B","file":"../../shaders/BokehShader2.js","sourcesContent":["define([\"skylark-threejs\"], function (THREE) {\n    'use strict';\n    var BokehShader = {\n        uniforms: {\n            'textureWidth': { value: 1 },\n            'textureHeight': { value: 1 },\n            'focalDepth': { value: 1 },\n            'focalLength': { value: 24 },\n            'fstop': { value: 0.9 },\n            'tColor': { value: null },\n            'tDepth': { value: null },\n            'maxblur': { value: 1 },\n            'showFocus': { value: 0 },\n            'manualdof': { value: 0 },\n            'vignetting': { value: 0 },\n            'depthblur': { value: 0 },\n            'threshold': { value: 0.5 },\n            'gain': { value: 2 },\n            'bias': { value: 0.5 },\n            'fringe': { value: 0.7 },\n            'znear': { value: 0.1 },\n            'zfar': { value: 100 },\n            'noise': { value: 1 },\n            'dithering': { value: 0.0001 },\n            'pentagon': { value: 0 },\n            'shaderFocus': { value: 1 },\n            'focusCoords': { value: new THREE.Vector2() }\n        },\n        vertexShader: [\n            'varying vec2 vUv;',\n            'void main() {',\n            '\\tvUv = uv;',\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n            '}'\n        ].join('\\n'),\n        fragmentShader: [\n            '#include <common>',\n            'varying vec2 vUv;',\n            'uniform sampler2D tColor;',\n            'uniform sampler2D tDepth;',\n            'uniform float textureWidth;',\n            'uniform float textureHeight;',\n            'uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below',\n            'uniform float focalLength; //focal length in mm',\n            'uniform float fstop; //f-stop value',\n            'uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)',\n            '/*',\n            'make sure that these two values are the same for your camera, otherwise distances will be wrong.',\n            '*/',\n            'uniform float znear; // camera clipping start',\n            'uniform float zfar; // camera clipping end',\n            '//------------------------------------------',\n            '//user variables',\n            'const int samples = SAMPLES; //samples on the first ring',\n            'const int rings = RINGS; //ring count',\n            'const int maxringsamples = rings * samples;',\n            'uniform bool manualdof; // manual dof calculation',\n            'float ndofstart = 1.0; // near dof blur start',\n            'float ndofdist = 2.0; // near dof blur falloff distance',\n            'float fdofstart = 1.0; // far dof blur start',\n            'float fdofdist = 3.0; // far dof blur falloff distance',\n            'float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)',\n            'uniform bool vignetting; // use optical lens vignetting',\n            'float vignout = 1.3; // vignetting outer border',\n            'float vignin = 0.0; // vignetting inner border',\n            'float vignfade = 22.0; // f-stops till vignete fades',\n            'uniform bool shaderFocus;',\n            '// disable if you use external focalDepth value',\n            'uniform vec2 focusCoords;',\n            '// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)',\n            '// if center of screen use vec2(0.5, 0.5);',\n            'uniform float maxblur;',\n            '//clamp value of max blur (0.0 = no blur, 1.0 default)',\n            'uniform float threshold; // highlight threshold;',\n            'uniform float gain; // highlight gain;',\n            'uniform float bias; // bokeh edge bias',\n            'uniform float fringe; // bokeh chromatic aberration / fringing',\n            'uniform bool noise; //use noise instead of pattern for sample dithering',\n            'uniform float dithering;',\n            'uniform bool depthblur; // blur the depth buffer',\n            'float dbsize = 1.25; // depth blur size',\n            '/*',\n            'next part is experimental',\n            'not looking good with small sample and ring count',\n            'looks okay starting from samples = 4, rings = 4',\n            '*/',\n            'uniform bool pentagon; //use pentagon as bokeh shape?',\n            'float feather = 0.4; //pentagon shape feather',\n            '//------------------------------------------',\n            'float penta(vec2 coords) {',\n            '\\t//pentagonal shape',\n            '\\tfloat scale = float(rings) - 1.3;',\n            '\\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);',\n            '\\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);',\n            '\\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);',\n            '\\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);',\n            '\\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);',\n            '\\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);',\n            '\\tvec4  one = vec4( 1.0 );',\n            '\\tvec4 P = vec4((coords),vec2(scale, scale));',\n            '\\tvec4 dist = vec4(0.0);',\n            '\\tfloat inorout = -4.0;',\n            '\\tdist.x = dot( P, HS0 );',\n            '\\tdist.y = dot( P, HS1 );',\n            '\\tdist.z = dot( P, HS2 );',\n            '\\tdist.w = dot( P, HS3 );',\n            '\\tdist = smoothstep( -feather, feather, dist );',\n            '\\tinorout += dot( dist, one );',\n            '\\tdist.x = dot( P, HS4 );',\n            '\\tdist.y = HS5.w - abs( P.z );',\n            '\\tdist = smoothstep( -feather, feather, dist );',\n            '\\tinorout += dist.x;',\n            '\\treturn clamp( inorout, 0.0, 1.0 );',\n            '}',\n            'float bdepth(vec2 coords) {',\n            '\\t// Depth buffer blur',\n            '\\tfloat d = 0.0;',\n            '\\tfloat kernel[9];',\n            '\\tvec2 offset[9];',\n            '\\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;',\n            '\\toffset[0] = vec2(-wh.x,-wh.y);',\n            '\\toffset[1] = vec2( 0.0, -wh.y);',\n            '\\toffset[2] = vec2( wh.x -wh.y);',\n            '\\toffset[3] = vec2(-wh.x,  0.0);',\n            '\\toffset[4] = vec2( 0.0,   0.0);',\n            '\\toffset[5] = vec2( wh.x,  0.0);',\n            '\\toffset[6] = vec2(-wh.x, wh.y);',\n            '\\toffset[7] = vec2( 0.0,  wh.y);',\n            '\\toffset[8] = vec2( wh.x, wh.y);',\n            '\\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;',\n            '\\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;',\n            '\\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;',\n            '\\tfor( int i=0; i<9; i++ ) {',\n            '\\t\\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;',\n            '\\t\\td += tmp * kernel[i];',\n            '\\t}',\n            '\\treturn d;',\n            '}',\n            'vec3 color(vec2 coords,float blur) {',\n            '\\t//processing the sample',\n            '\\tvec3 col = vec3(0.0);',\n            '\\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);',\n            '\\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;',\n            '\\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;',\n            '\\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;',\n            '\\tvec3 lumcoeff = vec3(0.299,0.587,0.114);',\n            '\\tfloat lum = dot(col.rgb, lumcoeff);',\n            '\\tfloat thresh = max((lum-threshold)*gain, 0.0);',\n            '\\treturn col+mix(vec3(0.0),col,thresh*blur);',\n            '}',\n            'vec3 debugFocus(vec3 col, float blur, float depth) {',\n            '\\tfloat edge = 0.002*depth; //distance based edge smoothing',\n            '\\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);',\n            '\\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);',\n            '\\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);',\n            '\\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);',\n            '\\treturn col;',\n            '}',\n            'float linearize(float depth) {',\n            '\\treturn -zfar * znear / (depth * (zfar - znear) - zfar);',\n            '}',\n            'float vignette() {',\n            '\\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));',\n            '\\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);',\n            '\\treturn clamp(dist,0.0,1.0);',\n            '}',\n            'float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {',\n            '\\tfloat rings2 = float(rings);',\n            '\\tfloat step = PI*2.0 / float(ringsamples);',\n            '\\tfloat pw = cos(j*step)*i;',\n            '\\tfloat ph = sin(j*step)*i;',\n            '\\tfloat p = 1.0;',\n            '\\tif (pentagon) {',\n            '\\t\\tp = penta(vec2(pw,ph));',\n            '\\t}',\n            '\\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;',\n            '\\treturn 1.0 * mix(1.0, i /rings2, bias) * p;',\n            '}',\n            'void main() {',\n            '\\t//scene depth calculation',\n            '\\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);',\n            '\\t// Blur depth?',\n            '\\tif ( depthblur ) {',\n            '\\t\\tdepth = linearize(bdepth(vUv.xy));',\n            '\\t}',\n            '\\t//focal plane calculation',\n            '\\tfloat fDepth = focalDepth;',\n            '\\tif (shaderFocus) {',\n            '\\t\\tfDepth = linearize(texture2D(tDepth,focusCoords).x);',\n            '\\t}',\n            '\\t// dof blur factor calculation',\n            '\\tfloat blur = 0.0;',\n            '\\tif (manualdof) {',\n            '\\t\\tfloat a = depth-fDepth; // Focal plane',\n            '\\t\\tfloat b = (a-fdofstart)/fdofdist; // Far DoF',\n            '\\t\\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof',\n            '\\t\\tblur = (a>0.0) ? b : c;',\n            '\\t} else {',\n            '\\t\\tfloat f = focalLength; // focal length in mm',\n            '\\t\\tfloat d = fDepth*1000.0; // focal plane in mm',\n            '\\t\\tfloat o = depth*1000.0; // depth in mm',\n            '\\t\\tfloat a = (o*f)/(o-f);',\n            '\\t\\tfloat b = (d*f)/(d-f);',\n            '\\t\\tfloat c = (d-f)/(d*fstop*CoC);',\n            '\\t\\tblur = abs(a-b)*c;',\n            '\\t}',\n            '\\tblur = clamp(blur,0.0,1.0);',\n            '\\t// calculation of pattern for dithering',\n            '\\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;',\n            '\\t// getting blur x and y step factor',\n            '\\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;',\n            '\\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;',\n            '\\t// calculation of final color',\n            '\\tvec3 col = vec3(0.0);',\n            '\\tif(blur < 0.05) {',\n            '\\t\\t//some optimization thingy',\n            '\\t\\tcol = texture2D(tColor, vUv.xy).rgb;',\n            '\\t} else {',\n            '\\t\\tcol = texture2D(tColor, vUv.xy).rgb;',\n            '\\t\\tfloat s = 1.0;',\n            '\\t\\tint ringsamples;',\n            '\\t\\tfor (int i = 1; i <= rings; i++) {',\n            '\\t\\t\\t/*unboxstart*/',\n            '\\t\\t\\tringsamples = i * samples;',\n            '\\t\\t\\tfor (int j = 0 ; j < maxringsamples ; j++) {',\n            '\\t\\t\\t\\tif (j >= ringsamples) break;',\n            '\\t\\t\\t\\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);',\n            '\\t\\t\\t}',\n            '\\t\\t\\t/*unboxend*/',\n            '\\t\\t}',\n            '\\t\\tcol /= s; //divide by sample count',\n            '\\t}',\n            '\\tif (showFocus) {',\n            '\\t\\tcol = debugFocus(col, blur, depth);',\n            '\\t}',\n            '\\tif (vignetting) {',\n            '\\t\\tcol *= vignette();',\n            '\\t}',\n            '\\tgl_FragColor.rgb = col;',\n            '\\tgl_FragColor.a = 1.0;',\n            '} '\n        ].join('\\n')\n    };\n    var BokehDepthShader = BokehShader.BokehDepthShader =  {\n        uniforms: {\n            'mNear': { value: 1 },\n            'mFar': { value: 1000 }\n        },\n        vertexShader: [\n            'varying float vViewZDepth;',\n            'void main() {',\n            '\\t#include <begin_vertex>',\n            '\\t#include <project_vertex>',\n            '\\tvViewZDepth = - mvPosition.z;',\n            '}'\n        ].join('\\n'),\n        fragmentShader: [\n            'uniform float mNear;',\n            'uniform float mFar;',\n            'varying float vViewZDepth;',\n            'void main() {',\n            '\\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );',\n            '\\tgl_FragColor = vec4( vec3( color ), 1.0 );',\n            '} '\n        ].join('\\n')\n    };\n\n    return  BokehShader;\n});"]}