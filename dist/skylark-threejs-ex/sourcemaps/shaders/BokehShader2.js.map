{"version":3,"sources":["shaders/BokehShader2.js"],"names":["define","THREE","threex","BokehShader","uniforms","textureWidth","value","textureHeight","focalDepth","focalLength","fstop","tColor","tDepth","maxblur","showFocus","manualdof","vignetting","depthblur","threshold","gain","bias","fringe","znear","zfar","noise","dithering","pentagon","shaderFocus","focusCoords","Vector2","vertexShader","join","fragmentShader","BokehDepthShader","mNear","mFar","shaders","BokehShader2"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,GACAC,UACIC,cAAkBC,MAAO,GACzBC,eAAmBD,MAAO,GAC1BE,YAAgBF,MAAO,GACvBG,aAAiBH,MAAO,IACxBI,OAAWJ,MAAO,IAClBK,QAAYL,MAAO,MACnBM,QAAYN,MAAO,MACnBO,SAAaP,MAAO,GACpBQ,WAAeR,MAAO,GACtBS,WAAeT,MAAO,GACtBU,YAAgBV,MAAO,GACvBW,WAAeX,MAAO,GACtBY,WAAeZ,MAAO,IACtBa,MAAUb,MAAO,GACjBc,MAAUd,MAAO,IACjBe,QAAYf,MAAO,IACnBgB,OAAWhB,MAAO,IAClBiB,MAAUjB,MAAO,KACjBkB,OAAWlB,MAAO,GAClBmB,WAAenB,MAAO,MACtBoB,UAAcpB,MAAO,GACrBqB,aAAiBrB,MAAO,GACxBsB,aAAiBtB,MAAO,IAAIL,EAAM4B,UAEtCC,cACI,oBACA,gBACA,cACA,8EACA,KACFC,KAAK,MACPC,gBACI,oBACA,oBACA,4BACA,4BACA,8BACA,+BACA,sGACA,kDACA,sCACA,4GACA,KACA,mGACA,KACA,gDACA,6CACA,+CACA,mBACA,2DACA,wCACA,8CACA,oDACA,gDACA,0DACA,+CACA,yDACA,0EACA,0DACA,kDACA,iDACA,uDACA,4BACA,kDACA,4BACA,oFACA,6CACA,yBACA,yDACA,mDACA,yCACA,yCACA,iEACA,0EACA,2BACA,mDACA,0CACA,KACA,4BACA,oDACA,kDACA,KACA,wDACA,gDACA,+CACA,6BACA,uBACA,sCACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,6BACA,gDACA,2BACA,0BACA,4BACA,4BACA,4BACA,4BACA,kDACA,iCACA,4BACA,iCACA,kDACA,uBACA,uCACA,IACA,8BACA,yBACA,mBACA,qBACA,oBACA,iEACA,mCACA,mCACA,mCACA,mCACA,mCACA,mCACA,mCACA,mCACA,mCACA,0EACA,0EACA,0EACA,+BACA,2DACA,4BACA,MACA,cACA,IACA,uCACA,4BACA,0BACA,2DACA,0EACA,8EACA,6EACA,6CACA,wCACA,mDACA,+CACA,IACA,uDACA,8DACA,wDACA,4DACA,kDACA,4DACA,gBACA,IACA,iCACA,4DACA,IACA,qBACA,kDACA,gFACA,gCACA,IACA,kGACA,iCACA,8CACA,8BACA,8BACA,mBACA,oBACA,8BACA,MACA,iFACA,gDACA,IACA,gBACA,8BACA,yDACA,mBACA,uBACA,yCACA,MACA,8BACA,+BACA,uBACA,2DACA,MACA,mCACA,sBACA,qBACA,6CACA,mDACA,qDACA,8BACA,aACA,mDACA,oDACA,6CACA,6BACA,6BACA,qCACA,yBACA,MACA,gCACA,4CACA,wFACA,wCACA,uDACA,wDACA,kCACA,0BACA,sBACA,iCACA,2CACA,aACA,2CACA,qBACA,uBACA,yCACA,uBACA,mCACA,qDACA,uCACA,yEACA,UACA,qBACA,QACA,yCACA,MACA,qBACA,0CACA,MACA,sBACA,yBACA,MACA,4BACA,0BACA,MACFD,KAAK,OAEY5B,EAAY8B,kBAC/B7B,UACI8B,OAAW5B,MAAO,GAClB6B,MAAU7B,MAAO,MAErBwB,cACI,6BACA,gBACA,4BACA,8BACA,kCACA,KACFC,KAAK,MACPC,gBACI,uBACA,sBACA,6BACA,gBACA,gEACA,+CACA,MACFD,KAAK,OAGX,OAAQ7B,EAAOkC,QAAQC,aAAelC","file":"../../shaders/BokehShader2.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var BokehShader = {\r\n        uniforms: {\r\n            'textureWidth': { value: 1 },\r\n            'textureHeight': { value: 1 },\r\n            'focalDepth': { value: 1 },\r\n            'focalLength': { value: 24 },\r\n            'fstop': { value: 0.9 },\r\n            'tColor': { value: null },\r\n            'tDepth': { value: null },\r\n            'maxblur': { value: 1 },\r\n            'showFocus': { value: 0 },\r\n            'manualdof': { value: 0 },\r\n            'vignetting': { value: 0 },\r\n            'depthblur': { value: 0 },\r\n            'threshold': { value: 0.5 },\r\n            'gain': { value: 2 },\r\n            'bias': { value: 0.5 },\r\n            'fringe': { value: 0.7 },\r\n            'znear': { value: 0.1 },\r\n            'zfar': { value: 100 },\r\n            'noise': { value: 1 },\r\n            'dithering': { value: 0.0001 },\r\n            'pentagon': { value: 0 },\r\n            'shaderFocus': { value: 1 },\r\n            'focusCoords': { value: new THREE.Vector2() }\r\n        },\r\n        vertexShader: [\r\n            'varying vec2 vUv;',\r\n            'void main() {',\r\n            '\\tvUv = uv;',\r\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            '#include <common>',\r\n            'varying vec2 vUv;',\r\n            'uniform sampler2D tColor;',\r\n            'uniform sampler2D tDepth;',\r\n            'uniform float textureWidth;',\r\n            'uniform float textureHeight;',\r\n            'uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below',\r\n            'uniform float focalLength; //focal length in mm',\r\n            'uniform float fstop; //f-stop value',\r\n            'uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)',\r\n            '/*',\r\n            'make sure that these two values are the same for your camera, otherwise distances will be wrong.',\r\n            '*/',\r\n            'uniform float znear; // camera clipping start',\r\n            'uniform float zfar; // camera clipping end',\r\n            '//------------------------------------------',\r\n            '//user variables',\r\n            'const int samples = SAMPLES; //samples on the first ring',\r\n            'const int rings = RINGS; //ring count',\r\n            'const int maxringsamples = rings * samples;',\r\n            'uniform bool manualdof; // manual dof calculation',\r\n            'float ndofstart = 1.0; // near dof blur start',\r\n            'float ndofdist = 2.0; // near dof blur falloff distance',\r\n            'float fdofstart = 1.0; // far dof blur start',\r\n            'float fdofdist = 3.0; // far dof blur falloff distance',\r\n            'float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)',\r\n            'uniform bool vignetting; // use optical lens vignetting',\r\n            'float vignout = 1.3; // vignetting outer border',\r\n            'float vignin = 0.0; // vignetting inner border',\r\n            'float vignfade = 22.0; // f-stops till vignete fades',\r\n            'uniform bool shaderFocus;',\r\n            '// disable if you use external focalDepth value',\r\n            'uniform vec2 focusCoords;',\r\n            '// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)',\r\n            '// if center of screen use vec2(0.5, 0.5);',\r\n            'uniform float maxblur;',\r\n            '//clamp value of max blur (0.0 = no blur, 1.0 default)',\r\n            'uniform float threshold; // highlight threshold;',\r\n            'uniform float gain; // highlight gain;',\r\n            'uniform float bias; // bokeh edge bias',\r\n            'uniform float fringe; // bokeh chromatic aberration / fringing',\r\n            'uniform bool noise; //use noise instead of pattern for sample dithering',\r\n            'uniform float dithering;',\r\n            'uniform bool depthblur; // blur the depth buffer',\r\n            'float dbsize = 1.25; // depth blur size',\r\n            '/*',\r\n            'next part is experimental',\r\n            'not looking good with small sample and ring count',\r\n            'looks okay starting from samples = 4, rings = 4',\r\n            '*/',\r\n            'uniform bool pentagon; //use pentagon as bokeh shape?',\r\n            'float feather = 0.4; //pentagon shape feather',\r\n            '//------------------------------------------',\r\n            'float penta(vec2 coords) {',\r\n            '\\t//pentagonal shape',\r\n            '\\tfloat scale = float(rings) - 1.3;',\r\n            '\\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);',\r\n            '\\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);',\r\n            '\\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);',\r\n            '\\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);',\r\n            '\\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);',\r\n            '\\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);',\r\n            '\\tvec4  one = vec4( 1.0 );',\r\n            '\\tvec4 P = vec4((coords),vec2(scale, scale));',\r\n            '\\tvec4 dist = vec4(0.0);',\r\n            '\\tfloat inorout = -4.0;',\r\n            '\\tdist.x = dot( P, HS0 );',\r\n            '\\tdist.y = dot( P, HS1 );',\r\n            '\\tdist.z = dot( P, HS2 );',\r\n            '\\tdist.w = dot( P, HS3 );',\r\n            '\\tdist = smoothstep( -feather, feather, dist );',\r\n            '\\tinorout += dot( dist, one );',\r\n            '\\tdist.x = dot( P, HS4 );',\r\n            '\\tdist.y = HS5.w - abs( P.z );',\r\n            '\\tdist = smoothstep( -feather, feather, dist );',\r\n            '\\tinorout += dist.x;',\r\n            '\\treturn clamp( inorout, 0.0, 1.0 );',\r\n            '}',\r\n            'float bdepth(vec2 coords) {',\r\n            '\\t// Depth buffer blur',\r\n            '\\tfloat d = 0.0;',\r\n            '\\tfloat kernel[9];',\r\n            '\\tvec2 offset[9];',\r\n            '\\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;',\r\n            '\\toffset[0] = vec2(-wh.x,-wh.y);',\r\n            '\\toffset[1] = vec2( 0.0, -wh.y);',\r\n            '\\toffset[2] = vec2( wh.x -wh.y);',\r\n            '\\toffset[3] = vec2(-wh.x,  0.0);',\r\n            '\\toffset[4] = vec2( 0.0,   0.0);',\r\n            '\\toffset[5] = vec2( wh.x,  0.0);',\r\n            '\\toffset[6] = vec2(-wh.x, wh.y);',\r\n            '\\toffset[7] = vec2( 0.0,  wh.y);',\r\n            '\\toffset[8] = vec2( wh.x, wh.y);',\r\n            '\\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;',\r\n            '\\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;',\r\n            '\\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;',\r\n            '\\tfor( int i=0; i<9; i++ ) {',\r\n            '\\t\\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;',\r\n            '\\t\\td += tmp * kernel[i];',\r\n            '\\t}',\r\n            '\\treturn d;',\r\n            '}',\r\n            'vec3 color(vec2 coords,float blur) {',\r\n            '\\t//processing the sample',\r\n            '\\tvec3 col = vec3(0.0);',\r\n            '\\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);',\r\n            '\\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;',\r\n            '\\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;',\r\n            '\\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;',\r\n            '\\tvec3 lumcoeff = vec3(0.299,0.587,0.114);',\r\n            '\\tfloat lum = dot(col.rgb, lumcoeff);',\r\n            '\\tfloat thresh = max((lum-threshold)*gain, 0.0);',\r\n            '\\treturn col+mix(vec3(0.0),col,thresh*blur);',\r\n            '}',\r\n            'vec3 debugFocus(vec3 col, float blur, float depth) {',\r\n            '\\tfloat edge = 0.002*depth; //distance based edge smoothing',\r\n            '\\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);',\r\n            '\\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);',\r\n            '\\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);',\r\n            '\\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);',\r\n            '\\treturn col;',\r\n            '}',\r\n            'float linearize(float depth) {',\r\n            '\\treturn -zfar * znear / (depth * (zfar - znear) - zfar);',\r\n            '}',\r\n            'float vignette() {',\r\n            '\\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));',\r\n            '\\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);',\r\n            '\\treturn clamp(dist,0.0,1.0);',\r\n            '}',\r\n            'float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {',\r\n            '\\tfloat rings2 = float(rings);',\r\n            '\\tfloat step = PI*2.0 / float(ringsamples);',\r\n            '\\tfloat pw = cos(j*step)*i;',\r\n            '\\tfloat ph = sin(j*step)*i;',\r\n            '\\tfloat p = 1.0;',\r\n            '\\tif (pentagon) {',\r\n            '\\t\\tp = penta(vec2(pw,ph));',\r\n            '\\t}',\r\n            '\\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;',\r\n            '\\treturn 1.0 * mix(1.0, i /rings2, bias) * p;',\r\n            '}',\r\n            'void main() {',\r\n            '\\t//scene depth calculation',\r\n            '\\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);',\r\n            '\\t// Blur depth?',\r\n            '\\tif ( depthblur ) {',\r\n            '\\t\\tdepth = linearize(bdepth(vUv.xy));',\r\n            '\\t}',\r\n            '\\t//focal plane calculation',\r\n            '\\tfloat fDepth = focalDepth;',\r\n            '\\tif (shaderFocus) {',\r\n            '\\t\\tfDepth = linearize(texture2D(tDepth,focusCoords).x);',\r\n            '\\t}',\r\n            '\\t// dof blur factor calculation',\r\n            '\\tfloat blur = 0.0;',\r\n            '\\tif (manualdof) {',\r\n            '\\t\\tfloat a = depth-fDepth; // Focal plane',\r\n            '\\t\\tfloat b = (a-fdofstart)/fdofdist; // Far DoF',\r\n            '\\t\\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof',\r\n            '\\t\\tblur = (a>0.0) ? b : c;',\r\n            '\\t} else {',\r\n            '\\t\\tfloat f = focalLength; // focal length in mm',\r\n            '\\t\\tfloat d = fDepth*1000.0; // focal plane in mm',\r\n            '\\t\\tfloat o = depth*1000.0; // depth in mm',\r\n            '\\t\\tfloat a = (o*f)/(o-f);',\r\n            '\\t\\tfloat b = (d*f)/(d-f);',\r\n            '\\t\\tfloat c = (d-f)/(d*fstop*CoC);',\r\n            '\\t\\tblur = abs(a-b)*c;',\r\n            '\\t}',\r\n            '\\tblur = clamp(blur,0.0,1.0);',\r\n            '\\t// calculation of pattern for dithering',\r\n            '\\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;',\r\n            '\\t// getting blur x and y step factor',\r\n            '\\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;',\r\n            '\\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;',\r\n            '\\t// calculation of final color',\r\n            '\\tvec3 col = vec3(0.0);',\r\n            '\\tif(blur < 0.05) {',\r\n            '\\t\\t//some optimization thingy',\r\n            '\\t\\tcol = texture2D(tColor, vUv.xy).rgb;',\r\n            '\\t} else {',\r\n            '\\t\\tcol = texture2D(tColor, vUv.xy).rgb;',\r\n            '\\t\\tfloat s = 1.0;',\r\n            '\\t\\tint ringsamples;',\r\n            '\\t\\tfor (int i = 1; i <= rings; i++) {',\r\n            '\\t\\t\\t/*unboxstart*/',\r\n            '\\t\\t\\tringsamples = i * samples;',\r\n            '\\t\\t\\tfor (int j = 0 ; j < maxringsamples ; j++) {',\r\n            '\\t\\t\\t\\tif (j >= ringsamples) break;',\r\n            '\\t\\t\\t\\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);',\r\n            '\\t\\t\\t}',\r\n            '\\t\\t\\t/*unboxend*/',\r\n            '\\t\\t}',\r\n            '\\t\\tcol /= s; //divide by sample count',\r\n            '\\t}',\r\n            '\\tif (showFocus) {',\r\n            '\\t\\tcol = debugFocus(col, blur, depth);',\r\n            '\\t}',\r\n            '\\tif (vignetting) {',\r\n            '\\t\\tcol *= vignette();',\r\n            '\\t}',\r\n            '\\tgl_FragColor.rgb = col;',\r\n            '\\tgl_FragColor.a = 1.0;',\r\n            '} '\r\n        ].join('\\n')\r\n    };\r\n    var BokehDepthShader = BokehShader.BokehDepthShader =  {\r\n        uniforms: {\r\n            'mNear': { value: 1 },\r\n            'mFar': { value: 1000 }\r\n        },\r\n        vertexShader: [\r\n            'varying float vViewZDepth;',\r\n            'void main() {',\r\n            '\\t#include <begin_vertex>',\r\n            '\\t#include <project_vertex>',\r\n            '\\tvViewZDepth = - mvPosition.z;',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            'uniform float mNear;',\r\n            'uniform float mFar;',\r\n            'varying float vViewZDepth;',\r\n            'void main() {',\r\n            '\\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );',\r\n            '\\tgl_FragColor = vec4( vec3( color ), 1.0 );',\r\n            '} '\r\n        ].join('\\n')\r\n    };\r\n\r\n    return  threex.shaders.BokehShader2 = BokehShader;\r\n});"]}