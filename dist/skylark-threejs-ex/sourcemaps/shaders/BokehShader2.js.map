{"version":3,"sources":["shaders/BokehShader2.js"],"names":["define","THREE","BokehShader","uniforms","textureWidth","value","textureHeight","focalDepth","focalLength","fstop","tColor","tDepth","maxblur","showFocus","manualdof","vignetting","depthblur","threshold","gain","bias","fringe","znear","zfar","noise","dithering","pentagon","shaderFocus","focusCoords","Vector2","vertexShader","join","fragmentShader","BokehDepthShader","mNear","mFar"],"mappings":";;;;;;;AAAAA,QACC,mBACC,SAASC,GAgZV,OAnYAA,EAAMC,aAELC,UAECC,cAAkBC,MAAO,GACzBC,eAAmBD,MAAO,GAE1BE,YAAgBF,MAAO,GACvBG,aAAiBH,MAAO,IACxBI,OAAWJ,MAAO,IAElBK,QAAYL,MAAO,MACnBM,QAAYN,MAAO,MAEnBO,SAAaP,MAAO,GAEpBQ,WAAeR,MAAO,GACtBS,WAAeT,MAAO,GACtBU,YAAgBV,MAAO,GACvBW,WAAeX,MAAO,GAEtBY,WAAeZ,MAAO,IACtBa,MAAUb,MAAO,GACjBc,MAAUd,MAAO,IACjBe,QAAYf,MAAO,IAEnBgB,OAAWhB,MAAO,IAClBiB,MAAUjB,MAAO,KAEjBkB,OAAWlB,MAAO,GAClBmB,WAAenB,MAAO,MACtBoB,UAAcpB,MAAO,GAErBqB,aAAiBrB,MAAO,GACxBsB,aAAiBtB,MAAO,IAAIJ,EAAM2B,UAKnCC,cAEC,oBAEA,gBAEA,cACA,8EAEA,KAECC,KAAM,MAERC,gBAEC,oBAEA,oBAEA,4BACA,4BACA,8BACA,+BAEA,sGACA,kDACA,sCACA,4GAEA,KACA,mGACA,KAEA,gDACA,6CAEA,+CACA,mBAEA,2DACA,wCAEA,8CAEA,oDACA,gDACA,0DACA,+CACA,yDAEA,0EAEA,0DAEA,kDACA,iDACA,uDAEA,4BACA,kDAEA,4BACA,oFACA,6CAEA,yBACA,yDAEA,mDACA,yCAEA,yCACA,iEAEA,0EAEA,2BAEA,mDACA,0CAEA,KACA,4BACA,oDACA,kDACA,KAEA,wDACA,gDAEA,+CAEA,6BACA,uBACA,sCACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DAEA,6BAEA,gDAEA,2BACA,0BAEA,4BACA,4BACA,4BACA,4BAEA,kDAEA,iCAEA,4BACA,iCAEA,kDACA,uBAEA,uCACA,IAEA,8BACA,yBACA,mBACA,qBACA,oBAEA,iEAEA,mCACA,mCACA,mCAEA,mCACA,mCACA,mCAEA,mCACA,mCACA,mCAEA,0EACA,0EACA,0EAGA,+BACA,2DACA,4BACA,MAEA,cACA,IAGA,uCACA,4BAEA,0BACA,2DAEA,0EACA,8EACA,6EAEA,6CACA,wCACA,mDACA,+CACA,IAEA,uDACA,8DACA,wDACA,4DAEA,kDACA,4DAEA,gBACA,IAEA,iCACA,4DACA,IAGA,qBACA,kDACA,gFACA,gCACA,IAEA,kGACA,iCACA,8CACA,8BACA,8BACA,mBACA,oBACA,8BACA,MACA,iFACA,gDACA,IAEA,gBACA,8BAEA,yDAEA,mBACA,uBACA,yCACA,MAEA,8BAEA,+BAEA,uBAEA,2DAEA,MAEA,mCAEA,sBAEA,qBACA,6CACA,mDACA,qDACA,8BACA,aACA,mDACA,oDACA,6CAEA,6BACA,6BACA,qCAEA,yBACA,MAEA,gCAEA,4CAEA,wFAEA,wCAEA,uDACA,wDAEA,kCAEA,0BAEA,sBACA,iCACA,2CACA,aACA,2CACA,qBACA,uBAEA,yCACA,uBACA,mCAEA,qDACA,uCACA,yEACA,UACA,qBACA,QAEA,yCACA,MAEA,qBACA,0CACA,MAEA,sBACA,yBACA,MAEA,4BACA,0BACA,MAECD,KAAM,OAIT7B,EAAM+B,kBAEL7B,UAEC8B,OAAW5B,MAAO,GAClB6B,MAAU7B,MAAO,MAIlBwB,cAEC,6BAEA,gBAEA,4BACA,8BAEA,kCAEA,KAECC,KAAM,MAERC,gBAEC,uBACA,sBAEA,6BAEA,gBAEA,gEACA,+CAEA,MAECD,KAAM,OAIF7B,EAAMC","file":"../../shaders/BokehShader2.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author zz85 / https://github.com/zz85 | twitter.com/blurspline\n\t *\n\t * Depth-of-field shader with bokeh\n\t * ported from GLSL shader by Martins Upitis\n\t * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n\t *\n\t * Requires #define RINGS and SAMPLES integers\n\t */\n\n\n\n\tTHREE.BokehShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"textureWidth\": { value: 1.0 },\n\t\t\t\"textureHeight\": { value: 1.0 },\n\n\t\t\t\"focalDepth\": { value: 1.0 },\n\t\t\t\"focalLength\": { value: 24.0 },\n\t\t\t\"fstop\": { value: 0.9 },\n\n\t\t\t\"tColor\": { value: null },\n\t\t\t\"tDepth\": { value: null },\n\n\t\t\t\"maxblur\": { value: 1.0 },\n\n\t\t\t\"showFocus\": { value: 0 },\n\t\t\t\"manualdof\": { value: 0 },\n\t\t\t\"vignetting\": { value: 0 },\n\t\t\t\"depthblur\": { value: 0 },\n\n\t\t\t\"threshold\": { value: 0.5 },\n\t\t\t\"gain\": { value: 2.0 },\n\t\t\t\"bias\": { value: 0.5 },\n\t\t\t\"fringe\": { value: 0.7 },\n\n\t\t\t\"znear\": { value: 0.1 },\n\t\t\t\"zfar\": { value: 100 },\n\n\t\t\t\"noise\": { value: 1 },\n\t\t\t\"dithering\": { value: 0.0001 },\n\t\t\t\"pentagon\": { value: 0 },\n\n\t\t\t\"shaderFocus\": { value: 1 },\n\t\t\t\"focusCoords\": { value: new THREE.Vector2() }\n\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"#include <common>\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform sampler2D tColor;\",\n\t\t\t\"uniform sampler2D tDepth;\",\n\t\t\t\"uniform float textureWidth;\",\n\t\t\t\"uniform float textureHeight;\",\n\n\t\t\t\"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\",\n\t\t\t\"uniform float focalLength; //focal length in mm\",\n\t\t\t\"uniform float fstop; //f-stop value\",\n\t\t\t\"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\",\n\n\t\t\t\"/*\",\n\t\t\t\"make sure that these two values are the same for your camera, otherwise distances will be wrong.\",\n\t\t\t\"*/\",\n\n\t\t\t\"uniform float znear; // camera clipping start\",\n\t\t\t\"uniform float zfar; // camera clipping end\",\n\n\t\t\t\"//------------------------------------------\",\n\t\t\t\"//user variables\",\n\n\t\t\t\"const int samples = SAMPLES; //samples on the first ring\",\n\t\t\t\"const int rings = RINGS; //ring count\",\n\n\t\t\t\"const int maxringsamples = rings * samples;\",\n\n\t\t\t\"uniform bool manualdof; // manual dof calculation\",\n\t\t\t\"float ndofstart = 1.0; // near dof blur start\",\n\t\t\t\"float ndofdist = 2.0; // near dof blur falloff distance\",\n\t\t\t\"float fdofstart = 1.0; // far dof blur start\",\n\t\t\t\"float fdofdist = 3.0; // far dof blur falloff distance\",\n\n\t\t\t\"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\",\n\n\t\t\t\"uniform bool vignetting; // use optical lens vignetting\",\n\n\t\t\t\"float vignout = 1.3; // vignetting outer border\",\n\t\t\t\"float vignin = 0.0; // vignetting inner border\",\n\t\t\t\"float vignfade = 22.0; // f-stops till vignete fades\",\n\n\t\t\t\"uniform bool shaderFocus;\",\n\t\t\t\"// disable if you use external focalDepth value\",\n\n\t\t\t\"uniform vec2 focusCoords;\",\n\t\t\t\"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\",\n\t\t\t\"// if center of screen use vec2(0.5, 0.5);\",\n\n\t\t\t\"uniform float maxblur;\",\n\t\t\t\"//clamp value of max blur (0.0 = no blur, 1.0 default)\",\n\n\t\t\t\"uniform float threshold; // highlight threshold;\",\n\t\t\t\"uniform float gain; // highlight gain;\",\n\n\t\t\t\"uniform float bias; // bokeh edge bias\",\n\t\t\t\"uniform float fringe; // bokeh chromatic aberration / fringing\",\n\n\t\t\t\"uniform bool noise; //use noise instead of pattern for sample dithering\",\n\n\t\t\t\"uniform float dithering;\",\n\n\t\t\t\"uniform bool depthblur; // blur the depth buffer\",\n\t\t\t\"float dbsize = 1.25; // depth blur size\",\n\n\t\t\t\"/*\",\n\t\t\t\"next part is experimental\",\n\t\t\t\"not looking good with small sample and ring count\",\n\t\t\t\"looks okay starting from samples = 4, rings = 4\",\n\t\t\t\"*/\",\n\n\t\t\t\"uniform bool pentagon; //use pentagon as bokeh shape?\",\n\t\t\t\"float feather = 0.4; //pentagon shape feather\",\n\n\t\t\t\"//------------------------------------------\",\n\n\t\t\t\"float penta(vec2 coords) {\",\n\t\t\t\"\t//pentagonal shape\",\n\t\t\t\"\tfloat scale = float(rings) - 1.3;\",\n\t\t\t\"\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\",\n\t\t\t\"\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\",\n\t\t\t\"\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\",\n\t\t\t\"\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\",\n\t\t\t\"\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\",\n\t\t\t\"\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\",\n\n\t\t\t\"\tvec4  one = vec4( 1.0 );\",\n\n\t\t\t\"\tvec4 P = vec4((coords),vec2(scale, scale));\",\n\n\t\t\t\"\tvec4 dist = vec4(0.0);\",\n\t\t\t\"\tfloat inorout = -4.0;\",\n\n\t\t\t\"\tdist.x = dot( P, HS0 );\",\n\t\t\t\"\tdist.y = dot( P, HS1 );\",\n\t\t\t\"\tdist.z = dot( P, HS2 );\",\n\t\t\t\"\tdist.w = dot( P, HS3 );\",\n\n\t\t\t\"\tdist = smoothstep( -feather, feather, dist );\",\n\n\t\t\t\"\tinorout += dot( dist, one );\",\n\n\t\t\t\"\tdist.x = dot( P, HS4 );\",\n\t\t\t\"\tdist.y = HS5.w - abs( P.z );\",\n\n\t\t\t\"\tdist = smoothstep( -feather, feather, dist );\",\n\t\t\t\"\tinorout += dist.x;\",\n\n\t\t\t\"\treturn clamp( inorout, 0.0, 1.0 );\",\n\t\t\t\"}\",\n\n\t\t\t\"float bdepth(vec2 coords) {\",\n\t\t\t\"\t// Depth buffer blur\",\n\t\t\t\"\tfloat d = 0.0;\",\n\t\t\t\"\tfloat kernel[9];\",\n\t\t\t\"\tvec2 offset[9];\",\n\n\t\t\t\"\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\",\n\n\t\t\t\"\toffset[0] = vec2(-wh.x,-wh.y);\",\n\t\t\t\"\toffset[1] = vec2( 0.0, -wh.y);\",\n\t\t\t\"\toffset[2] = vec2( wh.x -wh.y);\",\n\n\t\t\t\"\toffset[3] = vec2(-wh.x,  0.0);\",\n\t\t\t\"\toffset[4] = vec2( 0.0,   0.0);\",\n\t\t\t\"\toffset[5] = vec2( wh.x,  0.0);\",\n\n\t\t\t\"\toffset[6] = vec2(-wh.x, wh.y);\",\n\t\t\t\"\toffset[7] = vec2( 0.0,  wh.y);\",\n\t\t\t\"\toffset[8] = vec2( wh.x, wh.y);\",\n\n\t\t\t\"\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\",\n\t\t\t\"\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\",\n\t\t\t\"\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\",\n\n\n\t\t\t\"\tfor( int i=0; i<9; i++ ) {\",\n\t\t\t\"\t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;\",\n\t\t\t\"\t\td += tmp * kernel[i];\",\n\t\t\t\"\t}\",\n\n\t\t\t\"\treturn d;\",\n\t\t\t\"}\",\n\n\n\t\t\t\"vec3 color(vec2 coords,float blur) {\",\n\t\t\t\"\t//processing the sample\",\n\n\t\t\t\"\tvec3 col = vec3(0.0);\",\n\t\t\t\"\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);\",\n\n\t\t\t\"\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\",\n\t\t\t\"\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\",\n\t\t\t\"\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\",\n\n\t\t\t\"\tvec3 lumcoeff = vec3(0.299,0.587,0.114);\",\n\t\t\t\"\tfloat lum = dot(col.rgb, lumcoeff);\",\n\t\t\t\"\tfloat thresh = max((lum-threshold)*gain, 0.0);\",\n\t\t\t\"\treturn col+mix(vec3(0.0),col,thresh*blur);\",\n\t\t\t\"}\",\n\n\t\t\t\"vec3 debugFocus(vec3 col, float blur, float depth) {\",\n\t\t\t\"\tfloat edge = 0.002*depth; //distance based edge smoothing\",\n\t\t\t\"\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\",\n\t\t\t\"\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\",\n\n\t\t\t\"\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\",\n\t\t\t\"\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\",\n\n\t\t\t\"\treturn col;\",\n\t\t\t\"}\",\n\n\t\t\t\"float linearize(float depth) {\",\n\t\t\t\"\treturn -zfar * znear / (depth * (zfar - znear) - zfar);\",\n\t\t\t\"}\",\n\n\n\t\t\t\"float vignette() {\",\n\t\t\t\"\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));\",\n\t\t\t\"\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\",\n\t\t\t\"\treturn clamp(dist,0.0,1.0);\",\n\t\t\t\"}\",\n\n\t\t\t\"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\",\n\t\t\t\"\tfloat rings2 = float(rings);\",\n\t\t\t\"\tfloat step = PI*2.0 / float(ringsamples);\",\n\t\t\t\"\tfloat pw = cos(j*step)*i;\",\n\t\t\t\"\tfloat ph = sin(j*step)*i;\",\n\t\t\t\"\tfloat p = 1.0;\",\n\t\t\t\"\tif (pentagon) {\",\n\t\t\t\"\t\tp = penta(vec2(pw,ph));\",\n\t\t\t\"\t}\",\n\t\t\t\"\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\",\n\t\t\t\"\treturn 1.0 * mix(1.0, i /rings2, bias) * p;\",\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\t\t\t\"\t//scene depth calculation\",\n\n\t\t\t\"\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);\",\n\n\t\t\t\"\t// Blur depth?\",\n\t\t\t\"\tif ( depthblur ) {\",\n\t\t\t\"\t\tdepth = linearize(bdepth(vUv.xy));\",\n\t\t\t\"\t}\",\n\n\t\t\t\"\t//focal plane calculation\",\n\n\t\t\t\"\tfloat fDepth = focalDepth;\",\n\n\t\t\t\"\tif (shaderFocus) {\",\n\n\t\t\t\"\t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"\t// dof blur factor calculation\",\n\n\t\t\t\"\tfloat blur = 0.0;\",\n\n\t\t\t\"\tif (manualdof) {\",\n\t\t\t\"\t\tfloat a = depth-fDepth; // Focal plane\",\n\t\t\t\"\t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF\",\n\t\t\t\"\t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof\",\n\t\t\t\"\t\tblur = (a>0.0) ? b : c;\",\n\t\t\t\"\t} else {\",\n\t\t\t\"\t\tfloat f = focalLength; // focal length in mm\",\n\t\t\t\"\t\tfloat d = fDepth*1000.0; // focal plane in mm\",\n\t\t\t\"\t\tfloat o = depth*1000.0; // depth in mm\",\n\n\t\t\t\"\t\tfloat a = (o*f)/(o-f);\",\n\t\t\t\"\t\tfloat b = (d*f)/(d-f);\",\n\t\t\t\"\t\tfloat c = (d-f)/(d*fstop*CoC);\",\n\n\t\t\t\"\t\tblur = abs(a-b)*c;\",\n\t\t\t\"\t}\",\n\n\t\t\t\"\tblur = clamp(blur,0.0,1.0);\",\n\n\t\t\t\"\t// calculation of pattern for dithering\",\n\n\t\t\t\"\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;\",\n\n\t\t\t\"\t// getting blur x and y step factor\",\n\n\t\t\t\"\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;\",\n\t\t\t\"\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;\",\n\n\t\t\t\"\t// calculation of final color\",\n\n\t\t\t\"\tvec3 col = vec3(0.0);\",\n\n\t\t\t\"\tif(blur < 0.05) {\",\n\t\t\t\"\t\t//some optimization thingy\",\n\t\t\t\"\t\tcol = texture2D(tColor, vUv.xy).rgb;\",\n\t\t\t\"\t} else {\",\n\t\t\t\"\t\tcol = texture2D(tColor, vUv.xy).rgb;\",\n\t\t\t\"\t\tfloat s = 1.0;\",\n\t\t\t\"\t\tint ringsamples;\",\n\n\t\t\t\"\t\tfor (int i = 1; i <= rings; i++) {\",\n\t\t\t\"\t\t\t/*unboxstart*/\",\n\t\t\t\"\t\t\tringsamples = i * samples;\",\n\n\t\t\t\"\t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {\",\n\t\t\t\"\t\t\t\tif (j >= ringsamples) break;\",\n\t\t\t\"\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);\",\n\t\t\t\"\t\t\t}\",\n\t\t\t\"\t\t\t/*unboxend*/\",\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t\tcol /= s; //divide by sample count\",\n\t\t\t\"\t}\",\n\n\t\t\t\"\tif (showFocus) {\",\n\t\t\t\"\t\tcol = debugFocus(col, blur, depth);\",\n\t\t\t\"\t}\",\n\n\t\t\t\"\tif (vignetting) {\",\n\t\t\t\"\t\tcol *= vignette();\",\n\t\t\t\"\t}\",\n\n\t\t\t\"\tgl_FragColor.rgb = col;\",\n\t\t\t\"\tgl_FragColor.a = 1.0;\",\n\t\t\t\"} \"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\n\tTHREE.BokehDepthShader = {\n\n\t\tuniforms: {\n\n\t\t\t\"mNear\": { value: 1.0 },\n\t\t\t\"mFar\": { value: 1000.0 },\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying float vViewZDepth;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\t#include <begin_vertex>\",\n\t\t\t\"\t#include <project_vertex>\",\n\n\t\t\t\"\tvViewZDepth = - mvPosition.z;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float mNear;\",\n\t\t\t\"uniform float mFar;\",\n\n\t\t\t\"varying float vViewZDepth;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );\",\n\t\t\t\"\tgl_FragColor = vec4( vec3( color ), 1.0 );\",\n\n\t\t\t\"} \"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.BokehShader;\n});\n"]}