{"version":3,"sources":["shaders/ParallaxShader.js"],"names":["define","THREE","ParallaxShader","modes","none","basic","steep","occlusion","relief","uniforms","bumpMap","value","map","parallaxScale","parallaxMinLayers","parallaxMaxLayers","vertexShader","join","fragmentShader"],"mappings":";;;;;;;AAAAA,QACC,mBACC,SAASC,GA0LV,OApLAA,EAAMC,gBAELC,OACCC,KAAM,cACNC,MAAO,qBACPC,MAAO,qBACPC,UAAW,wBACXC,OAAQ,uBAGTC,UACCC,SAAaC,MAAO,MACpBC,KAASD,MAAO,MAChBE,eAAmBF,MAAO,MAC1BG,mBAAuBH,MAAO,MAC9BI,mBAAuBJ,MAAO,OAG/BK,cACC,oBACA,8BACA,wBAEA,gBAEA,cACA,+DACA,qCACA,kDACA,iDAEA,KAECC,KAAM,MAERC,gBACC,6BACA,yBAEA,+BACA,mCACA,mCAEA,oBACA,8BACA,wBAEA,4BAEA,oCAEA,yDAMA,kEACA,mCAEA,MAEA,QAEA,oCAGA,6GAEA,2CACA,sCAEA,0DAEA,uCAEA,8EAKA,0CACA,yDACA,iBACA,UACA,2CAEA,sCACA,0EACA,QAEA,gCAEA,qCAEA,2CAEA,yCACA,+CAGA,+CACA,2CAGA,mCACA,qDAEA,gCACA,8BACA,4EAEA,yDAEA,mDACA,+CAEA,mBAEA,mDACA,+CAEA,YAEA,UACA,qCAEA,6CAEA,wDAGA,8DACA,8FAGA,kDAGA,+EAEA,YAEA,oBAEA,aAEA,MACA,SAEA,4EAEC,8BACD,8BAEA,yCACA,yCACA,6CACA,6CACA,sCAEA,kGACA,oBACA,8DACA,mDAEA,qCACA,IAEA,gBAEA,gGACA,4CAEA,KAECD,KAAM,OAIFhB,EAAMC","file":"../../shaders/ParallaxShader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t// Parallax Occlusion shaders from\n\t//    http://sunandblackcat.com/tipFullView.php?topicid=28\n\t// No tangent-space transforms logic based on\n\t//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\n\n\tTHREE.ParallaxShader = {\n\t\t// Ordered from fastest to best quality.\n\t\tmodes: {\n\t\t\tnone: \"NO_PARALLAX\",\n\t\t\tbasic: \"USE_BASIC_PARALLAX\",\n\t\t\tsteep: \"USE_STEEP_PARALLAX\",\n\t\t\tocclusion: \"USE_OCLUSION_PARALLAX\", // a.k.a. POM\n\t\t\trelief: \"USE_RELIEF_PARALLAX\"\n\t\t},\n\n\t\tuniforms: {\n\t\t\t\"bumpMap\": { value: null },\n\t\t\t\"map\": { value: null },\n\t\t\t\"parallaxScale\": { value: null },\n\t\t\t\"parallaxMinLayers\": { value: null },\n\t\t\t\"parallaxMaxLayers\": { value: null }\n\t\t},\n\n\t\tvertexShader: [\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"varying vec3 vViewPosition;\",\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = uv;\",\n\t\t\t\"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\"\tvViewPosition = -mvPosition.xyz;\",\n\t\t\t\"\tvNormal = normalize( normalMatrix * normal );\",\n\t\t\t\"\tgl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\t\t\t\"uniform sampler2D bumpMap;\",\n\t\t\t\"uniform sampler2D map;\",\n\n\t\t\t\"uniform float parallaxScale;\",\n\t\t\t\"uniform float parallaxMinLayers;\",\n\t\t\t\"uniform float parallaxMaxLayers;\",\n\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"varying vec3 vViewPosition;\",\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\t\"#ifdef USE_BASIC_PARALLAX\",\n\n\t\t\t\"\tvec2 parallaxMap( in vec3 V ) {\",\n\n\t\t\t\"\t\tfloat initialHeight = texture2D( bumpMap, vUv ).r;\",\n\n\t\t\t// No Offset Limitting: messy, floating output at grazing angles.\n\t\t\t//\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\n\n\t\t\t// Offset Limiting\n\t\t\t\"\t\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;\",\n\t\t\t\"\t\treturn vUv - texCoordOffset;\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"#else\",\n\n\t\t\t\"\tvec2 parallaxMap( in vec3 V ) {\",\n\n\t\t\t// Determine number of layers from angle between V and N\n\t\t\t\"\t\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );\",\n\n\t\t\t\"\t\tfloat layerHeight = 1.0 / numLayers;\",\n\t\t\t\"\t\tfloat currentLayerHeight = 0.0;\",\n\t\t\t// Shift of texture coordinates for each iteration\n\t\t\t\"\t\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;\",\n\n\t\t\t\"\t\tvec2 currentTextureCoords = vUv;\",\n\n\t\t\t\"\t\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n\n\t\t\t// while ( heightFromTexture > currentLayerHeight )\n\t\t\t// Infinite loops are not well supported. Do a \"large\" finite\n\t\t\t// loop, but not too large, as it slows down some compilers.\n\t\t\t\"\t\tfor ( int i = 0; i < 30; i += 1 ) {\",\n\t\t\t\"\t\t\tif ( heightFromTexture <= currentLayerHeight ) {\",\n\t\t\t\"\t\t\t\tbreak;\",\n\t\t\t\"\t\t\t}\",\n\t\t\t\"\t\t\tcurrentLayerHeight += layerHeight;\",\n\t\t\t// Shift texture coordinates along vector V\n\t\t\t\"\t\t\tcurrentTextureCoords -= dtex;\",\n\t\t\t\"\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n\t\t\t\"\t\t}\",\n\n\t\t\t\"\t\t#ifdef USE_STEEP_PARALLAX\",\n\n\t\t\t\"\t\t\treturn currentTextureCoords;\",\n\n\t\t\t\"\t\t#elif defined( USE_RELIEF_PARALLAX )\",\n\n\t\t\t\"\t\t\tvec2 deltaTexCoord = dtex / 2.0;\",\n\t\t\t\"\t\t\tfloat deltaHeight = layerHeight / 2.0;\",\n\n\t\t\t// Return to the mid point of previous layer\n\t\t\t\"\t\t\tcurrentTextureCoords += deltaTexCoord;\",\n\t\t\t\"\t\t\tcurrentLayerHeight -= deltaHeight;\",\n\n\t\t\t// Binary search to increase precision of Steep Parallax Mapping\n\t\t\t\"\t\t\tconst int numSearches = 5;\",\n\t\t\t\"\t\t\tfor ( int i = 0; i < numSearches; i += 1 ) {\",\n\n\t\t\t\"\t\t\t\tdeltaTexCoord /= 2.0;\",\n\t\t\t\"\t\t\t\tdeltaHeight /= 2.0;\",\n\t\t\t\"\t\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n\t\t\t// Shift along or against vector V\n\t\t\t\"\t\t\t\tif( heightFromTexture > currentLayerHeight ) {\", // Below the surface\n\n\t\t\t\"\t\t\t\t\tcurrentTextureCoords -= deltaTexCoord;\",\n\t\t\t\"\t\t\t\t\tcurrentLayerHeight += deltaHeight;\",\n\n\t\t\t\"\t\t\t\t} else {\", // above the surface\n\n\t\t\t\"\t\t\t\t\tcurrentTextureCoords += deltaTexCoord;\",\n\t\t\t\"\t\t\t\t\tcurrentLayerHeight -= deltaHeight;\",\n\n\t\t\t\"\t\t\t\t}\",\n\n\t\t\t\"\t\t\t}\",\n\t\t\t\"\t\t\treturn currentTextureCoords;\",\n\n\t\t\t\"\t\t#elif defined( USE_OCLUSION_PARALLAX )\",\n\n\t\t\t\"\t\t\tvec2 prevTCoords = currentTextureCoords + dtex;\",\n\n\t\t\t// Heights for linear interpolation\n\t\t\t\"\t\t\tfloat nextH = heightFromTexture - currentLayerHeight;\",\n\t\t\t\"\t\t\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;\",\n\n\t\t\t// Proportions for linear interpolation\n\t\t\t\"\t\t\tfloat weight = nextH / ( nextH - prevH );\",\n\n\t\t\t// Interpolation of texture coordinates\n\t\t\t\"\t\t\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );\",\n\n\t\t\t\"\t\t#else\", // NO_PARALLAX\n\n\t\t\t\"\t\t\treturn vUv;\",\n\n\t\t\t\"\t\t#endif\",\n\n\t\t\t\"\t}\",\n\t\t\t\"#endif\",\n\n\t\t\t\"vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {\",\n\n\t \t\t\"\tvec2 texDx = dFdx( vUv );\",\n\t\t\t\"\tvec2 texDy = dFdy( vUv );\",\n\n\t\t\t\"\tvec3 vSigmaX = dFdx( surfPosition );\",\n\t\t\t\"\tvec3 vSigmaY = dFdy( surfPosition );\",\n\t\t\t\"\tvec3 vR1 = cross( vSigmaY, surfNormal );\",\n\t\t\t\"\tvec3 vR2 = cross( surfNormal, vSigmaX );\",\n\t\t\t\"\tfloat fDet = dot( vSigmaX, vR1 );\",\n\n\t\t\t\"\tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );\",\n\t\t\t\"\tvec3 vProjVtex;\",\n\t\t\t\"\tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;\",\n\t\t\t\"\tvProjVtex.z = dot( surfNormal, viewPosition );\",\n\n\t\t\t\"\treturn parallaxMap( vProjVtex );\",\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );\",\n\t\t\t\"\tgl_FragColor = texture2D( map, mapUv );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t};\n\t\n\treturn THREE.ParallaxShader;\n});"]}