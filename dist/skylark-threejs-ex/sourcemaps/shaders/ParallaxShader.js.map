{"version":3,"sources":["shaders/ParallaxShader.js"],"names":["define","threex","ParallaxShader","modes","none","basic","steep","occlusion","relief","uniforms","bumpMap","value","map","parallaxScale","parallaxMinLayers","parallaxMaxLayers","vertexShader","join","fragmentShader","shaders"],"mappings":";;;;;;;AAAAA,QACI,aACF,SAAUC,GACR,aACA,IAAIC,GACAC,OACIC,KAAM,cACNC,MAAO,qBACPC,MAAO,qBACPC,UAAW,wBACXC,OAAQ,uBAEZC,UACIC,SAAaC,MAAO,MACpBC,KAASD,MAAO,MAChBE,eAAmBF,MAAO,MAC1BG,mBAAuBH,MAAO,MAC9BI,mBAAuBJ,MAAO,OAElCK,cACI,oBACA,8BACA,wBACA,gBACA,cACA,+DACA,qCACA,kDACA,iDACA,KACFC,KAAK,MACPC,gBACI,6BACA,yBACA,+BACA,mCACA,mCACA,oBACA,8BACA,wBACA,4BACA,oCACA,yDACA,kEACA,mCACA,MACA,QACA,oCACA,6GACA,2CACA,sCACA,0DACA,uCACA,8EACA,0CACA,yDACA,iBACA,UACA,2CACA,sCACA,0EACA,QACA,gCACA,qCACA,2CACA,yCACA,+CACA,+CACA,2CACA,mCACA,qDACA,gCACA,8BACA,4EACA,yDACA,mDACA,+CACA,mBACA,mDACA,+CACA,YACA,UACA,qCACA,6CACA,wDACA,8DACA,8FACA,kDACA,+EACA,YACA,oBACA,aACA,MACA,SACA,4EACA,8BACA,8BACA,yCACA,yCACA,6CACA,6CACA,sCACA,kGACA,oBACA,8DACA,mDACA,qCACA,IACA,gBACA,gGACA,4CACA,KACFD,KAAK,OAEX,OAAOhB,EAAOkB,QAAQjB,eAAiBA","file":"../../shaders/ParallaxShader.js","sourcesContent":["define([\n    \"../threex\"\n],function (threex) {\n    'use strict';\n    var ParallaxShader = {\n        modes: {\n            none: 'NO_PARALLAX',\n            basic: 'USE_BASIC_PARALLAX',\n            steep: 'USE_STEEP_PARALLAX',\n            occlusion: 'USE_OCLUSION_PARALLAX',\n            relief: 'USE_RELIEF_PARALLAX'\n        },\n        uniforms: {\n            'bumpMap': { value: null },\n            'map': { value: null },\n            'parallaxScale': { value: null },\n            'parallaxMinLayers': { value: null },\n            'parallaxMaxLayers': { value: null }\n        },\n        vertexShader: [\n            'varying vec2 vUv;',\n            'varying vec3 vViewPosition;',\n            'varying vec3 vNormal;',\n            'void main() {',\n            '\\tvUv = uv;',\n            '\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\n            '\\tvViewPosition = -mvPosition.xyz;',\n            '\\tvNormal = normalize( normalMatrix * normal );',\n            '\\tgl_Position = projectionMatrix * mvPosition;',\n            '}'\n        ].join('\\n'),\n        fragmentShader: [\n            'uniform sampler2D bumpMap;',\n            'uniform sampler2D map;',\n            'uniform float parallaxScale;',\n            'uniform float parallaxMinLayers;',\n            'uniform float parallaxMaxLayers;',\n            'varying vec2 vUv;',\n            'varying vec3 vViewPosition;',\n            'varying vec3 vNormal;',\n            '#ifdef USE_BASIC_PARALLAX',\n            '\\tvec2 parallaxMap( in vec3 V ) {',\n            '\\t\\tfloat initialHeight = texture2D( bumpMap, vUv ).r;',\n            '\\t\\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;',\n            '\\t\\treturn vUv - texCoordOffset;',\n            '\\t}',\n            '#else',\n            '\\tvec2 parallaxMap( in vec3 V ) {',\n            '\\t\\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );',\n            '\\t\\tfloat layerHeight = 1.0 / numLayers;',\n            '\\t\\tfloat currentLayerHeight = 0.0;',\n            '\\t\\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;',\n            '\\t\\tvec2 currentTextureCoords = vUv;',\n            '\\t\\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;',\n            '\\t\\tfor ( int i = 0; i < 30; i += 1 ) {',\n            '\\t\\t\\tif ( heightFromTexture <= currentLayerHeight ) {',\n            '\\t\\t\\t\\tbreak;',\n            '\\t\\t\\t}',\n            '\\t\\t\\tcurrentLayerHeight += layerHeight;',\n            '\\t\\t\\tcurrentTextureCoords -= dtex;',\n            '\\t\\t\\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;',\n            '\\t\\t}',\n            '\\t\\t#ifdef USE_STEEP_PARALLAX',\n            '\\t\\t\\treturn currentTextureCoords;',\n            '\\t\\t#elif defined( USE_RELIEF_PARALLAX )',\n            '\\t\\t\\tvec2 deltaTexCoord = dtex / 2.0;',\n            '\\t\\t\\tfloat deltaHeight = layerHeight / 2.0;',\n            '\\t\\t\\tcurrentTextureCoords += deltaTexCoord;',\n            '\\t\\t\\tcurrentLayerHeight -= deltaHeight;',\n            '\\t\\t\\tconst int numSearches = 5;',\n            '\\t\\t\\tfor ( int i = 0; i < numSearches; i += 1 ) {',\n            '\\t\\t\\t\\tdeltaTexCoord /= 2.0;',\n            '\\t\\t\\t\\tdeltaHeight /= 2.0;',\n            '\\t\\t\\t\\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;',\n            '\\t\\t\\t\\tif( heightFromTexture > currentLayerHeight ) {',\n            '\\t\\t\\t\\t\\tcurrentTextureCoords -= deltaTexCoord;',\n            '\\t\\t\\t\\t\\tcurrentLayerHeight += deltaHeight;',\n            '\\t\\t\\t\\t} else {',\n            '\\t\\t\\t\\t\\tcurrentTextureCoords += deltaTexCoord;',\n            '\\t\\t\\t\\t\\tcurrentLayerHeight -= deltaHeight;',\n            '\\t\\t\\t\\t}',\n            '\\t\\t\\t}',\n            '\\t\\t\\treturn currentTextureCoords;',\n            '\\t\\t#elif defined( USE_OCLUSION_PARALLAX )',\n            '\\t\\t\\tvec2 prevTCoords = currentTextureCoords + dtex;',\n            '\\t\\t\\tfloat nextH = heightFromTexture - currentLayerHeight;',\n            '\\t\\t\\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;',\n            '\\t\\t\\tfloat weight = nextH / ( nextH - prevH );',\n            '\\t\\t\\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );',\n            '\\t\\t#else',\n            '\\t\\t\\treturn vUv;',\n            '\\t\\t#endif',\n            '\\t}',\n            '#endif',\n            'vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {',\n            '\\tvec2 texDx = dFdx( vUv );',\n            '\\tvec2 texDy = dFdy( vUv );',\n            '\\tvec3 vSigmaX = dFdx( surfPosition );',\n            '\\tvec3 vSigmaY = dFdy( surfPosition );',\n            '\\tvec3 vR1 = cross( vSigmaY, surfNormal );',\n            '\\tvec3 vR2 = cross( surfNormal, vSigmaX );',\n            '\\tfloat fDet = dot( vSigmaX, vR1 );',\n            '\\tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );',\n            '\\tvec3 vProjVtex;',\n            '\\tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;',\n            '\\tvProjVtex.z = dot( surfNormal, viewPosition );',\n            '\\treturn parallaxMap( vProjVtex );',\n            '}',\n            'void main() {',\n            '\\tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );',\n            '\\tgl_FragColor = texture2D( map, mapUv );',\n            '}'\n        ].join('\\n')\n    };\n    return threex.shaders.ParallaxShader = ParallaxShader;\n});"]}