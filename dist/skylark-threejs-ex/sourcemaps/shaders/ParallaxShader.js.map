{"version":3,"sources":["shaders/ParallaxShader.js"],"names":["define","threex","ParallaxShader","modes","none","basic","steep","occlusion","relief","uniforms","bumpMap","value","map","parallaxScale","parallaxMinLayers","parallaxMaxLayers","vertexShader","join","fragmentShader","shaders"],"mappings":";;;;;;;AAAAA,QACI,aACF,SAAUC,GACR,aACA,IAAIC,GACAC,OACIC,KAAM,cACNC,MAAO,qBACPC,MAAO,qBACPC,UAAW,wBACXC,OAAQ,uBAEZC,UACIC,SAAaC,MAAO,MACpBC,KAASD,MAAO,MAChBE,eAAmBF,MAAO,MAC1BG,mBAAuBH,MAAO,MAC9BI,mBAAuBJ,MAAO,OAElCK,cACI,oBACA,8BACA,wBACA,gBACA,cACA,+DACA,qCACA,kDACA,iDACA,KACFC,KAAK,MACPC,gBACI,6BACA,yBACA,+BACA,mCACA,mCACA,oBACA,8BACA,wBACA,4BACA,oCACA,yDACA,kEACA,mCACA,MACA,QACA,oCACA,6GACA,2CACA,sCACA,0DACA,uCACA,8EACA,0CACA,yDACA,iBACA,UACA,2CACA,sCACA,0EACA,QACA,gCACA,qCACA,2CACA,yCACA,+CACA,+CACA,2CACA,mCACA,qDACA,gCACA,8BACA,4EACA,yDACA,mDACA,+CACA,mBACA,mDACA,+CACA,YACA,UACA,qCACA,6CACA,wDACA,8DACA,8FACA,kDACA,+EACA,YACA,oBACA,aACA,MACA,SACA,4EACA,8BACA,8BACA,yCACA,yCACA,6CACA,6CACA,sCACA,kGACA,oBACA,8DACA,mDACA,qCACA,IACA,gBACA,gGACA,4CACA,KACFD,KAAK,OAEX,OAAOhB,EAAOkB,QAAQjB,eAAiBA","file":"../../shaders/ParallaxShader.js","sourcesContent":["define([\r\n    \"../threex\"\r\n],function (threex) {\r\n    'use strict';\r\n    var ParallaxShader = {\r\n        modes: {\r\n            none: 'NO_PARALLAX',\r\n            basic: 'USE_BASIC_PARALLAX',\r\n            steep: 'USE_STEEP_PARALLAX',\r\n            occlusion: 'USE_OCLUSION_PARALLAX',\r\n            relief: 'USE_RELIEF_PARALLAX'\r\n        },\r\n        uniforms: {\r\n            'bumpMap': { value: null },\r\n            'map': { value: null },\r\n            'parallaxScale': { value: null },\r\n            'parallaxMinLayers': { value: null },\r\n            'parallaxMaxLayers': { value: null }\r\n        },\r\n        vertexShader: [\r\n            'varying vec2 vUv;',\r\n            'varying vec3 vViewPosition;',\r\n            'varying vec3 vNormal;',\r\n            'void main() {',\r\n            '\\tvUv = uv;',\r\n            '\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\r\n            '\\tvViewPosition = -mvPosition.xyz;',\r\n            '\\tvNormal = normalize( normalMatrix * normal );',\r\n            '\\tgl_Position = projectionMatrix * mvPosition;',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            'uniform sampler2D bumpMap;',\r\n            'uniform sampler2D map;',\r\n            'uniform float parallaxScale;',\r\n            'uniform float parallaxMinLayers;',\r\n            'uniform float parallaxMaxLayers;',\r\n            'varying vec2 vUv;',\r\n            'varying vec3 vViewPosition;',\r\n            'varying vec3 vNormal;',\r\n            '#ifdef USE_BASIC_PARALLAX',\r\n            '\\tvec2 parallaxMap( in vec3 V ) {',\r\n            '\\t\\tfloat initialHeight = texture2D( bumpMap, vUv ).r;',\r\n            '\\t\\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;',\r\n            '\\t\\treturn vUv - texCoordOffset;',\r\n            '\\t}',\r\n            '#else',\r\n            '\\tvec2 parallaxMap( in vec3 V ) {',\r\n            '\\t\\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );',\r\n            '\\t\\tfloat layerHeight = 1.0 / numLayers;',\r\n            '\\t\\tfloat currentLayerHeight = 0.0;',\r\n            '\\t\\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;',\r\n            '\\t\\tvec2 currentTextureCoords = vUv;',\r\n            '\\t\\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;',\r\n            '\\t\\tfor ( int i = 0; i < 30; i += 1 ) {',\r\n            '\\t\\t\\tif ( heightFromTexture <= currentLayerHeight ) {',\r\n            '\\t\\t\\t\\tbreak;',\r\n            '\\t\\t\\t}',\r\n            '\\t\\t\\tcurrentLayerHeight += layerHeight;',\r\n            '\\t\\t\\tcurrentTextureCoords -= dtex;',\r\n            '\\t\\t\\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;',\r\n            '\\t\\t}',\r\n            '\\t\\t#ifdef USE_STEEP_PARALLAX',\r\n            '\\t\\t\\treturn currentTextureCoords;',\r\n            '\\t\\t#elif defined( USE_RELIEF_PARALLAX )',\r\n            '\\t\\t\\tvec2 deltaTexCoord = dtex / 2.0;',\r\n            '\\t\\t\\tfloat deltaHeight = layerHeight / 2.0;',\r\n            '\\t\\t\\tcurrentTextureCoords += deltaTexCoord;',\r\n            '\\t\\t\\tcurrentLayerHeight -= deltaHeight;',\r\n            '\\t\\t\\tconst int numSearches = 5;',\r\n            '\\t\\t\\tfor ( int i = 0; i < numSearches; i += 1 ) {',\r\n            '\\t\\t\\t\\tdeltaTexCoord /= 2.0;',\r\n            '\\t\\t\\t\\tdeltaHeight /= 2.0;',\r\n            '\\t\\t\\t\\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;',\r\n            '\\t\\t\\t\\tif( heightFromTexture > currentLayerHeight ) {',\r\n            '\\t\\t\\t\\t\\tcurrentTextureCoords -= deltaTexCoord;',\r\n            '\\t\\t\\t\\t\\tcurrentLayerHeight += deltaHeight;',\r\n            '\\t\\t\\t\\t} else {',\r\n            '\\t\\t\\t\\t\\tcurrentTextureCoords += deltaTexCoord;',\r\n            '\\t\\t\\t\\t\\tcurrentLayerHeight -= deltaHeight;',\r\n            '\\t\\t\\t\\t}',\r\n            '\\t\\t\\t}',\r\n            '\\t\\t\\treturn currentTextureCoords;',\r\n            '\\t\\t#elif defined( USE_OCLUSION_PARALLAX )',\r\n            '\\t\\t\\tvec2 prevTCoords = currentTextureCoords + dtex;',\r\n            '\\t\\t\\tfloat nextH = heightFromTexture - currentLayerHeight;',\r\n            '\\t\\t\\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;',\r\n            '\\t\\t\\tfloat weight = nextH / ( nextH - prevH );',\r\n            '\\t\\t\\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );',\r\n            '\\t\\t#else',\r\n            '\\t\\t\\treturn vUv;',\r\n            '\\t\\t#endif',\r\n            '\\t}',\r\n            '#endif',\r\n            'vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {',\r\n            '\\tvec2 texDx = dFdx( vUv );',\r\n            '\\tvec2 texDy = dFdy( vUv );',\r\n            '\\tvec3 vSigmaX = dFdx( surfPosition );',\r\n            '\\tvec3 vSigmaY = dFdy( surfPosition );',\r\n            '\\tvec3 vR1 = cross( vSigmaY, surfNormal );',\r\n            '\\tvec3 vR2 = cross( surfNormal, vSigmaX );',\r\n            '\\tfloat fDet = dot( vSigmaX, vR1 );',\r\n            '\\tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );',\r\n            '\\tvec3 vProjVtex;',\r\n            '\\tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;',\r\n            '\\tvProjVtex.z = dot( surfNormal, viewPosition );',\r\n            '\\treturn parallaxMap( vProjVtex );',\r\n            '}',\r\n            'void main() {',\r\n            '\\tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );',\r\n            '\\tgl_FragColor = texture2D( map, mapUv );',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    return threex.shaders.ParallaxShader = ParallaxShader;\r\n});"]}