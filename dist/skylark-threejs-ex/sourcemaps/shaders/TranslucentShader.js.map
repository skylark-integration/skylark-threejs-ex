{"version":3,"sources":["shaders/TranslucentShader.js"],"names":["define","THREE","TranslucentShader","uniforms","UniformsUtils","merge","UniformsLib","color","value","Color","diffuse","specular","emissive","opacity","shininess","thicknessMap","thicknessColor","thicknessDistortion","thicknessAmbient","thicknessAttenuation","thicknessPower","thicknessScale","vertexShader","ShaderChunk","join","fragmentShader"],"mappings":";;;;;;;AAAAA,QACC,mBACC,SAASC,GAiNV,OAtMAA,EAAMC,mBAELC,SAAUF,EAAMG,cAAcC,OAE7BJ,EAAMK,YAAsB,OAC5BL,EAAMK,YAAsB,QAE3BC,OAAWC,MAAO,IAAIP,EAAMQ,MAAO,WACnCC,SAAaF,MAAO,IAAIP,EAAMQ,MAAO,WACrCE,UAAcH,MAAO,IAAIP,EAAMQ,MAAO,WACtCG,UAAcJ,MAAO,IAAIP,EAAMQ,MAAO,IACtCI,SAAaL,MAAO,GACpBM,WAAeN,MAAO,GAEtBO,cAAkBP,MAAO,MACzBQ,gBAAoBR,MAAO,IAAIP,EAAMQ,MAAO,WAC5CQ,qBAAyBT,MAAO,IAChCU,kBAAsBV,MAAO,GAC7BW,sBAA0BX,MAAO,IACjCY,gBAAoBZ,MAAO,GAC3Ba,gBAAoBb,MAAO,OAK7Bc,cAEC,wBACA,oBAEA,8BAEArB,EAAMsB,YAAsB,OAE5B,gBAEA,8DAEA,+DAEA,qCAEA,kDAEA,cAEA,iDAEA,KAECC,KAAM,MAERC,gBACC,iBACA,kBACA,gBACA,sBACA,oBACA,mBACA,8BACA,+BACA,wCAEA,uBAEA,wBACA,yBACA,yBACA,yBACA,2BAGA,kCACA,gCACA,gCACA,qCACA,kCACA,sCACA,+BAEAxB,EAAMsB,YAAiC,kBAEvC,6JACA,qEACA,sGACA,kHACA,0EACA,+FACA,IAEA,gBAEA,wCAEA,uDAEA,kDACA,0GAEAtB,EAAMsB,YAA4B,aAClCtB,EAAMsB,YAA8B,eACpCtB,EAAMsB,YAAoC,qBAE1C,2CAEAtB,EAAMsB,YAAqC,sBAG3C,+BACA,yCACA,8BACA,mDAEA,+BAEA,yDAEA,6BAEA,gCACA,sDACA,wCACA,6EAEA,6BACA,8RACA,eAEA,sEAEA,wDACA,0EACA,eACA,QACA,8BAEA,aAEA,uDAEA,yCAEA,gCACA,oDACA,mDACA,wFAEA,6BACA,oQACA,eAEA,sEAEA,wDACA,0EACA,eACA,QACA,8BAEA,WAEA,sCAEA,wEAEA,kCAEA,kCACA,uDAEA,yFAEA,UACA,gCAEA,aAEA,WAEA,uCAEA,mCACA,4CAEA,WACAtB,EAAMsB,YAAmC,oBAEzC,kLACA,0DAEAtB,EAAMsB,YAAkC,mBAExC,KAECC,KAAM,OAIFvB,EAAMC","file":"../../shaders/TranslucentShader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author daoshengmu / http://dsmu.me/\n\t *\n\t * ------------------------------------------------------------------------------------------\n\t * Subsurface Scattering shader\n\t * Base on GDC 2011 â€“ Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look\n\t * https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/\n\t *------------------------------------------------------------------------------------------\n\t */\n\n\tTHREE.TranslucentShader = {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\t{\n\t\t\t\t\"color\": { value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\"diffuse\": { value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\"specular\": { value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\"emissive\": { value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"opacity\": { value: 1 },\n\t\t\t\t\"shininess\": { value: 1 },\n\n\t\t\t\t\"thicknessMap\": { value: null },\n\t\t\t\t\"thicknessColor\": { value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\"thicknessDistortion\": { value: 0.1 },\n\t\t\t\t\"thicknessAmbient\": { value: 0.0 },\n\t\t\t\t\"thicknessAttenuation\": { value: 0.1 },\n\t\t\t\t\"thicknessPower\": { value: 2.0 },\n\t\t\t\t\"thicknessScale\": { value: 10.0 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"\tvViewPosition = -mvPosition.xyz;\",\n\n\t\t\t\"\tvNormal = normalize( normalMatrix * normal );\",\n\n\t\t\t\"\tvUv = uv;\",\n\n\t\t\t\"\tgl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\"}\",\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\t\t\t\"#define USE_UV\",\n\t\t\t\"#define USE_MAP\",\n\t\t\t\"#define PHONG\",\n\t\t\t\"#define TRANSLUCENT\",\n\t\t\t\"#include <common>\",\n\t\t\t\"#include <bsdfs>\",\n\t\t\t\"#include <uv_pars_fragment>\",\n\t\t\t\"#include <map_pars_fragment>\",\n\t\t\t\"#include <lights_phong_pars_fragment>\",\n\n\t\t\t\"varying vec3 vColor;\",\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform vec3 specular;\",\n\t\t\t\"uniform vec3 emissive;\",\n\t\t\t\"uniform float opacity;\",\n\t\t\t\"uniform float shininess;\",\n\n\t\t\t// Translucency\n\t\t\t\"uniform sampler2D thicknessMap;\",\n\t\t\t\"uniform float thicknessPower;\",\n\t\t\t\"uniform float thicknessScale;\",\n\t\t\t\"uniform float thicknessDistortion;\",\n\t\t\t\"uniform float thicknessAmbient;\",\n\t\t\t\"uniform float thicknessAttenuation;\",\n\t\t\t\"uniform vec3 thicknessColor;\",\n\n\t\t\tTHREE.ShaderChunk[ \"lights_pars_begin\" ],\n\n\t\t\t\"void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {\",\n\t\t\t\"\tvec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;\",\n\t\t\t\"\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));\",\n\t\t\t\"\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;\",\n\t\t\t\"\tvec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;\",\n\t\t\t\"\treflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;\",\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec3 normal = normalize( vNormal );\",\n\n\t\t\t\"\tvec3 viewerDirection = normalize( vViewPosition );\",\n\n\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\n\t\t\t\"\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\",\n\n\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\n\t\t\t\"\tvec3 totalEmissiveRadiance = emissive;\",\n\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_fragment\" ],\n\n\t\t\t// Doing lights fragment begin.\n\t\t\t\"\tGeometricContext geometry;\",\n\t\t\t\"\tgeometry.position = - vViewPosition;\",\n\t\t\t\"\tgeometry.normal = normal;\",\n\t\t\t\"\tgeometry.viewDir = normalize( vViewPosition );\",\n\n\t\t\t\"\tIncidentLight directLight;\",\n\n\t\t\t\"\t#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\",\n\n\t\t\t\"\t\tPointLight pointLight;\",\n\n\t\t\t\"\t\t#pragma unroll_loop_start\",\n\t\t\t\"\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\",\n\t\t\t\"\t\t \tpointLight = pointLights[ i ];\",\n\t\t\t\"\t\t \tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\",\n\n\t\t\t\"\t\t\t#ifdef USE_SHADOWMAP\",\n\t\t\t\"\t\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\",\n\t\t\t\"\t\t\t#endif\",\n\n\t\t\t\"\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\",\n\n\t\t\t\"\t\t\t#if defined( TRANSLUCENT ) && defined( USE_UV )\",\n\t\t\t\"\t\t\tRE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);\",\n\t\t\t\"\t\t\t#endif\",\n\t\t\t\"\t\t}\",\n\t\t\t\"\t\t#pragma unroll_loop_end\",\n\n\t\t\t\"\t\t#endif\",\n\n\t\t\t\"\t#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\",\n\n\t\t\t\"\t\tDirectionalLight directionalLight;\",\n\n\t\t\t\"\t\t#pragma unroll_loop_start\",\n\t\t\t\"\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\",\n\t\t\t\"\t\t\tdirectionalLight = directionalLights[ i ];\",\n\t\t\t\"\t\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\",\n\n\t\t\t\"\t\t\t#ifdef USE_SHADOWMAP\",\n\t\t\t\"\t\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\",\n\t\t\t\"\t\t\t#endif\",\n\n\t\t\t\"\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\",\n\n\t\t\t\"\t\t\t#if defined( TRANSLUCENT ) && defined( USE_UV )\",\n\t\t\t\"\t\t\tRE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);\",\n\t\t\t\"\t\t\t#endif\",\n\t\t\t\"\t\t}\",\n\t\t\t\"\t\t#pragma unroll_loop_end\",\n\n\t\t\t\"\t#endif\",\n\n\t\t\t\"\t#if defined( RE_IndirectDiffuse )\",\n\n\t\t\t\"\t\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\",\n\n\t\t\t\"\t\t#if ( NUM_HEMI_LIGHTS > 0 )\",\n\n\t\t\t\"\t\t\t#pragma unroll_loop_start\",\n\t\t\t\"\t\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\",\n\n\t\t\t\"\t\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\",\n\n\t\t\t\"\t\t\t}\",\n\t\t\t\"\t\t\t#pragma unroll_loop_end\",\n\n\t\t\t\"\t\t#endif\",\n\n\t\t\t\"\t#endif\",\n\n\t\t\t\"\t#if defined( RE_IndirectSpecular )\",\n\n\t\t\t\"\t\tvec3 radiance = vec3( 0.0 );\",\n\t\t\t\"\t\tvec3 clearcoatRadiance = vec3( 0.0 );\",\n\n\t\t\t\"\t#endif\",\n\t\t\tTHREE.ShaderChunk[ \"lights_fragment_end\" ],\n\n\t\t\t\"\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\",\n\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\n\n\t\t\tTHREE.ShaderChunk[ \"encodings_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t};\n\t\n\treturn THREE.TranslucentShader;\n});\n"]}