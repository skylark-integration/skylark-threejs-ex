{"version":3,"sources":["shaders/TranslucentShader.js"],"names":["define","THREE","threex","TranslucentShader","uniforms","UniformsUtils","merge","UniformsLib","color","value","Color","diffuse","specular","emissive","opacity","shininess","thicknessMap","thicknessColor","thicknessDistortion","thicknessAmbient","thicknessAttenuation","thicknessPower","thicknessScale","vertexShader","ShaderChunk","join","fragmentShader","shaders"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,GACAC,SAAUH,EAAMI,cAAcC,OAC1BL,EAAMM,YAAoB,OAC1BN,EAAMM,YAAoB,QAEtBC,OAAWC,MAAO,IAAIR,EAAMS,MAAM,WAClCC,SAAaF,MAAO,IAAIR,EAAMS,MAAM,WACpCE,UAAcH,MAAO,IAAIR,EAAMS,MAAM,WACrCG,UAAcJ,MAAO,IAAIR,EAAMS,MAAM,IACrCI,SAAaL,MAAO,GACpBM,WAAeN,MAAO,GACtBO,cAAkBP,MAAO,MACzBQ,gBAAoBR,MAAO,IAAIR,EAAMS,MAAM,WAC3CQ,qBAAyBT,MAAO,IAChCU,kBAAsBV,MAAO,GAC7BW,sBAA0BX,MAAO,IACjCY,gBAAoBZ,MAAO,GAC3Ba,gBAAoBb,MAAO,OAGnCc,cACI,wBACA,oBACA,8BACAtB,EAAMuB,YAAoB,OAC1B,gBACA,8DACA,+DACA,qCACA,kDACA,cACA,iDACA,KACFC,KAAK,MACPC,gBACI,iBACA,kBACA,gBACA,sBACA,oBACA,mBACA,8BACA,+BACA,wCACA,uBACA,wBACA,yBACA,yBACA,yBACA,2BACA,kCACA,gCACA,gCACA,qCACA,kCACA,sCACA,+BACAzB,EAAMuB,YAA+B,kBACrC,6JACA,qEACA,sGACA,kHACA,0EACA,+FACA,IACA,gBACA,wCACA,uDACA,kDACA,0GACAvB,EAAMuB,YAA0B,aAChCvB,EAAMuB,YAA4B,eAClCvB,EAAMuB,YAAkC,qBACxC,2CACAvB,EAAMuB,YAAmC,sBACzC,+BACA,yCACA,8BACA,mDACA,+BACA,yDACA,6BACA,gCACA,sDACA,wCACA,6EACA,6BACA,8RACA,eACA,sEACA,wDACA,0EACA,eACA,QACA,8BACA,aACA,uDACA,yCACA,gCACA,oDACA,mDACA,wFACA,6BACA,oQACA,eACA,sEACA,wDACA,0EACA,eACA,QACA,8BACA,WACA,sCACA,wEACA,kCACA,kCACA,uDACA,yFACA,UACA,gCACA,aACA,WACA,uCACA,mCACA,4CACA,WACAvB,EAAMuB,YAAiC,oBACvC,kLACA,0DACAvB,EAAMuB,YAAgC,mBACtC,KACFC,KAAK,OAEX,OAAOvB,EAAOyB,QAAQxB,kBAAoBA","file":"../../shaders/TranslucentShader.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var TranslucentShader = {\r\n        uniforms: THREE.UniformsUtils.merge([\r\n            THREE.UniformsLib['common'],\r\n            THREE.UniformsLib['lights'],\r\n            {\r\n                'color': { value: new THREE.Color(16777215) },\r\n                'diffuse': { value: new THREE.Color(16777215) },\r\n                'specular': { value: new THREE.Color(16777215) },\r\n                'emissive': { value: new THREE.Color(0) },\r\n                'opacity': { value: 1 },\r\n                'shininess': { value: 1 },\r\n                'thicknessMap': { value: null },\r\n                'thicknessColor': { value: new THREE.Color(16777215) },\r\n                'thicknessDistortion': { value: 0.1 },\r\n                'thicknessAmbient': { value: 0 },\r\n                'thicknessAttenuation': { value: 0.1 },\r\n                'thicknessPower': { value: 2 },\r\n                'thicknessScale': { value: 10 }\r\n            }\r\n        ]),\r\n        vertexShader: [\r\n            'varying vec3 vNormal;',\r\n            'varying vec2 vUv;',\r\n            'varying vec3 vViewPosition;',\r\n            THREE.ShaderChunk['common'],\r\n            'void main() {',\r\n            '\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\r\n            '\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\r\n            '\\tvViewPosition = -mvPosition.xyz;',\r\n            '\\tvNormal = normalize( normalMatrix * normal );',\r\n            '\\tvUv = uv;',\r\n            '\\tgl_Position = projectionMatrix * mvPosition;',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            '#define USE_UV',\r\n            '#define USE_MAP',\r\n            '#define PHONG',\r\n            '#define TRANSLUCENT',\r\n            '#include <common>',\r\n            '#include <bsdfs>',\r\n            '#include <uv_pars_fragment>',\r\n            '#include <map_pars_fragment>',\r\n            '#include <lights_phong_pars_fragment>',\r\n            'varying vec3 vColor;',\r\n            'uniform vec3 diffuse;',\r\n            'uniform vec3 specular;',\r\n            'uniform vec3 emissive;',\r\n            'uniform float opacity;',\r\n            'uniform float shininess;',\r\n            'uniform sampler2D thicknessMap;',\r\n            'uniform float thicknessPower;',\r\n            'uniform float thicknessScale;',\r\n            'uniform float thicknessDistortion;',\r\n            'uniform float thicknessAmbient;',\r\n            'uniform float thicknessAttenuation;',\r\n            'uniform vec3 thicknessColor;',\r\n            THREE.ShaderChunk['lights_pars_begin'],\r\n            'void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {',\r\n            '\\tvec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;',\r\n            '\\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));',\r\n            '\\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;',\r\n            '\\tvec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;',\r\n            '\\treflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;',\r\n            '}',\r\n            'void main() {',\r\n            '\\tvec3 normal = normalize( vNormal );',\r\n            '\\tvec3 viewerDirection = normalize( vViewPosition );',\r\n            '\\tvec4 diffuseColor = vec4( diffuse, opacity );',\r\n            '\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );',\r\n            THREE.ShaderChunk['map_fragment'],\r\n            THREE.ShaderChunk['color_fragment'],\r\n            THREE.ShaderChunk['specularmap_fragment'],\r\n            '\\tvec3 totalEmissiveRadiance = emissive;',\r\n            THREE.ShaderChunk['lights_phong_fragment'],\r\n            '\\tGeometricContext geometry;',\r\n            '\\tgeometry.position = - vViewPosition;',\r\n            '\\tgeometry.normal = normal;',\r\n            '\\tgeometry.viewDir = normalize( vViewPosition );',\r\n            '\\tIncidentLight directLight;',\r\n            '\\t#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )',\r\n            '\\t\\tPointLight pointLight;',\r\n            '\\t\\t#pragma unroll_loop_start',\r\n            '\\t\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {',\r\n            '\\t\\t \\tpointLight = pointLights[ i ];',\r\n            '\\t\\t \\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );',\r\n            '\\t\\t\\t#ifdef USE_SHADOWMAP',\r\n            '\\t\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;',\r\n            '\\t\\t\\t#endif',\r\n            '\\t\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );',\r\n            '\\t\\t\\t#if defined( TRANSLUCENT ) && defined( USE_UV )',\r\n            '\\t\\t\\tRE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);',\r\n            '\\t\\t\\t#endif',\r\n            '\\t\\t}',\r\n            '\\t\\t#pragma unroll_loop_end',\r\n            '\\t\\t#endif',\r\n            '\\t#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )',\r\n            '\\t\\tDirectionalLight directionalLight;',\r\n            '\\t\\t#pragma unroll_loop_start',\r\n            '\\t\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {',\r\n            '\\t\\t\\tdirectionalLight = directionalLights[ i ];',\r\n            '\\t\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );',\r\n            '\\t\\t\\t#ifdef USE_SHADOWMAP',\r\n            '\\t\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;',\r\n            '\\t\\t\\t#endif',\r\n            '\\t\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );',\r\n            '\\t\\t\\t#if defined( TRANSLUCENT ) && defined( USE_UV )',\r\n            '\\t\\t\\tRE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);',\r\n            '\\t\\t\\t#endif',\r\n            '\\t\\t}',\r\n            '\\t\\t#pragma unroll_loop_end',\r\n            '\\t#endif',\r\n            '\\t#if defined( RE_IndirectDiffuse )',\r\n            '\\t\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );',\r\n            '\\t\\t#if ( NUM_HEMI_LIGHTS > 0 )',\r\n            '\\t\\t\\t#pragma unroll_loop_start',\r\n            '\\t\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {',\r\n            '\\t\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );',\r\n            '\\t\\t\\t}',\r\n            '\\t\\t\\t#pragma unroll_loop_end',\r\n            '\\t\\t#endif',\r\n            '\\t#endif',\r\n            '\\t#if defined( RE_IndirectSpecular )',\r\n            '\\t\\tvec3 radiance = vec3( 0.0 );',\r\n            '\\t\\tvec3 clearcoatRadiance = vec3( 0.0 );',\r\n            '\\t#endif',\r\n            THREE.ShaderChunk['lights_fragment_end'],\r\n            '\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;',\r\n            '\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );',\r\n            THREE.ShaderChunk['encodings_fragment'],\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    return threex.shaders.TranslucentShader = TranslucentShader;\r\n});"]}