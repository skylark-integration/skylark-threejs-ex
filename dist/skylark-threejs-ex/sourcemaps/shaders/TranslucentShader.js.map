{"version":3,"sources":["shaders/TranslucentShader.js"],"names":["define","THREE","uniforms","UniformsUtils","merge","UniformsLib","color","value","Color","diffuse","specular","emissive","opacity","shininess","thicknessMap","thicknessColor","thicknessDistortion","thicknessAmbient","thicknessAttenuation","thicknessPower","thicknessScale","vertexShader","ShaderChunk","join","fragmentShader"],"mappings":";;;;;;;AAAAA,QACI,mBACD,SAAUC,GACT,aAsIA,OApIIC,SAAUD,EAAME,cAAcC,OAC1BH,EAAMI,YAAoB,OAC1BJ,EAAMI,YAAoB,QAEtBC,OAAWC,MAAO,IAAIN,EAAMO,MAAM,WAClCC,SAAaF,MAAO,IAAIN,EAAMO,MAAM,WACpCE,UAAcH,MAAO,IAAIN,EAAMO,MAAM,WACrCG,UAAcJ,MAAO,IAAIN,EAAMO,MAAM,IACrCI,SAAaL,MAAO,GACpBM,WAAeN,MAAO,GACtBO,cAAkBP,MAAO,MACzBQ,gBAAoBR,MAAO,IAAIN,EAAMO,MAAM,WAC3CQ,qBAAyBT,MAAO,IAChCU,kBAAsBV,MAAO,GAC7BW,sBAA0BX,MAAO,IACjCY,gBAAoBZ,MAAO,GAC3Ba,gBAAoBb,MAAO,OAGnCc,cACI,wBACA,oBACA,8BACApB,EAAMqB,YAAoB,OAC1B,gBACA,8DACA,+DACA,qCACA,kDACA,cACA,iDACA,KACFC,KAAK,MACPC,gBACI,iBACA,kBACA,gBACA,sBACA,oBACA,mBACA,8BACA,+BACA,wCACA,uBACA,wBACA,yBACA,yBACA,yBACA,2BACA,kCACA,gCACA,gCACA,qCACA,kCACA,sCACA,+BACAvB,EAAMqB,YAA+B,kBACrC,6JACA,qEACA,sGACA,kHACA,0EACA,+FACA,IACA,gBACA,wCACA,uDACA,kDACA,0GACArB,EAAMqB,YAA0B,aAChCrB,EAAMqB,YAA4B,eAClCrB,EAAMqB,YAAkC,qBACxC,2CACArB,EAAMqB,YAAmC,sBACzC,+BACA,yCACA,8BACA,mDACA,+BACA,yDACA,6BACA,gCACA,sDACA,wCACA,6EACA,6BACA,8RACA,eACA,sEACA,wDACA,0EACA,eACA,QACA,8BACA,aACA,uDACA,yCACA,gCACA,oDACA,mDACA,wFACA,6BACA,oQACA,eACA,sEACA,wDACA,0EACA,eACA,QACA,8BACA,WACA,sCACA,wEACA,kCACA,kCACA,uDACA,yFACA,UACA,gCACA,aACA,WACA,uCACA,mCACA,4CACA,WACArB,EAAMqB,YAAiC,oBACvC,kLACA,0DACArB,EAAMqB,YAAgC,mBACtC,KACFC,KAAK","file":"../../shaders/TranslucentShader.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var TranslucentShader = {\n        uniforms: THREE.UniformsUtils.merge([\n            THREE.UniformsLib['common'],\n            THREE.UniformsLib['lights'],\n            {\n                'color': { value: new THREE.Color(16777215) },\n                'diffuse': { value: new THREE.Color(16777215) },\n                'specular': { value: new THREE.Color(16777215) },\n                'emissive': { value: new THREE.Color(0) },\n                'opacity': { value: 1 },\n                'shininess': { value: 1 },\n                'thicknessMap': { value: null },\n                'thicknessColor': { value: new THREE.Color(16777215) },\n                'thicknessDistortion': { value: 0.1 },\n                'thicknessAmbient': { value: 0 },\n                'thicknessAttenuation': { value: 0.1 },\n                'thicknessPower': { value: 2 },\n                'thicknessScale': { value: 10 }\n            }\n        ]),\n        vertexShader: [\n            'varying vec3 vNormal;',\n            'varying vec2 vUv;',\n            'varying vec3 vViewPosition;',\n            THREE.ShaderChunk['common'],\n            'void main() {',\n            '\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\n            '\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',\n            '\\tvViewPosition = -mvPosition.xyz;',\n            '\\tvNormal = normalize( normalMatrix * normal );',\n            '\\tvUv = uv;',\n            '\\tgl_Position = projectionMatrix * mvPosition;',\n            '}'\n        ].join('\\n'),\n        fragmentShader: [\n            '#define USE_UV',\n            '#define USE_MAP',\n            '#define PHONG',\n            '#define TRANSLUCENT',\n            '#include <common>',\n            '#include <bsdfs>',\n            '#include <uv_pars_fragment>',\n            '#include <map_pars_fragment>',\n            '#include <lights_phong_pars_fragment>',\n            'varying vec3 vColor;',\n            'uniform vec3 diffuse;',\n            'uniform vec3 specular;',\n            'uniform vec3 emissive;',\n            'uniform float opacity;',\n            'uniform float shininess;',\n            'uniform sampler2D thicknessMap;',\n            'uniform float thicknessPower;',\n            'uniform float thicknessScale;',\n            'uniform float thicknessDistortion;',\n            'uniform float thicknessAmbient;',\n            'uniform float thicknessAttenuation;',\n            'uniform vec3 thicknessColor;',\n            THREE.ShaderChunk['lights_pars_begin'],\n            'void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {',\n            '\\tvec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;',\n            '\\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));',\n            '\\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;',\n            '\\tvec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;',\n            '\\treflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;',\n            '}',\n            'void main() {',\n            '\\tvec3 normal = normalize( vNormal );',\n            '\\tvec3 viewerDirection = normalize( vViewPosition );',\n            '\\tvec4 diffuseColor = vec4( diffuse, opacity );',\n            '\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );',\n            THREE.ShaderChunk['map_fragment'],\n            THREE.ShaderChunk['color_fragment'],\n            THREE.ShaderChunk['specularmap_fragment'],\n            '\\tvec3 totalEmissiveRadiance = emissive;',\n            THREE.ShaderChunk['lights_phong_fragment'],\n            '\\tGeometricContext geometry;',\n            '\\tgeometry.position = - vViewPosition;',\n            '\\tgeometry.normal = normal;',\n            '\\tgeometry.viewDir = normalize( vViewPosition );',\n            '\\tIncidentLight directLight;',\n            '\\t#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )',\n            '\\t\\tPointLight pointLight;',\n            '\\t\\t#pragma unroll_loop_start',\n            '\\t\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {',\n            '\\t\\t \\tpointLight = pointLights[ i ];',\n            '\\t\\t \\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );',\n            '\\t\\t\\t#ifdef USE_SHADOWMAP',\n            '\\t\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;',\n            '\\t\\t\\t#endif',\n            '\\t\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );',\n            '\\t\\t\\t#if defined( TRANSLUCENT ) && defined( USE_UV )',\n            '\\t\\t\\tRE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);',\n            '\\t\\t\\t#endif',\n            '\\t\\t}',\n            '\\t\\t#pragma unroll_loop_end',\n            '\\t\\t#endif',\n            '\\t#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )',\n            '\\t\\tDirectionalLight directionalLight;',\n            '\\t\\t#pragma unroll_loop_start',\n            '\\t\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {',\n            '\\t\\t\\tdirectionalLight = directionalLights[ i ];',\n            '\\t\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );',\n            '\\t\\t\\t#ifdef USE_SHADOWMAP',\n            '\\t\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;',\n            '\\t\\t\\t#endif',\n            '\\t\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );',\n            '\\t\\t\\t#if defined( TRANSLUCENT ) && defined( USE_UV )',\n            '\\t\\t\\tRE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);',\n            '\\t\\t\\t#endif',\n            '\\t\\t}',\n            '\\t\\t#pragma unroll_loop_end',\n            '\\t#endif',\n            '\\t#if defined( RE_IndirectDiffuse )',\n            '\\t\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );',\n            '\\t\\t#if ( NUM_HEMI_LIGHTS > 0 )',\n            '\\t\\t\\t#pragma unroll_loop_start',\n            '\\t\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {',\n            '\\t\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );',\n            '\\t\\t\\t}',\n            '\\t\\t\\t#pragma unroll_loop_end',\n            '\\t\\t#endif',\n            '\\t#endif',\n            '\\t#if defined( RE_IndirectSpecular )',\n            '\\t\\tvec3 radiance = vec3( 0.0 );',\n            '\\t\\tvec3 clearcoatRadiance = vec3( 0.0 );',\n            '\\t#endif',\n            THREE.ShaderChunk['lights_fragment_end'],\n            '\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;',\n            '\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );',\n            THREE.ShaderChunk['encodings_fragment'],\n            '}'\n        ].join('\\n')\n    };\n    return TranslucentShader ;\n});"]}