{"version":3,"sources":["shaders/HalftoneShader.js"],"names":["define","threex","HalftoneShader","uniforms","tDiffuse","value","shape","radius","rotateR","Math","PI","rotateG","rotateB","scatter","width","height","blending","blendingMode","greyscale","disable","vertexShader","join","fragmentShader","shaders"],"mappings":";;;;;;;AAAAA,QACI,aACF,SAAUC,GACR,aACA,IAAIC,GACAC,UACIC,UAAcC,MAAO,MACrBC,OAAWD,MAAO,GAClBE,QAAYF,MAAO,GACnBG,SAAaH,MAAOI,KAAKC,GAAK,GAAK,GACnCC,SAAaN,MAAOI,KAAKC,GAAK,GAAK,GACnCE,SAAaP,MAAOI,KAAKC,GAAK,GAAK,GACnCG,SAAaR,MAAO,GACpBS,OAAWT,MAAO,GAClBU,QAAYV,MAAO,GACnBW,UAAcX,MAAO,GACrBY,cAAkBZ,MAAO,GACzBa,WAAeb,OAAO,GACtBc,SAAad,OAAO,IAExBe,cACI,oBACA,gBACA,cACA,4EACA,KACFC,KAAK,MACPC,gBACI,qCACA,0CACA,yBACA,sBACA,0BACA,uBACA,yBACA,4BACA,8BACA,yBACA,6BACA,4BACA,8BACA,wBACA,yBACA,yBACA,yBACA,yBACA,uBACA,wBACA,qBACA,wBACA,0BACA,4BACA,oBACA,0BACA,yBACA,6CACA,oCACA,IACA,oCACA,kCACA,IACA,2BACA,+EACA,IACA,4GACA,wDACA,yBACA,gCACA,gDACA,2CACA,gDACA,2BACA,wGACA,2FACA,QACA,wCACA,6CACA,iFACA,0DACA,0CACA,kEACA,yCACA,yCACA,oCACA,+FACA,MACA,uBACA,IACA,gBACA,iBACA,aACA,aACA,aACA,aACA,iBACA,iBACA,iBACA,iBACA,KACA,iCACA,iFACA,2EACA,yCACA,gCACA,0CACA,0CACA,qEACA,+EACA,MACA,mCACA,gBACA,IACA,6EACA,uDACA,0BACA,qCACA,qCACA,qCACA,qCACA,+BACA,qCACA,qCACA,qCACA,qCACA,aACA,qCACA,qCACA,qCACA,qCACA,MACA,iFACA,iFACA,iFACA,iFACA,uEACA,wEACA,wEACA,wEACA,kCACA,gBACA,IACA,+EACA,YACA,2DACA,kCACA,4EACA,2EACA,8DACA,oEACA,0DACA,iHACA,4GACA,sDACA,uGACA,kBACA,0DACA,0DACA,4BACA,iDACA,gFACA,4CACA,4CACA,MACA,uFACA,iFACA,yCACA,yCACA,uCACA,uCACA,2DACA,2DACA,cACA,IACA,mDACA,6CACA,qCACA,iDACA,+CACA,sDACA,+CACA,qDACA,yCACA,oDACA,yCACA,aACA,qCACA,MACA,IACA,gBACA,uBACA,sDACA,kCACA,yDACA,oEACA,oEACA,oEACA,2DACA,2DACA,2DACA,gDACA,gDACA,gDACA,gDACA,yBACA,uCACA,QACA,2CACA,aACA,iDACA,MACA,KACFD,KAAK,OAEX,OAAOpB,EAAOsB,QAAQrB,eAAiBA","file":"../../shaders/HalftoneShader.js","sourcesContent":["define([\r\n    \"../threex\"\r\n],function (threex) {\r\n    'use strict';\r\n    var HalftoneShader = {\r\n        uniforms: {\r\n            'tDiffuse': { value: null },\r\n            'shape': { value: 1 },\r\n            'radius': { value: 4 },\r\n            'rotateR': { value: Math.PI / 12 * 1 },\r\n            'rotateG': { value: Math.PI / 12 * 2 },\r\n            'rotateB': { value: Math.PI / 12 * 3 },\r\n            'scatter': { value: 0 },\r\n            'width': { value: 1 },\r\n            'height': { value: 1 },\r\n            'blending': { value: 1 },\r\n            'blendingMode': { value: 1 },\r\n            'greyscale': { value: false },\r\n            'disable': { value: false }\r\n        },\r\n        vertexShader: [\r\n            'varying vec2 vUV;',\r\n            'void main() {',\r\n            '\\tvUV = uv;',\r\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            '#define SQRT2_MINUS_ONE 0.41421356',\r\n            '#define SQRT2_HALF_MINUS_ONE 0.20710678',\r\n            '#define PI2 6.28318531',\r\n            '#define SHAPE_DOT 1',\r\n            '#define SHAPE_ELLIPSE 2',\r\n            '#define SHAPE_LINE 3',\r\n            '#define SHAPE_SQUARE 4',\r\n            '#define BLENDING_LINEAR 1',\r\n            '#define BLENDING_MULTIPLY 2',\r\n            '#define BLENDING_ADD 3',\r\n            '#define BLENDING_LIGHTER 4',\r\n            '#define BLENDING_DARKER 5',\r\n            'uniform sampler2D tDiffuse;',\r\n            'uniform float radius;',\r\n            'uniform float rotateR;',\r\n            'uniform float rotateG;',\r\n            'uniform float rotateB;',\r\n            'uniform float scatter;',\r\n            'uniform float width;',\r\n            'uniform float height;',\r\n            'uniform int shape;',\r\n            'uniform bool disable;',\r\n            'uniform float blending;',\r\n            'uniform int blendingMode;',\r\n            'varying vec2 vUV;',\r\n            'uniform bool greyscale;',\r\n            'const int samples = 8;',\r\n            'float blend( float a, float b, float t ) {',\r\n            '\\treturn a * ( 1.0 - t ) + b * t;',\r\n            '}',\r\n            'float hypot( float x, float y ) {',\r\n            '\\treturn sqrt( x * x + y * y );',\r\n            '}',\r\n            'float rand( vec2 seed ){',\r\n            'return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );',\r\n            '}',\r\n            'float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {',\r\n            '\\tfloat dist = hypot( coord.x - p.x, coord.y - p.y );',\r\n            '\\tfloat rad = channel;',\r\n            '\\tif ( shape == SHAPE_DOT ) {',\r\n            '\\t\\trad = pow( abs( rad ), 1.125 ) * rad_max;',\r\n            '\\t} else if ( shape == SHAPE_ELLIPSE ) {',\r\n            '\\t\\trad = pow( abs( rad ), 1.125 ) * rad_max;',\r\n            '\\t\\tif ( dist != 0.0 ) {',\r\n            '\\t\\t\\tfloat dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );',\r\n            '\\t\\t\\tdist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;',\r\n            '\\t\\t}',\r\n            '\\t} else if ( shape == SHAPE_LINE ) {',\r\n            '\\t\\trad = pow( abs( rad ), 1.5) * rad_max;',\r\n            '\\t\\tfloat dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;',\r\n            '\\t\\tdist = hypot( normal.x * dot_p, normal.y * dot_p );',\r\n            '\\t} else if ( shape == SHAPE_SQUARE ) {',\r\n            '\\t\\tfloat theta = atan( p.y - coord.y, p.x - coord.x ) - angle;',\r\n            '\\t\\tfloat sin_t = abs( sin( theta ) );',\r\n            '\\t\\tfloat cos_t = abs( cos( theta ) );',\r\n            '\\t\\trad = pow( abs( rad ), 1.4 );',\r\n            '\\t\\trad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );',\r\n            '\\t}',\r\n            '\\treturn rad - dist;',\r\n            '}',\r\n            'struct Cell {',\r\n            '\\tvec2 normal;',\r\n            '\\tvec2 p1;',\r\n            '\\tvec2 p2;',\r\n            '\\tvec2 p3;',\r\n            '\\tvec2 p4;',\r\n            '\\tfloat samp2;',\r\n            '\\tfloat samp1;',\r\n            '\\tfloat samp3;',\r\n            '\\tfloat samp4;',\r\n            '};',\r\n            'vec4 getSample( vec2 point ) {',\r\n            '\\tvec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );',\r\n            '\\tfloat base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;',\r\n            '\\tfloat step = PI2 / float( samples );',\r\n            '\\tfloat dist = radius * 0.66;',\r\n            '\\tfor ( int i = 0; i < samples; ++i ) {',\r\n            '\\t\\tfloat r = base + step * float( i );',\r\n            '\\t\\tvec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );',\r\n            '\\t\\ttex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );',\r\n            '\\t}',\r\n            '\\ttex /= float( samples ) + 1.0;',\r\n            '\\treturn tex;',\r\n            '}',\r\n            'float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {',\r\n            '\\tfloat dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;',\r\n            '\\tif ( channel == 0 ) {',\r\n            '\\t\\tc.samp1 = getSample( c.p1 ).r;',\r\n            '\\t\\tc.samp2 = getSample( c.p2 ).r;',\r\n            '\\t\\tc.samp3 = getSample( c.p3 ).r;',\r\n            '\\t\\tc.samp4 = getSample( c.p4 ).r;',\r\n            '\\t} else if (channel == 1) {',\r\n            '\\t\\tc.samp1 = getSample( c.p1 ).g;',\r\n            '\\t\\tc.samp2 = getSample( c.p2 ).g;',\r\n            '\\t\\tc.samp3 = getSample( c.p3 ).g;',\r\n            '\\t\\tc.samp4 = getSample( c.p4 ).g;',\r\n            '\\t} else {',\r\n            '\\t\\tc.samp1 = getSample( c.p1 ).b;',\r\n            '\\t\\tc.samp3 = getSample( c.p3 ).b;',\r\n            '\\t\\tc.samp2 = getSample( c.p2 ).b;',\r\n            '\\t\\tc.samp4 = getSample( c.p4 ).b;',\r\n            '\\t}',\r\n            '\\tdist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );',\r\n            '\\tdist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );',\r\n            '\\tdist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );',\r\n            '\\tdist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );',\r\n            '\\tres = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;',\r\n            '\\tres += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;',\r\n            '\\tres += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;',\r\n            '\\tres += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;',\r\n            '\\tres = clamp( res, 0.0, 1.0 );',\r\n            '\\treturn res;',\r\n            '}',\r\n            'Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {',\r\n            '\\tCell c;',\r\n            '\\tvec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );',\r\n            '\\tfloat threshold = step * 0.5;',\r\n            '\\tfloat dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );',\r\n            '\\tfloat dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );',\r\n            '\\tvec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );',\r\n            '\\tfloat offset_normal = mod( hypot( offset.x, offset.y ), step );',\r\n            '\\tfloat normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;',\r\n            '\\tfloat normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;',\r\n            '\\tfloat offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );',\r\n            '\\tfloat line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;',\r\n            '\\tfloat line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;',\r\n            '\\tc.normal = n;',\r\n            '\\tc.p1.x = p.x - n.x * normal_scale + n.y * line_scale;',\r\n            '\\tc.p1.y = p.y - n.y * normal_scale - n.x * line_scale;',\r\n            '\\tif ( scatter != 0.0 ) {',\r\n            '\\t\\tfloat off_mag = scatter * threshold * 0.5;',\r\n            '\\t\\tfloat off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;',\r\n            '\\t\\tc.p1.x += cos( off_angle ) * off_mag;',\r\n            '\\t\\tc.p1.y += sin( off_angle ) * off_mag;',\r\n            '\\t}',\r\n            '\\tfloat normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );',\r\n            '\\tfloat line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );',\r\n            '\\tc.p2.x = c.p1.x - n.x * normal_step;',\r\n            '\\tc.p2.y = c.p1.y - n.y * normal_step;',\r\n            '\\tc.p3.x = c.p1.x + n.y * line_step;',\r\n            '\\tc.p3.y = c.p1.y - n.x * line_step;',\r\n            '\\tc.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;',\r\n            '\\tc.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;',\r\n            '\\treturn c;',\r\n            '}',\r\n            'float blendColour( float a, float b, float t ) {',\r\n            '\\tif ( blendingMode == BLENDING_LINEAR ) {',\r\n            '\\t\\treturn blend( a, b, 1.0 - t );',\r\n            '\\t} else if ( blendingMode == BLENDING_ADD ) {',\r\n            '\\t\\treturn blend( a, min( 1.0, a + b ), t );',\r\n            '\\t} else if ( blendingMode == BLENDING_MULTIPLY ) {',\r\n            '\\t\\treturn blend( a, max( 0.0, a * b ), t );',\r\n            '\\t} else if ( blendingMode == BLENDING_LIGHTER ) {',\r\n            '\\t\\treturn blend( a, max( a, b ), t );',\r\n            '\\t} else if ( blendingMode == BLENDING_DARKER ) {',\r\n            '\\t\\treturn blend( a, min( a, b ), t );',\r\n            '\\t} else {',\r\n            '\\t\\treturn blend( a, b, 1.0 - t );',\r\n            '\\t}',\r\n            '}',\r\n            'void main() {',\r\n            '\\tif ( ! disable ) {',\r\n            '\\t\\tvec2 p = vec2( vUV.x * width, vUV.y * height );',\r\n            '\\t\\tvec2 origin = vec2( 0, 0 );',\r\n            '\\t\\tfloat aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;',\r\n            '\\t\\tCell cell_r = getReferenceCell( p, origin, rotateR, radius );',\r\n            '\\t\\tCell cell_g = getReferenceCell( p, origin, rotateG, radius );',\r\n            '\\t\\tCell cell_b = getReferenceCell( p, origin, rotateB, radius );',\r\n            '\\t\\tfloat r = getDotColour( cell_r, p, 0, rotateR, aa );',\r\n            '\\t\\tfloat g = getDotColour( cell_g, p, 1, rotateG, aa );',\r\n            '\\t\\tfloat b = getDotColour( cell_b, p, 2, rotateB, aa );',\r\n            '\\t\\tvec4 colour = texture2D( tDiffuse, vUV );',\r\n            '\\t\\tr = blendColour( r, colour.r, blending );',\r\n            '\\t\\tg = blendColour( g, colour.g, blending );',\r\n            '\\t\\tb = blendColour( b, colour.b, blending );',\r\n            '\\t\\tif ( greyscale ) {',\r\n            '\\t\\t\\tr = g = b = (r + b + g) / 3.0;',\r\n            '\\t\\t}',\r\n            '\\t\\tgl_FragColor = vec4( r, g, b, 1.0 );',\r\n            '\\t} else {',\r\n            '\\t\\tgl_FragColor = texture2D( tDiffuse, vUV );',\r\n            '\\t}',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    return threex.shaders.HalftoneShader = HalftoneShader;\r\n});"]}