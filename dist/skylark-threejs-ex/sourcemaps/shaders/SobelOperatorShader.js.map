{"version":3,"sources":["shaders/SobelOperatorShader.js"],"names":["define","THREE","threex","SobelOperatorShader","uniforms","tDiffuse","value","resolution","Vector2","vertexShader","join","fragmentShader","shaders"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,GACAC,UACIC,UAAcC,MAAO,MACrBC,YAAgBD,MAAO,IAAIL,EAAMO,UAErCC,cACI,oBACA,gBACA,cACA,8EACA,KACFC,KAAK,MACPC,gBACI,8BACA,2BACA,oBACA,gBACA,iEACA,0DACA,0DACA,yEACA,yEACA,yEACA,yEACA,yEACA,yEACA,yEACA,yEACA,yEACA,8EACA,gEACA,+DACA,8EACA,gEACA,+DACA,qEACA,yCACA,KACFD,KAAK,OAEX,OAAQR,EAAOU,QAAQT,oBAAsBA","file":"../../shaders/SobelOperatorShader.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var SobelOperatorShader = {\r\n        uniforms: {\r\n            'tDiffuse': { value: null },\r\n            'resolution': { value: new THREE.Vector2() }\r\n        },\r\n        vertexShader: [\r\n            'varying vec2 vUv;',\r\n            'void main() {',\r\n            '\\tvUv = uv;',\r\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            'uniform sampler2D tDiffuse;',\r\n            'uniform vec2 resolution;',\r\n            'varying vec2 vUv;',\r\n            'void main() {',\r\n            '\\tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );',\r\n            '\\tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );',\r\n            '\\tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );',\r\n            '\\tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;',\r\n            '\\tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;',\r\n            '\\tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;',\r\n            '\\tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;',\r\n            '\\tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;',\r\n            '\\tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;',\r\n            '\\tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;',\r\n            '\\tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;',\r\n            '\\tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;',\r\n            '\\tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + ',\r\n            '\\t\\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + ',\r\n            '\\t\\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; ',\r\n            '\\tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + ',\r\n            '\\t\\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + ',\r\n            '\\t\\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; ',\r\n            '\\tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );',\r\n            '\\tgl_FragColor = vec4( vec3( G ), 1 );',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    return  threex.shaders.SobelOperatorShader = SobelOperatorShader;\r\n});"]}