{"version":3,"sources":["misc/Ocean.js"],"names":["define","THREE","OceanShaders","Ocean","renderer","camera","scene","options","optionalParameter","value","defaultValue","undefined","this","changed","initial","oceanCamera","OrthographicCamera","position","z","clearColor","Scene","CLEAR_COLOR","geometryOrigin","GEOMETRY_ORIGIN","sunDirectionX","SUN_DIRECTION","sunDirectionY","sunDirectionZ","oceanColor","OCEAN_COLOR","Vector3","skyColor","SKY_COLOR","exposure","EXPOSURE","geometryResolution","GEOMETRY_RESOLUTION","geometrySize","GEOMETRY_SIZE","resolution","RESOLUTION","floatSize","SIZE_OF_FLOAT","windX","INITIAL_WIND","windY","size","INITIAL_SIZE","choppiness","INITIAL_CHOPPINESS","matrixNeedsUpdate","renderTargetType","USE_HALF_FLOAT","HalfFloatType","FloatType","LinearClampParams","minFilter","LinearFilter","magFilter","wrapS","ClampToEdgeWrapping","wrapT","format","RGBAFormat","stencilBuffer","depthBuffer","premultiplyAlpha","type","NearestClampParams","NearestFilter","NearestRepeatParams","RepeatWrapping","initialSpectrumFramebuffer","WebGLRenderTarget","spectrumFramebuffer","pingPhaseFramebuffer","pongPhaseFramebuffer","pingTransformFramebuffer","pongTransformFramebuffer","displacementMapFramebuffer","normalMapFramebuffer","fullscreeenVertexShader","oceanHorizontalShader","oceanHorizontalUniforms","UniformsUtils","clone","uniforms","materialOceanHorizontal","ShaderMaterial","vertexShader","fragmentShader","u_transformSize","u_subtransformSize","u_input","depthTest","oceanVerticalShader","oceanVerticalUniforms","materialOceanVertical","initialSpectrumShader","initialSpectrumUniforms","materialInitialSpectrum","u_wind","Vector2","u_resolution","phaseShader","phaseUniforms","materialPhase","spectrumShader","spectrumUniforms","materialSpectrum","u_initialSpectrum","normalShader","normalUniforms","materialNormal","u_displacementMap","oceanShader","oceanUniforms","materialOcean","u_geometrySize","texture","u_normalMap","u_oceanColor","u_skyColor","u_sunDirection","u_exposure","blending","screenQuad","Mesh","PlaneBufferGeometry","add","generateSeedPhaseTexture","generateMesh","prototype","geometry","rotateX","Math","PI","oceanMesh","render","currentRenderTarget","getRenderTarget","overrideMaterial","renderInitialSpectrum","renderWavePhase","renderSpectrum","renderSpectrumFFT","renderNormalMap","setRenderTarget","pingPhase","phaseArray","window","Float32Array","i","j","random","pingPhaseTexture","DataTexture","set","u_size","clear","material","u_phases","u_deltaTime","deltaTime","u_choppiness","iterations","log","pow"],"mappings":"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","file":"../../misc/Ocean.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"../shaders/OceanShaders\"\n],function(THREE,OceanShaders){\n\t/*\n\t\tthree.js Ocean\n\t*/\n\n\tTHREE.Ocean = function ( renderer, camera, scene, options ) {\n\n\t\t// flag used to trigger parameter changes\n\t\tthis.changed = true;\n\t\tthis.initial = true;\n\n\t\t// Assign required parameters as object properties\n\t\tthis.oceanCamera = new THREE.OrthographicCamera(); //camera.clone();\n\t\tthis.oceanCamera.position.z = 1;\n\t\tthis.renderer = renderer;\n\t\tthis.renderer.clearColor( 0xffffff );\n\n\t\tthis.scene = new THREE.Scene();\n\n\t\t// Assign optional parameters as variables and object properties\n\t\tfunction optionalParameter( value, defaultValue ) {\n\n\t\t\treturn value !== undefined ? value : defaultValue;\n\n\t\t}\n\t\toptions = options || {};\n\t\tthis.clearColor = optionalParameter( options.CLEAR_COLOR, [ 1.0, 1.0, 1.0, 0.0 ] );\n\t\tthis.geometryOrigin = optionalParameter( options.GEOMETRY_ORIGIN, [ - 1000.0, - 1000.0 ] );\n\t\tthis.sunDirectionX = optionalParameter( options.SUN_DIRECTION[ 0 ], - 1.0 );\n\t\tthis.sunDirectionY = optionalParameter( options.SUN_DIRECTION[ 1 ], 1.0 );\n\t\tthis.sunDirectionZ = optionalParameter( options.SUN_DIRECTION[ 2 ], 1.0 );\n\t\tthis.oceanColor = optionalParameter( options.OCEAN_COLOR, new THREE.Vector3( 0.004, 0.016, 0.047 ) );\n\t\tthis.skyColor = optionalParameter( options.SKY_COLOR, new THREE.Vector3( 3.2, 9.6, 12.8 ) );\n\t\tthis.exposure = optionalParameter( options.EXPOSURE, 0.35 );\n\t\tthis.geometryResolution = optionalParameter( options.GEOMETRY_RESOLUTION, 32 );\n\t\tthis.geometrySize = optionalParameter( options.GEOMETRY_SIZE, 2000 );\n\t\tthis.resolution = optionalParameter( options.RESOLUTION, 64 );\n\t\tthis.floatSize = optionalParameter( options.SIZE_OF_FLOAT, 4 );\n\t\tthis.windX = optionalParameter( options.INITIAL_WIND[ 0 ], 10.0 );\n\t\tthis.windY = optionalParameter( options.INITIAL_WIND[ 1 ], 10.0 );\n\t\tthis.size = optionalParameter( options.INITIAL_SIZE, 250.0 );\n\t\tthis.choppiness = optionalParameter( options.INITIAL_CHOPPINESS, 1.5 );\n\n\t\t//\n\t\tthis.matrixNeedsUpdate = false;\n\n\t\t// Setup framebuffer pipeline\n\t\tvar renderTargetType = optionalParameter( options.USE_HALF_FLOAT, false ) ? THREE.HalfFloatType : THREE.FloatType;\n\t\tvar LinearClampParams = {\n\t\t\tminFilter: THREE.LinearFilter,\n\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\twrapS: THREE.ClampToEdgeWrapping,\n\t\t\twrapT: THREE.ClampToEdgeWrapping,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\tstencilBuffer: false,\n\t\t\tdepthBuffer: false,\n\t\t\tpremultiplyAlpha: false,\n\t\t\ttype: renderTargetType\n\t\t};\n\t\tvar NearestClampParams = {\n\t\t\tminFilter: THREE.NearestFilter,\n\t\t\tmagFilter: THREE.NearestFilter,\n\t\t\twrapS: THREE.ClampToEdgeWrapping,\n\t\t\twrapT: THREE.ClampToEdgeWrapping,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\tstencilBuffer: false,\n\t\t\tdepthBuffer: false,\n\t\t\tpremultiplyAlpha: false,\n\t\t\ttype: renderTargetType\n\t\t};\n\t\tvar NearestRepeatParams = {\n\t\t\tminFilter: THREE.NearestFilter,\n\t\t\tmagFilter: THREE.NearestFilter,\n\t\t\twrapS: THREE.RepeatWrapping,\n\t\t\twrapT: THREE.RepeatWrapping,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\tstencilBuffer: false,\n\t\t\tdepthBuffer: false,\n\t\t\tpremultiplyAlpha: false,\n\t\t\ttype: renderTargetType\n\t\t};\n\t\tthis.initialSpectrumFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, NearestRepeatParams );\n\t\tthis.spectrumFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );\n\t\tthis.pingPhaseFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );\n\t\tthis.pongPhaseFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );\n\t\tthis.pingTransformFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );\n\t\tthis.pongTransformFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, NearestClampParams );\n\t\tthis.displacementMapFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, LinearClampParams );\n\t\tthis.normalMapFramebuffer = new THREE.WebGLRenderTarget( this.resolution, this.resolution, LinearClampParams );\n\n\t\t// Define shaders and constant uniforms\n\t\t////////////////////////////////////////\n\n\t\t// 0 - The vertex shader used in all of the simulation steps\n\t\tvar fullscreeenVertexShader = THREE.OceanShaders[ \"ocean_sim_vertex\" ];\n\n\t\t// 1 - Horizontal wave vertices used for FFT\n\t\tvar oceanHorizontalShader = THREE.OceanShaders[ \"ocean_subtransform\" ];\n\t\tvar oceanHorizontalUniforms = THREE.UniformsUtils.clone( oceanHorizontalShader.uniforms );\n\t\tthis.materialOceanHorizontal = new THREE.ShaderMaterial( {\n\t\t\tuniforms: oceanHorizontalUniforms,\n\t\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\t\tfragmentShader: \"#define HORIZONTAL \\n\" + oceanHorizontalShader.fragmentShader\n\t\t} );\n\t\tthis.materialOceanHorizontal.uniforms.u_transformSize = { value: this.resolution };\n\t\tthis.materialOceanHorizontal.uniforms.u_subtransformSize = { value: null };\n\t\tthis.materialOceanHorizontal.uniforms.u_input = { value: null };\n\t\tthis.materialOceanHorizontal.depthTest = false;\n\n\t\t// 2 - Vertical wave vertices used for FFT\n\t\tvar oceanVerticalShader = THREE.OceanShaders[ \"ocean_subtransform\" ];\n\t\tvar oceanVerticalUniforms = THREE.UniformsUtils.clone( oceanVerticalShader.uniforms );\n\t\tthis.materialOceanVertical = new THREE.ShaderMaterial( {\n\t\t\tuniforms: oceanVerticalUniforms,\n\t\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\t\tfragmentShader: oceanVerticalShader.fragmentShader\n\t\t} );\n\t\tthis.materialOceanVertical.uniforms.u_transformSize = { value: this.resolution };\n\t\tthis.materialOceanVertical.uniforms.u_subtransformSize = { value: null };\n\t\tthis.materialOceanVertical.uniforms.u_input = { value: null };\n\t\tthis.materialOceanVertical.depthTest = false;\n\n\t\t// 3 - Initial spectrum used to generate height map\n\t\tvar initialSpectrumShader = THREE.OceanShaders[ \"ocean_initial_spectrum\" ];\n\t\tvar initialSpectrumUniforms = THREE.UniformsUtils.clone( initialSpectrumShader.uniforms );\n\t\tthis.materialInitialSpectrum = new THREE.ShaderMaterial( {\n\t\t\tuniforms: initialSpectrumUniforms,\n\t\t\tvertexShader: initialSpectrumShader.vertexShader,\n\t\t\tfragmentShader: initialSpectrumShader.fragmentShader\n\t\t} );\n\t\tthis.materialInitialSpectrum.uniforms.u_wind = { value: new THREE.Vector2() };\n\t\tthis.materialInitialSpectrum.uniforms.u_resolution = { value: this.resolution };\n\t\tthis.materialInitialSpectrum.depthTest = false;\n\n\t\t// 4 - Phases used to animate heightmap\n\t\tvar phaseShader = THREE.OceanShaders[ \"ocean_phase\" ];\n\t\tvar phaseUniforms = THREE.UniformsUtils.clone( phaseShader.uniforms );\n\t\tthis.materialPhase = new THREE.ShaderMaterial( {\n\t\t\tuniforms: phaseUniforms,\n\t\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\t\tfragmentShader: phaseShader.fragmentShader\n\t\t} );\n\t\tthis.materialPhase.uniforms.u_resolution = { value: this.resolution };\n\t\tthis.materialPhase.depthTest = false;\n\n\t\t// 5 - Shader used to update spectrum\n\t\tvar spectrumShader = THREE.OceanShaders[ \"ocean_spectrum\" ];\n\t\tvar spectrumUniforms = THREE.UniformsUtils.clone( spectrumShader.uniforms );\n\t\tthis.materialSpectrum = new THREE.ShaderMaterial( {\n\t\t\tuniforms: spectrumUniforms,\n\t\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\t\tfragmentShader: spectrumShader.fragmentShader\n\t\t} );\n\t\tthis.materialSpectrum.uniforms.u_initialSpectrum = { value: null };\n\t\tthis.materialSpectrum.uniforms.u_resolution = { value: this.resolution };\n\t\tthis.materialSpectrum.depthTest = false;\n\n\t\t// 6 - Shader used to update spectrum normals\n\t\tvar normalShader = THREE.OceanShaders[ \"ocean_normals\" ];\n\t\tvar normalUniforms = THREE.UniformsUtils.clone( normalShader.uniforms );\n\t\tthis.materialNormal = new THREE.ShaderMaterial( {\n\t\t\tuniforms: normalUniforms,\n\t\t\tvertexShader: fullscreeenVertexShader.vertexShader,\n\t\t\tfragmentShader: normalShader.fragmentShader\n\t\t} );\n\t\tthis.materialNormal.uniforms.u_displacementMap = { value: null };\n\t\tthis.materialNormal.uniforms.u_resolution = { value: this.resolution };\n\t\tthis.materialNormal.depthTest = false;\n\n\t\t// 7 - Shader used to update normals\n\t\tvar oceanShader = THREE.OceanShaders[ \"ocean_main\" ];\n\t\tvar oceanUniforms = THREE.UniformsUtils.clone( oceanShader.uniforms );\n\t\tthis.materialOcean = new THREE.ShaderMaterial( {\n\t\t\tuniforms: oceanUniforms,\n\t\t\tvertexShader: oceanShader.vertexShader,\n\t\t\tfragmentShader: oceanShader.fragmentShader\n\t\t} );\n\t\t// this.materialOcean.wireframe = true;\n\t\tthis.materialOcean.uniforms.u_geometrySize = { value: this.resolution };\n\t\tthis.materialOcean.uniforms.u_displacementMap = { value: this.displacementMapFramebuffer.texture };\n\t\tthis.materialOcean.uniforms.u_normalMap = { value: this.normalMapFramebuffer.texture };\n\t\tthis.materialOcean.uniforms.u_oceanColor = { value: this.oceanColor };\n\t\tthis.materialOcean.uniforms.u_skyColor = { value: this.skyColor };\n\t\tthis.materialOcean.uniforms.u_sunDirection = { value: new THREE.Vector3( this.sunDirectionX, this.sunDirectionY, this.sunDirectionZ ) };\n\t\tthis.materialOcean.uniforms.u_exposure = { value: this.exposure };\n\n\t\t// Disable blending to prevent default premultiplied alpha values\n\t\tthis.materialOceanHorizontal.blending = 0;\n\t\tthis.materialOceanVertical.blending = 0;\n\t\tthis.materialInitialSpectrum.blending = 0;\n\t\tthis.materialPhase.blending = 0;\n\t\tthis.materialSpectrum.blending = 0;\n\t\tthis.materialNormal.blending = 0;\n\t\tthis.materialOcean.blending = 0;\n\n\t\t// Create the simulation plane\n\t\tthis.screenQuad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ) );\n\t\tthis.scene.add( this.screenQuad );\n\n\t\t// Initialise spectrum data\n\t\tthis.generateSeedPhaseTexture();\n\n\t\t// Generate the ocean mesh\n\t\tthis.generateMesh();\n\n\t};\n\n\tTHREE.Ocean.prototype.generateMesh = function () {\n\n\t\tvar geometry = new THREE.PlaneBufferGeometry( this.geometrySize, this.geometrySize, this.geometryResolution, this.geometryResolution );\n\n\t\tgeometry.rotateX( - Math.PI / 2 );\n\n\t\tthis.oceanMesh = new THREE.Mesh( geometry, this.materialOcean );\n\n\t};\n\n\tTHREE.Ocean.prototype.render = function () {\n\n\t\tvar currentRenderTarget = this.renderer.getRenderTarget();\n\n\t\tthis.scene.overrideMaterial = null;\n\n\t\tif ( this.changed )\n\t\t\tthis.renderInitialSpectrum();\n\n\t\tthis.renderWavePhase();\n\t\tthis.renderSpectrum();\n\t\tthis.renderSpectrumFFT();\n\t\tthis.renderNormalMap();\n\t\tthis.scene.overrideMaterial = null;\n\n\t\tthis.renderer.setRenderTarget( currentRenderTarget );\n\n\t};\n\n\tTHREE.Ocean.prototype.generateSeedPhaseTexture = function () {\n\n\t\t// Setup the seed texture\n\t\tthis.pingPhase = true;\n\t\tvar phaseArray = new window.Float32Array( this.resolution * this.resolution * 4 );\n\t\tfor ( var i = 0; i < this.resolution; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < this.resolution; j ++ ) {\n\n\t\t\t\tphaseArray[ i * this.resolution * 4 + j * 4 ] = Math.random() * 2.0 * Math.PI;\n\t\t\t\tphaseArray[ i * this.resolution * 4 + j * 4 + 1 ] = 0.0;\n\t\t\t\tphaseArray[ i * this.resolution * 4 + j * 4 + 2 ] = 0.0;\n\t\t\t\tphaseArray[ i * this.resolution * 4 + j * 4 + 3 ] = 0.0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.pingPhaseTexture = new THREE.DataTexture( phaseArray, this.resolution, this.resolution, THREE.RGBAFormat );\n\t\tthis.pingPhaseTexture.wrapS = THREE.ClampToEdgeWrapping;\n\t\tthis.pingPhaseTexture.wrapT = THREE.ClampToEdgeWrapping;\n\t\tthis.pingPhaseTexture.type = THREE.FloatType;\n\n\t};\n\n\tTHREE.Ocean.prototype.renderInitialSpectrum = function () {\n\n\t\tthis.scene.overrideMaterial = this.materialInitialSpectrum;\n\t\tthis.materialInitialSpectrum.uniforms.u_wind.value.set( this.windX, this.windY );\n\t\tthis.materialInitialSpectrum.uniforms.u_size.value = this.size;\n\n\t\tthis.renderer.setRenderTarget( this.initialSpectrumFramebuffer );\n\t\tthis.renderer.clear();\n\t\tthis.renderer.render( this.scene, this.oceanCamera );\n\n\t};\n\n\tTHREE.Ocean.prototype.renderWavePhase = function () {\n\n\t\tthis.scene.overrideMaterial = this.materialPhase;\n\t\tthis.screenQuad.material = this.materialPhase;\n\t\tif ( this.initial ) {\n\n\t\t\tthis.materialPhase.uniforms.u_phases.value = this.pingPhaseTexture;\n\t\t\tthis.initial = false;\n\n\t\t} else {\n\n\t\t\tthis.materialPhase.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer.texture : this.pongPhaseFramebuffer.texture;\n\n\t\t}\n\t\tthis.materialPhase.uniforms.u_deltaTime.value = this.deltaTime;\n\t\tthis.materialPhase.uniforms.u_size.value = this.size;\n\t\tthis.renderer.setRenderTarget( this.pingPhase ? this.pongPhaseFramebuffer : this.pingPhaseFramebuffer );\n\t\tthis.renderer.render( this.scene, this.oceanCamera );\n\t\tthis.pingPhase = ! this.pingPhase;\n\n\t};\n\n\tTHREE.Ocean.prototype.renderSpectrum = function () {\n\n\t\tthis.scene.overrideMaterial = this.materialSpectrum;\n\t\tthis.materialSpectrum.uniforms.u_initialSpectrum.value = this.initialSpectrumFramebuffer.texture;\n\t\tthis.materialSpectrum.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer.texture : this.pongPhaseFramebuffer.texture;\n\t\tthis.materialSpectrum.uniforms.u_choppiness.value = this.choppiness;\n\t\tthis.materialSpectrum.uniforms.u_size.value = this.size;\n\n\t\tthis.renderer.setRenderTarget( this.spectrumFramebuffer );\n\t\tthis.renderer.render( this.scene, this.oceanCamera );\n\n\t};\n\n\tTHREE.Ocean.prototype.renderSpectrumFFT = function () {\n\n\t\t// GPU FFT using Stockham formulation\n\t\tvar iterations = Math.log( this.resolution ) / Math.log( 2 ); // log2\n\n\t\tthis.scene.overrideMaterial = this.materialOceanHorizontal;\n\n\t\tfor ( var i = 0; i < iterations; i ++ ) {\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tthis.materialOceanHorizontal.uniforms.u_input.value = this.spectrumFramebuffer.texture;\n\t\t\t\tthis.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\n\t\t\t\tthis.renderer.setRenderTarget( this.pingTransformFramebuffer );\n\t\t\t\tthis.renderer.render( this.scene, this.oceanCamera );\n\n\t\t\t} else if ( i % 2 === 1 ) {\n\n\t\t\t\tthis.materialOceanHorizontal.uniforms.u_input.value = this.pingTransformFramebuffer.texture;\n\t\t\t\tthis.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\n\t\t\t\tthis.renderer.setRenderTarget( this.pongTransformFramebuffer );\n\t\t\t\tthis.renderer.render( this.scene, this.oceanCamera );\n\n\t\t\t} else {\n\n\t\t\t\tthis.materialOceanHorizontal.uniforms.u_input.value = this.pongTransformFramebuffer.texture;\n\t\t\t\tthis.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\n\t\t\t\tthis.renderer.setRenderTarget( this.pingTransformFramebuffer );\n\t\t\t\tthis.renderer.render( this.scene, this.oceanCamera );\n\n\t\t\t}\n\n\t\t}\n\t\tthis.scene.overrideMaterial = this.materialOceanVertical;\n\t\tfor ( var i = iterations; i < iterations * 2; i ++ ) {\n\n\t\t\tif ( i === iterations * 2 - 1 ) {\n\n\t\t\t\tthis.materialOceanVertical.uniforms.u_input.value = ( iterations % 2 === 0 ) ? this.pingTransformFramebuffer.texture : this.pongTransformFramebuffer.texture;\n\t\t\t\tthis.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\n\t\t\t\tthis.renderer.setRenderTarget( this.displacementMapFramebuffer );\n\t\t\t\tthis.renderer.render( this.scene, this.oceanCamera );\n\n\t\t\t} else if ( i % 2 === 1 ) {\n\n\t\t\t\tthis.materialOceanVertical.uniforms.u_input.value = this.pingTransformFramebuffer.texture;\n\t\t\t\tthis.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\n\t\t\t\tthis.renderer.setRenderTarget( this.pongTransformFramebuffer );\n\t\t\t\tthis.renderer.render( this.scene, this.oceanCamera );\n\n\t\t\t} else {\n\n\t\t\t\tthis.materialOceanVertical.uniforms.u_input.value = this.pongTransformFramebuffer.texture;\n\t\t\t\tthis.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );\n\n\t\t\t\tthis.renderer.setRenderTarget( this.pingTransformFramebuffer );\n\t\t\t\tthis.renderer.render( this.scene, this.oceanCamera );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tTHREE.Ocean.prototype.renderNormalMap = function () {\n\n\t\tthis.scene.overrideMaterial = this.materialNormal;\n\t\tif ( this.changed ) this.materialNormal.uniforms.u_size.value = this.size;\n\t\tthis.materialNormal.uniforms.u_displacementMap.value = this.displacementMapFramebuffer.texture;\n\n\t\tthis.renderer.setRenderTarget( this.normalMapFramebuffer );\n\t\tthis.renderer.clear();\n\t\tthis.renderer.render( this.scene, this.oceanCamera );\n\n\t};\n\t\n\treturn THREE.Ocean;\n});\n"]}