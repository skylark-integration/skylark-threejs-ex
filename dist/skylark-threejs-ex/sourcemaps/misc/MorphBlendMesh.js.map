{"version":3,"sources":["misc/MorphBlendMesh.js"],"names":["define","THREE","threex","MorphBlendMesh","geometry","material","Mesh","call","this","animationsMap","animationsList","numFrames","Object","keys","morphTargetDictionary","length","endFrame","fps","createAnimation","setAnimationWeight","prototype","assign","create","constructor","name","start","end","animation","duration","lastFrame","currentFrame","active","time","direction","weight","directionBackwards","mirroredLoop","push","autoCreateAnimations","firstAnimation","pattern","frameRanges","i","key","chunks","match","Infinity","range","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","console","warn","stopAnimation","update","delta","il","frameTime","keyframe","MathUtils","clamp","Math","floor","morphTargetInfluences","mix","misc"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,EAAiB,SAAUC,EAAUC,GACrCJ,EAAMK,KAAKC,KAAKC,KAAMJ,EAAUC,GAChCG,KAAKC,iBACLD,KAAKE,kBACL,IAAIC,EAAYC,OAAOC,KAAKL,KAAKM,uBAAuBC,OAGpDC,EAAWL,EAAY,EACvBM,EAAMN,EAAY,EACtBH,KAAKU,gBAJM,YACM,EAGsBF,EAAUC,GACjDT,KAAKW,mBALM,YAKmB,IAyKlC,OAvKAhB,EAAeiB,UAAYR,OAAOS,OAAOT,OAAOU,OAAOrB,EAAMK,KAAKc,YAC9DG,YAAapB,EACbe,gBAAiB,SAAUM,EAAMC,EAAOC,EAAKT,GACzC,IAAIU,GACAF,MAAOA,EACPC,IAAKA,EACLX,OAAQW,EAAMD,EAAQ,EACtBR,IAAKA,EACLW,UAAWF,EAAMD,GAASR,EAC1BY,UAAW,EACXC,aAAc,EACdC,QAAQ,EACRC,KAAM,EACNC,UAAW,EACXC,OAAQ,EACRC,oBAAoB,EACpBC,cAAc,GAElB5B,KAAKC,cAAce,GAAQG,EAC3BnB,KAAKE,eAAe2B,KAAKV,IAE7BW,qBAAsB,SAAUrB,GAC5B,IACIsB,EADAC,EAAU,mBACMC,KAChBC,EAAI,EACR,IAAK,IAAIC,KAAOnC,KAAKM,sBAAuB,CACxC,IAAI8B,EAASD,EAAIE,MAAML,GACvB,GAAII,GAAUA,EAAO7B,OAAS,EAErB0B,EADDjB,EAAOoB,EAAO,MAEdH,EAAYjB,IACRC,MAAOqB,EAAAA,EACPpB,KAAMoB,EAAAA,IAGVJ,GADAK,EAAQN,EAAYjB,IACVC,QACVsB,EAAMtB,MAAQiB,GACdA,EAAIK,EAAMrB,MACVqB,EAAMrB,IAAMgB,GACXH,IACDA,EAAiBf,GAEzBkB,IAEJ,IAAK,IAAIlB,KAAQiB,EAAa,CAC1B,IAAIM,EAAQN,EAAYjB,GACxBhB,KAAKU,gBAAgBM,EAAMuB,EAAMtB,MAAOsB,EAAMrB,IAAKT,GAEvDT,KAAK+B,eAAiBA,GAE1BS,6BAA8B,SAAUxB,GACpC,IAAIG,EAAYnB,KAAKC,cAAce,GAC/BG,IACAA,EAAUM,UAAY,EACtBN,EAAUQ,oBAAqB,IAGvCc,8BAA+B,SAAUzB,GACrC,IAAIG,EAAYnB,KAAKC,cAAce,GAC/BG,IACAA,EAAUM,WAAa,EACvBN,EAAUQ,oBAAqB,IAGvCe,gBAAiB,SAAU1B,EAAMP,GAC7B,IAAIU,EAAYnB,KAAKC,cAAce,GAC/BG,IACAA,EAAUV,IAAMA,EAChBU,EAAUC,UAAYD,EAAUD,IAAMC,EAAUF,OAASE,EAAUV,MAG3EkC,qBAAsB,SAAU3B,EAAMI,GAClC,IAAID,EAAYnB,KAAKC,cAAce,GAC/BG,IACAA,EAAUC,SAAWA,EACrBD,EAAUV,KAAOU,EAAUD,IAAMC,EAAUF,OAASE,EAAUC,WAGtET,mBAAoB,SAAUK,EAAMU,GAChC,IAAIP,EAAYnB,KAAKC,cAAce,GAC/BG,IACAA,EAAUO,OAASA,IAG3BkB,iBAAkB,SAAU5B,EAAMQ,GAC9B,IAAIL,EAAYnB,KAAKC,cAAce,GAC/BG,IACAA,EAAUK,KAAOA,IAGzBqB,iBAAkB,SAAU7B,GACxB,IAAIQ,EAAO,EACPL,EAAYnB,KAAKC,cAAce,GAInC,OAHIG,IACAK,EAAOL,EAAUK,MAEdA,GAEXsB,qBAAsB,SAAU9B,GAC5B,IAAII,GAAY,EACZD,EAAYnB,KAAKC,cAAce,GAInC,OAHIG,IACAC,EAAWD,EAAUC,UAElBA,GAEX2B,cAAe,SAAU/B,GACrB,IAAIG,EAAYnB,KAAKC,cAAce,GAC/BG,GACAA,EAAUK,KAAO,EACjBL,EAAUI,QAAS,GAEnByB,QAAQC,KAAK,6BAA+BjC,EAAO,oCAG3DkC,cAAe,SAAUlC,GACrB,IAAIG,EAAYnB,KAAKC,cAAce,GAC/BG,IACAA,EAAUI,QAAS,IAG3B4B,OAAQ,SAAUC,GACd,IAAK,IAAIlB,EAAI,EAAGmB,EAAKrD,KAAKE,eAAeK,OAAQ2B,EAAImB,EAAInB,IAAK,CAC1D,IAAIf,EAAYnB,KAAKE,eAAegC,GACpC,GAAKf,EAAUI,OAAf,CAEA,IAAI+B,EAAYnC,EAAUC,SAAWD,EAAUZ,OAC/CY,EAAUK,MAAQL,EAAUM,UAAY2B,EACpCjC,EAAUS,cACNT,EAAUK,KAAOL,EAAUC,UAAYD,EAAUK,KAAO,KACxDL,EAAUM,YAAc,EACpBN,EAAUK,KAAOL,EAAUC,WAC3BD,EAAUK,KAAOL,EAAUC,SAC3BD,EAAUQ,oBAAqB,GAE/BR,EAAUK,KAAO,IACjBL,EAAUK,KAAO,EACjBL,EAAUQ,oBAAqB,KAIvCR,EAAUK,KAAOL,EAAUK,KAAOL,EAAUC,SACxCD,EAAUK,KAAO,IACjBL,EAAUK,MAAQL,EAAUC,WAEpC,IAAImC,EAAWpC,EAAUF,MAAQxB,EAAM+D,UAAUC,MAAMC,KAAKC,MAAMxC,EAAUK,KAAO8B,GAAY,EAAGnC,EAAUZ,OAAS,GACjHmB,EAASP,EAAUO,OACnB6B,IAAapC,EAAUG,eACvBtB,KAAK4D,sBAAsBzC,EAAUE,WAAa,EAClDrB,KAAK4D,sBAAsBzC,EAAUG,cAAgB,EAAII,EACzD1B,KAAK4D,sBAAsBL,GAAY,EACvCpC,EAAUE,UAAYF,EAAUG,aAChCH,EAAUG,aAAeiC,GAE7B,IAAIM,EAAM1C,EAAUK,KAAO8B,EAAYA,EACnCnC,EAAUQ,qBACVkC,EAAM,EAAIA,GACV1C,EAAUG,eAAiBH,EAAUE,WACrCrB,KAAK4D,sBAAsBzC,EAAUG,cAAgBuC,EAAMnC,EAC3D1B,KAAK4D,sBAAsBzC,EAAUE,YAAc,EAAIwC,GAAOnC,GAE9D1B,KAAK4D,sBAAsBzC,EAAUG,cAAgBI,OAM9DhC,EAAOoE,KAAKnE,eAAiBA","file":"../../misc/MorphBlendMesh.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var MorphBlendMesh = function (geometry, material) {\r\n        THREE.Mesh.call(this, geometry, material);\r\n        this.animationsMap = {};\r\n        this.animationsList = [];\r\n        var numFrames = Object.keys(this.morphTargetDictionary).length;\r\n        var name = '__default';\r\n        var startFrame = 0;\r\n        var endFrame = numFrames - 1;\r\n        var fps = numFrames / 1;\r\n        this.createAnimation(name, startFrame, endFrame, fps);\r\n        this.setAnimationWeight(name, 1);\r\n    };\r\n    MorphBlendMesh.prototype = Object.assign(Object.create(THREE.Mesh.prototype), {\r\n        constructor: MorphBlendMesh,\r\n        createAnimation: function (name, start, end, fps) {\r\n            var animation = {\r\n                start: start,\r\n                end: end,\r\n                length: end - start + 1,\r\n                fps: fps,\r\n                duration: (end - start) / fps,\r\n                lastFrame: 0,\r\n                currentFrame: 0,\r\n                active: false,\r\n                time: 0,\r\n                direction: 1,\r\n                weight: 1,\r\n                directionBackwards: false,\r\n                mirroredLoop: false\r\n            };\r\n            this.animationsMap[name] = animation;\r\n            this.animationsList.push(animation);\r\n        },\r\n        autoCreateAnimations: function (fps) {\r\n            var pattern = /([a-z]+)_?(\\d+)/i;\r\n            var firstAnimation, frameRanges = {};\r\n            var i = 0;\r\n            for (var key in this.morphTargetDictionary) {\r\n                var chunks = key.match(pattern);\r\n                if (chunks && chunks.length > 1) {\r\n                    var name = chunks[1];\r\n                    if (!frameRanges[name])\r\n                        frameRanges[name] = {\r\n                            start: Infinity,\r\n                            end: -Infinity\r\n                        };\r\n                    var range = frameRanges[name];\r\n                    if (i < range.start)\r\n                        range.start = i;\r\n                    if (i > range.end)\r\n                        range.end = i;\r\n                    if (!firstAnimation)\r\n                        firstAnimation = name;\r\n                }\r\n                i++;\r\n            }\r\n            for (var name in frameRanges) {\r\n                var range = frameRanges[name];\r\n                this.createAnimation(name, range.start, range.end, fps);\r\n            }\r\n            this.firstAnimation = firstAnimation;\r\n        },\r\n        setAnimationDirectionForward: function (name) {\r\n            var animation = this.animationsMap[name];\r\n            if (animation) {\r\n                animation.direction = 1;\r\n                animation.directionBackwards = false;\r\n            }\r\n        },\r\n        setAnimationDirectionBackward: function (name) {\r\n            var animation = this.animationsMap[name];\r\n            if (animation) {\r\n                animation.direction = -1;\r\n                animation.directionBackwards = true;\r\n            }\r\n        },\r\n        setAnimationFPS: function (name, fps) {\r\n            var animation = this.animationsMap[name];\r\n            if (animation) {\r\n                animation.fps = fps;\r\n                animation.duration = (animation.end - animation.start) / animation.fps;\r\n            }\r\n        },\r\n        setAnimationDuration: function (name, duration) {\r\n            var animation = this.animationsMap[name];\r\n            if (animation) {\r\n                animation.duration = duration;\r\n                animation.fps = (animation.end - animation.start) / animation.duration;\r\n            }\r\n        },\r\n        setAnimationWeight: function (name, weight) {\r\n            var animation = this.animationsMap[name];\r\n            if (animation) {\r\n                animation.weight = weight;\r\n            }\r\n        },\r\n        setAnimationTime: function (name, time) {\r\n            var animation = this.animationsMap[name];\r\n            if (animation) {\r\n                animation.time = time;\r\n            }\r\n        },\r\n        getAnimationTime: function (name) {\r\n            var time = 0;\r\n            var animation = this.animationsMap[name];\r\n            if (animation) {\r\n                time = animation.time;\r\n            }\r\n            return time;\r\n        },\r\n        getAnimationDuration: function (name) {\r\n            var duration = -1;\r\n            var animation = this.animationsMap[name];\r\n            if (animation) {\r\n                duration = animation.duration;\r\n            }\r\n            return duration;\r\n        },\r\n        playAnimation: function (name) {\r\n            var animation = this.animationsMap[name];\r\n            if (animation) {\r\n                animation.time = 0;\r\n                animation.active = true;\r\n            } else {\r\n                console.warn('MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');\r\n            }\r\n        },\r\n        stopAnimation: function (name) {\r\n            var animation = this.animationsMap[name];\r\n            if (animation) {\r\n                animation.active = false;\r\n            }\r\n        },\r\n        update: function (delta) {\r\n            for (var i = 0, il = this.animationsList.length; i < il; i++) {\r\n                var animation = this.animationsList[i];\r\n                if (!animation.active)\r\n                    continue;\r\n                var frameTime = animation.duration / animation.length;\r\n                animation.time += animation.direction * delta;\r\n                if (animation.mirroredLoop) {\r\n                    if (animation.time > animation.duration || animation.time < 0) {\r\n                        animation.direction *= -1;\r\n                        if (animation.time > animation.duration) {\r\n                            animation.time = animation.duration;\r\n                            animation.directionBackwards = true;\r\n                        }\r\n                        if (animation.time < 0) {\r\n                            animation.time = 0;\r\n                            animation.directionBackwards = false;\r\n                        }\r\n                    }\r\n                } else {\r\n                    animation.time = animation.time % animation.duration;\r\n                    if (animation.time < 0)\r\n                        animation.time += animation.duration;\r\n                }\r\n                var keyframe = animation.start + THREE.MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\r\n                var weight = animation.weight;\r\n                if (keyframe !== animation.currentFrame) {\r\n                    this.morphTargetInfluences[animation.lastFrame] = 0;\r\n                    this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\r\n                    this.morphTargetInfluences[keyframe] = 0;\r\n                    animation.lastFrame = animation.currentFrame;\r\n                    animation.currentFrame = keyframe;\r\n                }\r\n                var mix = animation.time % frameTime / frameTime;\r\n                if (animation.directionBackwards)\r\n                    mix = 1 - mix;\r\n                if (animation.currentFrame !== animation.lastFrame) {\r\n                    this.morphTargetInfluences[animation.currentFrame] = mix * weight;\r\n                    this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\r\n                } else {\r\n                    this.morphTargetInfluences[animation.currentFrame] = weight;\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    return threex.misc.MorphBlendMesh = MorphBlendMesh;\r\n});"]}