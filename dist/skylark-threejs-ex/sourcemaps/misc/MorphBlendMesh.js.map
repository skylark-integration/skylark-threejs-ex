{"version":3,"sources":["misc/MorphBlendMesh.js"],"names":["define","THREE","MorphBlendMesh","geometry","material","Mesh","call","this","animationsMap","animationsList","numFrames","Object","keys","morphTargetDictionary","length","endFrame","fps","createAnimation","setAnimationWeight","prototype","assign","create","constructor","name","start","end","animation","duration","lastFrame","currentFrame","active","time","direction","weight","directionBackwards","mirroredLoop","push","autoCreateAnimations","firstAnimation","pattern","frameRanges","i","key","chunks","match","Infinity","range","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","console","warn","stopAnimation","update","delta","il","frameTime","keyframe","MathUtils","clamp","Math","floor","morphTargetInfluences","mix"],"mappings":"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","file":"../../misc/MorphBlendMesh.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var MorphBlendMesh = function (geometry, material) {\n        THREE.Mesh.call(this, geometry, material);\n        this.animationsMap = {};\n        this.animationsList = [];\n        var numFrames = Object.keys(this.morphTargetDictionary).length;\n        var name = '__default';\n        var startFrame = 0;\n        var endFrame = numFrames - 1;\n        var fps = numFrames / 1;\n        this.createAnimation(name, startFrame, endFrame, fps);\n        this.setAnimationWeight(name, 1);\n    };\n    MorphBlendMesh.prototype = Object.assign(Object.create(THREE.Mesh.prototype), {\n        constructor: MorphBlendMesh,\n        createAnimation: function (name, start, end, fps) {\n            var animation = {\n                start: start,\n                end: end,\n                length: end - start + 1,\n                fps: fps,\n                duration: (end - start) / fps,\n                lastFrame: 0,\n                currentFrame: 0,\n                active: false,\n                time: 0,\n                direction: 1,\n                weight: 1,\n                directionBackwards: false,\n                mirroredLoop: false\n            };\n            this.animationsMap[name] = animation;\n            this.animationsList.push(animation);\n        },\n        autoCreateAnimations: function (fps) {\n            var pattern = /([a-z]+)_?(\\d+)/i;\n            var firstAnimation, frameRanges = {};\n            var i = 0;\n            for (var key in this.morphTargetDictionary) {\n                var chunks = key.match(pattern);\n                if (chunks && chunks.length > 1) {\n                    var name = chunks[1];\n                    if (!frameRanges[name])\n                        frameRanges[name] = {\n                            start: Infinity,\n                            end: -Infinity\n                        };\n                    var range = frameRanges[name];\n                    if (i < range.start)\n                        range.start = i;\n                    if (i > range.end)\n                        range.end = i;\n                    if (!firstAnimation)\n                        firstAnimation = name;\n                }\n                i++;\n            }\n            for (var name in frameRanges) {\n                var range = frameRanges[name];\n                this.createAnimation(name, range.start, range.end, fps);\n            }\n            this.firstAnimation = firstAnimation;\n        },\n        setAnimationDirectionForward: function (name) {\n            var animation = this.animationsMap[name];\n            if (animation) {\n                animation.direction = 1;\n                animation.directionBackwards = false;\n            }\n        },\n        setAnimationDirectionBackward: function (name) {\n            var animation = this.animationsMap[name];\n            if (animation) {\n                animation.direction = -1;\n                animation.directionBackwards = true;\n            }\n        },\n        setAnimationFPS: function (name, fps) {\n            var animation = this.animationsMap[name];\n            if (animation) {\n                animation.fps = fps;\n                animation.duration = (animation.end - animation.start) / animation.fps;\n            }\n        },\n        setAnimationDuration: function (name, duration) {\n            var animation = this.animationsMap[name];\n            if (animation) {\n                animation.duration = duration;\n                animation.fps = (animation.end - animation.start) / animation.duration;\n            }\n        },\n        setAnimationWeight: function (name, weight) {\n            var animation = this.animationsMap[name];\n            if (animation) {\n                animation.weight = weight;\n            }\n        },\n        setAnimationTime: function (name, time) {\n            var animation = this.animationsMap[name];\n            if (animation) {\n                animation.time = time;\n            }\n        },\n        getAnimationTime: function (name) {\n            var time = 0;\n            var animation = this.animationsMap[name];\n            if (animation) {\n                time = animation.time;\n            }\n            return time;\n        },\n        getAnimationDuration: function (name) {\n            var duration = -1;\n            var animation = this.animationsMap[name];\n            if (animation) {\n                duration = animation.duration;\n            }\n            return duration;\n        },\n        playAnimation: function (name) {\n            var animation = this.animationsMap[name];\n            if (animation) {\n                animation.time = 0;\n                animation.active = true;\n            } else {\n                console.warn('MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');\n            }\n        },\n        stopAnimation: function (name) {\n            var animation = this.animationsMap[name];\n            if (animation) {\n                animation.active = false;\n            }\n        },\n        update: function (delta) {\n            for (var i = 0, il = this.animationsList.length; i < il; i++) {\n                var animation = this.animationsList[i];\n                if (!animation.active)\n                    continue;\n                var frameTime = animation.duration / animation.length;\n                animation.time += animation.direction * delta;\n                if (animation.mirroredLoop) {\n                    if (animation.time > animation.duration || animation.time < 0) {\n                        animation.direction *= -1;\n                        if (animation.time > animation.duration) {\n                            animation.time = animation.duration;\n                            animation.directionBackwards = true;\n                        }\n                        if (animation.time < 0) {\n                            animation.time = 0;\n                            animation.directionBackwards = false;\n                        }\n                    }\n                } else {\n                    animation.time = animation.time % animation.duration;\n                    if (animation.time < 0)\n                        animation.time += animation.duration;\n                }\n                var keyframe = animation.start + THREE.MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n                var weight = animation.weight;\n                if (keyframe !== animation.currentFrame) {\n                    this.morphTargetInfluences[animation.lastFrame] = 0;\n                    this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n                    this.morphTargetInfluences[keyframe] = 0;\n                    animation.lastFrame = animation.currentFrame;\n                    animation.currentFrame = keyframe;\n                }\n                var mix = animation.time % frameTime / frameTime;\n                if (animation.directionBackwards)\n                    mix = 1 - mix;\n                if (animation.currentFrame !== animation.lastFrame) {\n                    this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n                    this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n                } else {\n                    this.morphTargetInfluences[animation.currentFrame] = weight;\n                }\n            }\n        }\n    });\n    return MorphBlendMesh;\n});"]}