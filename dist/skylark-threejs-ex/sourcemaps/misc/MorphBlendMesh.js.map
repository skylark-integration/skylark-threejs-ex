{"version":3,"sources":["misc/MorphBlendMesh.js"],"names":["define","THREE","MorphBlendMesh","geometry","material","Mesh","call","this","animationsMap","animationsList","numFrames","Object","keys","morphTargetDictionary","length","endFrame","fps","createAnimation","setAnimationWeight","prototype","assign","create","constructor","name","start","end","animation","duration","lastFrame","currentFrame","active","time","direction","weight","directionBackwards","mirroredLoop","push","autoCreateAnimations","firstAnimation","pattern","frameRanges","i","key","chunks","match","Infinity","range","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","console","warn","stopAnimation","update","delta","il","frameTime","keyframe","MathUtils","clamp","Math","floor","morphTargetInfluences","mix"],"mappings":"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","file":"../../misc/MorphBlendMesh.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tTHREE.MorphBlendMesh = function ( geometry, material ) {\n\n\t\tTHREE.Mesh.call( this, geometry, material );\n\n\t\tthis.animationsMap = {};\n\t\tthis.animationsList = [];\n\n\t\t// prepare default animation\n\t\t// (all frames played together in 1 second)\n\n\t\tvar numFrames = Object.keys( this.morphTargetDictionary ).length;\n\n\t\tvar name = '__default';\n\n\t\tvar startFrame = 0;\n\t\tvar endFrame = numFrames - 1;\n\n\t\tvar fps = numFrames / 1;\n\n\t\tthis.createAnimation( name, startFrame, endFrame, fps );\n\t\tthis.setAnimationWeight( name, 1 );\n\n\t};\n\n\tTHREE.MorphBlendMesh.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {\n\n\t\tconstructor: THREE.MorphBlendMesh,\n\n\t\tcreateAnimation: function ( name, start, end, fps ) {\n\n\t\t\tvar animation = {\n\n\t\t\t\tstart: start,\n\t\t\t\tend: end,\n\n\t\t\t\tlength: end - start + 1,\n\n\t\t\t\tfps: fps,\n\t\t\t\tduration: ( end - start ) / fps,\n\n\t\t\t\tlastFrame: 0,\n\t\t\t\tcurrentFrame: 0,\n\n\t\t\t\tactive: false,\n\n\t\t\t\ttime: 0,\n\t\t\t\tdirection: 1,\n\t\t\t\tweight: 1,\n\n\t\t\t\tdirectionBackwards: false,\n\t\t\t\tmirroredLoop: false\n\n\t\t\t};\n\n\t\t\tthis.animationsMap[ name ] = animation;\n\t\t\tthis.animationsList.push( animation );\n\n\t\t},\n\n\t\tautoCreateAnimations: function ( fps ) {\n\n\t\t\tvar pattern = /([a-z]+)_?(\\d+)/i;\n\n\t\t\tvar firstAnimation, frameRanges = {};\n\n\t\t\tvar i = 0;\n\n\t\t\tfor ( var key in this.morphTargetDictionary ) {\n\n\t\t\t\tvar chunks = key.match( pattern );\n\n\t\t\t\tif ( chunks && chunks.length > 1 ) {\n\n\t\t\t\t\tvar name = chunks[ 1 ];\n\n\t\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\n\n\t\t\t\t\tvar range = frameRanges[ name ];\n\n\t\t\t\t\tif ( i < range.start ) range.start = i;\n\t\t\t\t\tif ( i > range.end ) range.end = i;\n\n\t\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tfor ( var name in frameRanges ) {\n\n\t\t\t\tvar range = frameRanges[ name ];\n\t\t\t\tthis.createAnimation( name, range.start, range.end, fps );\n\n\t\t\t}\n\n\t\t\tthis.firstAnimation = firstAnimation;\n\n\t\t},\n\n\t\tsetAnimationDirectionForward: function ( name ) {\n\n\t\t\tvar animation = this.animationsMap[ name ];\n\n\t\t\tif ( animation ) {\n\n\t\t\t\tanimation.direction = 1;\n\t\t\t\tanimation.directionBackwards = false;\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetAnimationDirectionBackward: function ( name ) {\n\n\t\t\tvar animation = this.animationsMap[ name ];\n\n\t\t\tif ( animation ) {\n\n\t\t\t\tanimation.direction = - 1;\n\t\t\t\tanimation.directionBackwards = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetAnimationFPS: function ( name, fps ) {\n\n\t\t\tvar animation = this.animationsMap[ name ];\n\n\t\t\tif ( animation ) {\n\n\t\t\t\tanimation.fps = fps;\n\t\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetAnimationDuration: function ( name, duration ) {\n\n\t\t\tvar animation = this.animationsMap[ name ];\n\n\t\t\tif ( animation ) {\n\n\t\t\t\tanimation.duration = duration;\n\t\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetAnimationWeight: function ( name, weight ) {\n\n\t\t\tvar animation = this.animationsMap[ name ];\n\n\t\t\tif ( animation ) {\n\n\t\t\t\tanimation.weight = weight;\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetAnimationTime: function ( name, time ) {\n\n\t\t\tvar animation = this.animationsMap[ name ];\n\n\t\t\tif ( animation ) {\n\n\t\t\t\tanimation.time = time;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetAnimationTime: function ( name ) {\n\n\t\t\tvar time = 0;\n\n\t\t\tvar animation = this.animationsMap[ name ];\n\n\t\t\tif ( animation ) {\n\n\t\t\t\ttime = animation.time;\n\n\t\t\t}\n\n\t\t\treturn time;\n\n\t\t},\n\n\t\tgetAnimationDuration: function ( name ) {\n\n\t\t\tvar duration = - 1;\n\n\t\t\tvar animation = this.animationsMap[ name ];\n\n\t\t\tif ( animation ) {\n\n\t\t\t\tduration = animation.duration;\n\n\t\t\t}\n\n\t\t\treturn duration;\n\n\t\t},\n\n\t\tplayAnimation: function ( name ) {\n\n\t\t\tvar animation = this.animationsMap[ name ];\n\n\t\t\tif ( animation ) {\n\n\t\t\t\tanimation.time = 0;\n\t\t\t\tanimation.active = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\n\n\t\t\t}\n\n\t\t},\n\n\t\tstopAnimation: function ( name ) {\n\n\t\t\tvar animation = this.animationsMap[ name ];\n\n\t\t\tif ( animation ) {\n\n\t\t\t\tanimation.active = false;\n\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: function ( delta ) {\n\n\t\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\n\n\t\t\t\tvar animation = this.animationsList[ i ];\n\n\t\t\t\tif ( ! animation.active ) continue;\n\n\t\t\t\tvar frameTime = animation.duration / animation.length;\n\n\t\t\t\tanimation.time += animation.direction * delta;\n\n\t\t\t\tif ( animation.mirroredLoop ) {\n\n\t\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\n\n\t\t\t\t\t\tanimation.direction *= - 1;\n\n\t\t\t\t\t\tif ( animation.time > animation.duration ) {\n\n\t\t\t\t\t\t\tanimation.time = animation.duration;\n\t\t\t\t\t\t\tanimation.directionBackwards = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( animation.time < 0 ) {\n\n\t\t\t\t\t\t\tanimation.time = 0;\n\t\t\t\t\t\t\tanimation.directionBackwards = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tanimation.time = animation.time % animation.duration;\n\n\t\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\n\n\t\t\t\t}\n\n\t\t\t\tvar keyframe = animation.start + THREE.MathUtils.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\n\t\t\t\tvar weight = animation.weight;\n\n\t\t\t\tif ( keyframe !== animation.currentFrame ) {\n\n\t\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\n\t\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\n\n\t\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\n\t\t\t\t\tanimation.lastFrame = animation.currentFrame;\n\t\t\t\t\tanimation.currentFrame = keyframe;\n\n\t\t\t\t}\n\n\t\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\n\n\t\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\n\n\t\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\n\n\t\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\n\t\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.MorphBlendMesh;\n});\n"]}