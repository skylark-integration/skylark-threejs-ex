{"version":3,"sources":["misc/GPUComputationRenderer.js"],"names":["define","THREE","GPUComputationRenderer","sizeX","sizeY","renderer","this","variables","currentTextureIndex","scene","Scene","camera","Camera","position","z","passThruUniforms","passThruTexture","value","passThruShader","createShaderMaterial","mesh","Mesh","PlaneBufferGeometry","addResolutionDefine","materialShader","defines","resolution","toFixed","computeFragmentShader","uniforms","material","ShaderMaterial","vertexShader","fragmentShader","add","addVariable","variableName","initialValueTexture","variable","name","dependencies","renderTargets","wrapS","wrapT","minFilter","NearestFilter","magFilter","push","setVariableDependencies","init","capabilities","isWebGL2","extensions","get","maxVertexTextures","i","length","createRenderTarget","renderTexture","d","depVar","found","j","compute","nextTextureIndex","il","dl","texture","doRenderTarget","getCurrentRenderTarget","getAlternateRenderTarget","sizeXTexture","sizeYTexture","ClampToEdgeWrapping","WebGLRenderTarget","format","RGBAFormat","type","test","navigator","userAgent","HalfFloatType","FloatType","stencilBuffer","depthBuffer","createTexture","data","Float32Array","DataTexture","input","output","currentRenderTarget","getRenderTarget","setRenderTarget","render"],"mappings":"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","file":"../../misc/GPUComputationRenderer.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author yomboprime https://github.com/yomboprime\n\t *\n\t * GPUComputationRenderer, based on SimulationRenderer by zz85\n\t *\n\t * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n\t * for each compute element (texel)\n\t *\n\t * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n\t * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n\t * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n\t *\n\t * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n\t * as inputs to render the textures of the next frame.\n\t *\n\t * The render targets of the variables can be used as input textures for your visualization shaders.\n\t *\n\t * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n\t * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n\t *\n\t * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n\t * #DEFINE resolution vec2( 1024.0, 1024.0 )\n\t *\n\t * -------------\n\t *\n\t * Basic use:\n\t *\n\t * // Initialization...\n\t *\n\t * // Create computation renderer\n\t * var gpuCompute = new THREE.GPUComputationRenderer( 1024, 1024, renderer );\n\t *\n\t * // Create initial state float textures\n\t * var pos0 = gpuCompute.createTexture();\n\t * var vel0 = gpuCompute.createTexture();\n\t * // and fill in here the texture data...\n\t *\n\t * // Add texture variables\n\t * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n\t * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n\t *\n\t * // Add variable dependencies\n\t * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n\t * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n\t *\n\t * // Add custom uniforms\n\t * velVar.material.uniforms.time = { value: 0.0 };\n\t *\n\t * // Check for completeness\n\t * var error = gpuCompute.init();\n\t * if ( error !== null ) {\n\t *\t\tconsole.error( error );\n\t  * }\n\t *\n\t *\n\t * // In each frame...\n\t *\n\t * // Compute!\n\t * gpuCompute.compute();\n\t *\n\t * // Update texture uniforms in your visualization materials with the gpu renderer output\n\t * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n\t *\n\t * // Do your rendering\n\t * renderer.render( myScene, myCamera );\n\t *\n\t * -------------\n\t *\n\t * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n\t * Note that the shaders can have multiple input textures.\n\t *\n\t * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n\t * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n\t *\n\t * var inputTexture = gpuCompute.createTexture();\n\t *\n\t * // Fill in here inputTexture...\n\t *\n\t * myFilter1.uniforms.theTexture.value = inputTexture;\n\t *\n\t * var myRenderTarget = gpuCompute.createRenderTarget();\n\t * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n\t *\n\t * var outputRenderTarget = gpuCompute.createRenderTarget();\n\t *\n\t * // Now use the output texture where you want:\n\t * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n\t *\n\t * // And compute each frame, before rendering to screen:\n\t * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n\t * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n\t *\n\t *\n\t *\n\t * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n\t * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n\t * @param {WebGLRenderer} renderer The renderer\n\t  */\n\n\tTHREE.GPUComputationRenderer = function ( sizeX, sizeY, renderer ) {\n\n\t\tthis.variables = [];\n\n\t\tthis.currentTextureIndex = 0;\n\n\t\tvar scene = new THREE.Scene();\n\n\t\tvar camera = new THREE.Camera();\n\t\tcamera.position.z = 1;\n\n\t\tvar passThruUniforms = {\n\t\t\tpassThruTexture: { value: null }\n\t\t};\n\n\t\tvar passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\n\n\t\tvar mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), passThruShader );\n\t\tscene.add( mesh );\n\n\n\t\tthis.addVariable = function ( variableName, computeFragmentShader, initialValueTexture ) {\n\n\t\t\tvar material = this.createShaderMaterial( computeFragmentShader );\n\n\t\t\tvar variable = {\n\t\t\t\tname: variableName,\n\t\t\t\tinitialValueTexture: initialValueTexture,\n\t\t\t\tmaterial: material,\n\t\t\t\tdependencies: null,\n\t\t\t\trenderTargets: [],\n\t\t\t\twrapS: null,\n\t\t\t\twrapT: null,\n\t\t\t\tminFilter: THREE.NearestFilter,\n\t\t\t\tmagFilter: THREE.NearestFilter\n\t\t\t};\n\n\t\t\tthis.variables.push( variable );\n\n\t\t\treturn variable;\n\n\t\t};\n\n\t\tthis.setVariableDependencies = function ( variable, dependencies ) {\n\n\t\t\tvariable.dependencies = dependencies;\n\n\t\t};\n\n\t\tthis.init = function () {\n\n\t\t\tif ( ! renderer.capabilities.isWebGL2 &&\n\t\t\t\t ! renderer.extensions.get( \"OES_texture_float\" ) ) {\n\n\t\t\t\treturn \"No OES_texture_float support for float textures.\";\n\n\t\t\t}\n\n\t\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\n\n\t\t\t\treturn \"No support for vertex shader textures.\";\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < this.variables.length; i ++ ) {\n\n\t\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t\t// Creates rendertargets and initialize them with input texture\n\t\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\n\t\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\n\n\t\t\t\t// Adds dependencies uniforms to the ShaderMaterial\n\t\t\t\tvar material = variable.material;\n\t\t\t\tvar uniforms = material.uniforms;\n\t\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\t\tfor ( var d = 0; d < variable.dependencies.length; d ++ ) {\n\n\t\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\t\tif ( depVar.name !== variable.name ) {\n\n\t\t\t\t\t\t\t// Checks if variable exists\n\t\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\t\tfor ( var j = 0; j < this.variables.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\n\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( ! found ) {\n\n\t\t\t\t\t\t\t\treturn \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\n\n\t\t\t\t\t\tmaterial.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.currentTextureIndex = 0;\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\tthis.compute = function () {\n\n\t\t\tvar currentTextureIndex = this.currentTextureIndex;\n\t\t\tvar nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n\t\t\tfor ( var i = 0, il = this.variables.length; i < il; i ++ ) {\n\n\t\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t\t// Sets texture dependencies uniforms\n\t\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\t\tvar uniforms = variable.material.uniforms;\n\t\t\t\t\tfor ( var d = 0, dl = variable.dependencies.length; d < dl; d ++ ) {\n\n\t\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Performs the computation for this variable\n\t\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\n\n\t\t\t}\n\n\t\t\tthis.currentTextureIndex = nextTextureIndex;\n\n\t\t};\n\n\t\tthis.getCurrentRenderTarget = function ( variable ) {\n\n\t\t\treturn variable.renderTargets[ this.currentTextureIndex ];\n\n\t\t};\n\n\t\tthis.getAlternateRenderTarget = function ( variable ) {\n\n\t\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\n\n\t\t};\n\n\t\tfunction addResolutionDefine( materialShader ) {\n\n\t\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + \" )\";\n\n\t\t}\n\t\tthis.addResolutionDefine = addResolutionDefine;\n\n\n\t\t// The following functions can be used to compute things manually\n\n\t\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\n\n\t\t\tuniforms = uniforms || {};\n\n\t\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\t\tuniforms: uniforms,\n\t\t\t\tvertexShader: getPassThroughVertexShader(),\n\t\t\t\tfragmentShader: computeFragmentShader\n\t\t\t} );\n\n\t\t\taddResolutionDefine( material );\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tthis.createShaderMaterial = createShaderMaterial;\n\n\t\tthis.createRenderTarget = function ( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\n\n\t\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\t\twrapS = wrapS || THREE.ClampToEdgeWrapping;\n\t\t\twrapT = wrapT || THREE.ClampToEdgeWrapping;\n\n\t\t\tminFilter = minFilter || THREE.NearestFilter;\n\t\t\tmagFilter = magFilter || THREE.NearestFilter;\n\n\t\t\tvar renderTarget = new THREE.WebGLRenderTarget( sizeXTexture, sizeYTexture, {\n\t\t\t\twrapS: wrapS,\n\t\t\t\twrapT: wrapT,\n\t\t\t\tminFilter: minFilter,\n\t\t\t\tmagFilter: magFilter,\n\t\t\t\tformat: THREE.RGBAFormat,\n\t\t\t\ttype: ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) ? THREE.HalfFloatType : THREE.FloatType,\n\t\t\t\tstencilBuffer: false,\n\t\t\t\tdepthBuffer: false\n\t\t\t} );\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\tthis.createTexture = function () {\n\n\t\t\tvar data = new Float32Array( sizeX * sizeY * 4 );\n\t\t\treturn new THREE.DataTexture( data, sizeX, sizeY, THREE.RGBAFormat, THREE.FloatType );\n\n\t\t};\n\n\t\tthis.renderTexture = function ( input, output ) {\n\n\t\t\t// Takes a texture, and render out in rendertarget\n\t\t\t// input = Texture\n\t\t\t// output = RenderTarget\n\n\t\t\tpassThruUniforms.passThruTexture.value = input;\n\n\t\t\tthis.doRenderTarget( passThruShader, output );\n\n\t\t\tpassThruUniforms.passThruTexture.value = null;\n\n\t\t};\n\n\t\tthis.doRenderTarget = function ( material, output ) {\n\n\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tmesh.material = material;\n\t\t\trenderer.setRenderTarget( output );\n\t\t\trenderer.render( scene, camera );\n\t\t\tmesh.material = passThruShader;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t};\n\n\t\t// Shaders\n\n\t\tfunction getPassThroughVertexShader() {\n\n\t\t\treturn\t\"void main()\t{\\n\" +\n\t\t\t\t\t\"\\n\" +\n\t\t\t\t\t\"\tgl_Position = vec4( position, 1.0 );\\n\" +\n\t\t\t\t\t\"\\n\" +\n\t\t\t\t\t\"}\\n\";\n\n\t\t}\n\n\t\tfunction getPassThroughFragmentShader() {\n\n\t\t\treturn\t\"uniform sampler2D passThruTexture;\\n\" +\n\t\t\t\t\t\"\\n\" +\n\t\t\t\t\t\"void main() {\\n\" +\n\t\t\t\t\t\"\\n\" +\n\t\t\t\t\t\"\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\" +\n\t\t\t\t\t\"\\n\" +\n\t\t\t\t\t\"\tgl_FragColor = texture2D( passThruTexture, uv );\\n\" +\n\t\t\t\t\t\"\\n\" +\n\t\t\t\t\t\"}\\n\";\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.GPUComputationRenderer;\n});\n"]}