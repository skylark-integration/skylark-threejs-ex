{"version":3,"sources":["misc/ConvexObjectBreaker.js"],"names":["define","THREE","ConvexBufferGeometry","v1","ConvexObjectBreaker","minSizeForBreak","smallDelta","this","tempLine1","Line3","tempPlane1","Plane","tempPlane2","tempPlane_Cut","tempCM1","Vector3","tempCM2","tempVector3","tempVector3_2","tempVector3_3","tempVector3_P0","tempVector3_P1","tempVector3_P2","tempVector3_N0","tempVector3_N1","tempVector3_AB","tempVector3_CB","tempResultObjects","object1","object2","segments","i","prototype","constructor","prepareBreakableObject","object","mass","velocity","angularVelocity","breakable","geometry","isBufferGeometry","console","error","userData","clone","subdivideByImpact","pointOfImpact","normal","maxRadialIterations","maxRandomIterations","debris","addVectors","setFromCoplanarPoints","position","maxTotalIterations","scope","subdivideRadial","subObject","startAngle","endAngle","numIterations","Math","random","push","angle","PI","copy","constant","sub","applyAxisAngle","add","cutByPlane","obj1","obj2","plane","output","coords","attributes","array","normals","numPoints","length","numFaces","indices","getIndex","getVertexIndex","faceIdx","vert","idx","points1","points2","delta","numPointPairs","p0","p1","n0","n1","a1","b1","c1","set","j","a2","b2","c2","dot","localPlane","updateMatrix","transformPlaneToLocalSpace","matrix","va","vb","vc","segment","i0","i1","mark0","d","distanceToPoint","mark1","start","end","intersection","undefined","intersectLine","segmentedObject1","segmentedObject2","newMass","radius1","numPoints1","divideScalar","p","max","x","y","z","radius2","numPoints2","numObjects","Mesh","material","quaternion","transformFreeVector","v","m","e","elements","transformFreeVectorInverse","transformTiedVectorInverse","resultPlane","referencePoint","coplanarPoint"],"mappings":";;;;;;;AAAAA,QACC,kBACA,gCACC,SAASC,EAAMC,GAufuC,IAElDC,EAmBL,OA5eAF,EAAMG,oBAAsB,SAAWC,EAAiBC,GAEvDC,KAAKF,gBAAkBA,GAAmB,IAC1CE,KAAKD,WAAaA,GAAc,KAEhCC,KAAKC,UAAY,IAAIP,EAAMQ,MAC3BF,KAAKG,WAAa,IAAIT,EAAMU,MAC5BJ,KAAKK,WAAa,IAAIX,EAAMU,MAC5BJ,KAAKM,cAAgB,IAAIZ,EAAMU,MAC/BJ,KAAKO,QAAU,IAAIb,EAAMc,QACzBR,KAAKS,QAAU,IAAIf,EAAMc,QACzBR,KAAKU,YAAc,IAAIhB,EAAMc,QAC7BR,KAAKW,cAAgB,IAAIjB,EAAMc,QAC/BR,KAAKY,cAAgB,IAAIlB,EAAMc,QAC/BR,KAAKa,eAAiB,IAAInB,EAAMc,QAChCR,KAAKc,eAAiB,IAAIpB,EAAMc,QAChCR,KAAKe,eAAiB,IAAIrB,EAAMc,QAChCR,KAAKgB,eAAiB,IAAItB,EAAMc,QAChCR,KAAKiB,eAAiB,IAAIvB,EAAMc,QAChCR,KAAKkB,eAAiB,IAAIxB,EAAMc,QAChCR,KAAKmB,eAAiB,IAAIzB,EAAMc,QAChCR,KAAKoB,mBAAsBC,QAAS,KAAMC,QAAS,MAEnDtB,KAAKuB,YAEL,IADA,IACUC,EAAI,EAAGA,EADT,IACgBA,IAAOxB,KAAKuB,SAAUC,IAAM,GAIrD9B,EAAMG,oBAAoB4B,WAEzBC,YAAahC,EAAMG,oBAEnB8B,uBAAwB,SAAWC,EAAQC,EAAMC,EAAUC,EAAiBC,GAMpEJ,EAAOK,SAASC,kBAEtBC,QAAQC,MAAO,oGAIhB,IAAIC,EAAWT,EAAOS,SACtBA,EAASR,KAAOA,EAChBQ,EAASP,SAAWA,EAASQ,QAC7BD,EAASN,gBAAkBA,EAAgBO,QAC3CD,EAASL,UAAYA,GAUtBO,kBAAmB,SAAWX,EAAQY,EAAeC,EAAQC,EAAqBC,GAEjF,IAAIC,KAEAzC,EAAaH,KAAKG,WAClBE,EAAaL,KAAKK,WAEtBL,KAAKU,YAAYmC,WAAYL,EAAeC,GAC5CtC,EAAW2C,sBAAuBN,EAAeZ,EAAOmB,SAAU/C,KAAKU,aAEvE,IAAIsC,EAAqBL,EAAsBD,EAE3CO,EAAQjD,KAgEZ,OA9DA,SAASkD,EAAiBC,EAAWC,EAAYC,EAAUC,GAE1D,GAAKC,KAAKC,SAA2B,IAAhBF,GAAwBA,EAAgBN,EAE5DJ,EAAOa,KAAMN,OAFd,CAQA,IAAIO,EAAQH,KAAKI,GAEM,IAAlBL,GAEJjD,EAAWoC,OAAOmB,KAAMzD,EAAWsC,QACnCpC,EAAWwD,SAAW1D,EAAW0D,UAI5BP,GAAiBZ,GAErBgB,GAAUL,EAAWD,IAAiB,GAAM,GAAMG,KAAKC,UAAaJ,EAGpEH,EAAMtC,cAAciD,KAAMhC,EAAOmB,UAAWe,IAAKtB,GAAgBuB,eAAgBtB,EAAQiB,GAAQM,IAAKxB,GACtGnC,EAAWyC,sBAAuBN,EAAeS,EAAMvC,YAAauC,EAAMtC,iBAI1E+C,GAAY,IAAwB,EAAhBJ,GAAwB,IAAQ,EAAIC,KAAKC,WAAeD,KAAKI,GAGjFV,EAAMtC,cAAciD,KAAMpB,GAAgBsB,IAAKX,EAAUJ,UAAWgB,eAAgBtB,EAAQiB,GAAQM,IAAKb,EAAUJ,UACnHE,EAAMrC,cAAcgD,KAAMnB,GAASuB,IAAKb,EAAUJ,UAClD1C,EAAWyC,sBAAuBK,EAAUJ,SAAUE,EAAMrC,cAAeqC,EAAMtC,gBAOnFsC,EAAMgB,WAAYd,EAAW9C,EAAY4C,EAAM7B,mBAE/C,IAAI8C,EAAOjB,EAAM7B,kBAAkBC,QAC/B8C,EAAOlB,EAAM7B,kBAAkBE,QAE9B4C,GAEJhB,EAAiBgB,EAAMd,EAAYM,EAAOJ,EAAgB,GAItDa,GAEJjB,EAAiBiB,EAAMT,EAAOL,EAAUC,EAAgB,IAM1DJ,CAAiBtB,EAAQ,EAAG,EAAI2B,KAAKI,GAAI,GAElCf,GAIRqB,WAAY,SAAWrC,EAAQwC,EAAOC,GAOrC,IAAIpC,EAAWL,EAAOK,SAClBqC,EAASrC,EAASsC,WAAWxB,SAASyB,MACtCC,EAAUxC,EAASsC,WAAW9B,OAAO+B,MAErCE,EAAYJ,EAAOK,OAAS,EAC5BC,EAAWF,EAAY,EAEvBG,EAAU5C,EAAS6C,WASvB,SAASC,EAAgBC,EAASC,GAIjC,IAAIC,EAAgB,EAAVF,EAAcC,EAExB,OAAOJ,EAAUA,EAASK,GAAQA,EAb9BL,IAGJD,GADAC,EAAUA,EAAQL,OACCG,OAAS,GAqB7B,IAPA,IAAIQ,KACAC,KAEAC,EAAQrF,KAAKD,WAGbuF,EAAgBZ,EAAYA,EACtBlD,EAAI,EAAGA,EAAI8D,EAAe9D,IAAOxB,KAAKuB,SAAUC,IAAM,EAEhE,IAAI+D,EAAKvF,KAAKa,eACV2E,EAAKxF,KAAKc,eACV2E,EAAKzF,KAAKgB,eACV0E,EAAK1F,KAAKiB,eAGd,IAAUO,EAAI,EAAGA,EAAIoD,EAAW,EAAGpD,IAAO,CAEzC,IAAImE,EAAKZ,EAAgBvD,EAAG,GACxBoE,EAAKb,EAAgBvD,EAAG,GACxBqE,EAAKd,EAAgBvD,EAAG,GAG5BiE,EAAGK,IAAKrB,EAASkB,GAAMlB,EAASkB,GAAO,EAAGlB,EAASkB,GAAO,GAE1D,IAAM,IAAII,EAAIvE,EAAI,EAAGuE,EAAInB,EAAUmB,IAAO,CAEzC,IAAIC,EAAKjB,EAAgBgB,EAAG,GACxBE,EAAKlB,EAAgBgB,EAAG,GACxBG,EAAKnB,EAAgBgB,EAAG,GAG5BL,EAAGI,IAAKrB,EAASuB,GAAMvB,EAASuB,GAAO,EAAGvB,EAASuB,GAAO,GAE3C,EAAIP,EAAGU,IAAKT,GAAOL,IAI5BM,IAAOK,GAAML,IAAOM,GAAMN,IAAOO,EAEhCN,IAAOI,GAAMJ,IAAOK,GAAML,IAAOM,GAErClG,KAAKuB,SAAUoE,EAAKjB,EAAYkB,IAAO,EACvC5F,KAAKuB,SAAUqE,EAAKlB,EAAYiB,IAAO,IAIvC3F,KAAKuB,SAAUsE,EAAKnB,EAAYiB,IAAO,EACvC3F,KAAKuB,SAAUoE,EAAKjB,EAAYmB,IAAO,GAI7BD,IAAOI,GAAMJ,IAAOK,GAAML,IAAOM,IAE5ClG,KAAKuB,SAAUsE,EAAKnB,EAAYkB,IAAO,EACvC5F,KAAKuB,SAAUqE,EAAKlB,EAAYmB,IAAO,KAW3C,IAAIO,EAAapG,KAAKM,cACtBsB,EAAOyE,eACP3G,EAAMG,oBAAoByG,2BAA4BlC,EAAOxC,EAAO2E,OAAQH,GAG5E,IAAU5E,EAAI,EAAGA,EAAIoD,EAAUpD,IAM9B,IAJA,IAAIgF,EAAKzB,EAAgBvD,EAAG,GACxBiF,EAAK1B,EAAgBvD,EAAG,GACxBkF,EAAK3B,EAAgBvD,EAAG,GAElBmF,EAAU,EAAGA,EAAU,EAAGA,IAAa,CAEhD,IAAIC,EAAiB,IAAZD,EAAgBH,EAAmB,IAAZG,EAAgBF,EAAKC,EACjDG,EAAiB,IAAZF,EAAgBF,EAAmB,IAAZE,EAAgBD,EAAKF,EAIrD,IAFmBxG,KAAKuB,SAAUqF,EAAKlC,EAAYmC,GAEnD,CAGA7G,KAAKuB,SAAUqF,EAAKlC,EAAYmC,IAAO,EACvC7G,KAAKuB,SAAUsF,EAAKnC,EAAYkC,IAAO,EAEvCrB,EAAGO,IAAKxB,EAAQ,EAAIsC,GAAMtC,EAAQ,EAAIsC,EAAK,GAAKtC,EAAQ,EAAIsC,EAAK,IACjEpB,EAAGM,IAAKxB,EAAQ,EAAIuC,GAAMvC,EAAQ,EAAIuC,EAAK,GAAKvC,EAAQ,EAAIuC,EAAK,IAGjE,IAAIC,EAAQ,GAERC,EAAIX,EAAWY,gBAAiBzB,IAE3BF,GAERyB,EAAQ,EACR1B,EAAQ3B,KAAM8B,EAAGjD,UAENyE,GAAM1B,GAEjByB,EAAQ,EACR3B,EAAQ1B,KAAM8B,EAAGjD,WAIjBwE,EAAQ,EACR3B,EAAQ1B,KAAM8B,EAAGjD,SACjB8C,EAAQ3B,KAAM8B,EAAGjD,UAKlB,IAEIyE,EAFAE,EAAQ,EAsBZ,IApBIF,EAAIX,EAAWY,gBAAiBxB,IAE3BH,GAER4B,EAAQ,EACR7B,EAAQ3B,KAAM+B,EAAGlD,UAENyE,GAAM1B,GAEjB4B,EAAQ,EACR9B,EAAQ1B,KAAM+B,EAAGlD,WAIjB2E,EAAQ,EACR9B,EAAQ1B,KAAM+B,EAAGlD,SACjB8C,EAAQ3B,KAAM+B,EAAGlD,UAID,IAAVwE,GAAyB,IAAVG,GAA6B,IAAVH,GAAyB,IAAVG,EAAgB,CAIvEjH,KAAKC,UAAUiH,MAAMtD,KAAM2B,GAC3BvF,KAAKC,UAAUkH,IAAIvD,KAAM4B,GAEzB,IAAI4B,EAAe,IAAI1H,EAAMc,QAG7B,QAAsB6G,KAFtBD,EAAehB,EAAWkB,cAAetH,KAAKC,UAAWmH,IAQxD,OAHAjF,QAAQC,MAAO,qDACfiC,EAAOkD,iBAAmB,KAC1BlD,EAAOmD,iBAAmB,KACnB,EAIRrC,EAAQ1B,KAAM2D,GACdhC,EAAQ3B,KAAM2D,EAAa9E,WAS9B,IAAImF,EAAiC,GAAvB7F,EAAOS,SAASR,KAG9B7B,KAAKO,QAAQuF,IAAK,EAAG,EAAG,GACxB,IAAI4B,EAAU,EACVC,EAAaxC,EAAQR,OAEzB,GAAKgD,EAAa,EAAI,CAErB,IAAUnG,EAAI,EAAGA,EAAImG,EAAYnG,IAAOxB,KAAKO,QAAQyD,IAAKmB,EAAS3D,IAEnExB,KAAKO,QAAQqH,aAAcD,GAC3B,IAAUnG,EAAI,EAAGA,EAAImG,EAAYnG,IAAO,EAEnCqG,EAAI1C,EAAS3D,IACfsC,IAAK9D,KAAKO,SACZmH,EAAUnE,KAAKuE,IAAKJ,EAASG,EAAEE,EAAGF,EAAEG,EAAGH,EAAEI,GAG1CjI,KAAKO,QAAQyD,IAAKpC,EAAOmB,UAI1B/C,KAAKS,QAAQqF,IAAK,EAAG,EAAG,GACxB,IAAIoC,EAAU,EACVC,EAAa/C,EAAQT,OACzB,GAAKwD,EAAa,EAAI,CAErB,IAAU3G,EAAI,EAAGA,EAAI2G,EAAY3G,IAAOxB,KAAKS,QAAQuD,IAAKoB,EAAS5D,IAEnExB,KAAKS,QAAQmH,aAAcO,GAC3B,IAAU3G,EAAI,EAAGA,EAAI2G,EAAY3G,IAAO,CAEvC,IAAIqG,GAAAA,EAAIzC,EAAS5D,IACfsC,IAAK9D,KAAKS,SACZyH,EAAU3E,KAAKuE,IAAKI,EAASL,EAAEE,EAAGF,EAAEG,EAAGH,EAAEI,GAG1CjI,KAAKS,QAAQuD,IAAKpC,EAAOmB,UAI1B,IAAI1B,EAAU,KACVC,EAAU,KAEV8G,EAAa,EA6BjB,OA3BKT,EAAa,KAEjBtG,EAAU,IAAI3B,EAAM2I,KAAM,IAAI3I,EAAMC,qBAAsBwF,GAAWvD,EAAO0G,WACpEvF,SAASa,KAAM5D,KAAKO,SAC5Bc,EAAQkH,WAAW3E,KAAMhC,EAAO2G,YAEhCvI,KAAK2B,uBAAwBN,EAASoG,EAAS7F,EAAOS,SAASP,SAAUF,EAAOS,SAASN,gBAAiB,EAAI2F,EAAU1H,KAAKF,iBAE7HsI,KAIID,EAAa,KAEjB7G,EAAU,IAAI5B,EAAM2I,KAAM,IAAI3I,EAAMC,qBAAsByF,GAAWxD,EAAO0G,WACpEvF,SAASa,KAAM5D,KAAKS,SAC5Ba,EAAQiH,WAAW3E,KAAMhC,EAAO2G,YAEhCvI,KAAK2B,uBAAwBL,EAASmG,EAAS7F,EAAOS,SAASP,SAAUF,EAAOS,SAASN,gBAAiB,EAAImG,EAAUlI,KAAKF,iBAE7HsI,KAID/D,EAAOhD,QAAUA,EACjBgD,EAAO/C,QAAUA,EAEV8G,IAMT1I,EAAMG,oBAAoB2I,oBAAsB,SAAWC,EAAGC,GAM7D,IAAIX,EAAIU,EAAEV,EAAGC,EAAIS,EAAET,EAAGC,EAAIQ,EAAER,EACxBU,EAAID,EAAEE,SAMV,OAJAH,EAAEV,EAAIY,EAAG,GAAMZ,EAAIY,EAAG,GAAMX,EAAIW,EAAG,GAAMV,EACzCQ,EAAET,EAAIW,EAAG,GAAMZ,EAAIY,EAAG,GAAMX,EAAIW,EAAG,GAAMV,EACzCQ,EAAER,EAAIU,EAAG,GAAMZ,EAAIY,EAAG,GAAMX,EAAIW,EAAG,IAAOV,EAEnCQ,GAIR/I,EAAMG,oBAAoBgJ,2BAA6B,SAAWJ,EAAGC,GAMpE,IAAIX,EAAIU,EAAEV,EAAGC,EAAIS,EAAET,EAAGC,EAAIQ,EAAER,EACxBU,EAAID,EAAEE,SAMV,OAJAH,EAAEV,EAAIY,EAAG,GAAMZ,EAAIY,EAAG,GAAMX,EAAIW,EAAG,GAAMV,EACzCQ,EAAET,EAAIW,EAAG,GAAMZ,EAAIY,EAAG,GAAMX,EAAIW,EAAG,GAAMV,EACzCQ,EAAER,EAAIU,EAAG,GAAMZ,EAAIY,EAAG,GAAMX,EAAIW,EAAG,IAAOV,EAEnCQ,GAIR/I,EAAMG,oBAAoBiJ,2BAA6B,SAAWL,EAAGC,GAMpE,IAAIX,EAAIU,EAAEV,EAAGC,EAAIS,EAAET,EAAGC,EAAIQ,EAAER,EACxBU,EAAID,EAAEE,SAMV,OAJAH,EAAEV,EAAIY,EAAG,GAAMZ,EAAIY,EAAG,GAAMX,EAAIW,EAAG,GAAMV,EAAIU,EAAG,IAChDF,EAAET,EAAIW,EAAG,GAAMZ,EAAIY,EAAG,GAAMX,EAAIW,EAAG,GAAMV,EAAIU,EAAG,IAChDF,EAAER,EAAIU,EAAG,GAAMZ,EAAIY,EAAG,GAAMX,EAAIW,EAAG,IAAOV,EAAIU,EAAG,IAE1CF,GAIR/I,EAAMG,oBAAoByG,4BAErB1G,EAAK,IAAIF,EAAMc,QAEZ,SAAqC4D,EAAOsE,EAAGK,GAErDA,EAAYtG,OAAOmB,KAAMQ,EAAM3B,QAC/BsG,EAAYlF,SAAWO,EAAMP,SAE7B,IAAImF,EAAiBtJ,EAAMG,oBAAoBiJ,2BAA4B1E,EAAM6E,cAAerJ,GAAM8I,GAEtGhJ,EAAMG,oBAAoBgJ,2BAA4BE,EAAYtG,OAAQiG,GAG1EK,EAAYlF,UAAamF,EAAe7C,IAAK4C,EAAYtG,UAOpD/C,EAAMG","file":"../../misc/ConvexObjectBreaker.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"../geometries/ConvexGeometry\"\n],function(THREE,ConvexBufferGeometry){\n\t/**\n\t * @author yomboprime https://github.com/yomboprime\n\t *\n\t * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\n\t *\n\t * Usage:\n\t *\n\t * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\n\t *\n\t * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\n\t *\n\t * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\n\t *\n\t * Requisites for the object:\n\t *\n\t *  - Mesh object must have a BufferGeometry (not Geometry) and a Material\n\t *\n\t *  - Vertex normals must be planar (not smoothed)\n\t *\n\t *  - The geometry must be convex (this is not checked in the library). You can create convex\n\t *  geometries with THREE.ConvexBufferGeometry. The BoxBufferGeometry, SphereBufferGeometry and other convex primitives\n\t *  can also be used.\n\t *\n\t * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\n\t * Use with caution and read the code when using with other libs.\n\t *\n\t * @param {double} minSizeForBreak Min size a debris can have to break.\n\t * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\n\t *\n\t*/\n\n\tTHREE.ConvexObjectBreaker = function ( minSizeForBreak, smallDelta ) {\n\n\t\tthis.minSizeForBreak = minSizeForBreak || 1.4;\n\t\tthis.smallDelta = smallDelta || 0.0001;\n\n\t\tthis.tempLine1 = new THREE.Line3();\n\t\tthis.tempPlane1 = new THREE.Plane();\n\t\tthis.tempPlane2 = new THREE.Plane();\n\t\tthis.tempPlane_Cut = new THREE.Plane();\n\t\tthis.tempCM1 = new THREE.Vector3();\n\t\tthis.tempCM2 = new THREE.Vector3();\n\t\tthis.tempVector3 = new THREE.Vector3();\n\t\tthis.tempVector3_2 = new THREE.Vector3();\n\t\tthis.tempVector3_3 = new THREE.Vector3();\n\t\tthis.tempVector3_P0 = new THREE.Vector3();\n\t\tthis.tempVector3_P1 = new THREE.Vector3();\n\t\tthis.tempVector3_P2 = new THREE.Vector3();\n\t\tthis.tempVector3_N0 = new THREE.Vector3();\n\t\tthis.tempVector3_N1 = new THREE.Vector3();\n\t\tthis.tempVector3_AB = new THREE.Vector3();\n\t\tthis.tempVector3_CB = new THREE.Vector3();\n\t\tthis.tempResultObjects = { object1: null, object2: null };\n\n\t\tthis.segments = [];\n\t\tvar n = 30 * 30;\n\t\tfor ( var i = 0; i < n; i ++ ) this.segments[ i ] = false;\n\n\t};\n\n\tTHREE.ConvexObjectBreaker.prototype = {\n\n\t\tconstructor: THREE.ConvexObjectBreaker,\n\n\t\tprepareBreakableObject: function ( object, mass, velocity, angularVelocity, breakable ) {\n\n\t\t\t// object is a THREE.Object3d (normally a Mesh), must have a BufferGeometry, and it must be convex.\n\t\t\t// Its material property is propagated to its children (sub-pieces)\n\t\t\t// mass must be > 0\n\n\t\t\tif ( ! object.geometry.isBufferGeometry ) {\n\n\t\t\t\tconsole.error( 'THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.' );\n\n\t\t\t}\n\n\t\t\tvar userData = object.userData;\n\t\t\tuserData.mass = mass;\n\t\t\tuserData.velocity = velocity.clone();\n\t\t\tuserData.angularVelocity = angularVelocity.clone();\n\t\t\tuserData.breakable = breakable;\n\n\t\t},\n\n\t\t/*\n\t\t * @param {int} maxRadialIterations Iterations for radial cuts.\n\t\t * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n\t\t *\n\t\t * Returns the array of pieces\n\t\t */\n\t\tsubdivideByImpact: function ( object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations ) {\n\n\t\t\tvar debris = [];\n\n\t\t\tvar tempPlane1 = this.tempPlane1;\n\t\t\tvar tempPlane2 = this.tempPlane2;\n\n\t\t\tthis.tempVector3.addVectors( pointOfImpact, normal );\n\t\t\ttempPlane1.setFromCoplanarPoints( pointOfImpact, object.position, this.tempVector3 );\n\n\t\t\tvar maxTotalIterations = maxRandomIterations + maxRadialIterations;\n\n\t\t\tvar scope = this;\n\n\t\t\tfunction subdivideRadial( subObject, startAngle, endAngle, numIterations ) {\n\n\t\t\t\tif ( Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations ) {\n\n\t\t\t\t\tdebris.push( subObject );\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvar angle = Math.PI;\n\n\t\t\t\tif ( numIterations === 0 ) {\n\n\t\t\t\t\ttempPlane2.normal.copy( tempPlane1.normal );\n\t\t\t\t\ttempPlane2.constant = tempPlane1.constant;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( numIterations <= maxRadialIterations ) {\n\n\t\t\t\t\t\tangle = ( endAngle - startAngle ) * ( 0.2 + 0.6 * Math.random() ) + startAngle;\n\n\t\t\t\t\t\t// Rotate tempPlane2 at impact point around normal axis and the angle\n\t\t\t\t\t\tscope.tempVector3_2.copy( object.position ).sub( pointOfImpact ).applyAxisAngle( normal, angle ).add( pointOfImpact );\n\t\t\t\t\t\ttempPlane2.setFromCoplanarPoints( pointOfImpact, scope.tempVector3, scope.tempVector3_2 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tangle = ( ( 0.5 * ( numIterations & 1 ) ) + 0.2 * ( 2 - Math.random() ) ) * Math.PI;\n\n\t\t\t\t\t\t// Rotate tempPlane2 at object position around normal axis and the angle\n\t\t\t\t\t\tscope.tempVector3_2.copy( pointOfImpact ).sub( subObject.position ).applyAxisAngle( normal, angle ).add( subObject.position );\n\t\t\t\t\t\tscope.tempVector3_3.copy( normal ).add( subObject.position );\n\t\t\t\t\t\ttempPlane2.setFromCoplanarPoints( subObject.position, scope.tempVector3_3, scope.tempVector3_2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Perform the cut\n\t\t\t\tscope.cutByPlane( subObject, tempPlane2, scope.tempResultObjects );\n\n\t\t\t\tvar obj1 = scope.tempResultObjects.object1;\n\t\t\t\tvar obj2 = scope.tempResultObjects.object2;\n\n\t\t\t\tif ( obj1 ) {\n\n\t\t\t\t\tsubdivideRadial( obj1, startAngle, angle, numIterations + 1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( obj2 ) {\n\n\t\t\t\t\tsubdivideRadial( obj2, angle, endAngle, numIterations + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tsubdivideRadial( object, 0, 2 * Math.PI, 0 );\n\n\t\t\treturn debris;\n\n\t\t},\n\n\t\tcutByPlane: function ( object, plane, output ) {\n\n\t\t\t// Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\n\t\t\t// object2 can be null if the plane doesn't cut the object.\n\t\t\t// object1 can be null only in case of internal error\n\t\t\t// Returned value is number of pieces, 0 for error.\n\n\t\t\tvar geometry = object.geometry;\n\t\t\tvar coords = geometry.attributes.position.array;\n\t\t\tvar normals = geometry.attributes.normal.array;\n\n\t\t\tvar numPoints = coords.length / 3;\n\t\t\tvar numFaces = numPoints / 3;\n\n\t\t\tvar indices = geometry.getIndex();\n\n\t\t\tif ( indices ) {\n\n\t\t\t\tindices = indices.array;\n\t\t\t\tnumFaces = indices.length / 3;\n\n\t\t\t}\n\n\t\t\tfunction getVertexIndex( faceIdx, vert ) {\n\n\t\t\t\t// vert = 0, 1 or 2.\n\n\t\t\t\tvar idx = faceIdx * 3 + vert;\n\n\t\t\t\treturn indices ? indices[ idx ] : idx;\n\n\t\t\t}\n\n\t\t\tvar points1 = [];\n\t\t\tvar points2 = [];\n\n\t\t\tvar delta = this.smallDelta;\n\n\t\t\t// Reset segments mark\n\t\t\tvar numPointPairs = numPoints * numPoints;\n\t\t\tfor ( var i = 0; i < numPointPairs; i ++ ) this.segments[ i ] = false;\n\n\t\t\tvar p0 = this.tempVector3_P0;\n\t\t\tvar p1 = this.tempVector3_P1;\n\t\t\tvar n0 = this.tempVector3_N0;\n\t\t\tvar n1 = this.tempVector3_N1;\n\n\t\t\t// Iterate through the faces to mark edges shared by coplanar faces\n\t\t\tfor ( var i = 0; i < numFaces - 1; i ++ ) {\n\n\t\t\t\tvar a1 = getVertexIndex( i, 0 );\n\t\t\t\tvar b1 = getVertexIndex( i, 1 );\n\t\t\t\tvar c1 = getVertexIndex( i, 2 );\n\n\t\t\t\t// Assuming all 3 vertices have the same normal\n\t\t\t\tn0.set( normals[ a1 ], normals[ a1 ] + 1, normals[ a1 ] + 2 );\n\n\t\t\t\tfor ( var j = i + 1; j < numFaces; j ++ ) {\n\n\t\t\t\t\tvar a2 = getVertexIndex( j, 0 );\n\t\t\t\t\tvar b2 = getVertexIndex( j, 1 );\n\t\t\t\t\tvar c2 = getVertexIndex( j, 2 );\n\n\t\t\t\t\t// Assuming all 3 vertices have the same normal\n\t\t\t\t\tn1.set( normals[ a2 ], normals[ a2 ] + 1, normals[ a2 ] + 2 );\n\n\t\t\t\t\tvar coplanar = 1 - n0.dot( n1 ) < delta;\n\n\t\t\t\t\tif ( coplanar ) {\n\n\t\t\t\t\t\tif ( a1 === a2 || a1 === b2 || a1 === c2 ) {\n\n\t\t\t\t\t\t\tif ( b1 === a2 || b1 === b2 || b1 === c2 ) {\n\n\t\t\t\t\t\t\t\tthis.segments[ a1 * numPoints + b1 ] = true;\n\t\t\t\t\t\t\t\tthis.segments[ b1 * numPoints + a1 ] = true;\n\n\t\t\t\t\t\t\t}\telse {\n\n\t\t\t\t\t\t\t\tthis.segments[ c1 * numPoints + a1 ] = true;\n\t\t\t\t\t\t\t\tthis.segments[ a1 * numPoints + c1 ] = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\telse if ( b1 === a2 || b1 === b2 || b1 === c2 ) {\n\n\t\t\t\t\t\t\tthis.segments[ c1 * numPoints + b1 ] = true;\n\t\t\t\t\t\t\tthis.segments[ b1 * numPoints + c1 ] = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Transform the plane to object local space\n\t\t\tvar localPlane = this.tempPlane_Cut;\n\t\t\tobject.updateMatrix();\n\t\t\tTHREE.ConvexObjectBreaker.transformPlaneToLocalSpace( plane, object.matrix, localPlane );\n\n\t\t\t// Iterate through the faces adding points to both pieces\n\t\t\tfor ( var i = 0; i < numFaces; i ++ ) {\n\n\t\t\t\tvar va = getVertexIndex( i, 0 );\n\t\t\t\tvar vb = getVertexIndex( i, 1 );\n\t\t\t\tvar vc = getVertexIndex( i, 2 );\n\n\t\t\t\tfor ( var segment = 0; segment < 3; segment ++ ) {\n\n\t\t\t\t\tvar i0 = segment === 0 ? va : ( segment === 1 ? vb : vc );\n\t\t\t\t\tvar i1 = segment === 0 ? vb : ( segment === 1 ? vc : va );\n\n\t\t\t\t\tvar segmentState = this.segments[ i0 * numPoints + i1 ];\n\n\t\t\t\t\tif ( segmentState ) continue; // The segment already has been processed in another face\n\n\t\t\t\t\t// Mark segment as processed (also inverted segment)\n\t\t\t\t\tthis.segments[ i0 * numPoints + i1 ] = true;\n\t\t\t\t\tthis.segments[ i1 * numPoints + i0 ] = true;\n\n\t\t\t\t\tp0.set( coords[ 3 * i0 ], coords[ 3 * i0 + 1 ], coords[ 3 * i0 + 2 ] );\n\t\t\t\t\tp1.set( coords[ 3 * i1 ], coords[ 3 * i1 + 1 ], coords[ 3 * i1 + 2 ] );\n\n\t\t\t\t\t// mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\t\t\t\t\tvar mark0 = 0;\n\n\t\t\t\t\tvar d = localPlane.distanceToPoint( p0 );\n\n\t\t\t\t\tif ( d > delta ) {\n\n\t\t\t\t\t\tmark0 = 2;\n\t\t\t\t\t\tpoints2.push( p0.clone() );\n\n\t\t\t\t\t} else if ( d < - delta ) {\n\n\t\t\t\t\t\tmark0 = 1;\n\t\t\t\t\t\tpoints1.push( p0.clone() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmark0 = 3;\n\t\t\t\t\t\tpoints1.push( p0.clone() );\n\t\t\t\t\t\tpoints2.push( p0.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\t\t\t\t\tvar mark1 = 0;\n\n\t\t\t\t\tvar d = localPlane.distanceToPoint( p1 );\n\n\t\t\t\t\tif ( d > delta ) {\n\n\t\t\t\t\t\tmark1 = 2;\n\t\t\t\t\t\tpoints2.push( p1.clone() );\n\n\t\t\t\t\t} else if ( d < - delta ) {\n\n\t\t\t\t\t\tmark1 = 1;\n\t\t\t\t\t\tpoints1.push( p1.clone() );\n\n\t\t\t\t\t}\telse {\n\n\t\t\t\t\t\tmark1 = 3;\n\t\t\t\t\t\tpoints1.push( p1.clone() );\n\t\t\t\t\t\tpoints2.push( p1.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( mark0 === 1 && mark1 === 2 ) || ( mark0 === 2 && mark1 === 1 ) ) {\n\n\t\t\t\t\t\t// Intersection of segment with the plane\n\n\t\t\t\t\t\tthis.tempLine1.start.copy( p0 );\n\t\t\t\t\t\tthis.tempLine1.end.copy( p1 );\n\n\t\t\t\t\t\tvar intersection = new THREE.Vector3();\n\t\t\t\t\t\tintersection = localPlane.intersectLine( this.tempLine1, intersection );\n\n\t\t\t\t\t\tif ( intersection === undefined ) {\n\n\t\t\t\t\t\t\t// Shouldn't happen\n\t\t\t\t\t\t\tconsole.error( \"Internal error: segment does not intersect plane.\" );\n\t\t\t\t\t\t\toutput.segmentedObject1 = null;\n\t\t\t\t\t\t\toutput.segmentedObject2 = null;\n\t\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpoints1.push( intersection );\n\t\t\t\t\t\tpoints2.push( intersection.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Calculate debris mass (very fast and imprecise):\n\t\t\tvar newMass = object.userData.mass * 0.5;\n\n\t\t\t// Calculate debris Center of Mass (again fast and imprecise)\n\t\t\tthis.tempCM1.set( 0, 0, 0 );\n\t\t\tvar radius1 = 0;\n\t\t\tvar numPoints1 = points1.length;\n\n\t\t\tif ( numPoints1 > 0 ) {\n\n\t\t\t\tfor ( var i = 0; i < numPoints1; i ++ ) this.tempCM1.add( points1[ i ] );\n\n\t\t\t\tthis.tempCM1.divideScalar( numPoints1 );\n\t\t\t\tfor ( var i = 0; i < numPoints1; i ++ ) {\n\n\t\t\t\t\tvar p = points1[ i ];\n\t\t\t\t\tp.sub( this.tempCM1 );\n\t\t\t\t\tradius1 = Math.max( radius1, p.x, p.y, p.z );\n\n\t\t\t\t}\n\t\t\t\tthis.tempCM1.add( object.position );\n\n\t\t\t}\n\n\t\t\tthis.tempCM2.set( 0, 0, 0 );\n\t\t\tvar radius2 = 0;\n\t\t\tvar numPoints2 = points2.length;\n\t\t\tif ( numPoints2 > 0 ) {\n\n\t\t\t\tfor ( var i = 0; i < numPoints2; i ++ ) this.tempCM2.add( points2[ i ] );\n\n\t\t\t\tthis.tempCM2.divideScalar( numPoints2 );\n\t\t\t\tfor ( var i = 0; i < numPoints2; i ++ ) {\n\n\t\t\t\t\tvar p = points2[ i ];\n\t\t\t\t\tp.sub( this.tempCM2 );\n\t\t\t\t\tradius2 = Math.max( radius2, p.x, p.y, p.z );\n\n\t\t\t\t}\n\t\t\t\tthis.tempCM2.add( object.position );\n\n\t\t\t}\n\n\t\t\tvar object1 = null;\n\t\t\tvar object2 = null;\n\n\t\t\tvar numObjects = 0;\n\n\t\t\tif ( numPoints1 > 4 ) {\n\n\t\t\t\tobject1 = new THREE.Mesh( new THREE.ConvexBufferGeometry( points1 ), object.material );\n\t\t\t\tobject1.position.copy( this.tempCM1 );\n\t\t\t\tobject1.quaternion.copy( object.quaternion );\n\n\t\t\t\tthis.prepareBreakableObject( object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak );\n\n\t\t\t\tnumObjects ++;\n\n\t\t\t}\n\n\t\t\tif ( numPoints2 > 4 ) {\n\n\t\t\t\tobject2 = new THREE.Mesh( new THREE.ConvexBufferGeometry( points2 ), object.material );\n\t\t\t\tobject2.position.copy( this.tempCM2 );\n\t\t\t\tobject2.quaternion.copy( object.quaternion );\n\n\t\t\t\tthis.prepareBreakableObject( object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak );\n\n\t\t\t\tnumObjects ++;\n\n\t\t\t}\n\n\t\t\toutput.object1 = object1;\n\t\t\toutput.object2 = object2;\n\n\t\t\treturn numObjects;\n\n\t\t}\n\n\t};\n\n\tTHREE.ConvexObjectBreaker.transformFreeVector = function ( v, m ) {\n\n\t\t// input:\n\t\t// vector interpreted as a free vector\n\t\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n\t\tvar x = v.x, y = v.y, z = v.z;\n\t\tvar e = m.elements;\n\n\t\tv.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tv.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tv.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn v;\n\n\t};\n\n\tTHREE.ConvexObjectBreaker.transformFreeVectorInverse = function ( v, m ) {\n\n\t\t// input:\n\t\t// vector interpreted as a free vector\n\t\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n\t\tvar x = v.x, y = v.y, z = v.z;\n\t\tvar e = m.elements;\n\n\t\tv.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z;\n\t\tv.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z;\n\t\tv.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z;\n\n\t\treturn v;\n\n\t};\n\n\tTHREE.ConvexObjectBreaker.transformTiedVectorInverse = function ( v, m ) {\n\n\t\t// input:\n\t\t// vector interpreted as a tied (ordinary) vector\n\t\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n\t\tvar x = v.x, y = v.y, z = v.z;\n\t\tvar e = m.elements;\n\n\t\tv.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z - e[ 12 ];\n\t\tv.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z - e[ 13 ];\n\t\tv.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z - e[ 14 ];\n\n\t\treturn v;\n\n\t};\n\n\tTHREE.ConvexObjectBreaker.transformPlaneToLocalSpace = function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function transformPlaneToLocalSpace( plane, m, resultPlane ) {\n\n\t\t\tresultPlane.normal.copy( plane.normal );\n\t\t\tresultPlane.constant = plane.constant;\n\n\t\t\tvar referencePoint = THREE.ConvexObjectBreaker.transformTiedVectorInverse( plane.coplanarPoint( v1 ), m );\n\n\t\t\tTHREE.ConvexObjectBreaker.transformFreeVectorInverse( resultPlane.normal, m );\n\n\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\t\tresultPlane.constant = - referencePoint.dot( resultPlane.normal );\n\n\n\t\t};\n\n\t}();\n\t\n\treturn THREE.ConvexObjectBreaker;\n});\n"]}