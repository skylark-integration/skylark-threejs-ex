{"version":3,"sources":["misc/VolumeSlice.js"],"names":["define","THREE","threex","VolumeSlice","volume","index","axis","slice","this","Object","defineProperty","get","set","value","geometryNeedsUpdate","canvas","document","createElement","canvasBuffer","updateGeometry","canvasMap","Texture","minFilter","LinearFilter","wrapS","wrapT","ClampToEdgeWrapping","material","MeshBasicMaterial","map","side","DoubleSide","transparent","mesh","Mesh","geometry","matrixAutoUpdate","repaint","prototype","constructor","iLength","jLength","sliceAccess","ctx","ctxBuffer","imgData","getImageData","data","volumeData","upperThreshold","lowerThreshold","windowLow","windowHigh","pixelCount","dataType","j","i","label","colorMap","length","color","alpha","Math","floor","putImageData","drawImage","width","height","needsUpdate","extracted","extractPerpendicularPlane","matrix","planeWidth","planeHeight","getContext","dispose","PlaneBufferGeometry","identity","applyMatrix4","misc"],"mappings":"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","file":"../../misc/VolumeSlice.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var VolumeSlice = function (volume, index, axis) {\r\n        var slice = this;\r\n        this.volume = volume;\r\n        index = index || 0;\r\n        Object.defineProperty(this, 'index', {\r\n            get: function () {\r\n                return index;\r\n            },\r\n            set: function (value) {\r\n                index = value;\r\n                slice.geometryNeedsUpdate = true;\r\n                return index;\r\n            }\r\n        });\r\n        this.axis = axis || 'z';\r\n        this.canvas = document.createElement('canvas');\r\n        this.canvasBuffer = document.createElement('canvas');\r\n        this.updateGeometry();\r\n        var canvasMap = new THREE.Texture(this.canvas);\r\n        canvasMap.minFilter = THREE.LinearFilter;\r\n        canvasMap.wrapS = canvasMap.wrapT = THREE.ClampToEdgeWrapping;\r\n        var material = new THREE.MeshBasicMaterial({\r\n            map: canvasMap,\r\n            side: THREE.DoubleSide,\r\n            transparent: true\r\n        });\r\n        this.mesh = new THREE.Mesh(this.geometry, material);\r\n        this.mesh.matrixAutoUpdate = false;\r\n        this.geometryNeedsUpdate = true;\r\n        this.repaint();\r\n    };\r\n    VolumeSlice.prototype = {\r\n        constructor: VolumeSlice,\r\n        repaint: function () {\r\n            if (this.geometryNeedsUpdate) {\r\n                this.updateGeometry();\r\n            }\r\n            var iLength = this.iLength, jLength = this.jLength, sliceAccess = this.sliceAccess, volume = this.volume, canvas = this.canvasBuffer, ctx = this.ctxBuffer;\r\n            var imgData = ctx.getImageData(0, 0, iLength, jLength);\r\n            var data = imgData.data;\r\n            var volumeData = volume.data;\r\n            var upperThreshold = volume.upperThreshold;\r\n            var lowerThreshold = volume.lowerThreshold;\r\n            var windowLow = volume.windowLow;\r\n            var windowHigh = volume.windowHigh;\r\n            var pixelCount = 0;\r\n            if (volume.dataType === 'label') {\r\n                for (var j = 0; j < jLength; j++) {\r\n                    for (var i = 0; i < iLength; i++) {\r\n                        var label = volumeData[sliceAccess(i, j)];\r\n                        label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\r\n                        var color = this.colorMap[label];\r\n                        data[4 * pixelCount] = color >> 24 & 255;\r\n                        data[4 * pixelCount + 1] = color >> 16 & 255;\r\n                        data[4 * pixelCount + 2] = color >> 8 & 255;\r\n                        data[4 * pixelCount + 3] = color & 255;\r\n                        pixelCount++;\r\n                    }\r\n                }\r\n            } else {\r\n                for (var j = 0; j < jLength; j++) {\r\n                    for (var i = 0; i < iLength; i++) {\r\n                        var value = volumeData[sliceAccess(i, j)];\r\n                        var alpha = 255;\r\n                        alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0;\r\n                        value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\r\n                        value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\r\n                        data[4 * pixelCount] = value;\r\n                        data[4 * pixelCount + 1] = value;\r\n                        data[4 * pixelCount + 2] = value;\r\n                        data[4 * pixelCount + 3] = alpha;\r\n                        pixelCount++;\r\n                    }\r\n                }\r\n            }\r\n            ctx.putImageData(imgData, 0, 0);\r\n            this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\r\n            this.mesh.material.map.needsUpdate = true;\r\n        },\r\n        updateGeometry: function () {\r\n            var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\r\n            this.sliceAccess = extracted.sliceAccess;\r\n            this.jLength = extracted.jLength;\r\n            this.iLength = extracted.iLength;\r\n            this.matrix = extracted.matrix;\r\n            this.canvas.width = extracted.planeWidth;\r\n            this.canvas.height = extracted.planeHeight;\r\n            this.canvasBuffer.width = this.iLength;\r\n            this.canvasBuffer.height = this.jLength;\r\n            this.ctx = this.canvas.getContext('2d');\r\n            this.ctxBuffer = this.canvasBuffer.getContext('2d');\r\n            if (this.geometry)\r\n                this.geometry.dispose();\r\n            this.geometry = new THREE.PlaneBufferGeometry(extracted.planeWidth, extracted.planeHeight);\r\n            if (this.mesh) {\r\n                this.mesh.geometry = this.geometry;\r\n                this.mesh.matrix.identity();\r\n                this.mesh.applyMatrix4(this.matrix);\r\n            }\r\n            this.geometryNeedsUpdate = false;\r\n        }\r\n    };\r\n    return threex.misc.VolumeSlice = VolumeSlice;\r\n});"]}