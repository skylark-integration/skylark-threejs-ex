{"version":3,"sources":["misc/VolumeSlice.js"],"names":["define","THREE","VolumeSlice","volume","index","axis","slice","this","Object","defineProperty","get","set","value","geometryNeedsUpdate","canvas","document","createElement","canvasBuffer","updateGeometry","canvasMap","Texture","minFilter","LinearFilter","wrapS","wrapT","ClampToEdgeWrapping","material","MeshBasicMaterial","map","side","DoubleSide","transparent","mesh","Mesh","geometry","matrixAutoUpdate","repaint","prototype","constructor","iLength","jLength","sliceAccess","ctx","ctxBuffer","imgData","getImageData","data","volumeData","upperThreshold","lowerThreshold","windowLow","windowHigh","pixelCount","dataType","j","i","label","colorMap","length","color","alpha","Math","floor","putImageData","drawImage","width","height","needsUpdate","extracted","extractPerpendicularPlane","matrix","planeWidth","planeHeight","getContext","dispose","PlaneBufferGeometry","identity","applyMatrix4"],"mappings":"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","file":"../../misc/VolumeSlice.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * This class has been made to hold a slice of a volume data\n\t * @class\n\t * @author Valentin Demeusy / https://github.com/stity\n\t * @param   {THREE.Volume} volume    The associated volume\n\t * @param   {number}       [index=0] The index of the slice\n\t * @param   {string}       [axis='z']      For now only 'x', 'y' or 'z' but later it will change to a normal vector\n\t * @see THREE.Volume\n\t */\n\tTHREE.VolumeSlice = function ( volume, index, axis ) {\n\n\t\tvar slice = this;\n\t\t/**\n\t\t * @member {THREE.Volume} volume The associated volume\n\t\t */\n\t\tthis.volume = volume;\n\t\t/**\n\t\t * @member {Number} index The index of the slice, if changed, will automatically call updateGeometry at the next repaint\n\t\t */\n\t\tindex = index || 0;\n\t\tObject.defineProperty( this, 'index', {\n\t\t\tget: function () {\n\n\t\t\t\treturn index;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tindex = value;\n\t\t\t\tslice.geometryNeedsUpdate = true;\n\t\t\t\treturn index;\n\n\t\t\t}\n\t\t} );\n\t\t/**\n\t\t * @member {String} axis The normal axis\n\t\t */\n\t\tthis.axis = axis || 'z';\n\n\t\t/**\n\t\t * @member {HTMLCanvasElement} canvas The final canvas used for the texture\n\t\t */\n\t\t/**\n\t\t * @member {CanvasRenderingContext2D} ctx Context of the canvas\n\t\t */\n\t\tthis.canvas = document.createElement( 'canvas' );\n\t\t/**\n\t\t * @member {HTMLCanvasElement} canvasBuffer The intermediary canvas used to paint the data\n\t\t */\n\t\t/**\n\t\t * @member {CanvasRenderingContext2D} ctxBuffer Context of the canvas buffer\n\t\t */\n\t\tthis.canvasBuffer = document.createElement( 'canvas' );\n\t\tthis.updateGeometry();\n\n\n\t\tvar canvasMap = new THREE.Texture( this.canvas );\n\t\tcanvasMap.minFilter = THREE.LinearFilter;\n\t\tcanvasMap.wrapS = canvasMap.wrapT = THREE.ClampToEdgeWrapping;\n\t\tvar material = new THREE.MeshBasicMaterial( { map: canvasMap, side: THREE.DoubleSide, transparent: true } );\n\t\t/**\n\t\t * @member {THREE.Mesh} mesh The mesh ready to get used in the scene\n\t\t */\n\t\tthis.mesh = new THREE.Mesh( this.geometry, material );\n\t\tthis.mesh.matrixAutoUpdate = false;\n\t\t/**\n\t\t * @member {Boolean} geometryNeedsUpdate If set to true, updateGeometry will be triggered at the next repaint\n\t\t */\n\t\tthis.geometryNeedsUpdate = true;\n\t\tthis.repaint();\n\n\t\t/**\n\t\t * @member {Number} iLength Width of slice in the original coordinate system, corresponds to the width of the buffer canvas\n\t\t */\n\n\t\t/**\n\t\t * @member {Number} jLength Height of slice in the original coordinate system, corresponds to the height of the buffer canvas\n\t\t */\n\n\t\t/**\n\t\t * @member {Function} sliceAccess Function that allow the slice to access right data\n\t\t * @see THREE.Volume.extractPerpendicularPlane\n\t\t * @param {Number} i The first coordinate\n\t\t * @param {Number} j The second coordinate\n\t\t * @returns {Number} the index corresponding to the voxel in volume.data of the given position in the slice\n\t\t */\n\n\n\t};\n\n\tTHREE.VolumeSlice.prototype = {\n\n\t\tconstructor: THREE.VolumeSlice,\n\n\t\t/**\n\t\t * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n\t\t * @memberof THREE.VolumeSlice\n\t\t */\n\t\trepaint: function () {\n\n\t\t\tif ( this.geometryNeedsUpdate ) {\n\n\t\t\t\tthis.updateGeometry();\n\n\t\t\t}\n\n\t\t\tvar iLength = this.iLength,\n\t\t\t\tjLength = this.jLength,\n\t\t\t\tsliceAccess = this.sliceAccess,\n\t\t\t\tvolume = this.volume,\n\t\t\t\tcanvas = this.canvasBuffer,\n\t\t\t\tctx = this.ctxBuffer;\n\n\n\t\t\t// get the imageData and pixel array from the canvas\n\t\t\tvar imgData = ctx.getImageData( 0, 0, iLength, jLength );\n\t\t\tvar data = imgData.data;\n\t\t\tvar volumeData = volume.data;\n\t\t\tvar upperThreshold = volume.upperThreshold;\n\t\t\tvar lowerThreshold = volume.lowerThreshold;\n\t\t\tvar windowLow = volume.windowLow;\n\t\t\tvar windowHigh = volume.windowHigh;\n\n\t\t\t// manipulate some pixel elements\n\t\t\tvar pixelCount = 0;\n\n\t\t\tif ( volume.dataType === 'label' ) {\n\n\t\t\t\t//this part is currently useless but will be used when colortables will be handled\n\t\t\t\tfor ( var j = 0; j < jLength; j ++ ) {\n\n\t\t\t\t\tfor ( var i = 0; i < iLength; i ++ ) {\n\n\t\t\t\t\t\tvar label = volumeData[ sliceAccess( i, j ) ];\n\t\t\t\t\t\tlabel = label >= this.colorMap.length ? ( label % this.colorMap.length ) + 1 : label;\n\t\t\t\t\t\tvar color = this.colorMap[ label ];\n\t\t\t\t\t\tdata[ 4 * pixelCount ] = ( color >> 24 ) & 0xff;\n\t\t\t\t\t\tdata[ 4 * pixelCount + 1 ] = ( color >> 16 ) & 0xff;\n\t\t\t\t\t\tdata[ 4 * pixelCount + 2 ] = ( color >> 8 ) & 0xff;\n\t\t\t\t\t\tdata[ 4 * pixelCount + 3 ] = color & 0xff;\n\t\t\t\t\t\tpixelCount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var j = 0; j < jLength; j ++ ) {\n\n\t\t\t\t\tfor ( var i = 0; i < iLength; i ++ ) {\n\n\t\t\t\t\t\tvar value = volumeData[ sliceAccess( i, j ) ];\n\t\t\t\t\t\tvar alpha = 0xff;\n\t\t\t\t\t\t//apply threshold\n\t\t\t\t\t\talpha = upperThreshold >= value ? ( lowerThreshold <= value ? alpha : 0 ) : 0;\n\t\t\t\t\t\t//apply window level\n\t\t\t\t\t\tvalue = Math.floor( 255 * ( value - windowLow ) / ( windowHigh - windowLow ) );\n\t\t\t\t\t\tvalue = value > 255 ? 255 : ( value < 0 ? 0 : value | 0 );\n\n\t\t\t\t\t\tdata[ 4 * pixelCount ] = value;\n\t\t\t\t\t\tdata[ 4 * pixelCount + 1 ] = value;\n\t\t\t\t\t\tdata[ 4 * pixelCount + 2 ] = value;\n\t\t\t\t\t\tdata[ 4 * pixelCount + 3 ] = alpha;\n\t\t\t\t\t\tpixelCount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tctx.putImageData( imgData, 0, 0 );\n\t\t\tthis.ctx.drawImage( canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height );\n\n\n\t\t\tthis.mesh.material.map.needsUpdate = true;\n\n\t\t},\n\n\t\t/**\n\t\t * @member {Function} Refresh the geometry according to axis and index\n\t\t * @see THREE.Volume.extractPerpendicularPlane\n\t\t * @memberof THREE.VolumeSlice\n\t\t */\n\t\tupdateGeometry: function () {\n\n\t\t\tvar extracted = this.volume.extractPerpendicularPlane( this.axis, this.index );\n\t\t\tthis.sliceAccess = extracted.sliceAccess;\n\t\t\tthis.jLength = extracted.jLength;\n\t\t\tthis.iLength = extracted.iLength;\n\t\t\tthis.matrix = extracted.matrix;\n\n\t\t\tthis.canvas.width = extracted.planeWidth;\n\t\t\tthis.canvas.height = extracted.planeHeight;\n\t\t\tthis.canvasBuffer.width = this.iLength;\n\t\t\tthis.canvasBuffer.height = this.jLength;\n\t\t\tthis.ctx = this.canvas.getContext( '2d' );\n\t\t\tthis.ctxBuffer = this.canvasBuffer.getContext( '2d' );\n\n\t\t\tif ( this.geometry ) this.geometry.dispose(); // dispose existing geometry\n\n\t\t\tthis.geometry = new THREE.PlaneBufferGeometry( extracted.planeWidth, extracted.planeHeight );\n\n\t\t\tif ( this.mesh ) {\n\n\t\t\t\tthis.mesh.geometry = this.geometry;\n\t\t\t\t//reset mesh matrix\n\t\t\t\tthis.mesh.matrix.identity();\n\t\t\t\tthis.mesh.applyMatrix4( this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.geometryNeedsUpdate = false;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.VolumeSlice;\n});\n"]}