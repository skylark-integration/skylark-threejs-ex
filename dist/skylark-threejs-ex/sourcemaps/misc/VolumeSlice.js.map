{"version":3,"sources":["misc/VolumeSlice.js"],"names":["define","THREE","VolumeSlice","volume","index","axis","slice","this","Object","defineProperty","get","set","value","geometryNeedsUpdate","canvas","document","createElement","canvasBuffer","updateGeometry","canvasMap","Texture","minFilter","LinearFilter","wrapS","wrapT","ClampToEdgeWrapping","material","MeshBasicMaterial","map","side","DoubleSide","transparent","mesh","Mesh","geometry","matrixAutoUpdate","repaint","prototype","constructor","iLength","jLength","sliceAccess","ctx","ctxBuffer","imgData","getImageData","data","volumeData","upperThreshold","lowerThreshold","windowLow","windowHigh","pixelCount","dataType","j","i","label","colorMap","length","color","alpha","Math","floor","putImageData","drawImage","width","height","needsUpdate","extracted","extractPerpendicularPlane","matrix","planeWidth","planeHeight","getContext","dispose","PlaneBufferGeometry","identity","applyMatrix4"],"mappings":"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","file":"../../misc/VolumeSlice.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var VolumeSlice = function (volume, index, axis) {\n        var slice = this;\n        this.volume = volume;\n        index = index || 0;\n        Object.defineProperty(this, 'index', {\n            get: function () {\n                return index;\n            },\n            set: function (value) {\n                index = value;\n                slice.geometryNeedsUpdate = true;\n                return index;\n            }\n        });\n        this.axis = axis || 'z';\n        this.canvas = document.createElement('canvas');\n        this.canvasBuffer = document.createElement('canvas');\n        this.updateGeometry();\n        var canvasMap = new THREE.Texture(this.canvas);\n        canvasMap.minFilter = THREE.LinearFilter;\n        canvasMap.wrapS = canvasMap.wrapT = THREE.ClampToEdgeWrapping;\n        var material = new THREE.MeshBasicMaterial({\n            map: canvasMap,\n            side: THREE.DoubleSide,\n            transparent: true\n        });\n        this.mesh = new THREE.Mesh(this.geometry, material);\n        this.mesh.matrixAutoUpdate = false;\n        this.geometryNeedsUpdate = true;\n        this.repaint();\n    };\n    VolumeSlice.prototype = {\n        constructor: VolumeSlice,\n        repaint: function () {\n            if (this.geometryNeedsUpdate) {\n                this.updateGeometry();\n            }\n            var iLength = this.iLength, jLength = this.jLength, sliceAccess = this.sliceAccess, volume = this.volume, canvas = this.canvasBuffer, ctx = this.ctxBuffer;\n            var imgData = ctx.getImageData(0, 0, iLength, jLength);\n            var data = imgData.data;\n            var volumeData = volume.data;\n            var upperThreshold = volume.upperThreshold;\n            var lowerThreshold = volume.lowerThreshold;\n            var windowLow = volume.windowLow;\n            var windowHigh = volume.windowHigh;\n            var pixelCount = 0;\n            if (volume.dataType === 'label') {\n                for (var j = 0; j < jLength; j++) {\n                    for (var i = 0; i < iLength; i++) {\n                        var label = volumeData[sliceAccess(i, j)];\n                        label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\n                        var color = this.colorMap[label];\n                        data[4 * pixelCount] = color >> 24 & 255;\n                        data[4 * pixelCount + 1] = color >> 16 & 255;\n                        data[4 * pixelCount + 2] = color >> 8 & 255;\n                        data[4 * pixelCount + 3] = color & 255;\n                        pixelCount++;\n                    }\n                }\n            } else {\n                for (var j = 0; j < jLength; j++) {\n                    for (var i = 0; i < iLength; i++) {\n                        var value = volumeData[sliceAccess(i, j)];\n                        var alpha = 255;\n                        alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0;\n                        value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\n                        value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\n                        data[4 * pixelCount] = value;\n                        data[4 * pixelCount + 1] = value;\n                        data[4 * pixelCount + 2] = value;\n                        data[4 * pixelCount + 3] = alpha;\n                        pixelCount++;\n                    }\n                }\n            }\n            ctx.putImageData(imgData, 0, 0);\n            this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\n            this.mesh.material.map.needsUpdate = true;\n        },\n        updateGeometry: function () {\n            var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\n            this.sliceAccess = extracted.sliceAccess;\n            this.jLength = extracted.jLength;\n            this.iLength = extracted.iLength;\n            this.matrix = extracted.matrix;\n            this.canvas.width = extracted.planeWidth;\n            this.canvas.height = extracted.planeHeight;\n            this.canvasBuffer.width = this.iLength;\n            this.canvasBuffer.height = this.jLength;\n            this.ctx = this.canvas.getContext('2d');\n            this.ctxBuffer = this.canvasBuffer.getContext('2d');\n            if (this.geometry)\n                this.geometry.dispose();\n            this.geometry = new THREE.PlaneBufferGeometry(extracted.planeWidth, extracted.planeHeight);\n            if (this.mesh) {\n                this.mesh.geometry = this.geometry;\n                this.mesh.matrix.identity();\n                this.mesh.applyMatrix4(this.matrix);\n            }\n            this.geometryNeedsUpdate = false;\n        }\n    };\n    return VolumeSlice;\n});"]}