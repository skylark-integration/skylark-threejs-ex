{"version":3,"sources":["objects/Sky.js"],"names":["define","THREE","threex","Sky","shader","SkyShader","material","ShaderMaterial","fragmentShader","vertexShader","uniforms","UniformsUtils","clone","side","BackSide","depthWrite","Mesh","call","this","BoxBufferGeometry","prototype","Object","create","luminance","value","turbidity","rayleigh","mieCoefficient","mieDirectionalG","sunPosition","Vector3","up","join","objects"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,EAAM,WACN,IAAIC,EAASD,EAAIE,UACbC,EAAW,IAAIL,EAAMM,gBACrBC,eAAgBJ,EAAOI,eACvBC,aAAcL,EAAOK,aACrBC,SAAUT,EAAMU,cAAcC,MAAMR,EAAOM,UAC3CG,KAAMZ,EAAMa,SACZC,YAAY,IAEhBd,EAAMe,KAAKC,KAAKC,KAAM,IAAIjB,EAAMkB,kBAAkB,EAAG,EAAG,GAAIb,IAyHhE,OAvHAH,EAAIiB,UAAYC,OAAOC,OAAOrB,EAAMe,KAAKI,WACzCjB,EAAIE,WACAK,UACIa,WAAeC,MAAO,GACtBC,WAAeD,MAAO,GACtBE,UAAcF,MAAO,GACrBG,gBAAoBH,MAAO,MAC3BI,iBAAqBJ,MAAO,IAC5BK,aAAiBL,MAAO,IAAIvB,EAAM6B,SAClCC,IAAQP,MAAO,IAAIvB,EAAM6B,QAAQ,EAAG,EAAG,KAE3CrB,cACI,4BACA,0BACA,2BACA,gCACA,mBACA,+BACA,8BACA,0BACA,uBACA,uBACA,uBACA,2EACA,iEACA,sDACA,yGACA,uBACA,8CACA,qGACA,gDACA,+BACA,2BACA,+CACA,yDACA,uGACA,IACA,6BACA,oCACA,iCACA,IACA,gBACA,8DACA,wCACA,8EACA,mCACA,8CACA,sDACA,mFACA,yEACA,kDACA,qDACA,KACFuB,KAAK,MACPxB,gBACI,+BACA,8BACA,0BACA,uBACA,uBACA,uBACA,2BACA,iCACA,mBACA,gDACA,iEACA,0BACA,4BACA,4CACA,wCACA,mGACA,0DACA,qDACA,0CACA,kEACA,IACA,6CACA,8BACA,qEACA,yDACA,IACA,wBACA,wBACA,wBACA,wBACA,wBACA,wBACA,+CACA,qCACA,0FACA,IACA,gBACA,8DACA,kEACA,oHACA,+CACA,0CACA,sDACA,sDACA,0DACA,uCACA,yDACA,uCACA,kHACA,6LACA,iFACA,yFACA,4EACA,iCACA,oGACA,+CACA,wEACA,yFACA,oCACA,8EACA,0CACA,KACFwB,KAAK,OAEJ9B,EAAO+B,QAAQ9B,IAAMA","file":"../../objects/Sky.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var Sky = function () {\r\n        var shader = Sky.SkyShader;\r\n        var material = new THREE.ShaderMaterial({\r\n            fragmentShader: shader.fragmentShader,\r\n            vertexShader: shader.vertexShader,\r\n            uniforms: THREE.UniformsUtils.clone(shader.uniforms),\r\n            side: THREE.BackSide,\r\n            depthWrite: false\r\n        });\r\n        THREE.Mesh.call(this, new THREE.BoxBufferGeometry(1, 1, 1), material);\r\n    };\r\n    Sky.prototype = Object.create(THREE.Mesh.prototype);\r\n    Sky.SkyShader = {\r\n        uniforms: {\r\n            'luminance': { value: 1 },\r\n            'turbidity': { value: 2 },\r\n            'rayleigh': { value: 1 },\r\n            'mieCoefficient': { value: 0.005 },\r\n            'mieDirectionalG': { value: 0.8 },\r\n            'sunPosition': { value: new THREE.Vector3() },\r\n            'up': { value: new THREE.Vector3(0, 1, 0) }\r\n        },\r\n        vertexShader: [\r\n            'uniform vec3 sunPosition;',\r\n            'uniform float rayleigh;',\r\n            'uniform float turbidity;',\r\n            'uniform float mieCoefficient;',\r\n            'uniform vec3 up;',\r\n            'varying vec3 vWorldPosition;',\r\n            'varying vec3 vSunDirection;',\r\n            'varying float vSunfade;',\r\n            'varying vec3 vBetaR;',\r\n            'varying vec3 vBetaM;',\r\n            'varying float vSunE;',\r\n            'const float e = 2.71828182845904523536028747135266249775724709369995957;',\r\n            'const float pi = 3.141592653589793238462643383279502884197169;',\r\n            'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );',\r\n            'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );',\r\n            'const float v = 4.0;',\r\n            'const vec3 K = vec3( 0.686, 0.678, 0.666 );',\r\n            'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );',\r\n            'const float cutoffAngle = 1.6110731556870734;',\r\n            'const float steepness = 1.5;',\r\n            'const float EE = 1000.0;',\r\n            'float sunIntensity( float zenithAngleCos ) {',\r\n            '\\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );',\r\n            '\\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );',\r\n            '}',\r\n            'vec3 totalMie( float T ) {',\r\n            '\\tfloat c = ( 0.2 * T ) * 10E-18;',\r\n            '\\treturn 0.434 * c * MieConst;',\r\n            '}',\r\n            'void main() {',\r\n            '\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\r\n            '\\tvWorldPosition = worldPosition.xyz;',\r\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n            '\\tgl_Position.z = gl_Position.w;',\r\n            '\\tvSunDirection = normalize( sunPosition );',\r\n            '\\tvSunE = sunIntensity( dot( vSunDirection, up ) );',\r\n            '\\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );',\r\n            '\\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );',\r\n            '\\tvBetaR = totalRayleigh * rayleighCoefficient;',\r\n            '\\tvBetaM = totalMie( turbidity ) * mieCoefficient;',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            'varying vec3 vWorldPosition;',\r\n            'varying vec3 vSunDirection;',\r\n            'varying float vSunfade;',\r\n            'varying vec3 vBetaR;',\r\n            'varying vec3 vBetaM;',\r\n            'varying float vSunE;',\r\n            'uniform float luminance;',\r\n            'uniform float mieDirectionalG;',\r\n            'uniform vec3 up;',\r\n            'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );',\r\n            'const float pi = 3.141592653589793238462643383279502884197169;',\r\n            'const float n = 1.0003;',\r\n            'const float N = 2.545E25;',\r\n            'const float rayleighZenithLength = 8.4E3;',\r\n            'const float mieZenithLength = 1.25E3;',\r\n            'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;',\r\n            'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;',\r\n            'const float ONE_OVER_FOURPI = 0.07957747154594767;',\r\n            'float rayleighPhase( float cosTheta ) {',\r\n            '\\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );',\r\n            '}',\r\n            'float hgPhase( float cosTheta, float g ) {',\r\n            '\\tfloat g2 = pow( g, 2.0 );',\r\n            '\\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );',\r\n            '\\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );',\r\n            '}',\r\n            'const float A = 0.15;',\r\n            'const float B = 0.50;',\r\n            'const float C = 0.10;',\r\n            'const float D = 0.20;',\r\n            'const float E = 0.02;',\r\n            'const float F = 0.30;',\r\n            'const float whiteScale = 1.0748724675633854;',\r\n            'vec3 Uncharted2Tonemap( vec3 x ) {',\r\n            '\\treturn ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;',\r\n            '}',\r\n            'void main() {',\r\n            '\\tvec3 direction = normalize( vWorldPosition - cameraPos );',\r\n            '\\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );',\r\n            '\\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );',\r\n            '\\tfloat sR = rayleighZenithLength * inverse;',\r\n            '\\tfloat sM = mieZenithLength * inverse;',\r\n            '\\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );',\r\n            '\\tfloat cosTheta = dot( direction, vSunDirection );',\r\n            '\\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );',\r\n            '\\tvec3 betaRTheta = vBetaR * rPhase;',\r\n            '\\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );',\r\n            '\\tvec3 betaMTheta = vBetaM * mPhase;',\r\n            '\\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );',\r\n            '\\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );',\r\n            '\\tfloat theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]',\r\n            '\\tfloat phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]',\r\n            '\\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );',\r\n            '\\tvec3 L0 = vec3( 0.1 ) * Fex;',\r\n            '\\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );',\r\n            '\\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;',\r\n            '\\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );',\r\n            '\\tvec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );',\r\n            '\\tvec3 color = curr * whiteScale;',\r\n            '\\tvec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );',\r\n            '\\tgl_FragColor = vec4( retColor, 1.0 );',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    return threex.objects.Sky = Sky;\r\n});"]}