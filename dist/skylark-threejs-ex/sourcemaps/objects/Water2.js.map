{"version":3,"sources":["objects/Water2.js"],"names":["define","THREE","Reflector","Refractor","Water","geometry","options","Mesh","call","this","type","scope","color","undefined","Color","textureWidth","textureHeight","clipBias","flowDirection","Vector2","flowSpeed","reflectivity","scale","shader","WaterShader","encoding","LinearEncoding","textureLoader","TextureLoader","flowMap","normalMap0","load","normalMap1","cycle","halfCycle","textureMatrix","Matrix4","clock","Clock","reflector","refractor","matrixAutoUpdate","material","ShaderMaterial","uniforms","UniformsUtils","merge","UniformsLib","vertexShader","fragmentShader","transparent","fog","defines","USE_FLOWMAP","value","wrapS","wrapT","RepeatWrapping","getRenderTarget","texture","x","y","z","w","onBeforeRender","renderer","scene","camera","delta","config","set","multiply","projectionMatrix","matrixWorldInverse","matrixWorld","updateTextureMatrix","getDelta","visible","copy","console","error","prototype","Object","create","constructor","tReflectionMap","tRefractionMap","tNormalMap0","tNormalMap1","Vector4","join"],"mappings":"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","file":"../../objects/Water2.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"./Reflector\",\n\t\"./Refractor\"\n],function(THREE,Reflector,Refractor){\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * References:\n\t *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\n\t * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\n\t *\n\t */\n\n\tTHREE.Water = function ( geometry, options ) {\n\n\t\tTHREE.Mesh.call( this, geometry );\n\n\t\tthis.type = 'Water';\n\n\t\tvar scope = this;\n\n\t\toptions = options || {};\n\n\t\tvar color = ( options.color !== undefined ) ? new THREE.Color( options.color ) : new THREE.Color( 0xFFFFFF );\n\t\tvar textureWidth = options.textureWidth || 512;\n\t\tvar textureHeight = options.textureHeight || 512;\n\t\tvar clipBias = options.clipBias || 0;\n\t\tvar flowDirection = options.flowDirection || new THREE.Vector2( 1, 0 );\n\t\tvar flowSpeed = options.flowSpeed || 0.03;\n\t\tvar reflectivity = options.reflectivity || 0.02;\n\t\tvar scale = options.scale || 1;\n\t\tvar shader = options.shader || THREE.Water.WaterShader;\n\t\tvar encoding = options.encoding !== undefined ? options.encoding : THREE.LinearEncoding;\n\n\t\tvar textureLoader = new THREE.TextureLoader();\n\n\t\tvar flowMap = options.flowMap || undefined;\n\t\tvar normalMap0 = options.normalMap0 || textureLoader.load( 'textures/water/Water_1_M_Normal.jpg' );\n\t\tvar normalMap1 = options.normalMap1 || textureLoader.load( 'textures/water/Water_2_M_Normal.jpg' );\n\n\t\tvar cycle = 0.15; // a cycle of a flow map phase\n\t\tvar halfCycle = cycle * 0.5;\n\t\tvar textureMatrix = new THREE.Matrix4();\n\t\tvar clock = new THREE.Clock();\n\n\t\t// internal components\n\n\t\tif ( THREE.Reflector === undefined ) {\n\n\t\t\tconsole.error( 'THREE.Water: Required component THREE.Reflector not found.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( THREE.Refractor === undefined ) {\n\n\t\t\tconsole.error( 'THREE.Water: Required component THREE.Refractor not found.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar reflector = new THREE.Reflector( geometry, {\n\t\t\ttextureWidth: textureWidth,\n\t\t\ttextureHeight: textureHeight,\n\t\t\tclipBias: clipBias,\n\t\t\tencoding: encoding\n\t\t} );\n\n\t\tvar refractor = new THREE.Refractor( geometry, {\n\t\t\ttextureWidth: textureWidth,\n\t\t\ttextureHeight: textureHeight,\n\t\t\tclipBias: clipBias,\n\t\t\tencoding: encoding\n\t\t} );\n\n\t\treflector.matrixAutoUpdate = false;\n\t\trefractor.matrixAutoUpdate = false;\n\n\t\t// material\n\n\t\tthis.material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\t\tshader.uniforms\n\t\t\t] ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\ttransparent: true,\n\t\t\tfog: true\n\t\t} );\n\n\t\tif ( flowMap !== undefined ) {\n\n\t\t\tthis.material.defines.USE_FLOWMAP = '';\n\t\t\tthis.material.uniforms[ \"tFlowMap\" ] = {\n\t\t\t\ttype: 't',\n\t\t\t\tvalue: flowMap\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tthis.material.uniforms[ \"flowDirection\" ] = {\n\t\t\t\ttype: 'v2',\n\t\t\t\tvalue: flowDirection\n\t\t\t};\n\n\t\t}\n\n\t\t// maps\n\n\t\tnormalMap0.wrapS = normalMap0.wrapT = THREE.RepeatWrapping;\n\t\tnormalMap1.wrapS = normalMap1.wrapT = THREE.RepeatWrapping;\n\n\t\tthis.material.uniforms[ \"tReflectionMap\" ].value = reflector.getRenderTarget().texture;\n\t\tthis.material.uniforms[ \"tRefractionMap\" ].value = refractor.getRenderTarget().texture;\n\t\tthis.material.uniforms[ \"tNormalMap0\" ].value = normalMap0;\n\t\tthis.material.uniforms[ \"tNormalMap1\" ].value = normalMap1;\n\n\t\t// water\n\n\t\tthis.material.uniforms[ \"color\" ].value = color;\n\t\tthis.material.uniforms[ \"reflectivity\" ].value = reflectivity;\n\t\tthis.material.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\n\t\t// inital values\n\n\t\tthis.material.uniforms[ \"config\" ].value.x = 0; // flowMapOffset0\n\t\tthis.material.uniforms[ \"config\" ].value.y = halfCycle; // flowMapOffset1\n\t\tthis.material.uniforms[ \"config\" ].value.z = halfCycle; // halfCycle\n\t\tthis.material.uniforms[ \"config\" ].value.w = scale; // scale\n\n\t\t// functions\n\n\t\tfunction updateTextureMatrix( camera ) {\n\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\n\t\t\ttextureMatrix.multiply( camera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t}\n\n\t\tfunction updateFlow() {\n\n\t\t\tvar delta = clock.getDelta();\n\t\t\tvar config = scope.material.uniforms[ \"config\" ];\n\n\t\t\tconfig.value.x += flowSpeed * delta; // flowMapOffset0\n\t\t\tconfig.value.y = config.value.x + halfCycle; // flowMapOffset1\n\n\t\t\t// Important: The distance between offsets should be always the value of \"halfCycle\".\n\t\t\t// Moreover, both offsets should be in the range of [ 0, cycle ].\n\t\t\t// This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n\t\t\tif ( config.value.x >= cycle ) {\n\n\t\t\t\tconfig.value.x = 0;\n\t\t\t\tconfig.value.y = halfCycle;\n\n\t\t\t} else if ( config.value.y >= cycle ) {\n\n\t\t\t\tconfig.value.y = config.value.y - cycle;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\tupdateTextureMatrix( camera );\n\t\t\tupdateFlow();\n\n\t\t\tscope.visible = false;\n\n\t\t\treflector.matrixWorld.copy( scope.matrixWorld );\n\t\t\trefractor.matrixWorld.copy( scope.matrixWorld );\n\n\t\t\treflector.onBeforeRender( renderer, scene, camera );\n\t\t\trefractor.onBeforeRender( renderer, scene, camera );\n\n\t\t\tscope.visible = true;\n\n\t\t};\n\n\t};\n\n\tTHREE.Water.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.Water.prototype.constructor = THREE.Water;\n\n\tTHREE.Water.WaterShader = {\n\n\t\tuniforms: {\n\n\t\t\t'color': {\n\t\t\t\ttype: 'c',\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'reflectivity': {\n\t\t\t\ttype: 'f',\n\t\t\t\tvalue: 0\n\t\t\t},\n\n\t\t\t'tReflectionMap': {\n\t\t\t\ttype: 't',\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'tRefractionMap': {\n\t\t\t\ttype: 't',\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'tNormalMap0': {\n\t\t\t\ttype: 't',\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'tNormalMap1': {\n\t\t\t\ttype: 't',\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'textureMatrix': {\n\t\t\t\ttype: 'm4',\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'config': {\n\t\t\t\ttype: 'v4',\n\t\t\t\tvalue: new THREE.Vector4()\n\t\t\t}\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t'#include <common>',\n\t\t\t'#include <fog_pars_vertex>',\n\t\t\t'#include <logdepthbuf_pars_vertex>',\n\n\t\t\t'uniform mat4 textureMatrix;',\n\n\t\t\t'varying vec4 vCoord;',\n\t\t\t'varying vec2 vUv;',\n\t\t\t'varying vec3 vToEye;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvUv = uv;',\n\t\t\t'\tvCoord = textureMatrix * vec4( position, 1.0 );',\n\n\t\t\t'\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\n\t\t\t'\tvToEye = cameraPosition - worldPosition.xyz;',\n\n\t\t\t'\tvec4 mvPosition =  viewMatrix * worldPosition;', // used in fog_vertex\n\t\t\t'\tgl_Position = projectionMatrix * mvPosition;',\n\n\t\t\t'\t#include <logdepthbuf_vertex>',\n\t\t\t'\t#include <fog_vertex>',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\n\t\t\t'#include <common>',\n\t\t\t'#include <fog_pars_fragment>',\n\t\t\t'#include <logdepthbuf_pars_fragment>',\n\n\t\t\t'uniform sampler2D tReflectionMap;',\n\t\t\t'uniform sampler2D tRefractionMap;',\n\t\t\t'uniform sampler2D tNormalMap0;',\n\t\t\t'uniform sampler2D tNormalMap1;',\n\n\t\t\t'#ifdef USE_FLOWMAP',\n\t\t\t'\tuniform sampler2D tFlowMap;',\n\t\t\t'#else',\n\t\t\t'\tuniform vec2 flowDirection;',\n\t\t\t'#endif',\n\n\t\t\t'uniform vec3 color;',\n\t\t\t'uniform float reflectivity;',\n\t\t\t'uniform vec4 config;',\n\n\t\t\t'varying vec4 vCoord;',\n\t\t\t'varying vec2 vUv;',\n\t\t\t'varying vec3 vToEye;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\t#include <logdepthbuf_fragment>',\n\n\t\t\t'\tfloat flowMapOffset0 = config.x;',\n\t\t\t'\tfloat flowMapOffset1 = config.y;',\n\t\t\t'\tfloat halfCycle = config.z;',\n\t\t\t'\tfloat scale = config.w;',\n\n\t\t\t'\tvec3 toEye = normalize( vToEye );',\n\n\t\t\t// determine flow direction\n\t\t\t'\tvec2 flow;',\n\t\t\t'\t#ifdef USE_FLOWMAP',\n\t\t\t'\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;',\n\t\t\t'\t#else',\n\t\t\t'\t\tflow = flowDirection;',\n\t\t\t'\t#endif',\n\t\t\t'\tflow.x *= - 1.0;',\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\t'\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );',\n\t\t\t'\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );',\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\t'\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;',\n\t\t\t'\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );',\n\n\t\t\t// calculate normal vector\n\t\t\t'\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );',\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\t'\tfloat theta = max( dot( toEye, normal ), 0.0 );',\n\t\t\t'\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );',\n\n\t\t\t// calculate final uv coords\n\t\t\t'\tvec3 coord = vCoord.xyz / vCoord.w;',\n\t\t\t'\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;',\n\n\t\t\t'\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );',\n\t\t\t'\tvec4 refractColor = texture2D( tRefractionMap, uv );',\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\t'\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );',\n\n\t\t\t'\t#include <tonemapping_fragment>',\n\t\t\t'\t#include <encodings_fragment>',\n\t\t\t'\t#include <fog_fragment>',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' )\n\t};\n\t\n\treturn THREE.Water;\n});\n"]}