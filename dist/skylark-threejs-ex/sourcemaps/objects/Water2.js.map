{"version":3,"sources":["objects/Water2.js"],"names":["define","THREE","threex","Reflector","Refractor","Water","geometry","options","Mesh","call","this","type","scope","color","undefined","Color","textureWidth","textureHeight","clipBias","flowDirection","Vector2","flowSpeed","reflectivity","scale","shader","WaterShader","encoding","LinearEncoding","textureLoader","TextureLoader","flowMap","normalMap0","load","normalMap1","cycle","halfCycle","textureMatrix","Matrix4","clock","Clock","reflector","refractor","matrixAutoUpdate","material","ShaderMaterial","uniforms","UniformsUtils","merge","UniformsLib","vertexShader","fragmentShader","transparent","fog","defines","USE_FLOWMAP","value","wrapS","wrapT","RepeatWrapping","getRenderTarget","texture","x","y","z","w","onBeforeRender","renderer","scene","camera","delta","config","set","multiply","projectionMatrix","matrixWorldInverse","matrixWorld","updateTextureMatrix","getDelta","visible","copy","console","error","prototype","Object","create","constructor","tReflectionMap","tRefractionMap","tNormalMap0","tNormalMap1","Vector4","join","objects","Water2"],"mappings":"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","file":"../../objects/Water2.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\",\r\n    '../objects/Reflector',\r\n    '../objects/Refractor'\r\n], function (\r\n    THREE, \r\n    threex,\r\n    Reflector, \r\n    Refractor\r\n) {\r\n    'use strict';\r\n    var Water = function (geometry, options) {\r\n        THREE.Mesh.call(this, geometry);\r\n        this.type = 'Water';\r\n        var scope = this;\r\n        options = options || {};\r\n        var color = options.color !== undefined ? new THREE.Color(options.color) : new THREE.Color(16777215);\r\n        var textureWidth = options.textureWidth || 512;\r\n        var textureHeight = options.textureHeight || 512;\r\n        var clipBias = options.clipBias || 0;\r\n        var flowDirection = options.flowDirection || new THREE.Vector2(1, 0);\r\n        var flowSpeed = options.flowSpeed || 0.03;\r\n        var reflectivity = options.reflectivity || 0.02;\r\n        var scale = options.scale || 1;\r\n        var shader = options.shader || Water.WaterShader;\r\n        var encoding = options.encoding !== undefined ? options.encoding : THREE.LinearEncoding;\r\n        var textureLoader = new THREE.TextureLoader();\r\n        var flowMap = options.flowMap || undefined;\r\n        var normalMap0 = options.normalMap0 || textureLoader.load('textures/water/Water_1_M_Normal.jpg');\r\n        var normalMap1 = options.normalMap1 || textureLoader.load('textures/water/Water_2_M_Normal.jpg');\r\n        var cycle = 0.15;\r\n        var halfCycle = cycle * 0.5;\r\n        var textureMatrix = new THREE.Matrix4();\r\n        var clock = new THREE.Clock();\r\n        if (Reflector === undefined) {\r\n            console.error('THREE.Water: Required component Reflector not found.');\r\n            return;\r\n        }\r\n        if (Refractor === undefined) {\r\n            console.error('THREE.Water: Required component Refractor not found.');\r\n            return;\r\n        }\r\n        var reflector = new Reflector(geometry, {\r\n            textureWidth: textureWidth,\r\n            textureHeight: textureHeight,\r\n            clipBias: clipBias,\r\n            encoding: encoding\r\n        });\r\n        var refractor = new Refractor(geometry, {\r\n            textureWidth: textureWidth,\r\n            textureHeight: textureHeight,\r\n            clipBias: clipBias,\r\n            encoding: encoding\r\n        });\r\n        reflector.matrixAutoUpdate = false;\r\n        refractor.matrixAutoUpdate = false;\r\n        this.material = new THREE.ShaderMaterial({\r\n            uniforms: THREE.UniformsUtils.merge([\r\n                THREE.UniformsLib['fog'],\r\n                shader.uniforms\r\n            ]),\r\n            vertexShader: shader.vertexShader,\r\n            fragmentShader: shader.fragmentShader,\r\n            transparent: true,\r\n            fog: true\r\n        });\r\n        if (flowMap !== undefined) {\r\n            this.material.defines.USE_FLOWMAP = '';\r\n            this.material.uniforms['tFlowMap'] = {\r\n                type: 't',\r\n                value: flowMap\r\n            };\r\n        } else {\r\n            this.material.uniforms['flowDirection'] = {\r\n                type: 'v2',\r\n                value: flowDirection\r\n            };\r\n        }\r\n        normalMap0.wrapS = normalMap0.wrapT = THREE.RepeatWrapping;\r\n        normalMap1.wrapS = normalMap1.wrapT = THREE.RepeatWrapping;\r\n        this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture;\r\n        this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture;\r\n        this.material.uniforms['tNormalMap0'].value = normalMap0;\r\n        this.material.uniforms['tNormalMap1'].value = normalMap1;\r\n        this.material.uniforms['color'].value = color;\r\n        this.material.uniforms['reflectivity'].value = reflectivity;\r\n        this.material.uniforms['textureMatrix'].value = textureMatrix;\r\n        this.material.uniforms['config'].value.x = 0;\r\n        this.material.uniforms['config'].value.y = halfCycle;\r\n        this.material.uniforms['config'].value.z = halfCycle;\r\n        this.material.uniforms['config'].value.w = scale;\r\n        function updateTextureMatrix(camera) {\r\n            textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\r\n            textureMatrix.multiply(camera.projectionMatrix);\r\n            textureMatrix.multiply(camera.matrixWorldInverse);\r\n            textureMatrix.multiply(scope.matrixWorld);\r\n        }\r\n        function updateFlow() {\r\n            var delta = clock.getDelta();\r\n            var config = scope.material.uniforms['config'];\r\n            config.value.x += flowSpeed * delta;\r\n            config.value.y = config.value.x + halfCycle;\r\n            if (config.value.x >= cycle) {\r\n                config.value.x = 0;\r\n                config.value.y = halfCycle;\r\n            } else if (config.value.y >= cycle) {\r\n                config.value.y = config.value.y - cycle;\r\n            }\r\n        }\r\n        this.onBeforeRender = function (renderer, scene, camera) {\r\n            updateTextureMatrix(camera);\r\n            updateFlow();\r\n            scope.visible = false;\r\n            reflector.matrixWorld.copy(scope.matrixWorld);\r\n            refractor.matrixWorld.copy(scope.matrixWorld);\r\n            reflector.onBeforeRender(renderer, scene, camera);\r\n            refractor.onBeforeRender(renderer, scene, camera);\r\n            scope.visible = true;\r\n        };\r\n    };\r\n    Water.prototype = Object.create(THREE.Mesh.prototype);\r\n    Water.prototype.constructor = Water;\r\n    Water.WaterShader = {\r\n        uniforms: {\r\n            'color': {\r\n                type: 'c',\r\n                value: null\r\n            },\r\n            'reflectivity': {\r\n                type: 'f',\r\n                value: 0\r\n            },\r\n            'tReflectionMap': {\r\n                type: 't',\r\n                value: null\r\n            },\r\n            'tRefractionMap': {\r\n                type: 't',\r\n                value: null\r\n            },\r\n            'tNormalMap0': {\r\n                type: 't',\r\n                value: null\r\n            },\r\n            'tNormalMap1': {\r\n                type: 't',\r\n                value: null\r\n            },\r\n            'textureMatrix': {\r\n                type: 'm4',\r\n                value: null\r\n            },\r\n            'config': {\r\n                type: 'v4',\r\n                value: new THREE.Vector4()\r\n            }\r\n        },\r\n        vertexShader: [\r\n            '#include <common>',\r\n            '#include <fog_pars_vertex>',\r\n            '#include <logdepthbuf_pars_vertex>',\r\n            'uniform mat4 textureMatrix;',\r\n            'varying vec4 vCoord;',\r\n            'varying vec2 vUv;',\r\n            'varying vec3 vToEye;',\r\n            'void main() {',\r\n            '\\tvUv = uv;',\r\n            '\\tvCoord = textureMatrix * vec4( position, 1.0 );',\r\n            '\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\r\n            '\\tvToEye = cameraPosition - worldPosition.xyz;',\r\n            '\\tvec4 mvPosition =  viewMatrix * worldPosition;',\r\n            '\\tgl_Position = projectionMatrix * mvPosition;',\r\n            '\\t#include <logdepthbuf_vertex>',\r\n            '\\t#include <fog_vertex>',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            '#include <common>',\r\n            '#include <fog_pars_fragment>',\r\n            '#include <logdepthbuf_pars_fragment>',\r\n            'uniform sampler2D tReflectionMap;',\r\n            'uniform sampler2D tRefractionMap;',\r\n            'uniform sampler2D tNormalMap0;',\r\n            'uniform sampler2D tNormalMap1;',\r\n            '#ifdef USE_FLOWMAP',\r\n            '\\tuniform sampler2D tFlowMap;',\r\n            '#else',\r\n            '\\tuniform vec2 flowDirection;',\r\n            '#endif',\r\n            'uniform vec3 color;',\r\n            'uniform float reflectivity;',\r\n            'uniform vec4 config;',\r\n            'varying vec4 vCoord;',\r\n            'varying vec2 vUv;',\r\n            'varying vec3 vToEye;',\r\n            'void main() {',\r\n            '\\t#include <logdepthbuf_fragment>',\r\n            '\\tfloat flowMapOffset0 = config.x;',\r\n            '\\tfloat flowMapOffset1 = config.y;',\r\n            '\\tfloat halfCycle = config.z;',\r\n            '\\tfloat scale = config.w;',\r\n            '\\tvec3 toEye = normalize( vToEye );',\r\n            '\\tvec2 flow;',\r\n            '\\t#ifdef USE_FLOWMAP',\r\n            '\\t\\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;',\r\n            '\\t#else',\r\n            '\\t\\tflow = flowDirection;',\r\n            '\\t#endif',\r\n            '\\tflow.x *= - 1.0;',\r\n            '\\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );',\r\n            '\\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );',\r\n            '\\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;',\r\n            '\\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );',\r\n            '\\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );',\r\n            '\\tfloat theta = max( dot( toEye, normal ), 0.0 );',\r\n            '\\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );',\r\n            '\\tvec3 coord = vCoord.xyz / vCoord.w;',\r\n            '\\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;',\r\n            '\\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );',\r\n            '\\tvec4 refractColor = texture2D( tRefractionMap, uv );',\r\n            '\\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );',\r\n            '\\t#include <tonemapping_fragment>',\r\n            '\\t#include <encodings_fragment>',\r\n            '\\t#include <fog_fragment>',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    return threex.objects.Water2 = Water;\r\n});"]}