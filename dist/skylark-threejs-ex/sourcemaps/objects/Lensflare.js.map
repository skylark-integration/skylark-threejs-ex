{"version":3,"sources":["objects/Lensflare.js"],"names":["define","THREE","geometry","float32Array","interleavedBuffer","Lensflare","Mesh","call","this","Geometry","MeshBasicMaterial","opacity","transparent","type","frustumCulled","renderOrder","Infinity","positionScreen","Vector3","positionView","tempMap","DataTexture","Uint8Array","RGBFormat","minFilter","NearestFilter","magFilter","wrapS","ClampToEdgeWrapping","wrapT","occlusionMap","material1a","RawShaderMaterial","uniforms","scale","value","screenPosition","vertexShader","join","fragmentShader","depthTest","depthWrite","material1b","map","mesh1","elements","shader","LensflareElement","Shader","material2","color","Color","Vector2","blending","AdditiveBlending","mesh2","addElement","element","push","screenPositionPixels","validArea","Box2","viewport","Vector4","onBeforeRender","renderer","scene","camera","getCurrentViewport","invAspect","w","z","halfViewportWidth","halfViewportHeight","size","set","min","x","y","max","setFromMatrixPosition","matrixWorld","applyMatrix4","matrixWorldInverse","copy","projectionMatrix","containsPoint","copyFramebufferToTexture","renderBufferDirect","vecX","vecY","i","l","length","texture","distance","uniformsNeedUpdate","dispose","prototype","Object","create","constructor","isLensflare","BufferGeometry","Float32Array","InterleavedBuffer","setIndex","setAttribute","InterleavedBufferAttribute"],"mappings":"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","file":"../../objects/Lensflare.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tTHREE.Lensflare = function () {\n\n\t\tTHREE.Mesh.call( this, THREE.Lensflare.Geometry, new THREE.MeshBasicMaterial( { opacity: 0, transparent: true } ) );\n\n\t\tthis.type = 'Lensflare';\n\t\tthis.frustumCulled = false;\n\t\tthis.renderOrder = Infinity;\n\n\t\t//\n\n\t\tvar positionScreen = new THREE.Vector3();\n\t\tvar positionView = new THREE.Vector3();\n\n\t\t// textures\n\n\t\tvar tempMap = new THREE.DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, THREE.RGBFormat );\n\t\ttempMap.minFilter = THREE.NearestFilter;\n\t\ttempMap.magFilter = THREE.NearestFilter;\n\t\ttempMap.wrapS = THREE.ClampToEdgeWrapping;\n\t\ttempMap.wrapT = THREE.ClampToEdgeWrapping;\n\n\t\tvar occlusionMap = new THREE.DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, THREE.RGBFormat );\n\t\tocclusionMap.minFilter = THREE.NearestFilter;\n\t\tocclusionMap.magFilter = THREE.NearestFilter;\n\t\tocclusionMap.wrapS = THREE.ClampToEdgeWrapping;\n\t\tocclusionMap.wrapT = THREE.ClampToEdgeWrapping;\n\n\t\t// material\n\n\t\tvar geometry = THREE.Lensflare.Geometry;\n\n\t\tvar material1a = new THREE.RawShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\t'scale': { value: null },\n\t\t\t\t'screenPosition': { value: null }\n\t\t\t},\n\t\t\tvertexShader: [\n\n\t\t\t\t'precision highp float;',\n\n\t\t\t\t'uniform vec3 screenPosition;',\n\t\t\t\t'uniform vec2 scale;',\n\n\t\t\t\t'attribute vec3 position;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ),\n\t\t\tfragmentShader: [\n\n\t\t\t\t'precision highp float;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ),\n\t\t\tdepthTest: true,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: false\n\t\t} );\n\n\t\tvar material1b = new THREE.RawShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\t'map': { value: tempMap },\n\t\t\t\t'scale': { value: null },\n\t\t\t\t'screenPosition': { value: null }\n\t\t\t},\n\t\t\tvertexShader: [\n\n\t\t\t\t'precision highp float;',\n\n\t\t\t\t'uniform vec3 screenPosition;',\n\t\t\t\t'uniform vec2 scale;',\n\n\t\t\t\t'attribute vec3 position;',\n\t\t\t\t'attribute vec2 uv;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tvUV = uv;',\n\n\t\t\t\t'\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ),\n\t\t\tfragmentShader: [\n\n\t\t\t\t'precision highp float;',\n\n\t\t\t\t'uniform sampler2D map;',\n\n\t\t\t\t'varying vec2 vUV;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tgl_FragColor = texture2D( map, vUV );',\n\n\t\t\t\t'}'\n\n\t\t\t].join( '\\n' ),\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: false\n\t\t} );\n\n\t\t// the following object is used for occlusionMap generation\n\n\t\tvar mesh1 = new THREE.Mesh( geometry, material1a );\n\n\t\t//\n\n\t\tvar elements = [];\n\n\t\tvar shader = THREE.LensflareElement.Shader;\n\n\t\tvar material2 = new THREE.RawShaderMaterial( {\n\t\t\tuniforms: {\n\t\t\t\t'map': { value: null },\n\t\t\t\t'occlusionMap': { value: occlusionMap },\n\t\t\t\t'color': { value: new THREE.Color( 0xffffff ) },\n\t\t\t\t'scale': { value: new THREE.Vector2() },\n\t\t\t\t'screenPosition': { value: new THREE.Vector3() }\n\t\t\t},\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tblending: THREE.AdditiveBlending,\n\t\t\ttransparent: true,\n\t\t\tdepthWrite: false\n\t\t} );\n\n\t\tvar mesh2 = new THREE.Mesh( geometry, material2 );\n\n\t\tthis.addElement = function ( element ) {\n\n\t\t\telements.push( element );\n\n\t\t};\n\n\t\t//\n\n\t\tvar scale = new THREE.Vector2();\n\t\tvar screenPositionPixels = new THREE.Vector2();\n\t\tvar validArea = new THREE.Box2();\n\t\tvar viewport = new THREE.Vector4();\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\trenderer.getCurrentViewport( viewport );\n\n\t\t\tvar invAspect = viewport.w / viewport.z;\n\t\t\tvar halfViewportWidth = viewport.z / 2.0;\n\t\t\tvar halfViewportHeight = viewport.w / 2.0;\n\n\t\t\tvar size = 16 / viewport.w;\n\t\t\tscale.set( size * invAspect, size );\n\n\t\t\tvalidArea.min.set( viewport.x, viewport.y );\n\t\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\n\n\t\t\t// calculate position in screen space\n\n\t\t\tpositionView.setFromMatrixPosition( this.matrixWorld );\n\t\t\tpositionView.applyMatrix4( camera.matrixWorldInverse );\n\n\t\t\tif ( positionView.z > 0 ) return; // lensflare is behind the camera\n\n\t\t\tpositionScreen.copy( positionView ).applyMatrix4( camera.projectionMatrix );\n\n\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\t\tscreenPositionPixels.x = viewport.x + ( positionScreen.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\t\tscreenPositionPixels.y = viewport.y + ( positionScreen.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t\t// screen cull\n\n\t\t\tif ( validArea.containsPoint( screenPositionPixels ) ) {\n\n\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\trenderer.copyFramebufferToTexture( screenPositionPixels, tempMap );\n\n\t\t\t\t// render pink quad\n\n\t\t\t\tvar uniforms = material1a.uniforms;\n\t\t\t\tuniforms[ \"scale\" ].value = scale;\n\t\t\t\tuniforms[ \"screenPosition\" ].value = positionScreen;\n\n\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1a, mesh1, null );\n\n\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\trenderer.copyFramebufferToTexture( screenPositionPixels, occlusionMap );\n\n\t\t\t\t// restore graphics\n\n\t\t\t\tvar uniforms = material1b.uniforms;\n\t\t\t\tuniforms[ \"scale\" ].value = scale;\n\t\t\t\tuniforms[ \"screenPosition\" ].value = positionScreen;\n\n\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1b, mesh1, null );\n\n\t\t\t\t// render elements\n\n\t\t\t\tvar vecX = - positionScreen.x * 2;\n\t\t\t\tvar vecY = - positionScreen.y * 2;\n\n\t\t\t\tfor ( var i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar element = elements[ i ];\n\n\t\t\t\t\tvar uniforms = material2.uniforms;\n\n\t\t\t\t\tuniforms[ \"color\" ].value.copy( element.color );\n\t\t\t\t\tuniforms[ \"map\" ].value = element.texture;\n\t\t\t\t\tuniforms[ \"screenPosition\" ].value.x = positionScreen.x + vecX * element.distance;\n\t\t\t\t\tuniforms[ \"screenPosition\" ].value.y = positionScreen.y + vecY * element.distance;\n\n\t\t\t\t\tvar size = element.size / viewport.w;\n\t\t\t\t\tvar invAspect = viewport.w / viewport.z;\n\n\t\t\t\t\tuniforms[ \"scale\" ].value.set( size * invAspect, size );\n\n\t\t\t\t\tmaterial2.uniformsNeedUpdate = true;\n\n\t\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material2, mesh2, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.dispose = function () {\n\n\t\t\tmaterial1a.dispose();\n\t\t\tmaterial1b.dispose();\n\t\t\tmaterial2.dispose();\n\n\t\t\ttempMap.dispose();\n\t\t\tocclusionMap.dispose();\n\n\t\t\tfor ( var i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\t\telements[ i ].texture.dispose();\n\n\t\t\t}\n\n\t\t};\n\n\t};\n\n\tTHREE.Lensflare.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.Lensflare.prototype.constructor = THREE.Lensflare;\n\tTHREE.Lensflare.prototype.isLensflare = true;\n\n\t//\n\n\tTHREE.LensflareElement = function ( texture, size, distance, color ) {\n\n\t\tthis.texture = texture;\n\t\tthis.size = size || 1;\n\t\tthis.distance = distance || 0;\n\t\tthis.color = color || new THREE.Color( 0xffffff );\n\n\t};\n\n\tTHREE.LensflareElement.Shader = {\n\n\t\tuniforms: {\n\n\t\t\t'map': { value: null },\n\t\t\t'occlusionMap': { value: null },\n\t\t\t'color': { value: null },\n\t\t\t'scale': { value: null },\n\t\t\t'screenPosition': { value: null }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t'precision highp float;',\n\n\t\t\t'uniform vec3 screenPosition;',\n\t\t\t'uniform vec2 scale;',\n\n\t\t\t'uniform sampler2D occlusionMap;',\n\n\t\t\t'attribute vec3 position;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'varying vec2 vUV;',\n\t\t\t'varying float vVisibility;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvUV = uv;',\n\n\t\t\t'\tvec2 pos = position.xy;',\n\n\t\t\t'\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',\n\t\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',\n\n\t\t\t'\tvVisibility =        visibility.r / 9.0;',\n\t\t\t'\tvVisibility *= 1.0 - visibility.g / 9.0;',\n\t\t\t'\tvVisibility *=       visibility.b / 9.0;',\n\n\t\t\t'\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\n\t\t\t'precision highp float;',\n\n\t\t\t'uniform sampler2D map;',\n\t\t\t'uniform vec3 color;',\n\n\t\t\t'varying vec2 vUV;',\n\t\t\t'varying float vVisibility;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvec4 texture = texture2D( map, vUV );',\n\t\t\t'\ttexture.a *= vVisibility;',\n\t\t\t'\tgl_FragColor = texture;',\n\t\t\t'\tgl_FragColor.rgb *= color;',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' )\n\n\t};\n\n\tTHREE.Lensflare.Geometry = ( function () {\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\tvar float32Array = new Float32Array( [\n\t\t\t- 1, - 1, 0, 0, 0,\n\t\t\t1, - 1, 0, 1, 0,\n\t\t\t1, 1, 0, 1, 1,\n\t\t\t- 1, 1, 0, 0, 1\n\t\t] );\n\n\t\tvar interleavedBuffer = new THREE.InterleavedBuffer( float32Array, 5 );\n\n\t\tgeometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\t\tgeometry.setAttribute( 'position', new THREE.InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\t\tgeometry.setAttribute( 'uv', new THREE.InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\t\treturn geometry;\n\n\t} )();\n\t\n\treturn THREE.Lensflare;\n});\n"]}