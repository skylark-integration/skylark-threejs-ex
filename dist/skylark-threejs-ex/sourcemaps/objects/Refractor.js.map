{"version":3,"sources":["objects/Refractor.js"],"names":["define","THREE","threex","Refractor","geometry","options","Mesh","call","this","type","scope","color","undefined","Color","textureWidth","textureHeight","clipBias","shader","RefractorShader","encoding","LinearEncoding","virtualCamera","PerspectiveCamera","matrixAutoUpdate","userData","refractor","refractorPlane","Plane","textureMatrix","Matrix4","parameters","minFilter","LinearFilter","magFilter","format","RGBFormat","stencilBuffer","renderTarget","WebGLRenderTarget","MathUtils","isPowerOfTwo","texture","generateMipmaps","material","ShaderMaterial","uniforms","UniformsUtils","clone","vertexShader","fragmentShader","transparent","value","refractorWorldPosition","cameraWorldPosition","rotationMatrix","view","normal","clipPlane","clipVector","q","visible","Vector3","camera","setFromMatrixPosition","matrixWorld","subVectors","extractRotation","set","applyMatrix4","dot","updateRefractorPlane","position","quaternion","Quaternion","scale","decompose","applyQuaternion","normalize","negate","setFromNormalAndCoplanarPoint","updateVirtualCamera","Vector4","copy","matrixWorldInverse","getInverse","projectionMatrix","far","x","y","z","constant","Math","sign","elements","w","multiplyScalar","onBeforeRender","renderer","scene","multiply","updateTextureMatrix","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","autoClear","clear","render","viewport","state","prototype","Object","create","constructor","tDiffuse","join","objects"],"mappings":"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","file":"../../objects/Refractor.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var Refractor = function (geometry, options) {\r\n        THREE.Mesh.call(this, geometry);\r\n        this.type = 'Refractor';\r\n        var scope = this;\r\n        options = options || {};\r\n        var color = options.color !== undefined ? new THREE.Color(options.color) : new THREE.Color(8355711);\r\n        var textureWidth = options.textureWidth || 512;\r\n        var textureHeight = options.textureHeight || 512;\r\n        var clipBias = options.clipBias || 0;\r\n        var shader = options.shader || Refractor.RefractorShader;\r\n        var encoding = options.encoding !== undefined ? options.encoding : THREE.LinearEncoding;\r\n        var virtualCamera = new THREE.PerspectiveCamera();\r\n        virtualCamera.matrixAutoUpdate = false;\r\n        virtualCamera.userData.refractor = true;\r\n        var refractorPlane = new THREE.Plane();\r\n        var textureMatrix = new THREE.Matrix4();\r\n        var parameters = {\r\n            minFilter: THREE.LinearFilter,\r\n            magFilter: THREE.LinearFilter,\r\n            format: THREE.RGBFormat,\r\n            stencilBuffer: false,\r\n            encoding: encoding\r\n        };\r\n        var renderTarget = new THREE.WebGLRenderTarget(textureWidth, textureHeight, parameters);\r\n        if (!THREE.MathUtils.isPowerOfTwo(textureWidth) || !THREE.MathUtils.isPowerOfTwo(textureHeight)) {\r\n            renderTarget.texture.generateMipmaps = false;\r\n        }\r\n        this.material = new THREE.ShaderMaterial({\r\n            uniforms: THREE.UniformsUtils.clone(shader.uniforms),\r\n            vertexShader: shader.vertexShader,\r\n            fragmentShader: shader.fragmentShader,\r\n            transparent: true\r\n        });\r\n        this.material.uniforms['color'].value = color;\r\n        this.material.uniforms['tDiffuse'].value = renderTarget.texture;\r\n        this.material.uniforms['textureMatrix'].value = textureMatrix;\r\n        var visible = function () {\r\n            var refractorWorldPosition = new THREE.Vector3();\r\n            var cameraWorldPosition = new THREE.Vector3();\r\n            var rotationMatrix = new THREE.Matrix4();\r\n            var view = new THREE.Vector3();\r\n            var normal = new THREE.Vector3();\r\n            return function visible(camera) {\r\n                refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\r\n                cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\r\n                view.subVectors(refractorWorldPosition, cameraWorldPosition);\r\n                rotationMatrix.extractRotation(scope.matrixWorld);\r\n                normal.set(0, 0, 1);\r\n                normal.applyMatrix4(rotationMatrix);\r\n                return view.dot(normal) < 0;\r\n            };\r\n        }();\r\n        var updateRefractorPlane = function () {\r\n            var normal = new THREE.Vector3();\r\n            var position = new THREE.Vector3();\r\n            var quaternion = new THREE.Quaternion();\r\n            var scale = new THREE.Vector3();\r\n            return function updateRefractorPlane() {\r\n                scope.matrixWorld.decompose(position, quaternion, scale);\r\n                normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();\r\n                normal.negate();\r\n                refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\r\n            };\r\n        }();\r\n        var updateVirtualCamera = function () {\r\n            var clipPlane = new THREE.Plane();\r\n            var clipVector = new THREE.Vector4();\r\n            var q = new THREE.Vector4();\r\n            return function updateVirtualCamera(camera) {\r\n                virtualCamera.matrixWorld.copy(camera.matrixWorld);\r\n                virtualCamera.matrixWorldInverse.getInverse(virtualCamera.matrixWorld);\r\n                virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\r\n                virtualCamera.far = camera.far;\r\n                clipPlane.copy(refractorPlane);\r\n                clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\r\n                clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\r\n                var projectionMatrix = virtualCamera.projectionMatrix;\r\n                q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\r\n                q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\r\n                q.z = -1;\r\n                q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\r\n                clipVector.multiplyScalar(2 / clipVector.dot(q));\r\n                projectionMatrix.elements[2] = clipVector.x;\r\n                projectionMatrix.elements[6] = clipVector.y;\r\n                projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;\r\n                projectionMatrix.elements[14] = clipVector.w;\r\n            };\r\n        }();\r\n        function updateTextureMatrix(camera) {\r\n            textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\r\n            textureMatrix.multiply(camera.projectionMatrix);\r\n            textureMatrix.multiply(camera.matrixWorldInverse);\r\n            textureMatrix.multiply(scope.matrixWorld);\r\n        }\r\n        function render(renderer, scene, camera) {\r\n            scope.visible = false;\r\n            var currentRenderTarget = renderer.getRenderTarget();\r\n            var currentXrEnabled = renderer.xr.enabled;\r\n            var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\r\n            renderer.xr.enabled = false;\r\n            renderer.shadowMap.autoUpdate = false;\r\n            renderer.setRenderTarget(renderTarget);\r\n            if (renderer.autoClear === false)\r\n                renderer.clear();\r\n            renderer.render(scene, virtualCamera);\r\n            renderer.xr.enabled = currentXrEnabled;\r\n            renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\r\n            renderer.setRenderTarget(currentRenderTarget);\r\n            var viewport = camera.viewport;\r\n            if (viewport !== undefined) {\r\n                renderer.state.viewport(viewport);\r\n            }\r\n            scope.visible = true;\r\n        }\r\n        this.onBeforeRender = function (renderer, scene, camera) {\r\n            if (camera.userData.refractor === true)\r\n                return;\r\n            if (!visible(camera) === true)\r\n                return;\r\n            updateRefractorPlane();\r\n            updateTextureMatrix(camera);\r\n            updateVirtualCamera(camera);\r\n            render(renderer, scene, camera);\r\n        };\r\n        this.getRenderTarget = function () {\r\n            return renderTarget;\r\n        };\r\n    };\r\n    Refractor.prototype = Object.create(THREE.Mesh.prototype);\r\n    Refractor.prototype.constructor = Refractor;\r\n    Refractor.RefractorShader = {\r\n        uniforms: {\r\n            'color': { value: null },\r\n            'tDiffuse': { value: null },\r\n            'textureMatrix': { value: null }\r\n        },\r\n        vertexShader: [\r\n            'uniform mat4 textureMatrix;',\r\n            'varying vec4 vUv;',\r\n            'void main() {',\r\n            '\\tvUv = textureMatrix * vec4( position, 1.0 );',\r\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            'uniform vec3 color;',\r\n            'uniform sampler2D tDiffuse;',\r\n            'varying vec4 vUv;',\r\n            'float blendOverlay( float base, float blend ) {',\r\n            '\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\r\n            '}',\r\n            'vec3 blendOverlay( vec3 base, vec3 blend ) {',\r\n            '\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\r\n            '}',\r\n            'void main() {',\r\n            '\\tvec4 base = texture2DProj( tDiffuse, vUv );',\r\n            '\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n    return threex.objects.Refractor = Refractor;\r\n});"]}