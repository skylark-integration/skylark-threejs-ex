{"version":3,"sources":["objects/Refractor.js"],"names":["define","THREE","threex","Refractor","geometry","options","Mesh","call","this","type","scope","color","undefined","Color","textureWidth","textureHeight","clipBias","shader","RefractorShader","encoding","LinearEncoding","virtualCamera","PerspectiveCamera","matrixAutoUpdate","userData","refractor","refractorPlane","Plane","textureMatrix","Matrix4","parameters","minFilter","LinearFilter","magFilter","format","RGBFormat","stencilBuffer","renderTarget","WebGLRenderTarget","MathUtils","isPowerOfTwo","texture","generateMipmaps","material","ShaderMaterial","uniforms","UniformsUtils","clone","vertexShader","fragmentShader","transparent","value","refractorWorldPosition","cameraWorldPosition","rotationMatrix","view","normal","clipPlane","clipVector","q","visible","Vector3","camera","setFromMatrixPosition","matrixWorld","subVectors","extractRotation","set","applyMatrix4","dot","updateRefractorPlane","position","quaternion","Quaternion","scale","decompose","applyQuaternion","normalize","negate","setFromNormalAndCoplanarPoint","updateVirtualCamera","Vector4","copy","matrixWorldInverse","getInverse","projectionMatrix","far","x","y","z","constant","Math","sign","elements","w","multiplyScalar","onBeforeRender","renderer","scene","multiply","updateTextureMatrix","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","autoClear","clear","render","viewport","state","prototype","Object","create","constructor","tDiffuse","join","objects"],"mappings":"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","file":"../../objects/Refractor.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    var Refractor = function (geometry, options) {\n        THREE.Mesh.call(this, geometry);\n        this.type = 'Refractor';\n        var scope = this;\n        options = options || {};\n        var color = options.color !== undefined ? new THREE.Color(options.color) : new THREE.Color(8355711);\n        var textureWidth = options.textureWidth || 512;\n        var textureHeight = options.textureHeight || 512;\n        var clipBias = options.clipBias || 0;\n        var shader = options.shader || Refractor.RefractorShader;\n        var encoding = options.encoding !== undefined ? options.encoding : THREE.LinearEncoding;\n        var virtualCamera = new THREE.PerspectiveCamera();\n        virtualCamera.matrixAutoUpdate = false;\n        virtualCamera.userData.refractor = true;\n        var refractorPlane = new THREE.Plane();\n        var textureMatrix = new THREE.Matrix4();\n        var parameters = {\n            minFilter: THREE.LinearFilter,\n            magFilter: THREE.LinearFilter,\n            format: THREE.RGBFormat,\n            stencilBuffer: false,\n            encoding: encoding\n        };\n        var renderTarget = new THREE.WebGLRenderTarget(textureWidth, textureHeight, parameters);\n        if (!THREE.MathUtils.isPowerOfTwo(textureWidth) || !THREE.MathUtils.isPowerOfTwo(textureHeight)) {\n            renderTarget.texture.generateMipmaps = false;\n        }\n        this.material = new THREE.ShaderMaterial({\n            uniforms: THREE.UniformsUtils.clone(shader.uniforms),\n            vertexShader: shader.vertexShader,\n            fragmentShader: shader.fragmentShader,\n            transparent: true\n        });\n        this.material.uniforms['color'].value = color;\n        this.material.uniforms['tDiffuse'].value = renderTarget.texture;\n        this.material.uniforms['textureMatrix'].value = textureMatrix;\n        var visible = function () {\n            var refractorWorldPosition = new THREE.Vector3();\n            var cameraWorldPosition = new THREE.Vector3();\n            var rotationMatrix = new THREE.Matrix4();\n            var view = new THREE.Vector3();\n            var normal = new THREE.Vector3();\n            return function visible(camera) {\n                refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n                cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n                view.subVectors(refractorWorldPosition, cameraWorldPosition);\n                rotationMatrix.extractRotation(scope.matrixWorld);\n                normal.set(0, 0, 1);\n                normal.applyMatrix4(rotationMatrix);\n                return view.dot(normal) < 0;\n            };\n        }();\n        var updateRefractorPlane = function () {\n            var normal = new THREE.Vector3();\n            var position = new THREE.Vector3();\n            var quaternion = new THREE.Quaternion();\n            var scale = new THREE.Vector3();\n            return function updateRefractorPlane() {\n                scope.matrixWorld.decompose(position, quaternion, scale);\n                normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();\n                normal.negate();\n                refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n            };\n        }();\n        var updateVirtualCamera = function () {\n            var clipPlane = new THREE.Plane();\n            var clipVector = new THREE.Vector4();\n            var q = new THREE.Vector4();\n            return function updateVirtualCamera(camera) {\n                virtualCamera.matrixWorld.copy(camera.matrixWorld);\n                virtualCamera.matrixWorldInverse.getInverse(virtualCamera.matrixWorld);\n                virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n                virtualCamera.far = camera.far;\n                clipPlane.copy(refractorPlane);\n                clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n                clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\n                var projectionMatrix = virtualCamera.projectionMatrix;\n                q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n                q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n                q.z = -1;\n                q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n                clipVector.multiplyScalar(2 / clipVector.dot(q));\n                projectionMatrix.elements[2] = clipVector.x;\n                projectionMatrix.elements[6] = clipVector.y;\n                projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;\n                projectionMatrix.elements[14] = clipVector.w;\n            };\n        }();\n        function updateTextureMatrix(camera) {\n            textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n            textureMatrix.multiply(camera.projectionMatrix);\n            textureMatrix.multiply(camera.matrixWorldInverse);\n            textureMatrix.multiply(scope.matrixWorld);\n        }\n        function render(renderer, scene, camera) {\n            scope.visible = false;\n            var currentRenderTarget = renderer.getRenderTarget();\n            var currentXrEnabled = renderer.xr.enabled;\n            var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n            renderer.xr.enabled = false;\n            renderer.shadowMap.autoUpdate = false;\n            renderer.setRenderTarget(renderTarget);\n            if (renderer.autoClear === false)\n                renderer.clear();\n            renderer.render(scene, virtualCamera);\n            renderer.xr.enabled = currentXrEnabled;\n            renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n            renderer.setRenderTarget(currentRenderTarget);\n            var viewport = camera.viewport;\n            if (viewport !== undefined) {\n                renderer.state.viewport(viewport);\n            }\n            scope.visible = true;\n        }\n        this.onBeforeRender = function (renderer, scene, camera) {\n            if (camera.userData.refractor === true)\n                return;\n            if (!visible(camera) === true)\n                return;\n            updateRefractorPlane();\n            updateTextureMatrix(camera);\n            updateVirtualCamera(camera);\n            render(renderer, scene, camera);\n        };\n        this.getRenderTarget = function () {\n            return renderTarget;\n        };\n    };\n    Refractor.prototype = Object.create(THREE.Mesh.prototype);\n    Refractor.prototype.constructor = Refractor;\n    Refractor.RefractorShader = {\n        uniforms: {\n            'color': { value: null },\n            'tDiffuse': { value: null },\n            'textureMatrix': { value: null }\n        },\n        vertexShader: [\n            'uniform mat4 textureMatrix;',\n            'varying vec4 vUv;',\n            'void main() {',\n            '\\tvUv = textureMatrix * vec4( position, 1.0 );',\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n            '}'\n        ].join('\\n'),\n        fragmentShader: [\n            'uniform vec3 color;',\n            'uniform sampler2D tDiffuse;',\n            'varying vec4 vUv;',\n            'float blendOverlay( float base, float blend ) {',\n            '\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\n            '}',\n            'vec3 blendOverlay( vec3 base, vec3 blend ) {',\n            '\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\n            '}',\n            'void main() {',\n            '\\tvec4 base = texture2DProj( tDiffuse, vUv );',\n            '\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\n            '}'\n        ].join('\\n')\n    };\n    return threex.objects.Refractor = Refractor;\n});"]}