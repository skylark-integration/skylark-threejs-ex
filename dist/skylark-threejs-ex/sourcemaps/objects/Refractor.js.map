{"version":3,"sources":["objects/Refractor.js"],"names":["define","THREE","Refractor","geometry","options","Mesh","call","this","type","scope","color","undefined","Color","textureWidth","textureHeight","clipBias","shader","RefractorShader","encoding","LinearEncoding","virtualCamera","PerspectiveCamera","matrixAutoUpdate","userData","refractor","refractorPlane","Plane","textureMatrix","Matrix4","parameters","minFilter","LinearFilter","magFilter","format","RGBFormat","stencilBuffer","renderTarget","WebGLRenderTarget","MathUtils","isPowerOfTwo","texture","generateMipmaps","material","ShaderMaterial","uniforms","UniformsUtils","clone","vertexShader","fragmentShader","transparent","value","refractorWorldPosition","cameraWorldPosition","rotationMatrix","view","normal","clipPlane","clipVector","q","visible","Vector3","camera","setFromMatrixPosition","matrixWorld","subVectors","extractRotation","set","applyMatrix4","dot","updateRefractorPlane","position","quaternion","Quaternion","scale","decompose","applyQuaternion","normalize","negate","setFromNormalAndCoplanarPoint","updateVirtualCamera","Vector4","copy","matrixWorldInverse","getInverse","projectionMatrix","far","x","y","z","constant","Math","sign","elements","w","multiplyScalar","onBeforeRender","renderer","scene","multiply","updateTextureMatrix","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","autoClear","clear","render","viewport","state","prototype","Object","create","constructor","tDiffuse","join"],"mappings":"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","file":"../../objects/Refractor.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t */\n\n\tTHREE.Refractor = function ( geometry, options ) {\n\n\t\tTHREE.Mesh.call( this, geometry );\n\n\t\tthis.type = 'Refractor';\n\n\t\tvar scope = this;\n\n\t\toptions = options || {};\n\n\t\tvar color = ( options.color !== undefined ) ? new THREE.Color( options.color ) : new THREE.Color( 0x7F7F7F );\n\t\tvar textureWidth = options.textureWidth || 512;\n\t\tvar textureHeight = options.textureHeight || 512;\n\t\tvar clipBias = options.clipBias || 0;\n\t\tvar shader = options.shader || THREE.Refractor.RefractorShader;\n\t\tvar encoding = options.encoding !== undefined ? options.encoding : THREE.LinearEncoding;\n\n\t\t//\n\n\t\tvar virtualCamera = new THREE.PerspectiveCamera();\n\t\tvirtualCamera.matrixAutoUpdate = false;\n\t\tvirtualCamera.userData.refractor = true;\n\n\t\t//\n\n\t\tvar refractorPlane = new THREE.Plane();\n\t\tvar textureMatrix = new THREE.Matrix4();\n\n\t\t// render target\n\n\t\tvar parameters = {\n\t\t\tminFilter: THREE.LinearFilter,\n\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\tformat: THREE.RGBFormat,\n\t\t\tstencilBuffer: false,\n\t\t\tencoding: encoding\n\t\t};\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\t\tif ( ! THREE.MathUtils.isPowerOfTwo( textureWidth ) || ! THREE.MathUtils.isPowerOfTwo( textureHeight ) ) {\n\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\t}\n\n\t\t// material\n\n\t\tthis.material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\ttransparent: true // ensures, refractors are drawn from farthest to closest\n\t\t} );\n\n\t\tthis.material.uniforms[ \"color\" ].value = color;\n\t\tthis.material.uniforms[ \"tDiffuse\" ].value = renderTarget.texture;\n\t\tthis.material.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\n\t\t// functions\n\n\t\tvar visible = ( function () {\n\n\t\t\tvar refractorWorldPosition = new THREE.Vector3();\n\t\t\tvar cameraWorldPosition = new THREE.Vector3();\n\t\t\tvar rotationMatrix = new THREE.Matrix4();\n\n\t\t\tvar view = new THREE.Vector3();\n\t\t\tvar normal = new THREE.Vector3();\n\n\t\t\treturn function visible( camera ) {\n\n\t\t\t\trefractorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\t\tview.subVectors( refractorWorldPosition, cameraWorldPosition );\n\n\t\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\t\tnormal.set( 0, 0, 1 );\n\t\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\t\treturn view.dot( normal ) < 0;\n\n\t\t\t};\n\n\t\t} )();\n\n\t\tvar updateRefractorPlane = ( function () {\n\n\t\t\tvar normal = new THREE.Vector3();\n\t\t\tvar position = new THREE.Vector3();\n\t\t\tvar quaternion = new THREE.Quaternion();\n\t\t\tvar scale = new THREE.Vector3();\n\n\t\t\treturn function updateRefractorPlane() {\n\n\t\t\t\tscope.matrixWorld.decompose( position, quaternion, scale );\n\t\t\t\tnormal.set( 0, 0, 1 ).applyQuaternion( quaternion ).normalize();\n\n\t\t\t\t// flip the normal because we want to cull everything above the plane\n\n\t\t\t\tnormal.negate();\n\n\t\t\t\trefractorPlane.setFromNormalAndCoplanarPoint( normal, position );\n\n\t\t\t};\n\n\t\t} )();\n\n\t\tvar updateVirtualCamera = ( function () {\n\n\t\t\tvar clipPlane = new THREE.Plane();\n\t\t\tvar clipVector = new THREE.Vector4();\n\t\t\tvar q = new THREE.Vector4();\n\n\t\t\treturn function updateVirtualCamera( camera ) {\n\n\t\t\t\tvirtualCamera.matrixWorld.copy( camera.matrixWorld );\n\t\t\t\tvirtualCamera.matrixWorldInverse.getInverse( virtualCamera.matrixWorld );\n\t\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\t\t\t\tvirtualCamera.far = camera.far; // used in WebGLBackground\n\n\t\t\t\t// The following code creates an oblique view frustum for clipping.\n\t\t\t\t// see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n\t\t\t\t// Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n\t\t\t\tclipPlane.copy( refractorPlane );\n\t\t\t\tclipPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\t\tclipVector.set( clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant );\n\n\t\t\t\t// calculate the clip-space corner point opposite the clipping plane and\n\t\t\t\t// transform it into camera space by multiplying it by the inverse of the projection matrix\n\n\t\t\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\t\tq.x = ( Math.sign( clipVector.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\t\tq.y = ( Math.sign( clipVector.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\t\tq.z = - 1.0;\n\t\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t\t// calculate the scaled plane vector\n\n\t\t\t\tclipVector.multiplyScalar( 2.0 / clipVector.dot( q ) );\n\n\t\t\t\t// replacing the third row of the projection matrix\n\n\t\t\t\tprojectionMatrix.elements[ 2 ] = clipVector.x;\n\t\t\t\tprojectionMatrix.elements[ 6 ] = clipVector.y;\n\t\t\t\tprojectionMatrix.elements[ 10 ] = clipVector.z + 1.0 - clipBias;\n\t\t\t\tprojectionMatrix.elements[ 14 ] = clipVector.w;\n\n\t\t\t};\n\n\t\t} )();\n\n\t\t// This will update the texture matrix that is used for projective texture mapping in the shader.\n\t\t// see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\t\tfunction updateTextureMatrix( camera ) {\n\n\t\t\t// this matrix does range mapping to [ 0, 1 ]\n\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\n\t\t\t// we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n\t\t\t// (matrix above) with the projection and view matrix of the virtual camera\n\t\t\t// and the model matrix of the refractor\n\n\t\t\ttextureMatrix.multiply( camera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t}\n\n\t\t//\n\n\t\tfunction render( renderer, scene, camera ) {\n\n\t\t\tscope.visible = false;\n\n\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\t\t\tvar currentXrEnabled = renderer.xr.enabled;\n\t\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// restore viewport\n\n\t\t\tvar viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t}\n\n\t\t//\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t// ensure refractors are rendered only once per frame\n\n\t\t\tif ( camera.userData.refractor === true ) return;\n\n\t\t\t// avoid rendering when the refractor is viewed from behind\n\n\t\t\tif ( ! visible( camera ) === true ) return;\n\n\t\t\t// update\n\n\t\t\tupdateRefractorPlane();\n\n\t\t\tupdateTextureMatrix( camera );\n\n\t\t\tupdateVirtualCamera( camera );\n\n\t\t\trender( renderer, scene, camera );\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t};\n\n\tTHREE.Refractor.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.Refractor.prototype.constructor = THREE.Refractor;\n\n\tTHREE.Refractor.RefractorShader = {\n\n\t\tuniforms: {\n\n\t\t\t'color': {\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'tDiffuse': {\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'textureMatrix': {\n\t\t\t\tvalue: null\n\t\t\t}\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t'uniform mat4 textureMatrix;',\n\n\t\t\t'varying vec4 vUv;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvUv = textureMatrix * vec4( position, 1.0 );',\n\n\t\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\n\t\t\t'uniform vec3 color;',\n\t\t\t'uniform sampler2D tDiffuse;',\n\n\t\t\t'varying vec4 vUv;',\n\n\t\t\t'float blendOverlay( float base, float blend ) {',\n\n\t\t\t'\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\n\n\t\t\t'}',\n\n\t\t\t'vec3 blendOverlay( vec3 base, vec3 blend ) {',\n\n\t\t\t'\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\n\n\t\t\t'}',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvec4 base = texture2DProj( tDiffuse, vUv );',\n\n\t\t\t'\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' )\n\t};\n\t\n\treturn THREE.Refractor;\n});\n"]}