{"version":3,"sources":["objects/Water.js"],"names":["define","THREE","Water","geometry","options","Mesh","call","this","scope","textureWidth","undefined","textureHeight","clipBias","alpha","time","normalSampler","waterNormals","sunDirection","Vector3","sunColor","Color","waterColor","eye","distortionScale","side","FrontSide","fog","mirrorPlane","Plane","normal","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","view","target","q","textureMatrix","mirrorCamera","PerspectiveCamera","parameters","minFilter","LinearFilter","magFilter","format","RGBFormat","stencilBuffer","renderTarget","WebGLRenderTarget","MathUtils","isPowerOfTwo","texture","generateMipmaps","mirrorShader","uniforms","UniformsUtils","merge","UniformsLib","value","mirrorSampler","size","vertexShader","join","fragmentShader","material","ShaderMaterial","clone","lights","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","visible","setRenderTarget","autoClear","clear","render","viewport","state","prototype","Object","create","constructor"],"mappings":"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","file":"../../objects/Water.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author jbouny / https://github.com/jbouny\n\t *\n\t * Work based on :\n\t * @author Slayvin / http://slayvin.net : Flat mirror for three.js\n\t * @author Stemkoski / http://www.adelphi.edu/~stemkoski : An implementation of water shader based on the flat mirror\n\t * @author Jonas Wagner / http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n\t */\n\n\tTHREE.Water = function ( geometry, options ) {\n\n\t\tTHREE.Mesh.call( this, geometry );\n\n\t\tvar scope = this;\n\n\t\toptions = options || {};\n\n\t\tvar textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\n\t\tvar textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\n\n\t\tvar clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n\t\tvar alpha = options.alpha !== undefined ? options.alpha : 1.0;\n\t\tvar time = options.time !== undefined ? options.time : 0.0;\n\t\tvar normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n\t\tvar sunDirection = options.sunDirection !== undefined ? options.sunDirection : new THREE.Vector3( 0.70707, 0.70707, 0.0 );\n\t\tvar sunColor = new THREE.Color( options.sunColor !== undefined ? options.sunColor : 0xffffff );\n\t\tvar waterColor = new THREE.Color( options.waterColor !== undefined ? options.waterColor : 0x7F7F7F );\n\t\tvar eye = options.eye !== undefined ? options.eye : new THREE.Vector3( 0, 0, 0 );\n\t\tvar distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n\t\tvar side = options.side !== undefined ? options.side : THREE.FrontSide;\n\t\tvar fog = options.fog !== undefined ? options.fog : false;\n\n\t\t//\n\n\t\tvar mirrorPlane = new THREE.Plane();\n\t\tvar normal = new THREE.Vector3();\n\t\tvar mirrorWorldPosition = new THREE.Vector3();\n\t\tvar cameraWorldPosition = new THREE.Vector3();\n\t\tvar rotationMatrix = new THREE.Matrix4();\n\t\tvar lookAtPosition = new THREE.Vector3( 0, 0, - 1 );\n\t\tvar clipPlane = new THREE.Vector4();\n\n\t\tvar view = new THREE.Vector3();\n\t\tvar target = new THREE.Vector3();\n\t\tvar q = new THREE.Vector4();\n\n\t\tvar textureMatrix = new THREE.Matrix4();\n\n\t\tvar mirrorCamera = new THREE.PerspectiveCamera();\n\n\t\tvar parameters = {\n\t\t\tminFilter: THREE.LinearFilter,\n\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\tformat: THREE.RGBFormat,\n\t\t\tstencilBuffer: false\n\t\t};\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\t\tif ( ! THREE.MathUtils.isPowerOfTwo( textureWidth ) || ! THREE.MathUtils.isPowerOfTwo( textureHeight ) ) {\n\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\t}\n\n\t\tvar mirrorShader = {\n\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\t\tTHREE.UniformsLib[ 'lights' ],\n\t\t\t\t{\n\t\t\t\t\t\"normalSampler\": { value: null },\n\t\t\t\t\t\"mirrorSampler\": { value: null },\n\t\t\t\t\t\"alpha\": { value: 1.0 },\n\t\t\t\t\t\"time\": { value: 0.0 },\n\t\t\t\t\t\"size\": { value: 1.0 },\n\t\t\t\t\t\"distortionScale\": { value: 20.0 },\n\t\t\t\t\t\"textureMatrix\": { value: new THREE.Matrix4() },\n\t\t\t\t\t\"sunColor\": { value: new THREE.Color( 0x7F7F7F ) },\n\t\t\t\t\t\"sunDirection\": { value: new THREE.Vector3( 0.70707, 0.70707, 0 ) },\n\t\t\t\t\t\"eye\": { value: new THREE.Vector3() },\n\t\t\t\t\t\"waterColor\": { value: new THREE.Color( 0x555555 ) }\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: [\n\t\t\t\t'uniform mat4 textureMatrix;',\n\t\t\t\t'uniform float time;',\n\n\t\t\t\t'varying vec4 mirrorCoord;',\n\t\t\t\t'varying vec4 worldPosition;',\n\n\t\t\t \t'#include <common>',\n\t\t\t \t'#include <fog_pars_vertex>',\n\t\t\t\t'#include <shadowmap_pars_vertex>',\n\t\t\t\t'#include <logdepthbuf_pars_vertex>',\n\n\t\t\t\t'void main() {',\n\t\t\t\t'\tmirrorCoord = modelMatrix * vec4( position, 1.0 );',\n\t\t\t\t'\tworldPosition = mirrorCoord.xyzw;',\n\t\t\t\t'\tmirrorCoord = textureMatrix * mirrorCoord;',\n\t\t\t\t'\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );',\n\t\t\t\t'\tgl_Position = projectionMatrix * mvPosition;',\n\n\t\t\t\t'#include <logdepthbuf_vertex>',\n\t\t\t\t'#include <fog_vertex>',\n\t\t\t\t'#include <shadowmap_vertex>',\n\t\t\t\t'}'\n\t\t\t].join( '\\n' ),\n\n\t\t\tfragmentShader: [\n\t\t\t\t'uniform sampler2D mirrorSampler;',\n\t\t\t\t'uniform float alpha;',\n\t\t\t\t'uniform float time;',\n\t\t\t\t'uniform float size;',\n\t\t\t\t'uniform float distortionScale;',\n\t\t\t\t'uniform sampler2D normalSampler;',\n\t\t\t\t'uniform vec3 sunColor;',\n\t\t\t\t'uniform vec3 sunDirection;',\n\t\t\t\t'uniform vec3 eye;',\n\t\t\t\t'uniform vec3 waterColor;',\n\n\t\t\t\t'varying vec4 mirrorCoord;',\n\t\t\t\t'varying vec4 worldPosition;',\n\n\t\t\t\t'vec4 getNoise( vec2 uv ) {',\n\t\t\t\t'\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);',\n\t\t\t\t'\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );',\n\t\t\t\t'\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );',\n\t\t\t\t'\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );',\n\t\t\t\t'\tvec4 noise = texture2D( normalSampler, uv0 ) +',\n\t\t\t\t'\t\ttexture2D( normalSampler, uv1 ) +',\n\t\t\t\t'\t\ttexture2D( normalSampler, uv2 ) +',\n\t\t\t\t'\t\ttexture2D( normalSampler, uv3 );',\n\t\t\t\t'\treturn noise * 0.5 - 1.0;',\n\t\t\t\t'}',\n\n\t\t\t\t'void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {',\n\t\t\t\t'\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );',\n\t\t\t\t'\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );',\n\t\t\t\t'\tspecularColor += pow( direction, shiny ) * sunColor * spec;',\n\t\t\t\t'\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;',\n\t\t\t\t'}',\n\n\t\t\t\t'#include <common>',\n\t\t\t\t'#include <packing>',\n\t\t\t\t'#include <bsdfs>',\n\t\t\t\t'#include <fog_pars_fragment>',\n\t\t\t\t'#include <logdepthbuf_pars_fragment>',\n\t\t\t\t'#include <lights_pars_begin>',\n\t\t\t\t'#include <shadowmap_pars_fragment>',\n\t\t\t\t'#include <shadowmask_pars_fragment>',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'#include <logdepthbuf_fragment>',\n\t\t\t\t'\tvec4 noise = getNoise( worldPosition.xz * size );',\n\t\t\t\t'\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );',\n\n\t\t\t\t'\tvec3 diffuseLight = vec3(0.0);',\n\t\t\t\t'\tvec3 specularLight = vec3(0.0);',\n\n\t\t\t\t'\tvec3 worldToEye = eye-worldPosition.xyz;',\n\t\t\t\t'\tvec3 eyeDirection = normalize( worldToEye );',\n\t\t\t\t'\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );',\n\n\t\t\t\t'\tfloat distance = length(worldToEye);',\n\n\t\t\t\t'\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;',\n\t\t\t\t'\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );',\n\n\t\t\t\t'\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );',\n\t\t\t\t'\tfloat rf0 = 0.3;',\n\t\t\t\t'\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );',\n\t\t\t\t'\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;',\n\t\t\t\t'\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);',\n\t\t\t\t'\tvec3 outgoingLight = albedo;',\n\t\t\t\t'\tgl_FragColor = vec4( outgoingLight, alpha );',\n\n\t\t\t\t'#include <tonemapping_fragment>',\n\t\t\t\t'#include <fog_fragment>',\n\t\t\t\t'}'\n\t\t\t].join( '\\n' )\n\n\t\t};\n\n\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\tfragmentShader: mirrorShader.fragmentShader,\n\t\t\tvertexShader: mirrorShader.vertexShader,\n\t\t\tuniforms: THREE.UniformsUtils.clone( mirrorShader.uniforms ),\n\t\t\tlights: true,\n\t\t\tside: side,\n\t\t\tfog: fog\n\t\t} );\n\n\t\tmaterial.uniforms[ \"mirrorSampler\" ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\t\tmaterial.uniforms[ \"alpha\" ].value = alpha;\n\t\tmaterial.uniforms[ \"time\" ].value = time;\n\t\tmaterial.uniforms[ \"normalSampler\" ].value = normalSampler;\n\t\tmaterial.uniforms[ \"sunColor\" ].value = sunColor;\n\t\tmaterial.uniforms[ \"waterColor\" ].value = waterColor;\n\t\tmaterial.uniforms[ \"sunDirection\" ].value = sunDirection;\n\t\tmaterial.uniforms[ \"distortionScale\" ].value = distortionScale;\n\n\t\tmaterial.uniforms[ \"eye\" ].value = eye;\n\n\t\tscope.material = material;\n\n\t\tscope.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\tmirrorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( mirrorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when mirror is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( mirrorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( mirrorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( mirrorWorldPosition );\n\n\t\t\tmirrorCamera.position.copy( view );\n\t\t\tmirrorCamera.up.set( 0, 1, 0 );\n\t\t\tmirrorCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tmirrorCamera.up.reflect( normal );\n\t\t\tmirrorCamera.lookAt( target );\n\n\t\t\tmirrorCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tmirrorCamera.updateMatrixWorld();\n\t\t\tmirrorCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( mirrorCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( mirrorCamera.matrixWorldInverse );\n\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\tmirrorPlane.setFromNormalAndCoplanarPoint( normal, mirrorWorldPosition );\n\t\t\tmirrorPlane.applyMatrix4( mirrorCamera.matrixWorldInverse );\n\n\t\t\tclipPlane.set( mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant );\n\n\t\t\tvar projectionMatrix = mirrorCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// Calculate the scaled plane vector\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t\t// Replacing the third row of the projection matrix\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t\teye.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\t//\n\n\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tvar currentXrEnabled = renderer.xr.enabled;\n\t\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\tscope.visible = false;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification and recursion\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, mirrorCamera );\n\n\t\t\tscope.visible = true;\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tvar viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t};\n\n\t};\n\n\tTHREE.Water.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.Water.prototype.constructor = THREE.Water;\n\t\n\treturn THREE.Water;\n});\n"]}