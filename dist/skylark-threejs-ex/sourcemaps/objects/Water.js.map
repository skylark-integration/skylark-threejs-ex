{"version":3,"sources":["objects/Water.js"],"names":["define","THREE","threex","Water","geometry","options","Mesh","call","this","scope","textureWidth","undefined","textureHeight","clipBias","alpha","time","normalSampler","waterNormals","sunDirection","Vector3","sunColor","Color","waterColor","eye","distortionScale","side","FrontSide","fog","mirrorPlane","Plane","normal","mirrorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","view","target","q","textureMatrix","mirrorCamera","PerspectiveCamera","parameters","minFilter","LinearFilter","magFilter","format","RGBFormat","stencilBuffer","renderTarget","WebGLRenderTarget","MathUtils","isPowerOfTwo","texture","generateMipmaps","mirrorShader","uniforms","UniformsUtils","merge","UniformsLib","value","mirrorSampler","size","vertexShader","join","fragmentShader","material","ShaderMaterial","clone","lights","onBeforeRender","renderer","scene","camera","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","visible","setRenderTarget","autoClear","clear","render","viewport","state","prototype","Object","create","constructor","objects"],"mappings":"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","file":"../../objects/Water.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var Water = function (geometry, options) {\r\n        THREE.Mesh.call(this, geometry);\r\n        var scope = this;\r\n        options = options || {};\r\n        var textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;\r\n        var textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;\r\n        var clipBias = options.clipBias !== undefined ? options.clipBias : 0;\r\n        var alpha = options.alpha !== undefined ? options.alpha : 1;\r\n        var time = options.time !== undefined ? options.time : 0;\r\n        var normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\r\n        var sunDirection = options.sunDirection !== undefined ? options.sunDirection : new THREE.Vector3(0.70707, 0.70707, 0);\r\n        var sunColor = new THREE.Color(options.sunColor !== undefined ? options.sunColor : 16777215);\r\n        var waterColor = new THREE.Color(options.waterColor !== undefined ? options.waterColor : 8355711);\r\n        var eye = options.eye !== undefined ? options.eye : new THREE.Vector3(0, 0, 0);\r\n        var distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20;\r\n        var side = options.side !== undefined ? options.side : THREE.FrontSide;\r\n        var fog = options.fog !== undefined ? options.fog : false;\r\n        var mirrorPlane = new THREE.Plane();\r\n        var normal = new THREE.Vector3();\r\n        var mirrorWorldPosition = new THREE.Vector3();\r\n        var cameraWorldPosition = new THREE.Vector3();\r\n        var rotationMatrix = new THREE.Matrix4();\r\n        var lookAtPosition = new THREE.Vector3(0, 0, -1);\r\n        var clipPlane = new THREE.Vector4();\r\n        var view = new THREE.Vector3();\r\n        var target = new THREE.Vector3();\r\n        var q = new THREE.Vector4();\r\n        var textureMatrix = new THREE.Matrix4();\r\n        var mirrorCamera = new THREE.PerspectiveCamera();\r\n        var parameters = {\r\n            minFilter: THREE.LinearFilter,\r\n            magFilter: THREE.LinearFilter,\r\n            format: THREE.RGBFormat,\r\n            stencilBuffer: false\r\n        };\r\n        var renderTarget = new THREE.WebGLRenderTarget(textureWidth, textureHeight, parameters);\r\n        if (!THREE.MathUtils.isPowerOfTwo(textureWidth) || !THREE.MathUtils.isPowerOfTwo(textureHeight)) {\r\n            renderTarget.texture.generateMipmaps = false;\r\n        }\r\n        var mirrorShader = {\r\n            uniforms: THREE.UniformsUtils.merge([\r\n                THREE.UniformsLib['fog'],\r\n                THREE.UniformsLib['lights'],\r\n                {\r\n                    'normalSampler': { value: null },\r\n                    'mirrorSampler': { value: null },\r\n                    'alpha': { value: 1 },\r\n                    'time': { value: 0 },\r\n                    'size': { value: 1 },\r\n                    'distortionScale': { value: 20 },\r\n                    'textureMatrix': { value: new THREE.Matrix4() },\r\n                    'sunColor': { value: new THREE.Color(8355711) },\r\n                    'sunDirection': { value: new THREE.Vector3(0.70707, 0.70707, 0) },\r\n                    'eye': { value: new THREE.Vector3() },\r\n                    'waterColor': { value: new THREE.Color(5592405) }\r\n                }\r\n            ]),\r\n            vertexShader: [\r\n                'uniform mat4 textureMatrix;',\r\n                'uniform float time;',\r\n                'varying vec4 mirrorCoord;',\r\n                'varying vec4 worldPosition;',\r\n                '#include <common>',\r\n                '#include <fog_pars_vertex>',\r\n                '#include <shadowmap_pars_vertex>',\r\n                '#include <logdepthbuf_pars_vertex>',\r\n                'void main() {',\r\n                '\\tmirrorCoord = modelMatrix * vec4( position, 1.0 );',\r\n                '\\tworldPosition = mirrorCoord.xyzw;',\r\n                '\\tmirrorCoord = textureMatrix * mirrorCoord;',\r\n                '\\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );',\r\n                '\\tgl_Position = projectionMatrix * mvPosition;',\r\n                '#include <logdepthbuf_vertex>',\r\n                '#include <fog_vertex>',\r\n                '#include <shadowmap_vertex>',\r\n                '}'\r\n            ].join('\\n'),\r\n            fragmentShader: [\r\n                'uniform sampler2D mirrorSampler;',\r\n                'uniform float alpha;',\r\n                'uniform float time;',\r\n                'uniform float size;',\r\n                'uniform float distortionScale;',\r\n                'uniform sampler2D normalSampler;',\r\n                'uniform vec3 sunColor;',\r\n                'uniform vec3 sunDirection;',\r\n                'uniform vec3 eye;',\r\n                'uniform vec3 waterColor;',\r\n                'varying vec4 mirrorCoord;',\r\n                'varying vec4 worldPosition;',\r\n                'vec4 getNoise( vec2 uv ) {',\r\n                '\\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);',\r\n                '\\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );',\r\n                '\\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );',\r\n                '\\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );',\r\n                '\\tvec4 noise = texture2D( normalSampler, uv0 ) +',\r\n                '\\t\\ttexture2D( normalSampler, uv1 ) +',\r\n                '\\t\\ttexture2D( normalSampler, uv2 ) +',\r\n                '\\t\\ttexture2D( normalSampler, uv3 );',\r\n                '\\treturn noise * 0.5 - 1.0;',\r\n                '}',\r\n                'void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {',\r\n                '\\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );',\r\n                '\\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );',\r\n                '\\tspecularColor += pow( direction, shiny ) * sunColor * spec;',\r\n                '\\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;',\r\n                '}',\r\n                '#include <common>',\r\n                '#include <packing>',\r\n                '#include <bsdfs>',\r\n                '#include <fog_pars_fragment>',\r\n                '#include <logdepthbuf_pars_fragment>',\r\n                '#include <lights_pars_begin>',\r\n                '#include <shadowmap_pars_fragment>',\r\n                '#include <shadowmask_pars_fragment>',\r\n                'void main() {',\r\n                '#include <logdepthbuf_fragment>',\r\n                '\\tvec4 noise = getNoise( worldPosition.xz * size );',\r\n                '\\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );',\r\n                '\\tvec3 diffuseLight = vec3(0.0);',\r\n                '\\tvec3 specularLight = vec3(0.0);',\r\n                '\\tvec3 worldToEye = eye-worldPosition.xyz;',\r\n                '\\tvec3 eyeDirection = normalize( worldToEye );',\r\n                '\\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );',\r\n                '\\tfloat distance = length(worldToEye);',\r\n                '\\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;',\r\n                '\\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );',\r\n                '\\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );',\r\n                '\\tfloat rf0 = 0.3;',\r\n                '\\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );',\r\n                '\\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;',\r\n                '\\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);',\r\n                '\\tvec3 outgoingLight = albedo;',\r\n                '\\tgl_FragColor = vec4( outgoingLight, alpha );',\r\n                '#include <tonemapping_fragment>',\r\n                '#include <fog_fragment>',\r\n                '}'\r\n            ].join('\\n')\r\n        };\r\n        var material = new THREE.ShaderMaterial({\r\n            fragmentShader: mirrorShader.fragmentShader,\r\n            vertexShader: mirrorShader.vertexShader,\r\n            uniforms: THREE.UniformsUtils.clone(mirrorShader.uniforms),\r\n            lights: true,\r\n            side: side,\r\n            fog: fog\r\n        });\r\n        material.uniforms['mirrorSampler'].value = renderTarget.texture;\r\n        material.uniforms['textureMatrix'].value = textureMatrix;\r\n        material.uniforms['alpha'].value = alpha;\r\n        material.uniforms['time'].value = time;\r\n        material.uniforms['normalSampler'].value = normalSampler;\r\n        material.uniforms['sunColor'].value = sunColor;\r\n        material.uniforms['waterColor'].value = waterColor;\r\n        material.uniforms['sunDirection'].value = sunDirection;\r\n        material.uniforms['distortionScale'].value = distortionScale;\r\n        material.uniforms['eye'].value = eye;\r\n        scope.material = material;\r\n        scope.onBeforeRender = function (renderer, scene, camera) {\r\n            mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\r\n            cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\r\n            rotationMatrix.extractRotation(scope.matrixWorld);\r\n            normal.set(0, 0, 1);\r\n            normal.applyMatrix4(rotationMatrix);\r\n            view.subVectors(mirrorWorldPosition, cameraWorldPosition);\r\n            if (view.dot(normal) > 0)\r\n                return;\r\n            view.reflect(normal).negate();\r\n            view.add(mirrorWorldPosition);\r\n            rotationMatrix.extractRotation(camera.matrixWorld);\r\n            lookAtPosition.set(0, 0, -1);\r\n            lookAtPosition.applyMatrix4(rotationMatrix);\r\n            lookAtPosition.add(cameraWorldPosition);\r\n            target.subVectors(mirrorWorldPosition, lookAtPosition);\r\n            target.reflect(normal).negate();\r\n            target.add(mirrorWorldPosition);\r\n            mirrorCamera.position.copy(view);\r\n            mirrorCamera.up.set(0, 1, 0);\r\n            mirrorCamera.up.applyMatrix4(rotationMatrix);\r\n            mirrorCamera.up.reflect(normal);\r\n            mirrorCamera.lookAt(target);\r\n            mirrorCamera.far = camera.far;\r\n            mirrorCamera.updateMatrixWorld();\r\n            mirrorCamera.projectionMatrix.copy(camera.projectionMatrix);\r\n            textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\r\n            textureMatrix.multiply(mirrorCamera.projectionMatrix);\r\n            textureMatrix.multiply(mirrorCamera.matrixWorldInverse);\r\n            mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\r\n            mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\r\n            clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\r\n            var projectionMatrix = mirrorCamera.projectionMatrix;\r\n            q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\r\n            q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\r\n            q.z = -1;\r\n            q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\r\n            clipPlane.multiplyScalar(2 / clipPlane.dot(q));\r\n            projectionMatrix.elements[2] = clipPlane.x;\r\n            projectionMatrix.elements[6] = clipPlane.y;\r\n            projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\r\n            projectionMatrix.elements[14] = clipPlane.w;\r\n            eye.setFromMatrixPosition(camera.matrixWorld);\r\n            var currentRenderTarget = renderer.getRenderTarget();\r\n            var currentXrEnabled = renderer.xr.enabled;\r\n            var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\r\n            scope.visible = false;\r\n            renderer.xr.enabled = false;\r\n            renderer.shadowMap.autoUpdate = false;\r\n            renderer.setRenderTarget(renderTarget);\r\n            if (renderer.autoClear === false)\r\n                renderer.clear();\r\n            renderer.render(scene, mirrorCamera);\r\n            scope.visible = true;\r\n            renderer.xr.enabled = currentXrEnabled;\r\n            renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\r\n            renderer.setRenderTarget(currentRenderTarget);\r\n            var viewport = camera.viewport;\r\n            if (viewport !== undefined) {\r\n                renderer.state.viewport(viewport);\r\n            }\r\n        };\r\n    };\r\n    Water.prototype = Object.create(THREE.Mesh.prototype);\r\n    Water.prototype.constructor = Water;\r\n\r\n    return threex.objects.Water = Water;\r\n});"]}