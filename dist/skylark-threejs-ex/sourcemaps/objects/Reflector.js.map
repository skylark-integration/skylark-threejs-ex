{"version":3,"sources":["objects/Reflector.js"],"names":["define","THREE","threex","Reflector","geometry","options","Mesh","call","this","type","scope","color","undefined","Color","textureWidth","textureHeight","clipBias","shader","ReflectorShader","recursion","encoding","LinearEncoding","reflectorPlane","Plane","normal","Vector3","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","view","target","q","textureMatrix","virtualCamera","PerspectiveCamera","parameters","minFilter","LinearFilter","magFilter","format","RGBFormat","stencilBuffer","renderTarget","WebGLRenderTarget","MathUtils","isPowerOfTwo","texture","generateMipmaps","material","ShaderMaterial","uniforms","UniformsUtils","clone","fragmentShader","vertexShader","value","onBeforeRender","renderer","scene","camera","userData","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","autoClear","clear","render","viewport","state","prototype","Object","create","constructor","tDiffuse","join","objects"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,EAAY,SAAUC,EAAUC,GAChCJ,EAAMK,KAAKC,KAAKC,KAAMJ,GACtBI,KAAKC,KAAO,YACZ,IAAIC,EAAQF,KAERG,OAA0BC,KAD9BP,EAAUA,OACUM,MAAsB,IAAIV,EAAMY,MAAMR,EAAQM,OAAS,IAAIV,EAAMY,MAAM,SACvFC,EAAeT,EAAQS,cAAgB,IACvCC,EAAgBV,EAAQU,eAAiB,IACzCC,EAAWX,EAAQW,UAAY,EAC/BC,EAASZ,EAAQY,QAAUd,EAAUe,gBACrCC,OAAkCP,IAAtBP,EAAQc,UAA0Bd,EAAQc,UAAY,EAClEC,OAAgCR,IAArBP,EAAQe,SAAyBf,EAAQe,SAAWnB,EAAMoB,eACrEC,EAAiB,IAAIrB,EAAMsB,MAC3BC,EAAS,IAAIvB,EAAMwB,QACnBC,EAAyB,IAAIzB,EAAMwB,QACnCE,EAAsB,IAAI1B,EAAMwB,QAChCG,EAAiB,IAAI3B,EAAM4B,QAC3BC,EAAiB,IAAI7B,EAAMwB,QAAQ,EAAG,GAAI,GAC1CM,EAAY,IAAI9B,EAAM+B,QACtBC,EAAO,IAAIhC,EAAMwB,QACjBS,EAAS,IAAIjC,EAAMwB,QACnBU,EAAI,IAAIlC,EAAM+B,QACdI,EAAgB,IAAInC,EAAM4B,QAC1BQ,EAAgB,IAAIpC,EAAMqC,kBAC1BC,GACAC,UAAWvC,EAAMwC,aACjBC,UAAWzC,EAAMwC,aACjBE,OAAQ1C,EAAM2C,UACdC,eAAe,EACfzB,SAAUA,GAEV0B,EAAe,IAAI7C,EAAM8C,kBAAkBjC,EAAcC,EAAewB,GACvEtC,EAAM+C,UAAUC,aAAanC,IAAkBb,EAAM+C,UAAUC,aAAalC,KAC7E+B,EAAaI,QAAQC,iBAAkB,GAE3C,IAAIC,EAAW,IAAInD,EAAMoD,gBACrBC,SAAUrD,EAAMsD,cAAcC,MAAMvC,EAAOqC,UAC3CG,eAAgBxC,EAAOwC,eACvBC,aAAczC,EAAOyC,eAEzBN,EAASE,SAAmB,SAAEK,MAAQb,EAAaI,QACnDE,EAASE,SAAgB,MAAEK,MAAQhD,EACnCyC,EAASE,SAAwB,cAAEK,MAAQvB,EAC3C5B,KAAK4C,SAAWA,EAChB5C,KAAKoD,eAAiB,SAAUC,EAAUC,EAAOC,GAC7C,GAAI,cAAeA,EAAOC,SAAU,CAChC,GAAID,EAAOC,SAAS7C,YAAcA,EAC9B,OACJ4C,EAAOC,SAAS7C,YAQpB,GANAO,EAAuBuC,sBAAsBvD,EAAMwD,aACnDvC,EAAoBsC,sBAAsBF,EAAOG,aACjDtC,EAAeuC,gBAAgBzD,EAAMwD,aACrC1C,EAAO4C,IAAI,EAAG,EAAG,GACjB5C,EAAO6C,aAAazC,GACpBK,EAAKqC,WAAW5C,EAAwBC,KACpCM,EAAKsC,IAAI/C,GAAU,GAAvB,CAEAS,EAAKuC,QAAQhD,GAAQiD,SACrBxC,EAAKyC,IAAIhD,GACTE,EAAeuC,gBAAgBJ,EAAOG,aACtCpC,EAAesC,IAAI,EAAG,GAAI,GAC1BtC,EAAeuC,aAAazC,GAC5BE,EAAe4C,IAAI/C,GACnBO,EAAOoC,WAAW5C,EAAwBI,GAC1CI,EAAOsC,QAAQhD,GAAQiD,SACvBvC,EAAOwC,IAAIhD,GACXW,EAAcsC,SAASC,KAAK3C,GAC5BI,EAAcwC,GAAGT,IAAI,EAAG,EAAG,GAC3B/B,EAAcwC,GAAGR,aAAazC,GAC9BS,EAAcwC,GAAGL,QAAQhD,GACzBa,EAAcyC,OAAO5C,GACrBG,EAAc0C,IAAMhB,EAAOgB,IAC3B1C,EAAc2C,oBACd3C,EAAc4C,iBAAiBL,KAAKb,EAAOkB,kBAC3C5C,EAAc2B,SAAS7C,UAAY,EACnCiB,EAAcgC,IAAI,GAAK,EAAG,EAAG,GAAK,EAAG,GAAK,EAAG,GAAK,EAAG,EAAG,GAAK,GAAK,EAAG,EAAG,EAAG,GAC3EhC,EAAc8C,SAAS7C,EAAc4C,kBACrC7C,EAAc8C,SAAS7C,EAAc8C,oBACrC/C,EAAc8C,SAASxE,EAAMwD,aAC7B5C,EAAe8D,8BAA8B5D,EAAQE,GACrDJ,EAAe+C,aAAahC,EAAc8C,oBAC1CpD,EAAUqC,IAAI9C,EAAeE,OAAO6D,EAAG/D,EAAeE,OAAO8D,EAAGhE,EAAeE,OAAO+D,EAAGjE,EAAekE,UACxG,IAAIP,EAAmB5C,EAAc4C,iBACrC9C,EAAEkD,GAAKI,KAAKC,KAAK3D,EAAUsD,GAAKJ,EAAiBU,SAAS,IAAMV,EAAiBU,SAAS,GAC1FxD,EAAEmD,GAAKG,KAAKC,KAAK3D,EAAUuD,GAAKL,EAAiBU,SAAS,IAAMV,EAAiBU,SAAS,GAC1FxD,EAAEoD,GAAK,EACPpD,EAAEyD,GAAK,EAAIX,EAAiBU,SAAS,KAAOV,EAAiBU,SAAS,IACtE5D,EAAU8D,eAAe,EAAI9D,EAAUwC,IAAIpC,IAC3C8C,EAAiBU,SAAS,GAAK5D,EAAUsD,EACzCJ,EAAiBU,SAAS,GAAK5D,EAAUuD,EACzCL,EAAiBU,SAAS,IAAM5D,EAAUwD,EAAI,EAAIvE,EAClDiE,EAAiBU,SAAS,IAAM5D,EAAU6D,EAC1ClF,EAAMoF,SAAU,EAChB,IAAIC,EAAsBlC,EAASmC,kBAC/BC,EAAmBpC,EAASqC,GAAGC,QAC/BC,EAA0BvC,EAASwC,UAAUC,WACjDzC,EAASqC,GAAGC,SAAU,EACtBtC,EAASwC,UAAUC,YAAa,EAChCzC,EAAS0C,gBAAgBzD,IACE,IAAvBe,EAAS2C,WACT3C,EAAS4C,QACb5C,EAAS6C,OAAO5C,EAAOzB,GACvBwB,EAASqC,GAAGC,QAAUF,EACtBpC,EAASwC,UAAUC,WAAaF,EAChCvC,EAAS0C,gBAAgBR,GACzB,IAAIY,EAAW5C,EAAO4C,cACL/F,IAAb+F,GACA9C,EAAS+C,MAAMD,SAASA,GAE5BjG,EAAMoF,SAAU,IAEpBtF,KAAKwF,gBAAkB,WACnB,OAAOlD,IAoCf,OAjCA3C,EAAU0G,UAAYC,OAAOC,OAAO9G,EAAMK,KAAKuG,WAC/C1G,EAAU0G,UAAUG,YAAc7G,EAClCA,EAAUe,iBACNoC,UACI3C,OAAWgD,MAAO,MAClBsD,UAActD,MAAO,MACrBvB,eAAmBuB,MAAO,OAE9BD,cACI,8BACA,oBACA,gBACA,iDACA,8EACA,KACFwD,KAAK,MACPzD,gBACI,sBACA,8BACA,oBACA,kDACA,sGACA,IACA,+CACA,sHACA,IACA,gBACA,gDACA,iEACA,KACFyD,KAAK,OAGJhH,EAAOiH,QAAQhH,UAAYA","file":"../../objects/Reflector.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var Reflector = function (geometry, options) {\r\n        THREE.Mesh.call(this, geometry);\r\n        this.type = 'Reflector';\r\n        var scope = this;\r\n        options = options || {};\r\n        var color = options.color !== undefined ? new THREE.Color(options.color) : new THREE.Color(8355711);\r\n        var textureWidth = options.textureWidth || 512;\r\n        var textureHeight = options.textureHeight || 512;\r\n        var clipBias = options.clipBias || 0;\r\n        var shader = options.shader || Reflector.ReflectorShader;\r\n        var recursion = options.recursion !== undefined ? options.recursion : 0;\r\n        var encoding = options.encoding !== undefined ? options.encoding : THREE.LinearEncoding;\r\n        var reflectorPlane = new THREE.Plane();\r\n        var normal = new THREE.Vector3();\r\n        var reflectorWorldPosition = new THREE.Vector3();\r\n        var cameraWorldPosition = new THREE.Vector3();\r\n        var rotationMatrix = new THREE.Matrix4();\r\n        var lookAtPosition = new THREE.Vector3(0, 0, -1);\r\n        var clipPlane = new THREE.Vector4();\r\n        var view = new THREE.Vector3();\r\n        var target = new THREE.Vector3();\r\n        var q = new THREE.Vector4();\r\n        var textureMatrix = new THREE.Matrix4();\r\n        var virtualCamera = new THREE.PerspectiveCamera();\r\n        var parameters = {\r\n            minFilter: THREE.LinearFilter,\r\n            magFilter: THREE.LinearFilter,\r\n            format: THREE.RGBFormat,\r\n            stencilBuffer: false,\r\n            encoding: encoding\r\n        };\r\n        var renderTarget = new THREE.WebGLRenderTarget(textureWidth, textureHeight, parameters);\r\n        if (!THREE.MathUtils.isPowerOfTwo(textureWidth) || !THREE.MathUtils.isPowerOfTwo(textureHeight)) {\r\n            renderTarget.texture.generateMipmaps = false;\r\n        }\r\n        var material = new THREE.ShaderMaterial({\r\n            uniforms: THREE.UniformsUtils.clone(shader.uniforms),\r\n            fragmentShader: shader.fragmentShader,\r\n            vertexShader: shader.vertexShader\r\n        });\r\n        material.uniforms['tDiffuse'].value = renderTarget.texture;\r\n        material.uniforms['color'].value = color;\r\n        material.uniforms['textureMatrix'].value = textureMatrix;\r\n        this.material = material;\r\n        this.onBeforeRender = function (renderer, scene, camera) {\r\n            if ('recursion' in camera.userData) {\r\n                if (camera.userData.recursion === recursion)\r\n                    return;\r\n                camera.userData.recursion++;\r\n            }\r\n            reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\r\n            cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\r\n            rotationMatrix.extractRotation(scope.matrixWorld);\r\n            normal.set(0, 0, 1);\r\n            normal.applyMatrix4(rotationMatrix);\r\n            view.subVectors(reflectorWorldPosition, cameraWorldPosition);\r\n            if (view.dot(normal) > 0)\r\n                return;\r\n            view.reflect(normal).negate();\r\n            view.add(reflectorWorldPosition);\r\n            rotationMatrix.extractRotation(camera.matrixWorld);\r\n            lookAtPosition.set(0, 0, -1);\r\n            lookAtPosition.applyMatrix4(rotationMatrix);\r\n            lookAtPosition.add(cameraWorldPosition);\r\n            target.subVectors(reflectorWorldPosition, lookAtPosition);\r\n            target.reflect(normal).negate();\r\n            target.add(reflectorWorldPosition);\r\n            virtualCamera.position.copy(view);\r\n            virtualCamera.up.set(0, 1, 0);\r\n            virtualCamera.up.applyMatrix4(rotationMatrix);\r\n            virtualCamera.up.reflect(normal);\r\n            virtualCamera.lookAt(target);\r\n            virtualCamera.far = camera.far;\r\n            virtualCamera.updateMatrixWorld();\r\n            virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\r\n            virtualCamera.userData.recursion = 0;\r\n            textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\r\n            textureMatrix.multiply(virtualCamera.projectionMatrix);\r\n            textureMatrix.multiply(virtualCamera.matrixWorldInverse);\r\n            textureMatrix.multiply(scope.matrixWorld);\r\n            reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\r\n            reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\r\n            clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\r\n            var projectionMatrix = virtualCamera.projectionMatrix;\r\n            q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\r\n            q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\r\n            q.z = -1;\r\n            q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\r\n            clipPlane.multiplyScalar(2 / clipPlane.dot(q));\r\n            projectionMatrix.elements[2] = clipPlane.x;\r\n            projectionMatrix.elements[6] = clipPlane.y;\r\n            projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\r\n            projectionMatrix.elements[14] = clipPlane.w;\r\n            scope.visible = false;\r\n            var currentRenderTarget = renderer.getRenderTarget();\r\n            var currentXrEnabled = renderer.xr.enabled;\r\n            var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\r\n            renderer.xr.enabled = false;\r\n            renderer.shadowMap.autoUpdate = false;\r\n            renderer.setRenderTarget(renderTarget);\r\n            if (renderer.autoClear === false)\r\n                renderer.clear();\r\n            renderer.render(scene, virtualCamera);\r\n            renderer.xr.enabled = currentXrEnabled;\r\n            renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\r\n            renderer.setRenderTarget(currentRenderTarget);\r\n            var viewport = camera.viewport;\r\n            if (viewport !== undefined) {\r\n                renderer.state.viewport(viewport);\r\n            }\r\n            scope.visible = true;\r\n        };\r\n        this.getRenderTarget = function () {\r\n            return renderTarget;\r\n        };\r\n    };\r\n    Reflector.prototype = Object.create(THREE.Mesh.prototype);\r\n    Reflector.prototype.constructor = Reflector;\r\n    Reflector.ReflectorShader = {\r\n        uniforms: {\r\n            'color': { value: null },\r\n            'tDiffuse': { value: null },\r\n            'textureMatrix': { value: null }\r\n        },\r\n        vertexShader: [\r\n            'uniform mat4 textureMatrix;',\r\n            'varying vec4 vUv;',\r\n            'void main() {',\r\n            '\\tvUv = textureMatrix * vec4( position, 1.0 );',\r\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n            '}'\r\n        ].join('\\n'),\r\n        fragmentShader: [\r\n            'uniform vec3 color;',\r\n            'uniform sampler2D tDiffuse;',\r\n            'varying vec4 vUv;',\r\n            'float blendOverlay( float base, float blend ) {',\r\n            '\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\r\n            '}',\r\n            'vec3 blendOverlay( vec3 base, vec3 blend ) {',\r\n            '\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\r\n            '}',\r\n            'void main() {',\r\n            '\\tvec4 base = texture2DProj( tDiffuse, vUv );',\r\n            '\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\r\n            '}'\r\n        ].join('\\n')\r\n    };\r\n\r\n    return threex.objects.Reflector = Reflector;\r\n});"]}