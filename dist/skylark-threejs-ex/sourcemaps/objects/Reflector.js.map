{"version":3,"sources":["objects/Reflector.js"],"names":["define","THREE","Reflector","geometry","options","Mesh","call","this","type","scope","color","undefined","Color","textureWidth","textureHeight","clipBias","shader","ReflectorShader","recursion","encoding","LinearEncoding","reflectorPlane","Plane","normal","Vector3","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","view","target","q","textureMatrix","virtualCamera","PerspectiveCamera","parameters","minFilter","LinearFilter","magFilter","format","RGBFormat","stencilBuffer","renderTarget","WebGLRenderTarget","MathUtils","isPowerOfTwo","texture","generateMipmaps","material","ShaderMaterial","uniforms","UniformsUtils","clone","fragmentShader","vertexShader","value","onBeforeRender","renderer","scene","camera","userData","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","autoClear","clear","render","viewport","state","prototype","Object","create","constructor","tDiffuse","join"],"mappings":"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","file":"../../objects/Reflector.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Slayvin / http://slayvin.net\n\t */\n\n\tTHREE.Reflector = function ( geometry, options ) {\n\n\t\tTHREE.Mesh.call( this, geometry );\n\n\t\tthis.type = 'Reflector';\n\n\t\tvar scope = this;\n\n\t\toptions = options || {};\n\n\t\tvar color = ( options.color !== undefined ) ? new THREE.Color( options.color ) : new THREE.Color( 0x7F7F7F );\n\t\tvar textureWidth = options.textureWidth || 512;\n\t\tvar textureHeight = options.textureHeight || 512;\n\t\tvar clipBias = options.clipBias || 0;\n\t\tvar shader = options.shader || THREE.Reflector.ReflectorShader;\n\t\tvar recursion = options.recursion !== undefined ? options.recursion : 0;\n\t\tvar encoding = options.encoding !== undefined ? options.encoding : THREE.LinearEncoding;\n\n\t\t//\n\n\t\tvar reflectorPlane = new THREE.Plane();\n\t\tvar normal = new THREE.Vector3();\n\t\tvar reflectorWorldPosition = new THREE.Vector3();\n\t\tvar cameraWorldPosition = new THREE.Vector3();\n\t\tvar rotationMatrix = new THREE.Matrix4();\n\t\tvar lookAtPosition = new THREE.Vector3( 0, 0, - 1 );\n\t\tvar clipPlane = new THREE.Vector4();\n\n\t\tvar view = new THREE.Vector3();\n\t\tvar target = new THREE.Vector3();\n\t\tvar q = new THREE.Vector4();\n\n\t\tvar textureMatrix = new THREE.Matrix4();\n\t\tvar virtualCamera = new THREE.PerspectiveCamera();\n\n\t\tvar parameters = {\n\t\t\tminFilter: THREE.LinearFilter,\n\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\tformat: THREE.RGBFormat,\n\t\t\tstencilBuffer: false,\n\t\t\tencoding: encoding\n\t\t};\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\t\tif ( ! THREE.MathUtils.isPowerOfTwo( textureWidth ) || ! THREE.MathUtils.isPowerOfTwo( textureHeight ) ) {\n\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\t}\n\n\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader\n\t\t} );\n\n\t\tmaterial.uniforms[ \"tDiffuse\" ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ \"color\" ].value = color;\n\t\tmaterial.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\n\t\tthis.material = material;\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\tif ( 'recursion' in camera.userData ) {\n\n\t\t\t\tif ( camera.userData.recursion === recursion ) return;\n\n\t\t\t\tcamera.userData.recursion ++;\n\n\t\t\t}\n\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when reflector is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( reflectorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( reflectorWorldPosition );\n\n\t\t\tvirtualCamera.position.copy( view );\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tvirtualCamera.up.reflect( normal );\n\t\t\tvirtualCamera.lookAt( target );\n\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\tvirtualCamera.userData.recursion = 0;\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// Calculate the scaled plane vector\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t\t// Replacing the third row of the projection matrix\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t\t// Render\n\n\t\t\tscope.visible = false;\n\n\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tvar currentXrEnabled = renderer.xr.enabled;\n\t\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification and recursion\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tvar viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t};\n\n\tTHREE.Reflector.prototype = Object.create( THREE.Mesh.prototype );\n\tTHREE.Reflector.prototype.constructor = THREE.Reflector;\n\n\tTHREE.Reflector.ReflectorShader = {\n\n\t\tuniforms: {\n\n\t\t\t'color': {\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'tDiffuse': {\n\t\t\t\tvalue: null\n\t\t\t},\n\n\t\t\t'textureMatrix': {\n\t\t\t\tvalue: null\n\t\t\t}\n\n\t\t},\n\n\t\tvertexShader: [\n\t\t\t'uniform mat4 textureMatrix;',\n\t\t\t'varying vec4 vUv;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvUv = textureMatrix * vec4( position, 1.0 );',\n\n\t\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t\t'}'\n\t\t].join( '\\n' ),\n\n\t\tfragmentShader: [\n\t\t\t'uniform vec3 color;',\n\t\t\t'uniform sampler2D tDiffuse;',\n\t\t\t'varying vec4 vUv;',\n\n\t\t\t'float blendOverlay( float base, float blend ) {',\n\n\t\t\t'\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\n\n\t\t\t'}',\n\n\t\t\t'vec3 blendOverlay( vec3 base, vec3 blend ) {',\n\n\t\t\t'\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\n\n\t\t\t'}',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvec4 base = texture2DProj( tDiffuse, vUv );',\n\t\t\t'\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\n\n\t\t\t'}'\n\t\t].join( '\\n' )\n\t};\n\t\n\treturn THREE.Reflector;\n});\n"]}