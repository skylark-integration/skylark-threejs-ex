{"version":3,"sources":["objects/Reflector.js"],"names":["define","THREE","threex","Reflector","geometry","options","Mesh","call","this","type","scope","color","undefined","Color","textureWidth","textureHeight","clipBias","shader","ReflectorShader","recursion","encoding","LinearEncoding","reflectorPlane","Plane","normal","Vector3","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","view","target","q","textureMatrix","virtualCamera","PerspectiveCamera","parameters","minFilter","LinearFilter","magFilter","format","RGBFormat","stencilBuffer","renderTarget","WebGLRenderTarget","MathUtils","isPowerOfTwo","texture","generateMipmaps","material","ShaderMaterial","uniforms","UniformsUtils","clone","fragmentShader","vertexShader","value","onBeforeRender","renderer","scene","camera","userData","setFromMatrixPosition","matrixWorld","extractRotation","set","applyMatrix4","subVectors","dot","reflect","negate","add","position","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","y","z","constant","Math","sign","elements","w","multiplyScalar","visible","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","autoClear","clear","render","viewport","state","prototype","Object","create","constructor","tDiffuse","join","objects"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,EAAY,SAAUC,EAAUC,GAChCJ,EAAMK,KAAKC,KAAKC,KAAMJ,GACtBI,KAAKC,KAAO,YACZ,IAAIC,EAAQF,KAERG,OAA0BC,KAD9BP,EAAUA,OACUM,MAAsB,IAAIV,EAAMY,MAAMR,EAAQM,OAAS,IAAIV,EAAMY,MAAM,SACvFC,EAAeT,EAAQS,cAAgB,IACvCC,EAAgBV,EAAQU,eAAiB,IACzCC,EAAWX,EAAQW,UAAY,EAC/BC,EAASZ,EAAQY,QAAUd,EAAUe,gBACrCC,OAAkCP,IAAtBP,EAAQc,UAA0Bd,EAAQc,UAAY,EAClEC,OAAgCR,IAArBP,EAAQe,SAAyBf,EAAQe,SAAWnB,EAAMoB,eACrEC,EAAiB,IAAIrB,EAAMsB,MAC3BC,EAAS,IAAIvB,EAAMwB,QACnBC,EAAyB,IAAIzB,EAAMwB,QACnCE,EAAsB,IAAI1B,EAAMwB,QAChCG,EAAiB,IAAI3B,EAAM4B,QAC3BC,EAAiB,IAAI7B,EAAMwB,QAAQ,EAAG,GAAI,GAC1CM,EAAY,IAAI9B,EAAM+B,QACtBC,EAAO,IAAIhC,EAAMwB,QACjBS,EAAS,IAAIjC,EAAMwB,QACnBU,EAAI,IAAIlC,EAAM+B,QACdI,EAAgB,IAAInC,EAAM4B,QAC1BQ,EAAgB,IAAIpC,EAAMqC,kBAC1BC,GACAC,UAAWvC,EAAMwC,aACjBC,UAAWzC,EAAMwC,aACjBE,OAAQ1C,EAAM2C,UACdC,eAAe,EACfzB,SAAUA,GAEV0B,EAAe,IAAI7C,EAAM8C,kBAAkBjC,EAAcC,EAAewB,GACvEtC,EAAM+C,UAAUC,aAAanC,IAAkBb,EAAM+C,UAAUC,aAAalC,KAC7E+B,EAAaI,QAAQC,iBAAkB,GAE3C,IAAIC,EAAW,IAAInD,EAAMoD,gBACrBC,SAAUrD,EAAMsD,cAAcC,MAAMvC,EAAOqC,UAC3CG,eAAgBxC,EAAOwC,eACvBC,aAAczC,EAAOyC,eAEzBN,EAASE,SAAmB,SAAEK,MAAQb,EAAaI,QACnDE,EAASE,SAAgB,MAAEK,MAAQhD,EACnCyC,EAASE,SAAwB,cAAEK,MAAQvB,EAC3C5B,KAAK4C,SAAWA,EAChB5C,KAAKoD,eAAiB,SAAUC,EAAUC,EAAOC,GAC7C,GAAI,cAAeA,EAAOC,SAAU,CAChC,GAAID,EAAOC,SAAS7C,YAAcA,EAC9B,OACJ4C,EAAOC,SAAS7C,YAQpB,GANAO,EAAuBuC,sBAAsBvD,EAAMwD,aACnDvC,EAAoBsC,sBAAsBF,EAAOG,aACjDtC,EAAeuC,gBAAgBzD,EAAMwD,aACrC1C,EAAO4C,IAAI,EAAG,EAAG,GACjB5C,EAAO6C,aAAazC,GACpBK,EAAKqC,WAAW5C,EAAwBC,KACpCM,EAAKsC,IAAI/C,GAAU,GAAvB,CAEAS,EAAKuC,QAAQhD,GAAQiD,SACrBxC,EAAKyC,IAAIhD,GACTE,EAAeuC,gBAAgBJ,EAAOG,aACtCpC,EAAesC,IAAI,EAAG,GAAI,GAC1BtC,EAAeuC,aAAazC,GAC5BE,EAAe4C,IAAI/C,GACnBO,EAAOoC,WAAW5C,EAAwBI,GAC1CI,EAAOsC,QAAQhD,GAAQiD,SACvBvC,EAAOwC,IAAIhD,GACXW,EAAcsC,SAASC,KAAK3C,GAC5BI,EAAcwC,GAAGT,IAAI,EAAG,EAAG,GAC3B/B,EAAcwC,GAAGR,aAAazC,GAC9BS,EAAcwC,GAAGL,QAAQhD,GACzBa,EAAcyC,OAAO5C,GACrBG,EAAc0C,IAAMhB,EAAOgB,IAC3B1C,EAAc2C,oBACd3C,EAAc4C,iBAAiBL,KAAKb,EAAOkB,kBAC3C5C,EAAc2B,SAAS7C,UAAY,EACnCiB,EAAcgC,IAAI,GAAK,EAAG,EAAG,GAAK,EAAG,GAAK,EAAG,GAAK,EAAG,EAAG,GAAK,GAAK,EAAG,EAAG,EAAG,GAC3EhC,EAAc8C,SAAS7C,EAAc4C,kBACrC7C,EAAc8C,SAAS7C,EAAc8C,oBACrC/C,EAAc8C,SAASxE,EAAMwD,aAC7B5C,EAAe8D,8BAA8B5D,EAAQE,GACrDJ,EAAe+C,aAAahC,EAAc8C,oBAC1CpD,EAAUqC,IAAI9C,EAAeE,OAAO6D,EAAG/D,EAAeE,OAAO8D,EAAGhE,EAAeE,OAAO+D,EAAGjE,EAAekE,UACxG,IAAIP,EAAmB5C,EAAc4C,iBACrC9C,EAAEkD,GAAKI,KAAKC,KAAK3D,EAAUsD,GAAKJ,EAAiBU,SAAS,IAAMV,EAAiBU,SAAS,GAC1FxD,EAAEmD,GAAKG,KAAKC,KAAK3D,EAAUuD,GAAKL,EAAiBU,SAAS,IAAMV,EAAiBU,SAAS,GAC1FxD,EAAEoD,GAAK,EACPpD,EAAEyD,GAAK,EAAIX,EAAiBU,SAAS,KAAOV,EAAiBU,SAAS,IACtE5D,EAAU8D,eAAe,EAAI9D,EAAUwC,IAAIpC,IAC3C8C,EAAiBU,SAAS,GAAK5D,EAAUsD,EACzCJ,EAAiBU,SAAS,GAAK5D,EAAUuD,EACzCL,EAAiBU,SAAS,IAAM5D,EAAUwD,EAAI,EAAIvE,EAClDiE,EAAiBU,SAAS,IAAM5D,EAAU6D,EAC1ClF,EAAMoF,SAAU,EAChB,IAAIC,EAAsBlC,EAASmC,kBAC/BC,EAAmBpC,EAASqC,GAAGC,QAC/BC,EAA0BvC,EAASwC,UAAUC,WACjDzC,EAASqC,GAAGC,SAAU,EACtBtC,EAASwC,UAAUC,YAAa,EAChCzC,EAAS0C,gBAAgBzD,IACE,IAAvBe,EAAS2C,WACT3C,EAAS4C,QACb5C,EAAS6C,OAAO5C,EAAOzB,GACvBwB,EAASqC,GAAGC,QAAUF,EACtBpC,EAASwC,UAAUC,WAAaF,EAChCvC,EAAS0C,gBAAgBR,GACzB,IAAIY,EAAW5C,EAAO4C,cACL/F,IAAb+F,GACA9C,EAAS+C,MAAMD,SAASA,GAE5BjG,EAAMoF,SAAU,IAEpBtF,KAAKwF,gBAAkB,WACnB,OAAOlD,IAoCf,OAjCA3C,EAAU0G,UAAYC,OAAOC,OAAO9G,EAAMK,KAAKuG,WAC/C1G,EAAU0G,UAAUG,YAAc7G,EAClCA,EAAUe,iBACNoC,UACI3C,OAAWgD,MAAO,MAClBsD,UAActD,MAAO,MACrBvB,eAAmBuB,MAAO,OAE9BD,cACI,8BACA,oBACA,gBACA,iDACA,8EACA,KACFwD,KAAK,MACPzD,gBACI,sBACA,8BACA,oBACA,kDACA,sGACA,IACA,+CACA,sHACA,IACA,gBACA,gDACA,iEACA,KACFyD,KAAK,OAGJhH,EAAOiH,QAAQhH,UAAYA","file":"../../objects/Reflector.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    var Reflector = function (geometry, options) {\n        THREE.Mesh.call(this, geometry);\n        this.type = 'Reflector';\n        var scope = this;\n        options = options || {};\n        var color = options.color !== undefined ? new THREE.Color(options.color) : new THREE.Color(8355711);\n        var textureWidth = options.textureWidth || 512;\n        var textureHeight = options.textureHeight || 512;\n        var clipBias = options.clipBias || 0;\n        var shader = options.shader || Reflector.ReflectorShader;\n        var recursion = options.recursion !== undefined ? options.recursion : 0;\n        var encoding = options.encoding !== undefined ? options.encoding : THREE.LinearEncoding;\n        var reflectorPlane = new THREE.Plane();\n        var normal = new THREE.Vector3();\n        var reflectorWorldPosition = new THREE.Vector3();\n        var cameraWorldPosition = new THREE.Vector3();\n        var rotationMatrix = new THREE.Matrix4();\n        var lookAtPosition = new THREE.Vector3(0, 0, -1);\n        var clipPlane = new THREE.Vector4();\n        var view = new THREE.Vector3();\n        var target = new THREE.Vector3();\n        var q = new THREE.Vector4();\n        var textureMatrix = new THREE.Matrix4();\n        var virtualCamera = new THREE.PerspectiveCamera();\n        var parameters = {\n            minFilter: THREE.LinearFilter,\n            magFilter: THREE.LinearFilter,\n            format: THREE.RGBFormat,\n            stencilBuffer: false,\n            encoding: encoding\n        };\n        var renderTarget = new THREE.WebGLRenderTarget(textureWidth, textureHeight, parameters);\n        if (!THREE.MathUtils.isPowerOfTwo(textureWidth) || !THREE.MathUtils.isPowerOfTwo(textureHeight)) {\n            renderTarget.texture.generateMipmaps = false;\n        }\n        var material = new THREE.ShaderMaterial({\n            uniforms: THREE.UniformsUtils.clone(shader.uniforms),\n            fragmentShader: shader.fragmentShader,\n            vertexShader: shader.vertexShader\n        });\n        material.uniforms['tDiffuse'].value = renderTarget.texture;\n        material.uniforms['color'].value = color;\n        material.uniforms['textureMatrix'].value = textureMatrix;\n        this.material = material;\n        this.onBeforeRender = function (renderer, scene, camera) {\n            if ('recursion' in camera.userData) {\n                if (camera.userData.recursion === recursion)\n                    return;\n                camera.userData.recursion++;\n            }\n            reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n            cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n            rotationMatrix.extractRotation(scope.matrixWorld);\n            normal.set(0, 0, 1);\n            normal.applyMatrix4(rotationMatrix);\n            view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n            if (view.dot(normal) > 0)\n                return;\n            view.reflect(normal).negate();\n            view.add(reflectorWorldPosition);\n            rotationMatrix.extractRotation(camera.matrixWorld);\n            lookAtPosition.set(0, 0, -1);\n            lookAtPosition.applyMatrix4(rotationMatrix);\n            lookAtPosition.add(cameraWorldPosition);\n            target.subVectors(reflectorWorldPosition, lookAtPosition);\n            target.reflect(normal).negate();\n            target.add(reflectorWorldPosition);\n            virtualCamera.position.copy(view);\n            virtualCamera.up.set(0, 1, 0);\n            virtualCamera.up.applyMatrix4(rotationMatrix);\n            virtualCamera.up.reflect(normal);\n            virtualCamera.lookAt(target);\n            virtualCamera.far = camera.far;\n            virtualCamera.updateMatrixWorld();\n            virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n            virtualCamera.userData.recursion = 0;\n            textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n            textureMatrix.multiply(virtualCamera.projectionMatrix);\n            textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n            textureMatrix.multiply(scope.matrixWorld);\n            reflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n            reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n            clipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n            var projectionMatrix = virtualCamera.projectionMatrix;\n            q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n            q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n            q.z = -1;\n            q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n            clipPlane.multiplyScalar(2 / clipPlane.dot(q));\n            projectionMatrix.elements[2] = clipPlane.x;\n            projectionMatrix.elements[6] = clipPlane.y;\n            projectionMatrix.elements[10] = clipPlane.z + 1 - clipBias;\n            projectionMatrix.elements[14] = clipPlane.w;\n            scope.visible = false;\n            var currentRenderTarget = renderer.getRenderTarget();\n            var currentXrEnabled = renderer.xr.enabled;\n            var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n            renderer.xr.enabled = false;\n            renderer.shadowMap.autoUpdate = false;\n            renderer.setRenderTarget(renderTarget);\n            if (renderer.autoClear === false)\n                renderer.clear();\n            renderer.render(scene, virtualCamera);\n            renderer.xr.enabled = currentXrEnabled;\n            renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n            renderer.setRenderTarget(currentRenderTarget);\n            var viewport = camera.viewport;\n            if (viewport !== undefined) {\n                renderer.state.viewport(viewport);\n            }\n            scope.visible = true;\n        };\n        this.getRenderTarget = function () {\n            return renderTarget;\n        };\n    };\n    Reflector.prototype = Object.create(THREE.Mesh.prototype);\n    Reflector.prototype.constructor = Reflector;\n    Reflector.ReflectorShader = {\n        uniforms: {\n            'color': { value: null },\n            'tDiffuse': { value: null },\n            'textureMatrix': { value: null }\n        },\n        vertexShader: [\n            'uniform mat4 textureMatrix;',\n            'varying vec4 vUv;',\n            'void main() {',\n            '\\tvUv = textureMatrix * vec4( position, 1.0 );',\n            '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n            '}'\n        ].join('\\n'),\n        fragmentShader: [\n            'uniform vec3 color;',\n            'uniform sampler2D tDiffuse;',\n            'varying vec4 vUv;',\n            'float blendOverlay( float base, float blend ) {',\n            '\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\n            '}',\n            'vec3 blendOverlay( vec3 base, vec3 blend ) {',\n            '\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\n            '}',\n            'void main() {',\n            '\\tvec4 base = texture2DProj( tDiffuse, vUv );',\n            '\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\n            '}'\n        ].join('\\n')\n    };\n\n    return threex.objects.Reflector = Reflector;\n});"]}