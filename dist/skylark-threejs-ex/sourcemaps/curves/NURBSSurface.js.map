{"version":3,"sources":["curves/NURBSSurface.js"],"names":["define","THREE","NURBSSurface","degree1","degree2","knots1","knots2","controlPoints","this","len1","length","len2","i","j","point","Vector4","x","y","z","w","prototype","constructor","getPoint","t1","t2","target","u","v","NURBSUtils","calcSurfacePoint"],"mappings":";;;;;;;AAAAA,QACC,kBACA,gBACC,SAASC,GAsDV,OAxCAA,EAAMC,aAAe,SAAWC,EAASC,EAASC,EAAQC,EAA8BC,GAEvFC,KAAKL,QAAUA,EACfK,KAAKJ,QAAUA,EACfI,KAAKH,OAASA,EACdG,KAAKF,OAASA,EACdE,KAAKD,iBAML,IAJA,IAAIE,EAAOJ,EAAOK,OAASP,EAAU,EACjCQ,EAAOL,EAAOI,OAASN,EAAU,EAG3BQ,EAAI,EAAGA,EAAIH,IAASG,EAAI,CAEjCJ,KAAKD,cAAeK,MACpB,IAAM,IAAIC,EAAI,EAAGA,EAAIF,IAASE,EAAI,CAEjC,IAAIC,EAAQP,EAAeK,GAAKC,GAChCL,KAAKD,cAAeK,GAAKC,GAAM,IAAIZ,EAAMc,QAASD,EAAME,EAAGF,EAAMG,EAAGH,EAAMI,EAAGJ,EAAMK,MAStFlB,EAAMC,aAAakB,WAElBC,YAAapB,EAAMC,aAEnBoB,SAAU,SAAWC,EAAIC,EAAIC,GAE5B,IAAIC,EAAIlB,KAAKH,OAAQ,GAAMkB,GAAOf,KAAKH,OAAQG,KAAKH,OAAOK,OAAS,GAAMF,KAAKH,OAAQ,IACnFsB,EAAInB,KAAKF,OAAQ,GAAMkB,GAAOhB,KAAKF,OAAQE,KAAKF,OAAOI,OAAS,GAAMF,KAAKF,OAAQ,IAEvFL,EAAM2B,WAAWC,iBAAkBrB,KAAKL,QAASK,KAAKJ,QAASI,KAAKH,OAAQG,KAAKF,OAAQE,KAAKD,cAAemB,EAAGC,EAAGF,KAI9GxB,EAAMC","file":"../../curves/NURBSSurface.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"./NURBSUtils\"\n],function(THREE){\n\t/**\n\t * @author renej\n\t * NURBS surface object\n\t *\n\t * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n\t *\n\t **/\n\n\n\t/**************************************************************\n\t *\tNURBS surface\n\t **************************************************************/\n\n\tTHREE.NURBSSurface = function ( degree1, degree2, knots1, knots2 /* arrays of reals */, controlPoints /* array^2 of Vector(2|3|4) */ ) {\n\n\t\tthis.degree1 = degree1;\n\t\tthis.degree2 = degree2;\n\t\tthis.knots1 = knots1;\n\t\tthis.knots2 = knots2;\n\t\tthis.controlPoints = [];\n\n\t\tvar len1 = knots1.length - degree1 - 1;\n\t\tvar len2 = knots2.length - degree2 - 1;\n\n\t\t// ensure Vector4 for control points\n\t\tfor ( var i = 0; i < len1; ++ i ) {\n\n\t\t\tthis.controlPoints[ i ] = [];\n\t\t\tfor ( var j = 0; j < len2; ++ j ) {\n\n\t\t\t\tvar point = controlPoints[ i ][ j ];\n\t\t\t\tthis.controlPoints[ i ][ j ] = new THREE.Vector4( point.x, point.y, point.z, point.w );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\tTHREE.NURBSSurface.prototype = {\n\n\t\tconstructor: THREE.NURBSSurface,\n\n\t\tgetPoint: function ( t1, t2, target ) {\n\n\t\t\tvar u = this.knots1[ 0 ] + t1 * ( this.knots1[ this.knots1.length - 1 ] - this.knots1[ 0 ] ); // linear mapping t1->u\n\t\t\tvar v = this.knots2[ 0 ] + t2 * ( this.knots2[ this.knots2.length - 1 ] - this.knots2[ 0 ] ); // linear mapping t2->u\n\n\t\t\tTHREE.NURBSUtils.calcSurfacePoint( this.degree1, this.degree2, this.knots1, this.knots2, this.controlPoints, u, v, target );\n\n\t\t}\n\t};\n\treturn THREE.NURBSSurface;\n});\n"]}