{"version":3,"sources":["curves/NURBSCurve.js"],"names":["define","THREE","NURBSCurve","degree","knots","controlPoints","startKnot","endKnot","Curve","call","this","length","i","point","Vector4","x","y","z","w","prototype","Object","create","constructor","getPoint","t","u","hpoint","NURBSUtils","calcBSplinePoint","divideScalar","Vector3","getTangent","tangent","calcNURBSDerivatives","clone","normalize"],"mappings":";;;;;;;AAAAA,QACC,kBACA,gBACC,SAASC,GAsEV,OAtDAA,EAAMC,WAAa,SAAWC,EAAQC,EAA4BC,EAA4CC,EAAgCC,GAE7IN,EAAMO,MAAMC,KAAMC,MAElBA,KAAKP,OAASA,EACdO,KAAKN,MAAQA,EACbM,KAAKL,iBAELK,KAAKJ,UAAYA,GAAa,EAC9BI,KAAKH,QAAUA,GAAaG,KAAKN,MAAMO,OAAS,EAChD,IAAM,IAAIC,EAAI,EAAGA,EAAIP,EAAcM,SAAWC,EAAI,CAGjD,IAAIC,EAAQR,EAAeO,GAC3BF,KAAKL,cAAeO,GAAM,IAAIX,EAAMa,QAASD,EAAME,EAAGF,EAAMG,EAAGH,EAAMI,EAAGJ,EAAMK,KAOhFjB,EAAMC,WAAWiB,UAAYC,OAAOC,OAAQpB,EAAMO,MAAMW,WACxDlB,EAAMC,WAAWiB,UAAUG,YAAcrB,EAAMC,WAG/CD,EAAMC,WAAWiB,UAAUI,SAAW,SAAWC,GAEhD,IAAIC,EAAIf,KAAKN,MAAOM,KAAKJ,WAAckB,GAAMd,KAAKN,MAAOM,KAAKH,SAAYG,KAAKN,MAAOM,KAAKJ,YAGvFoB,EAASzB,EAAM0B,WAAWC,iBAAkBlB,KAAKP,OAAQO,KAAKN,MAAOM,KAAKL,cAAeoB,GAS7F,OAPiB,GAAZC,EAAOR,GAGXQ,EAAOG,aAAcH,EAAOR,GAItB,IAAIjB,EAAM6B,QAASJ,EAAOX,EAAGW,EAAOV,EAAGU,EAAOT,IAKtDhB,EAAMC,WAAWiB,UAAUY,WAAa,SAAWP,GAElD,IAAIC,EAAIf,KAAKN,MAAO,GAAMoB,GAAMd,KAAKN,MAAOM,KAAKN,MAAMO,OAAS,GAAMD,KAAKN,MAAO,IAE9E4B,EADO/B,EAAM0B,WAAWM,qBAAsBvB,KAAKP,OAAQO,KAAKN,MAAOM,KAAKL,cAAeoB,EAAG,GAC9E,GAAIS,QAGxB,OAFAF,EAAQG,YAEDH,GAGD/B,EAAMC","file":"../../curves/NURBSCurve.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"./NURBSUtils\"\n],function(THREE){\n\t/**\n\t * @author renej\n\t * NURBS curve object\n\t *\n\t * Derives from Curve, overriding getPoint and getTangent.\n\t *\n\t * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n\t *\n\t **/\n\n\n\t/**************************************************************\n\t *\tNURBS curve\n\t **************************************************************/\n\n\tTHREE.NURBSCurve = function ( degree, knots /* array of reals */, controlPoints /* array of Vector(2|3|4) */, startKnot /* index in knots */, endKnot /* index in knots */ ) {\n\n\t\tTHREE.Curve.call( this );\n\n\t\tthis.degree = degree;\n\t\tthis.knots = knots;\n\t\tthis.controlPoints = [];\n\t\t// Used by periodic NURBS to remove hidden spans\n\t\tthis.startKnot = startKnot || 0;\n\t\tthis.endKnot = endKnot || ( this.knots.length - 1 );\n\t\tfor ( var i = 0; i < controlPoints.length; ++ i ) {\n\n\t\t\t// ensure Vector4 for control points\n\t\t\tvar point = controlPoints[ i ];\n\t\t\tthis.controlPoints[ i ] = new THREE.Vector4( point.x, point.y, point.z, point.w );\n\n\t\t}\n\n\t};\n\n\n\tTHREE.NURBSCurve.prototype = Object.create( THREE.Curve.prototype );\n\tTHREE.NURBSCurve.prototype.constructor = THREE.NURBSCurve;\n\n\n\tTHREE.NURBSCurve.prototype.getPoint = function ( t ) {\n\n\t\tvar u = this.knots[ this.startKnot ] + t * ( this.knots[ this.endKnot ] - this.knots[ this.startKnot ] ); // linear mapping t->u\n\n\t\t// following results in (wx, wy, wz, w) homogeneous point\n\t\tvar hpoint = THREE.NURBSUtils.calcBSplinePoint( this.degree, this.knots, this.controlPoints, u );\n\n\t\tif ( hpoint.w != 1.0 ) {\n\n\t\t\t// project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)\n\t\t\thpoint.divideScalar( hpoint.w );\n\n\t\t}\n\n\t\treturn new THREE.Vector3( hpoint.x, hpoint.y, hpoint.z );\n\n\t};\n\n\n\tTHREE.NURBSCurve.prototype.getTangent = function ( t ) {\n\n\t\tvar u = this.knots[ 0 ] + t * ( this.knots[ this.knots.length - 1 ] - this.knots[ 0 ] );\n\t\tvar ders = THREE.NURBSUtils.calcNURBSDerivatives( this.degree, this.knots, this.controlPoints, u, 1 );\n\t\tvar tangent = ders[ 1 ].clone();\n\t\ttangent.normalize();\n\n\t\treturn tangent;\n\n\t};\n\treturn THREE.NURBSCurve;\n});\n"]}