{"version":3,"sources":["interactive/SelectionBox.js"],"names":["define","THREE","SelectionBox","frustum","Frustum","center","Vector3","tmpPoint","vecNear","vecTopLeft","vecTopRight","vecDownRight","vecDownLeft","vecFarTopLeft","vecFarTopRight","vecFarDownRight","vecFarDownLeft","vectemp1","vectemp2","vectemp3","camera","scene","deep","this","startPoint","endPoint","collection","Number","MAX_VALUE","prototype","select","updateFrustum","searchChildInFrustum","updateProjectionMatrix","updateMatrixWorld","isPerspectiveCamera","copy","x","Math","min","y","max","position","set","unproject","sub","normalize","multiplyScalar","add","planes","setFromCoplanarPoints","normal","isOrthographicCamera","equals","addScalar","EPSILON","left","top","right","down","console","error","object","isMesh","isLine","isPoints","undefined","material","geometry","boundingSphere","computeBoundingSphere","applyMatrix4","matrixWorld","containsPoint","push","children","length"],"mappings":";;;;;;;AAAAA,QACC,mBACC,SAASC,GA4LV,OAtLAA,EAAMC,aAAe,WAEpB,IAAIC,EAAU,IAAIF,EAAMG,QACpBC,EAAS,IAAIJ,EAAMK,QAEnBC,EAAW,IAAIN,EAAMK,QAErBE,EAAU,IAAIP,EAAMK,QACpBG,EAAa,IAAIR,EAAMK,QACvBI,EAAc,IAAIT,EAAMK,QACxBK,EAAe,IAAIV,EAAMK,QACzBM,EAAc,IAAIX,EAAMK,QAExBO,EAAgB,IAAIZ,EAAMK,QAC1BQ,EAAiB,IAAIb,EAAMK,QAC3BS,EAAkB,IAAId,EAAMK,QAC5BU,EAAiB,IAAIf,EAAMK,QAE3BW,EAAW,IAAIhB,EAAMK,QACrBY,EAAW,IAAIjB,EAAMK,QACrBa,EAAW,IAAIlB,EAAMK,QAEzB,SAASJ,EAAckB,EAAQC,EAAOC,GAErCC,KAAKH,OAASA,EACdG,KAAKF,MAAQA,EACbE,KAAKC,WAAa,IAAIvB,EAAMK,QAC5BiB,KAAKE,SAAW,IAAIxB,EAAMK,QAC1BiB,KAAKG,cACLH,KAAKD,KAAOA,GAAQK,OAAOC,UAqJ5B,OAjJA1B,EAAa2B,UAAUC,OAAS,SAAWN,EAAYC,GAStD,OAPAF,KAAKC,WAAaA,GAAcD,KAAKC,WACrCD,KAAKE,SAAWA,GAAYF,KAAKE,SACjCF,KAAKG,cAELH,KAAKQ,cAAeR,KAAKC,WAAYD,KAAKE,UAC1CF,KAAKS,qBAAsB7B,EAASoB,KAAKF,OAElCE,KAAKG,YAIbxB,EAAa2B,UAAUE,cAAgB,SAAWP,EAAYC,GAQ7D,GANAD,EAAaA,GAAcD,KAAKC,WAChCC,EAAWA,GAAYF,KAAKE,SAE5BF,KAAKH,OAAOa,yBACZV,KAAKH,OAAOc,oBAEPX,KAAKH,OAAOe,oBAEhB5B,EAAS6B,KAAMZ,GACfjB,EAAS8B,EAAIC,KAAKC,IAAKf,EAAWa,EAAGZ,EAASY,GAC9C9B,EAASiC,EAAIF,KAAKG,IAAKjB,EAAWgB,EAAGf,EAASe,GAC9Cf,EAASY,EAAIC,KAAKG,IAAKjB,EAAWa,EAAGZ,EAASY,GAC9CZ,EAASe,EAAIF,KAAKC,IAAKf,EAAWgB,EAAGf,EAASe,GAE9ChC,EAAQ4B,KAAMb,KAAKH,OAAOsB,UAC1BjC,EAAW2B,KAAM7B,GACjBG,EAAYiC,IAAKlB,EAASY,EAAG9B,EAASiC,EAAG,GACzC7B,EAAayB,KAAMX,GACnBb,EAAY+B,IAAKpC,EAAS8B,EAAGZ,EAASe,EAAG,GAEzC/B,EAAWmC,UAAWrB,KAAKH,QAC3BV,EAAYkC,UAAWrB,KAAKH,QAC5BT,EAAaiC,UAAWrB,KAAKH,QAC7BR,EAAYgC,UAAWrB,KAAKH,QAE5BH,EAASmB,KAAM3B,GAAaoC,IAAKrC,GACjCU,EAASkB,KAAM1B,GAAcmC,IAAKrC,GAClCW,EAASiB,KAAMzB,GAAekC,IAAKrC,GACnCS,EAAS6B,YACT5B,EAAS4B,YACT3B,EAAS2B,YAET7B,EAAS8B,eAAgBxB,KAAKD,MAC9BJ,EAAS6B,eAAgBxB,KAAKD,MAC9BH,EAAS4B,eAAgBxB,KAAKD,MAC9BL,EAAS+B,IAAKxC,GACdU,EAAS8B,IAAKxC,GACdW,EAAS6B,IAAKxC,IAEVyC,EAAS9C,EAAQ8C,QAEb,GAAIC,sBAAuB1C,EAASC,EAAYC,GACxDuC,EAAQ,GAAIC,sBAAuB1C,EAASE,EAAaC,GACzDsC,EAAQ,GAAIC,sBAAuBvC,EAAcC,EAAaJ,GAC9DyC,EAAQ,GAAIC,sBAAuBtC,EAAaH,EAAYD,GAC5DyC,EAAQ,GAAIC,sBAAuBxC,EAAaC,EAAcC,GAC9DqC,EAAQ,GAAIC,sBAAuB/B,EAAUD,EAAUD,GACvDgC,EAAQ,GAAIE,OAAOJ,gBAAkB,QAE/B,GAAKxB,KAAKH,OAAOgC,qBAAuB,CAEzC5B,EAAW6B,OAAQ5B,IAAaA,EAAS6B,UAAW3B,OAAO4B,SAEhE,IAyBIN,EAzBAO,EAAOlB,KAAKC,IAAKf,EAAWa,EAAGZ,EAASY,GACxCoB,EAAMnB,KAAKG,IAAKjB,EAAWgB,EAAGf,EAASe,GACvCkB,EAAQpB,KAAKG,IAAKjB,EAAWa,EAAGZ,EAASY,GACzCsB,EAAOrB,KAAKC,IAAKf,EAAWgB,EAAGf,EAASe,GAE5C/B,EAAWkC,IAAKa,EAAMC,GAAO,GAC7B/C,EAAYiC,IAAKe,EAAOD,GAAO,GAC/B9C,EAAagC,IAAKe,EAAOC,GAAQ,GACjC/C,EAAY+B,IAAKa,EAAMG,GAAQ,GAE/B9C,EAAc8B,IAAKa,EAAMC,EAAK,GAC9B3C,EAAe6B,IAAKe,EAAOD,EAAK,GAChC1C,EAAgB4B,IAAKe,EAAOC,EAAM,GAClC3C,EAAe2B,IAAKa,EAAMG,EAAM,GAEhClD,EAAWmC,UAAWrB,KAAKH,QAC3BV,EAAYkC,UAAWrB,KAAKH,QAC5BT,EAAaiC,UAAWrB,KAAKH,QAC7BR,EAAYgC,UAAWrB,KAAKH,QAE5BP,EAAc+B,UAAWrB,KAAKH,QAC9BN,EAAe8B,UAAWrB,KAAKH,QAC/BL,EAAgB6B,UAAWrB,KAAKH,QAChCJ,EAAe4B,UAAWrB,KAAKH,SAE3B6B,EAAS9C,EAAQ8C,QAEb,GAAIC,sBAAuBzC,EAAYI,EAAeC,GAC9DmC,EAAQ,GAAIC,sBAAuBxC,EAAaI,EAAgBC,GAChEkC,EAAQ,GAAIC,sBAAuBnC,EAAiBC,EAAgBJ,GACpEqC,EAAQ,GAAIC,sBAAuBlC,EAAgBH,EAAeJ,GAClEwC,EAAQ,GAAIC,sBAAuBxC,EAAaC,EAAcC,GAC9DqC,EAAQ,GAAIC,sBAAuBnC,EAAiBD,EAAgBD,GACpEoC,EAAQ,GAAIE,OAAOJ,gBAAkB,QAIrCa,QAAQC,MAAO,iDAMjB3D,EAAa2B,UAAUG,qBAAuB,SAAW7B,EAAS2D,GAsBjE,IApBKA,EAAOC,QAAUD,EAAOE,QAAUF,EAAOG,gBAEpBC,IAApBJ,EAAOK,WAE6B,OAAnCL,EAAOM,SAASC,gBAA0BP,EAAOM,SAASE,wBAE/DjE,EAAO+B,KAAM0B,EAAOM,SAASC,eAAehE,QAE5CA,EAAOkE,aAAcT,EAAOU,aAEvBrE,EAAQsE,cAAepE,IAE3BkB,KAAKG,WAAWgD,KAAMZ,IAQpBA,EAAOa,SAASC,OAAS,EAE7B,IAAM,IAAIvC,EAAI,EAAGA,EAAIyB,EAAOa,SAASC,OAAQvC,IAE5Cd,KAAKS,qBAAsB7B,EAAS2D,EAAOa,SAAUtC,KAQjDnC,EAlLa,GAsLdD,EAAMC","file":"../../interactive/SelectionBox.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author HypnosNova / https://www.threejs.org.cn/gallery\n\t * This is a class to check whether objects are in a selection area in 3D space\n\t */\n\n\tTHREE.SelectionBox = ( function () {\n\n\t\tvar frustum = new THREE.Frustum();\n\t\tvar center = new THREE.Vector3();\n\n\t\tvar tmpPoint = new THREE.Vector3();\n\n\t\tvar vecNear = new THREE.Vector3();\n\t\tvar vecTopLeft = new THREE.Vector3();\n\t\tvar vecTopRight = new THREE.Vector3();\n\t\tvar vecDownRight = new THREE.Vector3();\n\t\tvar vecDownLeft = new THREE.Vector3();\n\n\t\tvar vecFarTopLeft = new THREE.Vector3();\n\t\tvar vecFarTopRight = new THREE.Vector3();\n\t\tvar vecFarDownRight = new THREE.Vector3();\n\t\tvar vecFarDownLeft = new THREE.Vector3();\n\n\t\tvar vectemp1 = new THREE.Vector3();\n\t\tvar vectemp2 = new THREE.Vector3();\n\t\tvar vectemp3 = new THREE.Vector3();\n\n\t\tfunction SelectionBox( camera, scene, deep ) {\n\n\t\t\tthis.camera = camera;\n\t\t\tthis.scene = scene;\n\t\t\tthis.startPoint = new THREE.Vector3();\n\t\t\tthis.endPoint = new THREE.Vector3();\n\t\t\tthis.collection = [];\n\t\t\tthis.deep = deep || Number.MAX_VALUE;\n\n\t\t}\n\n\t\tSelectionBox.prototype.select = function ( startPoint, endPoint ) {\n\n\t\t\tthis.startPoint = startPoint || this.startPoint;\n\t\t\tthis.endPoint = endPoint || this.endPoint;\n\t\t\tthis.collection = [];\n\n\t\t\tthis.updateFrustum( this.startPoint, this.endPoint );\n\t\t\tthis.searchChildInFrustum( frustum, this.scene );\n\n\t\t\treturn this.collection;\n\n\t\t};\n\n\t\tSelectionBox.prototype.updateFrustum = function ( startPoint, endPoint ) {\n\n\t\t\tstartPoint = startPoint || this.startPoint;\n\t\t\tendPoint = endPoint || this.endPoint;\n\n\t\t\tthis.camera.updateProjectionMatrix();\n\t\t\tthis.camera.updateMatrixWorld();\n\n\t\t\tif ( this.camera.isPerspectiveCamera ) {\n\n\t\t\t\ttmpPoint.copy( startPoint );\n\t\t\t\ttmpPoint.x = Math.min( startPoint.x, endPoint.x );\n\t\t\t\ttmpPoint.y = Math.max( startPoint.y, endPoint.y );\n\t\t\t\tendPoint.x = Math.max( startPoint.x, endPoint.x );\n\t\t\t\tendPoint.y = Math.min( startPoint.y, endPoint.y );\n\n\t\t\t\tvecNear.copy( this.camera.position );\n\t\t\t\tvecTopLeft.copy( tmpPoint );\n\t\t\t\tvecTopRight.set( endPoint.x, tmpPoint.y, 0 );\n\t\t\t\tvecDownRight.copy( endPoint );\n\t\t\t\tvecDownLeft.set( tmpPoint.x, endPoint.y, 0 );\n\n\t\t\t\tvecTopLeft.unproject( this.camera );\n\t\t\t\tvecTopRight.unproject( this.camera );\n\t\t\t\tvecDownRight.unproject( this.camera );\n\t\t\t\tvecDownLeft.unproject( this.camera );\n\n\t\t\t\tvectemp1.copy( vecTopLeft ).sub( vecNear );\n\t\t\t\tvectemp2.copy( vecTopRight ).sub( vecNear );\n\t\t\t\tvectemp3.copy( vecDownRight ).sub( vecNear );\n\t\t\t\tvectemp1.normalize();\n\t\t\t\tvectemp2.normalize();\n\t\t\t\tvectemp3.normalize();\n\n\t\t\t\tvectemp1.multiplyScalar( this.deep );\n\t\t\t\tvectemp2.multiplyScalar( this.deep );\n\t\t\t\tvectemp3.multiplyScalar( this.deep );\n\t\t\t\tvectemp1.add( vecNear );\n\t\t\t\tvectemp2.add( vecNear );\n\t\t\t\tvectemp3.add( vecNear );\n\n\t\t\t\tvar planes = frustum.planes;\n\n\t\t\t\tplanes[ 0 ].setFromCoplanarPoints( vecNear, vecTopLeft, vecTopRight );\n\t\t\t\tplanes[ 1 ].setFromCoplanarPoints( vecNear, vecTopRight, vecDownRight );\n\t\t\t\tplanes[ 2 ].setFromCoplanarPoints( vecDownRight, vecDownLeft, vecNear );\n\t\t\t\tplanes[ 3 ].setFromCoplanarPoints( vecDownLeft, vecTopLeft, vecNear );\n\t\t\t\tplanes[ 4 ].setFromCoplanarPoints( vecTopRight, vecDownRight, vecDownLeft );\n\t\t\t\tplanes[ 5 ].setFromCoplanarPoints( vectemp3, vectemp2, vectemp1 );\n\t\t\t\tplanes[ 5 ].normal.multiplyScalar( - 1 );\n\n\t\t\t} else if ( this.camera.isOrthographicCamera ) {\n\n\t\t\t\tif ( startPoint.equals( endPoint ) ) endPoint.addScalar( Number.EPSILON ); // avoid invalid frustum\n\n\t\t\t\tvar left = Math.min( startPoint.x, endPoint.x );\n\t\t\t\tvar top = Math.max( startPoint.y, endPoint.y );\n\t\t\t\tvar right = Math.max( startPoint.x, endPoint.x );\n\t\t\t\tvar down = Math.min( startPoint.y, endPoint.y );\n\n\t\t\t\tvecTopLeft.set( left, top, - 1 );\n\t\t\t\tvecTopRight.set( right, top, - 1 );\n\t\t\t\tvecDownRight.set( right, down, - 1 );\n\t\t\t\tvecDownLeft.set( left, down, - 1 );\n\n\t\t\t\tvecFarTopLeft.set( left, top, 1 );\n\t\t\t\tvecFarTopRight.set( right, top, 1 );\n\t\t\t\tvecFarDownRight.set( right, down, 1 );\n\t\t\t\tvecFarDownLeft.set( left, down, 1 );\n\n\t\t\t\tvecTopLeft.unproject( this.camera );\n\t\t\t\tvecTopRight.unproject( this.camera );\n\t\t\t\tvecDownRight.unproject( this.camera );\n\t\t\t\tvecDownLeft.unproject( this.camera );\n\n\t\t\t\tvecFarTopLeft.unproject( this.camera );\n\t\t\t\tvecFarTopRight.unproject( this.camera );\n\t\t\t\tvecFarDownRight.unproject( this.camera );\n\t\t\t\tvecFarDownLeft.unproject( this.camera );\n\n\t\t\t\tvar planes = frustum.planes;\n\n\t\t\t\tplanes[ 0 ].setFromCoplanarPoints( vecTopLeft, vecFarTopLeft, vecFarTopRight );\n\t\t\t\tplanes[ 1 ].setFromCoplanarPoints( vecTopRight, vecFarTopRight, vecFarDownRight );\n\t\t\t\tplanes[ 2 ].setFromCoplanarPoints( vecFarDownRight, vecFarDownLeft, vecDownLeft );\n\t\t\t\tplanes[ 3 ].setFromCoplanarPoints( vecFarDownLeft, vecFarTopLeft, vecTopLeft );\n\t\t\t\tplanes[ 4 ].setFromCoplanarPoints( vecTopRight, vecDownRight, vecDownLeft );\n\t\t\t\tplanes[ 5 ].setFromCoplanarPoints( vecFarDownRight, vecFarTopRight, vecFarTopLeft );\n\t\t\t\tplanes[ 5 ].normal.multiplyScalar( - 1 );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.SelectionBox: Unsupported camera type.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tSelectionBox.prototype.searchChildInFrustum = function ( frustum, object ) {\n\n\t\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\tif ( object.material !== undefined ) {\n\n\t\t\t\t\tif ( object.geometry.boundingSphere === null ) object.geometry.computeBoundingSphere();\n\n\t\t\t\t\tcenter.copy( object.geometry.boundingSphere.center );\n\n\t\t\t\t\tcenter.applyMatrix4( object.matrixWorld );\n\n\t\t\t\t\tif ( frustum.containsPoint( center ) ) {\n\n\t\t\t\t\t\tthis.collection.push( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( object.children.length > 0 ) {\n\n\t\t\t\tfor ( var x = 0; x < object.children.length; x ++ ) {\n\n\t\t\t\t\tthis.searchChildInFrustum( frustum, object.children[ x ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\treturn SelectionBox;\n\n\t} )();\n\t\n\treturn THREE.SelectionBox;\n});\n"]}