{"version":3,"sources":["interactive/SelectionBox.js"],"names":["define","THREE","frustum","Frustum","center","Vector3","tmpPoint","vecNear","vecTopLeft","vecTopRight","vecDownRight","vecDownLeft","vecFarTopLeft","vecFarTopRight","vecFarDownRight","vecFarDownLeft","vectemp1","vectemp2","vectemp3","SelectionBox","camera","scene","deep","this","startPoint","endPoint","collection","Number","MAX_VALUE","prototype","select","updateFrustum","searchChildInFrustum","updateProjectionMatrix","updateMatrixWorld","isPerspectiveCamera","copy","x","Math","min","y","max","position","set","unproject","sub","normalize","multiplyScalar","add","planes","setFromCoplanarPoints","normal","isOrthographicCamera","equals","addScalar","EPSILON","left","top","right","down","console","error","object","isMesh","isLine","isPoints","undefined","material","geometry","boundingSphere","computeBoundingSphere","applyMatrix4","matrixWorld","containsPoint","push","children","length"],"mappings":"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","file":"../../interactive/SelectionBox.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var SelectionBox = function () {\n        var frustum = new THREE.Frustum();\n        var center = new THREE.Vector3();\n        var tmpPoint = new THREE.Vector3();\n        var vecNear = new THREE.Vector3();\n        var vecTopLeft = new THREE.Vector3();\n        var vecTopRight = new THREE.Vector3();\n        var vecDownRight = new THREE.Vector3();\n        var vecDownLeft = new THREE.Vector3();\n        var vecFarTopLeft = new THREE.Vector3();\n        var vecFarTopRight = new THREE.Vector3();\n        var vecFarDownRight = new THREE.Vector3();\n        var vecFarDownLeft = new THREE.Vector3();\n        var vectemp1 = new THREE.Vector3();\n        var vectemp2 = new THREE.Vector3();\n        var vectemp3 = new THREE.Vector3();\n        function SelectionBox(camera, scene, deep) {\n            this.camera = camera;\n            this.scene = scene;\n            this.startPoint = new THREE.Vector3();\n            this.endPoint = new THREE.Vector3();\n            this.collection = [];\n            this.deep = deep || Number.MAX_VALUE;\n        }\n        SelectionBox.prototype.select = function (startPoint, endPoint) {\n            this.startPoint = startPoint || this.startPoint;\n            this.endPoint = endPoint || this.endPoint;\n            this.collection = [];\n            this.updateFrustum(this.startPoint, this.endPoint);\n            this.searchChildInFrustum(frustum, this.scene);\n            return this.collection;\n        };\n        SelectionBox.prototype.updateFrustum = function (startPoint, endPoint) {\n            startPoint = startPoint || this.startPoint;\n            endPoint = endPoint || this.endPoint;\n            this.camera.updateProjectionMatrix();\n            this.camera.updateMatrixWorld();\n            if (this.camera.isPerspectiveCamera) {\n                tmpPoint.copy(startPoint);\n                tmpPoint.x = Math.min(startPoint.x, endPoint.x);\n                tmpPoint.y = Math.max(startPoint.y, endPoint.y);\n                endPoint.x = Math.max(startPoint.x, endPoint.x);\n                endPoint.y = Math.min(startPoint.y, endPoint.y);\n                vecNear.copy(this.camera.position);\n                vecTopLeft.copy(tmpPoint);\n                vecTopRight.set(endPoint.x, tmpPoint.y, 0);\n                vecDownRight.copy(endPoint);\n                vecDownLeft.set(tmpPoint.x, endPoint.y, 0);\n                vecTopLeft.unproject(this.camera);\n                vecTopRight.unproject(this.camera);\n                vecDownRight.unproject(this.camera);\n                vecDownLeft.unproject(this.camera);\n                vectemp1.copy(vecTopLeft).sub(vecNear);\n                vectemp2.copy(vecTopRight).sub(vecNear);\n                vectemp3.copy(vecDownRight).sub(vecNear);\n                vectemp1.normalize();\n                vectemp2.normalize();\n                vectemp3.normalize();\n                vectemp1.multiplyScalar(this.deep);\n                vectemp2.multiplyScalar(this.deep);\n                vectemp3.multiplyScalar(this.deep);\n                vectemp1.add(vecNear);\n                vectemp2.add(vecNear);\n                vectemp3.add(vecNear);\n                var planes = frustum.planes;\n                planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);\n                planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);\n                planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);\n                planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);\n                planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n                planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);\n                planes[5].normal.multiplyScalar(-1);\n            } else if (this.camera.isOrthographicCamera) {\n                if (startPoint.equals(endPoint))\n                    endPoint.addScalar(Number.EPSILON);\n                var left = Math.min(startPoint.x, endPoint.x);\n                var top = Math.max(startPoint.y, endPoint.y);\n                var right = Math.max(startPoint.x, endPoint.x);\n                var down = Math.min(startPoint.y, endPoint.y);\n                vecTopLeft.set(left, top, -1);\n                vecTopRight.set(right, top, -1);\n                vecDownRight.set(right, down, -1);\n                vecDownLeft.set(left, down, -1);\n                vecFarTopLeft.set(left, top, 1);\n                vecFarTopRight.set(right, top, 1);\n                vecFarDownRight.set(right, down, 1);\n                vecFarDownLeft.set(left, down, 1);\n                vecTopLeft.unproject(this.camera);\n                vecTopRight.unproject(this.camera);\n                vecDownRight.unproject(this.camera);\n                vecDownLeft.unproject(this.camera);\n                vecFarTopLeft.unproject(this.camera);\n                vecFarTopRight.unproject(this.camera);\n                vecFarDownRight.unproject(this.camera);\n                vecFarDownLeft.unproject(this.camera);\n                var planes = frustum.planes;\n                planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);\n                planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);\n                planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);\n                planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);\n                planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n                planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);\n                planes[5].normal.multiplyScalar(-1);\n            } else {\n                console.error('THREE.SelectionBox: Unsupported camera type.');\n            }\n        };\n        SelectionBox.prototype.searchChildInFrustum = function (frustum, object) {\n            if (object.isMesh || object.isLine || object.isPoints) {\n                if (object.material !== undefined) {\n                    if (object.geometry.boundingSphere === null)\n                        object.geometry.computeBoundingSphere();\n                    center.copy(object.geometry.boundingSphere.center);\n                    center.applyMatrix4(object.matrixWorld);\n                    if (frustum.containsPoint(center)) {\n                        this.collection.push(object);\n                    }\n                }\n            }\n            if (object.children.length > 0) {\n                for (var x = 0; x < object.children.length; x++) {\n                    this.searchChildInFrustum(frustum, object.children[x]);\n                }\n            }\n        };\n        return SelectionBox;\n    }();\n\n    return SelectionBox;\n});"]}