{"version":3,"sources":["csm/CSM.js"],"names":["define","THREE","threex","Frustum","Shader","_cameraToLightMatrix","Matrix4","_lightSpaceFrustum","_center","Vector3","_bbox","Box3","_uniformArray","_logArray","csm","CSM","[object Object]","data","this","camera","parent","cascades","maxFar","mode","shadowMapSize","shadowBias","lightDirection","normalize","lightIntensity","lightNear","lightFar","lightMargin","customSplitsCallback","fade","mainFrustum","frustums","breaks","lights","shaders","Map","createLights","updateFrustums","injectInclude","i","light","DirectionalLight","castShadow","shadow","mapSize","width","height","near","far","bias","add","target","push","updateProjectionMatrix","setFromProjectionMatrix","projectionMatrix","split","length","shadowCam","frustum","nearVerts","vertices","farVerts","point1","point2","distanceTo","squaredBBWidth","Math","max","linearDepth","z","pow","left","right","top","bottom","min","uniformSplit","logarithmicSplit","amount","lambda","MathUtils","lerp","practicalSplit","undefined","console","error","texelWidth","texelHeight","updateMatrixWorld","multiplyMatrices","matrixWorldInverse","matrixWorld","toSpace","makeEmpty","j","expandByPoint","getCenter","x","floor","y","applyMatrix4","position","copy","ShaderChunk","lights_fragment_begin","lights_pars_begin","material","defines","USE_CSM","CSM_CASCADES","CSM_FADE","breaksVec2","self","onBeforeCompile","shader","getExtendedBreaks","uniforms","CSM_cascades","value","cameraNear","shadowFar","set","forEach","needsUpdate","Vector2","prev","getBreaks","initCascades","updateShadowBounds","updateUniforms","remove","clear"],"mappings":"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","file":"../../csm/CSM.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\",\r\n    './Frustum',\r\n    './Shader'\r\n], function (\r\n    THREE,\r\n    threex,\r\n    Frustum, \r\n    Shader\r\n) {\r\n    'use strict';\r\n    const _cameraToLightMatrix = new THREE.Matrix4();\r\n    const _lightSpaceFrustum = new Frustum();\r\n    const _center = new THREE.Vector3();\r\n    const _bbox = new THREE.Box3();\r\n    const _uniformArray = [];\r\n    const _logArray = [];\r\n    class CSM {\r\n        constructor(data) {\r\n            data = data || {};\r\n            this.camera = data.camera;\r\n            this.parent = data.parent;\r\n            this.cascades = data.cascades || 3;\r\n            this.maxFar = data.maxFar || 100000;\r\n            this.mode = data.mode || 'practical';\r\n            this.shadowMapSize = data.shadowMapSize || 2048;\r\n            this.shadowBias = data.shadowBias || 0.000001;\r\n            this.lightDirection = data.lightDirection || new THREE.Vector3(1, -1, 1).normalize();\r\n            this.lightIntensity = data.lightIntensity || 1;\r\n            this.lightNear = data.lightNear || 1;\r\n            this.lightFar = data.lightFar || 2000;\r\n            this.lightMargin = data.lightMargin || 200;\r\n            this.customSplitsCallback = data.customSplitsCallback;\r\n            this.fade = false;\r\n            this.mainFrustum = new Frustum();\r\n            this.frustums = [];\r\n            this.breaks = [];\r\n            this.lights = [];\r\n            this.shaders = new Map();\r\n            this.createLights();\r\n            this.updateFrustums();\r\n            this.injectInclude();\r\n        }\r\n        createLights() {\r\n            for (let i = 0; i < this.cascades; i++) {\r\n                const light = new THREE.DirectionalLight(16777215, this.lightIntensity);\r\n                light.castShadow = true;\r\n                light.shadow.mapSize.width = this.shadowMapSize;\r\n                light.shadow.mapSize.height = this.shadowMapSize;\r\n                light.shadow.camera.near = this.lightNear;\r\n                light.shadow.camera.far = this.lightFar;\r\n                light.shadow.bias = this.shadowBias;\r\n                this.parent.add(light);\r\n                this.parent.add(light.target);\r\n                this.lights.push(light);\r\n            }\r\n        }\r\n        initCascades() {\r\n            const camera = this.camera;\r\n            camera.updateProjectionMatrix();\r\n            this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar);\r\n            this.mainFrustum.split(this.breaks, this.frustums);\r\n        }\r\n        updateShadowBounds() {\r\n            const frustums = this.frustums;\r\n            for (let i = 0; i < frustums.length; i++) {\r\n                const light = this.lights[i];\r\n                const shadowCam = light.shadow.camera;\r\n                const frustum = this.frustums[i];\r\n                const nearVerts = frustum.vertices.near;\r\n                const farVerts = frustum.vertices.far;\r\n                const point1 = farVerts[0];\r\n                let point2;\r\n                if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {\r\n                    point2 = farVerts[2];\r\n                } else {\r\n                    point2 = nearVerts[2];\r\n                }\r\n                let squaredBBWidth = point1.distanceTo(point2);\r\n                if (this.fade) {\r\n                    const camera = this.camera;\r\n                    const far = Math.max(camera.far, this.maxFar);\r\n                    const linearDepth = frustum.vertices.far[0].z / (far - camera.near);\r\n                    const margin = 0.25 * Math.pow(linearDepth, 2) * (far - camera.near);\r\n                    squaredBBWidth += margin;\r\n                }\r\n                shadowCam.left = -squaredBBWidth / 2;\r\n                shadowCam.right = squaredBBWidth / 2;\r\n                shadowCam.top = squaredBBWidth / 2;\r\n                shadowCam.bottom = -squaredBBWidth / 2;\r\n                shadowCam.updateProjectionMatrix();\r\n            }\r\n        }\r\n        getBreaks() {\r\n            const camera = this.camera;\r\n            const far = Math.min(camera.far, this.maxFar);\r\n            this.breaks.length = 0;\r\n            switch (this.mode) {\r\n            case 'uniform':\r\n                uniformSplit(this.cascades, camera.near, far, this.breaks);\r\n                break;\r\n            case 'logarithmic':\r\n                logarithmicSplit(this.cascades, camera.near, far, this.breaks);\r\n                break;\r\n            case 'practical':\r\n                practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks);\r\n                break;\r\n            case 'custom':\r\n                if (this.customSplitsCallback === undefined)\r\n                    console.error('CSM: Custom split scheme callback not defined.');\r\n                this.customSplitsCallback(this.cascades, camera.near, far, this.breaks);\r\n                break;\r\n            }\r\n            function uniformSplit(amount, near, far, target) {\r\n                for (let i = 1; i < amount; i++) {\r\n                    target.push((near + (far - near) * i / amount) / far);\r\n                }\r\n                target.push(1);\r\n            }\r\n            function logarithmicSplit(amount, near, far, target) {\r\n                for (let i = 1; i < amount; i++) {\r\n                    target.push(near * (far / near) ** (i / amount) / far);\r\n                }\r\n                target.push(1);\r\n            }\r\n            function practicalSplit(amount, near, far, lambda, target) {\r\n                _uniformArray.length = 0;\r\n                _logArray.length = 0;\r\n                logarithmicSplit(amount, near, far, _logArray);\r\n                uniformSplit(amount, near, far, _uniformArray);\r\n                for (let i = 1; i < amount; i++) {\r\n                    target.push(THREE.MathUtils.lerp(_uniformArray[i - 1], _logArray[i - 1], lambda));\r\n                }\r\n                target.push(1);\r\n            }\r\n        }\r\n        update() {\r\n            const camera = this.camera;\r\n            const frustums = this.frustums;\r\n            for (let i = 0; i < frustums.length; i++) {\r\n                const light = this.lights[i];\r\n                const shadowCam = light.shadow.camera;\r\n                const texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;\r\n                const texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;\r\n                light.shadow.camera.updateMatrixWorld(true);\r\n                _cameraToLightMatrix.multiplyMatrices(light.shadow.camera.matrixWorldInverse, camera.matrixWorld);\r\n                frustums[i].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);\r\n                const nearVerts = _lightSpaceFrustum.vertices.near;\r\n                const farVerts = _lightSpaceFrustum.vertices.far;\r\n                _bbox.makeEmpty();\r\n                for (let j = 0; j < 4; j++) {\r\n                    _bbox.expandByPoint(nearVerts[j]);\r\n                    _bbox.expandByPoint(farVerts[j]);\r\n                }\r\n                _bbox.getCenter(_center);\r\n                _center.z = _bbox.max.z + this.lightMargin;\r\n                _center.x = Math.floor(_center.x / texelWidth) * texelWidth;\r\n                _center.y = Math.floor(_center.y / texelHeight) * texelHeight;\r\n                _center.applyMatrix4(light.shadow.camera.matrixWorld);\r\n                light.position.copy(_center);\r\n                light.target.position.copy(_center);\r\n                light.target.position.x += this.lightDirection.x;\r\n                light.target.position.y += this.lightDirection.y;\r\n                light.target.position.z += this.lightDirection.z;\r\n            }\r\n        }\r\n        injectInclude() {\r\n            THREE.ShaderChunk.lights_fragment_begin = Shader.lights_fragment_begin;\r\n            THREE.ShaderChunk.lights_pars_begin = Shader.lights_pars_begin;\r\n        }\r\n        setupMaterial(material) {\r\n            material.defines = material.defines || {};\r\n            material.defines.USE_CSM = 1;\r\n            material.defines.CSM_CASCADES = this.cascades;\r\n            if (this.fade) {\r\n                material.defines.CSM_FADE = '';\r\n            }\r\n            const breaksVec2 = [];\r\n            const self = this;\r\n            const shaders = this.shaders;\r\n            material.onBeforeCompile = function (shader) {\r\n                const far = Math.min(self.camera.far, self.maxFar);\r\n                self.getExtendedBreaks(breaksVec2);\r\n                shader.uniforms.CSM_cascades = { value: breaksVec2 };\r\n                shader.uniforms.cameraNear = { value: self.camera.near };\r\n                shader.uniforms.shadowFar = { value: far };\r\n                shaders.set(material, shader);\r\n            };\r\n            shaders.set(material, null);\r\n        }\r\n        updateUniforms() {\r\n            const far = Math.min(this.camera.far, this.maxFar);\r\n            const shaders = this.shaders;\r\n            shaders.forEach(function (shader, material) {\r\n                if (shader !== null) {\r\n                    const uniforms = shader.uniforms;\r\n                    this.getExtendedBreaks(uniforms.CSM_cascades.value);\r\n                    uniforms.cameraNear.value = this.camera.near;\r\n                    uniforms.shadowFar.value = far;\r\n                }\r\n                if (!this.fade && 'CSM_FADE' in material.defines) {\r\n                    delete material.defines.CSM_FADE;\r\n                    material.needsUpdate = true;\r\n                } else if (this.fade && !('CSM_FADE' in material.defines)) {\r\n                    material.defines.CSM_FADE = '';\r\n                    material.needsUpdate = true;\r\n                }\r\n            }, this);\r\n        }\r\n        getExtendedBreaks(target) {\r\n            while (target.length < this.breaks.length) {\r\n                target.push(new THREE.Vector2());\r\n            }\r\n            target.length = this.breaks.length;\r\n            for (let i = 0; i < this.cascades; i++) {\r\n                let amount = this.breaks[i];\r\n                let prev = this.breaks[i - 1] || 0;\r\n                target[i].x = prev;\r\n                target[i].y = amount;\r\n            }\r\n        }\r\n        updateFrustums() {\r\n            this.getBreaks();\r\n            this.initCascades();\r\n            this.updateShadowBounds();\r\n            this.updateUniforms();\r\n        }\r\n        remove() {\r\n            for (let i = 0; i < this.lights.length; i++) {\r\n                this.parent.remove(this.lights[i]);\r\n            }\r\n        }\r\n        dispose() {\r\n            const shaders = this.shaders;\r\n            shaders.forEach(function (shader, material) {\r\n                delete material.onBeforeCompile;\r\n                delete material.defines.USE_CSM;\r\n                delete material.defines.CSM_CASCADES;\r\n                delete material.defines.CSM_FADE;\r\n                if (shader !== null) {\r\n                    delete shader.uniforms.CSM_cascades;\r\n                    delete shader.uniforms.cameraNear;\r\n                    delete shader.uniforms.shadowFar;\r\n                }\r\n                material.needsUpdate = true;\r\n            });\r\n            shaders.clear();\r\n        }\r\n    }\r\n    return threex.csm.CSM = CSM;\r\n});"]}