{"version":3,"sources":["csm/Frustum.js"],"names":["define","THREE","inverseProjectionMatrix","Matrix4","Frustum","[object Object]","data","this","vertices","near","Vector3","far","undefined","projectionMatrix","setFromProjectionMatrix","maxFar","isOrthographic","elements","getInverse","set","forEach","v","applyMatrix4","absZ","Math","abs","z","min","multiplyScalar","breaks","target","length","push","i","cascade","j","copy","lerpVectors","cameraMatrix"],"mappings":";;;;;;;AAAAA,QAAQ,mBAAoB,SAAUC,GAClC,aACA,MAAMC,EAA0B,IAAID,EAAME,QAC1C,aAAaC,EACTC,YAAYC,GACRA,EAAOA,MACPC,KAAKC,UACDC,MACI,IAAIR,EAAMS,QACV,IAAIT,EAAMS,QACV,IAAIT,EAAMS,QACV,IAAIT,EAAMS,SAEdC,KACI,IAAIV,EAAMS,QACV,IAAIT,EAAMS,QACV,IAAIT,EAAMS,QACV,IAAIT,EAAMS,eAGYE,IAA1BN,EAAKO,kBACLN,KAAKO,wBAAwBR,EAAKO,iBAAkBP,EAAKS,QAAU,KAG3EV,wBAAwBQ,EAAkBE,GACtC,MAAMC,EAA0D,IAAzCH,EAAiBI,SAAS,IAsBjD,OArBAf,EAAwBgB,WAAWL,GACnCN,KAAKC,SAASC,KAAK,GAAGU,IAAI,EAAG,GAAI,GACjCZ,KAAKC,SAASC,KAAK,GAAGU,IAAI,GAAI,GAAI,GAClCZ,KAAKC,SAASC,KAAK,GAAGU,KAAK,GAAI,GAAI,GACnCZ,KAAKC,SAASC,KAAK,GAAGU,KAAK,EAAG,GAAI,GAClCZ,KAAKC,SAASC,KAAKW,QAAQ,SAAUC,GACjCA,EAAEC,aAAapB,KAEnBK,KAAKC,SAASG,IAAI,GAAGQ,IAAI,EAAG,EAAG,GAC/BZ,KAAKC,SAASG,IAAI,GAAGQ,IAAI,GAAI,EAAG,GAChCZ,KAAKC,SAASG,IAAI,GAAGQ,KAAK,GAAI,EAAG,GACjCZ,KAAKC,SAASG,IAAI,GAAGQ,KAAK,EAAG,EAAG,GAChCZ,KAAKC,SAASG,IAAIS,QAAQ,SAAUC,GAChCA,EAAEC,aAAapB,GACf,MAAMqB,EAAOC,KAAKC,IAAIJ,EAAEK,GACpBV,EACAK,EAAEK,GAAKF,KAAKG,IAAIZ,EAASQ,EAAM,GAE/BF,EAAEO,eAAeJ,KAAKG,IAAIZ,EAASQ,EAAM,MAG1ChB,KAAKC,SAEhBH,MAAMwB,EAAQC,GACV,KAAOD,EAAOE,OAASD,EAAOC,QAC1BD,EAAOE,KAAK,IAAI5B,GAEpB0B,EAAOC,OAASF,EAAOE,OACvB,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAOE,OAAQE,IAAK,CACpC,MAAMC,EAAUJ,EAAOG,GACvB,GAAU,IAANA,EACA,IAAK,IAAIE,EAAI,EAAGA,EAAI,EAAGA,IACnBD,EAAQ1B,SAASC,KAAK0B,GAAGC,KAAK7B,KAAKC,SAASC,KAAK0B,SAGrD,IAAK,IAAIA,EAAI,EAAGA,EAAI,EAAGA,IACnBD,EAAQ1B,SAASC,KAAK0B,GAAGE,YAAY9B,KAAKC,SAASC,KAAK0B,GAAI5B,KAAKC,SAASG,IAAIwB,GAAIN,EAAOI,EAAI,IAGrG,GAAIA,IAAMJ,EAAS,EACf,IAAK,IAAIM,EAAI,EAAGA,EAAI,EAAGA,IACnBD,EAAQ1B,SAASG,IAAIwB,GAAGC,KAAK7B,KAAKC,SAASG,IAAIwB,SAGnD,IAAK,IAAIA,EAAI,EAAGA,EAAI,EAAGA,IACnBD,EAAQ1B,SAASG,IAAIwB,GAAGE,YAAY9B,KAAKC,SAASC,KAAK0B,GAAI5B,KAAKC,SAASG,IAAIwB,GAAIN,EAAOI,KAKxG5B,QAAQiC,EAAcR,GAClB,IAAK,IAAIG,EAAI,EAAGA,EAAI,EAAGA,IACnBH,EAAOtB,SAASC,KAAKwB,GAAGG,KAAK7B,KAAKC,SAASC,KAAKwB,IAAIX,aAAagB,GACjER,EAAOtB,SAASG,IAAIsB,GAAGG,KAAK7B,KAAKC,SAASG,IAAIsB,IAAIX,aAAagB","file":"../../csm/Frustum.js","sourcesContent":["define([\"skylark-threejs\"], function (THREE) {\n    'use strict';\n    const inverseProjectionMatrix = new THREE.Matrix4();\n    return class Frustum {\n        constructor(data) {\n            data = data || {};\n            this.vertices = {\n                near: [\n                    new THREE.Vector3(),\n                    new THREE.Vector3(),\n                    new THREE.Vector3(),\n                    new THREE.Vector3()\n                ],\n                far: [\n                    new THREE.Vector3(),\n                    new THREE.Vector3(),\n                    new THREE.Vector3(),\n                    new THREE.Vector3()\n                ]\n            };\n            if (data.projectionMatrix !== undefined) {\n                this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 10000);\n            }\n        }\n        setFromProjectionMatrix(projectionMatrix, maxFar) {\n            const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\n            inverseProjectionMatrix.getInverse(projectionMatrix);\n            this.vertices.near[0].set(1, 1, -1);\n            this.vertices.near[1].set(1, -1, -1);\n            this.vertices.near[2].set(-1, -1, -1);\n            this.vertices.near[3].set(-1, 1, -1);\n            this.vertices.near.forEach(function (v) {\n                v.applyMatrix4(inverseProjectionMatrix);\n            });\n            this.vertices.far[0].set(1, 1, 1);\n            this.vertices.far[1].set(1, -1, 1);\n            this.vertices.far[2].set(-1, -1, 1);\n            this.vertices.far[3].set(-1, 1, 1);\n            this.vertices.far.forEach(function (v) {\n                v.applyMatrix4(inverseProjectionMatrix);\n                const absZ = Math.abs(v.z);\n                if (isOrthographic) {\n                    v.z *= Math.min(maxFar / absZ, 1);\n                } else {\n                    v.multiplyScalar(Math.min(maxFar / absZ, 1));\n                }\n            });\n            return this.vertices;\n        }\n        split(breaks, target) {\n            while (breaks.length > target.length) {\n                target.push(new Frustum());\n            }\n            target.length = breaks.length;\n            for (let i = 0; i < breaks.length; i++) {\n                const cascade = target[i];\n                if (i === 0) {\n                    for (let j = 0; j < 4; j++) {\n                        cascade.vertices.near[j].copy(this.vertices.near[j]);\n                    }\n                } else {\n                    for (let j = 0; j < 4; j++) {\n                        cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1]);\n                    }\n                }\n                if (i === breaks - 1) {\n                    for (let j = 0; j < 4; j++) {\n                        cascade.vertices.far[j].copy(this.vertices.far[j]);\n                    }\n                } else {\n                    for (let j = 0; j < 4; j++) {\n                        cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i]);\n                    }\n                }\n            }\n        }\n        toSpace(cameraMatrix, target) {\n            for (var i = 0; i < 4; i++) {\n                target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\n                target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\n            }\n        }\n    };\n});"]}