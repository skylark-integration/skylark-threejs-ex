{"version":3,"sources":["csm/Frustum.js"],"names":["define","THREE","threex","inverseProjectionMatrix","Matrix4","Frustum","[object Object]","data","this","vertices","near","Vector3","far","undefined","projectionMatrix","setFromProjectionMatrix","maxFar","isOrthographic","elements","getInverse","set","forEach","v","applyMatrix4","absZ","Math","abs","z","min","multiplyScalar","breaks","target","length","push","i","cascade","j","copy","lerpVectors","cameraMatrix","csm"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,MAAMC,EAA0B,IAAIF,EAAMG,cACpCC,EACFC,YAAYC,GACRA,EAAOA,MACPC,KAAKC,UACDC,MACI,IAAIT,EAAMU,QACV,IAAIV,EAAMU,QACV,IAAIV,EAAMU,QACV,IAAIV,EAAMU,SAEdC,KACI,IAAIX,EAAMU,QACV,IAAIV,EAAMU,QACV,IAAIV,EAAMU,QACV,IAAIV,EAAMU,eAGYE,IAA1BN,EAAKO,kBACLN,KAAKO,wBAAwBR,EAAKO,iBAAkBP,EAAKS,QAAU,KAG3EV,wBAAwBQ,EAAkBE,GACtC,MAAMC,EAA0D,IAAzCH,EAAiBI,SAAS,IAsBjD,OArBAf,EAAwBgB,WAAWL,GACnCN,KAAKC,SAASC,KAAK,GAAGU,IAAI,EAAG,GAAI,GACjCZ,KAAKC,SAASC,KAAK,GAAGU,IAAI,GAAI,GAAI,GAClCZ,KAAKC,SAASC,KAAK,GAAGU,KAAK,GAAI,GAAI,GACnCZ,KAAKC,SAASC,KAAK,GAAGU,KAAK,EAAG,GAAI,GAClCZ,KAAKC,SAASC,KAAKW,QAAQ,SAAUC,GACjCA,EAAEC,aAAapB,KAEnBK,KAAKC,SAASG,IAAI,GAAGQ,IAAI,EAAG,EAAG,GAC/BZ,KAAKC,SAASG,IAAI,GAAGQ,IAAI,GAAI,EAAG,GAChCZ,KAAKC,SAASG,IAAI,GAAGQ,KAAK,GAAI,EAAG,GACjCZ,KAAKC,SAASG,IAAI,GAAGQ,KAAK,EAAG,EAAG,GAChCZ,KAAKC,SAASG,IAAIS,QAAQ,SAAUC,GAChCA,EAAEC,aAAapB,GACf,MAAMqB,EAAOC,KAAKC,IAAIJ,EAAEK,GACpBV,EACAK,EAAEK,GAAKF,KAAKG,IAAIZ,EAASQ,EAAM,GAE/BF,EAAEO,eAAeJ,KAAKG,IAAIZ,EAASQ,EAAM,MAG1ChB,KAAKC,SAEhBH,MAAMwB,EAAQC,GACV,KAAOD,EAAOE,OAASD,EAAOC,QAC1BD,EAAOE,KAAK,IAAI5B,GAEpB0B,EAAOC,OAASF,EAAOE,OACvB,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAOE,OAAQE,IAAK,CACpC,MAAMC,EAAUJ,EAAOG,GACvB,GAAU,IAANA,EACA,IAAK,IAAIE,EAAI,EAAGA,EAAI,EAAGA,IACnBD,EAAQ1B,SAASC,KAAK0B,GAAGC,KAAK7B,KAAKC,SAASC,KAAK0B,SAGrD,IAAK,IAAIA,EAAI,EAAGA,EAAI,EAAGA,IACnBD,EAAQ1B,SAASC,KAAK0B,GAAGE,YAAY9B,KAAKC,SAASC,KAAK0B,GAAI5B,KAAKC,SAASG,IAAIwB,GAAIN,EAAOI,EAAI,IAGrG,GAAIA,IAAMJ,EAAS,EACf,IAAK,IAAIM,EAAI,EAAGA,EAAI,EAAGA,IACnBD,EAAQ1B,SAASG,IAAIwB,GAAGC,KAAK7B,KAAKC,SAASG,IAAIwB,SAGnD,IAAK,IAAIA,EAAI,EAAGA,EAAI,EAAGA,IACnBD,EAAQ1B,SAASG,IAAIwB,GAAGE,YAAY9B,KAAKC,SAASC,KAAK0B,GAAI5B,KAAKC,SAASG,IAAIwB,GAAIN,EAAOI,KAKxG5B,QAAQiC,EAAcR,GAClB,IAAK,IAAIG,EAAI,EAAGA,EAAI,EAAGA,IACnBH,EAAOtB,SAASC,KAAKwB,GAAGG,KAAK7B,KAAKC,SAASC,KAAKwB,IAAIX,aAAagB,GACjER,EAAOtB,SAASG,IAAIsB,GAAGG,KAAK7B,KAAKC,SAASG,IAAIsB,IAAIX,aAAagB,IAK3E,OAAOrC,EAAOsC,IAAInC,QAAUA","file":"../../csm/Frustum.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    const inverseProjectionMatrix = new THREE.Matrix4();\r\n    class Frustum {\r\n        constructor(data) {\r\n            data = data || {};\r\n            this.vertices = {\r\n                near: [\r\n                    new THREE.Vector3(),\r\n                    new THREE.Vector3(),\r\n                    new THREE.Vector3(),\r\n                    new THREE.Vector3()\r\n                ],\r\n                far: [\r\n                    new THREE.Vector3(),\r\n                    new THREE.Vector3(),\r\n                    new THREE.Vector3(),\r\n                    new THREE.Vector3()\r\n                ]\r\n            };\r\n            if (data.projectionMatrix !== undefined) {\r\n                this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 10000);\r\n            }\r\n        }\r\n        setFromProjectionMatrix(projectionMatrix, maxFar) {\r\n            const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\r\n            inverseProjectionMatrix.getInverse(projectionMatrix);\r\n            this.vertices.near[0].set(1, 1, -1);\r\n            this.vertices.near[1].set(1, -1, -1);\r\n            this.vertices.near[2].set(-1, -1, -1);\r\n            this.vertices.near[3].set(-1, 1, -1);\r\n            this.vertices.near.forEach(function (v) {\r\n                v.applyMatrix4(inverseProjectionMatrix);\r\n            });\r\n            this.vertices.far[0].set(1, 1, 1);\r\n            this.vertices.far[1].set(1, -1, 1);\r\n            this.vertices.far[2].set(-1, -1, 1);\r\n            this.vertices.far[3].set(-1, 1, 1);\r\n            this.vertices.far.forEach(function (v) {\r\n                v.applyMatrix4(inverseProjectionMatrix);\r\n                const absZ = Math.abs(v.z);\r\n                if (isOrthographic) {\r\n                    v.z *= Math.min(maxFar / absZ, 1);\r\n                } else {\r\n                    v.multiplyScalar(Math.min(maxFar / absZ, 1));\r\n                }\r\n            });\r\n            return this.vertices;\r\n        }\r\n        split(breaks, target) {\r\n            while (breaks.length > target.length) {\r\n                target.push(new Frustum());\r\n            }\r\n            target.length = breaks.length;\r\n            for (let i = 0; i < breaks.length; i++) {\r\n                const cascade = target[i];\r\n                if (i === 0) {\r\n                    for (let j = 0; j < 4; j++) {\r\n                        cascade.vertices.near[j].copy(this.vertices.near[j]);\r\n                    }\r\n                } else {\r\n                    for (let j = 0; j < 4; j++) {\r\n                        cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1]);\r\n                    }\r\n                }\r\n                if (i === breaks - 1) {\r\n                    for (let j = 0; j < 4; j++) {\r\n                        cascade.vertices.far[j].copy(this.vertices.far[j]);\r\n                    }\r\n                } else {\r\n                    for (let j = 0; j < 4; j++) {\r\n                        cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        toSpace(cameraMatrix, target) {\r\n            for (var i = 0; i < 4; i++) {\r\n                target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\r\n                target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\r\n            }\r\n        }\r\n    };\r\n\r\n    return threex.csm.Frustum = Frustum;\r\n});"]}