{"version":3,"sources":["loaders/AssimpLoader.js"],"names":["define","THREE","AssimpLoader","manager","Loader","call","this","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","setResponseType","buffer","parse","textureLoader","TextureLoader","resourcePath","setCrossOrigin","crossOrigin","Virtulous","KeyFrame","time","matrix","clone","position","Vector3","quaternion","Quaternion","scale","decompose","lerp","nextKey","l","l2","keypos","keyrot","key2pos","key2rot","tempAniPos","x","y","z","tempAniQuat","set","w","slerp","tempAniMatrix","compose","tempAniScale","Matrix4","KeyFrameTrack","keys","target","length","_accelTable","fps","addKey","key","push","init","sortKeys","j","i","parseFromThree","data","node","track","hierarchy","targets","parseFromCollada","sort","keySortFunc","a","b","t","reTarget","root","compareitor","TrackTargetNodeNameCompare","keySearchAccel","Math","floor","setTime","abs","key0","key1","matrixAutoUpdate","copy","matrixWorldNeedsUpdate","find","name","children","r","Animation","tracks","addTrack","max","n","ASSBIN_CHUNK_AICAMERA","ASSBIN_CHUNK_AILIGHT","ASSBIN_CHUNK_AITEXTURE","ASSBIN_CHUNK_AIMESH","ASSBIN_CHUNK_AINODEANIM","ASSBIN_CHUNK_AISCENE","ASSBIN_CHUNK_AIBONE","ASSBIN_CHUNK_AIANIMATION","ASSBIN_CHUNK_AINODE","ASSBIN_CHUNK_AIMATERIAL","ASSBIN_CHUNK_AIMATERIALPROPERTY","ASSBIN_MESH_HAS_POSITIONS","ASSBIN_MESH_HAS_NORMALS","ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS","ASSBIN_MESH_HAS_TEXCOORD_BASE","ASSBIN_MESH_HAS_COLOR_BASE","AI_MAX_NUMBER_OF_COLOR_SETS","AI_MAX_NUMBER_OF_TEXTURECOORDS","aiLightSource_DIRECTIONAL","aiLightSource_SPOT","aiTextureType_DIFFUSE","aiTextureType_NORMALS","aiTextureType_OPACITY","aiTextureType_LIGHTMAP","BONESPERVERT","ASSBIN_MESH_HAS_TEXCOORD","ASSBIN_MESH_HAS_COLOR","cloneTreeToBones","scene","rootBone","Bone","matrixWorld","nodeCount","toString","nodeToBoneMap","child","add","sortWeights","indexes","weights","pairs","sum","sqrt","findMatchingBone","indexOf","ret","aiMesh","mPrimitiveTypes","mNumVertices","mNumFaces","mNumBones","mMaterialIndex","mVertices","mNormals","mTangents","mBitangents","mColors","mTextureCoords","mFaces","mBones","hookupSkeletons","allBones","offsetMatrix","skeletonRoot","findNode","mName","mParent","isBone","threeSkeletonRootBone","toTHREE","threeNode","bone","tbone","mOffsetMatrix","skeleton","Skeleton","bind","material","skinning","mat","mesh","geometry","BufferGeometry","mMaterials","MeshLambertMaterial","setIndex","BufferAttribute","Uint32Array","mIndexArray","setAttribute","mVertexBuffer","mNormalBuffer","mColorBuffer","mTexCoordsBuffers","Float32Array","mTangentBuffer","mBitangentBuffer","bones","mWeights","weight","mVertexId","mWeight","parseInt","_weights","_bones","Mesh","SkinnedMesh","normalizeSkinWeights","aiFace","mNumIndices","mIndices","aiString","str","forEach","String","fromCharCode","replace","aiNode","mTransformation","mNumChildren","mNumMeshes","mMeshes","mChildren","o","Object3D","aiBone","mNumWeights","aiMaterialProperty","mKey","mSemantic","mIndex","mData","mDataLength","mType","dataAsColor","array","Uint8Array","reader","DataView","getFloat32","g","Color","dataAsFloat","dataAsBool","dataAsString","s","dataAsMap","substr","lastIndexOf","namePropMapping","?mat.name","$mat.shadingm","$mat.twosided","$mat.wireframe","$clr.ambient","$clr.diffuse","$clr.specular","$clr.emissive","$clr.transparent","$clr.reflective","$mat.shininess","$mat.reflectivity","$mat.refracti","$tex.file","nameTypeMapping","aiMaterial","mNumAllocated","mNumProperties","mProperties","MeshPhongMaterial","prop","map","normalMap","lightMap","alphaMap","ambient","color","veclerp","v1","v2","v","lm1","quatlerp","q1","q2","sampleTrack","lne","mValue","dist","Infinity","timeDist","mTime","dT","aiNodeAnim","mNodeName","mNumPositionKeys","mNumRotationKeys","mNumScalingKeys","mPositionKeys","mRotationKeys","mScalingKeys","mPreState","mPostState","tps","comp","getLength","apply","pos","rotation","t2","aiAnimation","mDuration","mTicksPerSecond","mNumChannels","mChannels","animationHandle","e","aiTexture","mWidth","mHeight","texAchFormatHint","pcData","aiLight","mAttenuationConstant","mAttenuationLinear","mAttenuationQuadratic","mAngleInnerCone","mAngleOuterCone","mColorDiffuse","mColorSpecular","mColorAmbient","aiCamera","mPosition","mLookAt","mUp","mHorizontalFOV","mClipPlaneNear","mClipPlaneFar","mAspect","littleEndian","readFloat","dataview","val","readOffset","Read_double","getFloat64","Read_uint16_t","getUint16","Read_unsigned_int","getUint32","Read_uint32_t","Read_aiVector3D","stream","Read_aiColor3D","c","Read_aiQuaternion","Read_aiString","stringlengthbytes","ReadBytes","Read_aiVertexWeight","Read_aiMatrix4x4","m","elements","i2","Read_aiVectorKey","Read_aiQuatKey","ReadArray_aiVectorKey","size","ReadBounds","T","Seek","sizeof","aiOrigin_CUR","ai_assert","bool","ReadBinaryBone","shortened","ReadArray_aiVertexWeight","ReadBinaryMesh","mNumUVComponents","subArray32","uv","f","Error","ReadBinaryMaterialProperty","ReadBinaryMaterial","ReadBinaryNodeAnim","nd","ReadArray_aiQuatKey","ReadBinaryAnim","anim","ReadBinaryTexture","tex","achFormatHint","ReadBinaryLight","ReadBinaryCamera","cam","ReadBinaryScene","mFlags","mNumMaterials","mNumAnimations","mNumTextures","mNumLights","mNumCameras","mRootNode","ReadBinaryNode","parent","depth","mDepth","node2","mAnimations","mTextures","mLights","mCameras","compressed","aiOrigin_BEG","pFiledata","pScene","versionMajor","versionMinor","versionRevision","compileFlags","k","boneNode","markBones","object","animation","off","ori","buff","bytes","getUint8","start","end","newbuff","slice","subArrayUint16","Uint16Array","subArrayUint8","subArrayUint32","extendStream","uncompressedSize","compressedSize","FileSize","Tell","compressedData","Read","uncompressedData","uncompress","ArrayBuffer","InternReadFile"],"mappings":"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","file":"../../loaders/AssimpLoader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Virtulous / https://virtulo.us/\n\t */\n\n\tTHREE.AssimpLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.AssimpLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.AssimpLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( scope.path === '' ) ? THREE.LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tonLoad( scope.parse( buffer, path ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( buffer, path ) {\n\n\t\t\tvar textureLoader = new THREE.TextureLoader( this.manager );\n\t\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\tvar Virtulous = {};\n\n\t\t\tVirtulous.KeyFrame = function ( time, matrix ) {\n\n\t\t\t\tthis.time = time;\n\t\t\t\tthis.matrix = matrix.clone();\n\t\t\t\tthis.position = new THREE.Vector3();\n\t\t\t\tthis.quaternion = new THREE.Quaternion();\n\t\t\t\tthis.scale = new THREE.Vector3( 1, 1, 1 );\n\t\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\t\t\t\tthis.clone = function () {\n\n\t\t\t\t\tvar n = new Virtulous.KeyFrame( this.time, this.matrix );\n\t\t\t\t\treturn n;\n\n\t\t\t\t};\n\t\t\t\tthis.lerp = function ( nextKey, time ) {\n\n\t\t\t\t\ttime -= this.time;\n\t\t\t\t\tvar dist = ( nextKey.time - this.time );\n\t\t\t\t\tvar l = time / dist;\n\t\t\t\t\tvar l2 = 1 - l;\n\t\t\t\t\tvar keypos = this.position;\n\t\t\t\t\tvar keyrot = this.quaternion;\n\t\t\t\t\t//      var keyscl =  key.parentspaceScl || key.scl;\n\t\t\t\t\tvar key2pos = nextKey.position;\n\t\t\t\t\tvar key2rot = nextKey.quaternion;\n\t\t\t\t\t//  var key2scl =  key2.parentspaceScl || key2.scl;\n\t\t\t\t\tVirtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n\t\t\t\t\tVirtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n\t\t\t\t\tVirtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;\n\t\t\t\t\t//     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\n\t\t\t\t\t//     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\n\t\t\t\t\t//     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\n\t\t\t\t\tVirtulous.KeyFrame.tempAniQuat.set( keyrot.x, keyrot.y, keyrot.z, keyrot.w );\n\t\t\t\t\tVirtulous.KeyFrame.tempAniQuat.slerp( key2rot, l );\n\t\t\t\t\treturn Virtulous.KeyFrame.tempAniMatrix.compose( Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale );\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t\tVirtulous.KeyFrame.tempAniPos = new THREE.Vector3();\n\t\t\tVirtulous.KeyFrame.tempAniQuat = new THREE.Quaternion();\n\t\t\tVirtulous.KeyFrame.tempAniScale = new THREE.Vector3( 1, 1, 1 );\n\t\t\tVirtulous.KeyFrame.tempAniMatrix = new THREE.Matrix4();\n\t\t\tVirtulous.KeyFrameTrack = function () {\n\n\t\t\t\tthis.keys = [];\n\t\t\t\tthis.target = null;\n\t\t\t\tthis.time = 0;\n\t\t\t\tthis.length = 0;\n\t\t\t\tthis._accelTable = {};\n\t\t\t\tthis.fps = 20;\n\t\t\t\tthis.addKey = function ( key ) {\n\n\t\t\t\t\tthis.keys.push( key );\n\n\t\t\t\t};\n\t\t\t\tthis.init = function () {\n\n\t\t\t\t\tthis.sortKeys();\n\n\t\t\t\t\tif ( this.keys.length > 0 )\n\t\t\t\t\t\tthis.length = this.keys[ this.keys.length - 1 ].time;\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.length = 0;\n\n\t\t\t\t\tif ( ! this.fps ) return;\n\n\t\t\t\t\tfor ( var j = 0; j < this.length * this.fps; j ++ ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < this.keys.length; i ++ ) {\n\n\t\t\t\t\t\t\tif ( this.keys[ i ].time == j ) {\n\n\t\t\t\t\t\t\t\tthis._accelTable[ j ] = i;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t} else if ( this.keys[ i ].time < j / this.fps && this.keys[ i + 1 ] && this.keys[ i + 1 ].time >= j / this.fps ) {\n\n\t\t\t\t\t\t\t\tthis._accelTable[ j ] = i;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tthis.parseFromThree = function ( data ) {\n\n\t\t\t\t\tvar fps = data.fps;\n\t\t\t\t\tthis.target = data.node;\n\t\t\t\t\tvar track = data.hierarchy[ 0 ].keys;\n\t\t\t\t\tfor ( var i = 0; i < track.length; i ++ ) {\n\n\t\t\t\t\t\tthis.addKey( new Virtulous.KeyFrame( i / fps || track[ i ].time, track[ i ].targets[ 0 ].data ) );\n\n\t\t\t\t\t}\n\t\t\t\t\tthis.init();\n\n\t\t\t\t};\n\n\t\t\t\tthis.parseFromCollada = function ( data ) {\n\n\t\t\t\t\tvar track = data.keys;\n\t\t\t\t\tvar fps = this.fps;\n\n\t\t\t\t\tfor ( var i = 0; i < track.length; i ++ ) {\n\n\t\t\t\t\t\tthis.addKey( new Virtulous.KeyFrame( i / fps || track[ i ].time, track[ i ].matrix ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.init();\n\n\t\t\t\t};\n\n\t\t\t\tthis.sortKeys = function () {\n\n\t\t\t\t\tthis.keys.sort( this.keySortFunc );\n\n\t\t\t\t};\n\n\t\t\t\tthis.keySortFunc = function ( a, b ) {\n\n\t\t\t\t\treturn a.time - b.time;\n\n\t\t\t\t};\n\n\t\t\t\tthis.clone = function () {\n\n\t\t\t\t\tvar t = new Virtulous.KeyFrameTrack();\n\t\t\t\t\tt.target = this.target;\n\t\t\t\t\tt.time = this.time;\n\t\t\t\t\tt.length = this.length;\n\n\t\t\t\t\tfor ( var i = 0; i < this.keys.length; i ++ ) {\n\n\t\t\t\t\t\tt.addKey( this.keys[ i ].clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tt.init();\n\t\t\t\t\treturn t;\n\n\t\t\t\t};\n\n\t\t\t\tthis.reTarget = function ( root, compareitor ) {\n\n\t\t\t\t\tif ( ! compareitor ) compareitor = Virtulous.TrackTargetNodeNameCompare;\n\t\t\t\t\tthis.target = compareitor( root, this.target );\n\n\t\t\t\t};\n\n\t\t\t\tthis.keySearchAccel = function ( time ) {\n\n\t\t\t\t\ttime *= this.fps;\n\t\t\t\t\ttime = Math.floor( time );\n\t\t\t\t\treturn this._accelTable[ time ] || 0;\n\n\t\t\t\t};\n\n\t\t\t\tthis.setTime = function ( time ) {\n\n\t\t\t\t\ttime = Math.abs( time );\n\t\t\t\t\tif ( this.length )\n\t\t\t\t\t\ttime = time % this.length + .05;\n\t\t\t\t\tvar key0 = null;\n\t\t\t\t\tvar key1 = null;\n\n\t\t\t\t\tfor ( var i = this.keySearchAccel( time ); i < this.keys.length; i ++ ) {\n\n\t\t\t\t\t\tif ( this.keys[ i ].time == time ) {\n\n\t\t\t\t\t\t\tkey0 = this.keys[ i ];\n\t\t\t\t\t\t\tkey1 = this.keys[ i ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if ( this.keys[ i ].time < time && this.keys[ i + 1 ] && this.keys[ i + 1 ].time > time ) {\n\n\t\t\t\t\t\t\tkey0 = this.keys[ i ];\n\t\t\t\t\t\t\tkey1 = this.keys[ i + 1 ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if ( this.keys[ i ].time < time && i == this.keys.length - 1 ) {\n\n\t\t\t\t\t\t\tkey0 = this.keys[ i ];\n\t\t\t\t\t\t\tkey1 = this.keys[ 0 ].clone();\n\t\t\t\t\t\t\tkey1.time += this.length + .05;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( key0 && key1 && key0 !== key1 ) {\n\n\t\t\t\t\t\tthis.target.matrixAutoUpdate = false;\n\t\t\t\t\t\tthis.target.matrix.copy( key0.lerp( key1, time ) );\n\t\t\t\t\t\tthis.target.matrixWorldNeedsUpdate = true;\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( key0 && key1 && key0 == key1 ) {\n\n\t\t\t\t\t\tthis.target.matrixAutoUpdate = false;\n\t\t\t\t\t\tthis.target.matrix.copy( key0.matrix );\n\t\t\t\t\t\tthis.target.matrixWorldNeedsUpdate = true;\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t\tVirtulous.TrackTargetNodeNameCompare = function ( root, target ) {\n\n\t\t\t\tfunction find( node, name ) {\n\n\t\t\t\t\tif ( node.name == name )\n\t\t\t\t\t\treturn node;\n\n\t\t\t\t\tfor ( var i = 0; i < node.children.length; i ++ ) {\n\n\t\t\t\t\t\tvar r = find( node.children[ i ], name );\n\t\t\t\t\t\tif ( r ) return r;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\treturn find( root, target.name );\n\n\t\t\t};\n\n\t\t\tVirtulous.Animation = function () {\n\n\t\t\t\tthis.tracks = [];\n\t\t\t\tthis.length = 0;\n\n\t\t\t\tthis.addTrack = function ( track ) {\n\n\t\t\t\t\tthis.tracks.push( track );\n\t\t\t\t\tthis.length = Math.max( track.length, this.length );\n\n\t\t\t\t};\n\n\t\t\t\tthis.setTime = function ( time ) {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ )\n\t\t\t\t\t\tthis.tracks[ i ].setTime( time );\n\n\t\t\t\t};\n\n\t\t\t\tthis.clone = function ( target, compareitor ) {\n\n\t\t\t\t\tif ( ! compareitor ) compareitor = Virtulous.TrackTargetNodeNameCompare;\n\t\t\t\t\tvar n = new Virtulous.Animation();\n\t\t\t\t\tn.target = target;\n\t\t\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\t\t\t\tvar track = this.tracks[ i ].clone();\n\t\t\t\t\t\ttrack.reTarget( target, compareitor );\n\t\t\t\t\t\tn.addTrack( track );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn n;\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t\tvar ASSBIN_CHUNK_AICAMERA = 0x1234;\n\t\t\tvar ASSBIN_CHUNK_AILIGHT = 0x1235;\n\t\t\tvar ASSBIN_CHUNK_AITEXTURE = 0x1236;\n\t\t\tvar ASSBIN_CHUNK_AIMESH = 0x1237;\n\t\t\tvar ASSBIN_CHUNK_AINODEANIM = 0x1238;\n\t\t\tvar ASSBIN_CHUNK_AISCENE = 0x1239;\n\t\t\tvar ASSBIN_CHUNK_AIBONE = 0x123a;\n\t\t\tvar ASSBIN_CHUNK_AIANIMATION = 0x123b;\n\t\t\tvar ASSBIN_CHUNK_AINODE = 0x123c;\n\t\t\tvar ASSBIN_CHUNK_AIMATERIAL = 0x123d;\n\t\t\tvar ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;\n\t\t\tvar ASSBIN_MESH_HAS_POSITIONS = 0x1;\n\t\t\tvar ASSBIN_MESH_HAS_NORMALS = 0x2;\n\t\t\tvar ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;\n\t\t\tvar ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;\n\t\t\tvar ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;\n\t\t\tvar AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n\t\t\tvar AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;\n\t\t\t//var aiLightSource_UNDEFINED = 0x0;\n\t\t\t//! A directional light source has a well-defined direction\n\t\t\t//! but is infinitely far away. That's quite a good\n\t\t\t//! approximation for sun light.\n\t\t\tvar aiLightSource_DIRECTIONAL = 0x1;\n\t\t\t//! A point light source has a well-defined position\n\t\t\t//! in space but no direction - it emits light in all\n\t\t\t//! directions. A normal bulb is a point light.\n\t\t\t//var aiLightSource_POINT = 0x2;\n\t\t\t//! A spot light source emits light in a specific\n\t\t\t//! angle. It has a position and a direction it is pointing to.\n\t\t\t//! A good example for a spot light is a light spot in\n\t\t\t//! sport arenas.\n\t\t\tvar aiLightSource_SPOT = 0x3;\n\t\t\t//! The generic light level of the world, including the bounces\n\t\t\t//! of all other lightsources.\n\t\t\t//! Typically, there's at most one ambient light in a scene.\n\t\t\t//! This light type doesn't have a valid position, direction, or\n\t\t\t//! other properties, just a color.\n\t\t\t//var aiLightSource_AMBIENT = 0x4;\n\t\t\t/** Flat shading. Shading is done on per-face base,\n\t\t\t *  diffuse only. Also known as 'faceted shading'.\n\t\t\t */\n\t\t\t//var aiShadingMode_Flat = 0x1;\n\t\t\t/** Simple Gouraud shading.\n\t\t\t */\n\t\t\t//var aiShadingMode_Gouraud = 0x2;\n\t\t\t/** Phong-Shading -\n\t\t\t */\n\t\t\t//var aiShadingMode_Phong = 0x3;\n\t\t\t/** Phong-Blinn-Shading\n\t\t\t */\n\t\t\t//var aiShadingMode_Blinn = 0x4;\n\t\t\t/** Toon-Shading per pixel\n\t\t\t *\n\t\t\t *  Also known as 'comic' shader.\n\t\t\t */\n\t\t\t//var aiShadingMode_Toon = 0x5;\n\t\t\t/** OrenNayar-Shading per pixel\n\t\t\t *\n\t\t\t *  Extension to standard Lambertian shading, taking the\n\t\t\t *  roughness of the material into account\n\t\t\t */\n\t\t\t//var aiShadingMode_OrenNayar = 0x6;\n\t\t\t/** Minnaert-Shading per pixel\n\t\t\t *\n\t\t\t *  Extension to standard Lambertian shading, taking the\n\t\t\t *  \"darkness\" of the material into account\n\t\t\t */\n\t\t\t//var aiShadingMode_Minnaert = 0x7;\n\t\t\t/** CookTorrance-Shading per pixel\n\t\t\t *\n\t\t\t *  Special shader for metallic surfaces.\n\t\t\t */\n\t\t\t//var aiShadingMode_CookTorrance = 0x8;\n\t\t\t/** No shading at all. Constant light influence of 1.0.\n\t\t\t */\n\t\t\t//var aiShadingMode_NoShading = 0x9;\n\t\t\t/** Fresnel shading\n\t\t\t */\n\t\t\t//var aiShadingMode_Fresnel = 0xa;\n\t\t\t//var aiTextureType_NONE = 0x0;\n\t\t\t/** The texture is combined with the result of the diffuse\n\t\t\t *  lighting equation.\n\t\t\t */\n\t\t\tvar aiTextureType_DIFFUSE = 0x1;\n\t\t\t/** The texture is combined with the result of the specular\n\t\t\t *  lighting equation.\n\t\t\t */\n\t\t\t//var aiTextureType_SPECULAR = 0x2;\n\t\t\t/** The texture is combined with the result of the ambient\n\t\t\t *  lighting equation.\n\t\t\t */\n\t\t\t//var aiTextureType_AMBIENT = 0x3;\n\t\t\t/** The texture is added to the result of the lighting\n\t\t\t *  calculation. It isn't influenced by incoming light.\n\t\t\t */\n\t\t\t//var aiTextureType_EMISSIVE = 0x4;\n\t\t\t/** The texture is a height map.\n\t\t\t *\n\t\t\t *  By convention, higher gray-scale values stand for\n\t\t\t *  higher elevations from the base height.\n\t\t\t */\n\t\t\t//var aiTextureType_HEIGHT = 0x5;\n\t\t\t/** The texture is a (tangent space) normal-map.\n\t\t\t *\n\t\t\t *  Again, there are several conventions for tangent-space\n\t\t\t *  normal maps. Assimp does (intentionally) not\n\t\t\t *  distinguish here.\n\t\t\t */\n\t\t\tvar aiTextureType_NORMALS = 0x6;\n\t\t\t/** The texture defines the glossiness of the material.\n\t\t\t *\n\t\t\t *  The glossiness is in fact the exponent of the specular\n\t\t\t *  (phong) lighting equation. Usually there is a conversion\n\t\t\t *  function defined to map the linear color values in the\n\t\t\t *  texture to a suitable exponent. Have fun.\n\t\t\t */\n\t\t\t//var aiTextureType_SHININESS = 0x7;\n\t\t\t/** The texture defines per-pixel opacity.\n\t\t\t *\n\t\t\t *  Usually 'white' means opaque and 'black' means\n\t\t\t *  'transparency'. Or quite the opposite. Have fun.\n\t\t\t */\n\t\t\tvar aiTextureType_OPACITY = 0x8;\n\t\t\t/** Displacement texture\n\t\t\t *\n\t\t\t *  The exact purpose and format is application-dependent.\n\t\t\t *  Higher color values stand for higher vertex displacements.\n\t\t\t */\n\t\t\t//var aiTextureType_DISPLACEMENT = 0x9;\n\t\t\t/** Lightmap texture (aka Ambient Occlusion)\n\t\t\t *\n\t\t\t *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n\t\t\t *  covered by this material property. The texture contains a\n\t\t\t *  scaling value for the final color value of a pixel. Its\n\t\t\t *  intensity is not affected by incoming light.\n\t\t\t */\n\t\t\tvar aiTextureType_LIGHTMAP = 0xA;\n\t\t\t/** Reflection texture\n\t\t\t *\n\t\t\t * Contains the color of a perfect mirror reflection.\n\t\t\t * Rarely used, almost never for real-time applications.\n\t\t\t */\n\t\t\t//var aiTextureType_REFLECTION = 0xB;\n\t\t\t/** Unknown texture\n\t\t\t *\n\t\t\t *  A texture reference that does not match any of the definitions\n\t\t\t *  above is considered to be 'unknown'. It is still imported,\n\t\t\t *  but is excluded from any further postprocessing.\n\t\t\t */\n\t\t\t//var aiTextureType_UNKNOWN = 0xC;\n\t\t\tvar BONESPERVERT = 4;\n\n\t\t\tfunction ASSBIN_MESH_HAS_TEXCOORD( n ) {\n\n\t\t\t\treturn ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n\n\t\t\t}\n\n\t\t\tfunction ASSBIN_MESH_HAS_COLOR( n ) {\n\n\t\t\t\treturn ASSBIN_MESH_HAS_COLOR_BASE << n;\n\n\t\t\t}\n\n\t\t\tfunction markBones( scene ) {\n\n\t\t\t\tfor ( var i in scene.mMeshes ) {\n\n\t\t\t\t\tvar mesh = scene.mMeshes[ i ];\n\t\t\t\t\tfor ( var k in mesh.mBones ) {\n\n\t\t\t\t\t\tvar boneNode = scene.findNode( mesh.mBones[ k ].mName );\n\t\t\t\t\t\tif ( boneNode )\n\t\t\t\t\t\t\tboneNode.isBone = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfunction cloneTreeToBones( root, scene ) {\n\n\t\t\t\tvar rootBone = new THREE.Bone();\n\t\t\t\trootBone.matrix.copy( root.matrix );\n\t\t\t\trootBone.matrixWorld.copy( root.matrixWorld );\n\t\t\t\trootBone.position.copy( root.position );\n\t\t\t\trootBone.quaternion.copy( root.quaternion );\n\t\t\t\trootBone.scale.copy( root.scale );\n\t\t\t\tscene.nodeCount ++;\n\t\t\t\trootBone.name = \"bone_\" + root.name + scene.nodeCount.toString();\n\n\t\t\t\tif ( ! scene.nodeToBoneMap[ root.name ] )\n\t\t\t\t\tscene.nodeToBoneMap[ root.name ] = [];\n\t\t\t\tscene.nodeToBoneMap[ root.name ].push( rootBone );\n\t\t\t\tfor ( var i in root.children ) {\n\n\t\t\t\t\tvar child = cloneTreeToBones( root.children[ i ], scene );\n\t\t\t\t\trootBone.add( child );\n\n\t\t\t\t}\n\n\t\t\t\treturn rootBone;\n\n\t\t\t}\n\n\t\t\tfunction sortWeights( indexes, weights ) {\n\n\t\t\t\tvar pairs = [];\n\n\t\t\t\tfor ( var i = 0; i < indexes.length; i ++ ) {\n\n\t\t\t\t\tpairs.push( {\n\t\t\t\t\t\ti: indexes[ i ],\n\t\t\t\t\t\tw: weights[ i ]\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tpairs.sort( function ( a, b ) {\n\n\t\t\t\t\treturn b.w - a.w;\n\n\t\t\t\t } );\n\n\t\t\t\twhile ( pairs.length < 4 ) {\n\n\t\t\t\t\tpairs.push( {\n\t\t\t\t\t\ti: 0,\n\t\t\t\t\t\tw: 0\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tif ( pairs.length > 4 )\n\t\t\t\t\tpairs.length = 4;\n\t\t\t\tvar sum = 0;\n\n\t\t\t\tfor ( var i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tsum += pairs[ i ].w * pairs[ i ].w;\n\n\t\t\t\t}\n\n\t\t\t\tsum = Math.sqrt( sum );\n\n\t\t\t\tfor ( var i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tpairs[ i ].w = pairs[ i ].w / sum;\n\t\t\t\t\tindexes[ i ] = pairs[ i ].i;\n\t\t\t\t\tweights[ i ] = pairs[ i ].w;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction findMatchingBone( root, name ) {\n\n\t\t\t\tif ( root.name.indexOf( \"bone_\" + name ) == 0 )\n\t\t\t\t\treturn root;\n\n\t\t\t\tfor ( var i in root.children ) {\n\n\t\t\t\t\tvar ret = findMatchingBone( root.children[ i ], name );\n\n\t\t\t\t\tif ( ret )\n\t\t\t\t\t\treturn ret;\n\n\t\t\t\t}\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\tfunction aiMesh() {\n\n\t\t\t\tthis.mPrimitiveTypes = 0;\n\t\t\t\tthis.mNumVertices = 0;\n\t\t\t\tthis.mNumFaces = 0;\n\t\t\t\tthis.mNumBones = 0;\n\t\t\t\tthis.mMaterialIndex = 0;\n\t\t\t\tthis.mVertices = [];\n\t\t\t\tthis.mNormals = [];\n\t\t\t\tthis.mTangents = [];\n\t\t\t\tthis.mBitangents = [];\n\t\t\t\tthis.mColors = [\n\t\t\t\t\t[]\n\t\t\t\t];\n\t\t\t\tthis.mTextureCoords = [\n\t\t\t\t\t[]\n\t\t\t\t];\n\t\t\t\tthis.mFaces = [];\n\t\t\t\tthis.mBones = [];\n\t\t\t\tthis.hookupSkeletons = function ( scene ) {\n\n\t\t\t\t\tif ( this.mBones.length == 0 ) return;\n\n\t\t\t\t\tvar allBones = [];\n\t\t\t\t\tvar offsetMatrix = [];\n\t\t\t\t\tvar skeletonRoot = scene.findNode( this.mBones[ 0 ].mName );\n\n\t\t\t\t\twhile ( skeletonRoot.mParent && skeletonRoot.mParent.isBone ) {\n\n\t\t\t\t\t\tskeletonRoot = skeletonRoot.mParent;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar threeSkeletonRoot = skeletonRoot.toTHREE( scene );\n\t\t\t\t\tvar threeSkeletonRootBone = cloneTreeToBones( threeSkeletonRoot, scene );\n\t\t\t\t\tthis.threeNode.add( threeSkeletonRootBone );\n\n\t\t\t\t\tfor ( var i = 0; i < this.mBones.length; i ++ ) {\n\n\t\t\t\t\t\tvar bone = findMatchingBone( threeSkeletonRootBone, this.mBones[ i ].mName );\n\n\t\t\t\t\t\tif ( bone ) {\n\n\t\t\t\t\t\t\tvar tbone = bone;\n\t\t\t\t\t\t\tallBones.push( tbone );\n\t\t\t\t\t\t\t//tbone.matrixAutoUpdate = false;\n\t\t\t\t\t\t\toffsetMatrix.push( this.mBones[ i ].mOffsetMatrix.toTHREE() );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar skeletonRoot = scene.findNode( this.mBones[ i ].mName );\n\t\t\t\t\t\t\tif ( ! skeletonRoot ) return;\n\t\t\t\t\t\t\tvar threeSkeletonRoot = skeletonRoot.toTHREE( scene );\n\t\t\t\t\t\t\tvar threeSkeletonRootBone = cloneTreeToBones( threeSkeletonRoot, scene );\n\t\t\t\t\t\t\tthis.threeNode.add( threeSkeletonRootBone );\n\t\t\t\t\t\t\tvar bone = findMatchingBone( threeSkeletonRootBone, this.mBones[ i ].mName );\n\t\t\t\t\t\t\tvar tbone = bone;\n\t\t\t\t\t\t\tallBones.push( tbone );\n\t\t\t\t\t\t\t//tbone.matrixAutoUpdate = false;\n\t\t\t\t\t\t\toffsetMatrix.push( this.mBones[ i ].mOffsetMatrix.toTHREE() );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tvar skeleton = new THREE.Skeleton( allBones, offsetMatrix );\n\n\t\t\t\t\tthis.threeNode.bind( skeleton, new THREE.Matrix4() );\n\t\t\t\t\tthis.threeNode.material.skinning = true;\n\n\t\t\t\t};\n\n\t\t\t\tthis.toTHREE = function ( scene ) {\n\n\t\t\t\t\tif ( this.threeNode ) return this.threeNode;\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\t\tvar mat;\n\t\t\t\t\tif ( scene.mMaterials[ this.mMaterialIndex ] )\n\t\t\t\t\t\tmat = scene.mMaterials[ this.mMaterialIndex ].toTHREE( scene );\n\t\t\t\t\telse\n\t\t\t\t\t\tmat = new THREE.MeshLambertMaterial();\n\t\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( new Uint32Array( this.mIndexArray ), 1 ) );\n\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( this.mVertexBuffer, 3 ) );\n\t\t\t\t\tif ( this.mNormalBuffer && this.mNormalBuffer.length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'normal', new THREE.BufferAttribute( this.mNormalBuffer, 3 ) );\n\t\t\t\t\tif ( this.mColorBuffer && this.mColorBuffer.length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.BufferAttribute( this.mColorBuffer, 4 ) );\n\t\t\t\t\tif ( this.mTexCoordsBuffers[ 0 ] && this.mTexCoordsBuffers[ 0 ].length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( this.mTexCoordsBuffers[ 0 ] ), 2 ) );\n\t\t\t\t\tif ( this.mTexCoordsBuffers[ 1 ] && this.mTexCoordsBuffers[ 1 ].length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'uv1', new THREE.BufferAttribute( new Float32Array( this.mTexCoordsBuffers[ 1 ] ), 2 ) );\n\t\t\t\t\tif ( this.mTangentBuffer && this.mTangentBuffer.length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'tangents', new THREE.BufferAttribute( this.mTangentBuffer, 3 ) );\n\t\t\t\t\tif ( this.mBitangentBuffer && this.mBitangentBuffer.length > 0 )\n\t\t\t\t\t\tgeometry.setAttribute( 'bitangents', new THREE.BufferAttribute( this.mBitangentBuffer, 3 ) );\n\t\t\t\t\tif ( this.mBones.length > 0 ) {\n\n\t\t\t\t\t\tvar weights = [];\n\t\t\t\t\t\tvar bones = [];\n\n\t\t\t\t\t\tfor ( var i = 0; i < this.mBones.length; i ++ ) {\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < this.mBones[ i ].mWeights.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar weight = this.mBones[ i ].mWeights[ j ];\n\t\t\t\t\t\t\t\tif ( weight ) {\n\n\t\t\t\t\t\t\t\t\tif ( ! weights[ weight.mVertexId ] ) weights[ weight.mVertexId ] = [];\n\t\t\t\t\t\t\t\t\tif ( ! bones[ weight.mVertexId ] ) bones[ weight.mVertexId ] = [];\n\t\t\t\t\t\t\t\t\tweights[ weight.mVertexId ].push( weight.mWeight );\n\t\t\t\t\t\t\t\t\tbones[ weight.mVertexId ].push( parseInt( i ) );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( var i in bones ) {\n\n\t\t\t\t\t\t\tsortWeights( bones[ i ], weights[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar _weights = [];\n\t\t\t\t\t\tvar _bones = [];\n\n\t\t\t\t\t\tfor ( var i = 0; i < weights.length; i ++ ) {\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\tif ( weights[ i ] && bones[ i ] ) {\n\n\t\t\t\t\t\t\t\t\t_weights.push( weights[ i ][ j ] );\n\t\t\t\t\t\t\t\t\t_bones.push( bones[ i ][ j ] );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t_weights.push( 0 );\n\t\t\t\t\t\t\t\t\t_bones.push( 0 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.setAttribute( 'skinWeight', new THREE.BufferAttribute( new Float32Array( _weights ), BONESPERVERT ) );\n\t\t\t\t\t\tgeometry.setAttribute( 'skinIndex', new THREE.BufferAttribute( new Float32Array( _bones ), BONESPERVERT ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar mesh;\n\n\t\t\t\t\tif ( this.mBones.length == 0 )\n\t\t\t\t\t\tmesh = new THREE.Mesh( geometry, mat );\n\n\t\t\t\t\tif ( this.mBones.length > 0 ) {\n\n\t\t\t\t\t\tmesh = new THREE.SkinnedMesh( geometry, mat );\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.threeNode = mesh;\n\t\t\t\t\t//mesh.matrixAutoUpdate = false;\n\t\t\t\t\treturn mesh;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiFace() {\n\n\t\t\t\tthis.mNumIndices = 0;\n\t\t\t\tthis.mIndices = [];\n\n\t\t\t}\n\n\t\t\tfunction aiVector3D() {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\treturn new THREE.Vector3( this.x, this.y, this.z );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiColor3D() {\n\n\t\t\t\tthis.r = 0;\n\t\t\t\tthis.g = 0;\n\t\t\t\tthis.b = 0;\n\t\t\t\tthis.a = 0;\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\treturn new THREE.Color( this.r, this.g, this.b );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiQuaternion() {\n\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\t\t\tthis.w = 0;\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\treturn new THREE.Quaternion( this.x, this.y, this.z, this.w );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiVertexWeight() {\n\n\t\t\t\tthis.mVertexId = 0;\n\t\t\t\tthis.mWeight = 0;\n\n\t\t\t}\n\n\t\t\tfunction aiString() {\n\n\t\t\t\tthis.data = [];\n\t\t\t\tthis.toString = function () {\n\n\t\t\t\t\tvar str = '';\n\t\t\t\t\tthis.data.forEach( function ( i ) {\n\n\t\t\t\t\t\tstr += ( String.fromCharCode( i ) );\n\n\t\t\t\t\t} );\n\t\t\t\t\treturn str.replace( /[^\\x20-\\x7E]+/g, '' );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiVectorKey() {\n\n\t\t\t\tthis.mTime = 0;\n\t\t\t\tthis.mValue = null;\n\n\t\t\t}\n\n\t\t\tfunction aiQuatKey() {\n\n\t\t\t\tthis.mTime = 0;\n\t\t\t\tthis.mValue = null;\n\n\t\t\t}\n\n\t\t\tfunction aiNode() {\n\n\t\t\t\tthis.mName = '';\n\t\t\t\tthis.mTransformation = [];\n\t\t\t\tthis.mNumChildren = 0;\n\t\t\t\tthis.mNumMeshes = 0;\n\t\t\t\tthis.mMeshes = [];\n\t\t\t\tthis.mChildren = [];\n\t\t\t\tthis.toTHREE = function ( scene ) {\n\n\t\t\t\t\tif ( this.threeNode ) return this.threeNode;\n\t\t\t\t\tvar o = new THREE.Object3D();\n\t\t\t\t\to.name = this.mName;\n\t\t\t\t\to.matrix = this.mTransformation.toTHREE();\n\n\t\t\t\t\tfor ( var i = 0; i < this.mChildren.length; i ++ ) {\n\n\t\t\t\t\t\to.add( this.mChildren[ i ].toTHREE( scene ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < this.mMeshes.length; i ++ ) {\n\n\t\t\t\t\t\to.add( scene.mMeshes[ this.mMeshes[ i ] ].toTHREE( scene ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.threeNode = o;\n\t\t\t\t\t//o.matrixAutoUpdate = false;\n\t\t\t\t\to.matrix.decompose( o.position, o.quaternion, o.scale );\n\t\t\t\t\treturn o;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiBone() {\n\n\t\t\t\tthis.mName = '';\n\t\t\t\tthis.mNumWeights = 0;\n\t\t\t\tthis.mOffsetMatrix = 0;\n\n\t\t\t}\n\n\t\t\tfunction aiMaterialProperty() {\n\n\t\t\t\tthis.mKey = \"\";\n\t\t\t\tthis.mSemantic = 0;\n\t\t\t\tthis.mIndex = 0;\n\t\t\t\tthis.mData = [];\n\t\t\t\tthis.mDataLength = 0;\n\t\t\t\tthis.mType = 0;\n\t\t\t\tthis.dataAsColor = function () {\n\n\t\t\t\t\tvar array = ( new Uint8Array( this.mData ) ).buffer;\n\t\t\t\t\tvar reader = new DataView( array );\n\t\t\t\t\tvar r = reader.getFloat32( 0, true );\n\t\t\t\t\tvar g = reader.getFloat32( 4, true );\n\t\t\t\t\tvar b = reader.getFloat32( 8, true );\n\t\t\t\t\t//var a = reader.getFloat32(12, true);\n\t\t\t\t\treturn new THREE.Color( r, g, b );\n\n\t\t\t\t};\n\n\t\t\t\tthis.dataAsFloat = function () {\n\n\t\t\t\t\tvar array = ( new Uint8Array( this.mData ) ).buffer;\n\t\t\t\t\tvar reader = new DataView( array );\n\t\t\t\t\tvar r = reader.getFloat32( 0, true );\n\t\t\t\t\treturn r;\n\n\t\t\t\t};\n\n\t\t\t\tthis.dataAsBool = function () {\n\n\t\t\t\t\tvar array = ( new Uint8Array( this.mData ) ).buffer;\n\t\t\t\t\tvar reader = new DataView( array );\n\t\t\t\t\tvar r = reader.getFloat32( 0, true );\n\t\t\t\t\treturn !! r;\n\n\t\t\t\t};\n\n\t\t\t\tthis.dataAsString = function () {\n\n\t\t\t\t\tvar s = new aiString();\n\t\t\t\t\ts.data = this.mData;\n\t\t\t\t\treturn s.toString();\n\n\t\t\t\t};\n\n\t\t\t\tthis.dataAsMap = function () {\n\n\t\t\t\t\tvar s = new aiString();\n\t\t\t\t\ts.data = this.mData;\n\t\t\t\t\tvar path = s.toString();\n\t\t\t\t\tpath = path.replace( /\\\\/g, '/' );\n\n\t\t\t\t\tif ( path.indexOf( '/' ) != - 1 ) {\n\n\t\t\t\t\t\tpath = path.substr( path.lastIndexOf( '/' ) + 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn textureLoader.load( path );\n\n\t\t\t\t};\n\n\t\t\t}\n\t\t\tvar namePropMapping = {\n\n\t\t\t\t\"?mat.name\": \"name\",\n\t\t\t\t\"$mat.shadingm\": \"shading\",\n\t\t\t\t\"$mat.twosided\": \"twoSided\",\n\t\t\t\t\"$mat.wireframe\": \"wireframe\",\n\t\t\t\t\"$clr.ambient\": \"ambient\",\n\t\t\t\t\"$clr.diffuse\": \"color\",\n\t\t\t\t\"$clr.specular\": \"specular\",\n\t\t\t\t\"$clr.emissive\": \"emissive\",\n\t\t\t\t\"$clr.transparent\": \"transparent\",\n\t\t\t\t\"$clr.reflective\": \"reflect\",\n\t\t\t\t\"$mat.shininess\": \"shininess\",\n\t\t\t\t\"$mat.reflectivity\": \"reflectivity\",\n\t\t\t\t\"$mat.refracti\": \"refraction\",\n\t\t\t\t\"$tex.file\": \"map\"\n\n\t\t\t};\n\n\t\t\tvar nameTypeMapping = {\n\n\t\t\t\t\"?mat.name\": \"string\",\n\t\t\t\t\"$mat.shadingm\": \"bool\",\n\t\t\t\t\"$mat.twosided\": \"bool\",\n\t\t\t\t\"$mat.wireframe\": \"bool\",\n\t\t\t\t\"$clr.ambient\": \"color\",\n\t\t\t\t\"$clr.diffuse\": \"color\",\n\t\t\t\t\"$clr.specular\": \"color\",\n\t\t\t\t\"$clr.emissive\": \"color\",\n\t\t\t\t\"$clr.transparent\": \"color\",\n\t\t\t\t\"$clr.reflective\": \"color\",\n\t\t\t\t\"$mat.shininess\": \"float\",\n\t\t\t\t\"$mat.reflectivity\": \"float\",\n\t\t\t\t\"$mat.refracti\": \"float\",\n\t\t\t\t\"$tex.file\": \"map\"\n\n\t\t\t};\n\n\t\t\tfunction aiMaterial() {\n\n\t\t\t\tthis.mNumAllocated = 0;\n\t\t\t\tthis.mNumProperties = 0;\n\t\t\t\tthis.mProperties = [];\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\tvar mat = new THREE.MeshPhongMaterial();\n\n\t\t\t\t\tfor ( var i = 0; i < this.mProperties.length; i ++ ) {\n\n\t\t\t\t\t\tif ( nameTypeMapping[ this.mProperties[ i ].mKey ] == 'float' )\n\t\t\t\t\t\t\tmat[ namePropMapping[ this.mProperties[ i ].mKey ] ] = this.mProperties[ i ].dataAsFloat();\n\t\t\t\t\t\tif ( nameTypeMapping[ this.mProperties[ i ].mKey ] == 'color' )\n\t\t\t\t\t\t\tmat[ namePropMapping[ this.mProperties[ i ].mKey ] ] = this.mProperties[ i ].dataAsColor();\n\t\t\t\t\t\tif ( nameTypeMapping[ this.mProperties[ i ].mKey ] == 'bool' )\n\t\t\t\t\t\t\tmat[ namePropMapping[ this.mProperties[ i ].mKey ] ] = this.mProperties[ i ].dataAsBool();\n\t\t\t\t\t\tif ( nameTypeMapping[ this.mProperties[ i ].mKey ] == 'string' )\n\t\t\t\t\t\t\tmat[ namePropMapping[ this.mProperties[ i ].mKey ] ] = this.mProperties[ i ].dataAsString();\n\t\t\t\t\t\tif ( nameTypeMapping[ this.mProperties[ i ].mKey ] == 'map' ) {\n\n\t\t\t\t\t\t\tvar prop = this.mProperties[ i ];\n\t\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_DIFFUSE )\n\t\t\t\t\t\t\t\tmat.map = this.mProperties[ i ].dataAsMap();\n\t\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_NORMALS )\n\t\t\t\t\t\t\t\tmat.normalMap = this.mProperties[ i ].dataAsMap();\n\t\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_LIGHTMAP )\n\t\t\t\t\t\t\t\tmat.lightMap = this.mProperties[ i ].dataAsMap();\n\t\t\t\t\t\t\tif ( prop.mSemantic == aiTextureType_OPACITY )\n\t\t\t\t\t\t\t\tmat.alphaMap = this.mProperties[ i ].dataAsMap();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmat.ambient.r = .53;\n\t\t\t\t\tmat.ambient.g = .53;\n\t\t\t\t\tmat.ambient.b = .53;\n\t\t\t\t\tmat.color.r = 1;\n\t\t\t\t\tmat.color.g = 1;\n\t\t\t\t\tmat.color.b = 1;\n\t\t\t\t\treturn mat;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\n\t\t\tfunction veclerp( v1, v2, l ) {\n\n\t\t\t\tvar v = new THREE.Vector3();\n\t\t\t\tvar lm1 = 1 - l;\n\t\t\t\tv.x = v1.x * l + v2.x * lm1;\n\t\t\t\tv.y = v1.y * l + v2.y * lm1;\n\t\t\t\tv.z = v1.z * l + v2.z * lm1;\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction quatlerp( q1, q2, l ) {\n\n\t\t\t\treturn q1.clone().slerp( q2, 1 - l );\n\n\t\t\t}\n\n\t\t\tfunction sampleTrack( keys, time, lne, lerp ) {\n\n\t\t\t\tif ( keys.length == 1 ) return keys[ 0 ].mValue.toTHREE();\n\n\t\t\t\tvar dist = Infinity;\n\t\t\t\tvar key = null;\n\t\t\t\tvar nextKey = null;\n\n\t\t\t\tfor ( var i = 0; i < keys.length; i ++ ) {\n\n\t\t\t\t\tvar timeDist = Math.abs( keys[ i ].mTime - time );\n\n\t\t\t\t\tif ( timeDist < dist && keys[ i ].mTime <= time ) {\n\n\t\t\t\t\t\tdist = timeDist;\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tnextKey = keys[ i + 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! key ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t} else if ( nextKey ) {\n\n\t\t\t\t\tvar dT = nextKey.mTime - key.mTime;\n\t\t\t\t\tvar T = key.mTime - time;\n\t\t\t\t\tvar l = T / dT;\n\n\t\t\t\t\treturn lerp( key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnextKey = keys[ 0 ].clone();\n\t\t\t\t\tnextKey.mTime += lne;\n\n\t\t\t\t\tvar dT = nextKey.mTime - key.mTime;\n\t\t\t\t\tvar T = key.mTime - time;\n\t\t\t\t\tvar l = T / dT;\n\n\t\t\t\t\treturn lerp( key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction aiNodeAnim() {\n\n\t\t\t\tthis.mNodeName = \"\";\n\t\t\t\tthis.mNumPositionKeys = 0;\n\t\t\t\tthis.mNumRotationKeys = 0;\n\t\t\t\tthis.mNumScalingKeys = 0;\n\t\t\t\tthis.mPositionKeys = [];\n\t\t\t\tthis.mRotationKeys = [];\n\t\t\t\tthis.mScalingKeys = [];\n\t\t\t\tthis.mPreState = \"\";\n\t\t\t\tthis.mPostState = \"\";\n\t\t\t\tthis.init = function ( tps ) {\n\n\t\t\t\t\tif ( ! tps ) tps = 1;\n\n\t\t\t\t\tfunction t( t ) {\n\n\t\t\t\t\t\tt.mTime /= tps;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.mPositionKeys.forEach( t );\n\t\t\t\t\tthis.mRotationKeys.forEach( t );\n\t\t\t\t\tthis.mScalingKeys.forEach( t );\n\n\t\t\t\t};\n\n\t\t\t\tthis.sortKeys = function () {\n\n\t\t\t\t\tfunction comp( a, b ) {\n\n\t\t\t\t\t\treturn a.mTime - b.mTime;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.mPositionKeys.sort( comp );\n\t\t\t\t\tthis.mRotationKeys.sort( comp );\n\t\t\t\t\tthis.mScalingKeys.sort( comp );\n\n\t\t\t\t};\n\n\t\t\t\tthis.getLength = function () {\n\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\tMath.max.apply( null, this.mPositionKeys.map( function ( a ) {\n\n\t\t\t\t\t\t\treturn a.mTime;\n\n\t\t\t\t\t\t} ) ),\n\t\t\t\t\t\tMath.max.apply( null, this.mRotationKeys.map( function ( a ) {\n\n\t\t\t\t\t\t\treturn a.mTime;\n\n\t\t\t\t\t\t} ) ),\n\t\t\t\t\t\tMath.max.apply( null, this.mScalingKeys.map( function ( a ) {\n\n\t\t\t\t\t\t\treturn a.mTime;\n\n\t\t\t\t\t } ) )\n\t\t\t\t\t);\n\n\t\t\t\t};\n\n\t\t\t\tthis.toTHREE = function ( o ) {\n\n\t\t\t\t\tthis.sortKeys();\n\t\t\t\t\tvar length = this.getLength();\n\t\t\t\t\tvar track = new Virtulous.KeyFrameTrack();\n\n\t\t\t\t\tfor ( var i = 0; i < length; i += .05 ) {\n\n\t\t\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\t\t\tvar time = i;\n\t\t\t\t\t\tvar pos = sampleTrack( this.mPositionKeys, time, length, veclerp );\n\t\t\t\t\t\tvar scale = sampleTrack( this.mScalingKeys, time, length, veclerp );\n\t\t\t\t\t\tvar rotation = sampleTrack( this.mRotationKeys, time, length, quatlerp );\n\t\t\t\t\t\tmatrix.compose( pos, rotation, scale );\n\n\t\t\t\t\t\tvar key = new Virtulous.KeyFrame( time, matrix );\n\t\t\t\t\t\ttrack.addKey( key );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttrack.target = o.findNode( this.mNodeName ).toTHREE();\n\n\t\t\t\t\tvar tracks = [ track ];\n\n\t\t\t\t\tif ( o.nodeToBoneMap[ this.mNodeName ] ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < o.nodeToBoneMap[ this.mNodeName ].length; i ++ ) {\n\n\t\t\t\t\t\t\tvar t2 = track.clone();\n\t\t\t\t\t\t\tt2.target = o.nodeToBoneMap[ this.mNodeName ][ i ];\n\t\t\t\t\t\t\ttracks.push( t2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tracks;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiAnimation() {\n\n\t\t\t\tthis.mName = \"\";\n\t\t\t\tthis.mDuration = 0;\n\t\t\t\tthis.mTicksPerSecond = 0;\n\t\t\t\tthis.mNumChannels = 0;\n\t\t\t\tthis.mChannels = [];\n\t\t\t\tthis.toTHREE = function ( root ) {\n\n\t\t\t\t\tvar animationHandle = new Virtulous.Animation();\n\n\t\t\t\t\tfor ( var i in this.mChannels ) {\n\n\t\t\t\t\t\tthis.mChannels[ i ].init( this.mTicksPerSecond );\n\n\t\t\t\t\t\tvar tracks = this.mChannels[ i ].toTHREE( root );\n\n\t\t\t\t\t\tfor ( var j in tracks ) {\n\n\t\t\t\t\t\t\ttracks[ j ].init();\n\t\t\t\t\t\t\tanimationHandle.addTrack( tracks[ j ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationHandle.length = Math.max.apply( null, animationHandle.tracks.map( function ( e ) {\n\n\t\t\t\t\t\treturn e.length;\n\n\t\t\t\t\t} ) );\n\t\t\t\t\treturn animationHandle;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiTexture() {\n\n\t\t\t\tthis.mWidth = 0;\n\t\t\t\tthis.mHeight = 0;\n\t\t\t\tthis.texAchFormatHint = [];\n\t\t\t\tthis.pcData = [];\n\n\t\t\t}\n\n\t\t\tfunction aiLight() {\n\n\t\t\t\tthis.mName = '';\n\t\t\t\tthis.mType = 0;\n\t\t\t\tthis.mAttenuationConstant = 0;\n\t\t\t\tthis.mAttenuationLinear = 0;\n\t\t\t\tthis.mAttenuationQuadratic = 0;\n\t\t\t\tthis.mAngleInnerCone = 0;\n\t\t\t\tthis.mAngleOuterCone = 0;\n\t\t\t\tthis.mColorDiffuse = null;\n\t\t\t\tthis.mColorSpecular = null;\n\t\t\t\tthis.mColorAmbient = null;\n\n\t\t\t}\n\n\t\t\tfunction aiCamera() {\n\n\t\t\t\tthis.mName = '';\n\t\t\t\tthis.mPosition = null;\n\t\t\t\tthis.mLookAt = null;\n\t\t\t\tthis.mUp = null;\n\t\t\t\tthis.mHorizontalFOV = 0;\n\t\t\t\tthis.mClipPlaneNear = 0;\n\t\t\t\tthis.mClipPlaneFar = 0;\n\t\t\t\tthis.mAspect = 0;\n\n\t\t\t}\n\n\t\t\tfunction aiScene() {\n\n\t\t\t\tthis.versionMajor = 0;\n\t\t\t\tthis.versionMinor = 0;\n\t\t\t\tthis.versionRevision = 0;\n\t\t\t\tthis.compileFlags = 0;\n\t\t\t\tthis.mFlags = 0;\n\t\t\t\tthis.mNumMeshes = 0;\n\t\t\t\tthis.mNumMaterials = 0;\n\t\t\t\tthis.mNumAnimations = 0;\n\t\t\t\tthis.mNumTextures = 0;\n\t\t\t\tthis.mNumLights = 0;\n\t\t\t\tthis.mNumCameras = 0;\n\t\t\t\tthis.mRootNode = null;\n\t\t\t\tthis.mMeshes = [];\n\t\t\t\tthis.mMaterials = [];\n\t\t\t\tthis.mAnimations = [];\n\t\t\t\tthis.mLights = [];\n\t\t\t\tthis.mCameras = [];\n\t\t\t\tthis.nodeToBoneMap = {};\n\t\t\t\tthis.findNode = function ( name, root ) {\n\n\t\t\t\t\tif ( ! root ) {\n\n\t\t\t\t\t\troot = this.mRootNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( root.mName == name ) {\n\n\t\t\t\t\t\treturn root;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < root.mChildren.length; i ++ ) {\n\n\t\t\t\t\t\tvar ret = this.findNode( name, root.mChildren[ i ] );\n\t\t\t\t\t\tif ( ret ) return ret;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t};\n\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\tthis.nodeCount = 0;\n\n\t\t\t\t\tmarkBones( this );\n\n\t\t\t\t\tvar o = this.mRootNode.toTHREE( this );\n\n\t\t\t\t\tfor ( var i in this.mMeshes )\n\t\t\t\t\t\tthis.mMeshes[ i ].hookupSkeletons( this );\n\n\t\t\t\t\tif ( this.mAnimations.length > 0 ) {\n\n\t\t\t\t\t\tvar a = this.mAnimations[ 0 ].toTHREE( this );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { object: o, animation: a };\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tfunction aiMatrix4() {\n\n\t\t\t\tthis.elements = [\n\t\t\t\t\t[],\n\t\t\t\t\t[],\n\t\t\t\t\t[],\n\t\t\t\t\t[]\n\t\t\t\t];\n\t\t\t\tthis.toTHREE = function () {\n\n\t\t\t\t\tvar m = new THREE.Matrix4();\n\n\t\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\t\tfor ( var i2 = 0; i2 < 4; ++ i2 ) {\n\n\t\t\t\t\t\t\tm.elements[ i * 4 + i2 ] = this.elements[ i2 ][ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn m;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar littleEndian = true;\n\n\t\t\tfunction readFloat( dataview ) {\n\n\t\t\t\tvar val = dataview.getFloat32( dataview.readOffset, littleEndian );\n\t\t\t\tdataview.readOffset += 4;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_double( dataview ) {\n\n\t\t\t\tvar val = dataview.getFloat64( dataview.readOffset, littleEndian );\n\t\t\t\tdataview.readOffset += 8;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_uint8_t( dataview ) {\n\n\t\t\t\tvar val = dataview.getUint8( dataview.readOffset );\n\t\t\t\tdataview.readOffset += 1;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_uint16_t( dataview ) {\n\n\t\t\t\tvar val = dataview.getUint16( dataview.readOffset, littleEndian );\n\t\t\t\tdataview.readOffset += 2;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_unsigned_int( dataview ) {\n\n\t\t\t\tvar val = dataview.getUint32( dataview.readOffset, littleEndian );\n\t\t\t\tdataview.readOffset += 4;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_uint32_t( dataview ) {\n\n\t\t\t\tvar val = dataview.getUint32( dataview.readOffset, littleEndian );\n\t\t\t\tdataview.readOffset += 4;\n\t\t\t\treturn val;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiVector3D( stream ) {\n\n\t\t\t\tvar v = new aiVector3D();\n\t\t\t\tv.x = readFloat( stream );\n\t\t\t\tv.y = readFloat( stream );\n\t\t\t\tv.z = readFloat( stream );\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiColor3D( stream ) {\n\n\t\t\t\tvar c = new aiColor3D();\n\t\t\t\tc.r = readFloat( stream );\n\t\t\t\tc.g = readFloat( stream );\n\t\t\t\tc.b = readFloat( stream );\n\t\t\t\treturn c;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiQuaternion( stream ) {\n\n\t\t\t\tvar v = new aiQuaternion();\n\t\t\t\tv.w = readFloat( stream );\n\t\t\t\tv.x = readFloat( stream );\n\t\t\t\tv.y = readFloat( stream );\n\t\t\t\tv.z = readFloat( stream );\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiString( stream ) {\n\n\t\t\t\tvar s = new aiString();\n\t\t\t\tvar stringlengthbytes = Read_unsigned_int( stream );\n\t\t\t\tstream.ReadBytes( s.data, 1, stringlengthbytes );\n\t\t\t\treturn s.toString();\n\n\t\t\t}\n\n\t\t\tfunction Read_aiVertexWeight( stream ) {\n\n\t\t\t\tvar w = new aiVertexWeight();\n\t\t\t\tw.mVertexId = Read_unsigned_int( stream );\n\t\t\t\tw.mWeight = readFloat( stream );\n\t\t\t\treturn w;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiMatrix4x4( stream ) {\n\n\t\t\t\tvar m = new aiMatrix4();\n\n\t\t\t\tfor ( var i = 0; i < 4; ++ i ) {\n\n\t\t\t\t\tfor ( var i2 = 0; i2 < 4; ++ i2 ) {\n\n\t\t\t\t\t\tm.elements[ i ][ i2 ] = readFloat( stream );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn m;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiVectorKey( stream ) {\n\n\t\t\t\tvar v = new aiVectorKey();\n\t\t\t\tv.mTime = Read_double( stream );\n\t\t\t\tv.mValue = Read_aiVector3D( stream );\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction Read_aiQuatKey( stream ) {\n\n\t\t\t\tvar v = new aiQuatKey();\n\t\t\t\tv.mTime = Read_double( stream );\n\t\t\t\tv.mValue = Read_aiQuaternion( stream );\n\t\t\t\treturn v;\n\n\t\t\t}\n\n\t\t\tfunction ReadArray_aiVertexWeight( stream, data, size ) {\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) data[ i ] = Read_aiVertexWeight( stream );\n\n\t\t\t}\n\n\t\t\tfunction ReadArray_aiVectorKey( stream, data, size ) {\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) data[ i ] = Read_aiVectorKey( stream );\n\n\t\t\t}\n\n\t\t\tfunction ReadArray_aiQuatKey( stream, data, size ) {\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) data[ i ] = Read_aiQuatKey( stream );\n\n\t\t\t}\n\n\t\t\tfunction ReadBounds( stream, T /*p*/, n ) {\n\n\t\t\t\t// not sure what to do here, the data isn't really useful.\n\t\t\t\treturn stream.Seek( sizeof( T ) * n, aiOrigin_CUR );\n\n\t\t\t}\n\n\t\t\tfunction ai_assert( bool ) {\n\n\t\t\t\tif ( ! bool )\n\t\t\t\t\tthrow ( \"asset failed\" );\n\n\t\t\t}\n\n\t\t\tfunction ReadBinaryNode( stream, parent, depth ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AINODE );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tvar node = new aiNode();\n\t\t\t\tnode.mParent = parent;\n\t\t\t\tnode.mDepth = depth;\n\t\t\t\tnode.mName = Read_aiString( stream );\n\t\t\t\tnode.mTransformation = Read_aiMatrix4x4( stream );\n\t\t\t\tnode.mNumChildren = Read_unsigned_int( stream );\n\t\t\t\tnode.mNumMeshes = Read_unsigned_int( stream );\n\n\t\t\t\tif ( node.mNumMeshes ) {\n\n\t\t\t\t\tnode.mMeshes = [];\n\n\t\t\t\t\tfor ( var i = 0; i < node.mNumMeshes; ++ i ) {\n\n\t\t\t\t\t\tnode.mMeshes[ i ] = Read_unsigned_int( stream );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( node.mNumChildren ) {\n\n\t\t\t\t\tnode.mChildren = [];\n\n\t\t\t\t\tfor ( var i = 0; i < node.mNumChildren; ++ i ) {\n\n\t\t\t\t\t\tvar node2 = ReadBinaryNode( stream, node, depth ++ );\n\t\t\t\t\t\tnode.mChildren[ i ] = node2;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t\t// -----------------------------------------------------------------------------------\n\n\t\t\tfunction ReadBinaryBone( stream, b ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIBONE );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tb.mName = Read_aiString( stream );\n\t\t\t\tb.mNumWeights = Read_unsigned_int( stream );\n\t\t\t\tb.mOffsetMatrix = Read_aiMatrix4x4( stream );\n\t\t\t\t// for the moment we write dumb min/max values for the bones, too.\n\t\t\t\t// maybe I'll add a better, hash-like solution later\n\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\tReadBounds( stream, b.mWeights, b.mNumWeights );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tb.mWeights = [];\n\t\t\t\t\tReadArray_aiVertexWeight( stream, b.mWeights, b.mNumWeights );\n\n\t\t\t\t}\n\n\t\t\t\treturn b;\n\n\t\t\t}\n\n\t\t\tfunction ReadBinaryMesh( stream, mesh ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIMESH );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tmesh.mPrimitiveTypes = Read_unsigned_int( stream );\n\t\t\t\tmesh.mNumVertices = Read_unsigned_int( stream );\n\t\t\t\tmesh.mNumFaces = Read_unsigned_int( stream );\n\t\t\t\tmesh.mNumBones = Read_unsigned_int( stream );\n\t\t\t\tmesh.mMaterialIndex = Read_unsigned_int( stream );\n\t\t\t\tmesh.mNumUVComponents = [];\n\t\t\t\t// first of all, write bits for all existent vertex components\n\t\t\t\tvar c = Read_unsigned_int( stream );\n\n\t\t\t\tif ( c & ASSBIN_MESH_HAS_POSITIONS ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, mesh.mVertices, mesh.mNumVertices );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tmesh.mVertices = [];\n\t\t\t\t\t\tmesh.mVertexBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\n\t\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( c & ASSBIN_MESH_HAS_NORMALS ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, mesh.mNormals, mesh.mNumVertices );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tmesh.mNormals = [];\n\t\t\t\t\t\tmesh.mNormalBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\n\t\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, mesh.mTangents, mesh.mNumVertices );\n\t\t\t\t\t\tReadBounds( stream, mesh.mBitangents, mesh.mNumVertices );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tmesh.mTangents = [];\n\t\t\t\t\t\tmesh.mTangentBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\n\t\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\n\t\t\t\t\t\tmesh.mBitangents = [];\n\t\t\t\t\t\tmesh.mBitangentBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4 );\n\t\t\t\t\t\tstream.Seek( mesh.mNumVertices * 3 * 4, aiOrigin_CUR );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++ n ) {\n\n\t\t\t\t\tif ( ! ( c & ASSBIN_MESH_HAS_COLOR( n ) ) ) break;\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, mesh.mColors[ n ], mesh.mNumVertices );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tmesh.mColors[ n ] = [];\n\t\t\t\t\t\tmesh.mColorBuffer = stream.subArray32( stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4 );\n\t\t\t\t\t\tstream.Seek( mesh.mNumVertices * 4 * 4, aiOrigin_CUR );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmesh.mTexCoordsBuffers = [];\n\n\t\t\t\tfor ( var n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++ n ) {\n\n\t\t\t\t\tif ( ! ( c & ASSBIN_MESH_HAS_TEXCOORD( n ) ) ) break;\n\n\t\t\t\t\t// write number of UV components\n\t\t\t\t\tmesh.mNumUVComponents[ n ] = Read_unsigned_int( stream );\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, mesh.mTextureCoords[ n ], mesh.mNumVertices );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tmesh.mTextureCoords[ n ] = [];\n\t\t\t\t\t\t//note that assbin always writes 3d texcoords\n\t\t\t\t\t\tmesh.mTexCoordsBuffers[ n ] = [];\n\n\t\t\t\t\t\tfor ( var uv = 0; uv < mesh.mNumVertices; uv ++ ) {\n\n\t\t\t\t\t\t\tmesh.mTexCoordsBuffers[ n ].push( readFloat( stream ) );\n\t\t\t\t\t\t\tmesh.mTexCoordsBuffers[ n ].push( readFloat( stream ) );\n\t\t\t\t\t\t\treadFloat( stream );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// write faces. There are no floating-point calculations involved\n\t\t\t\t// in these, so we can write a simple hash over the face data\n\t\t\t\t// to the dump file. We generate a single 32 Bit hash for 512 faces\n\t\t\t\t// using Assimp's standard hashing function.\n\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\tRead_unsigned_int( stream );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t// if there are less than 2^16 vertices, we can simply use 16 bit integers ...\n\t\t\t\t\tmesh.mFaces = [];\n\t\t\t\t\tmesh.mIndexArray = [];\n\n\t\t\t\t\tfor ( var i = 0; i < mesh.mNumFaces; ++ i ) {\n\n\t\t\t\t\t\tvar f = mesh.mFaces[ i ] = new aiFace();\n\t\t\t\t\t\t// BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\n\t\t\t\t\t\tf.mNumIndices = Read_uint16_t( stream );\n\t\t\t\t\t\tf.mIndices = [];\n\n\t\t\t\t\t\tfor ( var a = 0; a < f.mNumIndices; ++ a ) {\n\n\t\t\t\t\t\t\tif ( mesh.mNumVertices < ( 1 << 16 ) ) {\n\n\t\t\t\t\t\t\t\tf.mIndices[ a ] = Read_uint16_t( stream );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tf.mIndices[ a ] = Read_unsigned_int( stream );\n\n\t\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( f.mNumIndices === 3 ) {\n\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 0 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 1 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 2 ] );\n\n\t\t\t\t\t\t} else if ( f.mNumIndices === 4 ) {\n\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 0 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 1 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 2 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 2 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 3 ] );\n\t\t\t\t\t\t\tmesh.mIndexArray.push( f.mIndices[ 0 ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthrow ( new Error( \"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\" ) );\n\n\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// write bones\n\t\t\t\tif ( mesh.mNumBones ) {\n\n\t\t\t\t\tmesh.mBones = [];\n\n\t\t\t\t\tfor ( var a = 0; a < mesh.mNumBones; ++ a ) {\n\n\t\t\t\t\t\tmesh.mBones[ a ] = new aiBone();\n\t\t\t\t\t\tReadBinaryBone( stream, mesh.mBones[ a ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction ReadBinaryMaterialProperty( stream, prop ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tprop.mKey = Read_aiString( stream );\n\t\t\t\tprop.mSemantic = Read_unsigned_int( stream );\n\t\t\t\tprop.mIndex = Read_unsigned_int( stream );\n\t\t\t\tprop.mDataLength = Read_unsigned_int( stream );\n\t\t\t\tprop.mType = Read_unsigned_int( stream );\n\t\t\t\tprop.mData = [];\n\t\t\t\tstream.ReadBytes( prop.mData, 1, prop.mDataLength );\n\n\t\t\t}\n\n\t\t\t// -----------------------------------------------------------------------------------\n\n\t\t\tfunction ReadBinaryMaterial( stream, mat ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIMATERIAL );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tmat.mNumAllocated = mat.mNumProperties = Read_unsigned_int( stream );\n\n\t\t\t\tif ( mat.mNumProperties ) {\n\n\t\t\t\t\tif ( mat.mProperties ) {\n\n\t\t\t\t\t\tdelete mat.mProperties;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmat.mProperties = [];\n\n\t\t\t\t\tfor ( var i = 0; i < mat.mNumProperties; ++ i ) {\n\n\t\t\t\t\t\tmat.mProperties[ i ] = new aiMaterialProperty();\n\t\t\t\t\t\tReadBinaryMaterialProperty( stream, mat.mProperties[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// -----------------------------------------------------------------------------------\n\t\t\tfunction ReadBinaryNodeAnim( stream, nd ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AINODEANIM );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tnd.mNodeName = Read_aiString( stream );\n\t\t\t\tnd.mNumPositionKeys = Read_unsigned_int( stream );\n\t\t\t\tnd.mNumRotationKeys = Read_unsigned_int( stream );\n\t\t\t\tnd.mNumScalingKeys = Read_unsigned_int( stream );\n\t\t\t\tnd.mPreState = Read_unsigned_int( stream );\n\t\t\t\tnd.mPostState = Read_unsigned_int( stream );\n\n\t\t\t\tif ( nd.mNumPositionKeys ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, nd.mPositionKeys, nd.mNumPositionKeys );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// else write as usual\n\n\t\t\t\t\t\tnd.mPositionKeys = [];\n\t\t\t\t\t\tReadArray_aiVectorKey( stream, nd.mPositionKeys, nd.mNumPositionKeys );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( nd.mNumRotationKeys ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, nd.mRotationKeys, nd.mNumRotationKeys );\n\n\t\t\t\t\t} else {\n\n\t\t\t \t\t\t// else write as usual\n\n\t\t\t\t\t\tnd.mRotationKeys = [];\n\t\t\t\t\t\tReadArray_aiQuatKey( stream, nd.mRotationKeys, nd.mNumRotationKeys );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( nd.mNumScalingKeys ) {\n\n\t\t\t\t\tif ( shortened ) {\n\n\t\t\t\t\t\tReadBounds( stream, nd.mScalingKeys, nd.mNumScalingKeys );\n\n\t\t\t\t\t} else {\n\n\t\t \t\t\t\t// else write as usual\n\n\t\t\t\t\t\tnd.mScalingKeys = [];\n\t\t\t\t\t\tReadArray_aiVectorKey( stream, nd.mScalingKeys, nd.mNumScalingKeys );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// -----------------------------------------------------------------------------------\n\t\t\tfunction ReadBinaryAnim( stream, anim ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AIANIMATION );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tanim.mName = Read_aiString( stream );\n\t\t\t\tanim.mDuration = Read_double( stream );\n\t\t\t\tanim.mTicksPerSecond = Read_double( stream );\n\t\t\t\tanim.mNumChannels = Read_unsigned_int( stream );\n\n\t\t\t\tif ( anim.mNumChannels ) {\n\n\t\t\t\t\tanim.mChannels = [];\n\n\t\t\t\t\tfor ( var a = 0; a < anim.mNumChannels; ++ a ) {\n\n\t\t\t\t\t\tanim.mChannels[ a ] = new aiNodeAnim();\n\t\t\t\t\t\tReadBinaryNodeAnim( stream, anim.mChannels[ a ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction ReadBinaryTexture( stream, tex ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AITEXTURE );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\ttex.mWidth = Read_unsigned_int( stream );\n\t\t\t\ttex.mHeight = Read_unsigned_int( stream );\n\t\t\t\tstream.ReadBytes( tex.achFormatHint, 1, 4 );\n\n\t\t\t\tif ( ! shortened ) {\n\n\t\t\t\t\tif ( ! tex.mHeight ) {\n\n\t\t\t\t\t\ttex.pcData = [];\n\t\t\t\t\t\tstream.ReadBytes( tex.pcData, 1, tex.mWidth );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttex.pcData = [];\n\t\t\t\t\t\tstream.ReadBytes( tex.pcData, 1, tex.mWidth * tex.mHeight * 4 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// -----------------------------------------------------------------------------------\n\t\t\tfunction ReadBinaryLight( stream, l ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AILIGHT );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tl.mName = Read_aiString( stream );\n\t\t\t\tl.mType = Read_unsigned_int( stream );\n\n\t\t\t\tif ( l.mType != aiLightSource_DIRECTIONAL ) {\n\n\t\t\t\t\tl.mAttenuationConstant = readFloat( stream );\n\t\t\t\t\tl.mAttenuationLinear = readFloat( stream );\n\t\t\t\t\tl.mAttenuationQuadratic = readFloat( stream );\n\n\t\t\t\t}\n\n\t\t\t\tl.mColorDiffuse = Read_aiColor3D( stream );\n\t\t\t\tl.mColorSpecular = Read_aiColor3D( stream );\n\t\t\t\tl.mColorAmbient = Read_aiColor3D( stream );\n\n\t\t\t\tif ( l.mType == aiLightSource_SPOT ) {\n\n\t\t\t\t\tl.mAngleInnerCone = readFloat( stream );\n\t\t\t\t\tl.mAngleOuterCone = readFloat( stream );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// -----------------------------------------------------------------------------------\n\t\t\tfunction ReadBinaryCamera( stream, cam ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AICAMERA );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tcam.mName = Read_aiString( stream );\n\t\t\t\tcam.mPosition = Read_aiVector3D( stream );\n\t\t\t\tcam.mLookAt = Read_aiVector3D( stream );\n\t\t\t\tcam.mUp = Read_aiVector3D( stream );\n\t\t\t\tcam.mHorizontalFOV = readFloat( stream );\n\t\t\t\tcam.mClipPlaneNear = readFloat( stream );\n\t\t\t\tcam.mClipPlaneFar = readFloat( stream );\n\t\t\t\tcam.mAspect = readFloat( stream );\n\n\t\t\t}\n\n\t\t\tfunction ReadBinaryScene( stream, scene ) {\n\n\t\t\t\tvar chunkID = Read_uint32_t( stream );\n\t\t\t\tai_assert( chunkID == ASSBIN_CHUNK_AISCENE );\n\t\t\t\t/*uint32_t size =*/\n\t\t\t\tRead_uint32_t( stream );\n\t\t\t\tscene.mFlags = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumMeshes = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumMaterials = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumAnimations = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumTextures = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumLights = Read_unsigned_int( stream );\n\t\t\t\tscene.mNumCameras = Read_unsigned_int( stream );\n\t\t\t\t// Read node graph\n\t\t\t\tscene.mRootNode = new aiNode();\n\t\t\t\tscene.mRootNode = ReadBinaryNode( stream, null, 0 );\n\t\t\t\t// Read all meshes\n\t\t\t\tif ( scene.mNumMeshes ) {\n\n\t\t\t\t\tscene.mMeshes = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumMeshes; ++ i ) {\n\n\t\t\t\t\t\tscene.mMeshes[ i ] = new aiMesh();\n\t\t\t\t\t\tReadBinaryMesh( stream, scene.mMeshes[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// Read materials\n\t\t\t\tif ( scene.mNumMaterials ) {\n\n\t\t\t\t\tscene.mMaterials = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumMaterials; ++ i ) {\n\n\t\t\t\t\t\tscene.mMaterials[ i ] = new aiMaterial();\n\t\t\t\t\t\tReadBinaryMaterial( stream, scene.mMaterials[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// Read all animations\n\t\t\t\tif ( scene.mNumAnimations ) {\n\n\t\t\t\t\tscene.mAnimations = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumAnimations; ++ i ) {\n\n\t\t\t\t\t\tscene.mAnimations[ i ] = new aiAnimation();\n\t\t\t\t\t\tReadBinaryAnim( stream, scene.mAnimations[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// Read all textures\n\t\t\t\tif ( scene.mNumTextures ) {\n\n\t\t\t\t\tscene.mTextures = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumTextures; ++ i ) {\n\n\t\t\t\t\t\tscene.mTextures[ i ] = new aiTexture();\n\t\t\t\t\t\tReadBinaryTexture( stream, scene.mTextures[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// Read lights\n\t\t\t\tif ( scene.mNumLights ) {\n\n\t\t\t\t\tscene.mLights = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumLights; ++ i ) {\n\n\t\t\t\t\t\tscene.mLights[ i ] = new aiLight();\n\t\t\t\t\t\tReadBinaryLight( stream, scene.mLights[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// Read cameras\n\t\t\t\tif ( scene.mNumCameras ) {\n\n\t\t\t\t\tscene.mCameras = [];\n\n\t\t\t\t\tfor ( var i = 0; i < scene.mNumCameras; ++ i ) {\n\n\t\t\t\t\t\tscene.mCameras[ i ] = new aiCamera();\n\t\t\t\t\t\tReadBinaryCamera( stream, scene.mCameras[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tvar aiOrigin_CUR = 0;\n\t\t\tvar aiOrigin_BEG = 1;\n\n\t\t\tfunction extendStream( stream ) {\n\n\t\t\t\tstream.readOffset = 0;\n\t\t\t\tstream.Seek = function ( off, ori ) {\n\n\t\t\t\t\tif ( ori == aiOrigin_CUR ) {\n\n\t\t\t\t\t\tstream.readOffset += off;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( ori == aiOrigin_BEG ) {\n\n\t\t\t\t\t\tstream.readOffset = off;\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tstream.ReadBytes = function ( buff, size, n ) {\n\n\t\t\t\t\tvar bytes = size * n;\n\t\t\t\t\tfor ( var i = 0; i < bytes; i ++ )\n\t\t\t\t\t\tbuff[ i ] = Read_uint8_t( this );\n\n\t\t\t\t};\n\n\t\t\t\tstream.subArray32 = function ( start, end ) {\n\n\t\t\t\t\tvar buff = this.buffer;\n\t\t\t\t\tvar newbuff = buff.slice( start, end );\n\t\t\t\t\treturn new Float32Array( newbuff );\n\n\t\t\t\t};\n\n\t\t\t\tstream.subArrayUint16 = function ( start, end ) {\n\n\t\t\t\t\tvar buff = this.buffer;\n\t\t\t\t\tvar newbuff = buff.slice( start, end );\n\t\t\t\t\treturn new Uint16Array( newbuff );\n\n\t\t\t\t};\n\n\t\t\t\tstream.subArrayUint8 = function ( start, end ) {\n\n\t\t\t\t\tvar buff = this.buffer;\n\t\t\t\t\tvar newbuff = buff.slice( start, end );\n\t\t\t\t\treturn new Uint8Array( newbuff );\n\n\t\t\t\t};\n\n\t\t\t\tstream.subArrayUint32 = function ( start, end ) {\n\n\t\t\t\t\tvar buff = this.buffer;\n\t\t\t\t\tvar newbuff = buff.slice( start, end );\n\t\t\t\t\treturn new Uint32Array( newbuff );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar shortened, compressed;\n\n\t\t\tfunction InternReadFile( pFiledata ) {\n\n\t\t\t\tvar pScene = new aiScene();\n\t\t\t\tvar stream = new DataView( pFiledata );\n\t\t\t\textendStream( stream );\n\t\t\t\tstream.Seek( 44, aiOrigin_CUR ); // signature\n\t\t\t\t/*unsigned int versionMajor =*/\n\t\t\t\tpScene.versionMajor = Read_unsigned_int( stream );\n\t\t\t\t/*unsigned int versionMinor =*/\n\t\t\t\tpScene.versionMinor = Read_unsigned_int( stream );\n\t\t\t\t/*unsigned int versionRevision =*/\n\t\t\t\tpScene.versionRevision = Read_unsigned_int( stream );\n\t\t\t\t/*unsigned int compileFlags =*/\n\t\t\t\tpScene.compileFlags = Read_unsigned_int( stream );\n\t\t\t\tshortened = Read_uint16_t( stream ) > 0;\n\t\t\t\tcompressed = Read_uint16_t( stream ) > 0;\n\t\t\t\tif ( shortened )\n\t\t\t\t\tthrow \"Shortened binaries are not supported!\";\n\t\t\t\tstream.Seek( 256, aiOrigin_CUR ); // original filename\n\t\t\t\tstream.Seek( 128, aiOrigin_CUR ); // options\n\t\t\t\tstream.Seek( 64, aiOrigin_CUR ); // padding\n\t\t\t\tif ( compressed ) {\n\n\t\t\t\t\tvar uncompressedSize = Read_uint32_t( stream );\n\t\t\t\t\tvar compressedSize = stream.FileSize() - stream.Tell();\n\t\t\t\t\tvar compressedData = [];\n\t\t\t\t\tstream.Read( compressedData, 1, compressedSize );\n\t\t\t\t\tvar uncompressedData = [];\n\t\t\t\t\tuncompress( uncompressedData, uncompressedSize, compressedData, compressedSize );\n\t\t\t\t\tvar buff = new ArrayBuffer( uncompressedData );\n\t\t\t\t\tReadBinaryScene( buff, pScene );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tReadBinaryScene( stream, pScene );\n\n\t\t\t\t}\n\n\t\t\t\treturn pScene.toTHREE();\n\n\t\t\t}\n\n\t\t\treturn InternReadFile( buffer );\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.AssimpLoader;\n});\n"]}