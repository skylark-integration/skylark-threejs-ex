{"version":3,"sources":["loaders/EXRLoader.js"],"names":["define","THREE","threex","Inflate","EXRLoader","manager","DataTextureLoader","call","this","type","FloatType","prototype","Object","assign","create","constructor","parse","buffer","USHORT_RANGE","BITMAP_SIZE","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","HUF_DECMASK","SHORT_ZEROCODE_RUN","LONG_ZEROCODE_RUN","SHORTEST_LONG_RUN","ULONG_SIZE","FLOAT32_SIZE","INT32_SIZE","INT16_SIZE","INT8_SIZE","STATIC_HUFFMAN","DEFLATE","UNKNOWN","LOSSY_DCT","RLE","logBase","Math","pow","getBitsReturn","l","c","lc","getBits","nBits","uInt8Array","inOffset","parseUint8Array","hufTableBuffer","Array","hufUnpackEncTable","inDataView","ni","im","iM","hcode","p","value","zerun","i","nc","hufCanonicalCodeTable","hufLength","code","hufCode","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","Uint8Array","s","Int16","ref","UInt16","wdec14Return","a","b","wdec14","h","ls","hs","ai","as","bs","wav2Decode","j","nx","ox","ny","oy","p2","n","i00","i01","i10","i11","py","ey","oy1","oy2","ox1","ox2","px","ex","p01","p11","p10","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","hdec","len","lit","hufClearDecTable","hdecod","pl","plOffset","hufBuildDecTable","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","hufDecode","predictor","source","t","length","d","interleaveScalar","out","t1","t2","floor","stop","decodeRunLength","size","byteLength","reader","DataView","getInt8","count","push","getUint8","unRleAC","currAcComp","acBuffer","halfZigBlock","acValue","dctComp","dctInverse","data","cos","e","f","g","alpha","beta","theta","gamma","row","rowPtr","column","csc709Inverse","y","cb","cr","convertToHalf","src","dst","idx","encodeFloat16","toLinear","float","sign","abs","uncompressZIP","info","compressed","array","slice","offset","inflate","resize","verify","rawBuffer","decompress","tmpBuffer","uncompressDWA","viewer","width","lines","EXRHeader","channels","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","compression","channelRules","ruleSize","parseUint16","name","parseNullTerminatedString","parseUint8","index","Int8Array","channelData","cd","channel","decoded","pixelType","pLinear","height","cscSet","rule","Uint16Array","zlibInfo","dcBuffer","rleBuffer","outBufferEnd","rowOffsets","chan","rowPtrs","dataView","numFullBlocksX","numBlocksX","ceil","numBlocksY","leftoverX","leftoverY","currDcComp","dctData","rowBlock","comp","Float32Array","blocky","maxY","maxX","blockx","fill","decodeFloat16","setUint16","x","halfRow","getUint16","setFloat32","lossyDctDecode","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","TextDecoder","decode","parseUlong","uLong","getUint32","Uint32","Uint8","int","Number","getBigInt64","parseFloat32","getFloat32","binary","exponent","fraction","NaN","Infinity","floatView","int32View","Int32Array","val","bits","m","Uint16","parseValue","parseFixedLengthString","startOffset","xSampling","ySampling","parseChlist","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseChromaticities","parseCompression","xMin","yMin","xMax","yMax","parseBox2i","parseLineOrder","parseV2f","bufferDataView","keepReading","attributeName","attributeValue","uncompress","scanlineBlockSize","size_t","getValue","dataWindowHeight","dataWindow","tmpBufSize","bitmap","pizChannelData","minNonZero","maxNonZero","lut","k","reverseLutFromBitmap","start","nData","applyLut","tmpOffset","cp","end","set","HalfFloatType","numBlocks","byteArray","console","error","line","channelOffsets","R","G","B","A","compressionInfo","scanlineBlockIdx","line_y","true_y","channelID","cOff","header","format","RGBAFormat","setDataType","load","url","onLoad","onProgress","onError","texture","texData","encoding","LinearEncoding","minFilter","LinearFilter","magFilter","generateMipmaps","flipY","loaders"],"mappings":";;;;;;;AAAAA,QACI,kBACA,YACA,wBACD,SACCC,EACAC,EACAC,GAEA,aACA,IAAIC,EAAY,SAAUC,GACtBJ,EAAMK,kBAAkBC,KAAKC,KAAMH,GACnCG,KAAKC,KAAOR,EAAMS,WAgvCtB,OA9uCAN,EAAUO,UAAYC,OAAOC,OAAOD,OAAOE,OAAOb,EAAMK,kBAAkBK,YACtEI,YAAaX,EACbY,MAAO,SAAUC,GACb,MAAMC,EAAe,MACfC,EAAcD,GAAgB,EAE9BE,EAAc,GACdC,EAAc,MACdC,EAAc,GAAKF,EACnBG,EAAcD,EAAc,EAC5BE,EAAqB,GACrBC,EAAoB,GACpBC,EAAoB,EAAID,EAAoBD,EAC5CG,EAAa,EACbC,EAAe,EACfC,EAAa,EACbC,EAAa,EACbC,EAAY,EACZC,EAAiB,EACjBC,EAAU,EACVC,EAAU,EACVC,EAAY,EACZC,EAAM,EACNC,EAAUC,KAAKC,IAAI,UAAW,KAqBpC,MAAMC,GACFC,EAAG,EACHC,EAAG,EACHC,GAAI,GAER,SAASC,EAAQC,EAAOH,EAAGC,EAAIG,EAAYC,GACvC,KAAOJ,EAAKE,GACRH,EAAIA,GAAK,EAAIM,EAAgBF,EAAYC,GACzCJ,GAAM,EAEVA,GAAME,EACNL,EAAcC,EAAIC,GAAKC,GAAM,GAAKE,GAAS,EAC3CL,EAAcE,EAAIA,EAClBF,EAAcG,GAAKA,EAEvB,MAAMM,EAAiB,IAAIC,MAAM,IAkBjC,SAASC,EAAkBL,EAAYM,EAAYL,EAAUM,EAAIC,EAAIC,EAAIC,GAIrE,IAHA,IAAIC,EAAIV,EACJL,EAAI,EACJC,EAAK,EACFW,GAAMC,EAAID,IAAM,CACnB,GAAIG,EAAEC,MAAQX,EAASW,MAAQL,EAC3B,OAAO,EACXT,EAAQ,EAAGF,EAAGC,EAAIG,EAAYW,GAC9B,IAAIhB,EAAID,EAAcC,EAItB,GAHAC,EAAIF,EAAcE,EAClBC,EAAKH,EAAcG,GACnBa,EAAMF,GAAMb,EACRA,GAAKhB,EAAmB,CACxB,GAAIgC,EAAEC,MAAQX,EAASW,MAAQL,EAC3B,KAAM,yCAEVT,EAAQ,EAAGF,EAAGC,EAAIG,EAAYW,GAC9B,IAAIE,EAAQnB,EAAcC,EAAIf,EAG9B,GAFAgB,EAAIF,EAAcE,EAClBC,EAAKH,EAAcG,GACfW,EAAKK,EAAQJ,EAAK,EAClB,KAAM,yCAEV,KAAOI,KACHH,EAAMF,KAAQ,EAClBA,SACG,GAAIb,GAAKjB,EAAoB,CAEhC,GAAI8B,GADAK,EAAQlB,EAAIjB,EAAqB,GACpB+B,EAAK,EAClB,KAAM,yCAEV,KAAOI,KACHH,EAAMF,KAAQ,EAClBA,MAlDZ,SAA+BE,GAC3B,IAAK,IAAII,EAAI,EAAGA,GAAK,KAAMA,EACvBX,EAAeW,GAAK,EACxB,IAASA,EAAI,EAAGA,EAAIvC,IAAeuC,EAC/BX,EAAeO,EAAMI,KAAO,EAChC,IAAIlB,EAAI,EACR,IAASkB,EAAI,GAAIA,EAAI,IAAKA,EAAG,CACzB,IAAIC,EAAKnB,EAAIO,EAAeW,IAAM,EAClCX,EAAeW,GAAKlB,EACpBA,EAAImB,EAER,IAASD,EAAI,EAAGA,EAAIvC,IAAeuC,EAAG,CAClC,IAAInB,EAAIe,EAAMI,GACVnB,EAAI,IACJe,EAAMI,GAAKnB,EAAIQ,EAAeR,MAAQ,IAuC9CqB,CAAsBN,GAE1B,SAASO,EAAUC,GACf,OAAc,GAAPA,EAEX,SAASC,EAAQD,GACb,OAAOA,GAAQ,EAwCnB,MAAME,GACFxB,EAAG,EACHC,GAAI,GAER,SAASwB,EAAQzB,EAAGC,EAAIG,EAAYC,GAChCL,EAAIA,GAAK,EAAIM,EAAgBF,EAAYC,GACzCJ,GAAM,EACNuB,EAAcxB,EAAIA,EAClBwB,EAAcvB,GAAKA,EAEvB,MAAMyB,GACF1B,EAAG,EACHC,GAAI,GAER,SAAS0B,EAAQC,EAAIC,EAAK7B,EAAGC,EAAIG,EAAYM,EAAYL,EAAUyB,EAAWC,EAAiBC,GAC3F,GAAIJ,GAAMC,EAAK,CACP5B,EAAK,IACLwB,EAAQzB,EAAGC,EAAIG,EAAYC,GAC3BL,EAAIwB,EAAcxB,EAClBC,EAAKuB,EAAcvB,IAGvB,IAAIgC,EAAKjC,IADTC,GAAM,GAEFgC,EAAK,IAAIC,YAAYD,IAAK,GAC9B,GAAIF,EAAgBf,MAAQiB,EAAKD,EAC7B,OAAO,EAGX,IADA,IAAIG,EAAIL,EAAUC,EAAgBf,MAAQ,GACnCiB,KAAO,GACVH,EAAUC,EAAgBf,SAAWmB,MAEtC,CAAA,KAAIJ,EAAgBf,MAAQgB,GAG/B,OAAO,EAFPF,EAAUC,EAAgBf,SAAWY,EAIzCF,EAAc1B,EAAIA,EAClB0B,EAAczB,GAAKA,EAKvB,SAASmC,EAAMpB,GACX,IAAIqB,EAJR,SAAgBrB,GACZ,OAAe,MAARA,EAGGsB,CAAOtB,GACjB,OAAOqB,EAAM,MAAQA,EAAM,MAAQA,EAEvC,MAAME,GACFC,EAAG,EACHC,EAAG,GAEP,SAASC,EAAO3C,EAAG4C,GACf,IAAIC,EAAKR,EAAMrC,GACX8C,EAAKT,EAAMO,GAEXG,EAAKF,GAAW,EADXC,IAAAA,GACuB,GAC5BE,EAAKD,EACLE,EAAKF,EAHAD,EAITN,EAAaC,EAAIO,EACjBR,EAAaE,EAAIO,EAErB,SAASC,EAAW1E,EAAQ2E,EAAGC,EAAIC,EAAIC,EAAIC,GAIvC,IAHA,IAEIC,EAFAC,EAAIL,EAAKE,EAAKA,EAAKF,EACnBpC,EAAI,EAEDA,GAAKyC,GACRzC,IAAM,EAIV,IAFAwC,EADAxC,IAAM,EAENA,IAAM,EACCA,GAAK,GAAG,CAQX,IAPA,IAMI0C,EAAKC,EAAKC,EAAKC,EANfC,EAAK,EACLC,EAAKD,EAAKP,GAAMD,EAAKE,GACrBQ,EAAMT,EAAKvC,EACXiD,EAAMV,EAAKC,EACXU,EAAMb,EAAKrC,EACXmD,EAAMd,EAAKG,EAERM,GAAMC,EAAID,GAAMG,EAAK,CAGxB,IAFA,IAAIG,EAAKN,EACLO,EAAKP,EAAKT,GAAMD,EAAKI,GAClBY,GAAMC,EAAID,GAAMD,EAAK,CACxB,IAAIG,EAAMF,EAAKF,EAEXK,GADAC,EAAMJ,EAAKJ,GACCE,EAChBvB,EAAOnE,EAAO4F,EAAKjB,GAAI3E,EAAOgG,EAAMrB,IACpCO,EAAMlB,EAAaC,EACnBmB,EAAMpB,EAAaE,EACnBC,EAAOnE,EAAO8F,EAAMnB,GAAI3E,EAAO+F,EAAMpB,IACrCQ,EAAMnB,EAAaC,EACnBoB,EAAMrB,EAAaE,EACnBC,EAAOe,EAAKC,GACZnF,EAAO4F,EAAKjB,GAAKX,EAAaC,EAC9BjE,EAAO8F,EAAMnB,GAAKX,EAAaE,EAC/BC,EAAOiB,EAAKC,GACZrF,EAAOgG,EAAMrB,GAAKX,EAAaC,EAC/BjE,EAAO+F,EAAMpB,GAAKX,EAAaE,EAEnC,GAAIU,EAAKpC,EAAG,CACR,IAAIwD,EAAMJ,EAAKJ,EACfrB,EAAOnE,EAAO4F,EAAKjB,GAAI3E,EAAOgG,EAAMrB,IACpCO,EAAMlB,EAAaC,EACnBjE,EAAOgG,EAAMrB,GAAKX,EAAaE,EAC/BlE,EAAO4F,EAAKjB,GAAKO,GAGzB,GAAIJ,EAAKtC,EAGL,IAFIoD,EAAKN,EACLO,EAAKP,EAAKT,GAAMD,EAAKI,GAClBY,GAAMC,EAAID,GAAMD,EAAK,CACpBG,EAAMF,EAAKF,EACfvB,EAAOnE,EAAO4F,EAAKjB,GAAI3E,EAAO8F,EAAMnB,IACpCO,EAAMlB,EAAaC,EACnBjE,EAAO8F,EAAMnB,GAAKX,EAAaE,EAC/BlE,EAAO4F,EAAKjB,GAAKO,EAGzBF,EAAKxC,EACLA,IAAM,EAEV,OAAO8C,EA+DX,SAASW,EAAcpE,EAAYM,EAAYL,EAAUoE,EAAa3C,EAAW4C,GAC7E,IACIC,EAAkBtE,EAASW,MAC3BJ,EAAKgE,EAAYlE,EAAYL,GAC7BQ,EAAK+D,EAAYlE,EAAYL,GACjCA,EAASW,OAAS,EAClB,IAAIb,EAAQyE,EAAYlE,EAAYL,GAEpC,GADAA,EAASW,OAAS,EACdJ,EAAK,GAAKA,GAAMjC,GAAekC,EAAK,GAAKA,GAAMlC,EAC/C,KAAM,mCAEV,IAAIkG,EAAO,IAAIrE,MAAM7B,GACjBmG,EAAO,IAAItE,MAAM5B,GAIrB,GAjUJ,SAA0BkG,GACtB,IAAK,IAAI5D,EAAI,EAAGA,EAAItC,EAAasC,IAC7B4D,EAAK5D,MACL4D,EAAK5D,GAAG6D,IAAM,EACdD,EAAK5D,GAAG8D,IAAM,EACdF,EAAK5D,GAAGH,EAAI,KAyThBkE,CAAiBH,GAEjBrE,EAAkBL,EAAYM,EAAYL,EADjCoE,GAAepE,EAASW,MAAQ2D,GACe/D,EAAIC,EAAIgE,GAC5D1E,EAAQ,GAAKsE,GAAepE,EAASW,MAAQ2D,IAC7C,KAAM,sCA7Od,SAA0B7D,EAAOF,EAAIC,EAAIqE,GACrC,KAAOtE,GAAMC,EAAID,IAAM,CACnB,IAAIZ,EAAIuB,EAAQT,EAAMF,IAClBb,EAAIsB,EAAUP,EAAMF,IACxB,GAAIZ,GAAKD,EACL,KAAM,sBAEV,GAAIA,EAAIrB,EAAa,CAEjB,IADIyG,EAAKD,EAAOlF,GAAKD,EAAIrB,IAClBqG,IACH,KAAM,sBAGV,GADAI,EAAGH,MACCG,EAAGpE,EAAG,CACN,IAAIA,EAAIoE,EAAGpE,EACXoE,EAAGpE,EAAI,IAAIP,MAAM2E,EAAGH,KACpB,IAAK,IAAI9D,EAAI,EAAGA,EAAIiE,EAAGH,IAAM,IAAK9D,EAC9BiE,EAAGpE,EAAEG,GAAKH,EAAEG,QAGhBiE,EAAGpE,EAAI,IAAIP,MAAM,GAErB2E,EAAGpE,EAAEoE,EAAGH,IAAM,GAAKpE,OAChB,GAAIb,EACP,CAAA,IAAIqF,EAAW,EACf,IAASlE,EAAI,GAAKxC,EAAcqB,EAAGmB,EAAI,EAAGA,IAAK,CAC3C,IAAIiE,EACJ,IADIA,EAAKD,GAAQlF,GAAKtB,EAAcqB,GAAKqF,IAClCL,KAAOI,EAAGpE,EACb,KAAM,sBAEVoE,EAAGJ,IAAMhF,EACToF,EAAGH,IAAMpE,EACTwE,OA+MZC,CAAiBR,EAAMjE,EAAIC,EAAIiE,GAhFnC,SAAmBQ,EAAeC,EAAenF,EAAYM,EAAYL,EAAUM,EAAIkB,EAAK2D,EAAI1D,EAAW2D,GAKvG,IAJA,IAAIzF,EAAI,EACJC,EAAK,EACL+B,EAAqBwD,EACrBE,EAAc9F,KAAK+F,MAAMtF,EAASW,OAASL,EAAK,GAAK,GAClDN,EAASW,MAAQ0E,GAIpB,IAHAjE,EAAQzB,EAAGC,EAAIG,EAAYC,GAC3BL,EAAIwB,EAAcxB,EAClBC,EAAKuB,EAAcvB,GACZA,GAAMvB,GAGT,IADIyG,EAAKI,EADGvF,GAAKC,EAAKvB,EAAcG,IAE7BkG,IACH9E,GAAMkF,EAAGJ,IACTpD,EAAQwD,EAAGH,IAAKnD,EAAK7B,EAAGC,EAAIG,EAAYM,EAAYL,EAAUyB,EAAW2D,EAAWzD,GACpFhC,EAAI0B,EAAc1B,EAClBC,EAAKyB,EAAczB,OAChB,CACH,IAAKkF,EAAGpE,EACJ,KAAM,mBAEV,IAAImC,EACJ,IAAKA,EAAI,EAAGA,EAAIiC,EAAGH,IAAK9B,IAAK,CAEzB,IADA,IAAInD,EAAIsB,EAAUiE,EAAcH,EAAGpE,EAAEmC,KAC9BjD,EAAKF,GAAKM,EAASW,MAAQ0E,GAC9BjE,EAAQzB,EAAGC,EAAIG,EAAYC,GAC3BL,EAAIwB,EAAcxB,EAClBC,EAAKuB,EAAcvB,GAEvB,GAAIA,GAAMF,GACFwB,EAAQ+D,EAAcH,EAAGpE,EAAEmC,OAASlD,GAAKC,EAAKF,GAAK,GAAKA,GAAK,GAAI,CACjEE,GAAMF,EACN4B,EAAQwD,EAAGpE,EAAEmC,GAAIrB,EAAK7B,EAAGC,EAAIG,EAAYM,EAAYL,EAAUyB,EAAW2D,EAAWzD,GACrFhC,EAAI0B,EAAc1B,EAClBC,EAAKyB,EAAczB,GACnB,OAIZ,GAAIiD,GAAKiC,EAAGH,IACR,KAAM,mBAKtB,IAAI9D,EAAI,EAAIP,EAAK,EAGjB,IAFAX,IAAMkB,EACNjB,GAAMiB,EACCjB,EAAK,GAAG,CACX,IAAIkF,EACJ,KADIA,EAAKI,EAAcvF,GAAKtB,EAAcuB,EAAKpB,IACxCkG,IAMH,KAAM,mBALN9E,GAAMkF,EAAGJ,IACTpD,EAAQwD,EAAGH,IAAKnD,EAAK7B,EAAGC,EAAIG,EAAYM,EAAYL,EAAUyB,EAAW2D,EAAWzD,GACpFhC,EAAI0B,EAAc1B,EAClBC,EAAKyB,EAAczB,IA2B3B2F,CAAUf,EAAMC,EAAM1E,EAAYM,EAAYL,EAAUF,EAAOU,EAAI6D,EAAM5C,GAnBvDd,MAAO,IA0B7B,SAAS6E,EAAUC,GACf,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAOE,OAAQD,IAAK,CACpC,IAAIE,EAAIH,EAAOC,EAAI,GAAKD,EAAOC,GAAK,IACpCD,EAAOC,GAAKE,GAGpB,SAASC,EAAiBJ,EAAQK,GAK9B,IAJA,IAAIC,EAAK,EACLC,EAAKzG,KAAK0G,OAAOR,EAAOE,OAAS,GAAK,GACtC7D,EAAI,EACJoE,EAAOT,EAAOE,OAAS,IAEnB7D,EAAIoE,IAERJ,EAAIhE,KAAO2D,EAAOM,KACdjE,EAAIoE,KAERJ,EAAIhE,KAAO2D,EAAOO,KAG1B,SAASG,EAAgBV,GAKrB,IAJA,IAAIW,EAAOX,EAAOY,WACdP,EAAM,IAAI3F,MACVO,EAAI,EACJ4F,EAAS,IAAIC,SAASd,GACnBW,EAAO,GAAG,CACb,IAAI1G,EAAI4G,EAAOE,QAAQ9F,KACvB,GAAIhB,EAAI,EAAG,CAEP0G,IADIK,GAAS/G,GACG,EAChB,IAAK,IAAImB,EAAI,EAAGA,EAAI4F,EAAO5F,IACvBiF,EAAIY,KAAKJ,EAAOK,SAASjG,UAE1B,CACH,IAAI+F,EAAQ/G,EACZ0G,GAAQ,EACR,IAAIzF,EAAQ2F,EAAOK,SAASjG,KAC5B,IAASG,EAAI,EAAGA,EAAI4F,EAAQ,EAAG5F,IAC3BiF,EAAIY,KAAK/F,IAIrB,OAAOmF,EA8FX,SAASc,EAAQC,EAAYC,EAAUC,GAGnC,IAFA,IAAIC,EACAC,EAAU,EACPA,EAAU,IAEE,QADfD,EAAUF,EAASD,EAAWlG,QAE1BsG,EAAU,GACHD,GAAW,GAAK,IACvBC,GAAqB,IAAVD,GAEXD,EAAaE,GAAWD,EACxBC,KAEJJ,EAAWlG,QAqEnB,SAASuG,EAAWC,GAChB,MAAMhF,EAAI,GAAM5C,KAAK6H,IAAI,UACnBhF,EAAI,GAAM7C,KAAK6H,IAAI,YACnBzH,EAAI,GAAMJ,KAAK6H,IAAI,WACnBxB,EAAI,GAAMrG,KAAK6H,IAAI,EAAI,QAAU,IACjCC,EAAI,GAAM9H,KAAK6H,IAAI,YACnBE,EAAI,GAAM/H,KAAK6H,IAAI,EAAI,QAAU,GACjCG,EAAI,GAAMhI,KAAK6H,IAAI,aAKzB,IAJA,IAAII,EAAQ,IAAIrH,MAAM,GAClBsH,EAAO,IAAItH,MAAM,GACjBuH,EAAQ,IAAIvH,MAAM,GAClBwH,EAAQ,IAAIxH,MAAM,GACbyH,EAAM,EAAGA,EAAM,IAAKA,EAAK,CAC9B,IAAIC,EAAe,EAAND,EACbJ,EAAM,GAAK7H,EAAIwH,EAAKU,EAAS,GAC7BL,EAAM,GAAKF,EAAIH,EAAKU,EAAS,GAC7BL,EAAM,GAAK7H,EAAIwH,EAAKU,EAAS,GAC7BL,EAAM,GAAKF,EAAIH,EAAKU,EAAS,GAC7BJ,EAAK,GAAKrF,EAAI+E,EAAKU,EAAS,GAAKjC,EAAIuB,EAAKU,EAAS,GAAKR,EAAIF,EAAKU,EAAS,GAAKN,EAAIJ,EAAKU,EAAS,GACjGJ,EAAK,GAAK7B,EAAIuB,EAAKU,EAAS,GAAKN,EAAIJ,EAAKU,EAAS,GAAKzF,EAAI+E,EAAKU,EAAS,GAAKR,EAAIF,EAAKU,EAAS,GACjGJ,EAAK,GAAKJ,EAAIF,EAAKU,EAAS,GAAKzF,EAAI+E,EAAKU,EAAS,GAAKN,EAAIJ,EAAKU,EAAS,GAAKjC,EAAIuB,EAAKU,EAAS,GACjGJ,EAAK,GAAKF,EAAIJ,EAAKU,EAAS,GAAKR,EAAIF,EAAKU,EAAS,GAAKjC,EAAIuB,EAAKU,EAAS,GAAKzF,EAAI+E,EAAKU,EAAS,GACjGH,EAAM,GAAKvF,GAAKgF,EAAKU,EAAS,GAAKV,EAAKU,EAAS,IACjDH,EAAM,GAAKvF,GAAKgF,EAAKU,EAAS,GAAKV,EAAKU,EAAS,IACjDH,EAAM,GAAKF,EAAM,GAAKA,EAAM,GAC5BE,EAAM,GAAKF,EAAM,GAAKA,EAAM,GAC5BG,EAAM,GAAKD,EAAM,GAAKA,EAAM,GAC5BC,EAAM,GAAKD,EAAM,GAAKA,EAAM,GAC5BC,EAAM,GAAKD,EAAM,GAAKA,EAAM,GAC5BC,EAAM,GAAKD,EAAM,GAAKA,EAAM,GAC5BP,EAAKU,EAAS,GAAKF,EAAM,GAAKF,EAAK,GACnCN,EAAKU,EAAS,GAAKF,EAAM,GAAKF,EAAK,GACnCN,EAAKU,EAAS,GAAKF,EAAM,GAAKF,EAAK,GACnCN,EAAKU,EAAS,GAAKF,EAAM,GAAKF,EAAK,GACnCN,EAAKU,EAAS,GAAKF,EAAM,GAAKF,EAAK,GACnCN,EAAKU,EAAS,GAAKF,EAAM,GAAKF,EAAK,GACnCN,EAAKU,EAAS,GAAKF,EAAM,GAAKF,EAAK,GACnCN,EAAKU,EAAS,GAAKF,EAAM,GAAKF,EAAK,GAEvC,IAAK,IAAIK,EAAS,EAAGA,EAAS,IAAKA,EAC/BN,EAAM,GAAK7H,EAAIwH,EAAK,GAAKW,GACzBN,EAAM,GAAKF,EAAIH,EAAK,GAAKW,GACzBN,EAAM,GAAK7H,EAAIwH,EAAK,GAAKW,GACzBN,EAAM,GAAKF,EAAIH,EAAK,GAAKW,GACzBL,EAAK,GAAKrF,EAAI+E,EAAK,EAAIW,GAAUlC,EAAIuB,EAAK,GAAKW,GAAUT,EAAIF,EAAK,GAAKW,GAAUP,EAAIJ,EAAK,GAAKW,GAC/FL,EAAK,GAAK7B,EAAIuB,EAAK,EAAIW,GAAUP,EAAIJ,EAAK,GAAKW,GAAU1F,EAAI+E,EAAK,GAAKW,GAAUT,EAAIF,EAAK,GAAKW,GAC/FL,EAAK,GAAKJ,EAAIF,EAAK,EAAIW,GAAU1F,EAAI+E,EAAK,GAAKW,GAAUP,EAAIJ,EAAK,GAAKW,GAAUlC,EAAIuB,EAAK,GAAKW,GAC/FL,EAAK,GAAKF,EAAIJ,EAAK,EAAIW,GAAUT,EAAIF,EAAK,GAAKW,GAAUlC,EAAIuB,EAAK,GAAKW,GAAU1F,EAAI+E,EAAK,GAAKW,GAC/FJ,EAAM,GAAKvF,GAAKgF,EAAKW,GAAUX,EAAK,GAAKW,IACzCJ,EAAM,GAAKvF,GAAKgF,EAAKW,GAAUX,EAAK,GAAKW,IACzCJ,EAAM,GAAKF,EAAM,GAAKA,EAAM,GAC5BE,EAAM,GAAKF,EAAM,GAAKA,EAAM,GAC5BG,EAAM,GAAKD,EAAM,GAAKA,EAAM,GAC5BC,EAAM,GAAKD,EAAM,GAAKA,EAAM,GAC5BC,EAAM,GAAKD,EAAM,GAAKA,EAAM,GAC5BC,EAAM,GAAKD,EAAM,GAAKA,EAAM,GAC5BP,EAAK,EAAIW,GAAUH,EAAM,GAAKF,EAAK,GACnCN,EAAK,EAAIW,GAAUH,EAAM,GAAKF,EAAK,GACnCN,EAAK,GAAKW,GAAUH,EAAM,GAAKF,EAAK,GACpCN,EAAK,GAAKW,GAAUH,EAAM,GAAKF,EAAK,GACpCN,EAAK,GAAKW,GAAUH,EAAM,GAAKF,EAAK,GACpCN,EAAK,GAAKW,GAAUH,EAAM,GAAKF,EAAK,GACpCN,EAAK,GAAKW,GAAUH,EAAM,GAAKF,EAAK,GACpCN,EAAK,GAAKW,GAAUH,EAAM,GAAKF,EAAK,GAG5C,SAASM,EAAcZ,GACnB,IAAK,IAAItG,EAAI,EAAGA,EAAI,KAAMA,EAAG,CACzB,IAAImH,EAAIb,EAAK,GAAGtG,GACZoH,EAAKd,EAAK,GAAGtG,GACbqH,EAAKf,EAAK,GAAGtG,GACjBsG,EAAK,GAAGtG,GAAKmH,EAAI,OAASE,EAC1Bf,EAAK,GAAGtG,GAAKmH,EAAI,MAASC,EAAK,MAASC,EACxCf,EAAK,GAAGtG,GAAKmH,EAAI,OAASC,GAGlC,SAASE,EAAcC,EAAKC,EAAKC,GAC7B,IAAK,IAAIzH,EAAI,EAAGA,EAAI,KAAMA,EACtBwH,EAAIC,EAAMzH,GAAK0H,GAAcC,EAASJ,EAAIvH,KAGlD,SAAS2H,EAASC,GACd,OAAIA,GAAS,EACFlJ,KAAKmJ,KAAKD,GAASlJ,KAAKC,IAAID,KAAKoJ,IAAIF,GAAQ,KAE7ClJ,KAAKmJ,KAAKD,GAASlJ,KAAKC,IAAIF,EAASC,KAAKoJ,IAAIF,GAAS,GActE,SAASG,EAAcC,GACnB,IAAIC,EAAaD,EAAKE,MAAMC,MAAMH,EAAKI,OAAOtI,MAAOkI,EAAKI,OAAOtI,MAAQkI,EAAKzC,MAI1E8C,EAAU,IAAI9L,EAAQ0L,GACtBK,QAAQ,EACRC,QAAQ,IAERC,EAAY,IAAIxH,WAAWqH,EAAQI,aAAapL,QAChDqL,EAAY,IAAI1H,WAAWwH,EAAU1D,QAGzC,OAFAH,EAAU6D,GACVxD,EAAiBwD,EAAWE,GACrB,IAAIhD,SAASgD,EAAUrL,QAsDlC,SAASsL,EAAcX,GACnB,IAAIxI,EAAawI,EAAKY,OAClBzJ,GAAaW,MAAOkI,EAAKI,OAAOtI,OAChCc,EAAY,IAAII,WAAWgH,EAAKa,MAAQb,EAAKc,OAASC,GAAUC,SAASlE,OAASkD,EAAKnL,KAAOqB,IAC9F+K,GACAC,QAASC,EAAW3J,EAAYL,GAChCiK,wBAAyBD,EAAW3J,EAAYL,GAChDkK,sBAAuBF,EAAW3J,EAAYL,GAC9CmK,iBAAkBH,EAAW3J,EAAYL,GACzCoK,iBAAkBJ,EAAW3J,EAAYL,GACzCqK,kBAAmBL,EAAW3J,EAAYL,GAC1CsK,oBAAqBN,EAAW3J,EAAYL,GAC5CuK,WAAYP,EAAW3J,EAAYL,GACnCwK,yBAA0BR,EAAW3J,EAAYL,GACjDyK,yBAA0BT,EAAW3J,EAAYL,GACjD0K,cAAeV,EAAW3J,EAAYL,IAE1C,GAAI8J,EAAUC,QAAU,EACpB,KAAM,oBAAsBH,GAAUe,YAAc,YAAcb,EAAUC,QAAU,kBAG1F,IAFA,IAAIa,EAAe,IAAIzK,MACnB0K,EAAWC,GAAYzK,EAAYL,GAAYjB,EAC5C8L,EAAW,GAAG,CACjB,IAAIE,EAAOC,EAA0B3K,EAAWnC,OAAQ8B,GACpDW,EAAQsK,EAAW5K,EAAYL,GAC/B2K,EAAchK,GAAS,EAAI,EAE3BuK,EAAQ,IAAIC,YADLxK,GAAS,GAAK,IACQ,GAC7BjD,EAAOuN,EAAW5K,EAAYL,GAClC4K,EAAalE,MACTqE,KAAMA,EACNG,MAAOA,EACPxN,KAAMA,EACNiN,YAAaA,IAEjBE,GAAYE,EAAKpF,OAAS,EAI9B,IAFA,IAAIkE,EAAWD,GAAUC,SACrBuB,EAAc,IAAIjL,MAAM0I,EAAKgB,UACxBhJ,EAAI,EAAGA,EAAIgI,EAAKgB,WAAYhJ,EAAG,CACpC,IAAIwK,EAAKD,EAAYvK,MACjByK,EAAUzB,EAAShJ,GACvBwK,EAAGN,KAAOO,EAAQP,KAClBM,EAAGV,YAAcxL,EACjBkM,EAAGE,SAAU,EACbF,EAAG3N,KAAO4N,EAAQE,UAClBH,EAAGI,QAAUH,EAAQG,QACrBJ,EAAG3B,MAAQb,EAAKa,MAChB2B,EAAGK,OAAS7C,EAAKc,MAGrB,IADA,IAAIgC,GAAWrD,IAAK,IAAInI,MAAM,IACrB8I,EAAS,EAAGA,EAASJ,EAAKgB,WAAYZ,EAE3C,IADIoC,EAAKD,EAAYnC,GACZpI,EAAI,EAAGA,EAAI+J,EAAajF,SAAU9E,EAAG,CAC1C,IAAI+K,EAAOhB,EAAa/J,GACpBwK,EAAGN,MAAQa,EAAKb,OAChBM,EAAGV,YAAciB,EAAKjB,YAClBiB,EAAKV,OAAS,IACdS,EAAOrD,IAAIsD,EAAKV,OAASjC,GAE7BoC,EAAGpC,OAASA,GAIxB,GAAIa,EAAUK,iBAAmB,EAC7B,OAAQL,EAAUY,eAClB,KAAKzL,EACD,IAAI6H,EAAW,IAAI+E,YAAY/B,EAAUU,0BACzCrG,EAAc0E,EAAKE,MAAO1I,EAAYL,EAAU8J,EAAUK,iBAAkBrD,EAAUgD,EAAUU,0BAChG,MACJ,KAAKtL,EACD,IAAI4J,EAAaD,EAAKE,MAAMC,MAAMhJ,EAASW,MAAOX,EAASW,MAAQmJ,EAAUU,0BACzEtB,EAAU,IAAI9L,EAAQ0L,GACtBK,QAAQ,EACRC,QAAQ,IAERtC,EAAW,IAAI+E,YAAY3C,EAAQI,aAAapL,QACpD8B,EAASW,OAASmJ,EAAUU,yBAIpC,GAAIV,EAAUM,iBAAmB,EAAG,CAChC,IAAI0B,GACA/C,MAAOF,EAAKE,MACZE,OAAQjJ,EACRoG,KAAM0D,EAAUM,kBAEhB2B,EAAW,IAAIF,YAAYjD,EAAckD,GAAU5N,QACvD8B,EAASW,OAASmJ,EAAUM,iBAEhC,GAAIN,EAAUS,WAAa,EAAG,CACtBzB,EAAaD,EAAKE,MAAMC,MAAMhJ,EAASW,MAAOX,EAASW,MAAQmJ,EAAUO,mBAA7E,IAKI2B,EAAY7F,GAJZ+C,EAAU,IAAI9L,EAAQ0L,GACtBK,QAAQ,EACRC,QAAQ,KAE4BE,aAAapL,QACrD8B,EAASW,OAASmJ,EAAUO,kBAEhC,IAAI4B,EAAe,EACfC,EAAa,IAAI/L,MAAMiL,EAAYzF,QACvC,IAAS9E,EAAI,EAAGA,EAAIqL,EAAWvG,SAAU9E,EACrCqL,EAAWrL,GAAK,IAAIV,MAExB,IAAK,IAAI6H,EAAI,EAAGA,EAAIa,EAAKc,QAAS3B,EAC9B,IAAK,IAAImE,EAAO,EAAGA,EAAOf,EAAYzF,SAAUwG,EAC5CD,EAAWC,GAAMzF,KAAKuF,GACtBA,GAAgBb,EAAYe,GAAMzC,MAAQb,EAAKnL,KAAOqB,GA9blE,SAAwB4M,EAAQS,EAAShB,EAAatE,EAAUiF,EAAUtK,GACtE,IAAI4K,EAAW,IAAI9F,SAAS9E,EAAUvD,QAClCwL,EAAQ0B,EAAYO,EAAOrD,IAAI,IAAIoB,MACnCgC,EAASN,EAAYO,EAAOrD,IAAI,IAAIoD,OAEpCY,EAAiB/M,KAAK0G,MAAMyD,EAAQ,GACpC6C,EAAahN,KAAKiN,KAAK9C,EAAQ,GAC/B+C,EAAalN,KAAKiN,KAAKd,EAAS,GAChCgB,EAAYhD,EAA2B,GAAlB6C,EAAa,GAClCI,EAAYjB,EAA4B,GAAlBe,EAAa,GACnC5F,GAAelG,MAAO,GACtBiM,EAAa,IAAIzM,MAPP,GAQV0M,EAAU,IAAI1M,MARJ,GASV4G,EAAe,IAAI5G,MATT,GAUV2M,EAAW,IAAI3M,MAVL,GAWV+L,EAAa,IAAI/L,MAXP,GAYd,IAAK,IAAI4M,EAAO,EAAGA,EAZL,IAYuBA,EACjCb,EAAWa,GAAQX,EAAQT,EAAOrD,IAAIyE,IACtCH,EAAWG,GAAQA,EAAO,EAAI,EAAIH,EAAWG,EAAO,GAAKR,EAAaE,EACtEI,EAAQE,GAAQ,IAAIC,aAAa,IACjCjG,EAAagG,GAAQ,IAAIlB,YAAY,IACrCiB,EAASC,GAAQ,IAAIlB,YAAyB,GAAbU,GAErC,IAAK,IAAIU,EAAS,EAAGA,EAASR,IAAcQ,EAAQ,CAChD,IAAIC,EAAO,EACPD,GAAUR,EAAa,IACvBS,EAAOP,GACX,IAAIQ,EAAO,EACX,IAAK,IAAIC,EAAS,EAAGA,EAASb,IAAca,EAAQ,CAC5CA,GAAUb,EAAa,IACvBY,EAAOT,GACX,IAAK,IAAIK,EAAO,EAAGA,EA3Bb,IA2B+BA,EACjChG,EAAagG,GAAMM,KAAK,GACxBtG,EAAagG,GAAM,GAAKhB,EAASa,EAAWG,MAC5CnG,EAAQC,EAAYC,EAAUC,EAAagG,IA0EzC3E,EAzEOrB,EAAagG,IAyEf1E,EAzEsBwE,EAAQE,IA0E7C,GAAKO,GAAclF,EAAI,IAC3BC,EAAI,GAAKiF,GAAclF,EAAI,IAC3BC,EAAI,GAAKiF,GAAclF,EAAI,IAC3BC,EAAI,GAAKiF,GAAclF,EAAI,IAC3BC,EAAI,GAAKiF,GAAclF,EAAI,KAC3BC,EAAI,GAAKiF,GAAclF,EAAI,KAC3BC,EAAI,GAAKiF,GAAclF,EAAI,KAC3BC,EAAI,GAAKiF,GAAclF,EAAI,KAC3BC,EAAI,GAAKiF,GAAclF,EAAI,IAC3BC,EAAI,GAAKiF,GAAclF,EAAI,IAC3BC,EAAI,IAAMiF,GAAclF,EAAI,IAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,IAC5BC,EAAI,IAAMiF,GAAclF,EAAI,IAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,IAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAAI,IAAMiF,GAAclF,EAAI,KAC5BC,EAA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","file":"../../loaders/EXRLoader.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\",\r\n    'skylark-zlib/Inflate'\r\n], function (\r\n    THREE,\r\n    threex, \r\n    Inflate\r\n) {\r\n    'use strict';\r\n    var EXRLoader = function (manager) {\r\n        THREE.DataTextureLoader.call(this, manager);\r\n        this.type = THREE.FloatType;\r\n    };\r\n    EXRLoader.prototype = Object.assign(Object.create(THREE.DataTextureLoader.prototype), {\r\n        constructor: EXRLoader,\r\n        parse: function (buffer) {\r\n            const USHORT_RANGE = 1 << 16;\r\n            const BITMAP_SIZE = USHORT_RANGE >> 3;\r\n            const HUF_ENCBITS = 16;\r\n            const HUF_DECBITS = 14;\r\n            const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\r\n            const HUF_DECSIZE = 1 << HUF_DECBITS;\r\n            const HUF_DECMASK = HUF_DECSIZE - 1;\r\n            const SHORT_ZEROCODE_RUN = 59;\r\n            const LONG_ZEROCODE_RUN = 63;\r\n            const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\r\n            const ULONG_SIZE = 8;\r\n            const FLOAT32_SIZE = 4;\r\n            const INT32_SIZE = 4;\r\n            const INT16_SIZE = 2;\r\n            const INT8_SIZE = 1;\r\n            const STATIC_HUFFMAN = 0;\r\n            const DEFLATE = 1;\r\n            const UNKNOWN = 0;\r\n            const LOSSY_DCT = 1;\r\n            const RLE = 2;\r\n            const logBase = Math.pow(2.7182818, 2.2);\r\n            function reverseLutFromBitmap(bitmap, lut) {\r\n                var k = 0;\r\n                for (var i = 0; i < USHORT_RANGE; ++i) {\r\n                    if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\r\n                        lut[k++] = i;\r\n                    }\r\n                }\r\n                var n = k - 1;\r\n                while (k < USHORT_RANGE)\r\n                    lut[k++] = 0;\r\n                return n;\r\n            }\r\n            function hufClearDecTable(hdec) {\r\n                for (var i = 0; i < HUF_DECSIZE; i++) {\r\n                    hdec[i] = {};\r\n                    hdec[i].len = 0;\r\n                    hdec[i].lit = 0;\r\n                    hdec[i].p = null;\r\n                }\r\n            }\r\n            const getBitsReturn = {\r\n                l: 0,\r\n                c: 0,\r\n                lc: 0\r\n            };\r\n            function getBits(nBits, c, lc, uInt8Array, inOffset) {\r\n                while (lc < nBits) {\r\n                    c = c << 8 | parseUint8Array(uInt8Array, inOffset);\r\n                    lc += 8;\r\n                }\r\n                lc -= nBits;\r\n                getBitsReturn.l = c >> lc & (1 << nBits) - 1;\r\n                getBitsReturn.c = c;\r\n                getBitsReturn.lc = lc;\r\n            }\r\n            const hufTableBuffer = new Array(59);\r\n            function hufCanonicalCodeTable(hcode) {\r\n                for (var i = 0; i <= 58; ++i)\r\n                    hufTableBuffer[i] = 0;\r\n                for (var i = 0; i < HUF_ENCSIZE; ++i)\r\n                    hufTableBuffer[hcode[i]] += 1;\r\n                var c = 0;\r\n                for (var i = 58; i > 0; --i) {\r\n                    var nc = c + hufTableBuffer[i] >> 1;\r\n                    hufTableBuffer[i] = c;\r\n                    c = nc;\r\n                }\r\n                for (var i = 0; i < HUF_ENCSIZE; ++i) {\r\n                    var l = hcode[i];\r\n                    if (l > 0)\r\n                        hcode[i] = l | hufTableBuffer[l]++ << 6;\r\n                }\r\n            }\r\n            function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\r\n                var p = inOffset;\r\n                var c = 0;\r\n                var lc = 0;\r\n                for (; im <= iM; im++) {\r\n                    if (p.value - inOffset.value > ni)\r\n                        return false;\r\n                    getBits(6, c, lc, uInt8Array, p);\r\n                    var l = getBitsReturn.l;\r\n                    c = getBitsReturn.c;\r\n                    lc = getBitsReturn.lc;\r\n                    hcode[im] = l;\r\n                    if (l == LONG_ZEROCODE_RUN) {\r\n                        if (p.value - inOffset.value > ni) {\r\n                            throw 'Something wrong with hufUnpackEncTable';\r\n                        }\r\n                        getBits(8, c, lc, uInt8Array, p);\r\n                        var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\r\n                        c = getBitsReturn.c;\r\n                        lc = getBitsReturn.lc;\r\n                        if (im + zerun > iM + 1) {\r\n                            throw 'Something wrong with hufUnpackEncTable';\r\n                        }\r\n                        while (zerun--)\r\n                            hcode[im++] = 0;\r\n                        im--;\r\n                    } else if (l >= SHORT_ZEROCODE_RUN) {\r\n                        var zerun = l - SHORT_ZEROCODE_RUN + 2;\r\n                        if (im + zerun > iM + 1) {\r\n                            throw 'Something wrong with hufUnpackEncTable';\r\n                        }\r\n                        while (zerun--)\r\n                            hcode[im++] = 0;\r\n                        im--;\r\n                    }\r\n                }\r\n                hufCanonicalCodeTable(hcode);\r\n            }\r\n            function hufLength(code) {\r\n                return code & 63;\r\n            }\r\n            function hufCode(code) {\r\n                return code >> 6;\r\n            }\r\n            function hufBuildDecTable(hcode, im, iM, hdecod) {\r\n                for (; im <= iM; im++) {\r\n                    var c = hufCode(hcode[im]);\r\n                    var l = hufLength(hcode[im]);\r\n                    if (c >> l) {\r\n                        throw 'Invalid table entry';\r\n                    }\r\n                    if (l > HUF_DECBITS) {\r\n                        var pl = hdecod[c >> l - HUF_DECBITS];\r\n                        if (pl.len) {\r\n                            throw 'Invalid table entry';\r\n                        }\r\n                        pl.lit++;\r\n                        if (pl.p) {\r\n                            var p = pl.p;\r\n                            pl.p = new Array(pl.lit);\r\n                            for (var i = 0; i < pl.lit - 1; ++i) {\r\n                                pl.p[i] = p[i];\r\n                            }\r\n                        } else {\r\n                            pl.p = new Array(1);\r\n                        }\r\n                        pl.p[pl.lit - 1] = im;\r\n                    } else if (l) {\r\n                        var plOffset = 0;\r\n                        for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\r\n                            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\r\n                            if (pl.len || pl.p) {\r\n                                throw 'Invalid table entry';\r\n                            }\r\n                            pl.len = l;\r\n                            pl.lit = im;\r\n                            plOffset++;\r\n                        }\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n            const getCharReturn = {\r\n                c: 0,\r\n                lc: 0\r\n            };\r\n            function getChar(c, lc, uInt8Array, inOffset) {\r\n                c = c << 8 | parseUint8Array(uInt8Array, inOffset);\r\n                lc += 8;\r\n                getCharReturn.c = c;\r\n                getCharReturn.lc = lc;\r\n            }\r\n            const getCodeReturn = {\r\n                c: 0,\r\n                lc: 0\r\n            };\r\n            function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\r\n                if (po == rlc) {\r\n                    if (lc < 8) {\r\n                        getChar(c, lc, uInt8Array, inOffset);\r\n                        c = getCharReturn.c;\r\n                        lc = getCharReturn.lc;\r\n                    }\r\n                    lc -= 8;\r\n                    var cs = c >> lc;\r\n                    var cs = new Uint8Array([cs])[0];\r\n                    if (outBufferOffset.value + cs > outBufferEndOffset) {\r\n                        return false;\r\n                    }\r\n                    var s = outBuffer[outBufferOffset.value - 1];\r\n                    while (cs-- > 0) {\r\n                        outBuffer[outBufferOffset.value++] = s;\r\n                    }\r\n                } else if (outBufferOffset.value < outBufferEndOffset) {\r\n                    outBuffer[outBufferOffset.value++] = po;\r\n                } else {\r\n                    return false;\r\n                }\r\n                getCodeReturn.c = c;\r\n                getCodeReturn.lc = lc;\r\n            }\r\n            function UInt16(value) {\r\n                return value & 65535;\r\n            }\r\n            function Int16(value) {\r\n                var ref = UInt16(value);\r\n                return ref > 32767 ? ref - 65536 : ref;\r\n            }\r\n            const wdec14Return = {\r\n                a: 0,\r\n                b: 0\r\n            };\r\n            function wdec14(l, h) {\r\n                var ls = Int16(l);\r\n                var hs = Int16(h);\r\n                var hi = hs;\r\n                var ai = ls + (hi & 1) + (hi >> 1);\r\n                var as = ai;\r\n                var bs = ai - hi;\r\n                wdec14Return.a = as;\r\n                wdec14Return.b = bs;\r\n            }\r\n            function wav2Decode(buffer, j, nx, ox, ny, oy) {\r\n                var n = nx > ny ? ny : nx;\r\n                var p = 1;\r\n                var p2;\r\n                while (p <= n)\r\n                    p <<= 1;\r\n                p >>= 1;\r\n                p2 = p;\r\n                p >>= 1;\r\n                while (p >= 1) {\r\n                    var py = 0;\r\n                    var ey = py + oy * (ny - p2);\r\n                    var oy1 = oy * p;\r\n                    var oy2 = oy * p2;\r\n                    var ox1 = ox * p;\r\n                    var ox2 = ox * p2;\r\n                    var i00, i01, i10, i11;\r\n                    for (; py <= ey; py += oy2) {\r\n                        var px = py;\r\n                        var ex = py + ox * (nx - p2);\r\n                        for (; px <= ex; px += ox2) {\r\n                            var p01 = px + ox1;\r\n                            var p10 = px + oy1;\r\n                            var p11 = p10 + ox1;\r\n                            wdec14(buffer[px + j], buffer[p10 + j]);\r\n                            i00 = wdec14Return.a;\r\n                            i10 = wdec14Return.b;\r\n                            wdec14(buffer[p01 + j], buffer[p11 + j]);\r\n                            i01 = wdec14Return.a;\r\n                            i11 = wdec14Return.b;\r\n                            wdec14(i00, i01);\r\n                            buffer[px + j] = wdec14Return.a;\r\n                            buffer[p01 + j] = wdec14Return.b;\r\n                            wdec14(i10, i11);\r\n                            buffer[p10 + j] = wdec14Return.a;\r\n                            buffer[p11 + j] = wdec14Return.b;\r\n                        }\r\n                        if (nx & p) {\r\n                            var p10 = px + oy1;\r\n                            wdec14(buffer[px + j], buffer[p10 + j]);\r\n                            i00 = wdec14Return.a;\r\n                            buffer[p10 + j] = wdec14Return.b;\r\n                            buffer[px + j] = i00;\r\n                        }\r\n                    }\r\n                    if (ny & p) {\r\n                        var px = py;\r\n                        var ex = py + ox * (nx - p2);\r\n                        for (; px <= ex; px += ox2) {\r\n                            var p01 = px + ox1;\r\n                            wdec14(buffer[px + j], buffer[p01 + j]);\r\n                            i00 = wdec14Return.a;\r\n                            buffer[p01 + j] = wdec14Return.b;\r\n                            buffer[px + j] = i00;\r\n                        }\r\n                    }\r\n                    p2 = p;\r\n                    p >>= 1;\r\n                }\r\n                return py;\r\n            }\r\n            function hufDecode(encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\r\n                var c = 0;\r\n                var lc = 0;\r\n                var outBufferEndOffset = no;\r\n                var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\r\n                while (inOffset.value < inOffsetEnd) {\r\n                    getChar(c, lc, uInt8Array, inOffset);\r\n                    c = getCharReturn.c;\r\n                    lc = getCharReturn.lc;\r\n                    while (lc >= HUF_DECBITS) {\r\n                        var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\r\n                        var pl = decodingTable[index];\r\n                        if (pl.len) {\r\n                            lc -= pl.len;\r\n                            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\r\n                            c = getCodeReturn.c;\r\n                            lc = getCodeReturn.lc;\r\n                        } else {\r\n                            if (!pl.p) {\r\n                                throw 'hufDecode issues';\r\n                            }\r\n                            var j;\r\n                            for (j = 0; j < pl.lit; j++) {\r\n                                var l = hufLength(encodingTable[pl.p[j]]);\r\n                                while (lc < l && inOffset.value < inOffsetEnd) {\r\n                                    getChar(c, lc, uInt8Array, inOffset);\r\n                                    c = getCharReturn.c;\r\n                                    lc = getCharReturn.lc;\r\n                                }\r\n                                if (lc >= l) {\r\n                                    if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\r\n                                        lc -= l;\r\n                                        getCode(pl.p[j], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\r\n                                        c = getCodeReturn.c;\r\n                                        lc = getCodeReturn.lc;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (j == pl.lit) {\r\n                                throw 'hufDecode issues';\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                var i = 8 - ni & 7;\r\n                c >>= i;\r\n                lc -= i;\r\n                while (lc > 0) {\r\n                    var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\r\n                    if (pl.len) {\r\n                        lc -= pl.len;\r\n                        getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\r\n                        c = getCodeReturn.c;\r\n                        lc = getCodeReturn.lc;\r\n                    } else {\r\n                        throw 'hufDecode issues';\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n            function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\r\n                var outOffset = { value: 0 };\r\n                var initialInOffset = inOffset.value;\r\n                var im = parseUint32(inDataView, inOffset);\r\n                var iM = parseUint32(inDataView, inOffset);\r\n                inOffset.value += 4;\r\n                var nBits = parseUint32(inDataView, inOffset);\r\n                inOffset.value += 4;\r\n                if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\r\n                    throw 'Something wrong with HUF_ENCSIZE';\r\n                }\r\n                var freq = new Array(HUF_ENCSIZE);\r\n                var hdec = new Array(HUF_DECSIZE);\r\n                hufClearDecTable(hdec);\r\n                var ni = nCompressed - (inOffset.value - initialInOffset);\r\n                hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq);\r\n                if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\r\n                    throw 'Something wrong with hufUncompress';\r\n                }\r\n                hufBuildDecTable(freq, im, iM, hdec);\r\n                hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\r\n            }\r\n            function applyLut(lut, data, nData) {\r\n                for (var i = 0; i < nData; ++i) {\r\n                    data[i] = lut[data[i]];\r\n                }\r\n            }\r\n            function predictor(source) {\r\n                for (var t = 1; t < source.length; t++) {\r\n                    var d = source[t - 1] + source[t] - 128;\r\n                    source[t] = d;\r\n                }\r\n            }\r\n            function interleaveScalar(source, out) {\r\n                var t1 = 0;\r\n                var t2 = Math.floor((source.length + 1) / 2);\r\n                var s = 0;\r\n                var stop = source.length - 1;\r\n                while (true) {\r\n                    if (s > stop)\r\n                        break;\r\n                    out[s++] = source[t1++];\r\n                    if (s > stop)\r\n                        break;\r\n                    out[s++] = source[t2++];\r\n                }\r\n            }\r\n            function decodeRunLength(source) {\r\n                var size = source.byteLength;\r\n                var out = new Array();\r\n                var p = 0;\r\n                var reader = new DataView(source);\r\n                while (size > 0) {\r\n                    var l = reader.getInt8(p++);\r\n                    if (l < 0) {\r\n                        var count = -l;\r\n                        size -= count + 1;\r\n                        for (var i = 0; i < count; i++) {\r\n                            out.push(reader.getUint8(p++));\r\n                        }\r\n                    } else {\r\n                        var count = l;\r\n                        size -= 2;\r\n                        var value = reader.getUint8(p++);\r\n                        for (var i = 0; i < count + 1; i++) {\r\n                            out.push(value);\r\n                        }\r\n                    }\r\n                }\r\n                return out;\r\n            }\r\n            function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\r\n                var dataView = new DataView(outBuffer.buffer);\r\n                var width = channelData[cscSet.idx[0]].width;\r\n                var height = channelData[cscSet.idx[0]].height;\r\n                var numComp = 3;\r\n                var numFullBlocksX = Math.floor(width / 8);\r\n                var numBlocksX = Math.ceil(width / 8);\r\n                var numBlocksY = Math.ceil(height / 8);\r\n                var leftoverX = width - (numBlocksX - 1) * 8;\r\n                var leftoverY = height - (numBlocksY - 1) * 8;\r\n                var currAcComp = { value: 0 };\r\n                var currDcComp = new Array(numComp);\r\n                var dctData = new Array(numComp);\r\n                var halfZigBlock = new Array(numComp);\r\n                var rowBlock = new Array(numComp);\r\n                var rowOffsets = new Array(numComp);\r\n                for (let comp = 0; comp < numComp; ++comp) {\r\n                    rowOffsets[comp] = rowPtrs[cscSet.idx[comp]];\r\n                    currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY;\r\n                    dctData[comp] = new Float32Array(64);\r\n                    halfZigBlock[comp] = new Uint16Array(64);\r\n                    rowBlock[comp] = new Uint16Array(numBlocksX * 64);\r\n                }\r\n                for (let blocky = 0; blocky < numBlocksY; ++blocky) {\r\n                    var maxY = 8;\r\n                    if (blocky == numBlocksY - 1)\r\n                        maxY = leftoverY;\r\n                    var maxX = 8;\r\n                    for (let blockx = 0; blockx < numBlocksX; ++blockx) {\r\n                        if (blockx == numBlocksX - 1)\r\n                            maxX = leftoverX;\r\n                        for (let comp = 0; comp < numComp; ++comp) {\r\n                            halfZigBlock[comp].fill(0);\r\n                            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++];\r\n                            unRleAC(currAcComp, acBuffer, halfZigBlock[comp]);\r\n                            unZigZag(halfZigBlock[comp], dctData[comp]);\r\n                            dctInverse(dctData[comp]);\r\n                        }\r\n                        if (numComp == 3) {\r\n                            csc709Inverse(dctData);\r\n                        }\r\n                        for (let comp = 0; comp < numComp; ++comp) {\r\n                            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64);\r\n                        }\r\n                    }\r\n                    let offset = 0;\r\n                    for (let comp = 0; comp < numComp; ++comp) {\r\n                        let type = channelData[cscSet.idx[comp]].type;\r\n                        for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\r\n                            offset = rowOffsets[comp][y];\r\n                            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\r\n                                let src = blockx * 64 + (y & 7) * 8;\r\n                                dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true);\r\n                                dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true);\r\n                                dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true);\r\n                                dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true);\r\n                                dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true);\r\n                                dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true);\r\n                                dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true);\r\n                                dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true);\r\n                                offset += 8 * INT16_SIZE * type;\r\n                            }\r\n                        }\r\n                        if (numFullBlocksX != numBlocksX) {\r\n                            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\r\n                                let offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type;\r\n                                let src = numFullBlocksX * 64 + (y & 7) * 8;\r\n                                for (let x = 0; x < maxX; ++x) {\r\n                                    dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                var halfRow = new Uint16Array(width);\r\n                var dataView = new DataView(outBuffer.buffer);\r\n                for (var comp = 0; comp < numComp; ++comp) {\r\n                    channelData[cscSet.idx[comp]].decoded = true;\r\n                    var type = channelData[cscSet.idx[comp]].type;\r\n                    if (channelData[comp].type != 2)\r\n                        continue;\r\n                    for (var y = 0; y < height; ++y) {\r\n                        let offset = rowOffsets[comp][y];\r\n                        for (var x = 0; x < width; ++x) {\r\n                            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true);\r\n                        }\r\n                        for (var x = 0; x < width; ++x) {\r\n                            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            function unRleAC(currAcComp, acBuffer, halfZigBlock) {\r\n                var acValue;\r\n                var dctComp = 1;\r\n                while (dctComp < 64) {\r\n                    acValue = acBuffer[currAcComp.value];\r\n                    if (acValue == 65280) {\r\n                        dctComp = 64;\r\n                    } else if (acValue >> 8 == 255) {\r\n                        dctComp += acValue & 255;\r\n                    } else {\r\n                        halfZigBlock[dctComp] = acValue;\r\n                        dctComp++;\r\n                    }\r\n                    currAcComp.value++;\r\n                }\r\n            }\r\n            function unZigZag(src, dst) {\r\n                dst[0] = decodeFloat16(src[0]);\r\n                dst[1] = decodeFloat16(src[1]);\r\n                dst[2] = decodeFloat16(src[5]);\r\n                dst[3] = decodeFloat16(src[6]);\r\n                dst[4] = decodeFloat16(src[14]);\r\n                dst[5] = decodeFloat16(src[15]);\r\n                dst[6] = decodeFloat16(src[27]);\r\n                dst[7] = decodeFloat16(src[28]);\r\n                dst[8] = decodeFloat16(src[2]);\r\n                dst[9] = decodeFloat16(src[4]);\r\n                dst[10] = decodeFloat16(src[7]);\r\n                dst[11] = decodeFloat16(src[13]);\r\n                dst[12] = decodeFloat16(src[16]);\r\n                dst[13] = decodeFloat16(src[26]);\r\n                dst[14] = decodeFloat16(src[29]);\r\n                dst[15] = decodeFloat16(src[42]);\r\n                dst[16] = decodeFloat16(src[3]);\r\n                dst[17] = decodeFloat16(src[8]);\r\n                dst[18] = decodeFloat16(src[12]);\r\n                dst[19] = decodeFloat16(src[17]);\r\n                dst[20] = decodeFloat16(src[25]);\r\n                dst[21] = decodeFloat16(src[30]);\r\n                dst[22] = decodeFloat16(src[41]);\r\n                dst[23] = decodeFloat16(src[43]);\r\n                dst[24] = decodeFloat16(src[9]);\r\n                dst[25] = decodeFloat16(src[11]);\r\n                dst[26] = decodeFloat16(src[18]);\r\n                dst[27] = decodeFloat16(src[24]);\r\n                dst[28] = decodeFloat16(src[31]);\r\n                dst[29] = decodeFloat16(src[40]);\r\n                dst[30] = decodeFloat16(src[44]);\r\n                dst[31] = decodeFloat16(src[53]);\r\n                dst[32] = decodeFloat16(src[10]);\r\n                dst[33] = decodeFloat16(src[19]);\r\n                dst[34] = decodeFloat16(src[23]);\r\n                dst[35] = decodeFloat16(src[32]);\r\n                dst[36] = decodeFloat16(src[39]);\r\n                dst[37] = decodeFloat16(src[45]);\r\n                dst[38] = decodeFloat16(src[52]);\r\n                dst[39] = decodeFloat16(src[54]);\r\n                dst[40] = decodeFloat16(src[20]);\r\n                dst[41] = decodeFloat16(src[22]);\r\n                dst[42] = decodeFloat16(src[33]);\r\n                dst[43] = decodeFloat16(src[38]);\r\n                dst[44] = decodeFloat16(src[46]);\r\n                dst[45] = decodeFloat16(src[51]);\r\n                dst[46] = decodeFloat16(src[55]);\r\n                dst[47] = decodeFloat16(src[60]);\r\n                dst[48] = decodeFloat16(src[21]);\r\n                dst[49] = decodeFloat16(src[34]);\r\n                dst[50] = decodeFloat16(src[37]);\r\n                dst[51] = decodeFloat16(src[47]);\r\n                dst[52] = decodeFloat16(src[50]);\r\n                dst[53] = decodeFloat16(src[56]);\r\n                dst[54] = decodeFloat16(src[59]);\r\n                dst[55] = decodeFloat16(src[61]);\r\n                dst[56] = decodeFloat16(src[35]);\r\n                dst[57] = decodeFloat16(src[36]);\r\n                dst[58] = decodeFloat16(src[48]);\r\n                dst[59] = decodeFloat16(src[49]);\r\n                dst[60] = decodeFloat16(src[57]);\r\n                dst[61] = decodeFloat16(src[58]);\r\n                dst[62] = decodeFloat16(src[62]);\r\n                dst[63] = decodeFloat16(src[63]);\r\n            }\r\n            function dctInverse(data) {\r\n                const a = 0.5 * Math.cos(3.14159 / 4);\r\n                const b = 0.5 * Math.cos(3.14159 / 16);\r\n                const c = 0.5 * Math.cos(3.14159 / 8);\r\n                const d = 0.5 * Math.cos(3 * 3.14159 / 16);\r\n                const e = 0.5 * Math.cos(5 * 3.14159 / 16);\r\n                const f = 0.5 * Math.cos(3 * 3.14159 / 8);\r\n                const g = 0.5 * Math.cos(7 * 3.14159 / 16);\r\n                var alpha = new Array(4);\r\n                var beta = new Array(4);\r\n                var theta = new Array(4);\r\n                var gamma = new Array(4);\r\n                for (var row = 0; row < 8; ++row) {\r\n                    var rowPtr = row * 8;\r\n                    alpha[0] = c * data[rowPtr + 2];\r\n                    alpha[1] = f * data[rowPtr + 2];\r\n                    alpha[2] = c * data[rowPtr + 6];\r\n                    alpha[3] = f * data[rowPtr + 6];\r\n                    beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\r\n                    beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\r\n                    beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\r\n                    beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\r\n                    theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\r\n                    theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\r\n                    theta[1] = alpha[0] + alpha[3];\r\n                    theta[2] = alpha[1] - alpha[2];\r\n                    gamma[0] = theta[0] + theta[1];\r\n                    gamma[1] = theta[3] + theta[2];\r\n                    gamma[2] = theta[3] - theta[2];\r\n                    gamma[3] = theta[0] - theta[1];\r\n                    data[rowPtr + 0] = gamma[0] + beta[0];\r\n                    data[rowPtr + 1] = gamma[1] + beta[1];\r\n                    data[rowPtr + 2] = gamma[2] + beta[2];\r\n                    data[rowPtr + 3] = gamma[3] + beta[3];\r\n                    data[rowPtr + 4] = gamma[3] - beta[3];\r\n                    data[rowPtr + 5] = gamma[2] - beta[2];\r\n                    data[rowPtr + 6] = gamma[1] - beta[1];\r\n                    data[rowPtr + 7] = gamma[0] - beta[0];\r\n                }\r\n                for (var column = 0; column < 8; ++column) {\r\n                    alpha[0] = c * data[16 + column];\r\n                    alpha[1] = f * data[16 + column];\r\n                    alpha[2] = c * data[48 + column];\r\n                    alpha[3] = f * data[48 + column];\r\n                    beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\r\n                    beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\r\n                    beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\r\n                    beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\r\n                    theta[0] = a * (data[column] + data[32 + column]);\r\n                    theta[3] = a * (data[column] - data[32 + column]);\r\n                    theta[1] = alpha[0] + alpha[3];\r\n                    theta[2] = alpha[1] - alpha[2];\r\n                    gamma[0] = theta[0] + theta[1];\r\n                    gamma[1] = theta[3] + theta[2];\r\n                    gamma[2] = theta[3] - theta[2];\r\n                    gamma[3] = theta[0] - theta[1];\r\n                    data[0 + column] = gamma[0] + beta[0];\r\n                    data[8 + column] = gamma[1] + beta[1];\r\n                    data[16 + column] = gamma[2] + beta[2];\r\n                    data[24 + column] = gamma[3] + beta[3];\r\n                    data[32 + column] = gamma[3] - beta[3];\r\n                    data[40 + column] = gamma[2] - beta[2];\r\n                    data[48 + column] = gamma[1] - beta[1];\r\n                    data[56 + column] = gamma[0] - beta[0];\r\n                }\r\n            }\r\n            function csc709Inverse(data) {\r\n                for (var i = 0; i < 64; ++i) {\r\n                    var y = data[0][i];\r\n                    var cb = data[1][i];\r\n                    var cr = data[2][i];\r\n                    data[0][i] = y + 1.5747 * cr;\r\n                    data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\r\n                    data[2][i] = y + 1.8556 * cb;\r\n                }\r\n            }\r\n            function convertToHalf(src, dst, idx) {\r\n                for (var i = 0; i < 64; ++i) {\r\n                    dst[idx + i] = encodeFloat16(toLinear(src[i]));\r\n                }\r\n            }\r\n            function toLinear(float) {\r\n                if (float <= 1) {\r\n                    return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\r\n                } else {\r\n                    return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\r\n                }\r\n            }\r\n            function uncompressRAW(info) {\r\n                return new DataView(info.array.buffer, info.offset.value, info.size);\r\n            }\r\n            function uncompressRLE(info) {\r\n                var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\r\n                var rawBuffer = new Uint8Array(decodeRunLength(compressed));\r\n                var tmpBuffer = new Uint8Array(rawBuffer.length);\r\n                predictor(rawBuffer);\r\n                interleaveScalar(rawBuffer, tmpBuffer);\r\n                return new DataView(tmpBuffer.buffer);\r\n            }\r\n            function uncompressZIP(info) {\r\n                var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\r\n                //if (typeof b.Zlib === 'undefined') {\r\n                //    console.error('THREE.EXRLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib');\r\n                //}\r\n                var inflate = new Inflate(compressed, {\r\n                    resize: true,\r\n                    verify: true\r\n                });\r\n                var rawBuffer = new Uint8Array(inflate.decompress().buffer);\r\n                var tmpBuffer = new Uint8Array(rawBuffer.length);\r\n                predictor(rawBuffer);\r\n                interleaveScalar(rawBuffer, tmpBuffer);\r\n                return new DataView(tmpBuffer.buffer);\r\n            }\r\n            function uncompressPIZ(info) {\r\n                var inDataView = info.viewer;\r\n                var inOffset = { value: info.offset.value };\r\n                var tmpBufSize = info.width * scanlineBlockSize * (EXRHeader.channels.length * info.type);\r\n                var outBuffer = new Uint16Array(tmpBufSize);\r\n                var bitmap = new Uint8Array(BITMAP_SIZE);\r\n                var outBufferEnd = 0;\r\n                var pizChannelData = new Array(info.channels);\r\n                for (var i = 0; i < info.channels; i++) {\r\n                    pizChannelData[i] = {};\r\n                    pizChannelData[i]['start'] = outBufferEnd;\r\n                    pizChannelData[i]['end'] = pizChannelData[i]['start'];\r\n                    pizChannelData[i]['nx'] = info.width;\r\n                    pizChannelData[i]['ny'] = info.lines;\r\n                    pizChannelData[i]['size'] = info.type;\r\n                    outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\r\n                }\r\n                var minNonZero = parseUint16(inDataView, inOffset);\r\n                var maxNonZero = parseUint16(inDataView, inOffset);\r\n                if (maxNonZero >= BITMAP_SIZE) {\r\n                    throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\r\n                }\r\n                if (minNonZero <= maxNonZero) {\r\n                    for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\r\n                        bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\r\n                    }\r\n                }\r\n                var lut = new Uint16Array(USHORT_RANGE);\r\n                reverseLutFromBitmap(bitmap, lut);\r\n                var length = parseUint32(inDataView, inOffset);\r\n                hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\r\n                for (var i = 0; i < info.channels; ++i) {\r\n                    var cd = pizChannelData[i];\r\n                    for (var j = 0; j < pizChannelData[i].size; ++j) {\r\n                        wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size);\r\n                    }\r\n                }\r\n                applyLut(lut, outBuffer, outBufferEnd);\r\n                var tmpOffset = 0;\r\n                var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\r\n                for (var y = 0; y < info.lines; y++) {\r\n                    for (var c = 0; c < info.channels; c++) {\r\n                        var cd = pizChannelData[c];\r\n                        var n = cd.nx * cd.size;\r\n                        var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\r\n                        tmpBuffer.set(cp, tmpOffset);\r\n                        tmpOffset += n * INT16_SIZE;\r\n                        cd.end += n;\r\n                    }\r\n                }\r\n                return new DataView(tmpBuffer.buffer);\r\n            }\r\n            function uncompressDWA(info) {\r\n                var inDataView = info.viewer;\r\n                var inOffset = { value: info.offset.value };\r\n                var outBuffer = new Uint8Array(info.width * info.lines * (EXRHeader.channels.length * info.type * INT16_SIZE));\r\n                var dwaHeader = {\r\n                    version: parseInt64(inDataView, inOffset),\r\n                    unknownUncompressedSize: parseInt64(inDataView, inOffset),\r\n                    unknownCompressedSize: parseInt64(inDataView, inOffset),\r\n                    acCompressedSize: parseInt64(inDataView, inOffset),\r\n                    dcCompressedSize: parseInt64(inDataView, inOffset),\r\n                    rleCompressedSize: parseInt64(inDataView, inOffset),\r\n                    rleUncompressedSize: parseInt64(inDataView, inOffset),\r\n                    rleRawSize: parseInt64(inDataView, inOffset),\r\n                    totalAcUncompressedCount: parseInt64(inDataView, inOffset),\r\n                    totalDcUncompressedCount: parseInt64(inDataView, inOffset),\r\n                    acCompression: parseInt64(inDataView, inOffset)\r\n                };\r\n                if (dwaHeader.version < 2)\r\n                    throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported';\r\n                var channelRules = new Array();\r\n                var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\r\n                while (ruleSize > 0) {\r\n                    var name = parseNullTerminatedString(inDataView.buffer, inOffset);\r\n                    var value = parseUint8(inDataView, inOffset);\r\n                    var compression = value >> 2 & 3;\r\n                    var csc = (value >> 4) - 1;\r\n                    var index = new Int8Array([csc])[0];\r\n                    var type = parseUint8(inDataView, inOffset);\r\n                    channelRules.push({\r\n                        name: name,\r\n                        index: index,\r\n                        type: type,\r\n                        compression: compression\r\n                    });\r\n                    ruleSize -= name.length + 3;\r\n                }\r\n                var channels = EXRHeader.channels;\r\n                var channelData = new Array(info.channels);\r\n                for (var i = 0; i < info.channels; ++i) {\r\n                    var cd = channelData[i] = {};\r\n                    var channel = channels[i];\r\n                    cd.name = channel.name;\r\n                    cd.compression = UNKNOWN;\r\n                    cd.decoded = false;\r\n                    cd.type = channel.pixelType;\r\n                    cd.pLinear = channel.pLinear;\r\n                    cd.width = info.width;\r\n                    cd.height = info.lines;\r\n                }\r\n                var cscSet = { idx: new Array(3) };\r\n                for (var offset = 0; offset < info.channels; ++offset) {\r\n                    var cd = channelData[offset];\r\n                    for (var i = 0; i < channelRules.length; ++i) {\r\n                        var rule = channelRules[i];\r\n                        if (cd.name == rule.name) {\r\n                            cd.compression = rule.compression;\r\n                            if (rule.index >= 0) {\r\n                                cscSet.idx[rule.index] = offset;\r\n                            }\r\n                            cd.offset = offset;\r\n                        }\r\n                    }\r\n                }\r\n                if (dwaHeader.acCompressedSize > 0) {\r\n                    switch (dwaHeader.acCompression) {\r\n                    case STATIC_HUFFMAN:\r\n                        var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\r\n                        hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\r\n                        break;\r\n                    case DEFLATE:\r\n                        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\r\n                        var inflate = new Inflate(compressed, {\r\n                            resize: true,\r\n                            verify: true\r\n                        });\r\n                        var acBuffer = new Uint16Array(inflate.decompress().buffer);\r\n                        inOffset.value += dwaHeader.totalAcUncompressedCount;\r\n                        break;\r\n                    }\r\n                }\r\n                if (dwaHeader.dcCompressedSize > 0) {\r\n                    var zlibInfo = {\r\n                        array: info.array,\r\n                        offset: inOffset,\r\n                        size: dwaHeader.dcCompressedSize\r\n                    };\r\n                    var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\r\n                    inOffset.value += dwaHeader.dcCompressedSize;\r\n                }\r\n                if (dwaHeader.rleRawSize > 0) {\r\n                    var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\r\n                    var inflate = new Inflate(compressed, {\r\n                        resize: true,\r\n                        verify: true\r\n                    });\r\n                    var rleBuffer = decodeRunLength(inflate.decompress().buffer);\r\n                    inOffset.value += dwaHeader.rleCompressedSize;\r\n                }\r\n                var outBufferEnd = 0;\r\n                var rowOffsets = new Array(channelData.length);\r\n                for (var i = 0; i < rowOffsets.length; ++i) {\r\n                    rowOffsets[i] = new Array();\r\n                }\r\n                for (var y = 0; y < info.lines; ++y) {\r\n                    for (var chan = 0; chan < channelData.length; ++chan) {\r\n                        rowOffsets[chan].push(outBufferEnd);\r\n                        outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\r\n                    }\r\n                }\r\n                lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\r\n                for (var i = 0; i < channelData.length; ++i) {\r\n                    var cd = channelData[i];\r\n                    if (cd.decoded)\r\n                        continue;\r\n                    switch (cd.compression) {\r\n                    case RLE:\r\n                        var row = 0;\r\n                        var rleOffset = 0;\r\n                        for (var y = 0; y < info.lines; ++y) {\r\n                            var rowOffsetBytes = rowOffsets[i][row];\r\n                            for (var x = 0; x < cd.width; ++x) {\r\n                                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\r\n                                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\r\n                                }\r\n                                rleOffset++;\r\n                            }\r\n                            row++;\r\n                        }\r\n                        break;\r\n                    case LOSSY_DCT:\r\n                    default:\r\n                        throw 'EXRLoader.parse: unsupported channel compression';\r\n                    }\r\n                }\r\n                return new DataView(outBuffer.buffer);\r\n            }\r\n            function parseNullTerminatedString(buffer, offset) {\r\n                var uintBuffer = new Uint8Array(buffer);\r\n                var endOffset = 0;\r\n                while (uintBuffer[offset.value + endOffset] != 0) {\r\n                    endOffset += 1;\r\n                }\r\n                var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\r\n                offset.value = offset.value + endOffset + 1;\r\n                return stringValue;\r\n            }\r\n            function parseFixedLengthString(buffer, offset, size) {\r\n                var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\r\n                offset.value = offset.value + size;\r\n                return stringValue;\r\n            }\r\n            function parseUlong(dataView, offset) {\r\n                var uLong = dataView.getUint32(0, true);\r\n                offset.value = offset.value + ULONG_SIZE;\r\n                return uLong;\r\n            }\r\n            function parseUint32(dataView, offset) {\r\n                var Uint32 = dataView.getUint32(offset.value, true);\r\n                offset.value = offset.value + INT32_SIZE;\r\n                return Uint32;\r\n            }\r\n            function parseUint8Array(uInt8Array, offset) {\r\n                var Uint8 = uInt8Array[offset.value];\r\n                offset.value = offset.value + INT8_SIZE;\r\n                return Uint8;\r\n            }\r\n            function parseUint8(dataView, offset) {\r\n                var Uint8 = dataView.getUint8(offset.value);\r\n                offset.value = offset.value + INT8_SIZE;\r\n                return Uint8;\r\n            }\r\n            function parseInt64(dataView, offset) {\r\n                var int = Number(dataView.getBigInt64(offset.value, true));\r\n                offset.value += ULONG_SIZE;\r\n                return int;\r\n            }\r\n            function parseFloat32(dataView, offset) {\r\n                var float = dataView.getFloat32(offset.value, true);\r\n                offset.value += FLOAT32_SIZE;\r\n                return float;\r\n            }\r\n            function decodeFloat16(binary) {\r\n                var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\r\n                return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 0.00006103515625 * (fraction / 1024));\r\n            }\r\n            var encodeFloat16 = function () {\r\n                var floatView = new Float32Array(1);\r\n                var int32View = new Int32Array(floatView.buffer);\r\n                return function toHalf(val) {\r\n                    floatView[0] = val;\r\n                    var x = int32View[0];\r\n                    var bits = x >> 16 & 32768;\r\n                    var m = x >> 12 & 2047;\r\n                    var e = x >> 23 & 255;\r\n                    if (e < 103)\r\n                        return bits;\r\n                    if (e > 142) {\r\n                        bits |= 31744;\r\n                        bits |= (e == 255 ? 0 : 1) && x & 8388607;\r\n                        return bits;\r\n                    }\r\n                    if (e < 113) {\r\n                        m |= 2048;\r\n                        bits |= (m >> 114 - e) + (m >> 113 - e & 1);\r\n                        return bits;\r\n                    }\r\n                    bits |= e - 112 << 10 | m >> 1;\r\n                    bits += m & 1;\r\n                    return bits;\r\n                };\r\n            }();\r\n            function parseUint16(dataView, offset) {\r\n                var Uint16 = dataView.getUint16(offset.value, true);\r\n                offset.value += INT16_SIZE;\r\n                return Uint16;\r\n            }\r\n            function parseFloat16(buffer, offset) {\r\n                return decodeFloat16(parseUint16(buffer, offset));\r\n            }\r\n            function parseChlist(dataView, buffer, offset, size) {\r\n                var startOffset = offset.value;\r\n                var channels = [];\r\n                while (offset.value < startOffset + size - 1) {\r\n                    var name = parseNullTerminatedString(buffer, offset);\r\n                    var pixelType = parseUint32(dataView, offset);\r\n                    var pLinear = parseUint8(dataView, offset);\r\n                    offset.value += 3;\r\n                    var xSampling = parseUint32(dataView, offset);\r\n                    var ySampling = parseUint32(dataView, offset);\r\n                    channels.push({\r\n                        name: name,\r\n                        pixelType: pixelType,\r\n                        pLinear: pLinear,\r\n                        xSampling: xSampling,\r\n                        ySampling: ySampling\r\n                    });\r\n                }\r\n                offset.value += 1;\r\n                return channels;\r\n            }\r\n            function parseChromaticities(dataView, offset) {\r\n                var redX = parseFloat32(dataView, offset);\r\n                var redY = parseFloat32(dataView, offset);\r\n                var greenX = parseFloat32(dataView, offset);\r\n                var greenY = parseFloat32(dataView, offset);\r\n                var blueX = parseFloat32(dataView, offset);\r\n                var blueY = parseFloat32(dataView, offset);\r\n                var whiteX = parseFloat32(dataView, offset);\r\n                var whiteY = parseFloat32(dataView, offset);\r\n                return {\r\n                    redX: redX,\r\n                    redY: redY,\r\n                    greenX: greenX,\r\n                    greenY: greenY,\r\n                    blueX: blueX,\r\n                    blueY: blueY,\r\n                    whiteX: whiteX,\r\n                    whiteY: whiteY\r\n                };\r\n            }\r\n            function parseCompression(dataView, offset) {\r\n                var compressionCodes = [\r\n                    'NO_COMPRESSION',\r\n                    'RLE_COMPRESSION',\r\n                    'ZIPS_COMPRESSION',\r\n                    'ZIP_COMPRESSION',\r\n                    'PIZ_COMPRESSION',\r\n                    'PXR24_COMPRESSION',\r\n                    'B44_COMPRESSION',\r\n                    'B44A_COMPRESSION',\r\n                    'DWAA_COMPRESSION',\r\n                    'DWAB_COMPRESSION'\r\n                ];\r\n                var compression = parseUint8(dataView, offset);\r\n                return compressionCodes[compression];\r\n            }\r\n            function parseBox2i(dataView, offset) {\r\n                var xMin = parseUint32(dataView, offset);\r\n                var yMin = parseUint32(dataView, offset);\r\n                var xMax = parseUint32(dataView, offset);\r\n                var yMax = parseUint32(dataView, offset);\r\n                return {\r\n                    xMin: xMin,\r\n                    yMin: yMin,\r\n                    xMax: xMax,\r\n                    yMax: yMax\r\n                };\r\n            }\r\n            function parseLineOrder(dataView, offset) {\r\n                var lineOrders = ['INCREASING_Y'];\r\n                var lineOrder = parseUint8(dataView, offset);\r\n                return lineOrders[lineOrder];\r\n            }\r\n            function parseV2f(dataView, offset) {\r\n                var x = parseFloat32(dataView, offset);\r\n                var y = parseFloat32(dataView, offset);\r\n                return [\r\n                    x,\r\n                    y\r\n                ];\r\n            }\r\n            function parseValue(dataView, buffer, offset, type, size) {\r\n                if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\r\n                    return parseFixedLengthString(buffer, offset, size);\r\n                } else if (type === 'chlist') {\r\n                    return parseChlist(dataView, buffer, offset, size);\r\n                } else if (type === 'chromaticities') {\r\n                    return parseChromaticities(dataView, offset);\r\n                } else if (type === 'compression') {\r\n                    return parseCompression(dataView, offset);\r\n                } else if (type === 'box2i') {\r\n                    return parseBox2i(dataView, offset);\r\n                } else if (type === 'lineOrder') {\r\n                    return parseLineOrder(dataView, offset);\r\n                } else if (type === 'float') {\r\n                    return parseFloat32(dataView, offset);\r\n                } else if (type === 'v2f') {\r\n                    return parseV2f(dataView, offset);\r\n                } else if (type === 'int') {\r\n                    return parseUint32(dataView, offset);\r\n                } else {\r\n                    throw 'Cannot parse value for unsupported type: ' + type;\r\n                }\r\n            }\r\n            var bufferDataView = new DataView(buffer);\r\n            var uInt8Array = new Uint8Array(buffer);\r\n            var EXRHeader = {};\r\n            bufferDataView.getUint32(0, true);\r\n            bufferDataView.getUint8(4, true);\r\n            bufferDataView.getUint8(5, true);\r\n            var offset = { value: 8 };\r\n            var keepReading = true;\r\n            while (keepReading) {\r\n                var attributeName = parseNullTerminatedString(buffer, offset);\r\n                if (attributeName == 0) {\r\n                    keepReading = false;\r\n                } else {\r\n                    var attributeType = parseNullTerminatedString(buffer, offset);\r\n                    var attributeSize = parseUint32(bufferDataView, offset);\r\n                    var attributeValue = parseValue(bufferDataView, buffer, offset, attributeType, attributeSize);\r\n                    EXRHeader[attributeName] = attributeValue;\r\n                }\r\n            }\r\n            var dataWindowHeight = EXRHeader.dataWindow.yMax + 1;\r\n            var uncompress;\r\n            var scanlineBlockSize;\r\n            switch (EXRHeader.compression) {\r\n            case 'NO_COMPRESSION':\r\n                scanlineBlockSize = 1;\r\n                uncompress = uncompressRAW;\r\n                break;\r\n            case 'RLE_COMPRESSION':\r\n                scanlineBlockSize = 1;\r\n                uncompress = uncompressRLE;\r\n                break;\r\n            case 'ZIPS_COMPRESSION':\r\n                scanlineBlockSize = 1;\r\n                uncompress = uncompressZIP;\r\n                break;\r\n            case 'ZIP_COMPRESSION':\r\n                scanlineBlockSize = 16;\r\n                uncompress = uncompressZIP;\r\n                break;\r\n            case 'PIZ_COMPRESSION':\r\n                scanlineBlockSize = 32;\r\n                uncompress = uncompressPIZ;\r\n                break;\r\n            case 'DWAA_COMPRESSION':\r\n                scanlineBlockSize = 32;\r\n                uncompress = uncompressDWA;\r\n                break;\r\n            case 'DWAB_COMPRESSION':\r\n                scanlineBlockSize = 256;\r\n                uncompress = uncompressDWA;\r\n                break;\r\n            default:\r\n                throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported';\r\n            }\r\n            var size_t;\r\n            var getValue;\r\n            var pixelType = EXRHeader.channels[0].pixelType;\r\n            if (pixelType === 1) {\r\n                switch (this.type) {\r\n                case THREE.FloatType:\r\n                    getValue = parseFloat16;\r\n                    size_t = INT16_SIZE;\r\n                    break;\r\n                case THREE.HalfFloatType:\r\n                    getValue = parseUint16;\r\n                    size_t = INT16_SIZE;\r\n                    break;\r\n                }\r\n            } else if (pixelType === 2) {\r\n                switch (this.type) {\r\n                case THREE.FloatType:\r\n                    getValue = parseFloat32;\r\n                    size_t = FLOAT32_SIZE;\r\n                    break;\r\n                case THREE.HalfFloatType:\r\n                    throw 'EXRLoader.parse: unsupported HalfFloatType texture for FloatType image file.';\r\n                }\r\n            } else {\r\n                throw 'EXRLoader.parse: unsupported pixelType ' + pixelType + ' for ' + EXRHeader.compression + '.';\r\n            }\r\n            var numBlocks = dataWindowHeight / scanlineBlockSize;\r\n            for (var i = 0; i < numBlocks; i++) {\r\n                parseUlong(bufferDataView, offset);\r\n            }\r\n            var width = EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1;\r\n            var height = EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1;\r\n            var numChannels = 4;\r\n            var size = width * height * numChannels;\r\n            switch (this.type) {\r\n            case THREE.FloatType:\r\n                var byteArray = new Float32Array(size);\r\n                if (EXRHeader.channels.length < numChannels) {\r\n                    byteArray.fill(1, 0, size);\r\n                }\r\n                break;\r\n            case THREE.HalfFloatType:\r\n                var byteArray = new Uint16Array(size);\r\n                if (EXRHeader.channels.length < numChannels) {\r\n                    byteArray.fill(15360, 0, size);\r\n                }\r\n                break;\r\n            default:\r\n                console.error('THREE.EXRLoader: unsupported type: ', this.type);\r\n                break;\r\n            }\r\n            var channelOffsets = {\r\n                R: 0,\r\n                G: 1,\r\n                B: 2,\r\n                A: 3\r\n            };\r\n            var compressionInfo = {\r\n                size: 0,\r\n                width: width,\r\n                lines: scanlineBlockSize,\r\n                offset: offset,\r\n                array: uInt8Array,\r\n                viewer: bufferDataView,\r\n                type: pixelType,\r\n                channels: EXRHeader.channels.length\r\n            };\r\n            var line;\r\n            var size;\r\n            var viewer;\r\n            var tmpOffset = { value: 0 };\r\n            for (var scanlineBlockIdx = 0; scanlineBlockIdx < height / scanlineBlockSize; scanlineBlockIdx++) {\r\n                line = parseUint32(bufferDataView, offset);\r\n                size = parseUint32(bufferDataView, offset);\r\n                compressionInfo.lines = line + scanlineBlockSize > height ? height - line : scanlineBlockSize;\r\n                compressionInfo.offset = offset;\r\n                compressionInfo.size = size;\r\n                viewer = uncompress(compressionInfo);\r\n                offset.value += size;\r\n                for (var line_y = 0; line_y < scanlineBlockSize; line_y++) {\r\n                    var true_y = line_y + scanlineBlockIdx * scanlineBlockSize;\r\n                    if (true_y >= height)\r\n                        break;\r\n                    for (var channelID = 0; channelID < EXRHeader.channels.length; channelID++) {\r\n                        var cOff = channelOffsets[EXRHeader.channels[channelID].name];\r\n                        for (var x = 0; x < width; x++) {\r\n                            var idx = line_y * (EXRHeader.channels.length * width) + channelID * width + x;\r\n                            tmpOffset.value = idx * size_t;\r\n                            var val = getValue(viewer, tmpOffset);\r\n                            byteArray[(height - 1 - true_y) * (width * numChannels) + x * numChannels + cOff] = val;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return {\r\n                header: EXRHeader,\r\n                width: width,\r\n                height: height,\r\n                data: byteArray,\r\n                format: numChannels === 4 ? THREE.RGBAFormat : THREE.RGBFormat,\r\n                type: this.type\r\n            };\r\n        },\r\n        setDataType: function (value) {\r\n            this.type = value;\r\n            return this;\r\n        },\r\n        load: function (url, onLoad, onProgress, onError) {\r\n            function onLoadCallback(texture, texData) {\r\n                switch (texture.type) {\r\n                case THREE.FloatType:\r\n                    texture.encoding = THREE.LinearEncoding;\r\n                    texture.minFilter = THREE.LinearFilter;\r\n                    texture.magFilter = THREE.LinearFilter;\r\n                    texture.generateMipmaps = false;\r\n                    texture.flipY = false;\r\n                    break;\r\n                case THREE.HalfFloatType:\r\n                    texture.encoding = THREE.LinearEncoding;\r\n                    texture.minFilter = THREE.LinearFilter;\r\n                    texture.magFilter = THREE.LinearFilter;\r\n                    texture.generateMipmaps = false;\r\n                    texture.flipY = false;\r\n                    break;\r\n                }\r\n                if (onLoad)\r\n                    onLoad(texture, texData);\r\n            }\r\n            return THREE.DataTextureLoader.prototype.load.call(this, url, onLoadCallback, onProgress, onError);\r\n        }\r\n    });\r\n\r\n    return threex.loaders.EXRLoader = EXRLoader;\r\n});"]}