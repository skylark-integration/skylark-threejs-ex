{"version":3,"sources":["loaders/EXRLoader.js"],"names":["define","THREE","ZLib","EXRLoader","manager","DataTextureLoader","call","this","type","FloatType","prototype","Object","assign","create","constructor","parse","buffer","USHORT_RANGE","BITMAP_SIZE","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","HUF_DECMASK","SHORT_ZEROCODE_RUN","LONG_ZEROCODE_RUN","SHORTEST_LONG_RUN","ULONG_SIZE","FLOAT32_SIZE","INT32_SIZE","INT16_SIZE","INT8_SIZE","STATIC_HUFFMAN","DEFLATE","UNKNOWN","LOSSY_DCT","RLE","logBase","Math","pow","getBitsReturn","l","c","lc","getBits","nBits","uInt8Array","inOffset","parseUint8Array","hufTableBuffer","Array","hufUnpackEncTable","inDataView","ni","im","iM","hcode","p","value","zerun","i","nc","hufCanonicalCodeTable","hufLength","code","hufCode","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","Uint8Array","s","Int16","ref","UInt16","wdec14Return","a","b","wdec14","h","ls","hs","ai","as","bs","wav2Decode","j","nx","ox","ny","oy","p2","n","i00","i01","i10","i11","py","ey","oy1","oy2","ox1","ox2","px","ex","p01","p11","p10","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","hdec","len","lit","hufClearDecTable","hdecod","pl","plOffset","hufBuildDecTable","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","hufDecode","predictor","source","t","length","d","interleaveScalar","out","t1","t2","floor","stop","decodeRunLength","size","byteLength","reader","DataView","getInt8","count","push","getUint8","unRleAC","currAcComp","acBuffer","halfZigBlock","acValue","dctComp","dctInverse","data","cos","e","f","g","alpha","beta","theta","gamma","row","rowPtr","column","csc709Inverse","y","cb","cr","convertToHalf","src","dst","idx","encodeFloat16","toLinear","float","sign","abs","uncompressZIP","info","compressed","array","slice","offset","Zlib","console","error","inflate","Inflate","resize","verify","rawBuffer","decompress","tmpBuffer","uncompressDWA","viewer","width","lines","EXRHeader","channels","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","compression","channelRules","ruleSize","parseUint16","name","parseNullTerminatedString","parseUint8","index","Int8Array","channelData","cd","channel","decoded","pixelType","pLinear","height","cscSet","rule","Uint16Array","zlibInfo","dcBuffer","rleBuffer","outBufferEnd","rowOffsets","chan","rowPtrs","dataView","numFullBlocksX","numBlocksX","ceil","numBlocksY","leftoverX","leftoverY","currDcComp","dctData","rowBlock","comp","Float32Array","blocky","maxY","maxX","blockx","fill","decodeFloat16","setUint16","x","halfRow","getUint16","setFloat32","lossyDctDecode","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","TextDecoder","decode","parseUlong","uLong","getUint32","Uint32","Uint8","int","Number","getBigInt64","parseFloat32","getFloat32","binary","exponent","fraction","NaN","Infinity","floatView","int32View","Int32Array","val","bits","m","Uint16","parseValue","parseFixedLengthString","startOffset","xSampling","ySampling","parseChlist","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseChromaticities","parseCompression","xMin","yMin","xMax","yMax","parseBox2i","parseLineOrder","parseV2f","bufferDataView","keepReading","attributeName","attributeValue","uncompress","scanlineBlockSize","size_t","getValue","dataWindowHeight","dataWindow","tmpBufSize","bitmap","pizChannelData","minNonZero","maxNonZero","lut","k","reverseLutFromBitmap","start","nData","applyLut","tmpOffset","cp","end","set","HalfFloatType","numBlocks","byteArray","line","channelOffsets","R","G","B","A","compressionInfo","scanlineBlockIdx","line_y","true_y","channelID","cOff","header","format","RGBAFormat","setDataType","load","url","onLoad","onProgress","onError","texture","texData","encoding","LinearEncoding","minFilter","LinearFilter","magFilter","generateMipmaps","flipY"],"mappings":"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,IAC/BC,EAAK,GAAMqF,GAAetF,EAAK,IAE/BC,EAAK,IAAOqF,GAAetF,EAAK,IAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,IAChCC,EAAK,IAAOqF,GAAetF,EAAK,IAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAEhCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,IAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAEhCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAEhCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GAAetF,EAAK,KAChCC,EAAK,IAAOqF,GA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","file":"../../loaders/EXRLoader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE,ZLib){\n\t/**\n\t * @author Richard M. / https://github.com/richardmonette\n\t * @author ScieCode / http://github.com/sciecode\n\t *\n\t * OpenEXR loader which, currently, supports uncompressed, ZIP(S), RLE and PIZ wavelet compression.\n\t * Supports reading 16 and 32 bit data format.\n\t *\n\t * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n\t * implementation, so I have preserved their copyright notices.\n\t */\n\n\t// /*\n\t// Copyright (c) 2014 - 2017, Syoyo Fujita\n\t// All rights reserved.\n\n\t// Redistribution and use in source and binary forms, with or without\n\t// modification, are permitted provided that the following conditions are met:\n\t//     * Redistributions of source code must retain the above copyright\n\t//       notice, this list of conditions and the following disclaimer.\n\t//     * Redistributions in binary form must reproduce the above copyright\n\t//       notice, this list of conditions and the following disclaimer in the\n\t//       documentation and/or other materials provided with the distribution.\n\t//     * Neither the name of the Syoyo Fujita nor the\n\t//       names of its contributors may be used to endorse or promote products\n\t//       derived from this software without specific prior written permission.\n\n\t// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n\t// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n\t// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n\t// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n\t// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n\t// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n\t// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n\t// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n\t// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t// */\n\n\t// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n\t// ///////////////////////////////////////////////////////////////////////////\n\t// //\n\t// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n\t// // Digital Ltd. LLC\n\t// //\n\t// // All rights reserved.\n\t// //\n\t// // Redistribution and use in source and binary forms, with or without\n\t// // modification, are permitted provided that the following conditions are\n\t// // met:\n\t// // *       Redistributions of source code must retain the above copyright\n\t// // notice, this list of conditions and the following disclaimer.\n\t// // *       Redistributions in binary form must reproduce the above\n\t// // copyright notice, this list of conditions and the following disclaimer\n\t// // in the documentation and/or other materials provided with the\n\t// // distribution.\n\t// // *       Neither the name of Industrial Light & Magic nor the names of\n\t// // its contributors may be used to endorse or promote products derived\n\t// // from this software without specific prior written permission.\n\t// //\n\t// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t// //\n\t// ///////////////////////////////////////////////////////////////////////////\n\n\t// // End of OpenEXR license -------------------------------------------------\n\n\tTHREE.EXRLoader = function ( manager ) {\n\n\t\tTHREE.DataTextureLoader.call( this, manager );\n\n\t\tthis.type = THREE.FloatType;\n\n\t};\n\n\tTHREE.EXRLoader.prototype = Object.assign( Object.create( THREE.DataTextureLoader.prototype ), {\n\n\t\tconstructor: THREE.EXRLoader,\n\n\t\tparse: function ( buffer ) {\n\n\t\t\tconst USHORT_RANGE = ( 1 << 16 );\n\t\t\tconst BITMAP_SIZE = ( USHORT_RANGE >> 3 );\n\n\t\t\tconst HUF_ENCBITS = 16; // literal (value) bit length\n\t\t\tconst HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n\t\t\tconst HUF_ENCSIZE = ( 1 << HUF_ENCBITS ) + 1; // encoding table size\n\t\t\tconst HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\t\t\tconst HUF_DECMASK = HUF_DECSIZE - 1;\n\n\t\t\tconst SHORT_ZEROCODE_RUN = 59;\n\t\t\tconst LONG_ZEROCODE_RUN = 63;\n\t\t\tconst SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n\n\t\t\tconst ULONG_SIZE = 8;\n\t\t\tconst FLOAT32_SIZE = 4;\n\t\t\tconst INT32_SIZE = 4;\n\t\t\tconst INT16_SIZE = 2;\n\t\t\tconst INT8_SIZE = 1;\n\n\t\t\tconst STATIC_HUFFMAN = 0;\n\t\t\tconst DEFLATE = 1;\n\n\t\t\tconst UNKNOWN = 0;\n\t\t\tconst LOSSY_DCT = 1;\n\t\t\tconst RLE = 2;\n\n\t\t\tconst logBase = Math.pow( 2.7182818, 2.2 );\n\n\t\t\tfunction reverseLutFromBitmap( bitmap, lut ) {\n\n\t\t\t\tvar k = 0;\n\n\t\t\t\tfor ( var i = 0; i < USHORT_RANGE; ++ i ) {\n\n\t\t\t\t\tif ( ( i == 0 ) || ( bitmap[ i >> 3 ] & ( 1 << ( i & 7 ) ) ) ) {\n\n\t\t\t\t\t\tlut[ k ++ ] = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar n = k - 1;\n\n\t\t\t\twhile ( k < USHORT_RANGE ) lut[ k ++ ] = 0;\n\n\t\t\t\treturn n;\n\n\t\t\t}\n\n\t\t\tfunction hufClearDecTable( hdec ) {\n\n\t\t\t\tfor ( var i = 0; i < HUF_DECSIZE; i ++ ) {\n\n\t\t\t\t\thdec[ i ] = {};\n\t\t\t\t\thdec[ i ].len = 0;\n\t\t\t\t\thdec[ i ].lit = 0;\n\t\t\t\t\thdec[ i ].p = null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst getBitsReturn = { l: 0, c: 0, lc: 0 };\n\n\t\t\tfunction getBits( nBits, c, lc, uInt8Array, inOffset ) {\n\n\t\t\t\twhile ( lc < nBits ) {\n\n\t\t\t\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\n\t\t\t\t\tlc += 8;\n\n\t\t\t\t}\n\n\t\t\t\tlc -= nBits;\n\n\t\t\t\tgetBitsReturn.l = ( c >> lc ) & ( ( 1 << nBits ) - 1 );\n\t\t\t\tgetBitsReturn.c = c;\n\t\t\t\tgetBitsReturn.lc = lc;\n\n\t\t\t}\n\n\t\t\tconst hufTableBuffer = new Array( 59 );\n\n\t\t\tfunction hufCanonicalCodeTable( hcode ) {\n\n\t\t\t\tfor ( var i = 0; i <= 58; ++ i ) hufTableBuffer[ i ] = 0;\n\t\t\t\tfor ( var i = 0; i < HUF_ENCSIZE; ++ i ) hufTableBuffer[ hcode[ i ] ] += 1;\n\n\t\t\t\tvar c = 0;\n\n\t\t\t\tfor ( var i = 58; i > 0; -- i ) {\n\n\t\t\t\t\tvar nc = ( ( c + hufTableBuffer[ i ] ) >> 1 );\n\t\t\t\t\thufTableBuffer[ i ] = c;\n\t\t\t\t\tc = nc;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < HUF_ENCSIZE; ++ i ) {\n\n\t\t\t\t\tvar l = hcode[ i ];\n\t\t\t\t\tif ( l > 0 ) hcode[ i ] = l | ( hufTableBuffer[ l ] ++ << 6 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction hufUnpackEncTable( uInt8Array, inDataView, inOffset, ni, im, iM, hcode ) {\n\n\t\t\t\tvar p = inOffset;\n\t\t\t\tvar c = 0;\n\t\t\t\tvar lc = 0;\n\n\t\t\t\tfor ( ; im <= iM; im ++ ) {\n\n\t\t\t\t\tif ( p.value - inOffset.value > ni ) return false;\n\n\t\t\t\t\tgetBits( 6, c, lc, uInt8Array, p );\n\n\t\t\t\t\tvar l = getBitsReturn.l;\n\t\t\t\t\tc = getBitsReturn.c;\n\t\t\t\t\tlc = getBitsReturn.lc;\n\n\t\t\t\t\thcode[ im ] = l;\n\n\t\t\t\t\tif ( l == LONG_ZEROCODE_RUN ) {\n\n\t\t\t\t\t\tif ( p.value - inOffset.value > ni ) {\n\n\t\t\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgetBits( 8, c, lc, uInt8Array, p );\n\n\t\t\t\t\t\tvar zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n\t\t\t\t\t\tc = getBitsReturn.c;\n\t\t\t\t\t\tlc = getBitsReturn.lc;\n\n\t\t\t\t\t\tif ( im + zerun > iM + 1 ) {\n\n\t\t\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile ( zerun -- ) hcode[ im ++ ] = 0;\n\n\t\t\t\t\t\tim --;\n\n\t\t\t\t\t} else if ( l >= SHORT_ZEROCODE_RUN ) {\n\n\t\t\t\t\t\tvar zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n\t\t\t\t\t\tif ( im + zerun > iM + 1 ) {\n\n\t\t\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile ( zerun -- ) hcode[ im ++ ] = 0;\n\n\t\t\t\t\t\tim --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\thufCanonicalCodeTable( hcode );\n\n\t\t\t}\n\n\t\t\tfunction hufLength( code ) {\n\n\t\t\t\treturn code & 63;\n\n\t\t\t}\n\n\t\t\tfunction hufCode( code ) {\n\n\t\t\t\treturn code >> 6;\n\n\t\t\t}\n\n\t\t\tfunction hufBuildDecTable( hcode, im, iM, hdecod ) {\n\n\t\t\t\tfor ( ; im <= iM; im ++ ) {\n\n\t\t\t\t\tvar c = hufCode( hcode[ im ] );\n\t\t\t\t\tvar l = hufLength( hcode[ im ] );\n\n\t\t\t\t\tif ( c >> l ) {\n\n\t\t\t\t\t\tthrow 'Invalid table entry';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( l > HUF_DECBITS ) {\n\n\t\t\t\t\t\tvar pl = hdecod[ ( c >> ( l - HUF_DECBITS ) ) ];\n\n\t\t\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\t\t\tthrow 'Invalid table entry';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpl.lit ++;\n\n\t\t\t\t\t\tif ( pl.p ) {\n\n\t\t\t\t\t\t\tvar p = pl.p;\n\t\t\t\t\t\t\tpl.p = new Array( pl.lit );\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < pl.lit - 1; ++ i ) {\n\n\t\t\t\t\t\t\t\tpl.p[ i ] = p[ i ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tpl.p = new Array( 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpl.p[ pl.lit - 1 ] = im;\n\n\t\t\t\t\t} else if ( l ) {\n\n\t\t\t\t\t\tvar plOffset = 0;\n\n\t\t\t\t\t\tfor ( var i = 1 << ( HUF_DECBITS - l ); i > 0; i -- ) {\n\n\t\t\t\t\t\t\tvar pl = hdecod[ ( c << ( HUF_DECBITS - l ) ) + plOffset ];\n\n\t\t\t\t\t\t\tif ( pl.len || pl.p ) {\n\n\t\t\t\t\t\t\t\tthrow 'Invalid table entry';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpl.len = l;\n\t\t\t\t\t\t\tpl.lit = im;\n\n\t\t\t\t\t\t\tplOffset ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tconst getCharReturn = { c: 0, lc: 0 };\n\n\t\t\tfunction getChar( c, lc, uInt8Array, inOffset ) {\n\n\t\t\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\n\t\t\t\tlc += 8;\n\n\t\t\t\tgetCharReturn.c = c;\n\t\t\t\tgetCharReturn.lc = lc;\n\n\t\t\t}\n\n\t\t\tconst getCodeReturn = { c: 0, lc: 0 };\n\n\t\t\tfunction getCode( po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {\n\n\t\t\t\tif ( po == rlc ) {\n\n\t\t\t\t\tif ( lc < 8 ) {\n\n\t\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\t\t\t\t\t\tc = getCharReturn.c;\n\t\t\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlc -= 8;\n\n\t\t\t\t\tvar cs = ( c >> lc );\n\t\t\t\t\tvar cs = new Uint8Array( [ cs ] )[ 0 ];\n\n\t\t\t\t\tif ( outBufferOffset.value + cs > outBufferEndOffset ) {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar s = outBuffer[ outBufferOffset.value - 1 ];\n\n\t\t\t\t\twhile ( cs -- > 0 ) {\n\n\t\t\t\t\t\toutBuffer[ outBufferOffset.value ++ ] = s;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( outBufferOffset.value < outBufferEndOffset ) {\n\n\t\t\t\t\toutBuffer[ outBufferOffset.value ++ ] = po;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tgetCodeReturn.c = c;\n\t\t\t\tgetCodeReturn.lc = lc;\n\n\t\t\t}\n\n\t\t\tfunction UInt16( value ) {\n\n\t\t\t\treturn ( value & 0xFFFF );\n\n\t\t\t}\n\n\t\t\tfunction Int16( value ) {\n\n\t\t\t\tvar ref = UInt16( value );\n\t\t\t\treturn ( ref > 0x7FFF ) ? ref - 0x10000 : ref;\n\n\t\t\t}\n\n\t\t\tconst wdec14Return = { a: 0, b: 0 };\n\n\t\t\tfunction wdec14( l, h ) {\n\n\t\t\t\tvar ls = Int16( l );\n\t\t\t\tvar hs = Int16( h );\n\n\t\t\t\tvar hi = hs;\n\t\t\t\tvar ai = ls + ( hi & 1 ) + ( hi >> 1 );\n\n\t\t\t\tvar as = ai;\n\t\t\t\tvar bs = ai - hi;\n\n\t\t\t\twdec14Return.a = as;\n\t\t\t\twdec14Return.b = bs;\n\n\t\t\t}\n\n\t\t\tfunction wav2Decode( buffer, j, nx, ox, ny, oy ) {\n\n\t\t\t\tvar n = ( nx > ny ) ? ny : nx;\n\t\t\t\tvar p = 1;\n\t\t\t\tvar p2;\n\n\t\t\t\twhile ( p <= n ) p <<= 1;\n\n\t\t\t\tp >>= 1;\n\t\t\t\tp2 = p;\n\t\t\t\tp >>= 1;\n\n\t\t\t\twhile ( p >= 1 ) {\n\n\t\t\t\t\tvar py = 0;\n\t\t\t\t\tvar ey = py + oy * ( ny - p2 );\n\t\t\t\t\tvar oy1 = oy * p;\n\t\t\t\t\tvar oy2 = oy * p2;\n\t\t\t\t\tvar ox1 = ox * p;\n\t\t\t\t\tvar ox2 = ox * p2;\n\t\t\t\t\tvar i00, i01, i10, i11;\n\n\t\t\t\t\tfor ( ; py <= ey; py += oy2 ) {\n\n\t\t\t\t\t\tvar px = py;\n\t\t\t\t\t\tvar ex = py + ox * ( nx - p2 );\n\n\t\t\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\n\n\t\t\t\t\t\t\tvar p01 = px + ox1;\n\t\t\t\t\t\t\tvar p10 = px + oy1;\n\t\t\t\t\t\t\tvar p11 = p10 + ox1;\n\n\t\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\n\n\t\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\t\ti10 = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec14( buffer[ p01 + j ], buffer[ p11 + j ] );\n\n\t\t\t\t\t\t\ti01 = wdec14Return.a;\n\t\t\t\t\t\t\ti11 = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec14( i00, i01 );\n\n\t\t\t\t\t\t\tbuffer[ px + j ] = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\t\twdec14( i10, i11 );\n\n\t\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p11 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( nx & p ) {\n\n\t\t\t\t\t\t\tvar p10 = px + oy1;\n\n\t\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\n\n\t\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\t\tbuffer[ px + j ] = i00;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ny & p ) {\n\n\t\t\t\t\t\tvar px = py;\n\t\t\t\t\t\tvar ex = py + ox * ( nx - p2 );\n\n\t\t\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\n\n\t\t\t\t\t\t\tvar p01 = px + ox1;\n\n\t\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p01 + j ] );\n\n\t\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\t\tbuffer[ px + j ] = i00;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tp2 = p;\n\t\t\t\t\tp >>= 1;\n\n\t\t\t\t}\n\n\t\t\t\treturn py;\n\n\t\t\t}\n\n\t\t\tfunction hufDecode( encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset ) {\n\n\t\t\t\tvar c = 0;\n\t\t\t\tvar lc = 0;\n\t\t\t\tvar outBufferEndOffset = no;\n\t\t\t\tvar inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );\n\n\t\t\t\twhile ( inOffset.value < inOffsetEnd ) {\n\n\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\n\t\t\t\t\tc = getCharReturn.c;\n\t\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\t\twhile ( lc >= HUF_DECBITS ) {\n\n\t\t\t\t\t\tvar index = ( c >> ( lc - HUF_DECBITS ) ) & HUF_DECMASK;\n\t\t\t\t\t\tvar pl = decodingTable[ index ];\n\n\t\t\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\t\t\tlc -= pl.len;\n\n\t\t\t\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( ! pl.p ) {\n\n\t\t\t\t\t\t\t\tthrow 'hufDecode issues';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar j;\n\n\t\t\t\t\t\t\tfor ( j = 0; j < pl.lit; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar l = hufLength( encodingTable[ pl.p[ j ] ] );\n\n\t\t\t\t\t\t\t\twhile ( lc < l && inOffset.value < inOffsetEnd ) {\n\n\t\t\t\t\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\n\t\t\t\t\t\t\t\t\tc = getCharReturn.c;\n\t\t\t\t\t\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( lc >= l ) {\n\n\t\t\t\t\t\t\t\t\tif ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( ( c >> ( lc - l ) ) & ( ( 1 << l ) - 1 ) ) ) {\n\n\t\t\t\t\t\t\t\t\t\tlc -= l;\n\n\t\t\t\t\t\t\t\t\t\tgetCode( pl.p[ j ], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\t\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\t\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j == pl.lit ) {\n\n\t\t\t\t\t\t\t\tthrow 'hufDecode issues';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar i = ( 8 - ni ) & 7;\n\n\t\t\t\tc >>= i;\n\t\t\t\tlc -= i;\n\n\t\t\t\twhile ( lc > 0 ) {\n\n\t\t\t\t\tvar pl = decodingTable[ ( c << ( HUF_DECBITS - lc ) ) & HUF_DECMASK ];\n\n\t\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\t\tlc -= pl.len;\n\n\t\t\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow 'hufDecode issues';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tfunction hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw ) {\n\n\t\t\t\tvar outOffset = { value: 0 };\n\t\t\t\tvar initialInOffset = inOffset.value;\n\n\t\t\t\tvar im = parseUint32( inDataView, inOffset );\n\t\t\t\tvar iM = parseUint32( inDataView, inOffset );\n\n\t\t\t\tinOffset.value += 4;\n\n\t\t\t\tvar nBits = parseUint32( inDataView, inOffset );\n\n\t\t\t\tinOffset.value += 4;\n\n\t\t\t\tif ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) {\n\n\t\t\t\t\tthrow 'Something wrong with HUF_ENCSIZE';\n\n\t\t\t\t}\n\n\t\t\t\tvar freq = new Array( HUF_ENCSIZE );\n\t\t\t\tvar hdec = new Array( HUF_DECSIZE );\n\n\t\t\t\thufClearDecTable( hdec );\n\n\t\t\t\tvar ni = nCompressed - ( inOffset.value - initialInOffset );\n\n\t\t\t\thufUnpackEncTable( uInt8Array, inDataView, inOffset, ni, im, iM, freq );\n\n\t\t\t\tif ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {\n\n\t\t\t\t\tthrow 'Something wrong with hufUncompress';\n\n\t\t\t\t}\n\n\t\t\t\thufBuildDecTable( freq, im, iM, hdec );\n\n\t\t\t\thufDecode( freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset );\n\n\t\t\t}\n\n\t\t\tfunction applyLut( lut, data, nData ) {\n\n\t\t\t\tfor ( var i = 0; i < nData; ++ i ) {\n\n\t\t\t\t\tdata[ i ] = lut[ data[ i ] ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction predictor( source ) {\n\n\t\t\t\tfor ( var t = 1; t < source.length; t ++ ) {\n\n\t\t\t\t\tvar d = source[ t - 1 ] + source[ t ] - 128;\n\t\t\t\t\tsource[ t ] = d;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction interleaveScalar( source, out ) {\n\n\t\t\t\tvar t1 = 0;\n\t\t\t\tvar t2 = Math.floor( ( source.length + 1 ) / 2 );\n\t\t\t\tvar s = 0;\n\t\t\t\tvar stop = source.length - 1;\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tif ( s > stop ) break;\n\t\t\t\t\tout[ s ++ ] = source[ t1 ++ ];\n\n\t\t\t\t\tif ( s > stop ) break;\n\t\t\t\t\tout[ s ++ ] = source[ t2 ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction decodeRunLength( source ) {\n\n\t\t\t\tvar size = source.byteLength;\n\t\t\t\tvar out = new Array();\n\t\t\t\tvar p = 0;\n\n\t\t\t\tvar reader = new DataView( source );\n\n\t\t\t\twhile ( size > 0 ) {\n\n\t\t\t\t\tvar l = reader.getInt8( p ++ );\n\n\t\t\t\t\tif ( l < 0 ) {\n\n\t\t\t\t\t\tvar count = - l;\n\t\t\t\t\t\tsize -= count + 1;\n\n\t\t\t\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\tout.push( reader.getUint8( p ++ ) );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar count = l;\n\t\t\t\t\t\tsize -= 2;\n\n\t\t\t\t\t\tvar value = reader.getUint8( p ++ );\n\n\t\t\t\t\t\tfor ( var i = 0; i < count + 1; i ++ ) {\n\n\t\t\t\t\t\t\tout.push( value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn out;\n\n\t\t\t}\n\n\t\t\tfunction lossyDctDecode( cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer ) {\n\n\t\t\t\tvar dataView = new DataView( outBuffer.buffer );\n\n\t\t\t\tvar width = channelData[ cscSet.idx[ 0 ] ].width;\n\t\t\t\tvar height = channelData[ cscSet.idx[ 0 ] ].height;\n\n\t\t\t\tvar numComp = 3;\n\n\t\t\t\tvar numFullBlocksX = Math.floor( width / 8.0 );\n\t\t\t\tvar numBlocksX = Math.ceil( width / 8.0 );\n\t\t\t\tvar numBlocksY = Math.ceil( height / 8.0 );\n\t\t\t\tvar leftoverX = width - ( numBlocksX - 1 ) * 8;\n\t\t\t\tvar leftoverY = height - ( numBlocksY - 1 ) * 8;\n\n\t\t\t\tvar currAcComp = { value: 0 };\n\t\t\t\tvar currDcComp = new Array( numComp );\n\t\t\t\tvar dctData = new Array( numComp );\n\t\t\t\tvar halfZigBlock = new Array( numComp );\n\t\t\t\tvar rowBlock = new Array( numComp );\n\t\t\t\tvar rowOffsets = new Array( numComp );\n\n\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\trowOffsets[ comp ] = rowPtrs[ cscSet.idx[ comp ] ];\n\t\t\t\t\tcurrDcComp[ comp ] = ( comp < 1 ) ? 0 : currDcComp[ comp - 1 ] + numBlocksX * numBlocksY;\n\t\t\t\t\tdctData[ comp ] = new Float32Array( 64 );\n\t\t\t\t\thalfZigBlock[ comp ] = new Uint16Array( 64 );\n\t\t\t\t\trowBlock[ comp ] = new Uint16Array( numBlocksX * 64 );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let blocky = 0; blocky < numBlocksY; ++ blocky ) {\n\n\t\t\t\t\tvar maxY = 8;\n\n\t\t\t\t\tif ( blocky == numBlocksY - 1 )\n\t\t\t\t\t\tmaxY = leftoverY;\n\n\t\t\t\t\tvar maxX = 8;\n\n\t\t\t\t\tfor ( let blockx = 0; blockx < numBlocksX; ++ blockx ) {\n\n\t\t\t\t\t\tif ( blockx == numBlocksX - 1 )\n\t\t\t\t\t\t\tmaxX = leftoverX;\n\n\t\t\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\t\t\thalfZigBlock[ comp ].fill( 0 );\n\n\t\t\t\t\t\t\t// set block DC component\n\t\t\t\t\t\t\thalfZigBlock[ comp ][ 0 ] = dcBuffer[ currDcComp[ comp ] ++ ];\n\t\t\t\t\t\t\t// set block AC components\n\t\t\t\t\t\t\tunRleAC( currAcComp, acBuffer, halfZigBlock[ comp ] );\n\n\t\t\t\t\t\t\t// UnZigZag block to float\n\t\t\t\t\t\t\tunZigZag( halfZigBlock[ comp ], dctData[ comp ] );\n\t\t\t\t\t\t\t// decode float dct\n\t\t\t\t\t\t\tdctInverse( dctData[ comp ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( numComp == 3 ) {\n\n\t\t\t\t\t\t\tcsc709Inverse( dctData );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\t\t\tconvertToHalf( dctData[ comp ], rowBlock[ comp ], blockx * 64 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // blockx\n\n\t\t\t\t\tlet offset = 0;\n\n\t\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\t\tlet type = channelData[ cscSet.idx[ comp ] ].type;\n\n\t\t\t\t\t\tfor ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {\n\n\t\t\t\t\t\t\toffset = rowOffsets[ comp ][ y ];\n\n\t\t\t\t\t\t\tfor ( let blockx = 0; blockx < numFullBlocksX; ++ blockx ) {\n\n\t\t\t\t\t\t\t\tlet src = blockx * 64 + ( ( y & 0x7 ) * 8 );\n\n\t\t\t\t\t\t\t\tdataView.setUint16( offset + 0 * INT16_SIZE * type, rowBlock[ comp ][ src + 0 ], true );\n\t\t\t\t\t\t\t\tdataView.setUint16( offset + 1 * INT16_SIZE * type, rowBlock[ comp ][ src + 1 ], true );\n\t\t\t\t\t\t\t\tdataView.setUint16( offset + 2 * INT16_SIZE * type, rowBlock[ comp ][ src + 2 ], true );\n\t\t\t\t\t\t\t\tdataView.setUint16( offset + 3 * INT16_SIZE * type, rowBlock[ comp ][ src + 3 ], true );\n\n\t\t\t\t\t\t\t\tdataView.setUint16( offset + 4 * INT16_SIZE * type, rowBlock[ comp ][ src + 4 ], true );\n\t\t\t\t\t\t\t\tdataView.setUint16( offset + 5 * INT16_SIZE * type, rowBlock[ comp ][ src + 5 ], true );\n\t\t\t\t\t\t\t\tdataView.setUint16( offset + 6 * INT16_SIZE * type, rowBlock[ comp ][ src + 6 ], true );\n\t\t\t\t\t\t\t\tdataView.setUint16( offset + 7 * INT16_SIZE * type, rowBlock[ comp ][ src + 7 ], true );\n\n\t\t\t\t\t\t\t\toffset += 8 * INT16_SIZE * type;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// handle partial X blocks\n\t\t\t\t\t\tif ( numFullBlocksX != numBlocksX ) {\n\n\t\t\t\t\t\t\tfor ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {\n\n\t\t\t\t\t\t\t\tlet offset = rowOffsets[ comp ][ y ] + 8 * numFullBlocksX * INT16_SIZE * type;\n\t\t\t\t\t\t\t\tlet src = numFullBlocksX * 64 + ( ( y & 0x7 ) * 8 );\n\n\t\t\t\t\t\t\t\tfor ( let x = 0; x < maxX; ++ x ) {\n\n\t\t\t\t\t\t\t\t\tdataView.setUint16( offset + x * INT16_SIZE * type, rowBlock[ comp ][ src + x ], true );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // comp\n\n\t\t\t\t} // blocky\n\n\t\t\t\tvar halfRow = new Uint16Array( width );\n\t\t\t\tvar dataView = new DataView( outBuffer.buffer );\n\n\t\t\t\t// convert channels back to float, if needed\n\t\t\t\tfor ( var comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\tchannelData[ cscSet.idx[ comp ] ].decoded = true;\n\t\t\t\t\tvar type = channelData[ cscSet.idx[ comp ] ].type;\n\n\t\t\t\t\tif ( channelData[ comp ].type != 2 ) continue;\n\n\t\t\t\t\tfor ( var y = 0; y < height; ++ y ) {\n\n\t\t\t\t\t\tlet offset = rowOffsets[ comp ][ y ];\n\n\t\t\t\t\t\tfor ( var x = 0; x < width; ++ x ) {\n\n\t\t\t\t\t\t\thalfRow[ x ] = dataView.getUint16( offset + x * INT16_SIZE * type, true );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( var x = 0; x < width; ++ x ) {\n\n\t\t\t\t\t\t\tdataView.setFloat32( offset + x * INT16_SIZE * type, decodeFloat16( halfRow[ x ] ), true );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction unRleAC( currAcComp, acBuffer, halfZigBlock ) {\n\n\t\t\t\tvar acValue;\n\t\t\t\tvar dctComp = 1;\n\n\t\t\t\twhile ( dctComp < 64 ) {\n\n\t\t\t\t\tacValue = acBuffer[ currAcComp.value ];\n\n\t\t\t\t\tif ( acValue == 0xff00 ) {\n\n\t\t\t\t\t\tdctComp = 64;\n\n\t\t\t\t\t} else if ( acValue >> 8 == 0xff ) {\n\n\t\t\t\t\t\tdctComp += acValue & 0xff;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\thalfZigBlock[ dctComp ] = acValue;\n\t\t\t\t\t\tdctComp ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrAcComp.value ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction unZigZag( src, dst ) {\n\n\t\t\t\tdst[ 0 ] = decodeFloat16( src[ 0 ] );\n\t\t\t\tdst[ 1 ] = decodeFloat16( src[ 1 ] );\n\t\t\t\tdst[ 2 ] = decodeFloat16( src[ 5 ] );\n\t\t\t\tdst[ 3 ] = decodeFloat16( src[ 6 ] );\n\t\t\t\tdst[ 4 ] = decodeFloat16( src[ 14 ] );\n\t\t\t\tdst[ 5 ] = decodeFloat16( src[ 15 ] );\n\t\t\t\tdst[ 6 ] = decodeFloat16( src[ 27 ] );\n\t\t\t\tdst[ 7 ] = decodeFloat16( src[ 28 ] );\n\t\t\t\tdst[ 8 ] = decodeFloat16( src[ 2 ] );\n\t\t\t\tdst[ 9 ] = decodeFloat16( src[ 4 ] );\n\n\t\t\t\tdst[ 10 ] = decodeFloat16( src[ 7 ] );\n\t\t\t\tdst[ 11 ] = decodeFloat16( src[ 13 ] );\n\t\t\t\tdst[ 12 ] = decodeFloat16( src[ 16 ] );\n\t\t\t\tdst[ 13 ] = decodeFloat16( src[ 26 ] );\n\t\t\t\tdst[ 14 ] = decodeFloat16( src[ 29 ] );\n\t\t\t\tdst[ 15 ] = decodeFloat16( src[ 42 ] );\n\t\t\t\tdst[ 16 ] = decodeFloat16( src[ 3 ] );\n\t\t\t\tdst[ 17 ] = decodeFloat16( src[ 8 ] );\n\t\t\t\tdst[ 18 ] = decodeFloat16( src[ 12 ] );\n\t\t\t\tdst[ 19 ] = decodeFloat16( src[ 17 ] );\n\n\t\t\t\tdst[ 20 ] = decodeFloat16( src[ 25 ] );\n\t\t\t\tdst[ 21 ] = decodeFloat16( src[ 30 ] );\n\t\t\t\tdst[ 22 ] = decodeFloat16( src[ 41 ] );\n\t\t\t\tdst[ 23 ] = decodeFloat16( src[ 43 ] );\n\t\t\t\tdst[ 24 ] = decodeFloat16( src[ 9 ] );\n\t\t\t\tdst[ 25 ] = decodeFloat16( src[ 11 ] );\n\t\t\t\tdst[ 26 ] = decodeFloat16( src[ 18 ] );\n\t\t\t\tdst[ 27 ] = decodeFloat16( src[ 24 ] );\n\t\t\t\tdst[ 28 ] = decodeFloat16( src[ 31 ] );\n\t\t\t\tdst[ 29 ] = decodeFloat16( src[ 40 ] );\n\n\t\t\t\tdst[ 30 ] = decodeFloat16( src[ 44 ] );\n\t\t\t\tdst[ 31 ] = decodeFloat16( src[ 53 ] );\n\t\t\t\tdst[ 32 ] = decodeFloat16( src[ 10 ] );\n\t\t\t\tdst[ 33 ] = decodeFloat16( src[ 19 ] );\n\t\t\t\tdst[ 34 ] = decodeFloat16( src[ 23 ] );\n\t\t\t\tdst[ 35 ] = decodeFloat16( src[ 32 ] );\n\t\t\t\tdst[ 36 ] = decodeFloat16( src[ 39 ] );\n\t\t\t\tdst[ 37 ] = decodeFloat16( src[ 45 ] );\n\t\t\t\tdst[ 38 ] = decodeFloat16( src[ 52 ] );\n\t\t\t\tdst[ 39 ] = decodeFloat16( src[ 54 ] );\n\n\t\t\t\tdst[ 40 ] = decodeFloat16( src[ 20 ] );\n\t\t\t\tdst[ 41 ] = decodeFloat16( src[ 22 ] );\n\t\t\t\tdst[ 42 ] = decodeFloat16( src[ 33 ] );\n\t\t\t\tdst[ 43 ] = decodeFloat16( src[ 38 ] );\n\t\t\t\tdst[ 44 ] = decodeFloat16( src[ 46 ] );\n\t\t\t\tdst[ 45 ] = decodeFloat16( src[ 51 ] );\n\t\t\t\tdst[ 46 ] = decodeFloat16( src[ 55 ] );\n\t\t\t\tdst[ 47 ] = decodeFloat16( src[ 60 ] );\n\t\t\t\tdst[ 48 ] = decodeFloat16( src[ 21 ] );\n\t\t\t\tdst[ 49 ] = decodeFloat16( src[ 34 ] );\n\n\t\t\t\tdst[ 50 ] = decodeFloat16( src[ 37 ] );\n\t\t\t\tdst[ 51 ] = decodeFloat16( src[ 47 ] );\n\t\t\t\tdst[ 52 ] = decodeFloat16( src[ 50 ] );\n\t\t\t\tdst[ 53 ] = decodeFloat16( src[ 56 ] );\n\t\t\t\tdst[ 54 ] = decodeFloat16( src[ 59 ] );\n\t\t\t\tdst[ 55 ] = decodeFloat16( src[ 61 ] );\n\t\t\t\tdst[ 56 ] = decodeFloat16( src[ 35 ] );\n\t\t\t\tdst[ 57 ] = decodeFloat16( src[ 36 ] );\n\t\t\t\tdst[ 58 ] = decodeFloat16( src[ 48 ] );\n\t\t\t\tdst[ 59 ] = decodeFloat16( src[ 49 ] );\n\n\t\t\t\tdst[ 60 ] = decodeFloat16( src[ 57 ] );\n\t\t\t\tdst[ 61 ] = decodeFloat16( src[ 58 ] );\n\t\t\t\tdst[ 62 ] = decodeFloat16( src[ 62 ] );\n\t\t\t\tdst[ 63 ] = decodeFloat16( src[ 63 ] );\n\n\t\t\t}\n\n\t\t\tfunction dctInverse( data ) {\n\n\t\t\t\tconst a = 0.5 * Math.cos( 3.14159 / 4.0 );\n\t\t\t\tconst b = 0.5 * Math.cos( 3.14159 / 16.0 );\n\t\t\t\tconst c = 0.5 * Math.cos( 3.14159 / 8.0 );\n\t\t\t\tconst d = 0.5 * Math.cos( 3.0 * 3.14159 / 16.0 );\n\t\t\t\tconst e = 0.5 * Math.cos( 5.0 * 3.14159 / 16.0 );\n\t\t\t\tconst f = 0.5 * Math.cos( 3.0 * 3.14159 / 8.0 );\n\t\t\t\tconst g = 0.5 * Math.cos( 7.0 * 3.14159 / 16.0 );\n\n\t\t\t\tvar alpha = new Array( 4 );\n\t\t\t\tvar beta = new Array( 4 );\n\t\t\t\tvar theta = new Array( 4 );\n\t\t\t\tvar gamma = new Array( 4 );\n\n\t\t\t\tfor ( var row = 0; row < 8; ++ row ) {\n\n\t\t\t\t\tvar rowPtr = row * 8;\n\n\t\t\t\t\talpha[ 0 ] = c * data[ rowPtr + 2 ];\n\t\t\t\t\talpha[ 1 ] = f * data[ rowPtr + 2 ];\n\t\t\t\t\talpha[ 2 ] = c * data[ rowPtr + 6 ];\n\t\t\t\t\talpha[ 3 ] = f * data[ rowPtr + 6 ];\n\n\t\t\t\t\tbeta[ 0 ] = b * data[ rowPtr + 1 ] + d * data[ rowPtr + 3 ] + e * data[ rowPtr + 5 ] + g * data[ rowPtr + 7 ];\n\t\t\t\t\tbeta[ 1 ] = d * data[ rowPtr + 1 ] - g * data[ rowPtr + 3 ] - b * data[ rowPtr + 5 ] - e * data[ rowPtr + 7 ];\n\t\t\t\t\tbeta[ 2 ] = e * data[ rowPtr + 1 ] - b * data[ rowPtr + 3 ] + g * data[ rowPtr + 5 ] + d * data[ rowPtr + 7 ];\n\t\t\t\t\tbeta[ 3 ] = g * data[ rowPtr + 1 ] - e * data[ rowPtr + 3 ] + d * data[ rowPtr + 5 ] - b * data[ rowPtr + 7 ];\n\n\t\t\t\t\ttheta[ 0 ] = a * ( data[ rowPtr + 0 ] + data[ rowPtr + 4 ] );\n\t\t\t\t\ttheta[ 3 ] = a * ( data[ rowPtr + 0 ] - data[ rowPtr + 4 ] );\n\t\t\t\t\ttheta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];\n\t\t\t\t\ttheta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];\n\n\t\t\t\t\tgamma[ 0 ] = theta[ 0 ] + theta[ 1 ];\n\t\t\t\t\tgamma[ 1 ] = theta[ 3 ] + theta[ 2 ];\n\t\t\t\t\tgamma[ 2 ] = theta[ 3 ] - theta[ 2 ];\n\t\t\t\t\tgamma[ 3 ] = theta[ 0 ] - theta[ 1 ];\n\n\t\t\t\t\tdata[ rowPtr + 0 ] = gamma[ 0 ] + beta[ 0 ];\n\t\t\t\t\tdata[ rowPtr + 1 ] = gamma[ 1 ] + beta[ 1 ];\n\t\t\t\t\tdata[ rowPtr + 2 ] = gamma[ 2 ] + beta[ 2 ];\n\t\t\t\t\tdata[ rowPtr + 3 ] = gamma[ 3 ] + beta[ 3 ];\n\n\t\t\t\t\tdata[ rowPtr + 4 ] = gamma[ 3 ] - beta[ 3 ];\n\t\t\t\t\tdata[ rowPtr + 5 ] = gamma[ 2 ] - beta[ 2 ];\n\t\t\t\t\tdata[ rowPtr + 6 ] = gamma[ 1 ] - beta[ 1 ];\n\t\t\t\t\tdata[ rowPtr + 7 ] = gamma[ 0 ] - beta[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var column = 0; column < 8; ++ column ) {\n\n\t\t\t\t\talpha[ 0 ] = c * data[ 16 + column ];\n\t\t\t\t\talpha[ 1 ] = f * data[ 16 + column ];\n\t\t\t\t\talpha[ 2 ] = c * data[ 48 + column ];\n\t\t\t\t\talpha[ 3 ] = f * data[ 48 + column ];\n\n\t\t\t\t\tbeta[ 0 ] = b * data[ 8 + column ] + d * data[ 24 + column ] + e * data[ 40 + column ] + g * data[ 56 + column ];\n\t\t\t\t\tbeta[ 1 ] = d * data[ 8 + column ] - g * data[ 24 + column ] - b * data[ 40 + column ] - e * data[ 56 + column ];\n\t\t\t\t\tbeta[ 2 ] = e * data[ 8 + column ] - b * data[ 24 + column ] + g * data[ 40 + column ] + d * data[ 56 + column ];\n\t\t\t\t\tbeta[ 3 ] = g * data[ 8 + column ] - e * data[ 24 + column ] + d * data[ 40 + column ] - b * data[ 56 + column ];\n\n\t\t\t\t\ttheta[ 0 ] = a * ( data[ column ] + data[ 32 + column ] );\n\t\t\t\t\ttheta[ 3 ] = a * ( data[ column ] - data[ 32 + column ] );\n\n\t\t\t\t\ttheta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];\n\t\t\t\t\ttheta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];\n\n\t\t\t\t\tgamma[ 0 ] = theta[ 0 ] + theta[ 1 ];\n\t\t\t\t\tgamma[ 1 ] = theta[ 3 ] + theta[ 2 ];\n\t\t\t\t\tgamma[ 2 ] = theta[ 3 ] - theta[ 2 ];\n\t\t\t\t\tgamma[ 3 ] = theta[ 0 ] - theta[ 1 ];\n\n\t\t\t\t\tdata[ 0 + column ] = gamma[ 0 ] + beta[ 0 ];\n\t\t\t\t\tdata[ 8 + column ] = gamma[ 1 ] + beta[ 1 ];\n\t\t\t\t\tdata[ 16 + column ] = gamma[ 2 ] + beta[ 2 ];\n\t\t\t\t\tdata[ 24 + column ] = gamma[ 3 ] + beta[ 3 ];\n\n\t\t\t\t\tdata[ 32 + column ] = gamma[ 3 ] - beta[ 3 ];\n\t\t\t\t\tdata[ 40 + column ] = gamma[ 2 ] - beta[ 2 ];\n\t\t\t\t\tdata[ 48 + column ] = gamma[ 1 ] - beta[ 1 ];\n\t\t\t\t\tdata[ 56 + column ] = gamma[ 0 ] - beta[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction csc709Inverse( data ) {\n\n\t\t\t\tfor ( var i = 0; i < 64; ++ i ) {\n\n\t\t\t\t\tvar y = data[ 0 ][ i ];\n\t\t\t\t\tvar cb = data[ 1 ][ i ];\n\t\t\t\t\tvar cr = data[ 2 ][ i ];\n\n\t\t\t\t\tdata[ 0 ][ i ] = y + 1.5747 * cr;\n\t\t\t\t\tdata[ 1 ][ i ] = y - 0.1873 * cb - 0.4682 * cr;\n\t\t\t\t\tdata[ 2 ][ i ] = y + 1.8556 * cb;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction convertToHalf( src, dst, idx ) {\n\n\t\t\t\tfor ( var i = 0; i < 64; ++ i ) {\n\n\t\t\t\t\tdst[ idx + i ] = encodeFloat16( toLinear( src[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction toLinear( float ) {\n\n\t\t\t\tif ( float <= 1 ) {\n\n\t\t\t\t\treturn Math.sign( float ) * Math.pow( Math.abs( float ), 2.2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn Math.sign( float ) * Math.pow( logBase, Math.abs( float ) - 1.0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction uncompressRAW( info ) {\n\n\t\t\t\treturn new DataView( info.array.buffer, info.offset.value, info.size );\n\n\t\t\t}\n\n\t\t\tfunction uncompressRLE( info ) {\n\n\t\t\t\tvar compressed = info.viewer.buffer.slice( info.offset.value, info.offset.value + info.size );\n\n\t\t\t\tvar rawBuffer = new Uint8Array( decodeRunLength( compressed ) );\n\t\t\t\tvar tmpBuffer = new Uint8Array( rawBuffer.length );\n\n\t\t\t\tpredictor( rawBuffer ); // revert predictor\n\n\t\t\t\tinterleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels\n\n\t\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t\t}\n\n\t\t\tfunction uncompressZIP( info ) {\n\n\t\t\t\tvar compressed = info.array.slice( info.offset.value, info.offset.value + info.size );\n\n\t\t\t\tif ( typeof Zlib === 'undefined' ) {\n\n\t\t\t\t\tconsole.error( 'THREE.EXRLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js' );\n\n\t\t\t\t}\n\n\t\t\t\tvar inflate = new Zlib.Inflate( compressed, { resize: true, verify: true } ); // eslint-disable-line no-undef\n\n\t\t\t\tvar rawBuffer = new Uint8Array( inflate.decompress().buffer );\n\t\t\t\tvar tmpBuffer = new Uint8Array( rawBuffer.length );\n\n\t\t\t\tpredictor( rawBuffer ); // revert predictor\n\n\t\t\t\tinterleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels\n\n\t\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t\t}\n\n\t\t\tfunction uncompressPIZ( info ) {\n\n\t\t\t\tvar inDataView = info.viewer;\n\t\t\t\tvar inOffset = { value: info.offset.value };\n\n\t\t\t\tvar tmpBufSize = info.width * scanlineBlockSize * ( EXRHeader.channels.length * info.type );\n\t\t\t\tvar outBuffer = new Uint16Array( tmpBufSize );\n\t\t\t\tvar bitmap = new Uint8Array( BITMAP_SIZE );\n\n\t\t\t\t// Setup channel info\n\t\t\t\tvar outBufferEnd = 0;\n\t\t\t\tvar pizChannelData = new Array( info.channels );\n\t\t\t\tfor ( var i = 0; i < info.channels; i ++ ) {\n\n\t\t\t\t\tpizChannelData[ i ] = {};\n\t\t\t\t\tpizChannelData[ i ][ 'start' ] = outBufferEnd;\n\t\t\t\t\tpizChannelData[ i ][ 'end' ] = pizChannelData[ i ][ 'start' ];\n\t\t\t\t\tpizChannelData[ i ][ 'nx' ] = info.width;\n\t\t\t\t\tpizChannelData[ i ][ 'ny' ] = info.lines;\n\t\t\t\t\tpizChannelData[ i ][ 'size' ] = info.type;\n\n\t\t\t\t\toutBufferEnd += pizChannelData[ i ].nx * pizChannelData[ i ].ny * pizChannelData[ i ].size;\n\n\t\t\t\t}\n\n\t\t\t\t// Read range compression data\n\t\t\t\tvar minNonZero = parseUint16( inDataView, inOffset );\n\t\t\t\tvar maxNonZero = parseUint16( inDataView, inOffset );\n\n\t\t\t\tif ( maxNonZero >= BITMAP_SIZE ) {\n\n\t\t\t\t\tthrow 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n\n\t\t\t\t}\n\n\t\t\t\tif ( minNonZero <= maxNonZero ) {\n\n\t\t\t\t\tfor ( var i = 0; i < maxNonZero - minNonZero + 1; i ++ ) {\n\n\t\t\t\t\t\tbitmap[ i + minNonZero ] = parseUint8( inDataView, inOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Reverse LUT\n\t\t\t\tvar lut = new Uint16Array( USHORT_RANGE );\n\t\t\t\treverseLutFromBitmap( bitmap, lut );\n\n\t\t\t\tvar length = parseUint32( inDataView, inOffset );\n\n\t\t\t\t// Huffman decoding\n\t\t\t\thufUncompress( info.array, inDataView, inOffset, length, outBuffer, outBufferEnd );\n\n\t\t\t\t// Wavelet decoding\n\t\t\t\tfor ( var i = 0; i < info.channels; ++ i ) {\n\n\t\t\t\t\tvar cd = pizChannelData[ i ];\n\n\t\t\t\t\tfor ( var j = 0; j < pizChannelData[ i ].size; ++ j ) {\n\n\t\t\t\t\t\twav2Decode(\n\t\t\t\t\t\t\toutBuffer,\n\t\t\t\t\t\t\tcd.start + j,\n\t\t\t\t\t\t\tcd.nx,\n\t\t\t\t\t\t\tcd.size,\n\t\t\t\t\t\t\tcd.ny,\n\t\t\t\t\t\t\tcd.nx * cd.size\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Expand the pixel data to their original range\n\t\t\t\tapplyLut( lut, outBuffer, outBufferEnd );\n\n\t\t\t\t// Rearrange the pixel data into the format expected by the caller.\n\t\t\t\tvar tmpOffset = 0;\n\t\t\t\tvar tmpBuffer = new Uint8Array( outBuffer.buffer.byteLength );\n\t\t\t\tfor ( var y = 0; y < info.lines; y ++ ) {\n\n\t\t\t\t\tfor ( var c = 0; c < info.channels; c ++ ) {\n\n\t\t\t\t\t\tvar cd = pizChannelData[ c ];\n\n\t\t\t\t\t\tvar n = cd.nx * cd.size;\n\t\t\t\t\t\tvar cp = new Uint8Array( outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE );\n\n\t\t\t\t\t\ttmpBuffer.set( cp, tmpOffset );\n\t\t\t\t\t\ttmpOffset += n * INT16_SIZE;\n\t\t\t\t\t\tcd.end += n;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t\t}\n\n\t\t\tfunction uncompressDWA( info ) {\n\n\t\t\t\tvar inDataView = info.viewer;\n\t\t\t\tvar inOffset = { value: info.offset.value };\n\t\t\t\tvar outBuffer = new Uint8Array( info.width * info.lines * ( EXRHeader.channels.length * info.type * INT16_SIZE ) );\n\n\t\t\t\t// Read compression header information\n\t\t\t\tvar dwaHeader = {\n\n\t\t\t\t\tversion: parseInt64( inDataView, inOffset ),\n\t\t\t\t\tunknownUncompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\t\tunknownCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\t\tacCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\t\tdcCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\t\trleCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\t\trleUncompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\t\trleRawSize: parseInt64( inDataView, inOffset ),\n\t\t\t\t\ttotalAcUncompressedCount: parseInt64( inDataView, inOffset ),\n\t\t\t\t\ttotalDcUncompressedCount: parseInt64( inDataView, inOffset ),\n\t\t\t\t\tacCompression: parseInt64( inDataView, inOffset )\n\n\t\t\t\t};\n\n\t\t\t\tif ( dwaHeader.version < 2 )\n\t\t\t\t\tthrow 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported';\n\n\t\t\t\t// Read channel ruleset information\n\t\t\t\tvar channelRules = new Array();\n\t\t\t\tvar ruleSize = parseUint16( inDataView, inOffset ) - INT16_SIZE;\n\n\t\t\t\twhile ( ruleSize > 0 ) {\n\n\t\t\t\t\tvar name = parseNullTerminatedString( inDataView.buffer, inOffset );\n\t\t\t\t\tvar value = parseUint8( inDataView, inOffset );\n\t\t\t\t\tvar compression = ( value >> 2 ) & 3;\n\t\t\t\t\tvar csc = ( value >> 4 ) - 1;\n\t\t\t\t\tvar index = new Int8Array( [ csc ] )[ 0 ];\n\t\t\t\t\tvar type = parseUint8( inDataView, inOffset );\n\n\t\t\t\t\tchannelRules.push( {\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\tcompression: compression,\n\t\t\t\t\t} );\n\n\t\t\t\t\truleSize -= name.length + 3;\n\n\t\t\t\t}\n\n\t\t\t\t// Classify channels\n\t\t\t\tvar channels = EXRHeader.channels;\n\t\t\t\tvar channelData = new Array( info.channels );\n\n\t\t\t\tfor ( var i = 0; i < info.channels; ++ i ) {\n\n\t\t\t\t\tvar cd = channelData[ i ] = {};\n\t\t\t\t\tvar channel = channels[ i ];\n\n\t\t\t\t\tcd.name = channel.name;\n\t\t\t\t\tcd.compression = UNKNOWN;\n\t\t\t\t\tcd.decoded = false;\n\t\t\t\t\tcd.type = channel.pixelType;\n\t\t\t\t\tcd.pLinear = channel.pLinear;\n\t\t\t\t\tcd.width = info.width;\n\t\t\t\t\tcd.height = info.lines;\n\n\t\t\t\t}\n\n\t\t\t\tvar cscSet = {\n\t\t\t\t\tidx: new Array( 3 )\n\t\t\t\t};\n\n\t\t\t\tfor ( var offset = 0; offset < info.channels; ++ offset ) {\n\n\t\t\t\t\tvar cd = channelData[ offset ];\n\n\t\t\t\t\tfor ( var i = 0; i < channelRules.length; ++ i ) {\n\n\t\t\t\t\t\tvar rule = channelRules[ i ];\n\n\t\t\t\t\t\tif ( cd.name == rule.name ) {\n\n\t\t\t\t\t\t\tcd.compression = rule.compression;\n\n\t\t\t\t\t\t\tif ( rule.index >= 0 ) {\n\n\t\t\t\t\t\t\t\tcscSet.idx[ rule.index ] = offset;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcd.offset = offset;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Read DCT - AC component data\n\t\t\t\tif ( dwaHeader.acCompressedSize > 0 ) {\n\n\t\t\t\t\tswitch ( dwaHeader.acCompression ) {\n\n\t\t\t\t\t\tcase STATIC_HUFFMAN:\n\n\t\t\t\t\t\t\tvar acBuffer = new Uint16Array( dwaHeader.totalAcUncompressedCount );\n\t\t\t\t\t\t\thufUncompress( info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DEFLATE:\n\n\t\t\t\t\t\t\tvar compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount );\n\t\t\t\t\t\t\tvar inflate = new Zlib.Inflate( compressed, { resize: true, verify: true } );\n\t\t\t\t\t\t\tvar acBuffer = new Uint16Array( inflate.decompress().buffer );\n\t\t\t\t\t\t\tinOffset.value += dwaHeader.totalAcUncompressedCount;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\t// Read DCT - DC component data\n\t\t\t\tif ( dwaHeader.dcCompressedSize > 0 ) {\n\n\t\t\t\t\tvar zlibInfo = {\n\t\t\t\t\t\tarray: info.array,\n\t\t\t\t\t\toffset: inOffset,\n\t\t\t\t\t\tsize: dwaHeader.dcCompressedSize\n\t\t\t\t\t};\n\t\t\t\t\tvar dcBuffer = new Uint16Array( uncompressZIP( zlibInfo ).buffer );\n\t\t\t\t\tinOffset.value += dwaHeader.dcCompressedSize;\n\n\t\t\t\t}\n\n\t\t\t\t// Read RLE compressed data\n\t\t\t\tif ( dwaHeader.rleRawSize > 0 ) {\n\n\t\t\t\t\tvar compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.rleCompressedSize );\n\t\t\t\t\tvar inflate = new Zlib.Inflate( compressed, { resize: true, verify: true } );\n\t\t\t\t\tvar rleBuffer = decodeRunLength( inflate.decompress().buffer );\n\n\t\t\t\t\tinOffset.value += dwaHeader.rleCompressedSize;\n\n\t\t\t\t}\n\n\t\t\t\t// Prepare outbuffer data offset\n\t\t\t\tvar outBufferEnd = 0;\n\t\t\t\tvar rowOffsets = new Array( channelData.length );\n\t\t\t\tfor ( var i = 0; i < rowOffsets.length; ++ i ) {\n\n\t\t\t\t\trowOffsets[ i ] = new Array();\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var y = 0; y < info.lines; ++ y ) {\n\n\t\t\t\t\tfor ( var chan = 0; chan < channelData.length; ++ chan ) {\n\n\t\t\t\t\t\trowOffsets[ chan ].push( outBufferEnd );\n\t\t\t\t\t\toutBufferEnd += channelData[ chan ].width * info.type * INT16_SIZE;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Lossy DCT decode RGB channels\n\t\t\t\tlossyDctDecode( cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer );\n\n\t\t\t\t// Decode other channels\n\t\t\t\tfor ( var i = 0; i < channelData.length; ++ i ) {\n\n\t\t\t\t\tvar cd = channelData[ i ];\n\n\t\t\t\t\tif ( cd.decoded ) continue;\n\n\t\t\t\t\tswitch ( cd.compression ) {\n\n\t\t\t\t\t\tcase RLE:\n\n\t\t\t\t\t\t\tvar row = 0;\n\t\t\t\t\t\t\tvar rleOffset = 0;\n\n\t\t\t\t\t\t\tfor ( var y = 0; y < info.lines; ++ y ) {\n\n\t\t\t\t\t\t\t\tvar rowOffsetBytes = rowOffsets[ i ][ row ];\n\n\t\t\t\t\t\t\t\tfor ( var x = 0; x < cd.width; ++ x ) {\n\n\t\t\t\t\t\t\t\t\tfor ( var byte = 0; byte < INT16_SIZE * cd.type; ++ byte ) {\n\n\t\t\t\t\t\t\t\t\t\toutBuffer[ rowOffsetBytes ++ ] = rleBuffer[ rleOffset + byte * cd.width * cd.height ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\trleOffset ++;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\trow ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase LOSSY_DCT: // skip\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow 'EXRLoader.parse: unsupported channel compression';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new DataView( outBuffer.buffer );\n\n\t\t\t}\n\n\t\t\tfunction parseNullTerminatedString( buffer, offset ) {\n\n\t\t\t\tvar uintBuffer = new Uint8Array( buffer );\n\t\t\t\tvar endOffset = 0;\n\n\t\t\t\twhile ( uintBuffer[ offset.value + endOffset ] != 0 ) {\n\n\t\t\t\t\tendOffset += 1;\n\n\t\t\t\t}\n\n\t\t\t\tvar stringValue = new TextDecoder().decode(\n\t\t\t\t\tuintBuffer.slice( offset.value, offset.value + endOffset )\n\t\t\t\t);\n\n\t\t\t\toffset.value = offset.value + endOffset + 1;\n\n\t\t\t\treturn stringValue;\n\n\t\t\t}\n\n\t\t\tfunction parseFixedLengthString( buffer, offset, size ) {\n\n\t\t\t\tvar stringValue = new TextDecoder().decode(\n\t\t\t\t\tnew Uint8Array( buffer ).slice( offset.value, offset.value + size )\n\t\t\t\t);\n\n\t\t\t\toffset.value = offset.value + size;\n\n\t\t\t\treturn stringValue;\n\n\t\t\t}\n\n\t\t\tfunction parseUlong( dataView, offset ) {\n\n\t\t\t\tvar uLong = dataView.getUint32( 0, true );\n\n\t\t\t\toffset.value = offset.value + ULONG_SIZE;\n\n\t\t\t\treturn uLong;\n\n\t\t\t}\n\n\t\t\tfunction parseUint32( dataView, offset ) {\n\n\t\t\t\tvar Uint32 = dataView.getUint32( offset.value, true );\n\n\t\t\t\toffset.value = offset.value + INT32_SIZE;\n\n\t\t\t\treturn Uint32;\n\n\t\t\t}\n\n\t\t\tfunction parseUint8Array( uInt8Array, offset ) {\n\n\t\t\t\tvar Uint8 = uInt8Array[ offset.value ];\n\n\t\t\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\t\t\treturn Uint8;\n\n\t\t\t}\n\n\t\t\tfunction parseUint8( dataView, offset ) {\n\n\t\t\t\tvar Uint8 = dataView.getUint8( offset.value );\n\n\t\t\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\t\t\treturn Uint8;\n\n\t\t\t}\n\n\t\t\tfunction parseInt64( dataView, offset ) {\n\n\t\t\t\tvar int = Number( dataView.getBigInt64( offset.value, true ) );\n\n\t\t\t\toffset.value += ULONG_SIZE;\n\n\t\t\t\treturn int;\n\n\t\t\t}\n\n\t\t\tfunction parseFloat32( dataView, offset ) {\n\n\t\t\t\tvar float = dataView.getFloat32( offset.value, true );\n\n\t\t\t\toffset.value += FLOAT32_SIZE;\n\n\t\t\t\treturn float;\n\n\t\t\t}\n\n\t\t\t// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\t\t\tfunction decodeFloat16( binary ) {\n\n\t\t\t\tvar exponent = ( binary & 0x7C00 ) >> 10,\n\t\t\t\t\tfraction = binary & 0x03FF;\n\n\t\t\t\treturn ( binary >> 15 ? - 1 : 1 ) * (\n\t\t\t\t\texponent ?\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\texponent === 0x1F ?\n\t\t\t\t\t\t\t\tfraction ? NaN : Infinity :\n\t\t\t\t\t\t\t\tMath.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )\n\t\t\t\t\t\t) :\n\t\t\t\t\t\t6.103515625e-5 * ( fraction / 0x400 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tvar encodeFloat16 = ( function () {\n\n\t\t\t\t// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\n\n\t\t\t\tvar floatView = new Float32Array( 1 );\n\t\t\t\tvar int32View = new Int32Array( floatView.buffer );\n\n\t\t\t\t/* This method is faster than the OpenEXR implementation (very often\n\t\t\t\t * used, eg. in Ogre), with the additional benefit of rounding, inspired\n\t\t\t\t * by James Tursa?s half-precision code. */\n\t\t\t\treturn function toHalf( val ) {\n\n\t\t\t\t\tfloatView[ 0 ] = val;\n\t\t\t\t\tvar x = int32View[ 0 ];\n\n\t\t\t\t\tvar bits = ( x >> 16 ) & 0x8000; /* Get the sign */\n\t\t\t\t\tvar m = ( x >> 12 ) & 0x07ff; /* Keep one extra bit for rounding */\n\t\t\t\t\tvar e = ( x >> 23 ) & 0xff; /* Using int is faster here */\n\n\t\t\t\t\t/* If zero, or denormal, or exponent underflows too much for a denormal\n\t\t\t\t\t * half, return signed zero. */\n\t\t\t\t\tif ( e < 103 ) return bits;\n\n\t\t\t\t\t/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\t\t\t\t\tif ( e > 142 ) {\n\n\t\t\t\t\t\tbits |= 0x7c00;\n\t\t\t\t\t\t/* If exponent was 0xff and one mantissa bit was set, it means NaN,\n\t\t\t\t\t\t\t\t * not Inf, so make sure we set one mantissa bit too. */\n\t\t\t\t\t\tbits |= ( ( e == 255 ) ? 0 : 1 ) && ( x & 0x007fffff );\n\t\t\t\t\t\treturn bits;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t/* If exponent underflows but not too much, return a denormal */\n\t\t\t\t\tif ( e < 113 ) {\n\n\t\t\t\t\t\tm |= 0x0800;\n\t\t\t\t\t\t/* Extra rounding may overflow and set mantissa to 0 and exponent\n\t\t\t\t\t\t * to 1, which is OK. */\n\t\t\t\t\t\tbits |= ( m >> ( 114 - e ) ) + ( ( m >> ( 113 - e ) ) & 1 );\n\t\t\t\t\t\treturn bits;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbits |= ( ( e - 112 ) << 10 ) | ( m >> 1 );\n\t\t\t\t\t/* Extra rounding. An overflow will set mantissa to 0 and increment\n\t\t\t\t\t * the exponent, which is OK. */\n\t\t\t\t\tbits += m & 1;\n\t\t\t\t\treturn bits;\n\n\t\t\t\t};\n\n\t\t\t} )();\n\n\t\t\tfunction parseUint16( dataView, offset ) {\n\n\t\t\t\tvar Uint16 = dataView.getUint16( offset.value, true );\n\n\t\t\t\toffset.value += INT16_SIZE;\n\n\t\t\t\treturn Uint16;\n\n\t\t\t}\n\n\t\t\tfunction parseFloat16( buffer, offset ) {\n\n\t\t\t\treturn decodeFloat16( parseUint16( buffer, offset ) );\n\n\t\t\t}\n\n\t\t\tfunction parseChlist( dataView, buffer, offset, size ) {\n\n\t\t\t\tvar startOffset = offset.value;\n\t\t\t\tvar channels = [];\n\n\t\t\t\twhile ( offset.value < ( startOffset + size - 1 ) ) {\n\n\t\t\t\t\tvar name = parseNullTerminatedString( buffer, offset );\n\t\t\t\t\tvar pixelType = parseUint32( dataView, offset ); // TODO: Cast this to UINT, HALF or FLOAT\n\t\t\t\t\tvar pLinear = parseUint8( dataView, offset );\n\t\t\t\t\toffset.value += 3; // reserved, three chars\n\t\t\t\t\tvar xSampling = parseUint32( dataView, offset );\n\t\t\t\t\tvar ySampling = parseUint32( dataView, offset );\n\n\t\t\t\t\tchannels.push( {\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tpixelType: pixelType,\n\t\t\t\t\t\tpLinear: pLinear,\n\t\t\t\t\t\txSampling: xSampling,\n\t\t\t\t\t\tySampling: ySampling\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\toffset.value += 1;\n\n\t\t\t\treturn channels;\n\n\t\t\t}\n\n\t\t\tfunction parseChromaticities( dataView, offset ) {\n\n\t\t\t\tvar redX = parseFloat32( dataView, offset );\n\t\t\t\tvar redY = parseFloat32( dataView, offset );\n\t\t\t\tvar greenX = parseFloat32( dataView, offset );\n\t\t\t\tvar greenY = parseFloat32( dataView, offset );\n\t\t\t\tvar blueX = parseFloat32( dataView, offset );\n\t\t\t\tvar blueY = parseFloat32( dataView, offset );\n\t\t\t\tvar whiteX = parseFloat32( dataView, offset );\n\t\t\t\tvar whiteY = parseFloat32( dataView, offset );\n\n\t\t\t\treturn { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };\n\n\t\t\t}\n\n\t\t\tfunction parseCompression( dataView, offset ) {\n\n\t\t\t\tvar compressionCodes = [\n\t\t\t\t\t'NO_COMPRESSION',\n\t\t\t\t\t'RLE_COMPRESSION',\n\t\t\t\t\t'ZIPS_COMPRESSION',\n\t\t\t\t\t'ZIP_COMPRESSION',\n\t\t\t\t\t'PIZ_COMPRESSION',\n\t\t\t\t\t'PXR24_COMPRESSION',\n\t\t\t\t\t'B44_COMPRESSION',\n\t\t\t\t\t'B44A_COMPRESSION',\n\t\t\t\t\t'DWAA_COMPRESSION',\n\t\t\t\t\t'DWAB_COMPRESSION'\n\t\t\t\t];\n\n\t\t\t\tvar compression = parseUint8( dataView, offset );\n\n\t\t\t\treturn compressionCodes[ compression ];\n\n\t\t\t}\n\n\t\t\tfunction parseBox2i( dataView, offset ) {\n\n\t\t\t\tvar xMin = parseUint32( dataView, offset );\n\t\t\t\tvar yMin = parseUint32( dataView, offset );\n\t\t\t\tvar xMax = parseUint32( dataView, offset );\n\t\t\t\tvar yMax = parseUint32( dataView, offset );\n\n\t\t\t\treturn { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };\n\n\t\t\t}\n\n\t\t\tfunction parseLineOrder( dataView, offset ) {\n\n\t\t\t\tvar lineOrders = [\n\t\t\t\t\t'INCREASING_Y'\n\t\t\t\t];\n\n\t\t\t\tvar lineOrder = parseUint8( dataView, offset );\n\n\t\t\t\treturn lineOrders[ lineOrder ];\n\n\t\t\t}\n\n\t\t\tfunction parseV2f( dataView, offset ) {\n\n\t\t\t\tvar x = parseFloat32( dataView, offset );\n\t\t\t\tvar y = parseFloat32( dataView, offset );\n\n\t\t\t\treturn [ x, y ];\n\n\t\t\t}\n\n\t\t\tfunction parseValue( dataView, buffer, offset, type, size ) {\n\n\t\t\t\tif ( type === 'string' || type === 'stringvector' || type === 'iccProfile' ) {\n\n\t\t\t\t\treturn parseFixedLengthString( buffer, offset, size );\n\n\t\t\t\t} else if ( type === 'chlist' ) {\n\n\t\t\t\t\treturn parseChlist( dataView, buffer, offset, size );\n\n\t\t\t\t} else if ( type === 'chromaticities' ) {\n\n\t\t\t\t\treturn parseChromaticities( dataView, offset );\n\n\t\t\t\t} else if ( type === 'compression' ) {\n\n\t\t\t\t\treturn parseCompression( dataView, offset );\n\n\t\t\t\t} else if ( type === 'box2i' ) {\n\n\t\t\t\t\treturn parseBox2i( dataView, offset );\n\n\t\t\t\t} else if ( type === 'lineOrder' ) {\n\n\t\t\t\t\treturn parseLineOrder( dataView, offset );\n\n\t\t\t\t} else if ( type === 'float' ) {\n\n\t\t\t\t\treturn parseFloat32( dataView, offset );\n\n\t\t\t\t} else if ( type === 'v2f' ) {\n\n\t\t\t\t\treturn parseV2f( dataView, offset );\n\n\t\t\t\t} else if ( type === 'int' ) {\n\n\t\t\t\t\treturn parseUint32( dataView, offset );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow 'Cannot parse value for unsupported type: ' + type;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar bufferDataView = new DataView( buffer );\n\t\t\tvar uInt8Array = new Uint8Array( buffer );\n\n\t\t\tvar EXRHeader = {};\n\n\t\t\tbufferDataView.getUint32( 0, true ); // magic\n\t\t\tbufferDataView.getUint8( 4, true ); // versionByteZero\n\t\t\tbufferDataView.getUint8( 5, true ); // fullMask\n\n\t\t\t// start of header\n\n\t\t\tvar offset = { value: 8 }; // start at 8, after magic stuff\n\n\t\t\tvar keepReading = true;\n\n\t\t\twhile ( keepReading ) {\n\n\t\t\t\tvar attributeName = parseNullTerminatedString( buffer, offset );\n\n\t\t\t\tif ( attributeName == 0 ) {\n\n\t\t\t\t\tkeepReading = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar attributeType = parseNullTerminatedString( buffer, offset );\n\t\t\t\t\tvar attributeSize = parseUint32( bufferDataView, offset );\n\t\t\t\t\tvar attributeValue = parseValue( bufferDataView, buffer, offset, attributeType, attributeSize );\n\n\t\t\t\t\tEXRHeader[ attributeName ] = attributeValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// offsets\n\t\t\tvar dataWindowHeight = EXRHeader.dataWindow.yMax + 1;\n\n\t\t\tvar uncompress;\n\t\t\tvar scanlineBlockSize;\n\n\t\t\tswitch ( EXRHeader.compression ) {\n\n\t\t\t\tcase 'NO_COMPRESSION':\n\n\t\t\t\t\tscanlineBlockSize = 1;\n\t\t\t\t\tuncompress = uncompressRAW;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RLE_COMPRESSION':\n\n\t\t\t\t\tscanlineBlockSize = 1;\n\t\t\t\t\tuncompress = uncompressRLE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZIPS_COMPRESSION':\n\n\t\t\t\t\tscanlineBlockSize = 1;\n\t\t\t\t\tuncompress = uncompressZIP;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZIP_COMPRESSION':\n\n\t\t\t\t\tscanlineBlockSize = 16;\n\t\t\t\t\tuncompress = uncompressZIP;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PIZ_COMPRESSION':\n\n\t\t\t\t\tscanlineBlockSize = 32;\n\t\t\t\t\tuncompress = uncompressPIZ;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DWAA_COMPRESSION':\n\n\t\t\t\t\tscanlineBlockSize = 32;\n\t\t\t\t\tuncompress = uncompressDWA;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DWAB_COMPRESSION':\n\n\t\t\t\t\tscanlineBlockSize = 256;\n\t\t\t\t\tuncompress = uncompressDWA;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tthrow 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported';\n\n\t\t\t}\n\n\t\t\tvar size_t;\n\t\t\tvar getValue;\n\n\t\t\t// mixed pixelType not supported\n\t\t\tvar pixelType = EXRHeader.channels[ 0 ].pixelType;\n\n\t\t\tif ( pixelType === 1 ) { // half\n\n\t\t\t\tswitch ( this.type ) {\n\n\t\t\t\t\tcase THREE.FloatType:\n\n\t\t\t\t\t\tgetValue = parseFloat16;\n\t\t\t\t\t\tsize_t = INT16_SIZE;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.HalfFloatType:\n\n\t\t\t\t\t\tgetValue = parseUint16;\n\t\t\t\t\t\tsize_t = INT16_SIZE;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else if ( pixelType === 2 ) { // float\n\n\t\t\t\tswitch ( this.type ) {\n\n\t\t\t\t\tcase THREE.FloatType:\n\n\t\t\t\t\t\tgetValue = parseFloat32;\n\t\t\t\t\t\tsize_t = FLOAT32_SIZE;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.HalfFloatType:\n\n\t\t\t\t\t\tthrow 'EXRLoader.parse: unsupported HalfFloatType texture for FloatType image file.';\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthrow 'EXRLoader.parse: unsupported pixelType ' + pixelType + ' for ' + EXRHeader.compression + '.';\n\n\t\t\t}\n\n\t\t\tvar numBlocks = dataWindowHeight / scanlineBlockSize;\n\n\t\t\tfor ( var i = 0; i < numBlocks; i ++ ) {\n\n\t\t\t\tparseUlong( bufferDataView, offset ); // scanlineOffset\n\n\t\t\t}\n\n\t\t\t// we should be passed the scanline offset table, start reading pixel data\n\n\t\t\tvar width = EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1;\n\t\t\tvar height = EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1;\n\t\t\t// Firefox only supports RGBA (half) float textures\n\t\t\t// var numChannels = EXRHeader.channels.length;\n\t\t\tvar numChannels = 4;\n\t\t\tvar size = width * height * numChannels;\n\n\t\t\t// Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\t\t\tswitch ( this.type ) {\n\n\t\t\t\tcase THREE.FloatType:\n\n\t\t\t\t\tvar byteArray = new Float32Array( size );\n\n\t\t\t\t\tif ( EXRHeader.channels.length < numChannels ) {\n\n\t\t\t\t\t\tbyteArray.fill( 1, 0, size );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.HalfFloatType:\n\n\t\t\t\t\tvar byteArray = new Uint16Array( size );\n\n\t\t\t\t\tif ( EXRHeader.channels.length < numChannels ) {\n\n\t\t\t\t\t\tbyteArray.fill( 0x3C00, 0, size ); // Uint16Array holds half float data, 0x3C00 is 1\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.error( 'THREE.EXRLoader: unsupported type: ', this.type );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tvar channelOffsets = {\n\t\t\t\tR: 0,\n\t\t\t\tG: 1,\n\t\t\t\tB: 2,\n\t\t\t\tA: 3\n\t\t\t};\n\n\t\t\tvar compressionInfo = {\n\n\t\t\t\tsize: 0,\n\t\t\t\twidth: width,\n\t\t\t\tlines: scanlineBlockSize,\n\n\t\t\t\toffset: offset,\n\t\t\t\tarray: uInt8Array,\n\t\t\t\tviewer: bufferDataView,\n\n\t\t\t\ttype: pixelType,\n\t\t\t\tchannels: EXRHeader.channels.length,\n\n\t\t\t};\n\n\t\t\tvar line;\n\t\t\tvar size;\n\t\t\tvar viewer;\n\t\t\tvar tmpOffset = { value: 0 };\n\n\t\t\tfor ( var scanlineBlockIdx = 0; scanlineBlockIdx < height / scanlineBlockSize; scanlineBlockIdx ++ ) {\n\n\t\t\t\tline = parseUint32( bufferDataView, offset ); // line_no\n\t\t\t\tsize = parseUint32( bufferDataView, offset ); // data_len\n\n\t\t\t\tcompressionInfo.lines = ( line + scanlineBlockSize > height ) ? height - line : scanlineBlockSize;\n\t\t\t\tcompressionInfo.offset = offset;\n\t\t\t\tcompressionInfo.size = size;\n\n\t\t\t\tviewer = uncompress( compressionInfo );\n\n\t\t\t\toffset.value += size;\n\n\t\t\t\tfor ( var line_y = 0; line_y < scanlineBlockSize; line_y ++ ) {\n\n\t\t\t\t\tvar true_y = line_y + ( scanlineBlockIdx * scanlineBlockSize );\n\n\t\t\t\t\tif ( true_y >= height ) break;\n\n\t\t\t\t\tfor ( var channelID = 0; channelID < EXRHeader.channels.length; channelID ++ ) {\n\n\t\t\t\t\t\tvar cOff = channelOffsets[ EXRHeader.channels[ channelID ].name ];\n\n\t\t\t\t\t\tfor ( var x = 0; x < width; x ++ ) {\n\n\t\t\t\t\t\t\tvar idx = ( line_y * ( EXRHeader.channels.length * width ) ) + ( channelID * width ) + x;\n\t\t\t\t\t\t\ttmpOffset.value = idx * size_t;\n\n\t\t\t\t\t\t\tvar val = getValue( viewer, tmpOffset );\n\n\t\t\t\t\t\t\tbyteArray[ ( ( ( height - 1 - true_y ) * ( width * numChannels ) ) + ( x * numChannels ) ) + cOff ] = val;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\theader: EXRHeader,\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdata: byteArray,\n\t\t\t\tformat: numChannels === 4 ? THREE.RGBAFormat : THREE.RGBFormat,\n\t\t\t\ttype: this.type\n\t\t\t};\n\n\t\t},\n\n\t\tsetDataType: function ( value ) {\n\n\t\t\tthis.type = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\t\tswitch ( texture.type ) {\n\n\t\t\t\t\tcase THREE.FloatType:\n\n\t\t\t\t\t\ttexture.encoding = THREE.LinearEncoding;\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\t\ttexture.flipY = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.HalfFloatType:\n\n\t\t\t\t\t\ttexture.encoding = THREE.LinearEncoding;\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\t\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\t\ttexture.flipY = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t\t}\n\n\t\t\treturn THREE.DataTextureLoader.prototype.load.call( this, url, onLoadCallback, onProgress, onError );\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.EXRLoader;\n});\n"]}