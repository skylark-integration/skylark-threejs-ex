{"version":3,"sources":["loaders/RGBELoader.js"],"names":["define","THREE","threex","RGBELoader","manager","DataTextureLoader","call","this","type","UnsignedByteType","prototype","Object","assign","create","constructor","parse","buffer","rgbe_error","rgbe_error_code","msg","console","error","fgets","lineLimit","consume","p","pos","i","len","s","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","length","slice","RGBEByteToRGBHalf","floatView","Float32Array","int32View","Int32Array","toHalf","val","x","bits","m","e","sourceArray","sourceOffset","destArray","destOffset","scale","Math","pow","byteArray","Uint8Array","rgbe_header_info","line","match","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","width","height","charAt","parseFloat","parseInt","RGBE_ReadHeader","w","h","image_rgba_data","data_rgba","offset","count","byteValue","scanline_buffer","ptr","ptr_end","l","off","isEncodedRun","rgbeStart","scanline_width","num_scanlines","set","RGBE_ReadPixels_RLE","data","RGBEFormat","FloatType","numElements","floatArray","j","RGBFormat","HalfFloatType","halfArray","setDataType","value","load","url","onLoad","onProgress","onError","texture","texData","encoding","RGBEEncoding","minFilter","NearestFilter","magFilter","generateMipmaps","flipY","LinearEncoding","LinearFilter","loaders"],"mappings":"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","file":"../../loaders/RGBELoader.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var RGBELoader = function (manager) {\r\n        THREE.DataTextureLoader.call(this, manager);\r\n        this.type = THREE.UnsignedByteType;\r\n    };\r\n    RGBELoader.prototype = Object.assign(Object.create(THREE.DataTextureLoader.prototype), {\r\n        constructor: RGBELoader,\r\n        parse: function (buffer) {\r\n            var RGBE_RETURN_FAILURE = -1, rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function (rgbe_error_code, msg) {\r\n                    switch (rgbe_error_code) {\r\n                    case rgbe_read_error:\r\n                        console.error('RGBELoader Read Error: ' + (msg || ''));\r\n                        break;\r\n                    case rgbe_write_error:\r\n                        console.error('RGBELoader Write Error: ' + (msg || ''));\r\n                        break;\r\n                    case rgbe_format_error:\r\n                        console.error('RGBELoader Bad File Format: ' + (msg || ''));\r\n                        break;\r\n                    default:\r\n                    case rgbe_memory_error:\r\n                        console.error('RGBELoader: Error: ' + (msg || ''));\r\n                    }\r\n                    return RGBE_RETURN_FAILURE;\r\n                }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = '\\n', fgets = function (buffer, lineLimit, consume) {\r\n                    lineLimit = !lineLimit ? 1024 : lineLimit;\r\n                    var p = buffer.pos, i = -1, len = 0, s = '', chunkSize = 128, chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\r\n                    while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\r\n                        s += chunk;\r\n                        len += chunk.length;\r\n                        p += chunkSize;\r\n                        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\r\n                    }\r\n                    if (-1 < i) {\r\n                        if (false !== consume)\r\n                            buffer.pos += len + i + 1;\r\n                        return s + chunk.slice(0, i);\r\n                    }\r\n                    return false;\r\n                }, RGBE_ReadHeader = function (buffer) {\r\n                    var line, match, magic_token_re = /^#\\?(\\S+)$/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, header = {\r\n                            valid: 0,\r\n                            string: '',\r\n                            comments: '',\r\n                            programtype: 'RGBE',\r\n                            format: '',\r\n                            gamma: 1,\r\n                            exposure: 1,\r\n                            width: 0,\r\n                            height: 0\r\n                        };\r\n                    if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\r\n                        return rgbe_error(rgbe_read_error, 'no header found');\r\n                    }\r\n                    if (!(match = line.match(magic_token_re))) {\r\n                        return rgbe_error(rgbe_format_error, 'bad initial token');\r\n                    }\r\n                    header.valid |= RGBE_VALID_PROGRAMTYPE;\r\n                    header.programtype = match[1];\r\n                    header.string += line + '\\n';\r\n                    while (true) {\r\n                        line = fgets(buffer);\r\n                        if (false === line)\r\n                            break;\r\n                        header.string += line + '\\n';\r\n                        if ('#' === line.charAt(0)) {\r\n                            header.comments += line + '\\n';\r\n                            continue;\r\n                        }\r\n                        if (match = line.match(gamma_re)) {\r\n                            header.gamma = parseFloat(match[1], 10);\r\n                        }\r\n                        if (match = line.match(exposure_re)) {\r\n                            header.exposure = parseFloat(match[1], 10);\r\n                        }\r\n                        if (match = line.match(format_re)) {\r\n                            header.valid |= RGBE_VALID_FORMAT;\r\n                            header.format = match[1];\r\n                        }\r\n                        if (match = line.match(dimensions_re)) {\r\n                            header.valid |= RGBE_VALID_DIMENSIONS;\r\n                            header.height = parseInt(match[1], 10);\r\n                            header.width = parseInt(match[2], 10);\r\n                        }\r\n                        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS)\r\n                            break;\r\n                    }\r\n                    if (!(header.valid & RGBE_VALID_FORMAT)) {\r\n                        return rgbe_error(rgbe_format_error, 'missing format specifier');\r\n                    }\r\n                    if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\r\n                        return rgbe_error(rgbe_format_error, 'missing image size specifier');\r\n                    }\r\n                    return header;\r\n                }, RGBE_ReadPixels_RLE = function (buffer, w, h) {\r\n                    var data_rgba, offset, pos, count, byteValue, scanline_buffer, ptr, ptr_end, i, l, off, isEncodedRun, scanline_width = w, num_scanlines = h, rgbeStart;\r\n                    if (scanline_width < 8 || scanline_width > 32767 || (2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 128)) {\r\n                        return new Uint8Array(buffer);\r\n                    }\r\n                    if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\r\n                        return rgbe_error(rgbe_format_error, 'wrong scanline width');\r\n                    }\r\n                    data_rgba = new Uint8Array(4 * w * h);\r\n                    if (!data_rgba || !data_rgba.length) {\r\n                        return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\r\n                    }\r\n                    offset = 0;\r\n                    pos = 0;\r\n                    ptr_end = 4 * scanline_width;\r\n                    rgbeStart = new Uint8Array(4);\r\n                    scanline_buffer = new Uint8Array(ptr_end);\r\n                    while (num_scanlines > 0 && pos < buffer.byteLength) {\r\n                        if (pos + 4 > buffer.byteLength) {\r\n                            return rgbe_error(rgbe_read_error);\r\n                        }\r\n                        rgbeStart[0] = buffer[pos++];\r\n                        rgbeStart[1] = buffer[pos++];\r\n                        rgbeStart[2] = buffer[pos++];\r\n                        rgbeStart[3] = buffer[pos++];\r\n                        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\r\n                            return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\r\n                        }\r\n                        ptr = 0;\r\n                        while (ptr < ptr_end && pos < buffer.byteLength) {\r\n                            count = buffer[pos++];\r\n                            isEncodedRun = count > 128;\r\n                            if (isEncodedRun)\r\n                                count -= 128;\r\n                            if (0 === count || ptr + count > ptr_end) {\r\n                                return rgbe_error(rgbe_format_error, 'bad scanline data');\r\n                            }\r\n                            if (isEncodedRun) {\r\n                                byteValue = buffer[pos++];\r\n                                for (i = 0; i < count; i++) {\r\n                                    scanline_buffer[ptr++] = byteValue;\r\n                                }\r\n                            } else {\r\n                                scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\r\n                                ptr += count;\r\n                                pos += count;\r\n                            }\r\n                        }\r\n                        l = scanline_width;\r\n                        for (i = 0; i < l; i++) {\r\n                            off = 0;\r\n                            data_rgba[offset] = scanline_buffer[i + off];\r\n                            off += scanline_width;\r\n                            data_rgba[offset + 1] = scanline_buffer[i + off];\r\n                            off += scanline_width;\r\n                            data_rgba[offset + 2] = scanline_buffer[i + off];\r\n                            off += scanline_width;\r\n                            data_rgba[offset + 3] = scanline_buffer[i + off];\r\n                            offset += 4;\r\n                        }\r\n                        num_scanlines--;\r\n                    }\r\n                    return data_rgba;\r\n                };\r\n            var RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\r\n                var e = sourceArray[sourceOffset + 3];\r\n                var scale = Math.pow(2, e - 128) / 255;\r\n                destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\r\n                destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\r\n                destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\r\n            };\r\n            var RGBEByteToRGBHalf = function () {\r\n                var floatView = new Float32Array(1);\r\n                var int32View = new Int32Array(floatView.buffer);\r\n                function toHalf(val) {\r\n                    floatView[0] = val;\r\n                    var x = int32View[0];\r\n                    var bits = x >> 16 & 32768;\r\n                    var m = x >> 12 & 2047;\r\n                    var e = x >> 23 & 255;\r\n                    if (e < 103)\r\n                        return bits;\r\n                    if (e > 142) {\r\n                        bits |= 31744;\r\n                        bits |= (e == 255 ? 0 : 1) && x & 8388607;\r\n                        return bits;\r\n                    }\r\n                    if (e < 113) {\r\n                        m |= 2048;\r\n                        bits |= (m >> 114 - e) + (m >> 113 - e & 1);\r\n                        return bits;\r\n                    }\r\n                    bits |= e - 112 << 10 | m >> 1;\r\n                    bits += m & 1;\r\n                    return bits;\r\n                }\r\n                return function (sourceArray, sourceOffset, destArray, destOffset) {\r\n                    var e = sourceArray[sourceOffset + 3];\r\n                    var scale = Math.pow(2, e - 128) / 255;\r\n                    destArray[destOffset + 0] = toHalf(sourceArray[sourceOffset + 0] * scale);\r\n                    destArray[destOffset + 1] = toHalf(sourceArray[sourceOffset + 1] * scale);\r\n                    destArray[destOffset + 2] = toHalf(sourceArray[sourceOffset + 2] * scale);\r\n                };\r\n            }();\r\n            var byteArray = new Uint8Array(buffer);\r\n            byteArray.pos = 0;\r\n            var rgbe_header_info = RGBE_ReadHeader(byteArray);\r\n            if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\r\n                var w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\r\n                if (RGBE_RETURN_FAILURE !== image_rgba_data) {\r\n                    switch (this.type) {\r\n                    case THREE.UnsignedByteType:\r\n                        var data = image_rgba_data;\r\n                        var format = THREE.RGBEFormat;\r\n                        var type = THREE.UnsignedByteType;\r\n                        break;\r\n                    case THREE.FloatType:\r\n                        var numElements = image_rgba_data.length / 4 * 3;\r\n                        var floatArray = new Float32Array(numElements);\r\n                        for (var j = 0; j < numElements; j++) {\r\n                            RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);\r\n                        }\r\n                        var data = floatArray;\r\n                        var format = THREE.RGBFormat;\r\n                        var type = THREE.FloatType;\r\n                        break;\r\n                    case THREE.HalfFloatType:\r\n                        var numElements = image_rgba_data.length / 4 * 3;\r\n                        var halfArray = new Uint16Array(numElements);\r\n                        for (var j = 0; j < numElements; j++) {\r\n                            RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 3);\r\n                        }\r\n                        var data = halfArray;\r\n                        var format = THREE.RGBFormat;\r\n                        var type = THREE.HalfFloatType;\r\n                        break;\r\n                    default:\r\n                        console.error('THREE.RGBELoader: unsupported type: ', this.type);\r\n                        break;\r\n                    }\r\n                    return {\r\n                        width: w,\r\n                        height: h,\r\n                        data: data,\r\n                        header: rgbe_header_info.string,\r\n                        gamma: rgbe_header_info.gamma,\r\n                        exposure: rgbe_header_info.exposure,\r\n                        format: format,\r\n                        type: type\r\n                    };\r\n                }\r\n            }\r\n            return null;\r\n        },\r\n        setDataType: function (value) {\r\n            this.type = value;\r\n            return this;\r\n        },\r\n        load: function (url, onLoad, onProgress, onError) {\r\n            function onLoadCallback(texture, texData) {\r\n                switch (texture.type) {\r\n                case THREE.UnsignedByteType:\r\n                    texture.encoding = THREE.RGBEEncoding;\r\n                    texture.minFilter = THREE.NearestFilter;\r\n                    texture.magFilter = THREE.NearestFilter;\r\n                    texture.generateMipmaps = false;\r\n                    texture.flipY = true;\r\n                    break;\r\n                case THREE.FloatType:\r\n                    texture.encoding = THREE.LinearEncoding;\r\n                    texture.minFilter = THREE.LinearFilter;\r\n                    texture.magFilter = THREE.LinearFilter;\r\n                    texture.generateMipmaps = false;\r\n                    texture.flipY = true;\r\n                    break;\r\n                case THREE.HalfFloatType:\r\n                    texture.encoding = THREE.LinearEncoding;\r\n                    texture.minFilter = THREE.LinearFilter;\r\n                    texture.magFilter = THREE.LinearFilter;\r\n                    texture.generateMipmaps = false;\r\n                    texture.flipY = true;\r\n                    break;\r\n                }\r\n                if (onLoad)\r\n                    onLoad(texture, texData);\r\n            }\r\n            return THREE.DataTextureLoader.prototype.load.call(this, url, onLoadCallback, onProgress, onError);\r\n        }\r\n    });\r\n\r\n    return threex.loaders.RGBELoader = RGBELoader;\r\n});"]}