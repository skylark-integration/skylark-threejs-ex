{"version":3,"sources":["loaders/RGBELoader.js"],"names":["define","THREE","threex","RGBELoader","manager","DataTextureLoader","call","this","type","UnsignedByteType","prototype","Object","assign","create","constructor","parse","buffer","rgbe_error","rgbe_error_code","msg","console","error","fgets","lineLimit","consume","p","pos","i","len","s","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","length","slice","RGBEByteToRGBHalf","floatView","Float32Array","int32View","Int32Array","toHalf","val","x","bits","m","e","sourceArray","sourceOffset","destArray","destOffset","scale","Math","pow","byteArray","Uint8Array","rgbe_header_info","line","match","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","width","height","charAt","parseFloat","parseInt","RGBE_ReadHeader","w","h","image_rgba_data","data_rgba","offset","count","byteValue","scanline_buffer","ptr","ptr_end","l","off","isEncodedRun","rgbeStart","scanline_width","num_scanlines","set","RGBE_ReadPixels_RLE","data","RGBEFormat","FloatType","numElements","floatArray","j","RGBFormat","HalfFloatType","halfArray","setDataType","value","load","url","onLoad","onProgress","onError","texture","texData","encoding","RGBEEncoding","minFilter","NearestFilter","magFilter","generateMipmaps","flipY","LinearEncoding","LinearFilter","loaders"],"mappings":"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","file":"../../loaders/RGBELoader.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    var RGBELoader = function (manager) {\n        THREE.DataTextureLoader.call(this, manager);\n        this.type = THREE.UnsignedByteType;\n    };\n    RGBELoader.prototype = Object.assign(Object.create(THREE.DataTextureLoader.prototype), {\n        constructor: RGBELoader,\n        parse: function (buffer) {\n            var RGBE_RETURN_FAILURE = -1, rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function (rgbe_error_code, msg) {\n                    switch (rgbe_error_code) {\n                    case rgbe_read_error:\n                        console.error('RGBELoader Read Error: ' + (msg || ''));\n                        break;\n                    case rgbe_write_error:\n                        console.error('RGBELoader Write Error: ' + (msg || ''));\n                        break;\n                    case rgbe_format_error:\n                        console.error('RGBELoader Bad File Format: ' + (msg || ''));\n                        break;\n                    default:\n                    case rgbe_memory_error:\n                        console.error('RGBELoader: Error: ' + (msg || ''));\n                    }\n                    return RGBE_RETURN_FAILURE;\n                }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = '\\n', fgets = function (buffer, lineLimit, consume) {\n                    lineLimit = !lineLimit ? 1024 : lineLimit;\n                    var p = buffer.pos, i = -1, len = 0, s = '', chunkSize = 128, chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n                    while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n                        s += chunk;\n                        len += chunk.length;\n                        p += chunkSize;\n                        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n                    }\n                    if (-1 < i) {\n                        if (false !== consume)\n                            buffer.pos += len + i + 1;\n                        return s + chunk.slice(0, i);\n                    }\n                    return false;\n                }, RGBE_ReadHeader = function (buffer) {\n                    var line, match, magic_token_re = /^#\\?(\\S+)$/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, header = {\n                            valid: 0,\n                            string: '',\n                            comments: '',\n                            programtype: 'RGBE',\n                            format: '',\n                            gamma: 1,\n                            exposure: 1,\n                            width: 0,\n                            height: 0\n                        };\n                    if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n                        return rgbe_error(rgbe_read_error, 'no header found');\n                    }\n                    if (!(match = line.match(magic_token_re))) {\n                        return rgbe_error(rgbe_format_error, 'bad initial token');\n                    }\n                    header.valid |= RGBE_VALID_PROGRAMTYPE;\n                    header.programtype = match[1];\n                    header.string += line + '\\n';\n                    while (true) {\n                        line = fgets(buffer);\n                        if (false === line)\n                            break;\n                        header.string += line + '\\n';\n                        if ('#' === line.charAt(0)) {\n                            header.comments += line + '\\n';\n                            continue;\n                        }\n                        if (match = line.match(gamma_re)) {\n                            header.gamma = parseFloat(match[1], 10);\n                        }\n                        if (match = line.match(exposure_re)) {\n                            header.exposure = parseFloat(match[1], 10);\n                        }\n                        if (match = line.match(format_re)) {\n                            header.valid |= RGBE_VALID_FORMAT;\n                            header.format = match[1];\n                        }\n                        if (match = line.match(dimensions_re)) {\n                            header.valid |= RGBE_VALID_DIMENSIONS;\n                            header.height = parseInt(match[1], 10);\n                            header.width = parseInt(match[2], 10);\n                        }\n                        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS)\n                            break;\n                    }\n                    if (!(header.valid & RGBE_VALID_FORMAT)) {\n                        return rgbe_error(rgbe_format_error, 'missing format specifier');\n                    }\n                    if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n                        return rgbe_error(rgbe_format_error, 'missing image size specifier');\n                    }\n                    return header;\n                }, RGBE_ReadPixels_RLE = function (buffer, w, h) {\n                    var data_rgba, offset, pos, count, byteValue, scanline_buffer, ptr, ptr_end, i, l, off, isEncodedRun, scanline_width = w, num_scanlines = h, rgbeStart;\n                    if (scanline_width < 8 || scanline_width > 32767 || (2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 128)) {\n                        return new Uint8Array(buffer);\n                    }\n                    if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n                        return rgbe_error(rgbe_format_error, 'wrong scanline width');\n                    }\n                    data_rgba = new Uint8Array(4 * w * h);\n                    if (!data_rgba || !data_rgba.length) {\n                        return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\n                    }\n                    offset = 0;\n                    pos = 0;\n                    ptr_end = 4 * scanline_width;\n                    rgbeStart = new Uint8Array(4);\n                    scanline_buffer = new Uint8Array(ptr_end);\n                    while (num_scanlines > 0 && pos < buffer.byteLength) {\n                        if (pos + 4 > buffer.byteLength) {\n                            return rgbe_error(rgbe_read_error);\n                        }\n                        rgbeStart[0] = buffer[pos++];\n                        rgbeStart[1] = buffer[pos++];\n                        rgbeStart[2] = buffer[pos++];\n                        rgbeStart[3] = buffer[pos++];\n                        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n                            return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\n                        }\n                        ptr = 0;\n                        while (ptr < ptr_end && pos < buffer.byteLength) {\n                            count = buffer[pos++];\n                            isEncodedRun = count > 128;\n                            if (isEncodedRun)\n                                count -= 128;\n                            if (0 === count || ptr + count > ptr_end) {\n                                return rgbe_error(rgbe_format_error, 'bad scanline data');\n                            }\n                            if (isEncodedRun) {\n                                byteValue = buffer[pos++];\n                                for (i = 0; i < count; i++) {\n                                    scanline_buffer[ptr++] = byteValue;\n                                }\n                            } else {\n                                scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n                                ptr += count;\n                                pos += count;\n                            }\n                        }\n                        l = scanline_width;\n                        for (i = 0; i < l; i++) {\n                            off = 0;\n                            data_rgba[offset] = scanline_buffer[i + off];\n                            off += scanline_width;\n                            data_rgba[offset + 1] = scanline_buffer[i + off];\n                            off += scanline_width;\n                            data_rgba[offset + 2] = scanline_buffer[i + off];\n                            off += scanline_width;\n                            data_rgba[offset + 3] = scanline_buffer[i + off];\n                            offset += 4;\n                        }\n                        num_scanlines--;\n                    }\n                    return data_rgba;\n                };\n            var RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\n                var e = sourceArray[sourceOffset + 3];\n                var scale = Math.pow(2, e - 128) / 255;\n                destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n                destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n                destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n            };\n            var RGBEByteToRGBHalf = function () {\n                var floatView = new Float32Array(1);\n                var int32View = new Int32Array(floatView.buffer);\n                function toHalf(val) {\n                    floatView[0] = val;\n                    var x = int32View[0];\n                    var bits = x >> 16 & 32768;\n                    var m = x >> 12 & 2047;\n                    var e = x >> 23 & 255;\n                    if (e < 103)\n                        return bits;\n                    if (e > 142) {\n                        bits |= 31744;\n                        bits |= (e == 255 ? 0 : 1) && x & 8388607;\n                        return bits;\n                    }\n                    if (e < 113) {\n                        m |= 2048;\n                        bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n                        return bits;\n                    }\n                    bits |= e - 112 << 10 | m >> 1;\n                    bits += m & 1;\n                    return bits;\n                }\n                return function (sourceArray, sourceOffset, destArray, destOffset) {\n                    var e = sourceArray[sourceOffset + 3];\n                    var scale = Math.pow(2, e - 128) / 255;\n                    destArray[destOffset + 0] = toHalf(sourceArray[sourceOffset + 0] * scale);\n                    destArray[destOffset + 1] = toHalf(sourceArray[sourceOffset + 1] * scale);\n                    destArray[destOffset + 2] = toHalf(sourceArray[sourceOffset + 2] * scale);\n                };\n            }();\n            var byteArray = new Uint8Array(buffer);\n            byteArray.pos = 0;\n            var rgbe_header_info = RGBE_ReadHeader(byteArray);\n            if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n                var w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n                if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n                    switch (this.type) {\n                    case THREE.UnsignedByteType:\n                        var data = image_rgba_data;\n                        var format = THREE.RGBEFormat;\n                        var type = THREE.UnsignedByteType;\n                        break;\n                    case THREE.FloatType:\n                        var numElements = image_rgba_data.length / 4 * 3;\n                        var floatArray = new Float32Array(numElements);\n                        for (var j = 0; j < numElements; j++) {\n                            RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 3);\n                        }\n                        var data = floatArray;\n                        var format = THREE.RGBFormat;\n                        var type = THREE.FloatType;\n                        break;\n                    case THREE.HalfFloatType:\n                        var numElements = image_rgba_data.length / 4 * 3;\n                        var halfArray = new Uint16Array(numElements);\n                        for (var j = 0; j < numElements; j++) {\n                            RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 3);\n                        }\n                        var data = halfArray;\n                        var format = THREE.RGBFormat;\n                        var type = THREE.HalfFloatType;\n                        break;\n                    default:\n                        console.error('THREE.RGBELoader: unsupported type: ', this.type);\n                        break;\n                    }\n                    return {\n                        width: w,\n                        height: h,\n                        data: data,\n                        header: rgbe_header_info.string,\n                        gamma: rgbe_header_info.gamma,\n                        exposure: rgbe_header_info.exposure,\n                        format: format,\n                        type: type\n                    };\n                }\n            }\n            return null;\n        },\n        setDataType: function (value) {\n            this.type = value;\n            return this;\n        },\n        load: function (url, onLoad, onProgress, onError) {\n            function onLoadCallback(texture, texData) {\n                switch (texture.type) {\n                case THREE.UnsignedByteType:\n                    texture.encoding = THREE.RGBEEncoding;\n                    texture.minFilter = THREE.NearestFilter;\n                    texture.magFilter = THREE.NearestFilter;\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n                case THREE.FloatType:\n                    texture.encoding = THREE.LinearEncoding;\n                    texture.minFilter = THREE.LinearFilter;\n                    texture.magFilter = THREE.LinearFilter;\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n                case THREE.HalfFloatType:\n                    texture.encoding = THREE.LinearEncoding;\n                    texture.minFilter = THREE.LinearFilter;\n                    texture.magFilter = THREE.LinearFilter;\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n                }\n                if (onLoad)\n                    onLoad(texture, texData);\n            }\n            return THREE.DataTextureLoader.prototype.load.call(this, url, onLoadCallback, onProgress, onError);\n        }\n    });\n\n    return threex.loaders.RGBELoader = RGBELoader;\n});"]}