{"version":3,"sources":["loaders/VTKLoader.js"],"names":["define","THREE","Zlib","VTKLoader","manager","Loader","call","this","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setResponseType","text","parse","data","Int32Concat","first","second","firstLength","length","result","Int32Array","set","getStringFile","stringFile","charArray","Uint8Array","i","len","String","fromCharCode","meta","LoaderUtils","decodeText","split","indexOf","Base64toByteArray","b64","j","l","tmp","placeHolders","arr","Arr","Array","lookup","revLookup","code","charCodeAt","Error","L","parseDataArray","ele","compressed","numBytes","json","attributes","header_type","format","byteData","blocks","cSizeStart","headerSize","dataOffsets","currentOffset","type","txt","Float32Array","push","currentBlockSize","content","Inflate","slice","resize","verify","decompress","buffer","filter","el","idx","dom","window","DOMParser","parseFromString","e","ActiveXObject","async","loadXML","parseError","reason","srcText","xmlToJson","xml","obj","nodeType","attribute","item","nodeName","nodeValue","trim","hasChildNodes","childNodes","old","documentElement","points","normals","indices","PolyData","piece","Piece","hasOwnProperty","sections","sectionIndex","numberOfSections","section","DataArray","toString","dataArrayIndex","numberOfDataArrays","numberOfPoints","parseInt","NumberOfPoints","normalsName","Normals","Name","components","NumberOfComponents","numberOfStrips","NumberOfStrips","connectivity","offset","size","Uint32Array","indicesIndex","strip","s","len1","len0","numberOfPolys","NumberOfPolys","connectivityIndex","poly","geometry","BufferGeometry","setIndex","BufferAttribute","setAttribute","parseXML","includes","positions","colors","patWord","pat3Floats","patConnectivity","patPOINTS","patPOLYGONS","patTRIANGLE_STRIPS","patPOINT_DATA","patCELL_DATA","patCOLOR_SCALARS","patNORMALS","inPointsSection","inPolygonsSection","inTriangleStripSection","inPointDataSection","inCellDataSection","inColorSection","inNormalsSection","lines","line","dataset","exec","x","parseFloat","y","z","numVertices","inds","i0","k","i1","i2","r","g","b","nx","ny","nz","Float32BufferAttribute","numTriangles","toNonIndexed","position","count","newColors","parseASCII","pointIndex","state","dataView","DataView","vtk","index","findString","start","c","end","next","parsedString","join","getFloat32","indexCount","getInt32","byteLength","parseBinary"],"mappings":"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","file":"../../loaders/VTKLoader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE,Zlib){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Alex Pletzer\n\t *\n\t * Updated on 22.03.2017\n\t * VTK header is now parsed and used to extract all the compressed data\n\t * @author Andrii Iudin https://github.com/andreyyudin\n\t * @author Paul Kibet Korir https://github.com/polarise\n\t * @author Sriram Somasundharam https://github.com/raamssundar\n\t */\n\n\tTHREE.VTKLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.VTKLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.VTKLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data ) {\n\n\t\t\tfunction parseASCII( data ) {\n\n\t\t\t\t// connectivity of the triangles\n\t\t\t\tvar indices = [];\n\n\t\t\t\t// triangles vertices\n\t\t\t\tvar positions = [];\n\n\t\t\t\t// red, green, blue colors in the range 0 to 1\n\t\t\t\tvar colors = [];\n\n\t\t\t\t// normal vector, one per vertex\n\t\t\t\tvar normals = [];\n\n\t\t\t\tvar result;\n\n\t\t\t\t// pattern for detecting the end of a number sequence\n\t\t\t\tvar patWord = /^[^\\d.\\s-]+/;\n\n\t\t\t\t// pattern for reading vertices, 3 floats or integers\n\t\t\t\tvar pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g;\n\n\t\t\t\t// pattern for connectivity, an integer followed by any number of ints\n\t\t\t\t// the first integer is the number of polygon nodes\n\t\t\t\tvar patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/;\n\n\t\t\t\t// indicates start of vertex data section\n\t\t\t\tvar patPOINTS = /^POINTS /;\n\n\t\t\t\t// indicates start of polygon connectivity section\n\t\t\t\tvar patPOLYGONS = /^POLYGONS /;\n\n\t\t\t\t// indicates start of triangle strips section\n\t\t\t\tvar patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;\n\n\t\t\t\t// POINT_DATA number_of_values\n\t\t\t\tvar patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/;\n\n\t\t\t\t// CELL_DATA number_of_polys\n\t\t\t\tvar patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/;\n\n\t\t\t\t// Start of color section\n\t\t\t\tvar patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/;\n\n\t\t\t\t// NORMALS Normals float\n\t\t\t\tvar patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n\n\t\t\t\tvar inPointsSection = false;\n\t\t\t\tvar inPolygonsSection = false;\n\t\t\t\tvar inTriangleStripSection = false;\n\t\t\t\tvar inPointDataSection = false;\n\t\t\t\tvar inCellDataSection = false;\n\t\t\t\tvar inColorSection = false;\n\t\t\t\tvar inNormalsSection = false;\n\n\t\t\t\tvar lines = data.split( '\\n' );\n\n\t\t\t\tfor ( var i in lines ) {\n\n\t\t\t\t\tvar line = lines[ i ].trim();\n\n\t\t\t\t\tif ( line.indexOf( 'DATASET' ) === 0 ) {\n\n\t\t\t\t\t\tvar dataset = line.split( ' ' )[ 1 ];\n\n\t\t\t\t\t\tif ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );\n\n\t\t\t\t\t} else if ( inPointsSection ) {\n\n\t\t\t\t\t\t// get the vertices\n\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\t\tvar x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\tvar y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\tvar z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\tpositions.push( x, y, z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( inPolygonsSection ) {\n\n\t\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\t\tvar numVertices = parseInt( result[ 1 ] );\n\t\t\t\t\t\t\tvar inds = result[ 2 ].split( /\\s+/ );\n\n\t\t\t\t\t\t\tif ( numVertices >= 3 ) {\n\n\t\t\t\t\t\t\t\tvar i0 = parseInt( inds[ 0 ] );\n\t\t\t\t\t\t\t\tvar i1, i2;\n\t\t\t\t\t\t\t\tvar k = 1;\n\t\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\t\tfor ( var j = 0; j < numVertices - 2; ++ j ) {\n\n\t\t\t\t\t\t\t\t\ti1 = parseInt( inds[ k ] );\n\t\t\t\t\t\t\t\t\ti2 = parseInt( inds[ k + 1 ] );\n\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\t\t\t\t\t\t\t\t\tk ++;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( inTriangleStripSection ) {\n\n\t\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\t\tvar numVertices = parseInt( result[ 1 ] );\n\t\t\t\t\t\t\tvar inds = result[ 2 ].split( /\\s+/ );\n\n\t\t\t\t\t\t\tif ( numVertices >= 3 ) {\n\n\t\t\t\t\t\t\t\tvar i0, i1, i2;\n\t\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\t\tfor ( var j = 0; j < numVertices - 2; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tif ( j % 2 === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\ti0 = parseInt( inds[ j ] );\n\t\t\t\t\t\t\t\t\t\ti1 = parseInt( inds[ j + 2 ] );\n\t\t\t\t\t\t\t\t\t\ti2 = parseInt( inds[ j + 1 ] );\n\t\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ti0 = parseInt( inds[ j ] );\n\t\t\t\t\t\t\t\t\t\ti1 = parseInt( inds[ j + 1 ] );\n\t\t\t\t\t\t\t\t\t\ti2 = parseInt( inds[ j + 2 ] );\n\t\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( inPointDataSection || inCellDataSection ) {\n\n\t\t\t\t\t\tif ( inColorSection ) {\n\n\t\t\t\t\t\t\t// Get the colors\n\n\t\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\t\t\tvar r = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\t\tvar g = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\t\tvar b = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\t\tcolors.push( r, g, b );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( inNormalsSection ) {\n\n\t\t\t\t\t\t\t// Get the normal vectors\n\n\t\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\n\n\t\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\n\n\t\t\t\t\t\t\t\tvar nx = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\t\tvar ny = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\t\tvar nz = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\t\tnormals.push( nx, ny, nz );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( patPOLYGONS.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinPolygonsSection = true;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t} else if ( patPOINTS.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinPointsSection = true;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t} else if ( patTRIANGLE_STRIPS.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = true;\n\n\t\t\t\t\t} else if ( patPOINT_DATA.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinPointDataSection = true;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t} else if ( patCELL_DATA.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinCellDataSection = true;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t} else if ( patCOLOR_SCALARS.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinColorSection = true;\n\t\t\t\t\t\tinNormalsSection = false;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t} else if ( patNORMALS.exec( line ) !== null ) {\n\n\t\t\t\t\t\tinNormalsSection = true;\n\t\t\t\t\t\tinColorSection = false;\n\t\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\t\tinTriangleStripSection = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\n\t\t\t\tif ( normals.length === positions.length ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( colors.length !== indices.length ) {\n\n\t\t\t\t\t// stagger\n\n\t\t\t\t\tif ( colors.length === positions.length ) {\n\n\t\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// cell\n\n\t\t\t\t\tgeometry = geometry.toNonIndexed();\n\t\t\t\t\tvar numTriangles = geometry.attributes.position.count / 3;\n\n\t\t\t\t\tif ( colors.length === ( numTriangles * 3 ) ) {\n\n\t\t\t\t\t\tvar newColors = [];\n\n\t\t\t\t\t\tfor ( var i = 0; i < numTriangles; i ++ ) {\n\n\t\t\t\t\t\t\tvar r = colors[ 3 * i + 0 ];\n\t\t\t\t\t\t\tvar g = colors[ 3 * i + 1 ];\n\t\t\t\t\t\t\tvar b = colors[ 3 * i + 2 ];\n\n\t\t\t\t\t\t\tnewColors.push( r, g, b );\n\t\t\t\t\t\t\tnewColors.push( r, g, b );\n\t\t\t\t\t\t\tnewColors.push( r, g, b );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( newColors, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction parseBinary( data ) {\n\n\t\t\t\tvar count, pointIndex, i, numberOfPoints, s;\n\t\t\t\tvar buffer = new Uint8Array( data );\n\t\t\t\tvar dataView = new DataView( data );\n\n\t\t\t\t// Points and normals, by default, are empty\n\t\t\t\tvar points = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar indices = [];\n\n\t\t\t\t// Going to make a big array of strings\n\t\t\t\tvar vtk = [];\n\t\t\t\tvar index = 0;\n\n\t\t\t\tfunction findString( buffer, start ) {\n\n\t\t\t\t\tvar index = start;\n\t\t\t\t\tvar c = buffer[ index ];\n\t\t\t\t\tvar s = [];\n\t\t\t\t\twhile ( c !== 10 ) {\n\n\t\t\t\t\t\ts.push( String.fromCharCode( c ) );\n\t\t\t\t\t\tindex ++;\n\t\t\t\t\t\tc = buffer[ index ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { start: start,\n\t\t\t\t\t\tend: index,\n\t\t\t\t\t\tnext: index + 1,\n\t\t\t\t\t\tparsedString: s.join( '' ) };\n\n\t\t\t\t}\n\n\t\t\t\tvar state, line;\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\t// Get a string\n\t\t\t\t\tstate = findString( buffer, index );\n\t\t\t\t\tline = state.parsedString;\n\n\t\t\t\t\tif ( line.indexOf( 'DATASET' ) === 0 ) {\n\n\t\t\t\t\t\tvar dataset = line.split( ' ' )[ 1 ];\n\n\t\t\t\t\t\tif ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );\n\n\t\t\t\t\t} else if ( line.indexOf( 'POINTS' ) === 0 ) {\n\n\t\t\t\t\t\tvtk.push( line );\n\t\t\t\t\t\t// Add the points\n\t\t\t\t\t\tnumberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\n\n\t\t\t\t\t\t// Each point is 3 4-byte floats\n\t\t\t\t\t\tcount = numberOfPoints * 4 * 3;\n\n\t\t\t\t\t\tpoints = new Float32Array( numberOfPoints * 3 );\n\n\t\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\t\tfor ( i = 0; i < numberOfPoints; i ++ ) {\n\n\t\t\t\t\t\t\tpoints[ 3 * i ] = dataView.getFloat32( pointIndex, false );\n\t\t\t\t\t\t\tpoints[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\n\t\t\t\t\t\t\tpoints[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\n\t\t\t\t\t\t\tpointIndex = pointIndex + 12;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// increment our next pointer\n\t\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t\t} else if ( line.indexOf( 'TRIANGLE_STRIPS' ) === 0 ) {\n\n\t\t\t\t\t\tvar numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\n\t\t\t\t\t\tvar size = parseInt( line.split( ' ' )[ 2 ], 10 );\n\t\t\t\t\t\t// 4 byte integers\n\t\t\t\t\t\tcount = size * 4;\n\n\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\t\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\t\tfor ( i = 0; i < numberOfStrips; i ++ ) {\n\n\t\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\t\tvar indexCount = dataView.getInt32( pointIndex, false );\n\t\t\t\t\t\t\tvar strip = [];\n\t\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\t\tfor ( s = 0; s < indexCount; s ++ ) {\n\n\t\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\n\t\t\t\t\t\t\t\tpointIndex += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// retrieves the n-2 triangles from the triangle strip\n\t\t\t\t\t\t\tfor ( var j = 0; j < indexCount - 2; j ++ ) {\n\n\t\t\t\t\t\t\t\tif ( j % 2 ) {\n\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t\t\t} else {\n\n\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// increment our next pointer\n\t\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t\t} else if ( line.indexOf( 'POLYGONS' ) === 0 ) {\n\n\t\t\t\t\t\tvar numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\n\t\t\t\t\t\tvar size = parseInt( line.split( ' ' )[ 2 ], 10 );\n\t\t\t\t\t\t// 4 byte integers\n\t\t\t\t\t\tcount = size * 4;\n\n\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\t\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\t\tfor ( i = 0; i < numberOfStrips; i ++ ) {\n\n\t\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\t\tvar indexCount = dataView.getInt32( pointIndex, false );\n\t\t\t\t\t\t\tvar strip = [];\n\t\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\t\tfor ( s = 0; s < indexCount; s ++ ) {\n\n\t\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\n\t\t\t\t\t\t\t\tpointIndex += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// divide the polygon in n-2 triangle\n\t\t\t\t\t\t\tfor ( var j = 1; j < indexCount - 1; j ++ ) {\n\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ 0 ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// increment our next pointer\n\t\t\t\t\t\tstate.next = state.next + count + 1;\n\n\t\t\t\t\t} else if ( line.indexOf( 'POINT_DATA' ) === 0 ) {\n\n\t\t\t\t\t\tnumberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\n\n\t\t\t\t\t\t// Grab the next line\n\t\t\t\t\t\tstate = findString( buffer, state.next );\n\n\t\t\t\t\t\t// Now grab the binary data\n\t\t\t\t\t\tcount = numberOfPoints * 4 * 3;\n\n\t\t\t\t\t\tnormals = new Float32Array( numberOfPoints * 3 );\n\t\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\t\tfor ( i = 0; i < numberOfPoints; i ++ ) {\n\n\t\t\t\t\t\t\tnormals[ 3 * i ] = dataView.getFloat32( pointIndex, false );\n\t\t\t\t\t\t\tnormals[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\n\t\t\t\t\t\t\tnormals[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\n\t\t\t\t\t\t\tpointIndex += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Increment past our data\n\t\t\t\t\t\tstate.next = state.next + count;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Increment index\n\t\t\t\t\tindex = state.next;\n\n\t\t\t\t\tif ( index >= buffer.byteLength ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( points, 3 ) );\n\n\t\t\t\tif ( normals.length === points.length ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction Float32Concat( first, second ) {\n\n\t\t\t    var firstLength = first.length, result = new Float32Array( firstLength + second.length );\n\n\t\t\t    result.set( first );\n\t\t\t    result.set( second, firstLength );\n\n\t\t\t    return result;\n\n\t\t\t}\n\n\t\t\tfunction Int32Concat( first, second ) {\n\n\t\t\t    var firstLength = first.length, result = new Int32Array( firstLength + second.length );\n\n\t\t\t    result.set( first );\n\t\t\t    result.set( second, firstLength );\n\n\t\t\t    return result;\n\n\t\t\t}\n\n\t\t\tfunction parseXML( stringFile ) {\n\n\t\t\t\t// Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n\n\t\t\t\tfunction xmlToJson( xml ) {\n\n\t\t\t\t\t// Create the return object\n\t\t\t\t\tvar obj = {};\n\n\t\t\t\t\tif ( xml.nodeType === 1 ) { // element\n\n\t\t\t\t\t\t// do attributes\n\n\t\t\t\t\t\tif ( xml.attributes ) {\n\n\t\t\t\t\t\t\tif ( xml.attributes.length > 0 ) {\n\n\t\t\t\t\t\t\t\tobj[ 'attributes' ] = {};\n\n\t\t\t\t\t\t\t\tfor ( var j = 0; j < xml.attributes.length; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar attribute = xml.attributes.item( j );\n\t\t\t\t\t\t\t\t\tobj[ 'attributes' ][ attribute.nodeName ] = attribute.nodeValue.trim();\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( xml.nodeType === 3 ) { // text\n\n\t\t\t\t\t\tobj = xml.nodeValue.trim();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// do children\n\t\t\t\t\tif ( xml.hasChildNodes() ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\t\t\t\tvar item = xml.childNodes.item( i );\n\t\t\t\t\t\t\tvar nodeName = item.nodeName;\n\n\t\t\t\t\t\t\tif ( typeof obj[ nodeName ] === 'undefined' ) {\n\n\t\t\t\t\t\t\t\tvar tmp = xmlToJson( item );\n\n\t\t\t\t\t\t\t\tif ( tmp !== '' ) obj[ nodeName ] = tmp;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tif ( typeof obj[ nodeName ].push === 'undefined' ) {\n\n\t\t\t\t\t\t\t\t\tvar old = obj[ nodeName ];\n\t\t\t\t\t\t\t\t\tobj[ nodeName ] = [ old ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar tmp = xmlToJson( item );\n\n\t\t\t\t\t\t\t\tif ( tmp !== '' ) obj[ nodeName ].push( tmp );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn obj;\n\n\t\t\t\t}\n\n\t\t\t\t// Taken from Base64-js\n\t\t\t\tfunction Base64toByteArray( b64 ) {\n\n\t\t\t\t\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\t\t\t\t\tvar i;\n\t\t\t\t\tvar lookup = [];\n\t\t\t\t\tvar revLookup = [];\n\t\t\t\t\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\t\t\t\tvar len = code.length;\n\n\t\t\t\t\tfor ( i = 0; i < len; i ++ ) {\n\n\t\t\t\t\t\tlookup[ i ] = code[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( i = 0; i < len; ++ i ) {\n\n\t\t\t\t\t\trevLookup[ code.charCodeAt( i ) ] = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t\trevLookup[ '-'.charCodeAt( 0 ) ] = 62;\n\t\t\t\t\trevLookup[ '_'.charCodeAt( 0 ) ] = 63;\n\n\t\t\t\t\tvar j, l, tmp, placeHolders, arr;\n\t\t\t\t\tvar len = b64.length;\n\n\t\t\t\t\tif ( len % 4 > 0 ) {\n\n\t\t\t\t\t\tthrow new Error( 'Invalid string. Length must be a multiple of 4' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tplaceHolders = b64[ len - 2 ] === '=' ? 2 : b64[ len - 1 ] === '=' ? 1 : 0;\n\t\t\t\t\tarr = new Arr( len * 3 / 4 - placeHolders );\n\t\t\t\t\tl = placeHolders > 0 ? len - 4 : len;\n\n\t\t\t\t\tvar L = 0;\n\n\t\t\t\t\tfor ( i = 0, j = 0; i < l; i += 4, j += 3 ) {\n\n\t\t\t\t\t\ttmp = ( revLookup[ b64.charCodeAt( i ) ] << 18 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 12 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] << 6 ) | revLookup[ b64.charCodeAt( i + 3 ) ];\n\t\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF0000 ) >> 16;\n\t\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF00 ) >> 8;\n\t\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( placeHolders === 2 ) {\n\n\t\t\t\t\t\ttmp = ( revLookup[ b64.charCodeAt( i ) ] << 2 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] >> 4 );\n\t\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t\t} else if ( placeHolders === 1 ) {\n\n\t\t\t\t\t\ttmp = ( revLookup[ b64.charCodeAt( i ) ] << 10 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 4 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] >> 2 );\n\t\t\t\t\t\tarr[ L ++ ] = ( tmp >> 8 ) & 0xFF;\n\t\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn arr;\n\n\t\t\t\t}\n\n\t\t\t\tfunction parseDataArray( ele, compressed ) {\n\n\t\t\t\t\tvar numBytes = 0;\n\n\t\t\t\t\tif ( json.attributes.header_type === 'UInt64' ) {\n\n\t\t\t\t\t\tnumBytes = 8;\n\n\t\t\t\t\t}\telse if ( json.attributes.header_type === 'UInt32' ) {\n\n\t\t\t\t\t\tnumBytes = 4;\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// Check the format\n\t\t\t\t\tif ( ele.attributes.format === 'binary' && compressed ) {\n\n\t\t\t\t\t\tvar rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n\n\t\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\t\tvar txt = new Float32Array( );\n\n\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\t\tvar txt = new Int32Array( );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// VTP data with the header has the following structure:\n\t\t\t\t\t\t// [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n\t\t\t\t\t\t// [#blocks] = Number of blocks\n\t\t\t\t\t\t// [#u-size] = Block size before compression\n\t\t\t\t\t\t// [#p-size] = Size of last partial block (zero if it not needed)\n\t\t\t\t\t\t// [#c-size-i] = Size in bytes of block i after compression\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n\t\t\t\t\t\t// computed by summing the compressed block sizes from preceding blocks according to the header.\n\n\t\t\t\t\t\trawData = ele[ '#text' ];\n\n\t\t\t\t\t\tbyteData = Base64toByteArray( rawData );\n\n\t\t\t\t\t\tblocks = byteData[ 0 ];\n\t\t\t\t\t\tfor ( var i = 1; i < numBytes - 1; i ++ ) {\n\n\t\t\t\t\t\t\tblocks = blocks | ( byteData[ i ] << ( i * numBytes ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\theaderSize = ( blocks + 3 ) * numBytes;\n\t\t\t\t\t\tpadding = ( ( headerSize % 3 ) > 0 ) ? 3 - ( headerSize % 3 ) : 0;\n\t\t\t\t\t\theaderSize = headerSize + padding;\n\n\t\t\t\t\t\tdataOffsets = [];\n\t\t\t\t\t\tcurrentOffset = headerSize;\n\t\t\t\t\t\tdataOffsets.push( currentOffset );\n\n\t\t\t\t\t\t// Get the blocks sizes after the compression.\n\t\t\t\t\t\t// There are three blocks before c-size-i, so we skip 3*numBytes\n\t\t\t\t\t\tcSizeStart = 3 * numBytes;\n\n\t\t\t\t\t\tfor ( var i = 0; i < blocks; i ++ ) {\n\n\t\t\t\t\t\t\tvar currentBlockSize = byteData[ i * numBytes + cSizeStart ];\n\n\t\t\t\t\t\t\tfor ( var j = 1; j < numBytes - 1; j ++ ) {\n\n\t\t\t\t\t\t\t\t// Each data point consists of 8 bytes regardless of the header type\n\t\t\t\t\t\t\t\tcurrentBlockSize = currentBlockSize | ( byteData[ i * numBytes + cSizeStart + j ] << ( j * 8 ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcurrentOffset = currentOffset + currentBlockSize;\n\t\t\t\t\t\t\tdataOffsets.push( currentOffset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( var i = 0; i < dataOffsets.length - 1; i ++ ) {\n\n\t\t\t\t\t\t\tvar inflate = new Zlib.Inflate( byteData.slice( dataOffsets[ i ], dataOffsets[ i + 1 ] ), { resize: true, verify: true } ); // eslint-disable-line no-undef\n\t\t\t\t\t\t\tcontent = inflate.decompress();\n\t\t\t\t\t\t\tcontent = content.buffer;\n\n\t\t\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\t\t\tcontent = new Float32Array( content );\n\t\t\t\t\t\t\t\ttxt = Float32Concat( txt, content );\n\n\t\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\t\t\tcontent = new Int32Array( content );\n\t\t\t\t\t\t\t\ttxt = Int32Concat( txt, content );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete ele[ '#text' ];\n\n\t\t\t\t\t\tif ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\n\n\t\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\n\n\t\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) return true;\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ele.attributes.format === 'binary' && ! compressed ) {\n\n\t\t\t\t\t\t\tvar content = Base64toByteArray( ele[ '#text' ] );\n\n\t\t\t\t\t\t\t//  VTP data for the uncompressed case has the following structure:\n\t\t\t\t\t\t\t// [#bytes][DATA]\n\t\t\t\t\t\t\t// where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\t\t\t\t\t\t\tcontent = content.slice( numBytes ).buffer;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( ele[ '#text' ] ) {\n\n\t\t\t\t\t\t\t\tvar content = ele[ '#text' ].split( /\\s+/ ).filter( function ( el ) {\n\n\t\t\t\t\t\t\t\t\tif ( el !== '' ) return el;\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar content = new Int32Array( 0 ).buffer;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete ele[ '#text' ];\n\n\t\t\t\t\t\t// Get the content and optimize it\n\t\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\n\n\t\t\t\t\t\t\tvar txt = new Float32Array( content );\n\n\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int32' ) {\n\n\t\t\t\t\t\t\tvar txt = new Int32Array( content );\n\n\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\n\n\t\t\t\t\t\t\tvar txt = new Int32Array( content );\n\n\t\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\n\n\t\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\n\n\t\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) return true;\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} // endif ( ele.attributes.format === 'binary' && compressed )\n\n\t\t\t\t\treturn txt;\n\n\t\t\t\t}\n\n\t\t\t\t// Main part\n\t\t\t\t// Get Dom\n\t\t\t\tvar dom = null;\n\n\t\t\t\tif ( window.DOMParser ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tdom = ( new DOMParser() ).parseFromString( stringFile, 'text/xml' );\n\n\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\tdom = null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( window.ActiveXObject ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tdom = new ActiveXObject( 'Microsoft.XMLDOM' ); // eslint-disable-line no-undef\n\t\t\t\t\t\tdom.async = false;\n\n\t\t\t\t\t\tif ( ! dom.loadXML( /* xml */ ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( dom.parseError.reason + dom.parseError.srcText );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\tdom = null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'Cannot parse xml string!' );\n\n\t\t\t\t}\n\n\t\t\t\t// Get the doc\n\t\t\t\tvar doc = dom.documentElement;\n\t\t\t\t// Convert to json\n\t\t\t\tvar json = xmlToJson( doc );\n\t\t\t\tvar points = [];\n\t\t\t\tvar normals = [];\n\t\t\t\tvar indices = [];\n\n\t\t\t\tif ( json.PolyData ) {\n\n\t\t\t\t\tvar piece = json.PolyData.Piece;\n\t\t\t\t\tvar compressed = json.attributes.hasOwnProperty( 'compressor' );\n\n\t\t\t\t\t// Can be optimized\n\t\t\t\t\t// Loop through the sections\n\t\t\t\t\tvar sections = [ 'PointData', 'Points', 'Strips', 'Polys' ];// +['CellData', 'Verts', 'Lines'];\n\t\t\t\t\tvar sectionIndex = 0, numberOfSections = sections.length;\n\n\t\t\t\t\twhile ( sectionIndex < numberOfSections ) {\n\n\t\t\t\t\t\tvar section = piece[ sections[ sectionIndex ] ];\n\n\t\t\t\t\t\t// If it has a DataArray in it\n\n\t\t\t\t\t\tif ( section && section.DataArray ) {\n\n\t\t\t\t\t\t\t// Depending on the number of DataArrays\n\n\t\t\t\t\t\t\tif ( Object.prototype.toString.call( section.DataArray ) === '[object Array]' ) {\n\n\t\t\t\t\t\t\t\tvar arr = section.DataArray;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar arr = [ section.DataArray ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar dataArrayIndex = 0, numberOfDataArrays = arr.length;\n\n\t\t\t\t\t\t\twhile ( dataArrayIndex < numberOfDataArrays ) {\n\n\t\t\t\t\t\t\t\t// Parse the DataArray\n\t\t\t\t\t\t\t\tif ( ( '#text' in arr[ dataArrayIndex ] ) && ( arr[ dataArrayIndex ][ '#text' ].length > 0 ) ) {\n\n\t\t\t\t\t\t\t\t\tarr[ dataArrayIndex ].text = parseDataArray( arr[ dataArrayIndex ], compressed );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tdataArrayIndex ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tswitch ( sections[ sectionIndex ] ) {\n\n\t\t\t\t\t\t\t\t// if iti is point data\n\t\t\t\t\t\t\t\tcase 'PointData':\n\n\t\t\t\t\t\t\t\t\tvar numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\n\t\t\t\t\t\t\t\t\tvar normalsName = section.attributes.Normals;\n\n\t\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tfor ( var i = 0, len = arr.length; i < len; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( normalsName === arr[ i ].attributes.Name ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar components = arr[ i ].attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\t\t\t\tnormals = new Float32Array( numberOfPoints * components );\n\t\t\t\t\t\t\t\t\t\t\t\tnormals.set( arr[ i ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t// if it is points\n\t\t\t\t\t\t\t\tcase 'Points':\n\n\t\t\t\t\t\t\t\t\tvar numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\n\n\t\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tvar components = section.DataArray.attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\t\tpoints = new Float32Array( numberOfPoints * components );\n\t\t\t\t\t\t\t\t\t\tpoints.set( section.DataArray.text, 0 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t// if it is strips\n\t\t\t\t\t\t\t\tcase 'Strips':\n\n\t\t\t\t\t\t\t\t\tvar numberOfStrips = parseInt( piece.attributes.NumberOfStrips );\n\n\t\t\t\t\t\t\t\t\tif ( numberOfStrips > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tvar connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\n\t\t\t\t\t\t\t\t\t\tvar offset = new Int32Array( section.DataArray[ 1 ].text.length );\n\t\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\n\t\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\tvar size = numberOfStrips + connectivity.length;\n\t\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\n\n\t\t\t\t\t\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\t\t\t\t\t\tfor ( var i = 0, len = numberOfStrips; i < len; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar strip = [];\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( var s = 0, len1 = offset[ i ], len0 = 0; s < len1 - len0; s ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tstrip.push( connectivity[ s ] );\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) len0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( var j = 0, len1 = offset[ i ], len0 = 0; j < len1 - len0 - 2; j ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( j % 2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) len0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t// if it is polys\n\t\t\t\t\t\t\t\tcase 'Polys':\n\n\t\t\t\t\t\t\t\t\tvar numberOfPolys = parseInt( piece.attributes.NumberOfPolys );\n\n\t\t\t\t\t\t\t\t\tif ( numberOfPolys > 0 ) {\n\n\t\t\t\t\t\t\t\t\t\tvar connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\n\t\t\t\t\t\t\t\t\t\tvar offset = new Int32Array( section.DataArray[ 1 ].text.length );\n\t\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\n\t\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\n\n\t\t\t\t\t\t\t\t\t\tvar size = numberOfPolys + connectivity.length;\n\t\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfPolys );\n\t\t\t\t\t\t\t\t\t\tvar indicesIndex = 0, connectivityIndex = 0;\n\t\t\t\t\t\t\t\t\t\tvar i = 0, len = numberOfPolys, len0 = 0;\n\n\t\t\t\t\t\t\t\t\t\twhile ( i < len ) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar poly = [];\n\t\t\t\t\t\t\t\t\t\t\tvar s = 0, len1 = offset[ i ];\n\n\t\t\t\t\t\t\t\t\t\t\twhile ( s < len1 - len0 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpoly.push( connectivity[ connectivityIndex ++ ] );\n\t\t\t\t\t\t\t\t\t\t\t\ts ++;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tvar j = 1;\n\n\t\t\t\t\t\t\t\t\t\t\twhile ( j < len1 - len0 - 1 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ 0 ];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j ];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j + 1 ];\n\t\t\t\t\t\t\t\t\t\t\t\tj ++;\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\ti ++;\n\t\t\t\t\t\t\t\t\t\t\tlen0 = offset[ i - 1 ];\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsectionIndex ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( points, 3 ) );\n\n\t\t\t\t\tif ( normals.length === points.length ) {\n\n\t\t\t\t\t\tgeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'Unsupported DATASET type' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction getStringFile( data ) {\n\n\t\t\t\tvar stringFile = '';\n\t\t\t\tvar charArray = new Uint8Array( data );\n\t\t\t\tvar i = 0;\n\t\t\t\tvar len = charArray.length;\n\n\t\t\t\twhile ( len -- ) {\n\n\t\t\t\t\tstringFile += String.fromCharCode( charArray[ i ++ ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn stringFile;\n\n\t\t\t}\n\n\t\t\t// get the 5 first lines of the files to check if there is the key word binary\n\t\t\tvar meta = THREE.LoaderUtils.decodeText( new Uint8Array( data, 0, 250 ) ).split( '\\n' );\n\n\t\t\tif ( meta[ 0 ].indexOf( 'xml' ) !== - 1 ) {\n\n\t\t\t\treturn parseXML( getStringFile( data ) );\n\n\t\t\t} else if ( meta[ 2 ].includes( 'ASCII' ) ) {\n\n\t\t\t\treturn parseASCII( getStringFile( data ) );\n\n\t\t\t} else {\n\n\t\t\t\treturn parseBinary( data );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.VTKLoader;\n});\n"]}