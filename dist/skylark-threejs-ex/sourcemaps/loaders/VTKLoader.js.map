{"version":3,"sources":["loaders/VTKLoader.js"],"names":["define","THREE","Inflate","threex","VTKLoader","manager","Loader","call","this","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setResponseType","text","parse","data","Int32Concat","first","second","firstLength","length","result","Int32Array","set","getStringFile","stringFile","charArray","Uint8Array","i","len","String","fromCharCode","meta","LoaderUtils","decodeText","split","indexOf","Base64toByteArray","b64","j","l","tmp","placeHolders","arr","Arr","Array","lookup","revLookup","code","charCodeAt","Error","L","parseDataArray","ele","compressed","numBytes","json","attributes","header_type","format","byteData","blocks","cSizeStart","headerSize","dataOffsets","currentOffset","type","txt","Float32Array","push","currentBlockSize","content","slice","resize","verify","decompress","buffer","filter","el","idx","dom","window","DOMParser","parseFromString","e","ActiveXObject","async","loadXML","parseError","reason","srcText","xmlToJson","xml","obj","nodeType","attribute","item","nodeName","nodeValue","trim","hasChildNodes","childNodes","old","documentElement","points","normals","indices","PolyData","piece","Piece","hasOwnProperty","sections","sectionIndex","numberOfSections","section","DataArray","toString","dataArrayIndex","numberOfDataArrays","numberOfPoints","parseInt","NumberOfPoints","normalsName","Normals","Name","components","NumberOfComponents","numberOfStrips","NumberOfStrips","connectivity","offset","size","Uint32Array","indicesIndex","strip","s","len1","len0","numberOfPolys","NumberOfPolys","connectivityIndex","poly","geometry","BufferGeometry","setIndex","BufferAttribute","setAttribute","parseXML","includes","positions","colors","patWord","pat3Floats","patConnectivity","patPOINTS","patPOLYGONS","patTRIANGLE_STRIPS","patPOINT_DATA","patCELL_DATA","patCOLOR_SCALARS","patNORMALS","inPointsSection","inPolygonsSection","inTriangleStripSection","inPointDataSection","inCellDataSection","inColorSection","inNormalsSection","lines","line","dataset","exec","x","parseFloat","y","z","numVertices","inds","i0","k","i1","i2","r","g","b","nx","ny","nz","Float32BufferAttribute","numTriangles","toNonIndexed","position","count","newColors","parseASCII","pointIndex","state","dataView","DataView","vtk","index","findString","start","c","end","next","parsedString","join","getFloat32","indexCount","getInt32","byteLength","parseBinary","loaders"],"mappings":"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","file":"../../loaders/VTKLoader.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    'skylark-zlib/Inflate',\r\n    \"../threex\"\r\n], function (\r\n    THREE, \r\n    Inflate,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var VTKLoader = function (manager) {\r\n        THREE.Loader.call(this, manager);\r\n    };\r\n    VTKLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {\r\n        constructor: VTKLoader,\r\n        load: function (url, onLoad, onProgress, onError) {\r\n            var scope = this;\r\n            var loader = new THREE.FileLoader(scope.manager);\r\n            loader.setPath(scope.path);\r\n            loader.setResponseType('arraybuffer');\r\n            loader.load(url, function (text) {\r\n                onLoad(scope.parse(text));\r\n            }, onProgress, onError);\r\n        },\r\n        parse: function (data) {\r\n            function parseASCII(data) {\r\n                var indices = [];\r\n                var positions = [];\r\n                var colors = [];\r\n                var normals = [];\r\n                var result;\r\n                var patWord = /^[^\\d.\\s-]+/;\r\n                var pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g;\r\n                var patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/;\r\n                var patPOINTS = /^POINTS /;\r\n                var patPOLYGONS = /^POLYGONS /;\r\n                var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;\r\n                var patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/;\r\n                var patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/;\r\n                var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/;\r\n                var patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\r\n                var inPointsSection = false;\r\n                var inPolygonsSection = false;\r\n                var inTriangleStripSection = false;\r\n                var inPointDataSection = false;\r\n                var inCellDataSection = false;\r\n                var inColorSection = false;\r\n                var inNormalsSection = false;\r\n                var lines = data.split('\\n');\r\n                for (var i in lines) {\r\n                    var line = lines[i].trim();\r\n                    if (line.indexOf('DATASET') === 0) {\r\n                        var dataset = line.split(' ')[1];\r\n                        if (dataset !== 'POLYDATA')\r\n                            throw new Error('Unsupported DATASET type: ' + dataset);\r\n                    } else if (inPointsSection) {\r\n                        while ((result = pat3Floats.exec(line)) !== null) {\r\n                            if (patWord.exec(line) !== null)\r\n                                break;\r\n                            var x = parseFloat(result[1]);\r\n                            var y = parseFloat(result[2]);\r\n                            var z = parseFloat(result[3]);\r\n                            positions.push(x, y, z);\r\n                        }\r\n                    } else if (inPolygonsSection) {\r\n                        if ((result = patConnectivity.exec(line)) !== null) {\r\n                            var numVertices = parseInt(result[1]);\r\n                            var inds = result[2].split(/\\s+/);\r\n                            if (numVertices >= 3) {\r\n                                var i0 = parseInt(inds[0]);\r\n                                var i1, i2;\r\n                                var k = 1;\r\n                                for (var j = 0; j < numVertices - 2; ++j) {\r\n                                    i1 = parseInt(inds[k]);\r\n                                    i2 = parseInt(inds[k + 1]);\r\n                                    indices.push(i0, i1, i2);\r\n                                    k++;\r\n                                }\r\n                            }\r\n                        }\r\n                    } else if (inTriangleStripSection) {\r\n                        if ((result = patConnectivity.exec(line)) !== null) {\r\n                            var numVertices = parseInt(result[1]);\r\n                            var inds = result[2].split(/\\s+/);\r\n                            if (numVertices >= 3) {\r\n                                var i0, i1, i2;\r\n                                for (var j = 0; j < numVertices - 2; j++) {\r\n                                    if (j % 2 === 1) {\r\n                                        i0 = parseInt(inds[j]);\r\n                                        i1 = parseInt(inds[j + 2]);\r\n                                        i2 = parseInt(inds[j + 1]);\r\n                                        indices.push(i0, i1, i2);\r\n                                    } else {\r\n                                        i0 = parseInt(inds[j]);\r\n                                        i1 = parseInt(inds[j + 1]);\r\n                                        i2 = parseInt(inds[j + 2]);\r\n                                        indices.push(i0, i1, i2);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else if (inPointDataSection || inCellDataSection) {\r\n                        if (inColorSection) {\r\n                            while ((result = pat3Floats.exec(line)) !== null) {\r\n                                if (patWord.exec(line) !== null)\r\n                                    break;\r\n                                var r = parseFloat(result[1]);\r\n                                var g = parseFloat(result[2]);\r\n                                var b = parseFloat(result[3]);\r\n                                colors.push(r, g, b);\r\n                            }\r\n                        } else if (inNormalsSection) {\r\n                            while ((result = pat3Floats.exec(line)) !== null) {\r\n                                if (patWord.exec(line) !== null)\r\n                                    break;\r\n                                var nx = parseFloat(result[1]);\r\n                                var ny = parseFloat(result[2]);\r\n                                var nz = parseFloat(result[3]);\r\n                                normals.push(nx, ny, nz);\r\n                            }\r\n                        }\r\n                    }\r\n                    if (patPOLYGONS.exec(line) !== null) {\r\n                        inPolygonsSection = true;\r\n                        inPointsSection = false;\r\n                        inTriangleStripSection = false;\r\n                    } else if (patPOINTS.exec(line) !== null) {\r\n                        inPolygonsSection = false;\r\n                        inPointsSection = true;\r\n                        inTriangleStripSection = false;\r\n                    } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\r\n                        inPolygonsSection = false;\r\n                        inPointsSection = false;\r\n                        inTriangleStripSection = true;\r\n                    } else if (patPOINT_DATA.exec(line) !== null) {\r\n                        inPointDataSection = true;\r\n                        inPointsSection = false;\r\n                        inPolygonsSection = false;\r\n                        inTriangleStripSection = false;\r\n                    } else if (patCELL_DATA.exec(line) !== null) {\r\n                        inCellDataSection = true;\r\n                        inPointsSection = false;\r\n                        inPolygonsSection = false;\r\n                        inTriangleStripSection = false;\r\n                    } else if (patCOLOR_SCALARS.exec(line) !== null) {\r\n                        inColorSection = true;\r\n                        inNormalsSection = false;\r\n                        inPointsSection = false;\r\n                        inPolygonsSection = false;\r\n                        inTriangleStripSection = false;\r\n                    } else if (patNORMALS.exec(line) !== null) {\r\n                        inNormalsSection = true;\r\n                        inColorSection = false;\r\n                        inPointsSection = false;\r\n                        inPolygonsSection = false;\r\n                        inTriangleStripSection = false;\r\n                    }\r\n                }\r\n                var geometry = new THREE.BufferGeometry();\r\n                geometry.setIndex(indices);\r\n                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n                if (normals.length === positions.length) {\r\n                    geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\r\n                }\r\n                if (colors.length !== indices.length) {\r\n                    if (colors.length === positions.length) {\r\n                        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n                    }\r\n                } else {\r\n                    geometry = geometry.toNonIndexed();\r\n                    var numTriangles = geometry.attributes.position.count / 3;\r\n                    if (colors.length === numTriangles * 3) {\r\n                        var newColors = [];\r\n                        for (var i = 0; i < numTriangles; i++) {\r\n                            var r = colors[3 * i + 0];\r\n                            var g = colors[3 * i + 1];\r\n                            var b = colors[3 * i + 2];\r\n                            newColors.push(r, g, b);\r\n                            newColors.push(r, g, b);\r\n                            newColors.push(r, g, b);\r\n                        }\r\n                        geometry.setAttribute('color', new THREE.Float32BufferAttribute(newColors, 3));\r\n                    }\r\n                }\r\n                return geometry;\r\n            }\r\n            function parseBinary(data) {\r\n                var count, pointIndex, i, numberOfPoints, s;\r\n                var buffer = new Uint8Array(data);\r\n                var dataView = new DataView(data);\r\n                var points = [];\r\n                var normals = [];\r\n                var indices = [];\r\n                var vtk = [];\r\n                var index = 0;\r\n                function findString(buffer, start) {\r\n                    var index = start;\r\n                    var c = buffer[index];\r\n                    var s = [];\r\n                    while (c !== 10) {\r\n                        s.push(String.fromCharCode(c));\r\n                        index++;\r\n                        c = buffer[index];\r\n                    }\r\n                    return {\r\n                        start: start,\r\n                        end: index,\r\n                        next: index + 1,\r\n                        parsedString: s.join('')\r\n                    };\r\n                }\r\n                var state, line;\r\n                while (true) {\r\n                    state = findString(buffer, index);\r\n                    line = state.parsedString;\r\n                    if (line.indexOf('DATASET') === 0) {\r\n                        var dataset = line.split(' ')[1];\r\n                        if (dataset !== 'POLYDATA')\r\n                            throw new Error('Unsupported DATASET type: ' + dataset);\r\n                    } else if (line.indexOf('POINTS') === 0) {\r\n                        vtk.push(line);\r\n                        numberOfPoints = parseInt(line.split(' ')[1], 10);\r\n                        count = numberOfPoints * 4 * 3;\r\n                        points = new Float32Array(numberOfPoints * 3);\r\n                        pointIndex = state.next;\r\n                        for (i = 0; i < numberOfPoints; i++) {\r\n                            points[3 * i] = dataView.getFloat32(pointIndex, false);\r\n                            points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\r\n                            points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\r\n                            pointIndex = pointIndex + 12;\r\n                        }\r\n                        state.next = state.next + count + 1;\r\n                    } else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\r\n                        var numberOfStrips = parseInt(line.split(' ')[1], 10);\r\n                        var size = parseInt(line.split(' ')[2], 10);\r\n                        count = size * 4;\r\n                        indices = new Uint32Array(3 * size - 9 * numberOfStrips);\r\n                        var indicesIndex = 0;\r\n                        pointIndex = state.next;\r\n                        for (i = 0; i < numberOfStrips; i++) {\r\n                            var indexCount = dataView.getInt32(pointIndex, false);\r\n                            var strip = [];\r\n                            pointIndex += 4;\r\n                            for (s = 0; s < indexCount; s++) {\r\n                                strip.push(dataView.getInt32(pointIndex, false));\r\n                                pointIndex += 4;\r\n                            }\r\n                            for (var j = 0; j < indexCount - 2; j++) {\r\n                                if (j % 2) {\r\n                                    indices[indicesIndex++] = strip[j];\r\n                                    indices[indicesIndex++] = strip[j + 2];\r\n                                    indices[indicesIndex++] = strip[j + 1];\r\n                                } else {\r\n                                    indices[indicesIndex++] = strip[j];\r\n                                    indices[indicesIndex++] = strip[j + 1];\r\n                                    indices[indicesIndex++] = strip[j + 2];\r\n                                }\r\n                            }\r\n                        }\r\n                        state.next = state.next + count + 1;\r\n                    } else if (line.indexOf('POLYGONS') === 0) {\r\n                        var numberOfStrips = parseInt(line.split(' ')[1], 10);\r\n                        var size = parseInt(line.split(' ')[2], 10);\r\n                        count = size * 4;\r\n                        indices = new Uint32Array(3 * size - 9 * numberOfStrips);\r\n                        var indicesIndex = 0;\r\n                        pointIndex = state.next;\r\n                        for (i = 0; i < numberOfStrips; i++) {\r\n                            var indexCount = dataView.getInt32(pointIndex, false);\r\n                            var strip = [];\r\n                            pointIndex += 4;\r\n                            for (s = 0; s < indexCount; s++) {\r\n                                strip.push(dataView.getInt32(pointIndex, false));\r\n                                pointIndex += 4;\r\n                            }\r\n                            for (var j = 1; j < indexCount - 1; j++) {\r\n                                indices[indicesIndex++] = strip[0];\r\n                                indices[indicesIndex++] = strip[j];\r\n                                indices[indicesIndex++] = strip[j + 1];\r\n                            }\r\n                        }\r\n                        state.next = state.next + count + 1;\r\n                    } else if (line.indexOf('POINT_DATA') === 0) {\r\n                        numberOfPoints = parseInt(line.split(' ')[1], 10);\r\n                        state = findString(buffer, state.next);\r\n                        count = numberOfPoints * 4 * 3;\r\n                        normals = new Float32Array(numberOfPoints * 3);\r\n                        pointIndex = state.next;\r\n                        for (i = 0; i < numberOfPoints; i++) {\r\n                            normals[3 * i] = dataView.getFloat32(pointIndex, false);\r\n                            normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\r\n                            normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\r\n                            pointIndex += 12;\r\n                        }\r\n                        state.next = state.next + count;\r\n                    }\r\n                    index = state.next;\r\n                    if (index >= buffer.byteLength) {\r\n                        break;\r\n                    }\r\n                }\r\n                var geometry = new THREE.BufferGeometry();\r\n                geometry.setIndex(new THREE.BufferAttribute(indices, 1));\r\n                geometry.setAttribute('position', new THREE.BufferAttribute(points, 3));\r\n                if (normals.length === points.length) {\r\n                    geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));\r\n                }\r\n                return geometry;\r\n            }\r\n            function Float32Concat(first, second) {\r\n                var firstLength = first.length, result = new Float32Array(firstLength + second.length);\r\n                result.set(first);\r\n                result.set(second, firstLength);\r\n                return result;\r\n            }\r\n            function Int32Concat(first, second) {\r\n                var firstLength = first.length, result = new Int32Array(firstLength + second.length);\r\n                result.set(first);\r\n                result.set(second, firstLength);\r\n                return result;\r\n            }\r\n            function parseXML(stringFile) {\r\n                function xmlToJson(xml) {\r\n                    var obj = {};\r\n                    if (xml.nodeType === 1) {\r\n                        if (xml.attributes) {\r\n                            if (xml.attributes.length > 0) {\r\n                                obj['attributes'] = {};\r\n                                for (var j = 0; j < xml.attributes.length; j++) {\r\n                                    var attribute = xml.attributes.item(j);\r\n                                    obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\r\n                                }\r\n                            }\r\n                        }\r\n                    } else if (xml.nodeType === 3) {\r\n                        obj = xml.nodeValue.trim();\r\n                    }\r\n                    if (xml.hasChildNodes()) {\r\n                        for (var i = 0; i < xml.childNodes.length; i++) {\r\n                            var item = xml.childNodes.item(i);\r\n                            var nodeName = item.nodeName;\r\n                            if (typeof obj[nodeName] === 'undefined') {\r\n                                var tmp = xmlToJson(item);\r\n                                if (tmp !== '')\r\n                                    obj[nodeName] = tmp;\r\n                            } else {\r\n                                if (typeof obj[nodeName].push === 'undefined') {\r\n                                    var old = obj[nodeName];\r\n                                    obj[nodeName] = [old];\r\n                                }\r\n                                var tmp = xmlToJson(item);\r\n                                if (tmp !== '')\r\n                                    obj[nodeName].push(tmp);\r\n                            }\r\n                        }\r\n                    }\r\n                    return obj;\r\n                }\r\n                function Base64toByteArray(b64) {\r\n                    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\r\n                    var i;\r\n                    var lookup = [];\r\n                    var revLookup = [];\r\n                    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n                    var len = code.length;\r\n                    for (i = 0; i < len; i++) {\r\n                        lookup[i] = code[i];\r\n                    }\r\n                    for (i = 0; i < len; ++i) {\r\n                        revLookup[code.charCodeAt(i)] = i;\r\n                    }\r\n                    revLookup['-'.charCodeAt(0)] = 62;\r\n                    revLookup['_'.charCodeAt(0)] = 63;\r\n                    var j, l, tmp, placeHolders, arr;\r\n                    var len = b64.length;\r\n                    if (len % 4 > 0) {\r\n                        throw new Error('Invalid string. Length must be a multiple of 4');\r\n                    }\r\n                    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\r\n                    arr = new Arr(len * 3 / 4 - placeHolders);\r\n                    l = placeHolders > 0 ? len - 4 : len;\r\n                    var L = 0;\r\n                    for (i = 0, j = 0; i < l; i += 4, j += 3) {\r\n                        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\r\n                        arr[L++] = (tmp & 16711680) >> 16;\r\n                        arr[L++] = (tmp & 65280) >> 8;\r\n                        arr[L++] = tmp & 255;\r\n                    }\r\n                    if (placeHolders === 2) {\r\n                        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\r\n                        arr[L++] = tmp & 255;\r\n                    } else if (placeHolders === 1) {\r\n                        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\r\n                        arr[L++] = tmp >> 8 & 255;\r\n                        arr[L++] = tmp & 255;\r\n                    }\r\n                    return arr;\r\n                }\r\n                function parseDataArray(ele, compressed) {\r\n                    var numBytes = 0;\r\n                    if (json.attributes.header_type === 'UInt64') {\r\n                        numBytes = 8;\r\n                    } else if (json.attributes.header_type === 'UInt32') {\r\n                        numBytes = 4;\r\n                    }\r\n                    if (ele.attributes.format === 'binary' && compressed) {\r\n                        var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\r\n                        if (ele.attributes.type === 'Float32') {\r\n                            var txt = new Float32Array();\r\n                        } else if (ele.attributes.type === 'Int64') {\r\n                            var txt = new Int32Array();\r\n                        }\r\n                        rawData = ele['#text'];\r\n                        byteData = Base64toByteArray(rawData);\r\n                        blocks = byteData[0];\r\n                        for (var i = 1; i < numBytes - 1; i++) {\r\n                            blocks = blocks | byteData[i] << i * numBytes;\r\n                        }\r\n                        headerSize = (blocks + 3) * numBytes;\r\n                        padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\r\n                        headerSize = headerSize + padding;\r\n                        dataOffsets = [];\r\n                        currentOffset = headerSize;\r\n                        dataOffsets.push(currentOffset);\r\n                        cSizeStart = 3 * numBytes;\r\n                        for (var i = 0; i < blocks; i++) {\r\n                            var currentBlockSize = byteData[i * numBytes + cSizeStart];\r\n                            for (var j = 1; j < numBytes - 1; j++) {\r\n                                currentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * 8;\r\n                            }\r\n                            currentOffset = currentOffset + currentBlockSize;\r\n                            dataOffsets.push(currentOffset);\r\n                        }\r\n                        for (var i = 0; i < dataOffsets.length - 1; i++) {\r\n                            var inflate = new Inflate(byteData.slice(dataOffsets[i], dataOffsets[i + 1]), {\r\n                                resize: true,\r\n                                verify: true\r\n                            });\r\n                            content = inflate.decompress();\r\n                            content = content.buffer;\r\n                            if (ele.attributes.type === 'Float32') {\r\n                                content = new Float32Array(content);\r\n                                txt = Float32Concat(txt, content);\r\n                            } else if (ele.attributes.type === 'Int64') {\r\n                                content = new Int32Array(content);\r\n                                txt = Int32Concat(txt, content);\r\n                            }\r\n                        }\r\n                        delete ele['#text'];\r\n                        if (ele.attributes.type === 'Int64') {\r\n                            if (ele.attributes.format === 'binary') {\r\n                                txt = txt.filter(function (el, idx) {\r\n                                    if (idx % 2 !== 1)\r\n                                        return true;\r\n                                });\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (ele.attributes.format === 'binary' && !compressed) {\r\n                            var content = Base64toByteArray(ele['#text']);\r\n                            content = content.slice(numBytes).buffer;\r\n                        } else {\r\n                            if (ele['#text']) {\r\n                                var content = ele['#text'].split(/\\s+/).filter(function (el) {\r\n                                    if (el !== '')\r\n                                        return el;\r\n                                });\r\n                            } else {\r\n                                var content = new Int32Array(0).buffer;\r\n                            }\r\n                        }\r\n                        delete ele['#text'];\r\n                        if (ele.attributes.type === 'Float32') {\r\n                            var txt = new Float32Array(content);\r\n                        } else if (ele.attributes.type === 'Int32') {\r\n                            var txt = new Int32Array(content);\r\n                        } else if (ele.attributes.type === 'Int64') {\r\n                            var txt = new Int32Array(content);\r\n                            if (ele.attributes.format === 'binary') {\r\n                                txt = txt.filter(function (el, idx) {\r\n                                    if (idx % 2 !== 1)\r\n                                        return true;\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                    return txt;\r\n                }\r\n                var dom = null;\r\n                if (window.DOMParser) {\r\n                    try {\r\n                        dom = new DOMParser().parseFromString(stringFile, 'text/xml');\r\n                    } catch (e) {\r\n                        dom = null;\r\n                    }\r\n                } else if (window.ActiveXObject) {\r\n                    try {\r\n                        dom = new ActiveXObject('Microsoft.XMLDOM');\r\n                        dom.async = false;\r\n                        if (!dom.loadXML()) {\r\n                            throw new Error(dom.parseError.reason + dom.parseError.srcText);\r\n                        }\r\n                    } catch (e) {\r\n                        dom = null;\r\n                    }\r\n                } else {\r\n                    throw new Error('Cannot parse xml string!');\r\n                }\r\n                var doc = dom.documentElement;\r\n                var json = xmlToJson(doc);\r\n                var points = [];\r\n                var normals = [];\r\n                var indices = [];\r\n                if (json.PolyData) {\r\n                    var piece = json.PolyData.Piece;\r\n                    var compressed = json.attributes.hasOwnProperty('compressor');\r\n                    var sections = [\r\n                        'PointData',\r\n                        'Points',\r\n                        'Strips',\r\n                        'Polys'\r\n                    ];\r\n                    var sectionIndex = 0, numberOfSections = sections.length;\r\n                    while (sectionIndex < numberOfSections) {\r\n                        var section = piece[sections[sectionIndex]];\r\n                        if (section && section.DataArray) {\r\n                            if (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\r\n                                var arr = section.DataArray;\r\n                            } else {\r\n                                var arr = [section.DataArray];\r\n                            }\r\n                            var dataArrayIndex = 0, numberOfDataArrays = arr.length;\r\n                            while (dataArrayIndex < numberOfDataArrays) {\r\n                                if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\r\n                                    arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\r\n                                }\r\n                                dataArrayIndex++;\r\n                            }\r\n                            switch (sections[sectionIndex]) {\r\n                            case 'PointData':\r\n                                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\r\n                                var normalsName = section.attributes.Normals;\r\n                                if (numberOfPoints > 0) {\r\n                                    for (var i = 0, len = arr.length; i < len; i++) {\r\n                                        if (normalsName === arr[i].attributes.Name) {\r\n                                            var components = arr[i].attributes.NumberOfComponents;\r\n                                            normals = new Float32Array(numberOfPoints * components);\r\n                                            normals.set(arr[i].text, 0);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case 'Points':\r\n                                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\r\n                                if (numberOfPoints > 0) {\r\n                                    var components = section.DataArray.attributes.NumberOfComponents;\r\n                                    points = new Float32Array(numberOfPoints * components);\r\n                                    points.set(section.DataArray.text, 0);\r\n                                }\r\n                                break;\r\n                            case 'Strips':\r\n                                var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\r\n                                if (numberOfStrips > 0) {\r\n                                    var connectivity = new Int32Array(section.DataArray[0].text.length);\r\n                                    var offset = new Int32Array(section.DataArray[1].text.length);\r\n                                    connectivity.set(section.DataArray[0].text, 0);\r\n                                    offset.set(section.DataArray[1].text, 0);\r\n                                    var size = numberOfStrips + connectivity.length;\r\n                                    indices = new Uint32Array(3 * size - 9 * numberOfStrips);\r\n                                    var indicesIndex = 0;\r\n                                    for (var i = 0, len = numberOfStrips; i < len; i++) {\r\n                                        var strip = [];\r\n                                        for (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\r\n                                            strip.push(connectivity[s]);\r\n                                            if (i > 0)\r\n                                                len0 = offset[i - 1];\r\n                                        }\r\n                                        for (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\r\n                                            if (j % 2) {\r\n                                                indices[indicesIndex++] = strip[j];\r\n                                                indices[indicesIndex++] = strip[j + 2];\r\n                                                indices[indicesIndex++] = strip[j + 1];\r\n                                            } else {\r\n                                                indices[indicesIndex++] = strip[j];\r\n                                                indices[indicesIndex++] = strip[j + 1];\r\n                                                indices[indicesIndex++] = strip[j + 2];\r\n                                            }\r\n                                            if (i > 0)\r\n                                                len0 = offset[i - 1];\r\n                                        }\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case 'Polys':\r\n                                var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\r\n                                if (numberOfPolys > 0) {\r\n                                    var connectivity = new Int32Array(section.DataArray[0].text.length);\r\n                                    var offset = new Int32Array(section.DataArray[1].text.length);\r\n                                    connectivity.set(section.DataArray[0].text, 0);\r\n                                    offset.set(section.DataArray[1].text, 0);\r\n                                    var size = numberOfPolys + connectivity.length;\r\n                                    indices = new Uint32Array(3 * size - 9 * numberOfPolys);\r\n                                    var indicesIndex = 0, connectivityIndex = 0;\r\n                                    var i = 0, len = numberOfPolys, len0 = 0;\r\n                                    while (i < len) {\r\n                                        var poly = [];\r\n                                        var s = 0, len1 = offset[i];\r\n                                        while (s < len1 - len0) {\r\n                                            poly.push(connectivity[connectivityIndex++]);\r\n                                            s++;\r\n                                        }\r\n                                        var j = 1;\r\n                                        while (j < len1 - len0 - 1) {\r\n                                            indices[indicesIndex++] = poly[0];\r\n                                            indices[indicesIndex++] = poly[j];\r\n                                            indices[indicesIndex++] = poly[j + 1];\r\n                                            j++;\r\n                                        }\r\n                                        i++;\r\n                                        len0 = offset[i - 1];\r\n                                    }\r\n                                }\r\n                                break;\r\n                            default:\r\n                                break;\r\n                            }\r\n                        }\r\n                        sectionIndex++;\r\n                    }\r\n                    var geometry = new THREE.BufferGeometry();\r\n                    geometry.setIndex(new THREE.BufferAttribute(indices, 1));\r\n                    geometry.setAttribute('position', new THREE.BufferAttribute(points, 3));\r\n                    if (normals.length === points.length) {\r\n                        geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));\r\n                    }\r\n                    return geometry;\r\n                } else {\r\n                    throw new Error('Unsupported DATASET type');\r\n                }\r\n            }\r\n            function getStringFile(data) {\r\n                var stringFile = '';\r\n                var charArray = new Uint8Array(data);\r\n                var i = 0;\r\n                var len = charArray.length;\r\n                while (len--) {\r\n                    stringFile += String.fromCharCode(charArray[i++]);\r\n                }\r\n                return stringFile;\r\n            }\r\n            var meta = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\\n');\r\n            if (meta[0].indexOf('xml') !== -1) {\r\n                return parseXML(getStringFile(data));\r\n            } else if (meta[2].includes('ASCII')) {\r\n                return parseASCII(getStringFile(data));\r\n            } else {\r\n                return parseBinary(data);\r\n            }\r\n        }\r\n    });\r\n\r\n    return threex.loaders.VTKLoader = VTKLoader;\r\n});"]}