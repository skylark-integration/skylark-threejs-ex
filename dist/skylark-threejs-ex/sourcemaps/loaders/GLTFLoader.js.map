{"version":3,"sources":["loaders/GLTFLoader.js"],"names":["define","THREE","threex","GLTFLoader","manager","Loader","call","this","dracoLoader","ddsLoader","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","resourcePath","scope","path","LoaderUtils","extractUrlBase","itemStart","_onError","e","console","error","itemError","itemEnd","loader","FileLoader","setPath","setResponseType","crossOrigin","setWithCredentials","data","parse","gltf","setDRACOLoader","setDDSLoader","content","extensions","decodeText","Uint8Array","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","name","body","headerView","DataView","BINARY_EXTENSION_HEADER_LENGTH","header","magic","slice","version","getUint32","length","Error","chunkView","chunkIndex","byteLength","chunkLength","chunkType","BINARY_EXTENSION_CHUNK_TYPES","JSON","contentArray","BIN","byteOffset","json","undefined","asset","extensionsUsed","i","extensionName","extensionsRequired","KHR_LIGHTS_PUNCTUAL","GLTFLightsExtension","KHR_MATERIALS_CLEARCOAT","GLTFMaterialsClearcoatExtension","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS","GLTFMaterialsPbrSpecularGlossinessExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","MSFT_TEXTURE_DDS","GLTFTextureDDSExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","indexOf","warn","GLTFParser","extension","lightDefs","lights","loadLight","lightIndex","lightNode","lightDef","color","Color","fromArray","range","type","DirectionalLight","target","position","set","add","PointLight","distance","SpotLight","spot","innerConeAngle","outerConeAngle","Math","PI","angle","penumbra","decay","intensity","Promise","resolve","getMaterialType","MeshBasicMaterial","extendParams","materialParams","materialDef","parser","pending","opacity","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","array","baseColorTexture","push","assignTexture","all","MeshPhysicalMaterial","clearcoatFactor","clearcoat","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessTexture","clearcoatNormalTexture","scale","clearcoatNormalScale","Vector2","preload","GLTFMeshStandardSGMaterial","params","MeshStandardMaterial","isGLTFSpecularGlossinessMaterial","specularMapParsFragmentChunk","join","glossinessMapParsFragmentChunk","specularMapFragmentChunk","glossinessMapFragmentChunk","lightPhysicalFragmentChunk","uniforms","specular","value","setHex","glossiness","specularMap","glossinessMap","_extraUniforms","onBeforeCompile","shader","uniformName","fragmentShader","replace","defineProperties","get","v","defines","USE_GLOSSINESSMAP","USE_ROUGHNESSMAP","metalness","roughness","metalnessMap","roughnessMap","setValues","specularGlossinessParams","pbrSpecularGlossiness","diffuseFactor","diffuseTexture","emissive","glossinessFactor","specularFactor","specularGlossinessTexture","specGlossMapDef","createMaterial","material","fog","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","TangentSpaceNormalMap","normalScale","displacementMap","displacementScale","displacementBias","alphaMap","envMap","envMapIntensity","refractionRatio","GLTFCubicSplineInterpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","Interpolant","decodePrimitive","primitive","bufferViewIndex","bufferView","gltfAttributeMap","attributes","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","attributeName","threeAttributeName","ATTRIBUTES","toLowerCase","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","normalized","getDependency","then","decodeDracoFile","geometry","attribute","extendTexture","texture","transform","clone","offset","rotation","repeat","texCoord","needsUpdate","copy","source","copySampleValue_","index","result","values","valueSize","beforeStart_","afterEnd_","interpolate_","i1","t0","t","t1","stride","stride2","stride3","td","p","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","WEBGL_CONSTANTS","5120","Int8Array","5121","5122","Int16Array","5123","Uint16Array","5125","Uint32Array","5126","Float32Array","WEBGL_FILTERS","9728","NearestFilter","9729","LinearFilter","9984","NearestMipmapNearestFilter","9985","LinearMipmapNearestFilter","9986","NearestMipmapLinearFilter","9987","LinearMipmapLinearFilter","WEBGL_WRAPPINGS","33071","ClampToEdgeWrapping","33648","MirroredRepeatWrapping","10497","RepeatWrapping","WEBGL_TYPE_SIZES","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","LINEAR","InterpolateLinear","STEP","InterpolateDiscrete","ALPHA_MODES","MIME_TYPE_FORMATS","image/png","RGBAFormat","image/jpeg","RGBFormat","resolveURL","test","addUnknownExtensionsToUserData","knownExtensions","object","objectDef","userData","gltfExtensions","assignExtrasToUserData","gltfDef","extras","updateMorphTargets","mesh","meshDef","il","morphTargetInfluences","targetNames","morphTargetDictionary","createAttributesKey","attributesKey","keys","sort","options","cache","objects","key","remove","removeAll","primitiveCache","textureLoader","TextureLoader","setCrossOrigin","fileLoader","addPrimitiveAttributes","primitiveDef","assignAttributeAccessor","accessorIndex","accessor","setAttribute","gltfAttributeName","indices","setIndex","box","Box3","min","max","Vector3","targets","maxDisplacement","vector","setX","abs","setY","setZ","expandByVector","boundingBox","sphere","Sphere","getCenter","center","radius","distanceTo","boundingSphere","computeBounds","hasMorphPosition","hasMorphNormal","pendingPositionAccessors","pendingNormalAccessors","pendingAccessor","normal","morphPositions","morphNormals","morphAttributes","morphTargetsRelative","addMorphTargets","toTrianglesDrawMode","drawMode","getIndex","getAttribute","count","numberOfTriangles","newIndices","TriangleFanDrawMode","getX","newGeometry","markDefs","getDependencies","dependencies","scene","scenes","animations","cameras","catch","nodeDefs","nodes","skinDefs","skins","meshDefs","meshes","meshReferences","meshUses","skinIndex","skinLength","joints","isBone","nodeIndex","nodeLength","nodeDef","skin","isSkinnedMesh","cacheKey","dependency","loadScene","loadNode","loadMesh","loadAccessor","loadBufferView","loadBuffer","loadMaterial","loadTexture","loadSkin","loadAnimation","loadCamera","defs","def","bufferIndex","bufferDef","buffers","uri","reject","bufferViewDef","bufferViews","buffer","sparse","pendingBufferViews","bufferAttribute","itemSize","TypedArray","elementBytes","BYTES_PER_ELEMENT","itemBytes","byteStride","ibSlice","floor","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","BufferAttribute","itemSizeIndices","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setW","textureIndex","URL","self","webkitURL","textureDef","textures","textureExtensions","sourceURI","images","isObjectURL","blob","Blob","mimeType","createObjectURL","getHandler","revokeObjectURL","flipY","format","sampler","samplers","magFilter","minFilter","wrapS","wrapT","mapName","mapDef","isCompressedTexture","assignFinalMaterial","useVertexTangents","tangent","useVertexColors","useFlatShading","useSkinning","useMorphTargets","useMorphNormals","isPoints","uuid","pointsMaterial","PointsMaterial","Material","sizeAttenuation","isLine","lineMaterial","LineBasicMaterial","cachedMaterial","skinning","vertexTangents","vertexColors","flatShading","morphTargets","uv2","uv","y","materialIndex","materialType","materials","materialExtensions","sgExtension","kmuExtension","metallicFactor","roughnessFactor","metallicRoughnessTexture","doubleSided","side","DoubleSide","alphaMode","transparent","depthWrite","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","emissiveFactor","emissiveTexture","clearcoatExtension","encoding","sRGBEncoding","loadGeometries","primitives","createDracoPrimitive","dracoExtension","geometryPromise","mode","cached","promise","BufferGeometry","meshIndex","depthTest","FrontSide","results","geometries","SkinnedMesh","Mesh","skinWeight","normalizeSkinWeights","TriangleStripDrawMode","LineSegments","Line","LineLoop","Points","group","Group","cameraIndex","camera","cameraDef","PerspectiveCamera","MathUtils","radToDeg","yfov","aspectRatio","znear","zfar","OrthographicCamera","xmag","ymag","skinDef","skinEntry","inverseBindMatrices","animationIndex","animationDef","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","channel","node","id","input","parameters","output","inputAccessors","outputAccessors","tracks","inputAccessor","outputAccessor","TypedKeyframeTrack","updateMatrix","matrixAutoUpdate","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","targetName","interpolation","traverse","isMesh","outputArray","scaled","j","jl","track","createInterpolant","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","AnimationClip","instanceNum","o","light","Bone","Object3D","PropertyBinding","sanitizeNodeName","matrix","Matrix4","applyMatrix4","quaternion","buildNodeHierachy","nodeId","parentObject","pendingJoints","jointNodes","bones","boneInverses","jointNode","mat","bind","Skeleton","matrixWorld","children","child","sceneIndex","sceneDef","nodeIds","loaders"],"mappings":"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","file":"../../loaders/GLTFLoader.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    var GLTFLoader = function () {\n        function GLTFLoader(manager) {\n            THREE.Loader.call(this, manager);\n            this.dracoLoader = null;\n            this.ddsLoader = null;\n        }\n        GLTFLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {\n            constructor: GLTFLoader,\n            load: function (url, onLoad, onProgress, onError) {\n                var scope = this;\n                var resourcePath;\n                if (this.resourcePath !== '') {\n                    resourcePath = this.resourcePath;\n                } else if (this.path !== '') {\n                    resourcePath = this.path;\n                } else {\n                    resourcePath = THREE.LoaderUtils.extractUrlBase(url);\n                }\n                scope.manager.itemStart(url);\n                var _onError = function (e) {\n                    if (onError) {\n                        onError(e);\n                    } else {\n                        console.error(e);\n                    }\n                    scope.manager.itemError(url);\n                    scope.manager.itemEnd(url);\n                };\n                var loader = new THREE.FileLoader(scope.manager);\n                loader.setPath(this.path);\n                loader.setResponseType('arraybuffer');\n                if (scope.crossOrigin === 'use-credentials') {\n                    loader.setWithCredentials(true);\n                }\n                loader.load(url, function (data) {\n                    try {\n                        scope.parse(data, resourcePath, function (gltf) {\n                            onLoad(gltf);\n                            scope.manager.itemEnd(url);\n                        }, _onError);\n                    } catch (e) {\n                        _onError(e);\n                    }\n                }, onProgress, _onError);\n            },\n            setDRACOLoader: function (dracoLoader) {\n                this.dracoLoader = dracoLoader;\n                return this;\n            },\n            setDDSLoader: function (ddsLoader) {\n                this.ddsLoader = ddsLoader;\n                return this;\n            },\n            parse: function (data, path, onLoad, onError) {\n                var content;\n                var extensions = {};\n                if (typeof data === 'string') {\n                    content = data;\n                } else {\n                    var magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n                    if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n                        try {\n                            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n                        } catch (error) {\n                            if (onError)\n                                onError(error);\n                            return;\n                        }\n                        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n                    } else {\n                        content = THREE.LoaderUtils.decodeText(new Uint8Array(data));\n                    }\n                }\n                var json = JSON.parse(content);\n                if (json.asset === undefined || json.asset.version[0] < 2) {\n                    if (onError)\n                        onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));\n                    return;\n                }\n                if (json.extensionsUsed) {\n                    for (var i = 0; i < json.extensionsUsed.length; ++i) {\n                        var extensionName = json.extensionsUsed[i];\n                        var extensionsRequired = json.extensionsRequired || [];\n                        switch (extensionName) {\n                        case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:\n                            extensions[extensionName] = new GLTFLightsExtension(json);\n                            break;\n                        case EXTENSIONS.KHR_MATERIALS_CLEARCOAT:\n                            extensions[extensionName] = new GLTFMaterialsClearcoatExtension();\n                            break;\n                        case EXTENSIONS.KHR_MATERIALS_UNLIT:\n                            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n                            break;\n                        case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n                            extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n                            break;\n                        case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n                            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n                            break;\n                        case EXTENSIONS.MSFT_TEXTURE_DDS:\n                            extensions[extensionName] = new GLTFTextureDDSExtension(this.ddsLoader);\n                            break;\n                        case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n                            extensions[extensionName] = new GLTFTextureTransformExtension();\n                            break;\n                        case EXTENSIONS.KHR_MESH_QUANTIZATION:\n                            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n                            break;\n                        default:\n                            if (extensionsRequired.indexOf(extensionName) >= 0) {\n                                console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n                            }\n                        }\n                    }\n                }\n                var parser = new GLTFParser(json, extensions, {\n                    path: path || this.resourcePath || '',\n                    crossOrigin: this.crossOrigin,\n                    manager: this.manager\n                });\n                parser.parse(onLoad, onError);\n            }\n        });\n        function GLTFRegistry() {\n            var objects = {};\n            return {\n                get: function (key) {\n                    return objects[key];\n                },\n                add: function (key, object) {\n                    objects[key] = object;\n                },\n                remove: function (key) {\n                    delete objects[key];\n                },\n                removeAll: function () {\n                    objects = {};\n                }\n            };\n        }\n        var EXTENSIONS = {\n            KHR_BINARY_GLTF: 'KHR_binary_glTF',\n            KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n            KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n            KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n            KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n            KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n            KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n            KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n            MSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n        };\n        function GLTFTextureDDSExtension(ddsLoader) {\n            if (!ddsLoader) {\n                throw new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader');\n            }\n            this.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n            this.ddsLoader = ddsLoader;\n        }\n        function GLTFLightsExtension(json) {\n            this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n            var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || {};\n            this.lightDefs = extension.lights || [];\n        }\n        GLTFLightsExtension.prototype.loadLight = function (lightIndex) {\n            var lightDef = this.lightDefs[lightIndex];\n            var lightNode;\n            var color = new THREE.Color(16777215);\n            if (lightDef.color !== undefined)\n                color.fromArray(lightDef.color);\n            var range = lightDef.range !== undefined ? lightDef.range : 0;\n            switch (lightDef.type) {\n            case 'directional':\n                lightNode = new THREE.DirectionalLight(color);\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            case 'point':\n                lightNode = new THREE.PointLight(color);\n                lightNode.distance = range;\n                break;\n            case 'spot':\n                lightNode = new THREE.SpotLight(color);\n                lightNode.distance = range;\n                lightDef.spot = lightDef.spot || {};\n                lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n                lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4;\n                lightNode.angle = lightDef.spot.outerConeAngle;\n                lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            default:\n                throw new Error('THREE.GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".');\n            }\n            lightNode.position.set(0, 0, 0);\n            lightNode.decay = 2;\n            if (lightDef.intensity !== undefined)\n                lightNode.intensity = lightDef.intensity;\n            lightNode.name = lightDef.name || 'light_' + lightIndex;\n            return Promise.resolve(lightNode);\n        };\n        function GLTFMaterialsUnlitExtension() {\n            this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n        }\n        GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {\n            return THREE.MeshBasicMaterial;\n        };\n        GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, materialDef, parser) {\n            var pending = [];\n            materialParams.color = new THREE.Color(1, 1, 1);\n            materialParams.opacity = 1;\n            var metallicRoughness = materialDef.pbrMetallicRoughness;\n            if (metallicRoughness) {\n                if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                    var array = metallicRoughness.baseColorFactor;\n                    materialParams.color.fromArray(array);\n                    materialParams.opacity = array[3];\n                }\n                if (metallicRoughness.baseColorTexture !== undefined) {\n                    pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n                }\n            }\n            return Promise.all(pending);\n        };\n        function GLTFMaterialsClearcoatExtension() {\n            this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n        }\n        GLTFMaterialsClearcoatExtension.prototype.getMaterialType = function () {\n            return THREE.MeshPhysicalMaterial;\n        };\n        GLTFMaterialsClearcoatExtension.prototype.extendParams = function (materialParams, materialDef, parser) {\n            var pending = [];\n            var extension = materialDef.extensions[this.name];\n            if (extension.clearcoatFactor !== undefined) {\n                materialParams.clearcoat = extension.clearcoatFactor;\n            }\n            if (extension.clearcoatTexture !== undefined) {\n                pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));\n            }\n            if (extension.clearcoatRoughnessFactor !== undefined) {\n                materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n            }\n            if (extension.clearcoatRoughnessTexture !== undefined) {\n                pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));\n            }\n            if (extension.clearcoatNormalTexture !== undefined) {\n                pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));\n                if (extension.clearcoatNormalTexture.scale !== undefined) {\n                    var scale = extension.clearcoatNormalTexture.scale;\n                    materialParams.clearcoatNormalScale = new THREE.Vector2(scale, scale);\n                }\n            }\n            return Promise.all(pending);\n        };\n        var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n        var BINARY_EXTENSION_HEADER_LENGTH = 12;\n        var BINARY_EXTENSION_CHUNK_TYPES = {\n            JSON: 1313821514,\n            BIN: 5130562\n        };\n        function GLTFBinaryExtension(data) {\n            this.name = EXTENSIONS.KHR_BINARY_GLTF;\n            this.content = null;\n            this.body = null;\n            var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n            this.header = {\n                magic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n                version: headerView.getUint32(4, true),\n                length: headerView.getUint32(8, true)\n            };\n            if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n                throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n            } else if (this.header.version < 2) {\n                throw new Error('THREE.GLTFLoader: Legacy binary file detected.');\n            }\n            var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n            var chunkIndex = 0;\n            while (chunkIndex < chunkView.byteLength) {\n                var chunkLength = chunkView.getUint32(chunkIndex, true);\n                chunkIndex += 4;\n                var chunkType = chunkView.getUint32(chunkIndex, true);\n                chunkIndex += 4;\n                if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n                    var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n                    this.content = THREE.LoaderUtils.decodeText(contentArray);\n                } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n                    var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n                    this.body = data.slice(byteOffset, byteOffset + chunkLength);\n                }\n                chunkIndex += chunkLength;\n            }\n            if (this.content === null) {\n                throw new Error('THREE.GLTFLoader: JSON content not found.');\n            }\n        }\n        function GLTFDracoMeshCompressionExtension(json, dracoLoader) {\n            if (!dracoLoader) {\n                throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n            }\n            this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n            this.json = json;\n            this.dracoLoader = dracoLoader;\n            this.dracoLoader.preload();\n        }\n        GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {\n            var json = this.json;\n            var dracoLoader = this.dracoLoader;\n            var bufferViewIndex = primitive.extensions[this.name].bufferView;\n            var gltfAttributeMap = primitive.extensions[this.name].attributes;\n            var threeAttributeMap = {};\n            var attributeNormalizedMap = {};\n            var attributeTypeMap = {};\n            for (var attributeName in gltfAttributeMap) {\n                var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n                threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n            }\n            for (attributeName in primitive.attributes) {\n                var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n                if (gltfAttributeMap[attributeName] !== undefined) {\n                    var accessorDef = json.accessors[primitive.attributes[attributeName]];\n                    var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n                    attributeTypeMap[threeAttributeName] = componentType;\n                    attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n                }\n            }\n            return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n                return new Promise(function (resolve) {\n                    dracoLoader.decodeDracoFile(bufferView, function (geometry) {\n                        for (var attributeName in geometry.attributes) {\n                            var attribute = geometry.attributes[attributeName];\n                            var normalized = attributeNormalizedMap[attributeName];\n                            if (normalized !== undefined)\n                                attribute.normalized = normalized;\n                        }\n                        resolve(geometry);\n                    }, threeAttributeMap, attributeTypeMap);\n                });\n            });\n        };\n        function GLTFTextureTransformExtension() {\n            this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n        }\n        GLTFTextureTransformExtension.prototype.extendTexture = function (texture, transform) {\n            texture = texture.clone();\n            if (transform.offset !== undefined) {\n                texture.offset.fromArray(transform.offset);\n            }\n            if (transform.rotation !== undefined) {\n                texture.rotation = transform.rotation;\n            }\n            if (transform.scale !== undefined) {\n                texture.repeat.fromArray(transform.scale);\n            }\n            if (transform.texCoord !== undefined) {\n                console.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\n            }\n            texture.needsUpdate = true;\n            return texture;\n        };\n        function GLTFMeshStandardSGMaterial(params) {\n            THREE.MeshStandardMaterial.call(this);\n            this.isGLTFSpecularGlossinessMaterial = true;\n            var specularMapParsFragmentChunk = [\n                '#ifdef USE_SPECULARMAP',\n                '\\tuniform sampler2D specularMap;',\n                '#endif'\n            ].join('\\n');\n            var glossinessMapParsFragmentChunk = [\n                '#ifdef USE_GLOSSINESSMAP',\n                '\\tuniform sampler2D glossinessMap;',\n                '#endif'\n            ].join('\\n');\n            var specularMapFragmentChunk = [\n                'vec3 specularFactor = specular;',\n                '#ifdef USE_SPECULARMAP',\n                '\\tvec4 texelSpecular = texture2D( specularMap, vUv );',\n                '\\ttexelSpecular = sRGBToLinear( texelSpecular );',\n                '\\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\n                '\\tspecularFactor *= texelSpecular.rgb;',\n                '#endif'\n            ].join('\\n');\n            var glossinessMapFragmentChunk = [\n                'float glossinessFactor = glossiness;',\n                '#ifdef USE_GLOSSINESSMAP',\n                '\\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\n                '\\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\n                '\\tglossinessFactor *= texelGlossiness.a;',\n                '#endif'\n            ].join('\\n');\n            var lightPhysicalFragmentChunk = [\n                'PhysicalMaterial material;',\n                'material.diffuseColor = diffuseColor.rgb;',\n                'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',\n                'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',\n                'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.',\n                'material.specularRoughness += geometryRoughness;',\n                'material.specularRoughness = min( material.specularRoughness, 1.0 );',\n                'material.specularColor = specularFactor.rgb;'\n            ].join('\\n');\n            var uniforms = {\n                specular: { value: new THREE.Color().setHex(16777215) },\n                glossiness: { value: 1 },\n                specularMap: { value: null },\n                glossinessMap: { value: null }\n            };\n            this._extraUniforms = uniforms;\n            this.onBeforeCompile = function (shader) {\n                for (var uniformName in uniforms) {\n                    shader.uniforms[uniformName] = uniforms[uniformName];\n                }\n                shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;');\n                shader.fragmentShader = shader.fragmentShader.replace('uniform float metalness;', 'uniform float glossiness;');\n                shader.fragmentShader = shader.fragmentShader.replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk);\n                shader.fragmentShader = shader.fragmentShader.replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk);\n                shader.fragmentShader = shader.fragmentShader.replace('#include <roughnessmap_fragment>', specularMapFragmentChunk);\n                shader.fragmentShader = shader.fragmentShader.replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk);\n                shader.fragmentShader = shader.fragmentShader.replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n            };\n            Object.defineProperties(this, {\n                specular: {\n                    get: function () {\n                        return uniforms.specular.value;\n                    },\n                    set: function (v) {\n                        uniforms.specular.value = v;\n                    }\n                },\n                specularMap: {\n                    get: function () {\n                        return uniforms.specularMap.value;\n                    },\n                    set: function (v) {\n                        uniforms.specularMap.value = v;\n                    }\n                },\n                glossiness: {\n                    get: function () {\n                        return uniforms.glossiness.value;\n                    },\n                    set: function (v) {\n                        uniforms.glossiness.value = v;\n                    }\n                },\n                glossinessMap: {\n                    get: function () {\n                        return uniforms.glossinessMap.value;\n                    },\n                    set: function (v) {\n                        uniforms.glossinessMap.value = v;\n                        if (v) {\n                            this.defines.USE_GLOSSINESSMAP = '';\n                            this.defines.USE_ROUGHNESSMAP = '';\n                        } else {\n                            delete this.defines.USE_ROUGHNESSMAP;\n                            delete this.defines.USE_GLOSSINESSMAP;\n                        }\n                    }\n                }\n            });\n            delete this.metalness;\n            delete this.roughness;\n            delete this.metalnessMap;\n            delete this.roughnessMap;\n            this.setValues(params);\n        }\n        GLTFMeshStandardSGMaterial.prototype = Object.create(THREE.MeshStandardMaterial.prototype);\n        GLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;\n        GLTFMeshStandardSGMaterial.prototype.copy = function (source) {\n            THREE.MeshStandardMaterial.prototype.copy.call(this, source);\n            this.specularMap = source.specularMap;\n            this.specular.copy(source.specular);\n            this.glossinessMap = source.glossinessMap;\n            this.glossiness = source.glossiness;\n            delete this.metalness;\n            delete this.roughness;\n            delete this.metalnessMap;\n            delete this.roughnessMap;\n            return this;\n        };\n        function GLTFMaterialsPbrSpecularGlossinessExtension() {\n            return {\n                name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n                specularGlossinessParams: [\n                    'color',\n                    'map',\n                    'lightMap',\n                    'lightMapIntensity',\n                    'aoMap',\n                    'aoMapIntensity',\n                    'emissive',\n                    'emissiveIntensity',\n                    'emissiveMap',\n                    'bumpMap',\n                    'bumpScale',\n                    'normalMap',\n                    'normalMapType',\n                    'displacementMap',\n                    'displacementScale',\n                    'displacementBias',\n                    'specularMap',\n                    'specular',\n                    'glossinessMap',\n                    'glossiness',\n                    'alphaMap',\n                    'envMap',\n                    'envMapIntensity',\n                    'refractionRatio'\n                ],\n                getMaterialType: function () {\n                    return GLTFMeshStandardSGMaterial;\n                },\n                extendParams: function (materialParams, materialDef, parser) {\n                    var pbrSpecularGlossiness = materialDef.extensions[this.name];\n                    materialParams.color = new THREE.Color(1, 1, 1);\n                    materialParams.opacity = 1;\n                    var pending = [];\n                    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n                        var array = pbrSpecularGlossiness.diffuseFactor;\n                        materialParams.color.fromArray(array);\n                        materialParams.opacity = array[3];\n                    }\n                    if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n                        pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));\n                    }\n                    materialParams.emissive = new THREE.Color(0, 0, 0);\n                    materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1;\n                    materialParams.specular = new THREE.Color(1, 1, 1);\n                    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n                        materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n                    }\n                    if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n                        var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n                        pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));\n                        pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));\n                    }\n                    return Promise.all(pending);\n                },\n                createMaterial: function (materialParams) {\n                    var material = new GLTFMeshStandardSGMaterial(materialParams);\n                    material.fog = true;\n                    material.color = materialParams.color;\n                    material.map = materialParams.map === undefined ? null : materialParams.map;\n                    material.lightMap = null;\n                    material.lightMapIntensity = 1;\n                    material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;\n                    material.aoMapIntensity = 1;\n                    material.emissive = materialParams.emissive;\n                    material.emissiveIntensity = 1;\n                    material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;\n                    material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\n                    material.bumpScale = 1;\n                    material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;\n                    material.normalMapType = THREE.TangentSpaceNormalMap;\n                    if (materialParams.normalScale)\n                        material.normalScale = materialParams.normalScale;\n                    material.displacementMap = null;\n                    material.displacementScale = 1;\n                    material.displacementBias = 0;\n                    material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;\n                    material.specular = materialParams.specular;\n                    material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;\n                    material.glossiness = materialParams.glossiness;\n                    material.alphaMap = null;\n                    material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;\n                    material.envMapIntensity = 1;\n                    material.refractionRatio = 0.98;\n                    return material;\n                }\n            };\n        }\n        function GLTFMeshQuantizationExtension() {\n            this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n        }\n        function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n            THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n        }\n        GLTFCubicSplineInterpolant.prototype = Object.create(THREE.Interpolant.prototype);\n        GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n        GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function (index) {\n            var result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n            for (var i = 0; i !== valueSize; i++) {\n                result[i] = values[offset + i];\n            }\n            return result;\n        };\n        GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n        GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n        GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n            var result = this.resultBuffer;\n            var values = this.sampleValues;\n            var stride = this.valueSize;\n            var stride2 = stride * 2;\n            var stride3 = stride * 3;\n            var td = t1 - t0;\n            var p = (t - t0) / td;\n            var pp = p * p;\n            var ppp = pp * p;\n            var offset1 = i1 * stride3;\n            var offset0 = offset1 - stride3;\n            var s2 = -2 * ppp + 3 * pp;\n            var s3 = ppp - pp;\n            var s0 = 1 - s2;\n            var s1 = s3 - pp + p;\n            for (var i = 0; i !== stride; i++) {\n                var p0 = values[offset0 + i + stride];\n                var m0 = values[offset0 + i + stride2] * td;\n                var p1 = values[offset1 + i + stride];\n                var m1 = values[offset1 + i] * td;\n                result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n            }\n            return result;\n        };\n        var WEBGL_CONSTANTS = {\n            FLOAT: 5126,\n            FLOAT_MAT3: 35675,\n            FLOAT_MAT4: 35676,\n            FLOAT_VEC2: 35664,\n            FLOAT_VEC3: 35665,\n            FLOAT_VEC4: 35666,\n            LINEAR: 9729,\n            REPEAT: 10497,\n            SAMPLER_2D: 35678,\n            POINTS: 0,\n            LINES: 1,\n            LINE_LOOP: 2,\n            LINE_STRIP: 3,\n            TRIANGLES: 4,\n            TRIANGLE_STRIP: 5,\n            TRIANGLE_FAN: 6,\n            UNSIGNED_BYTE: 5121,\n            UNSIGNED_SHORT: 5123\n        };\n        var WEBGL_COMPONENT_TYPES = {\n            5120: Int8Array,\n            5121: Uint8Array,\n            5122: Int16Array,\n            5123: Uint16Array,\n            5125: Uint32Array,\n            5126: Float32Array\n        };\n        var WEBGL_FILTERS = {\n            9728: THREE.NearestFilter,\n            9729: THREE.LinearFilter,\n            9984: THREE.NearestMipmapNearestFilter,\n            9985: THREE.LinearMipmapNearestFilter,\n            9986: THREE.NearestMipmapLinearFilter,\n            9987: THREE.LinearMipmapLinearFilter\n        };\n        var WEBGL_WRAPPINGS = {\n            33071: THREE.ClampToEdgeWrapping,\n            33648: THREE.MirroredRepeatWrapping,\n            10497: THREE.RepeatWrapping\n        };\n        var WEBGL_TYPE_SIZES = {\n            'SCALAR': 1,\n            'VEC2': 2,\n            'VEC3': 3,\n            'VEC4': 4,\n            'MAT2': 4,\n            'MAT3': 9,\n            'MAT4': 16\n        };\n        var ATTRIBUTES = {\n            POSITION: 'position',\n            NORMAL: 'normal',\n            TANGENT: 'tangent',\n            TEXCOORD_0: 'uv',\n            TEXCOORD_1: 'uv2',\n            COLOR_0: 'color',\n            WEIGHTS_0: 'skinWeight',\n            JOINTS_0: 'skinIndex'\n        };\n        var PATH_PROPERTIES = {\n            scale: 'scale',\n            translation: 'position',\n            rotation: 'quaternion',\n            weights: 'morphTargetInfluences'\n        };\n        var INTERPOLATION = {\n            CUBICSPLINE: undefined,\n            LINEAR: THREE.InterpolateLinear,\n            STEP: THREE.InterpolateDiscrete\n        };\n        var ALPHA_MODES = {\n            OPAQUE: 'OPAQUE',\n            MASK: 'MASK',\n            BLEND: 'BLEND'\n        };\n        var MIME_TYPE_FORMATS = {\n            'image/png': THREE.RGBAFormat,\n            'image/jpeg': THREE.RGBFormat\n        };\n        function resolveURL(url, path) {\n            if (typeof url !== 'string' || url === '')\n                return '';\n            if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n                path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n            }\n            if (/^(https?:)?\\/\\//i.test(url))\n                return url;\n            if (/^data:.*,.*$/i.test(url))\n                return url;\n            if (/^blob:.*$/i.test(url))\n                return url;\n            return path + url;\n        }\n        function createDefaultMaterial(cache) {\n            if (cache['DefaultMaterial'] === undefined) {\n                cache['DefaultMaterial'] = new THREE.MeshStandardMaterial({\n                    color: 16777215,\n                    emissive: 0,\n                    metalness: 1,\n                    roughness: 1,\n                    transparent: false,\n                    depthTest: true,\n                    side: THREE.FrontSide\n                });\n            }\n            return cache['DefaultMaterial'];\n        }\n        function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n            for (var name in objectDef.extensions) {\n                if (knownExtensions[name] === undefined) {\n                    object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n                    object.userData.gltfExtensions[name] = objectDef.extensions[name];\n                }\n            }\n        }\n        function assignExtrasToUserData(object, gltfDef) {\n            if (gltfDef.extras !== undefined) {\n                if (typeof gltfDef.extras === 'object') {\n                    Object.assign(object.userData, gltfDef.extras);\n                } else {\n                    console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\n                }\n            }\n        }\n        function addMorphTargets(geometry, targets, parser) {\n            var hasMorphPosition = false;\n            var hasMorphNormal = false;\n            for (var i = 0, il = targets.length; i < il; i++) {\n                var target = targets[i];\n                if (target.POSITION !== undefined)\n                    hasMorphPosition = true;\n                if (target.NORMAL !== undefined)\n                    hasMorphNormal = true;\n                if (hasMorphPosition && hasMorphNormal)\n                    break;\n            }\n            if (!hasMorphPosition && !hasMorphNormal)\n                return Promise.resolve(geometry);\n            var pendingPositionAccessors = [];\n            var pendingNormalAccessors = [];\n            for (var i = 0, il = targets.length; i < il; i++) {\n                var target = targets[i];\n                if (hasMorphPosition) {\n                    var pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;\n                    pendingPositionAccessors.push(pendingAccessor);\n                }\n                if (hasMorphNormal) {\n                    var pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;\n                    pendingNormalAccessors.push(pendingAccessor);\n                }\n            }\n            return Promise.all([\n                Promise.all(pendingPositionAccessors),\n                Promise.all(pendingNormalAccessors)\n            ]).then(function (accessors) {\n                var morphPositions = accessors[0];\n                var morphNormals = accessors[1];\n                if (hasMorphPosition)\n                    geometry.morphAttributes.position = morphPositions;\n                if (hasMorphNormal)\n                    geometry.morphAttributes.normal = morphNormals;\n                geometry.morphTargetsRelative = true;\n                return geometry;\n            });\n        }\n        function updateMorphTargets(mesh, meshDef) {\n            mesh.updateMorphTargets();\n            if (meshDef.weights !== undefined) {\n                for (var i = 0, il = meshDef.weights.length; i < il; i++) {\n                    mesh.morphTargetInfluences[i] = meshDef.weights[i];\n                }\n            }\n            if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n                var targetNames = meshDef.extras.targetNames;\n                if (mesh.morphTargetInfluences.length === targetNames.length) {\n                    mesh.morphTargetDictionary = {};\n                    for (var i = 0, il = targetNames.length; i < il; i++) {\n                        mesh.morphTargetDictionary[targetNames[i]] = i;\n                    }\n                } else {\n                    console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n                }\n            }\n        }\n        function createPrimitiveKey(primitiveDef) {\n            var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n            var geometryKey;\n            if (dracoExtension) {\n                geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);\n            } else {\n                geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\n            }\n            return geometryKey;\n        }\n        function createAttributesKey(attributes) {\n            var attributesKey = '';\n            var keys = Object.keys(attributes).sort();\n            for (var i = 0, il = keys.length; i < il; i++) {\n                attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\n            }\n            return attributesKey;\n        }\n        function GLTFParser(json, extensions, options) {\n            this.json = json || {};\n            this.extensions = extensions || {};\n            this.options = options || {};\n            this.cache = new GLTFRegistry();\n            this.primitiveCache = {};\n            this.textureLoader = new THREE.TextureLoader(this.options.manager);\n            this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n            this.fileLoader = new THREE.FileLoader(this.options.manager);\n            this.fileLoader.setResponseType('arraybuffer');\n            if (this.options.crossOrigin === 'use-credentials') {\n                this.fileLoader.setWithCredentials(true);\n            }\n        }\n        GLTFParser.prototype.parse = function (onLoad, onError) {\n            var parser = this;\n            var json = this.json;\n            var extensions = this.extensions;\n            this.cache.removeAll();\n            this.markDefs();\n            Promise.all([\n                this.getDependencies('scene'),\n                this.getDependencies('animation'),\n                this.getDependencies('camera')\n            ]).then(function (dependencies) {\n                var result = {\n                    scene: dependencies[0][json.scene || 0],\n                    scenes: dependencies[0],\n                    animations: dependencies[1],\n                    cameras: dependencies[2],\n                    asset: json.asset,\n                    parser: parser,\n                    userData: {}\n                };\n                addUnknownExtensionsToUserData(extensions, result, json);\n                assignExtrasToUserData(result, json);\n                onLoad(result);\n            }).catch(onError);\n        };\n        GLTFParser.prototype.markDefs = function () {\n            var nodeDefs = this.json.nodes || [];\n            var skinDefs = this.json.skins || [];\n            var meshDefs = this.json.meshes || [];\n            var meshReferences = {};\n            var meshUses = {};\n            for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n                var joints = skinDefs[skinIndex].joints;\n                for (var i = 0, il = joints.length; i < il; i++) {\n                    nodeDefs[joints[i]].isBone = true;\n                }\n            }\n            for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n                var nodeDef = nodeDefs[nodeIndex];\n                if (nodeDef.mesh !== undefined) {\n                    if (meshReferences[nodeDef.mesh] === undefined) {\n                        meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;\n                    }\n                    meshReferences[nodeDef.mesh]++;\n                    if (nodeDef.skin !== undefined) {\n                        meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n                    }\n                }\n            }\n            this.json.meshReferences = meshReferences;\n            this.json.meshUses = meshUses;\n        };\n        GLTFParser.prototype.getDependency = function (type, index) {\n            var cacheKey = type + ':' + index;\n            var dependency = this.cache.get(cacheKey);\n            if (!dependency) {\n                switch (type) {\n                case 'scene':\n                    dependency = this.loadScene(index);\n                    break;\n                case 'node':\n                    dependency = this.loadNode(index);\n                    break;\n                case 'mesh':\n                    dependency = this.loadMesh(index);\n                    break;\n                case 'accessor':\n                    dependency = this.loadAccessor(index);\n                    break;\n                case 'bufferView':\n                    dependency = this.loadBufferView(index);\n                    break;\n                case 'buffer':\n                    dependency = this.loadBuffer(index);\n                    break;\n                case 'material':\n                    dependency = this.loadMaterial(index);\n                    break;\n                case 'texture':\n                    dependency = this.loadTexture(index);\n                    break;\n                case 'skin':\n                    dependency = this.loadSkin(index);\n                    break;\n                case 'animation':\n                    dependency = this.loadAnimation(index);\n                    break;\n                case 'camera':\n                    dependency = this.loadCamera(index);\n                    break;\n                case 'light':\n                    dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);\n                    break;\n                default:\n                    throw new Error('Unknown type: ' + type);\n                }\n                this.cache.add(cacheKey, dependency);\n            }\n            return dependency;\n        };\n        GLTFParser.prototype.getDependencies = function (type) {\n            var dependencies = this.cache.get(type);\n            if (!dependencies) {\n                var parser = this;\n                var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n                dependencies = Promise.all(defs.map(function (def, index) {\n                    return parser.getDependency(type, index);\n                }));\n                this.cache.add(type, dependencies);\n            }\n            return dependencies;\n        };\n        GLTFParser.prototype.loadBuffer = function (bufferIndex) {\n            var bufferDef = this.json.buffers[bufferIndex];\n            var loader = this.fileLoader;\n            if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n                throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n            }\n            if (bufferDef.uri === undefined && bufferIndex === 0) {\n                return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n            }\n            var options = this.options;\n            return new Promise(function (resolve, reject) {\n                loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n                    reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n                });\n            });\n        };\n        GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {\n            var bufferViewDef = this.json.bufferViews[bufferViewIndex];\n            return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n                var byteLength = bufferViewDef.byteLength || 0;\n                var byteOffset = bufferViewDef.byteOffset || 0;\n                return buffer.slice(byteOffset, byteOffset + byteLength);\n            });\n        };\n        GLTFParser.prototype.loadAccessor = function (accessorIndex) {\n            var parser = this;\n            var json = this.json;\n            var accessorDef = this.json.accessors[accessorIndex];\n            if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n                return Promise.resolve(null);\n            }\n            var pendingBufferViews = [];\n            if (accessorDef.bufferView !== undefined) {\n                pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n            } else {\n                pendingBufferViews.push(null);\n            }\n            if (accessorDef.sparse !== undefined) {\n                pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n                pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n            }\n            return Promise.all(pendingBufferViews).then(function (bufferViews) {\n                var bufferView = bufferViews[0];\n                var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n                var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n                var elementBytes = TypedArray.BYTES_PER_ELEMENT;\n                var itemBytes = elementBytes * itemSize;\n                var byteOffset = accessorDef.byteOffset || 0;\n                var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\n                var normalized = accessorDef.normalized === true;\n                var array, bufferAttribute;\n                if (byteStride && byteStride !== itemBytes) {\n                    var ibSlice = Math.floor(byteOffset / byteStride);\n                    var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n                    var ib = parser.cache.get(ibCacheKey);\n                    if (!ib) {\n                        array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n                        ib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);\n                        parser.cache.add(ibCacheKey, ib);\n                    }\n                    bufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n                } else {\n                    if (bufferView === null) {\n                        array = new TypedArray(accessorDef.count * itemSize);\n                    } else {\n                        array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n                    }\n                    bufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);\n                }\n                if (accessorDef.sparse !== undefined) {\n                    var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n                    var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n                    var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n                    var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n                    var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n                    var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n                    if (bufferView !== null) {\n                        bufferAttribute = new THREE.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n                    }\n                    for (var i = 0, il = sparseIndices.length; i < il; i++) {\n                        var index = sparseIndices[i];\n                        bufferAttribute.setX(index, sparseValues[i * itemSize]);\n                        if (itemSize >= 2)\n                            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n                        if (itemSize >= 3)\n                            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n                        if (itemSize >= 4)\n                            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n                        if (itemSize >= 5)\n                            throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n                    }\n                }\n                return bufferAttribute;\n            });\n        };\n        GLTFParser.prototype.loadTexture = function (textureIndex) {\n            var parser = this;\n            var json = this.json;\n            var options = this.options;\n            var textureLoader = this.textureLoader;\n            var URL = self.URL || self.webkitURL;\n            var textureDef = json.textures[textureIndex];\n            var textureExtensions = textureDef.extensions || {};\n            var source;\n            if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {\n                source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];\n            } else {\n                source = json.images[textureDef.source];\n            }\n            var sourceURI = source.uri;\n            var isObjectURL = false;\n            if (source.bufferView !== undefined) {\n                sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n                    isObjectURL = true;\n                    var blob = new Blob([bufferView], { type: source.mimeType });\n                    sourceURI = URL.createObjectURL(blob);\n                    return sourceURI;\n                });\n            }\n            return Promise.resolve(sourceURI).then(function (sourceURI) {\n                var loader = options.manager.getHandler(sourceURI);\n                if (!loader) {\n                    loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;\n                }\n                return new Promise(function (resolve, reject) {\n                    loader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);\n                });\n            }).then(function (texture) {\n                if (isObjectURL === true) {\n                    URL.revokeObjectURL(sourceURI);\n                }\n                texture.flipY = false;\n                if (textureDef.name)\n                    texture.name = textureDef.name;\n                if (source.mimeType in MIME_TYPE_FORMATS) {\n                    texture.format = MIME_TYPE_FORMATS[source.mimeType];\n                }\n                var samplers = json.samplers || {};\n                var sampler = samplers[textureDef.sampler] || {};\n                texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;\n                texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipmapLinearFilter;\n                texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;\n                texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;\n                return texture;\n            });\n        };\n        GLTFParser.prototype.assignTexture = function (materialParams, mapName, mapDef) {\n            var parser = this;\n            return this.getDependency('texture', mapDef.index).then(function (texture) {\n                if (!texture.isCompressedTexture) {\n                    switch (mapName) {\n                    case 'aoMap':\n                    case 'emissiveMap':\n                    case 'metalnessMap':\n                    case 'normalMap':\n                    case 'roughnessMap':\n                        texture.format = THREE.RGBFormat;\n                        break;\n                    }\n                }\n                if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {\n                    console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');\n                }\n                if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n                    var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\n                    if (transform) {\n                        texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n                    }\n                }\n                materialParams[mapName] = texture;\n            });\n        };\n        GLTFParser.prototype.assignFinalMaterial = function (mesh) {\n            var geometry = mesh.geometry;\n            var material = mesh.material;\n            var useVertexTangents = geometry.attributes.tangent !== undefined;\n            var useVertexColors = geometry.attributes.color !== undefined;\n            var useFlatShading = geometry.attributes.normal === undefined;\n            var useSkinning = mesh.isSkinnedMesh === true;\n            var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;\n            var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n            if (mesh.isPoints) {\n                var cacheKey = 'PointsMaterial:' + material.uuid;\n                var pointsMaterial = this.cache.get(cacheKey);\n                if (!pointsMaterial) {\n                    pointsMaterial = new THREE.PointsMaterial();\n                    THREE.Material.prototype.copy.call(pointsMaterial, material);\n                    pointsMaterial.color.copy(material.color);\n                    pointsMaterial.map = material.map;\n                    pointsMaterial.sizeAttenuation = false;\n                    this.cache.add(cacheKey, pointsMaterial);\n                }\n                material = pointsMaterial;\n            } else if (mesh.isLine) {\n                var cacheKey = 'LineBasicMaterial:' + material.uuid;\n                var lineMaterial = this.cache.get(cacheKey);\n                if (!lineMaterial) {\n                    lineMaterial = new THREE.LineBasicMaterial();\n                    THREE.Material.prototype.copy.call(lineMaterial, material);\n                    lineMaterial.color.copy(material.color);\n                    this.cache.add(cacheKey, lineMaterial);\n                }\n                material = lineMaterial;\n            }\n            if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {\n                var cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n                if (material.isGLTFSpecularGlossinessMaterial)\n                    cacheKey += 'specular-glossiness:';\n                if (useSkinning)\n                    cacheKey += 'skinning:';\n                if (useVertexTangents)\n                    cacheKey += 'vertex-tangents:';\n                if (useVertexColors)\n                    cacheKey += 'vertex-colors:';\n                if (useFlatShading)\n                    cacheKey += 'flat-shading:';\n                if (useMorphTargets)\n                    cacheKey += 'morph-targets:';\n                if (useMorphNormals)\n                    cacheKey += 'morph-normals:';\n                var cachedMaterial = this.cache.get(cacheKey);\n                if (!cachedMaterial) {\n                    cachedMaterial = material.clone();\n                    if (useSkinning)\n                        cachedMaterial.skinning = true;\n                    if (useVertexTangents)\n                        cachedMaterial.vertexTangents = true;\n                    if (useVertexColors)\n                        cachedMaterial.vertexColors = true;\n                    if (useFlatShading)\n                        cachedMaterial.flatShading = true;\n                    if (useMorphTargets)\n                        cachedMaterial.morphTargets = true;\n                    if (useMorphNormals)\n                        cachedMaterial.morphNormals = true;\n                    this.cache.add(cacheKey, cachedMaterial);\n                }\n                material = cachedMaterial;\n            }\n            if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n                geometry.setAttribute('uv2', new THREE.BufferAttribute(geometry.attributes.uv.array, 2));\n            }\n            if (material.normalScale && !useVertexTangents) {\n                material.normalScale.y = -material.normalScale.y;\n            }\n            if (material.clearcoatNormalScale && !useVertexTangents) {\n                material.clearcoatNormalScale.y = -material.clearcoatNormalScale.y;\n            }\n            mesh.material = material;\n        };\n        GLTFParser.prototype.loadMaterial = function (materialIndex) {\n            var parser = this;\n            var json = this.json;\n            var extensions = this.extensions;\n            var materialDef = json.materials[materialIndex];\n            var materialType;\n            var materialParams = {};\n            var materialExtensions = materialDef.extensions || {};\n            var pending = [];\n            if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n                var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n                materialType = sgExtension.getMaterialType();\n                pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n            } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n                var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n                materialType = kmuExtension.getMaterialType();\n                pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n            } else {\n                materialType = THREE.MeshStandardMaterial;\n                var metallicRoughness = materialDef.pbrMetallicRoughness || {};\n                materialParams.color = new THREE.Color(1, 1, 1);\n                materialParams.opacity = 1;\n                if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                    var array = metallicRoughness.baseColorFactor;\n                    materialParams.color.fromArray(array);\n                    materialParams.opacity = array[3];\n                }\n                if (metallicRoughness.baseColorTexture !== undefined) {\n                    pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n                }\n                materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1;\n                materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1;\n                if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n                    pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\n                    pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\n                }\n            }\n            if (materialDef.doubleSided === true) {\n                materialParams.side = THREE.DoubleSide;\n            }\n            var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n            if (alphaMode === ALPHA_MODES.BLEND) {\n                materialParams.transparent = true;\n                materialParams.depthWrite = false;\n            } else {\n                materialParams.transparent = false;\n                if (alphaMode === ALPHA_MODES.MASK) {\n                    materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n                }\n            }\n            if (materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n                pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));\n                materialParams.normalScale = new THREE.Vector2(1, 1);\n                if (materialDef.normalTexture.scale !== undefined) {\n                    materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);\n                }\n            }\n            if (materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n                pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\n                if (materialDef.occlusionTexture.strength !== undefined) {\n                    materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n                }\n            }\n            if (materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) {\n                materialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);\n            }\n            if (materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n                pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));\n            }\n            if (materialExtensions[EXTENSIONS.KHR_MATERIALS_CLEARCOAT]) {\n                var clearcoatExtension = extensions[EXTENSIONS.KHR_MATERIALS_CLEARCOAT];\n                materialType = clearcoatExtension.getMaterialType();\n                pending.push(clearcoatExtension.extendParams(materialParams, { extensions: materialExtensions }, parser));\n            }\n            return Promise.all(pending).then(function () {\n                var material;\n                if (materialType === GLTFMeshStandardSGMaterial) {\n                    material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n                } else {\n                    material = new materialType(materialParams);\n                }\n                if (materialDef.name)\n                    material.name = materialDef.name;\n                if (material.map)\n                    material.map.encoding = THREE.sRGBEncoding;\n                if (material.emissiveMap)\n                    material.emissiveMap.encoding = THREE.sRGBEncoding;\n                assignExtrasToUserData(material, materialDef);\n                if (materialDef.extensions)\n                    addUnknownExtensionsToUserData(extensions, material, materialDef);\n                return material;\n            });\n        };\n        function computeBounds(geometry, primitiveDef, parser) {\n            var attributes = primitiveDef.attributes;\n            var box = new THREE.Box3();\n            if (attributes.POSITION !== undefined) {\n                var accessor = parser.json.accessors[attributes.POSITION];\n                var min = accessor.min;\n                var max = accessor.max;\n                if (min !== undefined && max !== undefined) {\n                    box.set(new THREE.Vector3(min[0], min[1], min[2]), new THREE.Vector3(max[0], max[1], max[2]));\n                } else {\n                    console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n                    return;\n                }\n            } else {\n                return;\n            }\n            var targets = primitiveDef.targets;\n            if (targets !== undefined) {\n                var maxDisplacement = new THREE.Vector3();\n                var vector = new THREE.Vector3();\n                for (var i = 0, il = targets.length; i < il; i++) {\n                    var target = targets[i];\n                    if (target.POSITION !== undefined) {\n                        var accessor = parser.json.accessors[target.POSITION];\n                        var min = accessor.min;\n                        var max = accessor.max;\n                        if (min !== undefined && max !== undefined) {\n                            vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n                            vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n                            vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n                            maxDisplacement.max(vector);\n                        } else {\n                            console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n                        }\n                    }\n                }\n                box.expandByVector(maxDisplacement);\n            }\n            geometry.boundingBox = box;\n            var sphere = new THREE.Sphere();\n            box.getCenter(sphere.center);\n            sphere.radius = box.min.distanceTo(box.max) / 2;\n            geometry.boundingSphere = sphere;\n        }\n        function addPrimitiveAttributes(geometry, primitiveDef, parser) {\n            var attributes = primitiveDef.attributes;\n            var pending = [];\n            function assignAttributeAccessor(accessorIndex, attributeName) {\n                return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n                    geometry.setAttribute(attributeName, accessor);\n                });\n            }\n            for (var gltfAttributeName in attributes) {\n                var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n                if (threeAttributeName in geometry.attributes)\n                    continue;\n                pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n            }\n            if (primitiveDef.indices !== undefined && !geometry.index) {\n                var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n                    geometry.setIndex(accessor);\n                });\n                pending.push(accessor);\n            }\n            assignExtrasToUserData(geometry, primitiveDef);\n            computeBounds(geometry, primitiveDef, parser);\n            return Promise.all(pending).then(function () {\n                return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n            });\n        }\n        function toTrianglesDrawMode(geometry, drawMode) {\n            var index = geometry.getIndex();\n            if (index === null) {\n                var indices = [];\n                var position = geometry.getAttribute('position');\n                if (position !== undefined) {\n                    for (var i = 0; i < position.count; i++) {\n                        indices.push(i);\n                    }\n                    geometry.setIndex(indices);\n                    index = geometry.getIndex();\n                } else {\n                    console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n                    return geometry;\n                }\n            }\n            var numberOfTriangles = index.count - 2;\n            var newIndices = [];\n            if (drawMode === THREE.TriangleFanDrawMode) {\n                for (var i = 1; i <= numberOfTriangles; i++) {\n                    newIndices.push(index.getX(0));\n                    newIndices.push(index.getX(i));\n                    newIndices.push(index.getX(i + 1));\n                }\n            } else {\n                for (var i = 0; i < numberOfTriangles; i++) {\n                    if (i % 2 === 0) {\n                        newIndices.push(index.getX(i));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i + 2));\n                    } else {\n                        newIndices.push(index.getX(i + 2));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i));\n                    }\n                }\n            }\n            if (newIndices.length / 3 !== numberOfTriangles) {\n                console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n            }\n            var newGeometry = geometry.clone();\n            newGeometry.setIndex(newIndices);\n            return newGeometry;\n        }\n        GLTFParser.prototype.loadGeometries = function (primitives) {\n            var parser = this;\n            var extensions = this.extensions;\n            var cache = this.primitiveCache;\n            function createDracoPrimitive(primitive) {\n                return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\n                    return addPrimitiveAttributes(geometry, primitive, parser);\n                });\n            }\n            var pending = [];\n            for (var i = 0, il = primitives.length; i < il; i++) {\n                var primitive = primitives[i];\n                var cacheKey = createPrimitiveKey(primitive);\n                var cached = cache[cacheKey];\n                if (cached) {\n                    pending.push(cached.promise);\n                } else {\n                    var geometryPromise;\n                    if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n                        geometryPromise = createDracoPrimitive(primitive);\n                    } else {\n                        geometryPromise = addPrimitiveAttributes(new THREE.BufferGeometry(), primitive, parser);\n                    }\n                    cache[cacheKey] = {\n                        primitive: primitive,\n                        promise: geometryPromise\n                    };\n                    pending.push(geometryPromise);\n                }\n            }\n            return Promise.all(pending);\n        };\n        GLTFParser.prototype.loadMesh = function (meshIndex) {\n            var parser = this;\n            var json = this.json;\n            var meshDef = json.meshes[meshIndex];\n            var primitives = meshDef.primitives;\n            var pending = [];\n            for (var i = 0, il = primitives.length; i < il; i++) {\n                var material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);\n                pending.push(material);\n            }\n            pending.push(parser.loadGeometries(primitives));\n            return Promise.all(pending).then(function (results) {\n                var materials = results.slice(0, results.length - 1);\n                var geometries = results[results.length - 1];\n                var meshes = [];\n                for (var i = 0, il = geometries.length; i < il; i++) {\n                    var geometry = geometries[i];\n                    var primitive = primitives[i];\n                    var mesh;\n                    var material = materials[i];\n                    if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n                        mesh = meshDef.isSkinnedMesh === true ? new THREE.SkinnedMesh(geometry, material) : new THREE.Mesh(geometry, material);\n                        if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\n                            mesh.normalizeSkinWeights();\n                        }\n                        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n                            mesh.geometry = toTrianglesDrawMode(mesh.geometry, THREE.TriangleStripDrawMode);\n                        } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n                            mesh.geometry = toTrianglesDrawMode(mesh.geometry, THREE.TriangleFanDrawMode);\n                        }\n                    } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n                        mesh = new THREE.LineSegments(geometry, material);\n                    } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n                        mesh = new THREE.Line(geometry, material);\n                    } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n                        mesh = new THREE.LineLoop(geometry, material);\n                    } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n                        mesh = new THREE.Points(geometry, material);\n                    } else {\n                        throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n                    }\n                    if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n                        updateMorphTargets(mesh, meshDef);\n                    }\n                    mesh.name = meshDef.name || 'mesh_' + meshIndex;\n                    if (geometries.length > 1)\n                        mesh.name += '_' + i;\n                    assignExtrasToUserData(mesh, meshDef);\n                    parser.assignFinalMaterial(mesh);\n                    meshes.push(mesh);\n                }\n                if (meshes.length === 1) {\n                    return meshes[0];\n                }\n                var group = new THREE.Group();\n                for (var i = 0, il = meshes.length; i < il; i++) {\n                    group.add(meshes[i]);\n                }\n                return group;\n            });\n        };\n        GLTFParser.prototype.loadCamera = function (cameraIndex) {\n            var camera;\n            var cameraDef = this.json.cameras[cameraIndex];\n            var params = cameraDef[cameraDef.type];\n            if (!params) {\n                console.warn('THREE.GLTFLoader: Missing camera parameters.');\n                return;\n            }\n            if (cameraDef.type === 'perspective') {\n                camera = new THREE.PerspectiveCamera(THREE.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2000000);\n            } else if (cameraDef.type === 'orthographic') {\n                camera = new THREE.OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);\n            }\n            if (cameraDef.name)\n                camera.name = cameraDef.name;\n            assignExtrasToUserData(camera, cameraDef);\n            return Promise.resolve(camera);\n        };\n        GLTFParser.prototype.loadSkin = function (skinIndex) {\n            var skinDef = this.json.skins[skinIndex];\n            var skinEntry = { joints: skinDef.joints };\n            if (skinDef.inverseBindMatrices === undefined) {\n                return Promise.resolve(skinEntry);\n            }\n            return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n                skinEntry.inverseBindMatrices = accessor;\n                return skinEntry;\n            });\n        };\n        GLTFParser.prototype.loadAnimation = function (animationIndex) {\n            var json = this.json;\n            var animationDef = json.animations[animationIndex];\n            var pendingNodes = [];\n            var pendingInputAccessors = [];\n            var pendingOutputAccessors = [];\n            var pendingSamplers = [];\n            var pendingTargets = [];\n            for (var i = 0, il = animationDef.channels.length; i < il; i++) {\n                var channel = animationDef.channels[i];\n                var sampler = animationDef.samplers[channel.sampler];\n                var target = channel.target;\n                var name = target.node !== undefined ? target.node : target.id;\n                var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n                var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n                pendingNodes.push(this.getDependency('node', name));\n                pendingInputAccessors.push(this.getDependency('accessor', input));\n                pendingOutputAccessors.push(this.getDependency('accessor', output));\n                pendingSamplers.push(sampler);\n                pendingTargets.push(target);\n            }\n            return Promise.all([\n                Promise.all(pendingNodes),\n                Promise.all(pendingInputAccessors),\n                Promise.all(pendingOutputAccessors),\n                Promise.all(pendingSamplers),\n                Promise.all(pendingTargets)\n            ]).then(function (dependencies) {\n                var nodes = dependencies[0];\n                var inputAccessors = dependencies[1];\n                var outputAccessors = dependencies[2];\n                var samplers = dependencies[3];\n                var targets = dependencies[4];\n                var tracks = [];\n                for (var i = 0, il = nodes.length; i < il; i++) {\n                    var node = nodes[i];\n                    var inputAccessor = inputAccessors[i];\n                    var outputAccessor = outputAccessors[i];\n                    var sampler = samplers[i];\n                    var target = targets[i];\n                    if (node === undefined)\n                        continue;\n                    node.updateMatrix();\n                    node.matrixAutoUpdate = true;\n                    var TypedKeyframeTrack;\n                    switch (PATH_PROPERTIES[target.path]) {\n                    case PATH_PROPERTIES.weights:\n                        TypedKeyframeTrack = THREE.NumberKeyframeTrack;\n                        break;\n                    case PATH_PROPERTIES.rotation:\n                        TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\n                        break;\n                    case PATH_PROPERTIES.position:\n                    case PATH_PROPERTIES.scale:\n                    default:\n                        TypedKeyframeTrack = THREE.VectorKeyframeTrack;\n                        break;\n                    }\n                    var targetName = node.name ? node.name : node.uuid;\n                    var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;\n                    var targetNames = [];\n                    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n                        node.traverse(function (object) {\n                            if (object.isMesh === true && object.morphTargetInfluences) {\n                                targetNames.push(object.name ? object.name : object.uuid);\n                            }\n                        });\n                    } else {\n                        targetNames.push(targetName);\n                    }\n                    var outputArray = outputAccessor.array;\n                    if (outputAccessor.normalized) {\n                        var scale;\n                        if (outputArray.constructor === Int8Array) {\n                            scale = 1 / 127;\n                        } else if (outputArray.constructor === Uint8Array) {\n                            scale = 1 / 255;\n                        } else if (outputArray.constructor == Int16Array) {\n                            scale = 1 / 32767;\n                        } else if (outputArray.constructor === Uint16Array) {\n                            scale = 1 / 65535;\n                        } else {\n                            throw new Error('THREE.GLTFLoader: Unsupported output accessor component type.');\n                        }\n                        var scaled = new Float32Array(outputArray.length);\n                        for (var j = 0, jl = outputArray.length; j < jl; j++) {\n                            scaled[j] = outputArray[j] * scale;\n                        }\n                        outputArray = scaled;\n                    }\n                    for (var j = 0, jl = targetNames.length; j < jl; j++) {\n                        var track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);\n                        if (sampler.interpolation === 'CUBICSPLINE') {\n                            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n                                return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n                            };\n                            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n                        }\n                        tracks.push(track);\n                    }\n                }\n                var name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n                return new THREE.AnimationClip(name, undefined, tracks);\n            });\n        };\n        GLTFParser.prototype.loadNode = function (nodeIndex) {\n            var json = this.json;\n            var extensions = this.extensions;\n            var parser = this;\n            var meshReferences = json.meshReferences;\n            var meshUses = json.meshUses;\n            var nodeDef = json.nodes[nodeIndex];\n            return function () {\n                var pending = [];\n                if (nodeDef.mesh !== undefined) {\n                    pending.push(parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n                        var node;\n                        if (meshReferences[nodeDef.mesh] > 1) {\n                            var instanceNum = meshUses[nodeDef.mesh]++;\n                            node = mesh.clone();\n                            node.name += '_instance_' + instanceNum;\n                        } else {\n                            node = mesh;\n                        }\n                        if (nodeDef.weights !== undefined) {\n                            node.traverse(function (o) {\n                                if (!o.isMesh)\n                                    return;\n                                for (var i = 0, il = nodeDef.weights.length; i < il; i++) {\n                                    o.morphTargetInfluences[i] = nodeDef.weights[i];\n                                }\n                            });\n                        }\n                        return node;\n                    }));\n                }\n                if (nodeDef.camera !== undefined) {\n                    pending.push(parser.getDependency('camera', nodeDef.camera));\n                }\n                if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) {\n                    pending.push(parser.getDependency('light', nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light));\n                }\n                return Promise.all(pending);\n            }().then(function (objects) {\n                var node;\n                if (nodeDef.isBone === true) {\n                    node = new THREE.Bone();\n                } else if (objects.length > 1) {\n                    node = new THREE.Group();\n                } else if (objects.length === 1) {\n                    node = objects[0];\n                } else {\n                    node = new THREE.Object3D();\n                }\n                if (node !== objects[0]) {\n                    for (var i = 0, il = objects.length; i < il; i++) {\n                        node.add(objects[i]);\n                    }\n                }\n                if (nodeDef.name) {\n                    node.userData.name = nodeDef.name;\n                    node.name = THREE.PropertyBinding.sanitizeNodeName(nodeDef.name);\n                }\n                assignExtrasToUserData(node, nodeDef);\n                if (nodeDef.extensions)\n                    addUnknownExtensionsToUserData(extensions, node, nodeDef);\n                if (nodeDef.matrix !== undefined) {\n                    var matrix = new THREE.Matrix4();\n                    matrix.fromArray(nodeDef.matrix);\n                    node.applyMatrix4(matrix);\n                } else {\n                    if (nodeDef.translation !== undefined) {\n                        node.position.fromArray(nodeDef.translation);\n                    }\n                    if (nodeDef.rotation !== undefined) {\n                        node.quaternion.fromArray(nodeDef.rotation);\n                    }\n                    if (nodeDef.scale !== undefined) {\n                        node.scale.fromArray(nodeDef.scale);\n                    }\n                }\n                return node;\n            });\n        };\n        GLTFParser.prototype.loadScene = function () {\n            function buildNodeHierachy(nodeId, parentObject, json, parser) {\n                var nodeDef = json.nodes[nodeId];\n                return parser.getDependency('node', nodeId).then(function (node) {\n                    if (nodeDef.skin === undefined)\n                        return node;\n                    var skinEntry;\n                    return parser.getDependency('skin', nodeDef.skin).then(function (skin) {\n                        skinEntry = skin;\n                        var pendingJoints = [];\n                        for (var i = 0, il = skinEntry.joints.length; i < il; i++) {\n                            pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\n                        }\n                        return Promise.all(pendingJoints);\n                    }).then(function (jointNodes) {\n                        node.traverse(function (mesh) {\n                            if (!mesh.isMesh)\n                                return;\n                            var bones = [];\n                            var boneInverses = [];\n                            for (var j = 0, jl = jointNodes.length; j < jl; j++) {\n                                var jointNode = jointNodes[j];\n                                if (jointNode) {\n                                    bones.push(jointNode);\n                                    var mat = new THREE.Matrix4();\n                                    if (skinEntry.inverseBindMatrices !== undefined) {\n                                        mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n                                    }\n                                    boneInverses.push(mat);\n                                } else {\n                                    console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\n                                }\n                            }\n                            mesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);\n                        });\n                        return node;\n                    });\n                }).then(function (node) {\n                    parentObject.add(node);\n                    var pending = [];\n                    if (nodeDef.children) {\n                        var children = nodeDef.children;\n                        for (var i = 0, il = children.length; i < il; i++) {\n                            var child = children[i];\n                            pending.push(buildNodeHierachy(child, node, json, parser));\n                        }\n                    }\n                    return Promise.all(pending);\n                });\n            }\n            return function loadScene(sceneIndex) {\n                var json = this.json;\n                var extensions = this.extensions;\n                var sceneDef = this.json.scenes[sceneIndex];\n                var parser = this;\n                var scene = new THREE.Group();\n                if (sceneDef.name)\n                    scene.name = sceneDef.name;\n                assignExtrasToUserData(scene, sceneDef);\n                if (sceneDef.extensions)\n                    addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n                var nodeIds = sceneDef.nodes || [];\n                var pending = [];\n                for (var i = 0, il = nodeIds.length; i < il; i++) {\n                    pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\n                }\n                return Promise.all(pending).then(function () {\n                    return scene;\n                });\n            };\n        }();\n        return GLTFLoader;\n    }();\n    \n    return threex.loaders.GLTFLoader = GLTFLoader;\n});"]}