{"version":3,"sources":["loaders/PCDLoader.js"],"names":["define","THREE","PCDLoader","manager","Loader","call","this","littleEndian","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setResponseType","data","parse","e","textData","LoaderUtils","decodeText","Uint8Array","PCDheader","result1","search","result2","exec","substr","headerLen","length","str","replace","version","fields","size","type","count","width","height","viewpoint","points","parseFloat","split","parseInt","map","x","i","l","push","offset","sizeSum","rowSize","parseHeader","position","normal","color","lines","line","undefined","y","z","rgb","r","g","b","normal_x","normal_y","normal_z","sizes","Uint32Array","slice","compressedSize","decompressedSize","decompressed","inData","outLength","ctrl","len","ref","inLength","outData","inPtr","outPtr","Error","decompressLZF","dataview","DataView","buffer","getFloat32","getUint8","row","geometry","BufferGeometry","setAttribute","Float32BufferAttribute","computeBoundingSphere","material","PointsMaterial","vertexColors","setHex","Math","random","mesh","Points","name","reverse","join"],"mappings":"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","file":"../../loaders/PCDLoader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Filipe Caixeta / http://filipecaixeta.com.br\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Description: A THREE loader for PCD ascii and binary files.\n\t */\n\n\tTHREE.PCDLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.littleEndian = true;\n\n\t};\n\n\n\tTHREE.PCDLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.PCDLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( data ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( scope.parse( data, url ) );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow e;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data, url ) {\n\n\t\t\t// from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n\n\t\t\tfunction decompressLZF( inData, outLength ) {\n\n\t\t\t\tvar inLength = inData.length;\n\t\t\t\tvar outData = new Uint8Array( outLength );\n\t\t\t\tvar inPtr = 0;\n\t\t\t\tvar outPtr = 0;\n\t\t\t\tvar ctrl;\n\t\t\t\tvar len;\n\t\t\t\tvar ref;\n\t\t\t\tdo {\n\n\t\t\t\t\tctrl = inData[ inPtr ++ ];\n\t\t\t\t\tif ( ctrl < ( 1 << 5 ) ) {\n\n\t\t\t\t\t\tctrl ++;\n\t\t\t\t\t\tif ( outPtr + ctrl > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\t\tif ( inPtr + ctrl > inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\toutData[ outPtr ++ ] = inData[ inPtr ++ ];\n\n\t\t\t\t\t\t} while ( -- ctrl );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlen = ctrl >> 5;\n\t\t\t\t\t\tref = outPtr - ( ( ctrl & 0x1f ) << 8 ) - 1;\n\t\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\t\tif ( len === 7 ) {\n\n\t\t\t\t\t\t\tlen += inData[ inPtr ++ ];\n\t\t\t\t\t\t\tif ( inPtr >= inLength ) throw new Error( 'Invalid compressed data' );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tref -= inData[ inPtr ++ ];\n\t\t\t\t\t\tif ( outPtr + len + 2 > outLength ) throw new Error( 'Output buffer is not large enough' );\n\t\t\t\t\t\tif ( ref < 0 ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\t\tif ( ref >= outPtr ) throw new Error( 'Invalid compressed data' );\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\toutData[ outPtr ++ ] = outData[ ref ++ ];\n\n\t\t\t\t\t\t} while ( -- len + 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} while ( inPtr < inLength );\n\n\t\t\t\treturn outData;\n\n\t\t\t}\n\n\t\t\tfunction parseHeader( data ) {\n\n\t\t\t\tvar PCDheader = {};\n\t\t\t\tvar result1 = data.search( /[\\r\\n]DATA\\s(\\S*)\\s/i );\n\t\t\t\tvar result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec( data.substr( result1 - 1 ) );\n\n\t\t\t\tPCDheader.data = result2[ 1 ];\n\t\t\t\tPCDheader.headerLen = result2[ 0 ].length + result1;\n\t\t\t\tPCDheader.str = data.substr( 0, PCDheader.headerLen );\n\n\t\t\t\t// remove comments\n\n\t\t\t\tPCDheader.str = PCDheader.str.replace( /\\#.*/gi, '' );\n\n\t\t\t\t// parse\n\n\t\t\t\tPCDheader.version = /VERSION (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.fields = /FIELDS (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.size = /SIZE (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.type = /TYPE (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.count = /COUNT (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.width = /WIDTH (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.height = /HEIGHT (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.viewpoint = /VIEWPOINT (.*)/i.exec( PCDheader.str );\n\t\t\t\tPCDheader.points = /POINTS (.*)/i.exec( PCDheader.str );\n\n\t\t\t\t// evaluate\n\n\t\t\t\tif ( PCDheader.version !== null )\n\t\t\t\t\tPCDheader.version = parseFloat( PCDheader.version[ 1 ] );\n\n\t\t\t\tif ( PCDheader.fields !== null )\n\t\t\t\t\tPCDheader.fields = PCDheader.fields[ 1 ].split( ' ' );\n\n\t\t\t\tif ( PCDheader.type !== null )\n\t\t\t\t\tPCDheader.type = PCDheader.type[ 1 ].split( ' ' );\n\n\t\t\t\tif ( PCDheader.width !== null )\n\t\t\t\t\tPCDheader.width = parseInt( PCDheader.width[ 1 ] );\n\n\t\t\t\tif ( PCDheader.height !== null )\n\t\t\t\t\tPCDheader.height = parseInt( PCDheader.height[ 1 ] );\n\n\t\t\t\tif ( PCDheader.viewpoint !== null )\n\t\t\t\t\tPCDheader.viewpoint = PCDheader.viewpoint[ 1 ];\n\n\t\t\t\tif ( PCDheader.points !== null )\n\t\t\t\t\tPCDheader.points = parseInt( PCDheader.points[ 1 ], 10 );\n\n\t\t\t\tif ( PCDheader.points === null )\n\t\t\t\t\tPCDheader.points = PCDheader.width * PCDheader.height;\n\n\t\t\t\tif ( PCDheader.size !== null ) {\n\n\t\t\t\t\tPCDheader.size = PCDheader.size[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\tif ( PCDheader.count !== null ) {\n\n\t\t\t\t\tPCDheader.count = PCDheader.count[ 1 ].split( ' ' ).map( function ( x ) {\n\n\t\t\t\t\t\treturn parseInt( x, 10 );\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tPCDheader.count = [];\n\n\t\t\t\t\tfor ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tPCDheader.count.push( 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tPCDheader.offset = {};\n\n\t\t\t\tvar sizeSum = 0;\n\n\t\t\t\tfor ( var i = 0, l = PCDheader.fields.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = i;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tPCDheader.offset[ PCDheader.fields[ i ] ] = sizeSum;\n\t\t\t\t\t\tsizeSum += PCDheader.size[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// for binary only\n\n\t\t\t\tPCDheader.rowSize = sizeSum;\n\n\t\t\t\treturn PCDheader;\n\n\t\t\t}\n\n\t\t\tvar textData = THREE.LoaderUtils.decodeText( new Uint8Array( data ) );\n\n\t\t\t// parse header (always ascii format)\n\n\t\t\tvar PCDheader = parseHeader( textData );\n\n\t\t\t// parse data\n\n\t\t\tvar position = [];\n\t\t\tvar normal = [];\n\t\t\tvar color = [];\n\n\t\t\t// ascii\n\n\t\t\tif ( PCDheader.data === 'ascii' ) {\n\n\t\t\t\tvar offset = PCDheader.offset;\n\t\t\t\tvar pcdData = textData.substr( PCDheader.headerLen );\n\t\t\t\tvar lines = pcdData.split( '\\n' );\n\n\t\t\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( lines[ i ] === '' ) continue;\n\n\t\t\t\t\tvar line = lines[ i ].split( ' ' );\n\n\t\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\t\tposition.push( parseFloat( line[ offset.x ] ) );\n\t\t\t\t\t\tposition.push( parseFloat( line[ offset.y ] ) );\n\t\t\t\t\t\tposition.push( parseFloat( line[ offset.z ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\t\tvar rgb = parseFloat( line[ offset.rgb ] );\n\t\t\t\t\t\tvar r = ( rgb >> 16 ) & 0x0000ff;\n\t\t\t\t\t\tvar g = ( rgb >> 8 ) & 0x0000ff;\n\t\t\t\t\t\tvar b = ( rgb >> 0 ) & 0x0000ff;\n\t\t\t\t\t\tcolor.push( r / 255, g / 255, b / 255 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_x ] ) );\n\t\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_y ] ) );\n\t\t\t\t\t\tnormal.push( parseFloat( line[ offset.normal_z ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// binary-compressed\n\n\t\t\t// normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n\t\t\t// binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n\t\t\t// that requires a totally different parsing approach compared to non-compressed data\n\n\t\t\tif ( PCDheader.data === 'binary_compressed' ) {\n\n\t\t\t\tvar sizes = new Uint32Array( data.slice( PCDheader.headerLen, PCDheader.headerLen + 8 ) );\n\t\t\t\tvar compressedSize = sizes[ 0 ];\n\t\t\t\tvar decompressedSize = sizes[ 1 ];\n\t\t\t\tvar decompressed = decompressLZF( new Uint8Array( data, PCDheader.headerLen + 8, compressedSize ), decompressedSize );\n\t\t\t\tvar dataview = new DataView( decompressed.buffer );\n\n\t\t\t\tvar offset = PCDheader.offset;\n\n\t\t\t\tfor ( var i = 0; i < PCDheader.points; i ++ ) {\n\n\t\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.x ) + PCDheader.size[ 0 ] * i, this.littleEndian ) );\n\t\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.y ) + PCDheader.size[ 1 ] * i, this.littleEndian ) );\n\t\t\t\t\t\tposition.push( dataview.getFloat32( ( PCDheader.points * offset.z ) + PCDheader.size[ 2 ] * i, this.littleEndian ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 0 ) / 255.0 );\n\t\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 1 ) / 255.0 );\n\t\t\t\t\t\tcolor.push( dataview.getUint8( ( PCDheader.points * offset.rgb ) + PCDheader.size[ 3 ] * i + 2 ) / 255.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_x ) + PCDheader.size[ 4 ] * i, this.littleEndian ) );\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_y ) + PCDheader.size[ 5 ] * i, this.littleEndian ) );\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( ( PCDheader.points * offset.normal_z ) + PCDheader.size[ 6 ] * i, this.littleEndian ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// binary\n\n\t\t\tif ( PCDheader.data === 'binary' ) {\n\n\t\t\t\tvar dataview = new DataView( data, PCDheader.headerLen );\n\t\t\t\tvar offset = PCDheader.offset;\n\n\t\t\t\tfor ( var i = 0, row = 0; i < PCDheader.points; i ++, row += PCDheader.rowSize ) {\n\n\t\t\t\t\tif ( offset.x !== undefined ) {\n\n\t\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.x, this.littleEndian ) );\n\t\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.y, this.littleEndian ) );\n\t\t\t\t\t\tposition.push( dataview.getFloat32( row + offset.z, this.littleEndian ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.rgb !== undefined ) {\n\n\t\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 2 ) / 255.0 );\n\t\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 1 ) / 255.0 );\n\t\t\t\t\t\tcolor.push( dataview.getUint8( row + offset.rgb + 0 ) / 255.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( offset.normal_x !== undefined ) {\n\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_x, this.littleEndian ) );\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_y, this.littleEndian ) );\n\t\t\t\t\t\tnormal.push( dataview.getFloat32( row + offset.normal_z, this.littleEndian ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tif ( position.length > 0 ) geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( position, 3 ) );\n\t\t\tif ( normal.length > 0 ) geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normal, 3 ) );\n\t\t\tif ( color.length > 0 ) geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( color, 3 ) );\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t// build material\n\n\t\t\tvar material = new THREE.PointsMaterial( { size: 0.005 } );\n\n\t\t\tif ( color.length > 0 ) {\n\n\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.color.setHex( Math.random() * 0xffffff );\n\n\t\t\t}\n\n\t\t\t// build point cloud\n\n\t\t\tvar mesh = new THREE.Points( geometry, material );\n\t\t\tvar name = url.split( '' ).reverse().join( '' );\n\t\t\tname = /([^\\/]*)/.exec( name );\n\t\t\tname = name[ 1 ].split( '' ).reverse().join( '' );\n\t\t\tmesh.name = name;\n\n\t\t\treturn mesh;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.PCDLoader;\n});\n"]}