{"version":3,"sources":["loaders/PRWMLoader.js"],"names":["define","THREE","PRWMLoader","bigEndianPlatform","isBigEndianPlatform","buffer","ArrayBuffer","uint8Array","Uint8Array","uint16Array","Uint16Array","InvertedEncodingTypes","Float32Array","Int8Array","Int16Array","Int32Array","Uint32Array","getMethods","Float64Array","copyFromBuffer","sourceArrayBuffer","viewType","position","length","fromBigEndian","result","bytesPerElement","BYTES_PER_ELEMENT","readView","DataView","getMethod","name","littleEndian","i","manager","Loader","call","this","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setResponseType","replace","arrayBuffer","parse","attribute","data","array","version","flags","indexedGeometry","indicesType","bigEndian","attributesNumber","valuesNumber","indicesNumber","Error","attributeName","char","attributeType","cardinality","arrayType","values","indices","pos","attributes","String","fromCharCode","Math","ceil","type","decodePrwm","attributesKey","keys","bufferGeometry","BufferGeometry","setAttribute","BufferAttribute","normalized","setIndex"],"mappings":"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","file":"../../loaders/PRWMLoader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Kevin Chapelier / https://github.com/kchapelier\n\t * See https://github.com/kchapelier/PRWM for more informations about this file format\n\t */\n\n\tTHREE.PRWMLoader = ( function () {\n\n\t\tvar bigEndianPlatform = null;\n\n\t\t/**\n\t\t * Check if the endianness of the platform is big-endian (most significant bit first)\n\t\t * @returns {boolean} True if big-endian, false if little-endian\n\t\t */\n\t\tfunction isBigEndianPlatform() {\n\n\t\t\tif ( bigEndianPlatform === null ) {\n\n\t\t\t\tvar buffer = new ArrayBuffer( 2 ),\n\t\t\t\t\tuint8Array = new Uint8Array( buffer ),\n\t\t\t\t\tuint16Array = new Uint16Array( buffer );\n\n\t\t\t\tuint8Array[ 0 ] = 0xAA; // set first byte\n\t\t\t\tuint8Array[ 1 ] = 0xBB; // set second byte\n\t\t\t\tbigEndianPlatform = ( uint16Array[ 0 ] === 0xAABB );\n\n\t\t\t}\n\n\t\t\treturn bigEndianPlatform;\n\n\t\t}\n\n\t\t// match the values defined in the spec to the TypedArray types\n\t\tvar InvertedEncodingTypes = [\n\t\t\tnull,\n\t\t\tFloat32Array,\n\t\t\tnull,\n\t\t\tInt8Array,\n\t\t\tInt16Array,\n\t\t\tnull,\n\t\t\tInt32Array,\n\t\t\tUint8Array,\n\t\t\tUint16Array,\n\t\t\tnull,\n\t\t\tUint32Array\n\t\t];\n\n\t\t// define the method to use on a DataView, corresponding the TypedArray type\n\t\tvar getMethods = {\n\t\t\tUint16Array: 'getUint16',\n\t\t\tUint32Array: 'getUint32',\n\t\t\tInt16Array: 'getInt16',\n\t\t\tInt32Array: 'getInt32',\n\t\t\tFloat32Array: 'getFloat32',\n\t\t\tFloat64Array: 'getFloat64'\n\t\t};\n\n\n\t\tfunction copyFromBuffer( sourceArrayBuffer, viewType, position, length, fromBigEndian ) {\n\n\t\t\tvar bytesPerElement = viewType.BYTES_PER_ELEMENT,\n\t\t\t\tresult;\n\n\t\t\tif ( fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1 ) {\n\n\t\t\t\tresult = new viewType( sourceArrayBuffer, position, length );\n\n\t\t\t} else {\n\n\t\t\t\tvar readView = new DataView( sourceArrayBuffer, position, length * bytesPerElement ),\n\t\t\t\t\tgetMethod = getMethods[ viewType.name ],\n\t\t\t\t\tlittleEndian = ! fromBigEndian,\n\t\t\t\t\ti = 0;\n\n\t\t\t\tresult = new viewType( length );\n\n\t\t\t\tfor ( ; i < length; i ++ ) {\n\n\t\t\t\t\tresult[ i ] = readView[ getMethod ]( i * bytesPerElement, littleEndian );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\n\t\tfunction decodePrwm( buffer ) {\n\n\t\t\tvar array = new Uint8Array( buffer ),\n\t\t\t\tversion = array[ 0 ],\n\t\t\t\tflags = array[ 1 ],\n\t\t\t\tindexedGeometry = !! ( flags >> 7 & 0x01 ),\n\t\t\t\tindicesType = flags >> 6 & 0x01,\n\t\t\t\tbigEndian = ( flags >> 5 & 0x01 ) === 1,\n\t\t\t\tattributesNumber = flags & 0x1F,\n\t\t\t\tvaluesNumber = 0,\n\t\t\t\tindicesNumber = 0;\n\n\t\t\tif ( bigEndian ) {\n\n\t\t\t\tvaluesNumber = ( array[ 2 ] << 16 ) + ( array[ 3 ] << 8 ) + array[ 4 ];\n\t\t\t\tindicesNumber = ( array[ 5 ] << 16 ) + ( array[ 6 ] << 8 ) + array[ 7 ];\n\n\t\t\t} else {\n\n\t\t\t\tvaluesNumber = array[ 2 ] + ( array[ 3 ] << 8 ) + ( array[ 4 ] << 16 );\n\t\t\t\tindicesNumber = array[ 5 ] + ( array[ 6 ] << 8 ) + ( array[ 7 ] << 16 );\n\n\t\t\t}\n\n\t\t\t/** PRELIMINARY CHECKS **/\n\n\t\t\tif ( version === 0 ) {\n\n\t\t\t\tthrow new Error( 'PRWM decoder: Invalid format version: 0' );\n\n\t\t\t} else if ( version !== 1 ) {\n\n\t\t\t\tthrow new Error( 'PRWM decoder: Unsupported format version: ' + version );\n\n\t\t\t}\n\n\t\t\tif ( ! indexedGeometry ) {\n\n\t\t\t\tif ( indicesType !== 0 ) {\n\n\t\t\t\t\tthrow new Error( 'PRWM decoder: Indices type must be set to 0 for non-indexed geometries' );\n\n\t\t\t\t} else if ( indicesNumber !== 0 ) {\n\n\t\t\t\t\tthrow new Error( 'PRWM decoder: Number of indices must be set to 0 for non-indexed geometries' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/** PARSING **/\n\n\t\t\tvar pos = 8;\n\n\t\t\tvar attributes = {},\n\t\t\t\tattributeName,\n\t\t\t\tchar,\n\t\t\t\tattributeType,\n\t\t\t\tcardinality,\n\t\t\t\tencodingType,\n\t\t\t\tarrayType,\n\t\t\t\tvalues,\n\t\t\t\tindices,\n\t\t\t\ti;\n\n\t\t\tfor ( i = 0; i < attributesNumber; i ++ ) {\n\n\t\t\t\tattributeName = '';\n\n\t\t\t\twhile ( pos < array.length ) {\n\n\t\t\t\t\tchar = array[ pos ];\n\t\t\t\t\tpos ++;\n\n\t\t\t\t\tif ( char === 0 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tattributeName += String.fromCharCode( char );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tflags = array[ pos ];\n\n\t\t\t\tattributeType = flags >> 7 & 0x01;\n\t\t\t\tcardinality = ( flags >> 4 & 0x03 ) + 1;\n\t\t\t\tencodingType = flags & 0x0F;\n\t\t\t\tarrayType = InvertedEncodingTypes[ encodingType ];\n\n\t\t\t\tpos ++;\n\n\t\t\t\t// padding to next multiple of 4\n\t\t\t\tpos = Math.ceil( pos / 4 ) * 4;\n\n\t\t\t\tvalues = copyFromBuffer( buffer, arrayType, pos, cardinality * valuesNumber, bigEndian );\n\n\t\t\t\tpos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n\n\t\t\t\tattributes[ attributeName ] = {\n\t\t\t\t\ttype: attributeType,\n\t\t\t\t\tcardinality: cardinality,\n\t\t\t\t\tvalues: values\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tpos = Math.ceil( pos / 4 ) * 4;\n\n\t\t\tindices = null;\n\n\t\t\tif ( indexedGeometry ) {\n\n\t\t\t\tindices = copyFromBuffer(\n\t\t\t\t\tbuffer,\n\t\t\t\t\tindicesType === 1 ? Uint32Array : Uint16Array,\n\t\t\t\t\tpos,\n\t\t\t\t\tindicesNumber,\n\t\t\t\t\tbigEndian\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tversion: version,\n\t\t\t\tattributes: attributes,\n\t\t\t\tindices: indices\n\t\t\t};\n\n\t\t}\n\n\t\t// Define the public interface\n\n\t\tfunction PRWMLoader( manager ) {\n\n\t\t\tTHREE.Loader.call( this, manager );\n\n\t\t}\n\n\t\tPRWMLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\t\tconstructor: PRWMLoader,\n\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\t\tloader.setPath( scope.path );\n\t\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\t\turl = url.replace( /\\*/g, isBigEndianPlatform() ? 'be' : 'le' );\n\n\t\t\t\tloader.load( url, function ( arrayBuffer ) {\n\n\t\t\t\t\tonLoad( scope.parse( arrayBuffer ) );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t},\n\n\t\t\tparse: function ( arrayBuffer ) {\n\n\t\t\t\tvar data = decodePrwm( arrayBuffer ),\n\t\t\t\t\tattributesKey = Object.keys( data.attributes ),\n\t\t\t\t\tbufferGeometry = new THREE.BufferGeometry(),\n\t\t\t\t\tattribute,\n\t\t\t\t\ti;\n\n\t\t\t\tfor ( i = 0; i < attributesKey.length; i ++ ) {\n\n\t\t\t\t\tattribute = data.attributes[ attributesKey[ i ] ];\n\t\t\t\t\tbufferGeometry.setAttribute( attributesKey[ i ], new THREE.BufferAttribute( attribute.values, attribute.cardinality, attribute.normalized ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.indices !== null ) {\n\n\t\t\t\t\tbufferGeometry.setIndex( new THREE.BufferAttribute( data.indices, 1 ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn bufferGeometry;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tPRWMLoader.isBigEndianPlatform = function () {\n\n\t\t\treturn isBigEndianPlatform();\n\n\t\t};\n\n\t\treturn PRWMLoader;\n\n\t} )();\n\t\n\treturn THREE.PRWMLoader;\n});\n"]}