{"version":3,"sources":["loaders/BVHLoader.js"],"names":["define","THREE","BVHLoader","manager","Loader","call","this","animateBonePositions","animateBoneRotations","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","text","parse","readFrameData","data","frameTime","bone","type","keyframe","time","position","Vector3","rotation","Quaternion","frames","push","quat","vx","vy","vz","i","channels","length","x","parseFloat","shift","trim","y","z","setFromAxisAngle","Math","PI","multiply","console","warn","children","nextLine","lines","line","bones","error","list","root","readNode","firstline","node","name","tokens","split","toUpperCase","offset","isNaN","numChannels","parseInt","splice","numFrames","readBvh","threeBones","toTHREEBone","source","Bone","add","threeClip","tracks","times","positions","rotations","j","frame","w","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationClip","toTHREEAnimation","skeleton","Skeleton","clip"],"mappings":"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","file":"../../loaders/BVHLoader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author herzig / http://github.com/herzig\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Description: reads BVH files and outputs a single THREE.Skeleton and an THREE.AnimationClip\n\t *\n\t * Currently only supports bvh files containing a single root.\n\t *\n\t */\n\n\tTHREE.BVHLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.animateBonePositions = true;\n\t\tthis.animateBoneRotations = true;\n\n\t};\n\n\tTHREE.BVHLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.BVHLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( text ) {\n\n\t\t\t/*\n\t\t\t\treads a string array (lines) from a BVH file\n\t\t\t\tand outputs a skeleton structure including motion data\n\n\t\t\t\treturns thee root node:\n\t\t\t\t{ name: '', channels: [], children: [] }\n\t\t\t*/\n\t\t\tfunction readBvh( lines ) {\n\n\t\t\t\t// read model structure\n\n\t\t\t\tif ( nextLine( lines ) !== 'HIERARCHY' ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BVHLoader: HIERARCHY expected.' );\n\n\t\t\t\t}\n\n\t\t\t\tvar list = []; // collects flat array of all bones\n\t\t\t\tvar root = readNode( lines, nextLine( lines ), list );\n\n\t\t\t\t// read motion data\n\n\t\t\t\tif ( nextLine( lines ) !== 'MOTION' ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BVHLoader: MOTION expected.' );\n\n\t\t\t\t}\n\n\t\t\t\t// number of frames\n\n\t\t\t\tvar tokens = nextLine( lines ).split( /[\\s]+/ );\n\t\t\t\tvar numFrames = parseInt( tokens[ 1 ] );\n\n\t\t\t\tif ( isNaN( numFrames ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BVHLoader: Failed to read number of frames.' );\n\n\t\t\t\t}\n\n\t\t\t\t// frame time\n\n\t\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\t\t\t\tvar frameTime = parseFloat( tokens[ 2 ] );\n\n\t\t\t\tif ( isNaN( frameTime ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BVHLoader: Failed to read frame time.' );\n\n\t\t\t\t}\n\n\t\t\t\t// read frame data line by line\n\n\t\t\t\tfor ( var i = 0; i < numFrames; i ++ ) {\n\n\t\t\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\t\t\t\t\treadFrameData( tokens, i * frameTime, root );\n\n\t\t\t\t}\n\n\t\t\t\treturn list;\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t\tRecursively reads data from a single frame into the bone hierarchy.\n\t\t\t\tThe passed bone hierarchy has to be structured in the same order as the BVH file.\n\t\t\t\tkeyframe data is stored in bone.frames.\n\n\t\t\t\t- data: splitted string array (frame values), values are shift()ed so\n\t\t\t\tthis should be empty after parsing the whole hierarchy.\n\t\t\t\t- frameTime: playback time for this keyframe.\n\t\t\t\t- bone: the bone to read frame data from.\n\t\t\t*/\n\t\t\tfunction readFrameData( data, frameTime, bone ) {\n\n\t\t\t\t// end sites have no motion data\n\n\t\t\t\tif ( bone.type === 'ENDSITE' ) return;\n\n\t\t\t\t// add keyframe\n\n\t\t\t\tvar keyframe = {\n\t\t\t\t\ttime: frameTime,\n\t\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\t\trotation: new THREE.Quaternion()\n\t\t\t\t};\n\n\t\t\t\tbone.frames.push( keyframe );\n\n\t\t\t\tvar quat = new THREE.Quaternion();\n\n\t\t\t\tvar vx = new THREE.Vector3( 1, 0, 0 );\n\t\t\t\tvar vy = new THREE.Vector3( 0, 1, 0 );\n\t\t\t\tvar vz = new THREE.Vector3( 0, 0, 1 );\n\n\t\t\t\t// parse values for each channel in node\n\n\t\t\t\tfor ( var i = 0; i < bone.channels.length; i ++ ) {\n\n\t\t\t\t\tswitch ( bone.channels[ i ] ) {\n\n\t\t\t\t\t\tcase 'Xposition':\n\t\t\t\t\t\t\tkeyframe.position.x = parseFloat( data.shift().trim() );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Yposition':\n\t\t\t\t\t\t\tkeyframe.position.y = parseFloat( data.shift().trim() );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Zposition':\n\t\t\t\t\t\t\tkeyframe.position.z = parseFloat( data.shift().trim() );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Xrotation':\n\t\t\t\t\t\t\tquat.setFromAxisAngle( vx, parseFloat( data.shift().trim() ) * Math.PI / 180 );\n\t\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Yrotation':\n\t\t\t\t\t\t\tquat.setFromAxisAngle( vy, parseFloat( data.shift().trim() ) * Math.PI / 180 );\n\t\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Zrotation':\n\t\t\t\t\t\t\tquat.setFromAxisAngle( vz, parseFloat( data.shift().trim() ) * Math.PI / 180 );\n\t\t\t\t\t\t\tkeyframe.rotation.multiply( quat );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.BVHLoader: Invalid channel type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse child nodes\n\n\t\t\t\tfor ( var i = 0; i < bone.children.length; i ++ ) {\n\n\t\t\t\t\treadFrameData( data, frameTime, bone.children[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t Recursively parses the HIERACHY section of the BVH file\n\n\t\t\t - lines: all lines of the file. lines are consumed as we go along.\n\t\t\t - firstline: line containing the node type and name e.g. 'JOINT hip'\n\t\t\t - list: collects a flat list of nodes\n\n\t\t\t returns: a BVH node including children\n\t\t\t*/\n\t\t\tfunction readNode( lines, firstline, list ) {\n\n\t\t\t\tvar node = { name: '', type: '', frames: [] };\n\t\t\t\tlist.push( node );\n\n\t\t\t\t// parse node type and name\n\n\t\t\t\tvar tokens = firstline.split( /[\\s]+/ );\n\n\t\t\t\tif ( tokens[ 0 ].toUpperCase() === 'END' && tokens[ 1 ].toUpperCase() === 'SITE' ) {\n\n\t\t\t\t\tnode.type = 'ENDSITE';\n\t\t\t\t\tnode.name = 'ENDSITE'; // bvh end sites have no name\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode.name = tokens[ 1 ];\n\t\t\t\t\tnode.type = tokens[ 0 ].toUpperCase();\n\n\t\t\t\t}\n\n\t\t\t\tif ( nextLine( lines ) !== '{' ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BVHLoader: Expected opening { after type & name' );\n\n\t\t\t\t}\n\n\t\t\t\t// parse OFFSET\n\n\t\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\n\t\t\t\tif ( tokens[ 0 ] !== 'OFFSET' ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BVHLoader: Expected OFFSET but got: ' + tokens[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tokens.length !== 4 ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BVHLoader: Invalid number of values for OFFSET.' );\n\n\t\t\t\t}\n\n\t\t\t\tvar offset = new THREE.Vector3(\n\t\t\t\t\tparseFloat( tokens[ 1 ] ),\n\t\t\t\t\tparseFloat( tokens[ 2 ] ),\n\t\t\t\t\tparseFloat( tokens[ 3 ] )\n\t\t\t\t);\n\n\t\t\t\tif ( isNaN( offset.x ) || isNaN( offset.y ) || isNaN( offset.z ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BVHLoader: Invalid values of OFFSET.' );\n\n\t\t\t\t}\n\n\t\t\t\tnode.offset = offset;\n\n\t\t\t\t// parse CHANNELS definitions\n\n\t\t\t\tif ( node.type !== 'ENDSITE' ) {\n\n\t\t\t\t\ttokens = nextLine( lines ).split( /[\\s]+/ );\n\n\t\t\t\t\tif ( tokens[ 0 ] !== 'CHANNELS' ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.BVHLoader: Expected CHANNELS definition.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar numChannels = parseInt( tokens[ 1 ] );\n\t\t\t\t\tnode.channels = tokens.splice( 2, numChannels );\n\t\t\t\t\tnode.children = [];\n\n\t\t\t\t}\n\n\t\t\t\t// read children\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tvar line = nextLine( lines );\n\n\t\t\t\t\tif ( line === '}' ) {\n\n\t\t\t\t\t\treturn node;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnode.children.push( readNode( lines, line, list ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t\trecursively converts the internal bvh node structure to a THREE.Bone hierarchy\n\n\t\t\t\tsource: the bvh root node\n\t\t\t\tlist: pass an empty array, collects a flat list of all converted THREE.Bones\n\n\t\t\t\treturns the root THREE.Bone\n\t\t\t*/\n\t\t\tfunction toTHREEBone( source, list ) {\n\n\t\t\t\tvar bone = new THREE.Bone();\n\t\t\t\tlist.push( bone );\n\n\t\t\t\tbone.position.add( source.offset );\n\t\t\t\tbone.name = source.name;\n\n\t\t\t\tif ( source.type !== 'ENDSITE' ) {\n\n\t\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\t\t\tbone.add( toTHREEBone( source.children[ i ], list ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t\tbuilds a THREE.AnimationClip from the keyframe data saved in each bone.\n\n\t\t\t\tbone: bvh root node\n\n\t\t\t\treturns: a THREE.AnimationClip containing position and quaternion tracks\n\t\t\t*/\n\t\t\tfunction toTHREEAnimation( bones ) {\n\n\t\t\t\tvar tracks = [];\n\n\t\t\t\t// create a position and quaternion animation track for each node\n\n\t\t\t\tfor ( var i = 0; i < bones.length; i ++ ) {\n\n\t\t\t\t\tvar bone = bones[ i ];\n\n\t\t\t\t\tif ( bone.type === 'ENDSITE' )\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// track data\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar positions = [];\n\t\t\t\t\tvar rotations = [];\n\n\t\t\t\t\tfor ( var j = 0; j < bone.frames.length; j ++ ) {\n\n\t\t\t\t\t\tvar frame = bone.frames[ j ];\n\n\t\t\t\t\t\ttimes.push( frame.time );\n\n\t\t\t\t\t\t// the animation system animates the position property,\n\t\t\t\t\t\t// so we have to add the joint offset to all values\n\n\t\t\t\t\t\tpositions.push( frame.position.x + bone.offset.x );\n\t\t\t\t\t\tpositions.push( frame.position.y + bone.offset.y );\n\t\t\t\t\t\tpositions.push( frame.position.z + bone.offset.z );\n\n\t\t\t\t\t\trotations.push( frame.rotation.x );\n\t\t\t\t\t\trotations.push( frame.rotation.y );\n\t\t\t\t\t\trotations.push( frame.rotation.z );\n\t\t\t\t\t\trotations.push( frame.rotation.w );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( scope.animateBonePositions ) {\n\n\t\t\t\t\t\ttracks.push( new THREE.VectorKeyframeTrack( '.bones[' + bone.name + '].position', times, positions ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( scope.animateBoneRotations ) {\n\n\t\t\t\t\t\ttracks.push( new THREE.QuaternionKeyframeTrack( '.bones[' + bone.name + '].quaternion', times, rotations ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new THREE.AnimationClip( 'animation', - 1, tracks );\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t\treturns the next non-empty line in lines\n\t\t\t*/\n\t\t\tfunction nextLine( lines ) {\n\n\t\t\t\tvar line;\n\t\t\t\t// skip empty lines\n\t\t\t\twhile ( ( line = lines.shift().trim() ).length === 0 ) { }\n\t\t\t\treturn line;\n\n\t\t\t}\n\n\t\t\tvar scope = this;\n\n\t\t\tvar lines = text.split( /[\\r\\n]+/g );\n\n\t\t\tvar bones = readBvh( lines );\n\n\t\t\tvar threeBones = [];\n\t\t\ttoTHREEBone( bones[ 0 ], threeBones );\n\n\t\t\tvar threeClip = toTHREEAnimation( bones );\n\n\t\t\treturn {\n\t\t\t\tskeleton: new THREE.Skeleton( threeBones ),\n\t\t\t\tclip: threeClip\n\t\t\t};\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.BVHLoader;\n});\n"]}