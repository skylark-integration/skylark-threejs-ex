{"version":3,"sources":["loaders/PVRLoader.js"],"names":["define","THREE","PVRLoader","manager","CompressedTextureLoader","call","this","prototype","Object","assign","create","constructor","parse","buffer","loadMipmaps","header","Uint32Array","pvrDatas","_parseV3","_parseV2","console","error","bpp","format","metaLen","pixelFormat","height","width","numFaces","numMipmaps","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_PVRTC_4BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","dataPtr","numSurfaces","isCubemap","_extract","headerLength","flags","bitmaskAlpha","numSurfs","formatFlags","_hasAlpha","blockSize","pvr","mipmaps","mipmapCount","dataOffset","dataSize","blockWidth","blockHeight","widthBlocks","heightBlocks","length","mipLevel","sWidth","sHeight","surfIndex","mipmap","data","Uint8Array"],"mappings":"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","file":"../../loaders/PVRLoader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/*\n\t *\t PVRLoader\n\t *   Author: pierre lepers\n\t *   Date: 17/09/2014 11:09\n\t *\n\t *\t PVR v2 (legacy) parser\n\t *   TODO : Add Support for PVR v3 format\n\t *   TODO : implement loadMipmaps option\n\t */\n\n\tTHREE.PVRLoader = function ( manager ) {\n\n\t\tTHREE.CompressedTextureLoader.call( this, manager );\n\n\t};\n\n\tTHREE.PVRLoader.prototype = Object.assign( Object.create( THREE.CompressedTextureLoader.prototype ), {\n\n\t\tconstructor: THREE.PVRLoader,\n\n\t\tparse: function ( buffer, loadMipmaps ) {\n\n\t\t\tvar headerLengthInt = 13;\n\t\t\tvar header = new Uint32Array( buffer, 0, headerLengthInt );\n\n\t\t\tvar pvrDatas = {\n\t\t\t\tbuffer: buffer,\n\t\t\t\theader: header,\n\t\t\t\tloadMipmaps: loadMipmaps\n\t\t\t};\n\n\t\t\tif ( header[ 0 ] === 0x03525650 ) {\n\n\t\t\t\t// PVR v3\n\n\t\t\t\treturn THREE.PVRLoader._parseV3( pvrDatas );\n\n\t\t\t} else if ( header[ 11 ] === 0x21525650 ) {\n\n\t\t\t\t// PVR v2\n\n\t\t\t\treturn THREE.PVRLoader._parseV2( pvrDatas );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.PVRLoader: Unknown PVR format.' );\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\tTHREE.PVRLoader._parseV3 = function ( pvrDatas ) {\n\n\t\tvar header = pvrDatas.header;\n\t\tvar bpp, format;\n\n\n\t\tvar metaLen = header[ 12 ],\n\t\t\tpixelFormat = header[ 2 ],\n\t\t\theight = header[ 6 ],\n\t\t\twidth = header[ 7 ],\n\t\t\t// numSurfs = header[ 9 ],\n\t\t\tnumFaces = header[ 10 ],\n\t\t\tnumMipmaps = header[ 11 ];\n\n\t\tswitch ( pixelFormat ) {\n\n\t\t\tcase 0 : // PVRTC 2bpp RGB\n\t\t\t\tbpp = 2;\n\t\t\t\tformat = THREE.RGB_PVRTC_2BPPV1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase 1 : // PVRTC 2bpp RGBA\n\t\t\t\tbpp = 2;\n\t\t\t\tformat = THREE.RGBA_PVRTC_2BPPV1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase 2 : // PVRTC 4bpp RGB\n\t\t\t\tbpp = 4;\n\t\t\t\tformat = THREE.RGB_PVRTC_4BPPV1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase 3 : // PVRTC 4bpp RGBA\n\t\t\t\tbpp = 4;\n\t\t\t\tformat = THREE.RGBA_PVRTC_4BPPV1_Format;\n\t\t\t\tbreak;\n\n\t\t\tdefault :\n\t\t\t\tconsole.error( 'THREE.PVRLoader: Unsupported PVR format:', pixelFormat );\n\n\t\t}\n\n\t\tpvrDatas.dataPtr = 52 + metaLen;\n\t\tpvrDatas.bpp = bpp;\n\t\tpvrDatas.format = format;\n\t\tpvrDatas.width = width;\n\t\tpvrDatas.height = height;\n\t\tpvrDatas.numSurfaces = numFaces;\n\t\tpvrDatas.numMipmaps = numMipmaps;\n\t\tpvrDatas.isCubemap \t= ( numFaces === 6 );\n\n\t\treturn THREE.PVRLoader._extract( pvrDatas );\n\n\t};\n\n\tTHREE.PVRLoader._parseV2 = function ( pvrDatas ) {\n\n\t\tvar header = pvrDatas.header;\n\n\t\tvar headerLength = header[ 0 ],\n\t\t\theight = header[ 1 ],\n\t\t\twidth = header[ 2 ],\n\t\t\tnumMipmaps = header[ 3 ],\n\t\t\tflags = header[ 4 ],\n\t\t\t// dataLength = header[ 5 ],\n\t\t\t// bpp =  header[ 6 ],\n\t\t\t// bitmaskRed = header[ 7 ],\n\t\t\t// bitmaskGreen = header[ 8 ],\n\t\t\t// bitmaskBlue = header[ 9 ],\n\t\t\tbitmaskAlpha = header[ 10 ],\n\t\t\t// pvrTag = header[ 11 ],\n\t\t\tnumSurfs = header[ 12 ];\n\n\n\t\tvar TYPE_MASK = 0xff;\n\t\tvar PVRTC_2 = 24,\n\t\t\tPVRTC_4 = 25;\n\n\t\tvar formatFlags = flags & TYPE_MASK;\n\n\t\tvar bpp, format;\n\t\tvar _hasAlpha = bitmaskAlpha > 0;\n\n\t\tif ( formatFlags === PVRTC_4 ) {\n\n\t\t\tformat = _hasAlpha ? THREE.RGBA_PVRTC_4BPPV1_Format : THREE.RGB_PVRTC_4BPPV1_Format;\n\t\t\tbpp = 4;\n\n\t\t} else if ( formatFlags === PVRTC_2 ) {\n\n\t\t\tformat = _hasAlpha ? THREE.RGBA_PVRTC_2BPPV1_Format : THREE.RGB_PVRTC_2BPPV1_Format;\n\t\t\tbpp = 2;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.PVRLoader: Unknown PVR format:', formatFlags );\n\n\t\t}\n\n\t\tpvrDatas.dataPtr = headerLength;\n\t\tpvrDatas.bpp = bpp;\n\t\tpvrDatas.format = format;\n\t\tpvrDatas.width = width;\n\t\tpvrDatas.height = height;\n\t\tpvrDatas.numSurfaces = numSurfs;\n\t\tpvrDatas.numMipmaps = numMipmaps + 1;\n\n\t\t// guess cubemap type seems tricky in v2\n\t\t// it juste a pvr containing 6 surface (no explicit cubemap type)\n\t\tpvrDatas.isCubemap \t= ( numSurfs === 6 );\n\n\t\treturn THREE.PVRLoader._extract( pvrDatas );\n\n\t};\n\n\n\tTHREE.PVRLoader._extract = function ( pvrDatas ) {\n\n\t\tvar pvr = {\n\t\t\tmipmaps: [],\n\t\t\twidth: pvrDatas.width,\n\t\t\theight: pvrDatas.height,\n\t\t\tformat: pvrDatas.format,\n\t\t\tmipmapCount: pvrDatas.numMipmaps,\n\t\t\tisCubemap: pvrDatas.isCubemap\n\t\t};\n\n\t\tvar buffer = pvrDatas.buffer;\n\n\t\tvar dataOffset = pvrDatas.dataPtr,\n\t\t\tbpp = pvrDatas.bpp,\n\t\t\tnumSurfs = pvrDatas.numSurfaces,\n\t\t\tdataSize = 0,\n\t\t\tblockSize = 0,\n\t\t\tblockWidth = 0,\n\t\t\tblockHeight = 0,\n\t\t\twidthBlocks = 0,\n\t\t\theightBlocks = 0;\n\n\t\tif ( bpp === 2 ) {\n\n\t\t\tblockWidth = 8;\n\t\t\tblockHeight = 4;\n\n\t\t} else {\n\n\t\t\tblockWidth = 4;\n\t\t\tblockHeight = 4;\n\n\t\t}\n\n\t\tblockSize = ( blockWidth * blockHeight ) * bpp / 8;\n\n\t\tpvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;\n\n\t\tvar mipLevel = 0;\n\n\t\twhile ( mipLevel < pvrDatas.numMipmaps ) {\n\n\t\t\tvar sWidth = pvrDatas.width >> mipLevel,\n\t\t\t\tsHeight = pvrDatas.height >> mipLevel;\n\n\t\t\twidthBlocks = sWidth / blockWidth;\n\t\t\theightBlocks = sHeight / blockHeight;\n\n\t\t\t// Clamp to minimum number of blocks\n\t\t\tif ( widthBlocks < 2 ) widthBlocks = 2;\n\t\t\tif ( heightBlocks < 2 ) heightBlocks = 2;\n\n\t\t\tdataSize = widthBlocks * heightBlocks * blockSize;\n\n\t\t\tfor ( var surfIndex = 0; surfIndex < numSurfs; surfIndex ++ ) {\n\n\t\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataSize );\n\n\t\t\t\tvar mipmap = {\n\t\t\t\t\tdata: byteArray,\n\t\t\t\t\twidth: sWidth,\n\t\t\t\t\theight: sHeight\n\t\t\t\t};\n\n\t\t\t\tpvr.mipmaps[ surfIndex * pvrDatas.numMipmaps + mipLevel ] = mipmap;\n\n\t\t\t\tdataOffset += dataSize;\n\n\t\t\t}\n\n\t\t\tmipLevel ++;\n\n\t\t}\n\n\t\treturn pvr;\n\n\t};\n\t\n\treturn THREE.PVRLoader;\n});\n"]}