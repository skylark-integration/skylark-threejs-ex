{"version":3,"sources":["loaders/PVRLoader.js"],"names":["define","THREE","threex","PVRLoader","manager","CompressedTextureLoader","call","this","prototype","Object","assign","create","constructor","parse","buffer","loadMipmaps","header","Uint32Array","pvrDatas","_parseV3","_parseV2","console","error","bpp","format","metaLen","pixelFormat","height","width","numFaces","numMipmaps","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_PVRTC_4BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","dataPtr","numSurfaces","isCubemap","_extract","headerLength","flags","bitmaskAlpha","numSurfs","formatFlags","_hasAlpha","blockSize","pvr","mipmaps","mipmapCount","dataOffset","dataSize","blockWidth","blockHeight","widthBlocks","heightBlocks","length","mipLevel","sWidth","sHeight","surfIndex","mipmap","data","Uint8Array","loaders"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,EAAY,SAAUC,GACtBH,EAAMI,wBAAwBC,KAAKC,KAAMH,IA8H7C,OA5HAD,EAAUK,UAAYC,OAAOC,OAAOD,OAAOE,OAAOV,EAAMI,wBAAwBG,YAC5EI,YAAaT,EACbU,MAAO,SAAUC,EAAQC,GACrB,IACIC,EAAS,IAAIC,YAAYH,EAAQ,EADf,IAElBI,GACAJ,OAAQA,EACRE,OAAQA,EACRD,YAAaA,GAEjB,OAAkB,WAAdC,EAAO,GACAb,EAAUgB,SAASD,GACJ,YAAfF,EAAO,IACPb,EAAUiB,SAASF,QAE1BG,QAAQC,MAAM,2CAI1BnB,EAAUgB,SAAW,SAAUD,GAC3B,IACIK,EAAKC,EADLR,EAASE,EAASF,OAElBS,EAAUT,EAAO,IAAKU,EAAcV,EAAO,GAAIW,EAASX,EAAO,GAAIY,EAAQZ,EAAO,GAAIa,EAAWb,EAAO,IAAKc,EAAad,EAAO,IACrI,OAAQU,GACR,KAAK,EACDH,EAAM,EACNC,EAASvB,EAAM8B,wBACf,MACJ,KAAK,EACDR,EAAM,EACNC,EAASvB,EAAM+B,yBACf,MACJ,KAAK,EACDT,EAAM,EACNC,EAASvB,EAAMgC,wBACf,MACJ,KAAK,EACDV,EAAM,EACNC,EAASvB,EAAMiC,yBACf,MACJ,QACIb,QAAQC,MAAM,2CAA4CI,GAU9D,OARAR,EAASiB,QAAU,GAAKV,EACxBP,EAASK,IAAMA,EACfL,EAASM,OAASA,EAClBN,EAASU,MAAQA,EACjBV,EAASS,OAASA,EAClBT,EAASkB,YAAcP,EACvBX,EAASY,WAAaA,EACtBZ,EAASmB,UAAyB,IAAbR,EACd1B,EAAUmC,SAASpB,IAE9Bf,EAAUiB,SAAW,SAAUF,GAC3B,IAKIK,EAAKC,EALLR,EAASE,EAASF,OAClBuB,EAAevB,EAAO,GAAIW,EAASX,EAAO,GAAIY,EAAQZ,EAAO,GAAIc,EAAad,EAAO,GAAIwB,EAAQxB,EAAO,GAAIyB,EAAezB,EAAO,IAAK0B,EAAW1B,EAAO,IAGzJ2B,EAFY,IAEEH,EAEdI,EAAYH,EAAe,EAkB/B,OArB4B,KAIxBE,GACAnB,EAASoB,EAAY3C,EAAMiC,yBAA2BjC,EAAMgC,wBAC5DV,EAAM,GANI,KAOHoB,GACPnB,EAASoB,EAAY3C,EAAM+B,yBAA2B/B,EAAM8B,wBAC5DR,EAAM,GAENF,QAAQC,MAAM,uCAAwCqB,GAE1DzB,EAASiB,QAAUI,EACnBrB,EAASK,IAAMA,EACfL,EAASM,OAASA,EAClBN,EAASU,MAAQA,EACjBV,EAASS,OAASA,EAClBT,EAASkB,YAAcM,EACvBxB,EAASY,WAAaA,EAAa,EACnCZ,EAASmB,UAAyB,IAAbK,EACdvC,EAAUmC,SAASpB,IAE9Bf,EAAUmC,SAAW,SAAUpB,GAC3B,IASsG2B,EATlGC,GACAC,WACAnB,MAAOV,EAASU,MAChBD,OAAQT,EAASS,OACjBH,OAAQN,EAASM,OACjBwB,YAAa9B,EAASY,WACtBO,UAAWnB,EAASmB,WAEpBvB,EAASI,EAASJ,OAClBmC,EAAa/B,EAASiB,QAASZ,EAAML,EAASK,IAAKmB,EAAWxB,EAASkB,YAAac,EAAW,EAAkBC,EAAa,EAAGC,EAAc,EAAGC,EAAc,EAAGC,EAAe,EAC1K,IAAR/B,GACA4B,EAAa,EACbC,EAAc,IAEdD,EAAa,EACbC,EAAc,GAElBP,EAAYM,EAAaC,EAAc7B,EAAM,EAC7CuB,EAAIC,QAAQQ,OAASrC,EAASY,WAAaY,EAE3C,IADA,IAAIc,EAAW,EACRA,EAAWtC,EAASY,YAAY,CACnC,IAAI2B,EAASvC,EAASU,OAAS4B,EAAUE,EAAUxC,EAASS,QAAU6B,EAEtEF,EAAeI,EAAUN,GADzBC,EAAcI,EAASN,GAEL,IACdE,EAAc,GACdC,EAAe,IACfA,EAAe,GACnBJ,EAAWG,EAAcC,EAAeT,EACxC,IAAK,IAAIc,EAAY,EAAGA,EAAYjB,EAAUiB,IAAa,CACvD,IACIC,GACAC,KAFY,IAAIC,WAAWhD,EAAQmC,EAAYC,GAG/CtB,MAAO6B,EACP9B,OAAQ+B,GAEZZ,EAAIC,QAAQY,EAAYzC,EAASY,WAAa0B,GAAYI,EAC1DX,GAAcC,EAElBM,IAEJ,OAAOV,GAEJ5C,EAAO6D,QAAQ5D,UAAYA","file":"../../loaders/PVRLoader.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    var PVRLoader = function (manager) {\n        THREE.CompressedTextureLoader.call(this, manager);\n    };\n    PVRLoader.prototype = Object.assign(Object.create(THREE.CompressedTextureLoader.prototype), {\n        constructor: PVRLoader,\n        parse: function (buffer, loadMipmaps) {\n            var headerLengthInt = 13;\n            var header = new Uint32Array(buffer, 0, headerLengthInt);\n            var pvrDatas = {\n                buffer: buffer,\n                header: header,\n                loadMipmaps: loadMipmaps\n            };\n            if (header[0] === 55727696) {\n                return PVRLoader._parseV3(pvrDatas);\n            } else if (header[11] === 559044176) {\n                return PVRLoader._parseV2(pvrDatas);\n            } else {\n                console.error('THREE.PVRLoader: Unknown PVR format.');\n            }\n        }\n    });\n    PVRLoader._parseV3 = function (pvrDatas) {\n        var header = pvrDatas.header;\n        var bpp, format;\n        var metaLen = header[12], pixelFormat = header[2], height = header[6], width = header[7], numFaces = header[10], numMipmaps = header[11];\n        switch (pixelFormat) {\n        case 0:\n            bpp = 2;\n            format = THREE.RGB_PVRTC_2BPPV1_Format;\n            break;\n        case 1:\n            bpp = 2;\n            format = THREE.RGBA_PVRTC_2BPPV1_Format;\n            break;\n        case 2:\n            bpp = 4;\n            format = THREE.RGB_PVRTC_4BPPV1_Format;\n            break;\n        case 3:\n            bpp = 4;\n            format = THREE.RGBA_PVRTC_4BPPV1_Format;\n            break;\n        default:\n            console.error('THREE.PVRLoader: Unsupported PVR format:', pixelFormat);\n        }\n        pvrDatas.dataPtr = 52 + metaLen;\n        pvrDatas.bpp = bpp;\n        pvrDatas.format = format;\n        pvrDatas.width = width;\n        pvrDatas.height = height;\n        pvrDatas.numSurfaces = numFaces;\n        pvrDatas.numMipmaps = numMipmaps;\n        pvrDatas.isCubemap = numFaces === 6;\n        return PVRLoader._extract(pvrDatas);\n    };\n    PVRLoader._parseV2 = function (pvrDatas) {\n        var header = pvrDatas.header;\n        var headerLength = header[0], height = header[1], width = header[2], numMipmaps = header[3], flags = header[4], bitmaskAlpha = header[10], numSurfs = header[12];\n        var TYPE_MASK = 255;\n        var PVRTC_2 = 24, PVRTC_4 = 25;\n        var formatFlags = flags & TYPE_MASK;\n        var bpp, format;\n        var _hasAlpha = bitmaskAlpha > 0;\n        if (formatFlags === PVRTC_4) {\n            format = _hasAlpha ? THREE.RGBA_PVRTC_4BPPV1_Format : THREE.RGB_PVRTC_4BPPV1_Format;\n            bpp = 4;\n        } else if (formatFlags === PVRTC_2) {\n            format = _hasAlpha ? THREE.RGBA_PVRTC_2BPPV1_Format : THREE.RGB_PVRTC_2BPPV1_Format;\n            bpp = 2;\n        } else {\n            console.error('THREE.PVRLoader: Unknown PVR format:', formatFlags);\n        }\n        pvrDatas.dataPtr = headerLength;\n        pvrDatas.bpp = bpp;\n        pvrDatas.format = format;\n        pvrDatas.width = width;\n        pvrDatas.height = height;\n        pvrDatas.numSurfaces = numSurfs;\n        pvrDatas.numMipmaps = numMipmaps + 1;\n        pvrDatas.isCubemap = numSurfs === 6;\n        return PVRLoader._extract(pvrDatas);\n    };\n    PVRLoader._extract = function (pvrDatas) {\n        var pvr = {\n            mipmaps: [],\n            width: pvrDatas.width,\n            height: pvrDatas.height,\n            format: pvrDatas.format,\n            mipmapCount: pvrDatas.numMipmaps,\n            isCubemap: pvrDatas.isCubemap\n        };\n        var buffer = pvrDatas.buffer;\n        var dataOffset = pvrDatas.dataPtr, bpp = pvrDatas.bpp, numSurfs = pvrDatas.numSurfaces, dataSize = 0, blockSize = 0, blockWidth = 0, blockHeight = 0, widthBlocks = 0, heightBlocks = 0;\n        if (bpp === 2) {\n            blockWidth = 8;\n            blockHeight = 4;\n        } else {\n            blockWidth = 4;\n            blockHeight = 4;\n        }\n        blockSize = blockWidth * blockHeight * bpp / 8;\n        pvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;\n        var mipLevel = 0;\n        while (mipLevel < pvrDatas.numMipmaps) {\n            var sWidth = pvrDatas.width >> mipLevel, sHeight = pvrDatas.height >> mipLevel;\n            widthBlocks = sWidth / blockWidth;\n            heightBlocks = sHeight / blockHeight;\n            if (widthBlocks < 2)\n                widthBlocks = 2;\n            if (heightBlocks < 2)\n                heightBlocks = 2;\n            dataSize = widthBlocks * heightBlocks * blockSize;\n            for (var surfIndex = 0; surfIndex < numSurfs; surfIndex++) {\n                var byteArray = new Uint8Array(buffer, dataOffset, dataSize);\n                var mipmap = {\n                    data: byteArray,\n                    width: sWidth,\n                    height: sHeight\n                };\n                pvr.mipmaps[surfIndex * pvrDatas.numMipmaps + mipLevel] = mipmap;\n                dataOffset += dataSize;\n            }\n            mipLevel++;\n        }\n        return pvr;\n    };\n    return threex.loaders.PVRLoader = PVRLoader;\n});"]}