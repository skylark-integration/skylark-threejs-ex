{"version":3,"sources":["loaders/PVRLoader.js"],"names":["define","THREE","threex","PVRLoader","manager","CompressedTextureLoader","call","this","prototype","Object","assign","create","constructor","parse","buffer","loadMipmaps","header","Uint32Array","pvrDatas","_parseV3","_parseV2","console","error","bpp","format","metaLen","pixelFormat","height","width","numFaces","numMipmaps","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_PVRTC_4BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","dataPtr","numSurfaces","isCubemap","_extract","headerLength","flags","bitmaskAlpha","numSurfs","formatFlags","_hasAlpha","blockSize","pvr","mipmaps","mipmapCount","dataOffset","dataSize","blockWidth","blockHeight","widthBlocks","heightBlocks","length","mipLevel","sWidth","sHeight","surfIndex","mipmap","data","Uint8Array","loaders"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,EAAY,SAAUC,GACtBH,EAAMI,wBAAwBC,KAAKC,KAAMH,IA8H7C,OA5HAD,EAAUK,UAAYC,OAAOC,OAAOD,OAAOE,OAAOV,EAAMI,wBAAwBG,YAC5EI,YAAaT,EACbU,MAAO,SAAUC,EAAQC,GACrB,IACIC,EAAS,IAAIC,YAAYH,EAAQ,EADf,IAElBI,GACAJ,OAAQA,EACRE,OAAQA,EACRD,YAAaA,GAEjB,OAAkB,WAAdC,EAAO,GACAb,EAAUgB,SAASD,GACJ,YAAfF,EAAO,IACPb,EAAUiB,SAASF,QAE1BG,QAAQC,MAAM,2CAI1BnB,EAAUgB,SAAW,SAAUD,GAC3B,IACIK,EAAKC,EADLR,EAASE,EAASF,OAElBS,EAAUT,EAAO,IAAKU,EAAcV,EAAO,GAAIW,EAASX,EAAO,GAAIY,EAAQZ,EAAO,GAAIa,EAAWb,EAAO,IAAKc,EAAad,EAAO,IACrI,OAAQU,GACR,KAAK,EACDH,EAAM,EACNC,EAASvB,EAAM8B,wBACf,MACJ,KAAK,EACDR,EAAM,EACNC,EAASvB,EAAM+B,yBACf,MACJ,KAAK,EACDT,EAAM,EACNC,EAASvB,EAAMgC,wBACf,MACJ,KAAK,EACDV,EAAM,EACNC,EAASvB,EAAMiC,yBACf,MACJ,QACIb,QAAQC,MAAM,2CAA4CI,GAU9D,OARAR,EAASiB,QAAU,GAAKV,EACxBP,EAASK,IAAMA,EACfL,EAASM,OAASA,EAClBN,EAASU,MAAQA,EACjBV,EAASS,OAASA,EAClBT,EAASkB,YAAcP,EACvBX,EAASY,WAAaA,EACtBZ,EAASmB,UAAyB,IAAbR,EACd1B,EAAUmC,SAASpB,IAE9Bf,EAAUiB,SAAW,SAAUF,GAC3B,IAKIK,EAAKC,EALLR,EAASE,EAASF,OAClBuB,EAAevB,EAAO,GAAIW,EAASX,EAAO,GAAIY,EAAQZ,EAAO,GAAIc,EAAad,EAAO,GAAIwB,EAAQxB,EAAO,GAAIyB,EAAezB,EAAO,IAAK0B,EAAW1B,EAAO,IAGzJ2B,EAFY,IAEEH,EAEdI,EAAYH,EAAe,EAkB/B,OArB4B,KAIxBE,GACAnB,EAASoB,EAAY3C,EAAMiC,yBAA2BjC,EAAMgC,wBAC5DV,EAAM,GANI,KAOHoB,GACPnB,EAASoB,EAAY3C,EAAM+B,yBAA2B/B,EAAM8B,wBAC5DR,EAAM,GAENF,QAAQC,MAAM,uCAAwCqB,GAE1DzB,EAASiB,QAAUI,EACnBrB,EAASK,IAAMA,EACfL,EAASM,OAASA,EAClBN,EAASU,MAAQA,EACjBV,EAASS,OAASA,EAClBT,EAASkB,YAAcM,EACvBxB,EAASY,WAAaA,EAAa,EACnCZ,EAASmB,UAAyB,IAAbK,EACdvC,EAAUmC,SAASpB,IAE9Bf,EAAUmC,SAAW,SAAUpB,GAC3B,IASsG2B,EATlGC,GACAC,WACAnB,MAAOV,EAASU,MAChBD,OAAQT,EAASS,OACjBH,OAAQN,EAASM,OACjBwB,YAAa9B,EAASY,WACtBO,UAAWnB,EAASmB,WAEpBvB,EAASI,EAASJ,OAClBmC,EAAa/B,EAASiB,QAASZ,EAAML,EAASK,IAAKmB,EAAWxB,EAASkB,YAAac,EAAW,EAAkBC,EAAa,EAAGC,EAAc,EAAGC,EAAc,EAAGC,EAAe,EAC1K,IAAR/B,GACA4B,EAAa,EACbC,EAAc,IAEdD,EAAa,EACbC,EAAc,GAElBP,EAAYM,EAAaC,EAAc7B,EAAM,EAC7CuB,EAAIC,QAAQQ,OAASrC,EAASY,WAAaY,EAE3C,IADA,IAAIc,EAAW,EACRA,EAAWtC,EAASY,YAAY,CACnC,IAAI2B,EAASvC,EAASU,OAAS4B,EAAUE,EAAUxC,EAASS,QAAU6B,EAEtEF,EAAeI,EAAUN,GADzBC,EAAcI,EAASN,GAEL,IACdE,EAAc,GACdC,EAAe,IACfA,EAAe,GACnBJ,EAAWG,EAAcC,EAAeT,EACxC,IAAK,IAAIc,EAAY,EAAGA,EAAYjB,EAAUiB,IAAa,CACvD,IACIC,GACAC,KAFY,IAAIC,WAAWhD,EAAQmC,EAAYC,GAG/CtB,MAAO6B,EACP9B,OAAQ+B,GAEZZ,EAAIC,QAAQY,EAAYzC,EAASY,WAAa0B,GAAYI,EAC1DX,GAAcC,EAElBM,IAEJ,OAAOV,GAEJ5C,EAAO6D,QAAQ5D,UAAYA","file":"../../loaders/PVRLoader.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var PVRLoader = function (manager) {\r\n        THREE.CompressedTextureLoader.call(this, manager);\r\n    };\r\n    PVRLoader.prototype = Object.assign(Object.create(THREE.CompressedTextureLoader.prototype), {\r\n        constructor: PVRLoader,\r\n        parse: function (buffer, loadMipmaps) {\r\n            var headerLengthInt = 13;\r\n            var header = new Uint32Array(buffer, 0, headerLengthInt);\r\n            var pvrDatas = {\r\n                buffer: buffer,\r\n                header: header,\r\n                loadMipmaps: loadMipmaps\r\n            };\r\n            if (header[0] === 55727696) {\r\n                return PVRLoader._parseV3(pvrDatas);\r\n            } else if (header[11] === 559044176) {\r\n                return PVRLoader._parseV2(pvrDatas);\r\n            } else {\r\n                console.error('THREE.PVRLoader: Unknown PVR format.');\r\n            }\r\n        }\r\n    });\r\n    PVRLoader._parseV3 = function (pvrDatas) {\r\n        var header = pvrDatas.header;\r\n        var bpp, format;\r\n        var metaLen = header[12], pixelFormat = header[2], height = header[6], width = header[7], numFaces = header[10], numMipmaps = header[11];\r\n        switch (pixelFormat) {\r\n        case 0:\r\n            bpp = 2;\r\n            format = THREE.RGB_PVRTC_2BPPV1_Format;\r\n            break;\r\n        case 1:\r\n            bpp = 2;\r\n            format = THREE.RGBA_PVRTC_2BPPV1_Format;\r\n            break;\r\n        case 2:\r\n            bpp = 4;\r\n            format = THREE.RGB_PVRTC_4BPPV1_Format;\r\n            break;\r\n        case 3:\r\n            bpp = 4;\r\n            format = THREE.RGBA_PVRTC_4BPPV1_Format;\r\n            break;\r\n        default:\r\n            console.error('THREE.PVRLoader: Unsupported PVR format:', pixelFormat);\r\n        }\r\n        pvrDatas.dataPtr = 52 + metaLen;\r\n        pvrDatas.bpp = bpp;\r\n        pvrDatas.format = format;\r\n        pvrDatas.width = width;\r\n        pvrDatas.height = height;\r\n        pvrDatas.numSurfaces = numFaces;\r\n        pvrDatas.numMipmaps = numMipmaps;\r\n        pvrDatas.isCubemap = numFaces === 6;\r\n        return PVRLoader._extract(pvrDatas);\r\n    };\r\n    PVRLoader._parseV2 = function (pvrDatas) {\r\n        var header = pvrDatas.header;\r\n        var headerLength = header[0], height = header[1], width = header[2], numMipmaps = header[3], flags = header[4], bitmaskAlpha = header[10], numSurfs = header[12];\r\n        var TYPE_MASK = 255;\r\n        var PVRTC_2 = 24, PVRTC_4 = 25;\r\n        var formatFlags = flags & TYPE_MASK;\r\n        var bpp, format;\r\n        var _hasAlpha = bitmaskAlpha > 0;\r\n        if (formatFlags === PVRTC_4) {\r\n            format = _hasAlpha ? THREE.RGBA_PVRTC_4BPPV1_Format : THREE.RGB_PVRTC_4BPPV1_Format;\r\n            bpp = 4;\r\n        } else if (formatFlags === PVRTC_2) {\r\n            format = _hasAlpha ? THREE.RGBA_PVRTC_2BPPV1_Format : THREE.RGB_PVRTC_2BPPV1_Format;\r\n            bpp = 2;\r\n        } else {\r\n            console.error('THREE.PVRLoader: Unknown PVR format:', formatFlags);\r\n        }\r\n        pvrDatas.dataPtr = headerLength;\r\n        pvrDatas.bpp = bpp;\r\n        pvrDatas.format = format;\r\n        pvrDatas.width = width;\r\n        pvrDatas.height = height;\r\n        pvrDatas.numSurfaces = numSurfs;\r\n        pvrDatas.numMipmaps = numMipmaps + 1;\r\n        pvrDatas.isCubemap = numSurfs === 6;\r\n        return PVRLoader._extract(pvrDatas);\r\n    };\r\n    PVRLoader._extract = function (pvrDatas) {\r\n        var pvr = {\r\n            mipmaps: [],\r\n            width: pvrDatas.width,\r\n            height: pvrDatas.height,\r\n            format: pvrDatas.format,\r\n            mipmapCount: pvrDatas.numMipmaps,\r\n            isCubemap: pvrDatas.isCubemap\r\n        };\r\n        var buffer = pvrDatas.buffer;\r\n        var dataOffset = pvrDatas.dataPtr, bpp = pvrDatas.bpp, numSurfs = pvrDatas.numSurfaces, dataSize = 0, blockSize = 0, blockWidth = 0, blockHeight = 0, widthBlocks = 0, heightBlocks = 0;\r\n        if (bpp === 2) {\r\n            blockWidth = 8;\r\n            blockHeight = 4;\r\n        } else {\r\n            blockWidth = 4;\r\n            blockHeight = 4;\r\n        }\r\n        blockSize = blockWidth * blockHeight * bpp / 8;\r\n        pvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;\r\n        var mipLevel = 0;\r\n        while (mipLevel < pvrDatas.numMipmaps) {\r\n            var sWidth = pvrDatas.width >> mipLevel, sHeight = pvrDatas.height >> mipLevel;\r\n            widthBlocks = sWidth / blockWidth;\r\n            heightBlocks = sHeight / blockHeight;\r\n            if (widthBlocks < 2)\r\n                widthBlocks = 2;\r\n            if (heightBlocks < 2)\r\n                heightBlocks = 2;\r\n            dataSize = widthBlocks * heightBlocks * blockSize;\r\n            for (var surfIndex = 0; surfIndex < numSurfs; surfIndex++) {\r\n                var byteArray = new Uint8Array(buffer, dataOffset, dataSize);\r\n                var mipmap = {\r\n                    data: byteArray,\r\n                    width: sWidth,\r\n                    height: sHeight\r\n                };\r\n                pvr.mipmaps[surfIndex * pvrDatas.numMipmaps + mipLevel] = mipmap;\r\n                dataOffset += dataSize;\r\n            }\r\n            mipLevel++;\r\n        }\r\n        return pvr;\r\n    };\r\n    return threex.loaders.PVRLoader = PVRLoader;\r\n});"]}