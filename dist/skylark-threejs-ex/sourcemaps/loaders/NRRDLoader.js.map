{"version":3,"sources":["loaders/NRRDLoader.js"],"names":["define","THREE","Volume","Zlib","NRRDLoader","manager","Loader","call","this","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setResponseType","data","parse","_data","_dataPointer","_nativeLittleEndian","Int8Array","Int16Array","buffer","_littleEndian","headerObject","_bytes","type","chunks","undefined","_chunkSize","_array_type","Uint8Array","Uint16Array","Uint32Array","Int32Array","Float32Array","Float64Array","slice","array","chunkSize","u8","byteOffset","byteLength","i","j","k","tmp","flipEndianness","scan","_length","length","_header","_data_start","parseChars","header","field","fn","l","lines","m","_i","_len","split","match","isNrrd","trim","fieldFunctions","Error","encoding","vectors","Vector3","spacings","isNaN","multiplyScalar","parseHeader","subarray","inflate","Gunzip","decompress","start","end","value","number","lengthOfTheResult","sizes","reduce","previous","current","base","result","__array","resultIndex","parsingFunction","parseInt","parseFloat","String","fromCharCode","parseDataAsText","_copy","volume","min_max","computeMinMax","min","max","windowLow","windowHigh","dimensions","xLength","yLength","zLength","spacingX","spacingY","spacingZ","spacing","matrix","Matrix4","_spaceX","_spaceY","space","v","set","inverseMatrix","getInverse","RASDimensions","applyMatrix4","round","toArray","map","Math","abs","lowerThreshold","Infinity","upperThreshold","output","endian","dimension","dim","_ref","_results","push","space origin","space_origin","space directions","f","parts","_j","_len2","_results2"],"mappings":"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","file":"../../loaders/NRRDLoader.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"../misc/Volume\"\n],function(THREE,Volume,Zlib){\n\t/*\n\t *  three.js NRRD file loader\n\t */\n\n\tTHREE.NRRDLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.NRRDLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.NRRDLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( data ) {\n\n\t\t\t\tonLoad( scope.parse( data ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data ) {\n\n\t\t\t// this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X\n\n\t\t\tvar _data = data;\n\n\t\t\tvar _dataPointer = 0;\n\n\t\t\tvar _nativeLittleEndian = new Int8Array( new Int16Array( [ 1 ] ).buffer )[ 0 ] > 0;\n\n\t\t\tvar _littleEndian = true;\n\n\t\t\tvar headerObject = {};\n\n\t\t\tfunction scan( type, chunks ) {\n\n\t\t\t\tif ( chunks === undefined || chunks === null ) {\n\n\t\t\t\t\tchunks = 1;\n\n\t\t\t\t}\n\n\t\t\t\tvar _chunkSize = 1;\n\t\t\t\tvar _array_type = Uint8Array;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t// 1 byte data types\n\t\t\t\t\tcase 'uchar':\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'schar':\n\t\t\t\t\t\t_array_type = Int8Array;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// 2 byte data types\n\t\t\t\t\tcase 'ushort':\n\t\t\t\t\t\t_array_type = Uint16Array;\n\t\t\t\t\t\t_chunkSize = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'sshort':\n\t\t\t\t\t\t_array_type = Int16Array;\n\t\t\t\t\t\t_chunkSize = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// 4 byte data types\n\t\t\t\t\tcase 'uint':\n\t\t\t\t\t\t_array_type = Uint32Array;\n\t\t\t\t\t\t_chunkSize = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'sint':\n\t\t\t\t\t\t_array_type = Int32Array;\n\t\t\t\t\t\t_chunkSize = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\t_array_type = Float32Array;\n\t\t\t\t\t\t_chunkSize = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'complex':\n\t\t\t\t\t\t_array_type = Float64Array;\n\t\t\t\t\t\t_chunkSize = 8;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'double':\n\t\t\t\t\t\t_array_type = Float64Array;\n\t\t\t\t\t\t_chunkSize = 8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// increase the data pointer in-place\n\t\t\t\tvar _bytes = new _array_type( _data.slice( _dataPointer,\n\t\t\t\t\t_dataPointer += chunks * _chunkSize ) );\n\n\t\t\t\t// if required, flip the endianness of the bytes\n\t\t\t\tif ( _nativeLittleEndian != _littleEndian ) {\n\n\t\t\t\t\t// we need to flip here since the format doesn't match the native endianness\n\t\t\t\t\t_bytes = flipEndianness( _bytes, _chunkSize );\n\n\t\t\t\t}\n\n\t\t\t\tif ( chunks == 1 ) {\n\n\t\t\t\t\t// if only one chunk was requested, just return one value\n\t\t\t\t\treturn _bytes[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\t// return the byte array\n\t\t\t\treturn _bytes;\n\n\t\t\t}\n\n\t\t\t//Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js.\n\n\t\t\tfunction flipEndianness( array, chunkSize ) {\n\n\t\t\t\tvar u8 = new Uint8Array( array.buffer, array.byteOffset, array.byteLength );\n\t\t\t\tfor ( var i = 0; i < array.byteLength; i += chunkSize ) {\n\n\t\t\t\t\tfor ( var j = i + chunkSize - 1, k = i; j > k; j --, k ++ ) {\n\n\t\t\t\t\t\tvar tmp = u8[ k ];\n\t\t\t\t\t\tu8[ k ] = u8[ j ];\n\t\t\t\t\t\tu8[ j ] = tmp;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\t//parse the header\n\t\t\tfunction parseHeader( header ) {\n\n\t\t\t\tvar data, field, fn, i, l, lines, m, _i, _len;\n\t\t\t\tlines = header.split( /\\r?\\n/ );\n\t\t\t\tfor ( _i = 0, _len = lines.length; _i < _len; _i ++ ) {\n\n\t\t\t\t\tl = lines[ _i ];\n\t\t\t\t\tif ( l.match( /NRRD\\d+/ ) ) {\n\n\t\t\t\t\t\theaderObject.isNrrd = true;\n\n\t\t\t\t\t} else if ( l.match( /^#/ ) ) {\n\t\t\t\t\t} else if ( m = l.match( /(.*):(.*)/ ) ) {\n\n\t\t\t\t\t\tfield = m[ 1 ].trim();\n\t\t\t\t\t\tdata = m[ 2 ].trim();\n\t\t\t\t\t\tfn = THREE.NRRDLoader.prototype.fieldFunctions[ field ];\n\t\t\t\t\t\tif ( fn ) {\n\n\t\t\t\t\t\t\tfn.call( headerObject, data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\theaderObject[ field ] = data;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ( ! headerObject.isNrrd ) {\n\n\t\t\t\t\tthrow new Error( 'Not an NRRD file' );\n\n\t\t\t\t}\n\t\t\t\tif ( headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2' ) {\n\n\t\t\t\t\tthrow new Error( 'Bzip is not supported' );\n\n\t\t\t\t}\n\t\t\t\tif ( ! headerObject.vectors ) {\n\n\t\t\t\t\t//if no space direction is set, let's use the identity\n\t\t\t\t\theaderObject.vectors = [ new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ) ];\n\t\t\t\t\t//apply spacing if defined\n\t\t\t\t\tif ( headerObject.spacings ) {\n\n\t\t\t\t\t\tfor ( i = 0; i <= 2; i ++ ) {\n\n\t\t\t\t\t\t\tif ( ! isNaN( headerObject.spacings[ i ] ) ) {\n\n\t\t\t\t\t\t\t\theaderObject.vectors[ i ].multiplyScalar( headerObject.spacings[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//parse the data when registred as one of this type : 'text', 'ascii', 'txt'\n\t\t\tfunction parseDataAsText( data, start, end ) {\n\n\t\t\t\tvar number = '';\n\t\t\t\tstart = start || 0;\n\t\t\t\tend = end || data.length;\n\t\t\t\tvar value;\n\t\t\t\t//length of the result is the product of the sizes\n\t\t\t\tvar lengthOfTheResult = headerObject.sizes.reduce( function ( previous, current ) {\n\n\t\t\t\t\treturn previous * current;\n\n\t\t\t\t}, 1 );\n\n\t\t\t\tvar base = 10;\n\t\t\t\tif ( headerObject.encoding === 'hex' ) {\n\n\t\t\t\t\tbase = 16;\n\n\t\t\t\t}\n\n\t\t\t\tvar result = new headerObject.__array( lengthOfTheResult );\n\t\t\t\tvar resultIndex = 0;\n\t\t\t\tvar parsingFunction = parseInt;\n\t\t\t\tif ( headerObject.__array === Float32Array || headerObject.__array === Float64Array ) {\n\n\t\t\t\t\tparsingFunction = parseFloat;\n\n\t\t\t\t}\n\t\t\t\tfor ( var i = start; i < end; i ++ ) {\n\n\t\t\t\t\tvalue = data[ i ];\n\t\t\t\t\t//if value is not a space\n\t\t\t\t\tif ( ( value < 9 || value > 13 ) && value !== 32 ) {\n\n\t\t\t\t\t\tnumber += String.fromCharCode( value );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\t\t\tresult[ resultIndex ] = parsingFunction( number, base );\n\t\t\t\t\t\t\tresultIndex ++;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnumber = '';\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\tresult[ resultIndex ] = parsingFunction( number, base );\n\t\t\t\t\tresultIndex ++;\n\n\t\t\t\t}\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\tvar _bytes = scan( 'uchar', data.byteLength );\n\t\t\tvar _length = _bytes.length;\n\t\t\tvar _header = null;\n\t\t\tvar _data_start = 0;\n\t\t\tvar i;\n\t\t\tfor ( i = 1; i < _length; i ++ ) {\n\n\t\t\t\tif ( _bytes[ i - 1 ] == 10 && _bytes[ i ] == 10 ) {\n\n\t\t\t\t\t// we found two line breaks in a row\n\t\t\t\t\t// now we know what the header is\n\t\t\t\t\t_header = this.parseChars( _bytes, 0, i - 2 );\n\t\t\t\t\t// this is were the data starts\n\t\t\t\t\t_data_start = i + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// parse the header\n\t\t\tparseHeader( _header );\n\n\t\t\tvar _data = _bytes.subarray( _data_start ); // the data without header\n\t\t\tif ( headerObject.encoding === 'gzip' || headerObject.encoding === 'gz' ) {\n\n\t\t\t\t// we need to decompress the datastream\n\t\t\t\t// here we start the unzipping and get a typed Uint8Array back\n\t\t\t\tvar inflate = new Zlib.Gunzip( new Uint8Array( _data ) ); // eslint-disable-line no-undef\n\t\t\t\t_data = inflate.decompress();\n\n\t\t\t} else if ( headerObject.encoding === 'ascii' || headerObject.encoding === 'text' || headerObject.encoding === 'txt' || headerObject.encoding === 'hex' ) {\n\n\t\t\t\t_data = parseDataAsText( _data );\n\n\t\t\t} else if ( headerObject.encoding === 'raw' ) {\n\n\t\t\t\t//we need to copy the array to create a new array buffer, else we retrieve the original arraybuffer with the header\n\t\t\t\tvar _copy = new Uint8Array( _data.length );\n\n\t\t\t\tfor ( var i = 0; i < _data.length; i ++ ) {\n\n\t\t\t\t\t_copy[ i ] = _data[ i ];\n\n\t\t\t\t}\n\n\t\t\t\t_data = _copy;\n\n\t\t\t}\n\t\t\t// .. let's use the underlying array buffer\n\t\t\t_data = _data.buffer;\n\n\t\t\tvar volume = new THREE.Volume();\n\t\t\tvolume.header = headerObject;\n\t\t\t//\n\t\t\t// parse the (unzipped) data to a datastream of the correct type\n\t\t\t//\n\t\t\tvolume.data = new headerObject.__array( _data );\n\t\t\t// get the min and max intensities\n\t\t\tvar min_max = volume.computeMinMax();\n\t\t\tvar min = min_max[ 0 ];\n\t\t\tvar max = min_max[ 1 ];\n\t\t\t// attach the scalar range to the volume\n\t\t\tvolume.windowLow = min;\n\t\t\tvolume.windowHigh = max;\n\n\t\t\t// get the image dimensions\n\t\t\tvolume.dimensions = [ headerObject.sizes[ 0 ], headerObject.sizes[ 1 ], headerObject.sizes[ 2 ] ];\n\t\t\tvolume.xLength = volume.dimensions[ 0 ];\n\t\t\tvolume.yLength = volume.dimensions[ 1 ];\n\t\t\tvolume.zLength = volume.dimensions[ 2 ];\n\t\t\t// spacing\n\t\t\tvar spacingX = ( new THREE.Vector3( headerObject.vectors[ 0 ][ 0 ], headerObject.vectors[ 0 ][ 1 ],\n\t\t\t\theaderObject.vectors[ 0 ][ 2 ] ) ).length();\n\t\t\tvar spacingY = ( new THREE.Vector3( headerObject.vectors[ 1 ][ 0 ], headerObject.vectors[ 1 ][ 1 ],\n\t\t\t\theaderObject.vectors[ 1 ][ 2 ] ) ).length();\n\t\t\tvar spacingZ = ( new THREE.Vector3( headerObject.vectors[ 2 ][ 0 ], headerObject.vectors[ 2 ][ 1 ],\n\t\t\t\theaderObject.vectors[ 2 ][ 2 ] ) ).length();\n\t\t\tvolume.spacing = [ spacingX, spacingY, spacingZ ];\n\n\n\t\t\t// Create IJKtoRAS matrix\n\t\t\tvolume.matrix = new THREE.Matrix4();\n\n\t\t\tvar _spaceX = 1;\n\t\t\tvar _spaceY = 1;\n\t\t\tvar _spaceZ = 1;\n\n\t\t\tif ( headerObject.space == \"left-posterior-superior\" ) {\n\n\t\t\t\t_spaceX = - 1;\n\t\t\t\t_spaceY = - 1;\n\n\t\t\t} else if ( headerObject.space === 'left-anterior-superior' ) {\n\n\t\t\t\t_spaceX = - 1;\n\n\t\t\t}\n\n\n\t\t\tif ( ! headerObject.vectors ) {\n\n\t\t\t\tvolume.matrix.set(\n\t\t\t\t\t_spaceX, 0, 0, 0,\n\t\t\t\t\t0, _spaceY, 0, 0,\n\t\t\t\t\t0, 0, _spaceZ, 0,\n\t\t\t\t\t0, 0, 0, 1 );\n\n\t\t\t} else {\n\n\t\t\t\tvar v = headerObject.vectors;\n\n\t\t\t\tvolume.matrix.set(\n\t\t\t\t\t_spaceX * v[ 0 ][ 0 ], _spaceX * v[ 1 ][ 0 ], _spaceX * v[ 2 ][ 0 ], 0,\n\t\t\t\t\t_spaceY * v[ 0 ][ 1 ], _spaceY * v[ 1 ][ 1 ], _spaceY * v[ 2 ][ 1 ], 0,\n\t\t\t\t\t_spaceZ * v[ 0 ][ 2 ], _spaceZ * v[ 1 ][ 2 ], _spaceZ * v[ 2 ][ 2 ], 0,\n\t\t\t\t\t0, 0, 0, 1 );\n\n\t\t\t}\n\n\t\t\tvolume.inverseMatrix = new THREE.Matrix4();\n\t\t\tvolume.inverseMatrix.getInverse( volume.matrix );\n\t\t\tvolume.RASDimensions = ( new THREE.Vector3( volume.xLength, volume.yLength, volume.zLength ) ).applyMatrix4( volume.matrix ).round().toArray().map( Math.abs );\n\n\t\t\t// .. and set the default threshold\n\t\t\t// only if the threshold was not already set\n\t\t\tif ( volume.lowerThreshold === - Infinity ) {\n\n\t\t\t\tvolume.lowerThreshold = min;\n\n\t\t\t}\n\t\t\tif ( volume.upperThreshold === Infinity ) {\n\n\t\t\t\tvolume.upperThreshold = max;\n\n\t\t\t}\n\n\t\t\treturn volume;\n\n\t\t},\n\n\t\tparseChars: function ( array, start, end ) {\n\n\t\t\t// without borders, use the whole array\n\t\t\tif ( start === undefined ) {\n\n\t\t\t\tstart = 0;\n\n\t\t\t}\n\t\t\tif ( end === undefined ) {\n\n\t\t\t\tend = array.length;\n\n\t\t\t}\n\n\t\t\tvar output = '';\n\t\t\t// create and append the chars\n\t\t\tvar i = 0;\n\t\t\tfor ( i = start; i < end; ++ i ) {\n\n\t\t\t\toutput += String.fromCharCode( array[ i ] );\n\n\t\t\t}\n\n\t\t\treturn output;\n\n\t\t},\n\n\t\tfieldFunctions: {\n\n\t\t\ttype: function ( data ) {\n\n\t\t\t\tswitch ( data ) {\n\n\t\t\t\t\tcase 'uchar':\n\t\t\t\t\tcase 'unsigned char':\n\t\t\t\t\tcase 'uint8':\n\t\t\t\t\tcase 'uint8_t':\n\t\t\t\t\t\tthis.__array = Uint8Array;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'signed char':\n\t\t\t\t\tcase 'int8':\n\t\t\t\t\tcase 'int8_t':\n\t\t\t\t\t\tthis.__array = Int8Array;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'short':\n\t\t\t\t\tcase 'short int':\n\t\t\t\t\tcase 'signed short':\n\t\t\t\t\tcase 'signed short int':\n\t\t\t\t\tcase 'int16':\n\t\t\t\t\tcase 'int16_t':\n\t\t\t\t\t\tthis.__array = Int16Array;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'ushort':\n\t\t\t\t\tcase 'unsigned short':\n\t\t\t\t\tcase 'unsigned short int':\n\t\t\t\t\tcase 'uint16':\n\t\t\t\t\tcase 'uint16_t':\n\t\t\t\t\t\tthis.__array = Uint16Array;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'int':\n\t\t\t\t\tcase 'signed int':\n\t\t\t\t\tcase 'int32':\n\t\t\t\t\tcase 'int32_t':\n\t\t\t\t\t\tthis.__array = Int32Array;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'uint':\n\t\t\t\t\tcase 'unsigned int':\n\t\t\t\t\tcase 'uint32':\n\t\t\t\t\tcase 'uint32_t':\n\t\t\t\t\t\tthis.__array = Uint32Array;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tthis.__array = Float32Array;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'double':\n\t\t\t\t\t\tthis.__array = Float64Array;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'Unsupported NRRD data type: ' + data );\n\n\t\t\t\t}\n\n\t\t\t\treturn this.type = data;\n\n\t\t\t},\n\n\t\t\tendian: function ( data ) {\n\n\t\t\t\treturn this.endian = data;\n\n\t\t\t},\n\n\t\t\tencoding: function ( data ) {\n\n\t\t\t\treturn this.encoding = data;\n\n\t\t\t},\n\n\t\t\tdimension: function ( data ) {\n\n\t\t\t\treturn this.dim = parseInt( data, 10 );\n\n\t\t\t},\n\n\t\t\tsizes: function ( data ) {\n\n\t\t\t\tvar i;\n\t\t\t\treturn this.sizes = ( function () {\n\n\t\t\t\t\tvar _i, _len, _ref, _results;\n\t\t\t\t\t_ref = data.split( /\\s+/ );\n\t\t\t\t\t_results = [];\n\t\t\t\t\tfor ( _i = 0, _len = _ref.length; _i < _len; _i ++ ) {\n\n\t\t\t\t\t\ti = _ref[ _i ];\n\t\t\t\t\t\t_results.push( parseInt( i, 10 ) );\n\n\t\t\t\t\t}\n\t\t\t\t\treturn _results;\n\n\t\t\t\t} )();\n\n\t\t\t},\n\n\t\t\tspace: function ( data ) {\n\n\t\t\t\treturn this.space = data;\n\n\t\t\t},\n\n\t\t\t'space origin': function ( data ) {\n\n\t\t\t\treturn this.space_origin = data.split( \"(\" )[ 1 ].split( \")\" )[ 0 ].split( \",\" );\n\n\t\t\t},\n\n\t\t\t'space directions': function ( data ) {\n\n\t\t\t\tvar f, parts, v;\n\t\t\t\tparts = data.match( /\\(.*?\\)/g );\n\t\t\t\treturn this.vectors = ( function () {\n\n\t\t\t\t\tvar _i, _len, _results;\n\t\t\t\t\t_results = [];\n\t\t\t\t\tfor ( _i = 0, _len = parts.length; _i < _len; _i ++ ) {\n\n\t\t\t\t\t\tv = parts[ _i ];\n\t\t\t\t\t\t_results.push( ( function () {\n\n\t\t\t\t\t\t\tvar _j, _len2, _ref, _results2;\n\t\t\t\t\t\t\t_ref = v.slice( 1, - 1 ).split( /,/ );\n\t\t\t\t\t\t\t_results2 = [];\n\t\t\t\t\t\t\tfor ( _j = 0, _len2 = _ref.length; _j < _len2; _j ++ ) {\n\n\t\t\t\t\t\t\t\tf = _ref[ _j ];\n\t\t\t\t\t\t\t\t_results2.push( parseFloat( f ) );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn _results2;\n\n\t\t\t\t\t\t} )() );\n\n\t\t\t\t\t}\n\t\t\t\t\treturn _results;\n\n\t\t\t\t} )();\n\n\t\t\t},\n\n\t\t\tspacings: function ( data ) {\n\n\t\t\t\tvar f, parts;\n\t\t\t\tparts = data.split( /\\s+/ );\n\t\t\t\treturn this.spacings = ( function () {\n\n\t\t\t\t\tvar _i, _len, _results = [];\n\n\t\t\t\t\tfor ( _i = 0, _len = parts.length; _i < _len; _i ++ ) {\n\n\t\t\t\t\t\tf = parts[ _i ];\n\t\t\t\t\t\t_results.push( parseFloat( f ) );\n\n\t\t\t\t\t}\n\t\t\t\t\treturn _results;\n\n\t\t\t\t} )();\n\n\t\t\t}\n\t\t}\n\n\t} );\n\t\n\treturn THREE.NRRDLoader;\n});\n"]}