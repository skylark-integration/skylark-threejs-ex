{"version":3,"sources":["loaders/STLLoader.js"],"names":["define","THREE","threex","STLLoader","manager","Loader","call","this","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setResponseType","text","parse","exception","data","matchDataViewAt","query","reader","offset","i","il","length","getUint8","buffer","binData","array_buffer","Uint8Array","charCodeAt","ensureBinary","DataView","getUint32","byteLength","solid","off","isBinary","r","g","b","colors","defaultR","defaultG","defaultB","alpha","faces","hasColors","index","Float32Array","geometry","BufferGeometry","vertices","normals","face","start","normalX","getFloat32","normalY","normalZ","packedColor","getUint16","vertexstart","componentIdx","setAttribute","BufferAttribute","parseBinary","result","patternSolid","patternFace","faceCounter","patternFloat","source","patternVertex","RegExp","patternNormal","normal","Vector3","groupCount","startVertex","endVertex","exec","vertexCountPerFace","normalCountPerFace","x","parseFloat","y","z","push","console","error","count","addGroup","Float32BufferAttribute","parseASCII","LoaderUtils","decodeText","loaders"],"mappings":"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","file":"../../loaders/STLLoader.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    var STLLoader = function (manager) {\n        THREE.Loader.call(this, manager);\n    };\n    STLLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {\n        constructor: STLLoader,\n        load: function (url, onLoad, onProgress, onError) {\n            var scope = this;\n            var loader = new THREE.FileLoader(scope.manager);\n            loader.setPath(scope.path);\n            loader.setResponseType('arraybuffer');\n            loader.load(url, function (text) {\n                try {\n                    onLoad(scope.parse(text));\n                } catch (exception) {\n                    if (onError) {\n                        onError(exception);\n                    }\n                }\n            }, onProgress, onError);\n        },\n        parse: function (data) {\n            function isBinary(data) {\n                var expect, face_size, n_faces, reader;\n                reader = new DataView(data);\n                face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\n                n_faces = reader.getUint32(80, true);\n                expect = 80 + 32 / 8 + n_faces * face_size;\n                if (expect === reader.byteLength) {\n                    return true;\n                }\n                var solid = [\n                    115,\n                    111,\n                    108,\n                    105,\n                    100\n                ];\n                for (var off = 0; off < 5; off++) {\n                    if (matchDataViewAt(solid, reader, off))\n                        return false;\n                }\n                return true;\n            }\n            function matchDataViewAt(query, reader, offset) {\n                for (var i = 0, il = query.length; i < il; i++) {\n                    if (query[i] !== reader.getUint8(offset + i, false))\n                        return false;\n                }\n                return true;\n            }\n            function parseBinary(data) {\n                var reader = new DataView(data);\n                var faces = reader.getUint32(80, true);\n                var r, g, b, hasColors = false, colors;\n                var defaultR, defaultG, defaultB, alpha;\n                for (var index = 0; index < 80 - 10; index++) {\n                    if (reader.getUint32(index, false) == 1129270351 && reader.getUint8(index + 4) == 82 && reader.getUint8(index + 5) == 61) {\n                        hasColors = true;\n                        colors = new Float32Array(faces * 3 * 3);\n                        defaultR = reader.getUint8(index + 6) / 255;\n                        defaultG = reader.getUint8(index + 7) / 255;\n                        defaultB = reader.getUint8(index + 8) / 255;\n                        alpha = reader.getUint8(index + 9) / 255;\n                    }\n                }\n                var dataOffset = 84;\n                var faceLength = 12 * 4 + 2;\n                var geometry = new THREE.BufferGeometry();\n                var vertices = new Float32Array(faces * 3 * 3);\n                var normals = new Float32Array(faces * 3 * 3);\n                for (var face = 0; face < faces; face++) {\n                    var start = dataOffset + face * faceLength;\n                    var normalX = reader.getFloat32(start, true);\n                    var normalY = reader.getFloat32(start + 4, true);\n                    var normalZ = reader.getFloat32(start + 8, true);\n                    if (hasColors) {\n                        var packedColor = reader.getUint16(start + 48, true);\n                        if ((packedColor & 32768) === 0) {\n                            r = (packedColor & 31) / 31;\n                            g = (packedColor >> 5 & 31) / 31;\n                            b = (packedColor >> 10 & 31) / 31;\n                        } else {\n                            r = defaultR;\n                            g = defaultG;\n                            b = defaultB;\n                        }\n                    }\n                    for (var i = 1; i <= 3; i++) {\n                        var vertexstart = start + i * 12;\n                        var componentIdx = face * 3 * 3 + (i - 1) * 3;\n                        vertices[componentIdx] = reader.getFloat32(vertexstart, true);\n                        vertices[componentIdx + 1] = reader.getFloat32(vertexstart + 4, true);\n                        vertices[componentIdx + 2] = reader.getFloat32(vertexstart + 8, true);\n                        normals[componentIdx] = normalX;\n                        normals[componentIdx + 1] = normalY;\n                        normals[componentIdx + 2] = normalZ;\n                        if (hasColors) {\n                            colors[componentIdx] = r;\n                            colors[componentIdx + 1] = g;\n                            colors[componentIdx + 2] = b;\n                        }\n                    }\n                }\n                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\n                geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));\n                if (hasColors) {\n                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n                    geometry.hasColors = true;\n                    geometry.alpha = alpha;\n                }\n                return geometry;\n            }\n            function parseASCII(data) {\n                var geometry = new THREE.BufferGeometry();\n                var patternSolid = /solid([\\s\\S]*?)endsolid/g;\n                var patternFace = /facet([\\s\\S]*?)endfacet/g;\n                var faceCounter = 0;\n                var patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n                var patternVertex = new RegExp('vertex' + patternFloat + patternFloat + patternFloat, 'g');\n                var patternNormal = new RegExp('normal' + patternFloat + patternFloat + patternFloat, 'g');\n                var vertices = [];\n                var normals = [];\n                var normal = new THREE.Vector3();\n                var result;\n                var groupCount = 0;\n                var startVertex = 0;\n                var endVertex = 0;\n                while ((result = patternSolid.exec(data)) !== null) {\n                    startVertex = endVertex;\n                    var solid = result[0];\n                    while ((result = patternFace.exec(solid)) !== null) {\n                        var vertexCountPerFace = 0;\n                        var normalCountPerFace = 0;\n                        var text = result[0];\n                        while ((result = patternNormal.exec(text)) !== null) {\n                            normal.x = parseFloat(result[1]);\n                            normal.y = parseFloat(result[2]);\n                            normal.z = parseFloat(result[3]);\n                            normalCountPerFace++;\n                        }\n                        while ((result = patternVertex.exec(text)) !== null) {\n                            vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n                            normals.push(normal.x, normal.y, normal.z);\n                            vertexCountPerFace++;\n                            endVertex++;\n                        }\n                        if (normalCountPerFace !== 1) {\n                            console.error(\"THREE.STLLoader: Something isn't right with the normal of face number \" + faceCounter);\n                        }\n                        if (vertexCountPerFace !== 3) {\n                            console.error(\"THREE.STLLoader: Something isn't right with the vertices of face number \" + faceCounter);\n                        }\n                        faceCounter++;\n                    }\n                    var start = startVertex;\n                    var count = endVertex - startVertex;\n                    geometry.addGroup(start, count, groupCount);\n                    groupCount++;\n                }\n                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n                return geometry;\n            }\n            function ensureString(buffer) {\n                if (typeof buffer !== 'string') {\n                    return THREE.LoaderUtils.decodeText(new Uint8Array(buffer));\n                }\n                return buffer;\n            }\n            function ensureBinary(buffer) {\n                if (typeof buffer === 'string') {\n                    var array_buffer = new Uint8Array(buffer.length);\n                    for (var i = 0; i < buffer.length; i++) {\n                        array_buffer[i] = buffer.charCodeAt(i) & 255;\n                    }\n                    return array_buffer.buffer || array_buffer;\n                } else {\n                    return buffer;\n                }\n            }\n            var binData = ensureBinary(data);\n            return isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data));\n        }\n    });\n\n    return threex.loaders.STLLoader = STLLoader;\n});"]}