{"version":3,"sources":["loaders/STLLoader.js"],"names":["define","THREE","threex","STLLoader","manager","Loader","call","this","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setResponseType","text","parse","exception","data","matchDataViewAt","query","reader","offset","i","il","length","getUint8","buffer","binData","array_buffer","Uint8Array","charCodeAt","ensureBinary","DataView","getUint32","byteLength","solid","off","isBinary","r","g","b","colors","defaultR","defaultG","defaultB","alpha","faces","hasColors","index","Float32Array","geometry","BufferGeometry","vertices","normals","face","start","normalX","getFloat32","normalY","normalZ","packedColor","getUint16","vertexstart","componentIdx","setAttribute","BufferAttribute","parseBinary","result","patternSolid","patternFace","faceCounter","patternFloat","source","patternVertex","RegExp","patternNormal","normal","Vector3","groupCount","startVertex","endVertex","exec","vertexCountPerFace","normalCountPerFace","x","parseFloat","y","z","push","console","error","count","addGroup","Float32BufferAttribute","parseASCII","LoaderUtils","decodeText","loaders"],"mappings":"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","file":"../../loaders/STLLoader.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var STLLoader = function (manager) {\r\n        THREE.Loader.call(this, manager);\r\n    };\r\n    STLLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {\r\n        constructor: STLLoader,\r\n        load: function (url, onLoad, onProgress, onError) {\r\n            var scope = this;\r\n            var loader = new THREE.FileLoader(scope.manager);\r\n            loader.setPath(scope.path);\r\n            loader.setResponseType('arraybuffer');\r\n            loader.load(url, function (text) {\r\n                try {\r\n                    onLoad(scope.parse(text));\r\n                } catch (exception) {\r\n                    if (onError) {\r\n                        onError(exception);\r\n                    }\r\n                }\r\n            }, onProgress, onError);\r\n        },\r\n        parse: function (data) {\r\n            function isBinary(data) {\r\n                var expect, face_size, n_faces, reader;\r\n                reader = new DataView(data);\r\n                face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\r\n                n_faces = reader.getUint32(80, true);\r\n                expect = 80 + 32 / 8 + n_faces * face_size;\r\n                if (expect === reader.byteLength) {\r\n                    return true;\r\n                }\r\n                var solid = [\r\n                    115,\r\n                    111,\r\n                    108,\r\n                    105,\r\n                    100\r\n                ];\r\n                for (var off = 0; off < 5; off++) {\r\n                    if (matchDataViewAt(solid, reader, off))\r\n                        return false;\r\n                }\r\n                return true;\r\n            }\r\n            function matchDataViewAt(query, reader, offset) {\r\n                for (var i = 0, il = query.length; i < il; i++) {\r\n                    if (query[i] !== reader.getUint8(offset + i, false))\r\n                        return false;\r\n                }\r\n                return true;\r\n            }\r\n            function parseBinary(data) {\r\n                var reader = new DataView(data);\r\n                var faces = reader.getUint32(80, true);\r\n                var r, g, b, hasColors = false, colors;\r\n                var defaultR, defaultG, defaultB, alpha;\r\n                for (var index = 0; index < 80 - 10; index++) {\r\n                    if (reader.getUint32(index, false) == 1129270351 && reader.getUint8(index + 4) == 82 && reader.getUint8(index + 5) == 61) {\r\n                        hasColors = true;\r\n                        colors = new Float32Array(faces * 3 * 3);\r\n                        defaultR = reader.getUint8(index + 6) / 255;\r\n                        defaultG = reader.getUint8(index + 7) / 255;\r\n                        defaultB = reader.getUint8(index + 8) / 255;\r\n                        alpha = reader.getUint8(index + 9) / 255;\r\n                    }\r\n                }\r\n                var dataOffset = 84;\r\n                var faceLength = 12 * 4 + 2;\r\n                var geometry = new THREE.BufferGeometry();\r\n                var vertices = new Float32Array(faces * 3 * 3);\r\n                var normals = new Float32Array(faces * 3 * 3);\r\n                for (var face = 0; face < faces; face++) {\r\n                    var start = dataOffset + face * faceLength;\r\n                    var normalX = reader.getFloat32(start, true);\r\n                    var normalY = reader.getFloat32(start + 4, true);\r\n                    var normalZ = reader.getFloat32(start + 8, true);\r\n                    if (hasColors) {\r\n                        var packedColor = reader.getUint16(start + 48, true);\r\n                        if ((packedColor & 32768) === 0) {\r\n                            r = (packedColor & 31) / 31;\r\n                            g = (packedColor >> 5 & 31) / 31;\r\n                            b = (packedColor >> 10 & 31) / 31;\r\n                        } else {\r\n                            r = defaultR;\r\n                            g = defaultG;\r\n                            b = defaultB;\r\n                        }\r\n                    }\r\n                    for (var i = 1; i <= 3; i++) {\r\n                        var vertexstart = start + i * 12;\r\n                        var componentIdx = face * 3 * 3 + (i - 1) * 3;\r\n                        vertices[componentIdx] = reader.getFloat32(vertexstart, true);\r\n                        vertices[componentIdx + 1] = reader.getFloat32(vertexstart + 4, true);\r\n                        vertices[componentIdx + 2] = reader.getFloat32(vertexstart + 8, true);\r\n                        normals[componentIdx] = normalX;\r\n                        normals[componentIdx + 1] = normalY;\r\n                        normals[componentIdx + 2] = normalZ;\r\n                        if (hasColors) {\r\n                            colors[componentIdx] = r;\r\n                            colors[componentIdx + 1] = g;\r\n                            colors[componentIdx + 2] = b;\r\n                        }\r\n                    }\r\n                }\r\n                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\r\n                geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));\r\n                if (hasColors) {\r\n                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\r\n                    geometry.hasColors = true;\r\n                    geometry.alpha = alpha;\r\n                }\r\n                return geometry;\r\n            }\r\n            function parseASCII(data) {\r\n                var geometry = new THREE.BufferGeometry();\r\n                var patternSolid = /solid([\\s\\S]*?)endsolid/g;\r\n                var patternFace = /facet([\\s\\S]*?)endfacet/g;\r\n                var faceCounter = 0;\r\n                var patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\r\n                var patternVertex = new RegExp('vertex' + patternFloat + patternFloat + patternFloat, 'g');\r\n                var patternNormal = new RegExp('normal' + patternFloat + patternFloat + patternFloat, 'g');\r\n                var vertices = [];\r\n                var normals = [];\r\n                var normal = new THREE.Vector3();\r\n                var result;\r\n                var groupCount = 0;\r\n                var startVertex = 0;\r\n                var endVertex = 0;\r\n                while ((result = patternSolid.exec(data)) !== null) {\r\n                    startVertex = endVertex;\r\n                    var solid = result[0];\r\n                    while ((result = patternFace.exec(solid)) !== null) {\r\n                        var vertexCountPerFace = 0;\r\n                        var normalCountPerFace = 0;\r\n                        var text = result[0];\r\n                        while ((result = patternNormal.exec(text)) !== null) {\r\n                            normal.x = parseFloat(result[1]);\r\n                            normal.y = parseFloat(result[2]);\r\n                            normal.z = parseFloat(result[3]);\r\n                            normalCountPerFace++;\r\n                        }\r\n                        while ((result = patternVertex.exec(text)) !== null) {\r\n                            vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\r\n                            normals.push(normal.x, normal.y, normal.z);\r\n                            vertexCountPerFace++;\r\n                            endVertex++;\r\n                        }\r\n                        if (normalCountPerFace !== 1) {\r\n                            console.error(\"THREE.STLLoader: Something isn't right with the normal of face number \" + faceCounter);\r\n                        }\r\n                        if (vertexCountPerFace !== 3) {\r\n                            console.error(\"THREE.STLLoader: Something isn't right with the vertices of face number \" + faceCounter);\r\n                        }\r\n                        faceCounter++;\r\n                    }\r\n                    var start = startVertex;\r\n                    var count = endVertex - startVertex;\r\n                    geometry.addGroup(start, count, groupCount);\r\n                    groupCount++;\r\n                }\r\n                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\r\n                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\r\n                return geometry;\r\n            }\r\n            function ensureString(buffer) {\r\n                if (typeof buffer !== 'string') {\r\n                    return THREE.LoaderUtils.decodeText(new Uint8Array(buffer));\r\n                }\r\n                return buffer;\r\n            }\r\n            function ensureBinary(buffer) {\r\n                if (typeof buffer === 'string') {\r\n                    var array_buffer = new Uint8Array(buffer.length);\r\n                    for (var i = 0; i < buffer.length; i++) {\r\n                        array_buffer[i] = buffer.charCodeAt(i) & 255;\r\n                    }\r\n                    return array_buffer.buffer || array_buffer;\r\n                } else {\r\n                    return buffer;\r\n                }\r\n            }\r\n            var binData = ensureBinary(data);\r\n            return isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data));\r\n        }\r\n    });\r\n\r\n    return threex.loaders.STLLoader = STLLoader;\r\n});"]}