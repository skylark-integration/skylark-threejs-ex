{"version":3,"sources":["loaders/STLLoader.js"],"names":["define","THREE","STLLoader","manager","Loader","call","this","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setResponseType","text","parse","exception","data","matchDataViewAt","query","reader","offset","i","il","length","getUint8","buffer","binData","array_buffer","Uint8Array","charCodeAt","ensureBinary","DataView","getUint32","byteLength","solid","off","isBinary","r","g","b","colors","defaultR","defaultG","defaultB","alpha","faces","hasColors","index","Float32Array","geometry","BufferGeometry","vertices","normals","face","start","normalX","getFloat32","normalY","normalZ","packedColor","getUint16","vertexstart","componentIdx","setAttribute","BufferAttribute","parseBinary","result","patternSolid","patternFace","faceCounter","patternFloat","source","patternVertex","RegExp","patternNormal","normal","Vector3","groupCount","startVertex","endVertex","exec","vertexCountPerFace","normalCountPerFace","x","parseFloat","y","z","push","console","error","count","addGroup","Float32BufferAttribute","parseASCII","LoaderUtils","decodeText"],"mappings":"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","file":"../../loaders/STLLoader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author aleeper / http://adamleeper.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author gero3 / https://github.com/gero3\n\t * @author Mugen87 / https://github.com/Mugen87\n\t * @author neverhood311 / https://github.com/neverhood311\n\t *\n\t * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n\t *\n\t * Supports both binary and ASCII encoded files, with automatic detection of type.\n\t *\n\t * The loader returns a non-indexed buffer geometry.\n\t *\n\t * Limitations:\n\t *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n\t *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n\t *  ASCII decoding assumes file is UTF-8.\n\t *\n\t * Usage:\n\t *  var loader = new THREE.STLLoader();\n\t *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n\t *    scene.add( new THREE.Mesh( geometry ) );\n\t *  });\n\t *\n\t * For binary STLs geometry might contain colors for vertices. To use it:\n\t *  // use the same code to load STL as above\n\t *  if (geometry.hasColors) {\n\t *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });\n\t *  } else { .... }\n\t *  var mesh = new THREE.Mesh( geometry, material );\n\t *\n\t * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\n\t * Groups can be used to assign a different color by defining an array of materials with the same length of\n\t * geometry.groups and passing it to the Mesh constructor:\n\t *\n\t * var mesh = new THREE.Mesh( geometry, material );\n\t *\n\t * For example:\n\t *\n\t *  var materials = [];\n\t *  var nGeometryGroups = geometry.groups.length;\n\t *\n\t *  var colorMap = ...; // Some logic to index colors.\n\t *\n\t *  for (var i = 0; i < nGeometryGroups; i++) {\n\t *\n\t *\t\tvar material = new THREE.MeshPhongMaterial({\n\t *\t\t\tcolor: colorMap[i],\n\t *\t\t\twireframe: false\n\t *\t\t});\n\t *\n\t *  }\n\t *\n\t *  materials.push(material);\n\t *  var mesh = new THREE.Mesh(geometry, materials);\n\t */\n\n\n\tTHREE.STLLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.STLLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.STLLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t\t} catch ( exception ) {\n\n\t\t\t\t\tif ( onError ) {\n\n\t\t\t\t\t\tonError( exception );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( data ) {\n\n\t\t\tfunction isBinary( data ) {\n\n\t\t\t\tvar expect, face_size, n_faces, reader;\n\t\t\t\treader = new DataView( data );\n\t\t\t\tface_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\n\t\t\t\tn_faces = reader.getUint32( 80, true );\n\t\t\t\texpect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\n\n\t\t\t\tif ( expect === reader.byteLength ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n\t\t\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n\t\t\t\t// Search for \"solid\" to start anywhere after those prefixes.\n\n\t\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\t\t\t\tvar solid = [ 115, 111, 108, 105, 100 ];\n\n\t\t\t\tfor ( var off = 0; off < 5; off ++ ) {\n\n\t\t\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n\t\t\t\t\tif ( matchDataViewAt( solid, reader, off ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tfunction matchDataViewAt( query, reader, offset ) {\n\n\t\t\t\t// Check if each byte in query matches the corresponding byte from the current offset\n\n\t\t\t\tfor ( var i = 0, il = query.length; i < il; i ++ ) {\n\n\t\t\t\t\tif ( query[ i ] !== reader.getUint8( offset + i, false ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\tfunction parseBinary( data ) {\n\n\t\t\t\tvar reader = new DataView( data );\n\t\t\t\tvar faces = reader.getUint32( 80, true );\n\n\t\t\t\tvar r, g, b, hasColors = false, colors;\n\t\t\t\tvar defaultR, defaultG, defaultB, alpha;\n\n\t\t\t\t// process STL header\n\t\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\n\t\t\t\tfor ( var index = 0; index < 80 - 10; index ++ ) {\n\n\t\t\t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&\n\t\t\t\t\t\t( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&\n\t\t\t\t\t\t( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {\n\n\t\t\t\t\t\thasColors = true;\n\t\t\t\t\t\tcolors = new Float32Array( faces * 3 * 3 );\n\n\t\t\t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\n\t\t\t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\n\t\t\t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\n\t\t\t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar dataOffset = 84;\n\t\t\t\tvar faceLength = 12 * 4 + 2;\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\tvar vertices = new Float32Array( faces * 3 * 3 );\n\t\t\t\tvar normals = new Float32Array( faces * 3 * 3 );\n\n\t\t\t\tfor ( var face = 0; face < faces; face ++ ) {\n\n\t\t\t\t\tvar start = dataOffset + face * faceLength;\n\t\t\t\t\tvar normalX = reader.getFloat32( start, true );\n\t\t\t\t\tvar normalY = reader.getFloat32( start + 4, true );\n\t\t\t\t\tvar normalZ = reader.getFloat32( start + 8, true );\n\n\t\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\t\tvar packedColor = reader.getUint16( start + 48, true );\n\n\t\t\t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\n\n\t\t\t\t\t\t\t// facet has its own unique color\n\n\t\t\t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\n\t\t\t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\n\t\t\t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tr = defaultR;\n\t\t\t\t\t\t\tg = defaultG;\n\t\t\t\t\t\t\tb = defaultB;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 1; i <= 3; i ++ ) {\n\n\t\t\t\t\t\tvar vertexstart = start + i * 12;\n\t\t\t\t\t\tvar componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );\n\n\t\t\t\t\t\tvertices[ componentIdx ] = reader.getFloat32( vertexstart, true );\n\t\t\t\t\t\tvertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );\n\t\t\t\t\t\tvertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );\n\n\t\t\t\t\t\tnormals[ componentIdx ] = normalX;\n\t\t\t\t\t\tnormals[ componentIdx + 1 ] = normalY;\n\t\t\t\t\t\tnormals[ componentIdx + 2 ] = normalZ;\n\n\t\t\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\t\t\tcolors[ componentIdx ] = r;\n\t\t\t\t\t\t\tcolors[ componentIdx + 1 ] = g;\n\t\t\t\t\t\t\tcolors[ componentIdx + 2 ] = b;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\n\t\t\t\tif ( hasColors ) {\n\n\t\t\t\t\tgeometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\n\t\t\t\t\tgeometry.hasColors = true;\n\t\t\t\t\tgeometry.alpha = alpha;\n\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction parseASCII( data ) {\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tvar patternSolid = /solid([\\s\\S]*?)endsolid/g;\n\t\t\t\tvar patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\t\t\tvar faceCounter = 0;\n\n\t\t\t\tvar patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\t\t\tvar patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );\n\t\t\t\tvar patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );\n\n\t\t\t\tvar vertices = [];\n\t\t\t\tvar normals = [];\n\n\t\t\t\tvar normal = new THREE.Vector3();\n\n\t\t\t\tvar result;\n\n\t\t\t\tvar groupCount = 0;\n\t\t\t\tvar startVertex = 0;\n\t\t\t\tvar endVertex = 0;\n\n\t\t\t\twhile ( ( result = patternSolid.exec( data ) ) !== null ) {\n\n\t\t\t\t\tstartVertex = endVertex;\n\n\t\t\t\t\tvar solid = result[ 0 ];\n\n\t\t\t\t\twhile ( ( result = patternFace.exec( solid ) ) !== null ) {\n\n\t\t\t\t\t\tvar vertexCountPerFace = 0;\n\t\t\t\t\t\tvar normalCountPerFace = 0;\n\n\t\t\t\t\t\tvar text = result[ 0 ];\n\n\t\t\t\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\t\tnormal.x = parseFloat( result[ 1 ] );\n\t\t\t\t\t\t\tnormal.y = parseFloat( result[ 2 ] );\n\t\t\t\t\t\t\tnormal.z = parseFloat( result[ 3 ] );\n\t\t\t\t\t\t\tnormalCountPerFace ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\n\n\t\t\t\t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\n\t\t\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\t\t\t\t\t\t\tvertexCountPerFace ++;\n\t\t\t\t\t\t\tendVertex ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// every face have to own ONE valid normal\n\n\t\t\t\t\t\tif ( normalCountPerFace !== 1 ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// each face have to own THREE valid vertices\n\n\t\t\t\t\t\tif ( vertexCountPerFace !== 3 ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfaceCounter ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar start = startVertex;\n\t\t\t\t\tvar count = endVertex - startVertex;\n\n\t\t\t\t\tgeometry.addGroup( start, count, groupCount );\n\t\t\t\t\tgroupCount ++;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tfunction ensureString( buffer ) {\n\n\t\t\t\tif ( typeof buffer !== 'string' ) {\n\n\t\t\t\t\treturn THREE.LoaderUtils.decodeText( new Uint8Array( buffer ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn buffer;\n\n\t\t\t}\n\n\t\t\tfunction ensureBinary( buffer ) {\n\n\t\t\t\tif ( typeof buffer === 'string' ) {\n\n\t\t\t\t\tvar array_buffer = new Uint8Array( buffer.length );\n\t\t\t\t\tfor ( var i = 0; i < buffer.length; i ++ ) {\n\n\t\t\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn array_buffer.buffer || array_buffer;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn buffer;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// start\n\n\t\t\tvar binData = ensureBinary( data );\n\n\t\t\treturn isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.STLLoader;\n});\n"]}