{"version":3,"sources":["loaders/TGALoader.js"],"names":["define","THREE","TGALoader","manager","Loader","call","this","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","texture","Texture","loader","FileLoader","setResponseType","setPath","path","buffer","image","parse","needsUpdate","undefined","TGA_TYPE_NO_DATA","TGA_TYPE_INDEXED","TGA_TYPE_RGB","TGA_TYPE_GREY","TGA_TYPE_RLE_INDEXED","TGA_TYPE_RLE_RGB","TGA_TYPE_RLE_GREY","TGA_ORIGIN_MASK","TGA_ORIGIN_SHIFT","TGA_ORIGIN_BL","TGA_ORIGIN_BR","TGA_ORIGIN_UL","TGA_ORIGIN_UR","length","console","error","content","Uint8Array","offset","header","id_length","colormap_type","image_type","colormap_index","colormap_length","colormap_size","origin","width","height","pixel_size","flags","tgaCheckHeader","use_rle","use_pal","use_grey","useOffscreen","OffscreenCanvas","canvas","document","createElement","context","getContext","imageData","createImageData","result","data","pixel_data","pixel_total","palettes","subarray","c","count","i","shift","pixels","set","tgaParse","palette","x_start","y_start","x_step","y_step","x_end","y_end","color","x","y","tgaGetImageDataGrey8bits","tgaGetImageDataGrey16bits","colormap","tgaGetImageData8bits","tgaGetImageData16bits","tgaGetImageData24bits","tgaGetImageData32bits","getTgaRGBA","putImageData","transferToImageBitmap"],"mappings":"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","file":"../../loaders/TGALoader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Daosheng Mu / https://github.com/DaoshengMu/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author takahirox / https://github.com/takahirox/\n\t */\n\n\tTHREE.TGALoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t};\n\n\tTHREE.TGALoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.TGALoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar texture = new THREE.Texture();\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\t\t\tloader.setPath( this.path );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\ttexture.image = scope.parse( buffer );\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\t\tonLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\tparse: function ( buffer ) {\n\n\t\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n\t\t\tfunction tgaCheckHeader( header ) {\n\n\t\t\t\tswitch ( header.image_type ) {\n\n\t\t\t\t\t// check indexed type\n\n\t\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\t\tif ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// check colormap type\n\n\t\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\t\tif ( header.colormap_type ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// What the need of a file without data ?\n\n\t\t\t\t\tcase TGA_TYPE_NO_DATA:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t\t\t\t\t// Invalid type ?\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid type \"%s\".', header.image_type );\n\n\t\t\t\t}\n\n\t\t\t\t// check image width and height\n\n\t\t\t\tif ( header.width <= 0 || header.height <= 0 ) {\n\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid image size.' );\n\n\t\t\t\t}\n\n\t\t\t\t// check image pixel size\n\n\t\t\t\tif ( header.pixel_size !== 8 && header.pixel_size !== 16 &&\n\t\t\t\t\theader.pixel_size !== 24 && header.pixel_size !== 32 ) {\n\n\t\t\t\t\tconsole.error( 'THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// parse tga image buffer\n\n\t\t\tfunction tgaParse( use_rle, use_pal, header, offset, data ) {\n\n\t\t\t\tvar pixel_data,\n\t\t\t\t\tpixel_size,\n\t\t\t\t\tpixel_total,\n\t\t\t\t\tpalettes;\n\n\t\t\t\tpixel_size = header.pixel_size >> 3;\n\t\t\t\tpixel_total = header.width * header.height * pixel_size;\n\n\t\t\t\t // read palettes\n\n\t\t\t\t if ( use_pal ) {\n\n\t\t\t\t\t palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );\n\n\t\t\t\t }\n\n\t\t\t\t // read RLE\n\n\t\t\t\t if ( use_rle ) {\n\n\t\t\t\t\t pixel_data = new Uint8Array( pixel_total );\n\n\t\t\t\t\tvar c, count, i;\n\t\t\t\t\tvar shift = 0;\n\t\t\t\t\tvar pixels = new Uint8Array( pixel_size );\n\n\t\t\t\t\twhile ( shift < pixel_total ) {\n\n\t\t\t\t\t\tc = data[ offset ++ ];\n\t\t\t\t\t\tcount = ( c & 0x7f ) + 1;\n\n\t\t\t\t\t\t// RLE pixels\n\n\t\t\t\t\t\tif ( c & 0x80 ) {\n\n\t\t\t\t\t\t\t// bind pixel tmp array\n\n\t\t\t\t\t\t\tfor ( i = 0; i < pixel_size; ++ i ) {\n\n\t\t\t\t\t\t\t\tpixels[ i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// copy pixel array\n\n\t\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\t\tpixel_data.set( pixels, shift + i * pixel_size );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tshift += pixel_size * count;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\t\tcount *= pixel_size;\n\t\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\t\tpixel_data[ shift + i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tshift += count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t } else {\n\n\t\t\t\t\t// raw pixels\n\n\t\t\t\t\tpixel_data = data.subarray(\n\t\t\t\t\t\t offset, offset += ( use_pal ? header.width * header.height : pixel_total )\n\t\t\t\t\t);\n\n\t\t\t\t }\n\n\t\t\t\t return {\n\t\t\t\t\tpixel_data: pixel_data,\n\t\t\t\t\tpalettes: palettes\n\t\t\t\t };\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {\n\n\t\t\t\tvar colormap = palettes;\n\t\t\t\tvar color, i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\t\tvar color, i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\t\tcolor = image[ i + 0 ] + ( image[ i + 1 ] << 8 ); // Inversed ?\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) >> 3;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\t\tvar i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 3 ) {\n\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\t\tvar i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 4 ) {\n\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\t\tvar color, i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = color;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = color;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = color;\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\t\tvar i = 0, x, y;\n\t\t\t\tvar width = header.width;\n\n\t\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn imageData;\n\n\t\t\t}\n\n\t\t\tfunction getTgaRGBA( data, width, height, image, palette ) {\n\n\t\t\t\tvar x_start,\n\t\t\t\t\ty_start,\n\t\t\t\t\tx_step,\n\t\t\t\t\ty_step,\n\t\t\t\t\tx_end,\n\t\t\t\t\ty_end;\n\n\t\t\t\tswitch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {\n\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase TGA_ORIGIN_UL:\n\t\t\t\t\t\tx_start = 0;\n\t\t\t\t\t\tx_step = 1;\n\t\t\t\t\t\tx_end = width;\n\t\t\t\t\t\ty_start = 0;\n\t\t\t\t\t\ty_step = 1;\n\t\t\t\t\t\ty_end = height;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TGA_ORIGIN_BL:\n\t\t\t\t\t\tx_start = 0;\n\t\t\t\t\t\tx_step = 1;\n\t\t\t\t\t\tx_end = width;\n\t\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\t\ty_step = - 1;\n\t\t\t\t\t\ty_end = - 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TGA_ORIGIN_UR:\n\t\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\t\tx_step = - 1;\n\t\t\t\t\t\tx_end = - 1;\n\t\t\t\t\t\ty_start = 0;\n\t\t\t\t\t\ty_step = 1;\n\t\t\t\t\t\ty_end = height;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TGA_ORIGIN_BR:\n\t\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\t\tx_step = - 1;\n\t\t\t\t\t\tx_end = - 1;\n\t\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\t\ty_step = - 1;\n\t\t\t\t\t\ty_end = - 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( use_grey ) {\n\n\t\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\ttgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 16:\n\t\t\t\t\t\t\ttgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\ttgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 16:\n\t\t\t\t\t\t\ttgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 24:\n\t\t\t\t\t\t\ttgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 32:\n\t\t\t\t\t\t\ttgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Load image data according to specific method\n\t\t\t\t// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n\t\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\t\t\t\treturn data;\n\n\t\t\t}\n\n\t\t\t// TGA constants\n\n\t\t\tvar TGA_TYPE_NO_DATA = 0,\n\t\t\t\tTGA_TYPE_INDEXED = 1,\n\t\t\t\tTGA_TYPE_RGB = 2,\n\t\t\t\tTGA_TYPE_GREY = 3,\n\t\t\t\tTGA_TYPE_RLE_INDEXED = 9,\n\t\t\t\tTGA_TYPE_RLE_RGB = 10,\n\t\t\t\tTGA_TYPE_RLE_GREY = 11,\n\n\t\t\t\tTGA_ORIGIN_MASK = 0x30,\n\t\t\t\tTGA_ORIGIN_SHIFT = 0x04,\n\t\t\t\tTGA_ORIGIN_BL = 0x00,\n\t\t\t\tTGA_ORIGIN_BR = 0x01,\n\t\t\t\tTGA_ORIGIN_UL = 0x02,\n\t\t\t\tTGA_ORIGIN_UR = 0x03;\n\n\t\t\tif ( buffer.length < 19 ) console.error( 'THREE.TGALoader: Not enough data to contain header.' );\n\n\t\t\tvar content = new Uint8Array( buffer ),\n\t\t\t\toffset = 0,\n\t\t\t\theader = {\n\t\t\t\t\tid_length: content[ offset ++ ],\n\t\t\t\t\tcolormap_type: content[ offset ++ ],\n\t\t\t\t\timage_type: content[ offset ++ ],\n\t\t\t\t\tcolormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tcolormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tcolormap_size: content[ offset ++ ],\n\t\t\t\t\torigin: [\n\t\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8\n\t\t\t\t\t],\n\t\t\t\t\twidth: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\theight: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tpixel_size: content[ offset ++ ],\n\t\t\t\t\tflags: content[ offset ++ ]\n\t\t\t\t};\n\n\t\t\t// check tga if it is valid format\n\n\t\t\ttgaCheckHeader( header );\n\n\t\t\tif ( header.id_length + offset > buffer.length ) {\n\n\t\t\t\tconsole.error( 'THREE.TGALoader: No data.' );\n\n\t\t\t}\n\n\t\t\t// skip the needn't data\n\n\t\t\toffset += header.id_length;\n\n\t\t\t// get targa information about RLE compression and palette\n\n\t\t\tvar use_rle = false,\n\t\t\t\tuse_pal = false,\n\t\t\t\tuse_grey = false;\n\n\t\t\tswitch ( header.image_type ) {\n\n\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\tuse_rle = true;\n\t\t\t\t\tuse_pal = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\t\tuse_pal = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\t\tuse_rle = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\tuse_rle = true;\n\t\t\t\t\tuse_grey = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\t\tuse_grey = true;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar useOffscreen = typeof OffscreenCanvas !== 'undefined';\n\n\t\t\tvar canvas = useOffscreen ? new OffscreenCanvas( header.width, header.height ) : document.createElement( 'canvas' );\n\t\t\tcanvas.width = header.width;\n\t\t\tcanvas.height = header.height;\n\n\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\tvar imageData = context.createImageData( header.width, header.height );\n\n\t\t\tvar result = tgaParse( use_rle, use_pal, header, offset, content );\n\t\t\tvar rgbaData = getTgaRGBA( imageData.data, header.width, header.height, result.pixel_data, result.palettes );\n\n\t\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\t\treturn useOffscreen ? canvas.transferToImageBitmap() : canvas;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.TGALoader;\n});\n"]}