{"version":3,"sources":["loaders/SVGLoader.js"],"names":["define","THREE","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","SVGLoader","manager","Loader","call","this","defaultDPI","defaultUnit","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","text","parse","parseArcCommand","rx","ry","x_axis_rotation","large_arc_flag","sweep_flag","start","end","Math","PI","abs","dx2","x","dy2","y","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","currentPath","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseStyle","node","style","addStyle","svgName","jsName","adjustFunction","undefined","v","hasAttribute","getAttribute","clamp","parseFloatWithUnits","positive","getReflection","a","b","parseFloats","string","array","split","i","length","number","indexOf","lastIndexOf","splice","units","unitConversion","mm","cm","in","pt","pc","px","theUnit","String","n","u","endsWith","substring","scale","parseFloat","getTransformScaleX","m","te","elements","getTransformScaleY","paths","transformStack","tempTransform0","Matrix3","tempTransform1","tempTransform2","tempTransform3","tempV2","Vector2","tempV3","Vector3","currentTransform","xml","DOMParser","parseFromString","parseNode","nodeType","transform","transformsTexts","tIndex","transformText","trim","openParPos","closeParPos","transformType","substr","identity","tx","ty","translate","angle","rotate","multiplyMatrices","scaleX","scaleY","set","tan","premultiply","parseNodeTransform","copy","push","getNodeTransform","nodeName","ShapePath","point","control","firstPoint","isFirstPoint","doSetFirstPoint","commands","match","l","command","type","charAt","data","numbers","j","jl","moveTo","lineTo","bezierCurveTo","quadraticCurveTo","clone","autoClose","curves","currentPoint","console","warn","parsePathNode","w","h","parseRectNode","index","replace","parsePolygonNode","parsePolylineNode","r","subpath","Path","absarc","subPaths","parseCircleNode","parseEllipseNode","x1","y1","x2","y2","parseLineNode","log","fill","color","setStyle","transfVec2","v2","applyMatrix3","isRotated","isTransformRotated","subPath","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","aX","aY","xRadius","yRadius","transformPath","userData","nodes","childNodes","pop","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","points","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","BufferGeometry","setAttribute","Float32BufferAttribute","vertexOffset","numPoints","dupPoints","distanceTo","newPoints","removeDuplicatedPoints","nextPoint","innerSideModified","joinIsOnLeftSide","isMiter","isClosed","equals","previousPoint","strokeWidth2","deltaU","u0","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","u1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","result","position","center","il","rotateAround","addVectors","vl"],"mappings":"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","file":"../../loaders/SVGLoader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author zz85 / http://joshuakoo.com/\n\t * @author yomboprime / https://yombo.org\n\t */\n\n\tTHREE.SVGLoader = function ( manager ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\t// Default dots per inch\n\t\tthis.defaultDPI = 90;\n\n\t\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\t\tthis.defaultUnit = \"px\";\n\n\t};\n\n\tTHREE.SVGLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.SVGLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader( scope.manager );\n\t\t\tloader.setPath( scope.path );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( text ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tfunction parseNode( node, style ) {\n\n\t\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\t\tvar transform = getNodeTransform( node );\n\n\t\t\t\tvar path = null;\n\n\t\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\t\tcase 'svg':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'g':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'path':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rect':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polygon':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polyline':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'circle':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ellipse':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'line':\n\t\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( node );\n\n\t\t\t\t}\n\n\t\t\t\tif ( path ) {\n\n\t\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\t\tpaths.push( path );\n\n\t\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t\t}\n\n\t\t\t\tvar nodes = node.childNodes;\n\n\t\t\t\tfor ( var i = 0; i < nodes.length; i ++ ) {\n\n\t\t\t\t\tparseNode( nodes[ i ], style );\n\n\t\t\t\t}\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\ttransformStack.pop();\n\n\t\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parsePathNode( node ) {\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\n\t\t\t\tvar point = new THREE.Vector2();\n\t\t\t\tvar control = new THREE.Vector2();\n\n\t\t\t\tvar firstPoint = new THREE.Vector2();\n\t\t\t\tvar isFirstPoint = true;\n\t\t\t\tvar doSetFirstPoint = false;\n\n\t\t\t\tvar d = node.getAttribute( 'd' );\n\n\t\t\t\t// console.log( d );\n\n\t\t\t\tvar commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\t\tfor ( var i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar command = commands[ i ];\n\n\t\t\t\t\tvar type = command.charAt( 0 );\n\t\t\t\t\tvar data = command.substr( 1 ).trim();\n\n\t\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\t\tcase 'M':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'H':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'V':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'C':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'S':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'T':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'm':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'h':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 's':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'q':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 't':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'a':\n\t\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Z':\n\t\t\t\t\t\tcase 'z':\n\t\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t\t * From\n\t\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t\t * To\n\t\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t\t */\n\n\t\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t\t// Ensure radii are positive\n\t\t\t\trx = Math.abs( rx );\n\t\t\t\try = Math.abs( ry );\n\n\t\t\t\t// Compute (x1′, y1′)\n\t\t\t\tvar dx2 = ( start.x - end.x ) / 2.0;\n\t\t\t\tvar dy2 = ( start.y - end.y ) / 2.0;\n\t\t\t\tvar x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\t\tvar y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t\t// Compute (cx′, cy′)\n\t\t\t\tvar rxs = rx * rx;\n\t\t\t\tvar rys = ry * ry;\n\t\t\t\tvar x1ps = x1p * x1p;\n\t\t\t\tvar y1ps = y1p * y1p;\n\n\t\t\t\t// Ensure radii are large enough\n\t\t\t\tvar cr = x1ps / rxs + y1ps / rys;\n\n\t\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\t\tvar s = Math.sqrt( cr );\n\t\t\t\t\trx = s * rx;\n\t\t\t\t\try = s * ry;\n\t\t\t\t\trxs = rx * rx;\n\t\t\t\t\trys = ry * ry;\n\n\t\t\t\t}\n\n\t\t\t\tvar dq = ( rxs * y1ps + rys * x1ps );\n\t\t\t\tvar pq = ( rxs * rys - dq ) / dq;\n\t\t\t\tvar q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\t\tvar cxp = q * rx * y1p / ry;\n\t\t\t\tvar cyp = - q * ry * x1p / rx;\n\n\t\t\t\t// Step 3: Compute (cx, cy) from (cx′, cy′)\n\t\t\t\tvar cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\t\tvar cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t\t// Step 4: Compute θ1 and Δθ\n\t\t\t\tvar theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\t\tvar delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t\t}\n\n\t\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\t\tvar dot = ux * vx + uy * vy;\n\t\t\t\tvar len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\t\tvar ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\t\treturn ang;\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t\t*/\n\t\t\tfunction parseRectNode( node ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\t\t\t\tvar w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\t\tvar h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\t\t\t\tpath.moveTo( x + 2 * rx, y );\n\t\t\t\tpath.lineTo( x + w - 2 * rx, y );\n\t\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry );\n\t\t\t\tpath.lineTo( x + w, y + h - 2 * ry );\n\t\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h );\n\t\t\t\tpath.lineTo( x + 2 * rx, y + h );\n\n\t\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\t\tpath.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );\n\n\t\t\t\t}\n\n\t\t\t\tpath.lineTo( x, y + 2 * ry );\n\n\t\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\t\tpath.bezierCurveTo( x, y, x, y, x + 2 * rx, y );\n\n\t\t\t\t}\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\tfunction parsePolygonNode( node ) {\n\n\t\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\n\t\t\t\tvar index = 0;\n\n\t\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\tfunction parsePolylineNode( node ) {\n\n\t\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex ++;\n\n\t\t\t\t}\n\n\t\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\n\t\t\t\tvar index = 0;\n\n\t\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\tfunction parseCircleNode( node ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\t\tvar r = parseFloatWithUnits( node.getAttribute( 'r' ) );\n\n\t\t\t\tvar subpath = new THREE.Path();\n\t\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\t\t\t\tpath.subPaths.push( subpath );\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\tfunction parseEllipseNode( node ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) );\n\t\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) );\n\n\t\t\t\tvar subpath = new THREE.Path();\n\t\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\t\t\t\tpath.subPaths.push( subpath );\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\tfunction parseLineNode( node ) {\n\n\t\t\t\tvar x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) );\n\t\t\t\tvar y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) );\n\t\t\t\tvar x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) );\n\t\t\t\tvar y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) );\n\n\t\t\t\tvar path = new THREE.ShapePath();\n\t\t\t\tpath.moveTo( x1, y1 );\n\t\t\t\tpath.lineTo( x2, y2 );\n\t\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\t\treturn path;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfunction parseStyle( node, style ) {\n\n\t\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\t\treturn v;\n\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t\t}\n\n\t\t\t\tfunction clamp( v ) {\n\n\t\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tfunction positive( v ) {\n\n\t\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t\t}\n\n\t\t\t\taddStyle( 'fill', 'fill' );\n\t\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\n\t\t\t\treturn style;\n\n\t\t\t}\n\n\t\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\t\tfunction getReflection( a, b ) {\n\n\t\t\t\treturn a - ( b - a );\n\n\t\t\t}\n\n\t\t\tfunction parseFloats( string ) {\n\n\t\t\t\tvar array = string.split( /[\\s,]+|(?=\\s?[+\\-])/ );\n\n\t\t\t\tfor ( var i = 0; i < array.length; i ++ ) {\n\n\t\t\t\t\tvar number = array[ i ];\n\n\t\t\t\t\t// Handle values like 48.6037.7.8\n\t\t\t\t\t// TODO Find a regex for this\n\n\t\t\t\t\tif ( number.indexOf( '.' ) !== number.lastIndexOf( '.' ) ) {\n\n\t\t\t\t\t\tvar split = number.split( '.' );\n\n\t\t\t\t\t\tfor ( var s = 2; s < split.length; s ++ ) {\n\n\t\t\t\t\t\t\tarray.splice( i + s - 1, 0, '0.' + split[ s ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tarray[ i ] = parseFloatWithUnits( number );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\n\t\t\t}\n\n\t\t\t// Units\n\n\t\t\tvar units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\t\tvar unitConversion = {\n\n\t\t\t\t\"mm\": {\n\t\t\t\t\t\"mm\": 1,\n\t\t\t\t\t\"cm\": 0.1,\n\t\t\t\t\t\"in\": 1 / 25.4,\n\t\t\t\t\t\"pt\": 72 / 25.4,\n\t\t\t\t\t\"pc\": 6 / 25.4,\n\t\t\t\t\t\"px\": - 1\n\t\t\t\t},\n\t\t\t\t\"cm\": {\n\t\t\t\t\t\"mm\": 10,\n\t\t\t\t\t\"cm\": 1,\n\t\t\t\t\t\"in\": 1 / 2.54,\n\t\t\t\t\t\"pt\": 72 / 2.54,\n\t\t\t\t\t\"pc\": 6 / 2.54,\n\t\t\t\t\t\"px\": - 1\n\t\t\t\t},\n\t\t\t\t\"in\": {\n\t\t\t\t\t\"mm\": 25.4,\n\t\t\t\t\t\"cm\": 2.54,\n\t\t\t\t\t\"in\": 1,\n\t\t\t\t\t\"pt\": 72,\n\t\t\t\t\t\"pc\": 6,\n\t\t\t\t\t\"px\": - 1\n\t\t\t\t},\n\t\t\t\t\"pt\": {\n\t\t\t\t\t\"mm\": 25.4 / 72,\n\t\t\t\t\t\"cm\": 2.54 / 72,\n\t\t\t\t\t\"in\": 1 / 72,\n\t\t\t\t\t\"pt\": 1,\n\t\t\t\t\t\"pc\": 6 / 72,\n\t\t\t\t\t\"px\": - 1\n\t\t\t\t},\n\t\t\t\t\"pc\": {\n\t\t\t\t\t\"mm\": 25.4 / 6,\n\t\t\t\t\t\"cm\": 2.54 / 6,\n\t\t\t\t\t\"in\": 1 / 6,\n\t\t\t\t\t\"pt\": 72 / 6,\n\t\t\t\t\t\"pc\": 1,\n\t\t\t\t\t\"px\": - 1\n\t\t\t\t},\n\t\t\t\t\"px\": {\n\t\t\t\t\t\"px\": 1\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\t\tvar theUnit = \"px\";\n\n\t\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\t\tfor ( var i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\t\tvar u = units[ i ];\n\n\t\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar scale = undefined;\n\n\t\t\t\tif ( theUnit === \"px\" && scope.defaultUnit !== \"px\" ) {\n\n\t\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\t\tscale = unitConversion[ \"in\" ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\t\tscale = unitConversion[ theUnit ][ \"in\" ] * scope.defaultDPI;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn scale * parseFloat( string );\n\n\t\t\t}\n\n\t\t\t// Transforms\n\n\t\t\tfunction getNodeTransform( node ) {\n\n\t\t\t\tif ( ! node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tvar transform = parseNodeTransform( node );\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tcurrentTransform.copy( transform );\n\t\t\t\ttransformStack.push( transform );\n\n\t\t\t\treturn transform;\n\n\t\t\t}\n\n\t\t\tfunction parseNodeTransform( node ) {\n\n\t\t\t\tvar transform = new THREE.Matrix3();\n\t\t\t\tvar currentTransform = tempTransform0;\n\t\t\t\tvar transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tvar transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tvar openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tvar closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tvar transformType = transformText.substr( 0, openParPos );\n\n\t\t\t\t\t\tvar array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase \"translate\":\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tvar ty = tx;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"rotate\":\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar angle = 0;\n\t\t\t\t\t\t\t\t\tvar cx = 0;\n\t\t\t\t\t\t\t\t\tvar cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"scale\":\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tvar scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tvar scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"skewX\":\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"skewY\":\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase \"matrix\":\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t\treturn transform;\n\n\t\t\t}\n\n\t\t\tfunction transformPath( path, m ) {\n\n\t\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t\t}\n\n\t\t\t\tvar isRotated = isTransformRotated( m );\n\n\t\t\t\tvar subPaths = path.subPaths;\n\n\t\t\t\tfor ( var i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\t\tvar subPath = subPaths[ i ];\n\t\t\t\t\tvar curves = subPath.curves;\n\n\t\t\t\t\tfor ( var j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\t\tvar curve = curves[ j ];\n\n\t\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( \"SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.\" );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction isTransformRotated( m ) {\n\n\t\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t\t}\n\n\t\t\tfunction getTransformScaleX( m ) {\n\n\t\t\t\tvar te = m.elements;\n\t\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t\t}\n\n\t\t\tfunction getTransformScaleY( m ) {\n\n\t\t\t\tvar te = m.elements;\n\t\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar paths = [];\n\n\t\t\tvar transformStack = [];\n\n\t\t\tvar tempTransform0 = new THREE.Matrix3();\n\t\t\tvar tempTransform1 = new THREE.Matrix3();\n\t\t\tvar tempTransform2 = new THREE.Matrix3();\n\t\t\tvar tempTransform3 = new THREE.Matrix3();\n\t\t\tvar tempV2 = new THREE.Vector2();\n\t\t\tvar tempV3 = new THREE.Vector3();\n\n\t\t\tvar currentTransform = new THREE.Matrix3();\n\n\t\t\tvar xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\t\tparseNode( xml.documentElement, {\n\t\t\t\tfill: '#000',\n\t\t\t\tfillOpacity: 1,\n\t\t\t\tstrokeOpacity: 1,\n\t\t\t\tstrokeWidth: 1,\n\t\t\t\tstrokeLineJoin: 'miter',\n\t\t\t\tstrokeLineCap: 'butt',\n\t\t\t\tstrokeMiterLimit: 4\n\t\t\t} );\n\n\t\t\tvar data = { paths: paths, xml: xml.documentElement };\n\n\t\t\t// console.log( paths );\n\t\t\treturn data;\n\n\t\t}\n\n\t} );\n\n\tTHREE.SVGLoader.getStrokeStyle = function ( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t\t// Param width: Stroke width\n\t\t// Param color: As returned by THREE.Color.getStyle()\n\t\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t\t// Returns style object\n\n\t\twidth = width !== undefined ? width : 1;\n\t\tcolor = color !== undefined ? color : '#000';\n\t\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\t\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\t\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\t\treturn {\n\t\t\tstrokeColor: color,\n\t\t\tstrokeWidth: width,\n\t\t\tstrokeLineJoin: lineJoin,\n\t\t\tstrokeLineCap: lineCap,\n\t\t\tstrokeMiterLimit: miterLimit\n\t\t};\n\n\t};\n\n\tTHREE.SVGLoader.pointsToStroke = function ( points, style, arcDivisions, minDistance ) {\n\n\t\t// Generates a stroke with some witdh around the given path.\n\t\t// The path can be open or closed (last point equals to first point)\n\t\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\tif ( THREE.SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n\t\tgeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );\n\n\t\treturn geometry;\n\n\t};\n\n\tTHREE.SVGLoader.pointsToStrokeWithBuffers = function () {\n\n\t\tvar tempV2_1 = new THREE.Vector2();\n\t\tvar tempV2_2 = new THREE.Vector2();\n\t\tvar tempV2_3 = new THREE.Vector2();\n\t\tvar tempV2_4 = new THREE.Vector2();\n\t\tvar tempV2_5 = new THREE.Vector2();\n\t\tvar tempV2_6 = new THREE.Vector2();\n\t\tvar tempV2_7 = new THREE.Vector2();\n\t\tvar lastPointL = new THREE.Vector2();\n\t\tvar lastPointR = new THREE.Vector2();\n\t\tvar point0L = new THREE.Vector2();\n\t\tvar point0R = new THREE.Vector2();\n\t\tvar currentPointL = new THREE.Vector2();\n\t\tvar currentPointR = new THREE.Vector2();\n\t\tvar nextPointL = new THREE.Vector2();\n\t\tvar nextPointR = new THREE.Vector2();\n\t\tvar innerPoint = new THREE.Vector2();\n\t\tvar outerPoint = new THREE.Vector2();\n\n\t\treturn function ( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t\t// This function can be called to update existing arrays or buffers.\n\t\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t\t// First ensure there are no duplicated points\n\t\t\tpoints = removeDuplicatedPoints( points );\n\n\t\t\tvar numPoints = points.length;\n\n\t\t\tif ( numPoints < 2 ) return 0;\n\n\t\t\tvar isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\t\tvar currentPoint;\n\t\t\tvar previousPoint = points[ 0 ];\n\t\t\tvar nextPoint;\n\n\t\t\tvar strokeWidth2 = style.strokeWidth / 2;\n\n\t\t\tvar deltaU = 1 / ( numPoints - 1 );\n\t\t\tvar u0 = 0;\n\n\t\t\tvar innerSideModified;\n\t\t\tvar joinIsOnLeftSide;\n\t\t\tvar isMiter;\n\t\t\tvar initialJoinIsOnLeftSide = false;\n\n\t\t\tvar numVertices = 0;\n\t\t\tvar currentCoordinate = vertexOffset * 3;\n\t\t\tvar currentCoordinateUV = vertexOffset * 2;\n\n\t\t\t// Get initial left and right stroke points\n\t\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\t\tpoint0L.copy( lastPointL );\n\t\t\tpoint0R.copy( lastPointR );\n\n\t\t\tfor ( var iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t\t// Get next point\n\t\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t\t}\n\n\t\t\t\t// Normal of previous segment in tempV2_1\n\t\t\t\tvar normal1 = tempV2_1;\n\t\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tvar u1 = u0 + deltaU;\n\n\t\t\t\tinnerSideModified = false;\n\n\t\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t\t}\n\t\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\t\ttempV2_3.normalize();\n\t\t\t\t\tvar dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t\t// If path is straight, don't create join\n\t\t\t\t\tif ( dot !== 0 ) {\n\n\t\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\t\tvar miterSide = strokeWidth2 / dot;\n\t\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\t\tvar miterLength2 = tempV2_5.length();\n\t\t\t\t\t\tvar segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\t\tvar segmentLengthNext = tempV2_6.length();\n\t\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tvar miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t\t// Start line endcap\n\t\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t\t}\n\n\t\t\t\t// Increment loop variables\n\n\t\t\t\tu0 = u1;\n\n\t\t\t\tpreviousPoint = currentPoint;\n\n\t\t\t\tlastPointL.copy( nextPointL );\n\t\t\t\tlastPointR.copy( nextPointR );\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed ) {\n\n\t\t\t\t// Ending line endcap\n\t\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\t\tvar lastOuter = outerPoint;\n\t\t\t\tvar lastInner = innerPoint;\n\n\t\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\t\tlastOuter = innerPoint;\n\t\t\t\t\tlastInner = outerPoint;\n\n\t\t\t\t}\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn numVertices;\n\n\t\t\t// -- End of algorithm\n\n\t\t\t// -- Functions\n\n\t\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\t\tresult.subVectors( p2, p1 );\n\t\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t\t}\n\n\t\t\tfunction addVertex( position, u, v ) {\n\n\t\t\t\tif ( vertices ) {\n\n\t\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\t\tif ( normals ) {\n\n\t\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnumVertices += 3;\n\n\t\t\t}\n\n\t\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\t\tvar angle = Math.PI;\n\t\t\t\tvar dot = tempV2_1.dot( tempV2_2 );\n\t\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\t\tangle /= arcDivisions;\n\n\t\t\t\ttempV2_3.copy( p1 );\n\n\t\t\t\tfor ( var i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t\t}\n\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( p2, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t}\n\n\t\t\tfunction makeSegmentTriangles() {\n\n\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t\t}\n\n\t\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t\t// param center: End point of the path\n\t\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'square':\n\n\t\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t\tvar vl = vertices.length;\n\n\t\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'butt':\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t// Nothing to do here\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\t\tvar dupPoints = false;\n\t\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\t\tdupPoints = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\t\tvar newPoints = [];\n\t\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\t\treturn newPoints;\n\n\t\t\t}\n\n\t\t};\n\n\t}();\n\t\n\treturn THREE.SVGLoader;\n});\n"]}