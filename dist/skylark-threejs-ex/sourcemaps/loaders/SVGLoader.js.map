{"version":3,"sources":["loaders/SVGLoader.js"],"names":["define","THREE","threex","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","SVGLoader","manager","Loader","call","this","defaultDPI","defaultUnit","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","text","parse","parseArcCommand","rx","ry","x_axis_rotation","large_arc_flag","sweep_flag","start","end","Math","PI","abs","dx2","x","dy2","y","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","currentPath","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseStyle","node","style","addStyle","svgName","jsName","adjustFunction","undefined","v","hasAttribute","getAttribute","clamp","parseFloatWithUnits","positive","getReflection","a","b","parseFloats","string","array","split","i","length","number","indexOf","lastIndexOf","splice","units","unitConversion","mm","cm","in","pt","pc","px","theUnit","String","n","u","endsWith","substring","scale","parseFloat","getTransformScaleX","m","te","elements","getTransformScaleY","paths","transformStack","tempTransform0","Matrix3","tempTransform1","tempTransform2","tempTransform3","tempV2","Vector2","tempV3","Vector3","currentTransform","xml","DOMParser","parseFromString","parseNode","nodeType","transform","transformsTexts","tIndex","transformText","trim","openParPos","closeParPos","transformType","substr","identity","tx","ty","translate","angle","rotate","multiplyMatrices","scaleX","scaleY","set","tan","premultiply","parseNodeTransform","copy","push","getNodeTransform","nodeName","ShapePath","point","control","firstPoint","isFirstPoint","doSetFirstPoint","commands","match","l","command","type","charAt","data","numbers","j","jl","moveTo","lineTo","bezierCurveTo","quadraticCurveTo","clone","autoClose","curves","currentPoint","console","warn","parsePathNode","w","h","parseRectNode","index","replace","parsePolygonNode","parsePolylineNode","r","subpath","Path","absarc","subPaths","parseCircleNode","parseEllipseNode","x1","y1","x2","y2","parseLineNode","log","fill","color","setStyle","transfVec2","v2","applyMatrix3","isRotated","isTransformRotated","subPath","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","aX","aY","xRadius","yRadius","transformPath","userData","nodes","childNodes","pop","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","points","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","BufferGeometry","setAttribute","Float32BufferAttribute","vertexOffset","numPoints","dupPoints","distanceTo","newPoints","removeDuplicatedPoints","nextPoint","innerSideModified","joinIsOnLeftSide","isMiter","isClosed","equals","previousPoint","strokeWidth2","deltaU","u0","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","u1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","result","position","center","il","rotateAround","addVectors","vl","loaders"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAixBQC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAjyBJC,EAAY,SAAUC,GACtBpB,EAAMqB,OAAOC,KAAKC,KAAMH,GACxBG,KAAKC,WAAa,GAClBD,KAAKE,YAAc,MAqrCvB,OAnrCAN,EAAUO,UAAYC,OAAOC,OAAOD,OAAOE,OAAO7B,EAAMqB,OAAOK,YAC3DI,YAAaX,EACbY,KAAM,SAAUC,EAAKC,EAAQC,EAAYC,GACrC,IAAIC,EAAQb,KACRc,EAAS,IAAIrC,EAAMsC,WAAWF,EAAMhB,SACxCiB,EAAOE,QAAQH,EAAMI,MACrBH,EAAON,KAAKC,EAAK,SAAUS,GACvBR,EAAOG,EAAMM,MAAMD,KACpBP,EAAYC,IAEnBO,MAAO,SAAUD,GACb,IAAIL,EAAQb,KAwUZ,SAASoB,EAAgBH,EAAMI,EAAIC,EAAIC,EAAiBC,EAAgBC,EAAYC,EAAOC,GACvFJ,EAAkBA,EAAkBK,KAAKC,GAAK,IAC9CR,EAAKO,KAAKE,IAAIT,GACdC,EAAKM,KAAKE,IAAIR,GACd,IAAIS,GAAOL,EAAMM,EAAIL,EAAIK,GAAK,EAC1BC,GAAOP,EAAMQ,EAAIP,EAAIO,GAAK,EAC1BC,EAAMP,KAAKQ,IAAIb,GAAmBQ,EAAMH,KAAKS,IAAId,GAAmBU,EACpEK,GAAOV,KAAKS,IAAId,GAAmBQ,EAAMH,KAAKQ,IAAIb,GAAmBU,EACrEM,EAAMlB,EAAKA,EACXmB,EAAMlB,EAAKA,EACXmB,EAAON,EAAMA,EACbO,EAAOJ,EAAMA,EACbK,EAAKF,EAAOF,EAAMG,EAAOF,EAC7B,GAAIG,EAAK,EAAG,CACR,IAAIC,EAAIhB,KAAKiB,KAAKF,GAGlBJ,GAFAlB,GAAKuB,GAEMvB,EACXmB,GAFAlB,GAAKsB,GAEMtB,EAEf,IAAIwB,EAAKP,EAAMG,EAAOF,EAAMC,EACxBM,GAAMR,EAAMC,EAAMM,GAAMA,EACxBE,EAAIpB,KAAKiB,KAAKjB,KAAKqB,IAAI,EAAGF,IAC1BvB,IAAmBC,IACnBuB,GAAKA,GACT,IAAIE,EAAMF,EAAI3B,EAAKiB,EAAMhB,EACrB6B,GAAOH,EAAI1B,EAAKa,EAAMd,EACtB+B,EAAKxB,KAAKQ,IAAIb,GAAmB2B,EAAMtB,KAAKS,IAAId,GAAmB4B,GAAOzB,EAAMM,EAAIL,EAAIK,GAAK,EAC7FqB,EAAKzB,KAAKS,IAAId,GAAmB2B,EAAMtB,KAAKQ,IAAIb,GAAmB4B,GAAOzB,EAAMQ,EAAIP,EAAIO,GAAK,EAC7FoB,EAAQC,EAAS,EAAG,GAAIpB,EAAMe,GAAO7B,GAAKiB,EAAMa,GAAO7B,GACvDkC,EAAQD,GAAUpB,EAAMe,GAAO7B,GAAKiB,EAAMa,GAAO7B,IAAMa,EAAMe,GAAO7B,IAAMiB,EAAMa,GAAO7B,IAAiB,EAAVM,KAAKC,IACvGZ,EAAKwC,YAAYC,WAAWN,EAAIC,EAAIhC,EAAIC,EAAIgC,EAAOA,EAAQE,EAAsB,IAAf/B,EAAkBF,GAExF,SAASgC,EAASI,EAAIC,EAAIC,EAAIC,GAC1B,IAAIC,EAAMJ,EAAKE,EAAKD,EAAKE,EACrBE,EAAMpC,KAAKiB,KAAKc,EAAKA,EAAKC,EAAKA,GAAMhC,KAAKiB,KAAKgB,EAAKA,EAAKC,EAAKA,GAC9DG,EAAMrC,KAAKsC,KAAKtC,KAAKqB,KAAK,EAAGrB,KAAKuC,IAAI,EAAGJ,EAAMC,KAGnD,OAFIL,EAAKG,EAAKF,EAAKC,EAAK,IACpBI,GAAOA,GACJA,EA+FX,SAASG,EAAWC,EAAMC,GAEtB,SAASC,EAASC,EAASC,EAAQC,QACRC,IAAnBD,IACAA,EAAiB,SAAcE,GAC3B,OAAOA,IAEXP,EAAKQ,aAAaL,KAClBF,EAAMG,GAAUC,EAAeL,EAAKS,aAAaN,KACjDH,EAAKC,OAAiC,KAAxBD,EAAKC,MAAME,KACzBF,EAAMG,GAAUC,EAAeL,EAAKC,MAAME,KAElD,SAASO,EAAMH,GACX,OAAOhD,KAAKqB,IAAI,EAAGrB,KAAKuC,IAAI,EAAGa,EAAoBJ,KAEvD,SAASK,EAASL,GACd,OAAOhD,KAAKqB,IAAI,EAAG+B,EAAoBJ,IAU3C,OAzBAN,EAAQlE,OAAOC,UAAWiE,GAiB1BC,EAAS,OAAQ,QACjBA,EAAS,eAAgB,cAAeQ,GACxCR,EAAS,SAAU,UACnBA,EAAS,iBAAkB,gBAAiBQ,GAC5CR,EAAS,eAAgB,cAAeU,GACxCV,EAAS,kBAAmB,kBAC5BA,EAAS,iBAAkB,iBAC3BA,EAAS,oBAAqB,mBAAoBU,GAC3CX,EAEX,SAASY,EAAcC,EAAGC,GACtB,OAAOD,GAAKC,EAAID,GAEpB,SAASE,EAAYC,GAEjB,IADA,IAAIC,EAAQD,EAAOE,MAAM,uBAChBC,EAAI,EAAGA,EAAIF,EAAMG,OAAQD,IAAK,CACnC,IAAIE,EAASJ,EAAME,GACnB,GAAIE,EAAOC,QAAQ,OAASD,EAAOE,YAAY,KAE3C,IADA,IAAIL,EAAQG,EAAOH,MAAM,KAChB5C,EAAI,EAAGA,EAAI4C,EAAME,OAAQ9C,IAC9B2C,EAAMO,OAAOL,EAAI7C,EAAI,EAAG,EAAG,KAAO4C,EAAM5C,IAGhD2C,EAAME,GAAKT,EAAoBW,GAEnC,OAAOJ,EAEX,IAAIQ,GACA,KACA,KACA,KACA,KACA,KACA,MAEAC,GACAC,IACIA,GAAM,EACNC,GAAM,GACNC,GAAM,EAAI,KACVC,GAAM,GAAK,KACXC,GAAM,EAAI,KACVC,IAAO,GAEXJ,IACID,GAAM,GACNC,GAAM,EACNC,GAAM,EAAI,KACVC,GAAM,GAAK,KACXC,GAAM,EAAI,KACVC,IAAO,GAEXH,IACIF,GAAM,KACNC,GAAM,KACNC,GAAM,EACNC,GAAM,GACNC,GAAM,EACNC,IAAO,GAEXF,IACIH,GAAM,KAAO,GACbC,GAAM,KAAO,GACbC,GAAM,EAAI,GACVC,GAAM,EACNC,GAAM,EAAI,GACVC,IAAO,GAEXD,IACIJ,GAAM,KAAO,EACbC,GAAM,KAAO,EACbC,GAAM,EAAI,EACVC,GAAM,GACNC,GAAM,EACNC,IAAO,GAEXA,IAAQA,GAAM,IAElB,SAAStB,EAAoBM,GACzB,IAAIiB,EAAU,KACd,GAAsB,iBAAXjB,GAAuBA,aAAkBkB,OAChD,IAAK,IAAIf,EAAI,EAAGgB,EAAIV,EAAML,OAAQD,EAAIgB,EAAGhB,IAAK,CAC1C,IAAIiB,EAAIX,EAAMN,GACd,GAAIH,EAAOqB,SAASD,GAAI,CACpBH,EAAUG,EACVpB,EAASA,EAAOsB,UAAU,EAAGtB,EAAOI,OAASgB,EAAEhB,QAC/C,OAIZ,IAAImB,OAAQlC,EASZ,MARgB,OAAZ4B,GAA0C,OAAtB1F,EAAMX,YAC1B2G,EAAQb,EAAmB,GAAEnF,EAAMX,aAAeW,EAAMZ,YAExD4G,EAAQb,EAAeO,GAAS1F,EAAMX,cAC1B,IACR2G,EAAQb,EAAeO,GAAa,GAAI1F,EAAMZ,YAG/C4G,EAAQC,WAAWxB,GAgI9B,SAASyB,EAAmBC,GACxB,IAAIC,EAAKD,EAAEE,SACX,OAAOtF,KAAKiB,KAAKoE,EAAG,GAAKA,EAAG,GAAKA,EAAG,GAAKA,EAAG,IAEhD,SAASE,EAAmBH,GACxB,IAAIC,EAAKD,EAAEE,SACX,OAAOtF,KAAKiB,KAAKoE,EAAG,GAAKA,EAAG,GAAKA,EAAG,GAAKA,EAAG,IAEhD,IAAIG,KACAC,KACAC,EAAiB,IAAI7I,EAAM8I,QAC3BC,EAAiB,IAAI/I,EAAM8I,QAC3BE,EAAiB,IAAIhJ,EAAM8I,QAC3BG,EAAiB,IAAIjJ,EAAM8I,QAC3BI,EAAS,IAAIlJ,EAAMmJ,QACnBC,EAAS,IAAIpJ,EAAMqJ,QACnBC,EAAmB,IAAItJ,EAAM8I,QAC7BS,GAAM,IAAIC,WAAYC,gBAAgBhH,EAAM,iBAchD,OAjuBA,SAASiH,EAAU9D,EAAMC,GACrB,GAAsB,IAAlBD,EAAK+D,SAAT,CAEA,IAAIC,EAikBR,SAA0BhE,GACtB,IAAKA,EAAKQ,aAAa,aACnB,OAAO,KAEX,IAAIwD,EAQR,SAA4BhE,GAIxB,IAHA,IAAIgE,EAAY,IAAI5J,EAAM8I,QACtBQ,EAAmBT,EACnBgB,EAAkBjE,EAAKS,aAAa,aAAaU,MAAM,KAClD+C,EAASD,EAAgB5C,OAAS,EAAG6C,GAAU,EAAGA,IAAU,CACjE,IAAIC,EAAgBF,EAAgBC,GAAQE,OAC5C,GAAsB,KAAlBD,EAAJ,CAEA,IAAIE,EAAaF,EAAc5C,QAAQ,KACnC+C,EAAcH,EAAc9C,OAChC,GAAIgD,EAAa,GAAKA,EAAaC,EAAa,CAC5C,IAAIC,EAAgBJ,EAAcK,OAAO,EAAGH,GACxCnD,EAAQF,EAAYmD,EAAcK,OAAOH,EAAa,EAAGC,EAAcD,EAAa,IAExF,OADAX,EAAiBe,WACTF,GACR,IAAK,YACD,GAAIrD,EAAMG,QAAU,EAAG,CACnB,IAAIqD,EAAKxD,EAAM,GACXyD,EAAKD,EACLxD,EAAMG,QAAU,IAChBsD,EAAKzD,EAAM,IAEfwC,EAAiBkB,UAAUF,EAAIC,GAEnC,MACJ,IAAK,SACD,GAAIzD,EAAMG,QAAU,EAAG,CACnB,IAAIwD,EAAQ,EACR9F,EAAK,EACLC,EAAK,EACT6F,GAAS3D,EAAM,GAAK3D,KAAKC,GAAK,IAC1B0D,EAAMG,QAAU,IAChBtC,EAAKmC,EAAM,GACXlC,EAAKkC,EAAM,IAEfiC,EAAesB,WAAWG,WAAW7F,GAAKC,GAC1CoE,EAAeqB,WAAWK,OAAOD,GACjCxB,EAAe0B,iBAAiB3B,EAAgBD,GAChDA,EAAesB,WAAWG,UAAU7F,EAAIC,GACxC0E,EAAiBqB,iBAAiB5B,EAAgBE,GAEtD,MACJ,IAAK,QACD,GAAInC,EAAMG,QAAU,EAAG,CACnB,IAAI2D,EAAS9D,EAAM,GACf+D,EAASD,EACT9D,EAAMG,QAAU,IAChB4D,EAAS/D,EAAM,IAEnBwC,EAAiBlB,MAAMwC,EAAQC,GAEnC,MACJ,IAAK,QACoB,IAAjB/D,EAAMG,QACNqC,EAAiBwB,IAAI,EAAG3H,KAAK4H,IAAIjE,EAAM,GAAK3D,KAAKC,GAAK,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAElF,MACJ,IAAK,QACoB,IAAjB0D,EAAMG,QACNqC,EAAiBwB,IAAI,EAAG,EAAG,EAAG3H,KAAK4H,IAAIjE,EAAM,GAAK3D,KAAKC,GAAK,KAAM,EAAG,EAAG,EAAG,EAAG,GAElF,MACJ,IAAK,SACoB,IAAjB0D,EAAMG,QACNqC,EAAiBwB,IAAIhE,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAI,EAAG,EAAG,IAKnG8C,EAAUoB,YAAY1B,IAE1B,OAAOM,EA/ESqB,CAAmBrF,GAMnC,OALIgD,EAAe3B,OAAS,GACxB2C,EAAUoB,YAAYpC,EAAeA,EAAe3B,OAAS,IAEjEqC,EAAiB4B,KAAKtB,GACtBhB,EAAeuC,KAAKvB,GACbA,EA3kBSwB,CAAiBxF,GAC7BpD,EAAO,KACX,OAAQoD,EAAKyF,UACb,IAAK,MACD,MACJ,IAAK,IACDxF,EAAQF,EAAWC,EAAMC,GACzB,MACJ,IAAK,OACDA,EAAQF,EAAWC,EAAMC,GACrBD,EAAKQ,aAAa,OAClB5D,EAqDZ,SAAuBoD,GASnB,IARA,IAAIpD,EAAO,IAAIxC,EAAMsL,UACjBC,EAAQ,IAAIvL,EAAMmJ,QAClBqC,EAAU,IAAIxL,EAAMmJ,QACpBsC,EAAa,IAAIzL,EAAMmJ,QACvBuC,GAAe,EACfC,GAAkB,EAElBC,EADIhG,EAAKS,aAAa,KACTwF,MAAM,wBACd7E,EAAI,EAAG8E,EAAIF,EAAS3E,OAAQD,EAAI8E,EAAG9E,IAAK,CAC7C,IAAI+E,EAAUH,EAAS5E,GACnBgF,EAAOD,EAAQE,OAAO,GACtBC,EAAOH,EAAQ3B,OAAO,GAAGJ,OAK7B,QAJqB,IAAjB0B,IACAC,GAAkB,EAClBD,GAAe,GAEXM,GACR,IAAK,IAED,IADA,IAAIG,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,GAAK,EAC9Cb,EAAMhI,EAAI4I,EAAQC,EAAI,GACtBb,EAAM9H,EAAI0I,EAAQC,EAAI,GACtBZ,EAAQjI,EAAIgI,EAAMhI,EAClBiI,EAAQ/H,EAAI8H,EAAM9H,EACR,IAAN2I,EACA5J,EAAK8J,OAAOf,EAAMhI,EAAGgI,EAAM9H,GAE3BjB,EAAK+J,OAAOhB,EAAMhI,EAAGgI,EAAM9H,GAErB,IAAN2I,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,IACzCb,EAAMhI,EAAI4I,EAAQC,GAClBZ,EAAQjI,EAAIgI,EAAMhI,EAClBiI,EAAQ/H,EAAI8H,EAAM9H,EAClBjB,EAAK+J,OAAOhB,EAAMhI,EAAGgI,EAAM9H,GACjB,IAAN2I,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,IACzCb,EAAM9H,EAAI0I,EAAQC,GAClBZ,EAAQjI,EAAIgI,EAAMhI,EAClBiI,EAAQ/H,EAAI8H,EAAM9H,EAClBjB,EAAK+J,OAAOhB,EAAMhI,EAAGgI,EAAM9H,GACjB,IAAN2I,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,GAAK,EAC9Cb,EAAMhI,EAAI4I,EAAQC,EAAI,GACtBb,EAAM9H,EAAI0I,EAAQC,EAAI,GACtBZ,EAAQjI,EAAIgI,EAAMhI,EAClBiI,EAAQ/H,EAAI8H,EAAM9H,EAClBjB,EAAK+J,OAAOhB,EAAMhI,EAAGgI,EAAM9H,GACjB,IAAN2I,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,GAAK,EAC9C5J,EAAKgK,cAAcL,EAAQC,EAAI,GAAID,EAAQC,EAAI,GAAID,EAAQC,EAAI,GAAID,EAAQC,EAAI,GAAID,EAAQC,EAAI,GAAID,EAAQC,EAAI,IAC/GZ,EAAQjI,EAAI4I,EAAQC,EAAI,GACxBZ,EAAQ/H,EAAI0I,EAAQC,EAAI,GACxBb,EAAMhI,EAAI4I,EAAQC,EAAI,GACtBb,EAAM9H,EAAI0I,EAAQC,EAAI,GACZ,IAANA,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,GAAK,EAC9C5J,EAAKgK,cAAc/F,EAAc8E,EAAMhI,EAAGiI,EAAQjI,GAAIkD,EAAc8E,EAAM9H,EAAG+H,EAAQ/H,GAAI0I,EAAQC,EAAI,GAAID,EAAQC,EAAI,GAAID,EAAQC,EAAI,GAAID,EAAQC,EAAI,IACrJZ,EAAQjI,EAAI4I,EAAQC,EAAI,GACxBZ,EAAQ/H,EAAI0I,EAAQC,EAAI,GACxBb,EAAMhI,EAAI4I,EAAQC,EAAI,GACtBb,EAAM9H,EAAI0I,EAAQC,EAAI,GACZ,IAANA,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,GAAK,EAC9C5J,EAAKiK,iBAAiBN,EAAQC,EAAI,GAAID,EAAQC,EAAI,GAAID,EAAQC,EAAI,GAAID,EAAQC,EAAI,IAClFZ,EAAQjI,EAAI4I,EAAQC,EAAI,GACxBZ,EAAQ/H,EAAI0I,EAAQC,EAAI,GACxBb,EAAMhI,EAAI4I,EAAQC,EAAI,GACtBb,EAAM9H,EAAI0I,EAAQC,EAAI,GACZ,IAANA,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,GAAK,EAAG,CACjD,IAAIxJ,EAAK6D,EAAc8E,EAAMhI,EAAGiI,EAAQjI,GACpCV,EAAK4D,EAAc8E,EAAM9H,EAAG+H,EAAQ/H,GACxCjB,EAAKiK,iBAAiB7J,EAAIC,EAAIsJ,EAAQC,EAAI,GAAID,EAAQC,EAAI,IAC1DZ,EAAQjI,EAAIX,EACZ4I,EAAQ/H,EAAIZ,EACZ0I,EAAMhI,EAAI4I,EAAQC,EAAI,GACtBb,EAAM9H,EAAI0I,EAAQC,EAAI,GACZ,IAANA,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,GAAK,EAAG,CACjD,IAAInJ,EAAQsI,EAAMmB,QAClBnB,EAAMhI,EAAI4I,EAAQC,EAAI,GACtBb,EAAM9H,EAAI0I,EAAQC,EAAI,GACtBZ,EAAQjI,EAAIgI,EAAMhI,EAClBiI,EAAQ/H,EAAI8H,EAAM9H,EAClBd,EAAgBH,EAAM2J,EAAQC,GAAID,EAAQC,EAAI,GAAID,EAAQC,EAAI,GAAID,EAAQC,EAAI,GAAID,EAAQC,EAAI,GAAInJ,EAAOsI,GAC/F,IAANa,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,GAAK,EAC9Cb,EAAMhI,GAAK4I,EAAQC,EAAI,GACvBb,EAAM9H,GAAK0I,EAAQC,EAAI,GACvBZ,EAAQjI,EAAIgI,EAAMhI,EAClBiI,EAAQ/H,EAAI8H,EAAM9H,EACR,IAAN2I,EACA5J,EAAK8J,OAAOf,EAAMhI,EAAGgI,EAAM9H,GAE3BjB,EAAK+J,OAAOhB,EAAMhI,EAAGgI,EAAM9H,GAErB,IAAN2I,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,IACzCb,EAAMhI,GAAK4I,EAAQC,GACnBZ,EAAQjI,EAAIgI,EAAMhI,EAClBiI,EAAQ/H,EAAI8H,EAAM9H,EAClBjB,EAAK+J,OAAOhB,EAAMhI,EAAGgI,EAAM9H,GACjB,IAAN2I,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,IACzCb,EAAM9H,GAAK0I,EAAQC,GACnBZ,EAAQjI,EAAIgI,EAAMhI,EAClBiI,EAAQ/H,EAAI8H,EAAM9H,EAClBjB,EAAK+J,OAAOhB,EAAMhI,EAAGgI,EAAM9H,GACjB,IAAN2I,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,GAAK,EAC9Cb,EAAMhI,GAAK4I,EAAQC,EAAI,GACvBb,EAAM9H,GAAK0I,EAAQC,EAAI,GACvBZ,EAAQjI,EAAIgI,EAAMhI,EAClBiI,EAAQ/H,EAAI8H,EAAM9H,EAClBjB,EAAK+J,OAAOhB,EAAMhI,EAAGgI,EAAM9H,GACjB,IAAN2I,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,GAAK,EAC9C5J,EAAKgK,cAAcjB,EAAMhI,EAAI4I,EAAQC,EAAI,GAAIb,EAAM9H,EAAI0I,EAAQC,EAAI,GAAIb,EAAMhI,EAAI4I,EAAQC,EAAI,GAAIb,EAAM9H,EAAI0I,EAAQC,EAAI,GAAIb,EAAMhI,EAAI4I,EAAQC,EAAI,GAAIb,EAAM9H,EAAI0I,EAAQC,EAAI,IAC3KZ,EAAQjI,EAAIgI,EAAMhI,EAAI4I,EAAQC,EAAI,GAClCZ,EAAQ/H,EAAI8H,EAAM9H,EAAI0I,EAAQC,EAAI,GAClCb,EAAMhI,GAAK4I,EAAQC,EAAI,GACvBb,EAAM9H,GAAK0I,EAAQC,EAAI,GACb,IAANA,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,GAAK,EAC9C5J,EAAKgK,cAAc/F,EAAc8E,EAAMhI,EAAGiI,EAAQjI,GAAIkD,EAAc8E,EAAM9H,EAAG+H,EAAQ/H,GAAI8H,EAAMhI,EAAI4I,EAAQC,EAAI,GAAIb,EAAM9H,EAAI0I,EAAQC,EAAI,GAAIb,EAAMhI,EAAI4I,EAAQC,EAAI,GAAIb,EAAM9H,EAAI0I,EAAQC,EAAI,IAC7LZ,EAAQjI,EAAIgI,EAAMhI,EAAI4I,EAAQC,EAAI,GAClCZ,EAAQ/H,EAAI8H,EAAM9H,EAAI0I,EAAQC,EAAI,GAClCb,EAAMhI,GAAK4I,EAAQC,EAAI,GACvBb,EAAM9H,GAAK0I,EAAQC,EAAI,GACb,IAANA,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,GAAK,EAC9C5J,EAAKiK,iBAAiBlB,EAAMhI,EAAI4I,EAAQC,EAAI,GAAIb,EAAM9H,EAAI0I,EAAQC,EAAI,GAAIb,EAAMhI,EAAI4I,EAAQC,EAAI,GAAIb,EAAM9H,EAAI0I,EAAQC,EAAI,IAC1HZ,EAAQjI,EAAIgI,EAAMhI,EAAI4I,EAAQC,EAAI,GAClCZ,EAAQ/H,EAAI8H,EAAM9H,EAAI0I,EAAQC,EAAI,GAClCb,EAAMhI,GAAK4I,EAAQC,EAAI,GACvBb,EAAM9H,GAAK0I,EAAQC,EAAI,GACb,IAANA,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,GAAK,EAAG,CACjD,IAAIxJ,EAAK6D,EAAc8E,EAAMhI,EAAGiI,EAAQjI,GACpCV,EAAK4D,EAAc8E,EAAM9H,EAAG+H,EAAQ/H,GACxCjB,EAAKiK,iBAAiB7J,EAAIC,EAAI0I,EAAMhI,EAAI4I,EAAQC,EAAI,GAAIb,EAAM9H,EAAI0I,EAAQC,EAAI,IAC9EZ,EAAQjI,EAAIX,EACZ4I,EAAQ/H,EAAIZ,EACZ0I,EAAMhI,EAAIgI,EAAMhI,EAAI4I,EAAQC,EAAI,GAChCb,EAAM9H,EAAI8H,EAAM9H,EAAI0I,EAAQC,EAAI,GACtB,IAANA,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IAED,IADA,IAAIY,EAAUvF,EAAYsF,GACjBE,EAAI,EAAGC,EAAKF,EAAQlF,OAAQmF,EAAIC,EAAID,GAAK,EAAG,CACjD,IAAInJ,EAAQsI,EAAMmB,QAClBnB,EAAMhI,GAAK4I,EAAQC,EAAI,GACvBb,EAAM9H,GAAK0I,EAAQC,EAAI,GACvBZ,EAAQjI,EAAIgI,EAAMhI,EAClBiI,EAAQ/H,EAAI8H,EAAM9H,EAClBd,EAAgBH,EAAM2J,EAAQC,GAAID,EAAQC,EAAI,GAAID,EAAQC,EAAI,GAAID,EAAQC,EAAI,GAAID,EAAQC,EAAI,GAAInJ,EAAOsI,GAC/F,IAANa,IAA+B,IAApBT,GACXF,EAAWP,KAAKK,GAExB,MACJ,IAAK,IACL,IAAK,IACD/I,EAAKwC,YAAY2H,WAAY,EACzBnK,EAAKwC,YAAY4H,OAAO3F,OAAS,IACjCsE,EAAML,KAAKO,GACXjJ,EAAKwC,YAAY6H,aAAa3B,KAAKK,GACnCG,GAAe,GAEnB,MACJ,QACIoB,QAAQC,KAAKhB,GAEjBJ,GAAkB,EAEtB,OAAOnJ,EAvTQwK,CAAcpH,IACzB,MACJ,IAAK,OACDC,EAAQF,EAAWC,EAAMC,GACzBrD,EA8VR,SAAuBoD,GACnB,IAAIrC,EAAIgD,EAAoBX,EAAKS,aAAa,MAAQ,GAClD5C,EAAI8C,EAAoBX,EAAKS,aAAa,MAAQ,GAClDzD,EAAK2D,EAAoBX,EAAKS,aAAa,OAAS,GACpDxD,EAAK0D,EAAoBX,EAAKS,aAAa,OAAS,GACpD4G,EAAI1G,EAAoBX,EAAKS,aAAa,UAC1C6G,EAAI3G,EAAoBX,EAAKS,aAAa,WAC1C7D,EAAO,IAAIxC,EAAMsL,UAgBrB,OAfA9I,EAAK8J,OAAO/I,EAAI,EAAIX,EAAIa,GACxBjB,EAAK+J,OAAOhJ,EAAI0J,EAAI,EAAIrK,EAAIa,IACjB,IAAPb,GAAmB,IAAPC,IACZL,EAAKgK,cAAcjJ,EAAI0J,EAAGxJ,EAAGF,EAAI0J,EAAGxJ,EAAGF,EAAI0J,EAAGxJ,EAAI,EAAIZ,GAC1DL,EAAK+J,OAAOhJ,EAAI0J,EAAGxJ,EAAIyJ,EAAI,EAAIrK,IACpB,IAAPD,GAAmB,IAAPC,IACZL,EAAKgK,cAAcjJ,EAAI0J,EAAGxJ,EAAIyJ,EAAG3J,EAAI0J,EAAGxJ,EAAIyJ,EAAG3J,EAAI0J,EAAI,EAAIrK,EAAIa,EAAIyJ,GACvE1K,EAAK+J,OAAOhJ,EAAI,EAAIX,EAAIa,EAAIyJ,IACjB,IAAPtK,GAAmB,IAAPC,IACZL,EAAKgK,cAAcjJ,EAAGE,EAAIyJ,EAAG3J,EAAGE,EAAIyJ,EAAG3J,EAAGE,EAAIyJ,EAAI,EAAIrK,GAE1DL,EAAK+J,OAAOhJ,EAAGE,EAAI,EAAIZ,IACZ,IAAPD,GAAmB,IAAPC,IACZL,EAAKgK,cAAcjJ,EAAGE,EAAGF,EAAGE,EAAGF,EAAI,EAAIX,EAAIa,GAExCjB,EArXI2K,CAAcvH,GACrB,MACJ,IAAK,UACDC,EAAQF,EAAWC,EAAMC,GACzBrD,EAmXR,SAA0BoD,GAWtB,IACIpD,EAAO,IAAIxC,EAAMsL,UACjB8B,EAAQ,EAGZ,OAFAxH,EAAKS,aAAa,UAAUgH,QAHhB,kCAVZ,SAAkBxB,EAAOnF,EAAGC,GACxB,IAAIpD,EAAIgD,EAAoBG,GACxBjD,EAAI8C,EAAoBI,GACd,IAAVyG,EACA5K,EAAK8J,OAAO/I,EAAGE,GAEfjB,EAAK+J,OAAOhJ,EAAGE,GAEnB2J,MAMJ5K,EAAKwC,YAAY2H,WAAY,EACtBnK,EAnYI8K,CAAiB1H,GACxB,MACJ,IAAK,WACDC,EAAQF,EAAWC,EAAMC,GACzBrD,EAiYR,SAA2BoD,GAWvB,IACIpD,EAAO,IAAIxC,EAAMsL,UACjB8B,EAAQ,EAGZ,OAFAxH,EAAKS,aAAa,UAAUgH,QAHhB,kCAVZ,SAAkBxB,EAAOnF,EAAGC,GACxB,IAAIpD,EAAIgD,EAAoBG,GACxBjD,EAAI8C,EAAoBI,GACd,IAAVyG,EACA5K,EAAK8J,OAAO/I,EAAGE,GAEfjB,EAAK+J,OAAOhJ,EAAGE,GAEnB2J,MAMJ5K,EAAKwC,YAAY2H,WAAY,EACtBnK,EAjZI+K,CAAkB3H,GACzB,MACJ,IAAK,SACDC,EAAQF,EAAWC,EAAMC,GACzBrD,EA+YR,SAAyBoD,GACrB,IAAIrC,EAAIgD,EAAoBX,EAAKS,aAAa,OAC1C5C,EAAI8C,EAAoBX,EAAKS,aAAa,OAC1CmH,EAAIjH,EAAoBX,EAAKS,aAAa,MAC1CoH,EAAU,IAAIzN,EAAM0N,KACxBD,EAAQE,OAAOpK,EAAGE,EAAG+J,EAAG,EAAa,EAAVrK,KAAKC,IAChC,IAAIZ,EAAO,IAAIxC,EAAMsL,UAErB,OADA9I,EAAKoL,SAASzC,KAAKsC,GACZjL,EAvZIqL,CAAgBjI,GACvB,MACJ,IAAK,UACDC,EAAQF,EAAWC,EAAMC,GACzBrD,EAqZR,SAA0BoD,GACtB,IAAIrC,EAAIgD,EAAoBX,EAAKS,aAAa,OAC1C5C,EAAI8C,EAAoBX,EAAKS,aAAa,OAC1CzD,EAAK2D,EAAoBX,EAAKS,aAAa,OAC3CxD,EAAK0D,EAAoBX,EAAKS,aAAa,OAC3CoH,EAAU,IAAIzN,EAAM0N,KACxBD,EAAQxI,WAAW1B,EAAGE,EAAGb,EAAIC,EAAI,EAAa,EAAVM,KAAKC,IACzC,IAAIZ,EAAO,IAAIxC,EAAMsL,UAErB,OADA9I,EAAKoL,SAASzC,KAAKsC,GACZjL,EA9ZIsL,CAAiBlI,GACxB,MACJ,IAAK,OACDC,EAAQF,EAAWC,EAAMC,GACzBrD,EA4ZR,SAAuBoD,GACnB,IAAImI,EAAKxH,EAAoBX,EAAKS,aAAa,OAC3C2H,EAAKzH,EAAoBX,EAAKS,aAAa,OAC3C4H,EAAK1H,EAAoBX,EAAKS,aAAa,OAC3C6H,EAAK3H,EAAoBX,EAAKS,aAAa,OAC3C7D,EAAO,IAAIxC,EAAMsL,UAIrB,OAHA9I,EAAK8J,OAAOyB,EAAIC,GAChBxL,EAAK+J,OAAO0B,EAAIC,GAChB1L,EAAKwC,YAAY2H,WAAY,EACtBnK,EAraI2L,CAAcvI,GACrB,MACJ,QACIkH,QAAQsB,IAAIxI,GAEZpD,SACmB0D,IAAfL,EAAMwI,MAAqC,SAAfxI,EAAMwI,MAClC7L,EAAK8L,MAAMC,SAAS1I,EAAMwI,MA4mBtC,SAAuB7L,EAAM+F,GACzB,SAASiG,EAAWC,GAChBrF,EAAO0B,IAAI2D,EAAGlL,EAAGkL,EAAGhL,EAAG,GAAGiL,aAAanG,GACvCkG,EAAG3D,IAAI1B,EAAO7F,EAAG6F,EAAO3F,GAI5B,IAFA,IAAIkL,EAiCR,SAA4BpG,GACxB,OAAyB,IAAlBA,EAAEE,SAAS,IAA8B,IAAlBF,EAAEE,SAAS,GAlCzBmG,CAAmBrG,GAC/BqF,EAAWpL,EAAKoL,SACX5G,EAAI,EAAGgB,EAAI4F,EAAS3G,OAAQD,EAAIgB,EAAGhB,IAGxC,IAFA,IAAI6H,EAAUjB,EAAS5G,GACnB4F,EAASiC,EAAQjC,OACZR,EAAI,EAAGA,EAAIQ,EAAO3F,OAAQmF,IAAK,CACpC,IAAI0C,EAAQlC,EAAOR,GACf0C,EAAMC,aACNP,EAAWM,EAAME,IACjBR,EAAWM,EAAML,KACVK,EAAMG,oBACbT,EAAWM,EAAMI,IACjBV,EAAWM,EAAME,IACjBR,EAAWM,EAAML,IACjBD,EAAWM,EAAMK,KACVL,EAAMM,wBACbZ,EAAWM,EAAMI,IACjBV,EAAWM,EAAME,IACjBR,EAAWM,EAAML,KACVK,EAAMO,iBACTV,GACA7B,QAAQC,KAAK,8EAEjB7D,EAAO4B,IAAIgE,EAAMQ,GAAIR,EAAMS,IAC3Bf,EAAWtF,GACX4F,EAAMQ,GAAKpG,EAAO3F,EAClBuL,EAAMS,GAAKrG,EAAOzF,EAClBqL,EAAMU,SAAWlH,EAAmBC,GACpCuG,EAAMW,SAAW/G,EAAmBH,KA3oB5CmH,CAAclN,EAAM8G,GACpBX,EAAMwC,KAAK3I,GACXA,EAAKmN,UACD/J,KAAMA,EACNC,MAAOA,IAIf,IADA,IAAI+J,EAAQhK,EAAKiK,WACR7I,EAAI,EAAGA,EAAI4I,EAAM3I,OAAQD,IAC9B0C,EAAUkG,EAAM5I,GAAInB,GAEpB+D,IACAhB,EAAekH,MACXlH,EAAe3B,OAAS,EACxBqC,EAAiB4B,KAAKtC,EAAeA,EAAe3B,OAAS,IAE7DqC,EAAiBe,aAqpB7BX,CAAUH,EAAIwG,iBACV1B,KAAM,OACN2B,YAAa,EACbC,cAAe,EACfC,YAAa,EACbC,eAAgB,QAChBC,cAAe,OACfC,iBAAkB,KAGlB1H,MAAOA,EACPY,IAAKA,EAAIwG,oBAKrB5O,EAAUmP,eAAiB,SAAUC,EAAOjC,EAAOkC,EAAUC,EAASC,GAMlE,OALAH,OAAkBrK,IAAVqK,EAAsBA,EAAQ,GAMlCI,YALJrC,OAAkBpI,IAAVoI,EAAsBA,EAAQ,OAMlC4B,YAAaK,EACbJ,eANJK,OAAwBtK,IAAbsK,EAAyBA,EAAW,QAO3CJ,cANJK,OAAsBvK,IAAZuK,EAAwBA,EAAU,OAOxCJ,iBANJK,OAA4BxK,IAAfwK,EAA2BA,EAAa,IASzDvP,EAAUyP,eAAiB,SAAUC,EAAQhL,EAAOiL,EAAcC,GAC9D,IAAIC,KACAC,KACAC,KACJ,GAA8G,IAA1G/P,EAAUgQ,0BAA0BN,EAAQhL,EAAOiL,EAAcC,EAAaC,EAAUC,EAASC,GACjG,OAAO,KAEX,IAAIE,EAAW,IAAIpR,EAAMqR,eAIzB,OAHAD,EAASE,aAAa,WAAY,IAAItR,EAAMuR,uBAAuBP,EAAU,IAC7EI,EAASE,aAAa,SAAU,IAAItR,EAAMuR,uBAAuBN,EAAS,IAC1EG,EAASE,aAAa,KAAM,IAAItR,EAAMuR,uBAAuBL,EAAK,IAC3DE,GAEXjQ,EAAUgQ,2BACFjR,EAAW,IAAIF,EAAMmJ,QACrBhJ,EAAW,IAAIH,EAAMmJ,QACrB/I,EAAW,IAAIJ,EAAMmJ,QACrB9I,EAAW,IAAIL,EAAMmJ,QACrB7I,EAAW,IAAIN,EAAMmJ,QACrB5I,EAAW,IAAIP,EAAMmJ,QACrB3I,EAAW,IAAIR,EAAMmJ,QACrB1I,EAAa,IAAIT,EAAMmJ,QACvBzI,EAAa,IAAIV,EAAMmJ,QACvBxI,EAAU,IAAIX,EAAMmJ,QACpBvI,EAAU,IAAIZ,EAAMmJ,QACpBtI,EAAgB,IAAIb,EAAMmJ,QAC1BrI,EAAgB,IAAId,EAAMmJ,QAC1BpI,EAAa,IAAIf,EAAMmJ,QACvBnI,EAAa,IAAIhB,EAAMmJ,QACvBlI,EAAa,IAAIjB,EAAMmJ,QACvBjI,EAAa,IAAIlB,EAAMmJ,QACpB,SAAU0H,EAAQhL,EAAOiL,EAAcC,EAAaC,EAAUC,EAASC,EAAKM,GAC/EV,OAAgC5K,IAAjB4K,EAA6BA,EAAe,GAC3DC,OAA8B7K,IAAhB6K,EAA4BA,EAAc,KACxDS,OAAgCtL,IAAjBsL,EAA6BA,EAAe,EAE3D,IAAIC,GADJZ,EA4XA,SAAgCA,GAE5B,IADA,IAAIa,GAAY,EACP1K,EAAI,EAAGgB,EAAI6I,EAAO5J,OAAS,EAAGD,EAAIgB,EAAGhB,IAC1C,GAAI6J,EAAO7J,GAAG2K,WAAWd,EAAO7J,EAAI,IAAM+J,EAAa,CACnDW,GAAY,EACZ,MAGR,IAAKA,EACD,OAAOb,EACX,IAAIe,KACJA,EAAUzG,KAAK0F,EAAO,IACtB,IAAK,IAAI7J,EAAI,EAAGgB,EAAI6I,EAAO5J,OAAS,EAAGD,EAAIgB,EAAGhB,IACtC6J,EAAO7J,GAAG2K,WAAWd,EAAO7J,EAAI,KAAO+J,GACvCa,EAAUzG,KAAK0F,EAAO7J,IAI9B,OADA4K,EAAUzG,KAAK0F,EAAOA,EAAO5J,OAAS,IAC/B2K,EA9YFC,CAAuBhB,IACT5J,OACvB,GAAIwK,EAAY,EACZ,OAAO,EACX,IACI5E,EAEAiF,EAIAC,EACAC,EACAC,EATAC,EAAWrB,EAAO,GAAGsB,OAAOtB,EAAOY,EAAY,IAE/CW,EAAgBvB,EAAO,GAEvBwB,EAAexM,EAAMqK,YAAc,EACnCoC,EAAS,GAAKb,EAAY,GAC1Bc,EAAK,EAILC,GAA0B,EAC1BC,EAAc,EACdC,EAAmC,EAAflB,EACpBmB,EAAqC,EAAfnB,EAC1BoB,EAAU/B,EAAO,GAAIA,EAAO,GAAI3Q,GAAU2S,eAAeR,GACzD5R,EAAWyK,KAAK2F,EAAO,IAAIiC,IAAI5S,GAC/BQ,EAAWwK,KAAK2F,EAAO,IAAIkC,IAAI7S,GAC/BS,EAAQuK,KAAKzK,GACbG,EAAQsK,KAAKxK,GACb,IAAK,IAAIsS,EAAS,EAAGA,EAASvB,EAAWuB,IAAU,CAC/CnG,EAAegE,EAAOmC,GAGdlB,EAFJkB,IAAWvB,EAAY,EACnBS,EACYrB,EAAO,QAEP3K,EAEJ2K,EAAOmC,EAAS,GAEhC,IAAIC,EAAU/S,EACd0S,EAAUR,EAAevF,EAAcoG,GACvC7S,EAAS8K,KAAK+H,GAASJ,eAAeR,GACtCxR,EAAcqK,KAAK2B,GAAciG,IAAI1S,GACrCU,EAAcoK,KAAK2B,GAAckG,IAAI3S,GACrC,IAAI8S,EAAKX,EAAKD,EAEd,GADAP,GAAoB,OACF7L,IAAd4L,EAAyB,CACzBc,EAAU/F,EAAciF,EAAW3R,GACnCC,EAAS8K,KAAK/K,GAAU0S,eAAeR,GACvCtR,EAAWmK,KAAK2B,GAAciG,IAAI1S,GAClCY,EAAWkK,KAAK2B,GAAckG,IAAI3S,GAClC4R,GAAmB,EACnB5R,EAAS+S,WAAWrB,EAAWM,GAC3Ba,EAAQ3N,IAAIlF,GAAY,IACxB4R,GAAmB,GAER,IAAXgB,IACAR,EAA0BR,GAC9B5R,EAAS+S,WAAWrB,EAAWjF,GAC/BzM,EAASgT,YACT,IAAI9N,EAAMnC,KAAKE,IAAI4P,EAAQ3N,IAAIlF,IAC/B,GAAY,IAARkF,EAAW,CACX,IAAI+N,EAAYhB,EAAe/M,EAC/BlF,EAASyS,gBAAgBQ,GACzBhT,EAAS8S,WAAWtG,EAAcuF,GAClC9R,EAAS4K,KAAK7K,GAAUiT,UAAUD,GAAWN,IAAI3S,GACjDa,EAAWiK,KAAK5K,GAAUiT,SAC1B,IAAIC,EAAelT,EAAS2G,SACxBwM,EAAoBpT,EAAS4G,SACjC5G,EAASqT,aAAaD,GACtBlT,EAAS4S,WAAWrB,EAAWjF,GAC/B,IAAI8G,EAAoBpT,EAAS0G,SAmBjC,OAlBA1G,EAASmT,aAAaC,GAClBtT,EAASiF,IAAIrE,GAAcwS,GAAqBlT,EAAS+E,IAAIrE,GAAc0S,IAC3E5B,GAAoB,GAExB7Q,EAAWgK,KAAK5K,GAAUyS,IAAIlG,GAC9B5L,EAAW8R,IAAIlG,GACfoF,GAAU,EACNF,EACIC,GACAhR,EAAWkK,KAAKjK,GAChBH,EAAcoK,KAAKjK,KAEnBF,EAAWmK,KAAKjK,GAChBJ,EAAcqK,KAAKjK,IAGvB2S,KAEI/N,EAAMsK,gBACd,IAAK,QACD0D,GAAyB7B,EAAkBD,EAAmBmB,GAC9D,MACJ,IAAK,QACDY,GAAwC9B,EAAkBD,GACtDC,EACA+B,EAAmBlH,EAAchM,EAAeE,EAAYmS,EAAI,GAEhEa,EAAmBlH,EAAc7L,EAAYF,EAAeoS,EAAI,GAEpE,MACJ,IAAK,QACL,IAAK,aACL,QACI,IAAIc,EAAgB3B,EAAexM,EAAMwK,iBAAmBmD,EAC5D,GAAIQ,EAAgB,EAAG,CACnB,GAA6B,eAAzBnO,EAAMsK,eAAiC,CACvC0D,GAAyB7B,EAAkBD,EAAmBmB,GAC9D,MAEAY,GAAwC9B,EAAkBD,GACtDC,GACAzR,EAAS4S,WAAWjS,EAAYL,GAAegS,eAAemB,GAAejB,IAAIlS,GACjFL,EAAS2S,WAAWjS,EAAYH,GAAY8R,eAAemB,GAAejB,IAAIhS,GAC9EkT,EAAUpT,EAAeqS,EAAI,GAC7Be,EAAU1T,EAAU2S,EAAI,GACxBe,EAAUpH,EAAcqG,EAAI,IAC5Be,EAAUpH,EAAcqG,EAAI,IAC5Be,EAAU1T,EAAU2S,EAAI,GACxBe,EAAUzT,EAAU0S,EAAI,GACxBe,EAAUpH,EAAcqG,EAAI,IAC5Be,EAAUzT,EAAU0S,EAAI,GACxBe,EAAUlT,EAAYmS,EAAI,KAE1B3S,EAAS4S,WAAWjS,EAAYJ,GAAe+R,eAAemB,GAAejB,IAAIjS,GACjFN,EAAS2S,WAAWjS,EAAYF,GAAY6R,eAAemB,GAAejB,IAAI/R,GAC9EiT,EAAUnT,EAAeoS,EAAI,GAC7Be,EAAU1T,EAAU2S,EAAI,GACxBe,EAAUpH,EAAcqG,EAAI,IAC5Be,EAAUpH,EAAcqG,EAAI,IAC5Be,EAAU1T,EAAU2S,EAAI,GACxBe,EAAUzT,EAAU0S,EAAI,GACxBe,EAAUpH,EAAcqG,EAAI,IAC5Be,EAAUzT,EAAU0S,EAAI,GACxBe,EAAUjT,EAAYkS,EAAI,SAI9BnB,GACIC,GACAiC,EAAUvT,EAAY6R,EAAI,GAC1B0B,EAAUxT,EAAY8R,EAAI,GAC1B0B,EAAU/S,EAAYgS,EAAI,GAC1Be,EAAUvT,EAAY6R,EAAI,GAC1B0B,EAAU/S,EAAYgS,EAAI,GAC1Be,EAAUhT,EAAYiS,EAAI,KAE1Be,EAAUvT,EAAY6R,EAAI,GAC1B0B,EAAUxT,EAAY8R,EAAI,GAC1B0B,EAAU/S,EAAYgS,EAAI,GAC1Be,EAAUxT,EAAY8R,EAAI,GAC1B0B,EAAUhT,EAAYiS,EAAI,GAC1Be,EAAU/S,EAAYgS,EAAI,IAE1BlB,EACAjR,EAAWmK,KAAKhK,GAEhBF,EAAWkK,KAAKhK,IAGhB8Q,GACAiC,EAAUpT,EAAeqS,EAAI,GAC7Be,EAAU/S,EAAYgS,EAAI,GAC1Be,EAAUpH,EAAcqG,EAAI,IAC5Be,EAAUpH,EAAcqG,EAAI,IAC5Be,EAAU/S,EAAYgS,EAAI,GAC1Be,EAAUlT,EAAYmS,EAAI,KAE1Be,EAAUnT,EAAeoS,EAAI,GAC7Be,EAAU/S,EAAYgS,EAAI,GAC1Be,EAAUpH,EAAcqG,EAAI,IAC5Be,EAAUpH,EAAcqG,EAAI,IAC5Be,EAAU/S,EAAYgS,EAAI,GAC1Be,EAAUjT,EAAYkS,EAAI,IAGlCjB,GAAU,QAKlB2B,UAGJA,KAEC1B,GAAYc,IAAWvB,EAAY,GACpCyC,GAAerD,EAAO,GAAIlQ,EAASC,EAASoR,GAAkB,EAAMO,GAExEA,EAAKW,EACLd,EAAgBvF,EAChBpM,EAAWyK,KAAKnK,GAChBL,EAAWwK,KAAKlK,GAEpB,GAAKkR,GAEE,GAAIH,GAAqBf,EAAU,CACtC,IAAImD,EAAYjT,EACZkT,EAAYnT,EACZuR,IAA4BR,IAC5BmC,EAAYlT,EACZmT,EAAYlT,GAEZ8Q,GACIC,GAAWO,KACX4B,EAAUC,QAAQrD,EAAU,GAC5BoD,EAAUC,QAAQrD,EAAU,GACxBiB,GACAkC,EAAUE,QAAQrD,EAAU,KAIhCiB,GAAYO,IACZ4B,EAAUC,QAAQrD,EAAU,GAC5BoD,EAAUC,QAAQrD,EAAU,GACxBiB,GACAkC,EAAUE,QAAQrD,EAAU,UArBxCkD,GAAerH,EAAchM,EAAeC,EAAekR,GAAkB,EAAOkB,GA0BxF,OAAOT,EACP,SAASG,EAAU0B,EAAIC,EAAIC,GAEvB,OADAA,EAAOrB,WAAWoB,EAAID,GACfE,EAAO1J,KAAK0J,EAAO/Q,EAAG+Q,EAAOjR,GAAG6P,YAE3C,SAASa,EAAUQ,EAAUxM,EAAG9B,GACxB6K,IACAA,EAAS0B,GAAqB+B,EAASlR,EACvCyN,EAAS0B,EAAoB,GAAK+B,EAAShR,EAC3CuN,EAAS0B,EAAoB,GAAK,EAC9BzB,IACAA,EAAQyB,GAAqB,EAC7BzB,EAAQyB,EAAoB,GAAK,EACjCzB,EAAQyB,EAAoB,GAAK,GAErCA,GAAqB,EACjBxB,IACAA,EAAIyB,GAAuB1K,EAC3BiJ,EAAIyB,EAAsB,GAAKxM,EAC/BwM,GAAuB,IAG/BF,GAAe,EAEnB,SAASsB,EAAmBW,EAAQJ,EAAIC,EAAItM,EAAG9B,GAC3CjG,EAASgL,KAAKoJ,GAAIxB,IAAI4B,GAAQtB,YAC9BjT,EAAS+K,KAAKqJ,GAAIzB,IAAI4B,GAAQtB,YAC9B,IAAI3I,EAAQtH,KAAKC,GACbkC,EAAMpF,EAASoF,IAAInF,GACnBgD,KAAKE,IAAIiC,GAAO,IAChBmF,EAAQtH,KAAKE,IAAIF,KAAKsC,KAAKH,KAC/BmF,GAASqG,EACT1Q,EAAS8K,KAAKoJ,GACd,IAAK,IAAItN,EAAI,EAAG2N,EAAK7D,EAAe,EAAG9J,EAAI2N,EAAI3N,IAC3C3G,EAAS6K,KAAK9K,GAAUwU,aAAaF,EAAQjK,GAC7CwJ,EAAU7T,EAAU6H,EAAG9B,GACvB8N,EAAU5T,EAAU4H,EAAG9B,GACvB8N,EAAUS,EAAQzM,EAAG,IACrB7H,EAAS8K,KAAK7K,GAElB4T,EAAU5T,EAAU4H,EAAG9B,GACvB8N,EAAUM,EAAItM,EAAG9B,GACjB8N,EAAUS,EAAQzM,EAAG,IAEzB,SAAS2L,KACLK,EAAUvT,EAAY6R,EAAI,GAC1B0B,EAAUxT,EAAY8R,EAAI,GAC1B0B,EAAUpT,EAAeqS,EAAI,GAC7Be,EAAUvT,EAAY6R,EAAI,GAC1B0B,EAAUpT,EAAeqS,EAAI,GAC7Be,EAAUnT,EAAeoS,EAAI,GAEjC,SAASW,GAAyB7B,EAAkBD,EAAmB9J,GAC/D8J,EACIC,GACAiC,EAAUvT,EAAY6R,EAAI,GAC1B0B,EAAUxT,EAAY8R,EAAI,GAC1B0B,EAAUpT,EAAeqS,EAAI,GAC7Be,EAAUvT,EAAY6R,EAAI,GAC1B0B,EAAUpT,EAAeqS,EAAI,GAC7Be,EAAUhT,EAAYiS,EAAI,GAC1Be,EAAUpT,EAAeoH,EAAG,GAC5BgM,EAAUlT,EAAYkH,EAAG,GACzBgM,EAAUhT,EAAYgH,EAAG,MAEzBgM,EAAUvT,EAAY6R,EAAI,GAC1B0B,EAAUxT,EAAY8R,EAAI,GAC1B0B,EAAUnT,EAAeoS,EAAI,GAC7Be,EAAUxT,EAAY8R,EAAI,GAC1B0B,EAAUhT,EAAYiS,EAAI,GAC1Be,EAAUnT,EAAeoS,EAAI,GAC7Be,EAAUnT,EAAemH,EAAG,GAC5BgM,EAAUjT,EAAYiH,EAAG,GACzBgM,EAAUhT,EAAYgH,EAAG,KAGzB+J,GACAiC,EAAUpT,EAAeoH,EAAG,GAC5BgM,EAAUlT,EAAYkH,EAAG,GACzBgM,EAAUpH,EAAc5E,EAAG,MAE3BgM,EAAUnT,EAAemH,EAAG,GAC5BgM,EAAUjT,EAAYiH,EAAG,GACzBgM,EAAUpH,EAAc5E,EAAG,KAIvC,SAAS6L,GAAwC9B,EAAkBD,GAC3DA,IACIC,GACAiC,EAAUvT,EAAY6R,EAAI,GAC1B0B,EAAUxT,EAAY8R,EAAI,GAC1B0B,EAAUpT,EAAeqS,EAAI,GAC7Be,EAAUvT,EAAY6R,EAAI,GAC1B0B,EAAUpT,EAAeqS,EAAI,GAC7Be,EAAUhT,EAAYiS,EAAI,GAC1Be,EAAUpT,EAAe0R,EAAI,GAC7B0B,EAAUpH,EAAcqG,EAAI,IAC5Be,EAAUhT,EAAYiS,EAAI,GAC1Be,EAAUpH,EAAcqG,EAAI,IAC5Be,EAAUlT,EAAYwR,EAAI,GAC1B0B,EAAUhT,EAAYiS,EAAI,KAE1Be,EAAUvT,EAAY6R,EAAI,GAC1B0B,EAAUxT,EAAY8R,EAAI,GAC1B0B,EAAUnT,EAAeoS,EAAI,GAC7Be,EAAUxT,EAAY8R,EAAI,GAC1B0B,EAAUhT,EAAYiS,EAAI,GAC1Be,EAAUnT,EAAeoS,EAAI,GAC7Be,EAAUnT,EAAeyR,EAAI,GAC7B0B,EAAUhT,EAAYiS,EAAI,GAC1Be,EAAUpH,EAAcqG,EAAI,IAC5Be,EAAUpH,EAAcqG,EAAI,IAC5Be,EAAUhT,EAAYiS,EAAI,GAC1Be,EAAUjT,EAAYuR,EAAI,KAItC,SAAS2B,GAAeQ,EAAQJ,EAAIC,EAAIvC,EAAkB/O,EAAOgF,GAC7D,OAAQpC,EAAMuK,eACd,IAAK,QACGnN,EACA8Q,EAAmBW,EAAQH,EAAID,EAAIrM,EAAG,IAEtC8L,EAAmBW,EAAQJ,EAAIC,EAAItM,EAAG,IAE1C,MACJ,IAAK,SACD,GAAIhF,EACA/C,EAASiT,WAAWmB,EAAII,GACxBvU,EAAS2K,IAAI5K,EAASuD,GAAIvD,EAASqD,GACnCnD,EAASyU,WAAW3U,EAAUC,GAAU4S,IAAI2B,GAC5CrU,EAAS8S,WAAWhT,EAAUD,GAAU6S,IAAI2B,GACxC1C,GACA5R,EAASiU,QAAQrD,EAAU,GAC3B3Q,EAASgU,QAAQrD,EAAU,GAC3B3Q,EAASgU,QAAQrD,EAAU,KAE3B5Q,EAASiU,QAAQrD,EAAU,GAC3B5Q,EAASiU,QAAQrD,EAAU,GAC3B3Q,EAASgU,QAAQrD,EAAU,QAE5B,CACH9Q,EAASiT,WAAWoB,EAAIG,GACxBvU,EAAS2K,IAAI5K,EAASuD,GAAIvD,EAASqD,GACnCnD,EAASyU,WAAW3U,EAAUC,GAAU4S,IAAI2B,GAC5CrU,EAAS8S,WAAWhT,EAAUD,GAAU6S,IAAI2B,GAC5C,IAAII,EAAK9D,EAAS/J,OACd+K,GACA5R,EAASiU,QAAQrD,EAAU8D,EAAK,GAChCzU,EAASgU,QAAQrD,EAAU8D,EAAK,GAChCzU,EAASgU,QAAQrD,EAAU8D,EAAK,MAEhC1U,EAASiU,QAAQrD,EAAU8D,EAAK,GAChCzU,EAASgU,QAAQrD,EAAU8D,EAAK,GAChCzU,EAASgU,QAAQrD,EAAU8D,EAAK,UA+BjD7U,EAAO8U,QAAQ5T,UAAYA","file":"../../loaders/SVGLoader.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    var SVGLoader = function (manager) {\n        THREE.Loader.call(this, manager);\n        this.defaultDPI = 90;\n        this.defaultUnit = 'px';\n    };\n    SVGLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {\n        constructor: SVGLoader,\n        load: function (url, onLoad, onProgress, onError) {\n            var scope = this;\n            var loader = new THREE.FileLoader(scope.manager);\n            loader.setPath(scope.path);\n            loader.load(url, function (text) {\n                onLoad(scope.parse(text));\n            }, onProgress, onError);\n        },\n        parse: function (text) {\n            var scope = this;\n            function parseNode(node, style) {\n                if (node.nodeType !== 1)\n                    return;\n                var transform = getNodeTransform(node);\n                var path = null;\n                switch (node.nodeName) {\n                case 'svg':\n                    break;\n                case 'g':\n                    style = parseStyle(node, style);\n                    break;\n                case 'path':\n                    style = parseStyle(node, style);\n                    if (node.hasAttribute('d'))\n                        path = parsePathNode(node);\n                    break;\n                case 'rect':\n                    style = parseStyle(node, style);\n                    path = parseRectNode(node);\n                    break;\n                case 'polygon':\n                    style = parseStyle(node, style);\n                    path = parsePolygonNode(node);\n                    break;\n                case 'polyline':\n                    style = parseStyle(node, style);\n                    path = parsePolylineNode(node);\n                    break;\n                case 'circle':\n                    style = parseStyle(node, style);\n                    path = parseCircleNode(node);\n                    break;\n                case 'ellipse':\n                    style = parseStyle(node, style);\n                    path = parseEllipseNode(node);\n                    break;\n                case 'line':\n                    style = parseStyle(node, style);\n                    path = parseLineNode(node);\n                    break;\n                default:\n                    console.log(node);\n                }\n                if (path) {\n                    if (style.fill !== undefined && style.fill !== 'none') {\n                        path.color.setStyle(style.fill);\n                    }\n                    transformPath(path, currentTransform);\n                    paths.push(path);\n                    path.userData = {\n                        node: node,\n                        style: style\n                    };\n                }\n                var nodes = node.childNodes;\n                for (var i = 0; i < nodes.length; i++) {\n                    parseNode(nodes[i], style);\n                }\n                if (transform) {\n                    transformStack.pop();\n                    if (transformStack.length > 0) {\n                        currentTransform.copy(transformStack[transformStack.length - 1]);\n                    } else {\n                        currentTransform.identity();\n                    }\n                }\n            }\n            function parsePathNode(node) {\n                var path = new THREE.ShapePath();\n                var point = new THREE.Vector2();\n                var control = new THREE.Vector2();\n                var firstPoint = new THREE.Vector2();\n                var isFirstPoint = true;\n                var doSetFirstPoint = false;\n                var d = node.getAttribute('d');\n                var commands = d.match(/[a-df-z][^a-df-z]*/ig);\n                for (var i = 0, l = commands.length; i < l; i++) {\n                    var command = commands[i];\n                    var type = command.charAt(0);\n                    var data = command.substr(1).trim();\n                    if (isFirstPoint === true) {\n                        doSetFirstPoint = true;\n                        isFirstPoint = false;\n                    }\n                    switch (type) {\n                    case 'M':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n                            point.x = numbers[j + 0];\n                            point.y = numbers[j + 1];\n                            control.x = point.x;\n                            control.y = point.y;\n                            if (j === 0) {\n                                path.moveTo(point.x, point.y);\n                            } else {\n                                path.lineTo(point.x, point.y);\n                            }\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'H':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j++) {\n                            point.x = numbers[j];\n                            control.x = point.x;\n                            control.y = point.y;\n                            path.lineTo(point.x, point.y);\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'V':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j++) {\n                            point.y = numbers[j];\n                            control.x = point.x;\n                            control.y = point.y;\n                            path.lineTo(point.x, point.y);\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'L':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n                            point.x = numbers[j + 0];\n                            point.y = numbers[j + 1];\n                            control.x = point.x;\n                            control.y = point.y;\n                            path.lineTo(point.x, point.y);\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'C':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j += 6) {\n                            path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);\n                            control.x = numbers[j + 2];\n                            control.y = numbers[j + 3];\n                            point.x = numbers[j + 4];\n                            point.y = numbers[j + 5];\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'S':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j += 4) {\n                            path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n                            control.x = numbers[j + 0];\n                            control.y = numbers[j + 1];\n                            point.x = numbers[j + 2];\n                            point.y = numbers[j + 3];\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'Q':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j += 4) {\n                            path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n                            control.x = numbers[j + 0];\n                            control.y = numbers[j + 1];\n                            point.x = numbers[j + 2];\n                            point.y = numbers[j + 3];\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'T':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n                            var rx = getReflection(point.x, control.x);\n                            var ry = getReflection(point.y, control.y);\n                            path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n                            control.x = rx;\n                            control.y = ry;\n                            point.x = numbers[j + 0];\n                            point.y = numbers[j + 1];\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'A':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j += 7) {\n                            var start = point.clone();\n                            point.x = numbers[j + 5];\n                            point.y = numbers[j + 6];\n                            control.x = point.x;\n                            control.y = point.y;\n                            parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'm':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n                            point.x += numbers[j + 0];\n                            point.y += numbers[j + 1];\n                            control.x = point.x;\n                            control.y = point.y;\n                            if (j === 0) {\n                                path.moveTo(point.x, point.y);\n                            } else {\n                                path.lineTo(point.x, point.y);\n                            }\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'h':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j++) {\n                            point.x += numbers[j];\n                            control.x = point.x;\n                            control.y = point.y;\n                            path.lineTo(point.x, point.y);\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'v':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j++) {\n                            point.y += numbers[j];\n                            control.x = point.x;\n                            control.y = point.y;\n                            path.lineTo(point.x, point.y);\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'l':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n                            point.x += numbers[j + 0];\n                            point.y += numbers[j + 1];\n                            control.x = point.x;\n                            control.y = point.y;\n                            path.lineTo(point.x, point.y);\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'c':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j += 6) {\n                            path.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);\n                            control.x = point.x + numbers[j + 2];\n                            control.y = point.y + numbers[j + 3];\n                            point.x += numbers[j + 4];\n                            point.y += numbers[j + 5];\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 's':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j += 4) {\n                            path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n                            control.x = point.x + numbers[j + 0];\n                            control.y = point.y + numbers[j + 1];\n                            point.x += numbers[j + 2];\n                            point.y += numbers[j + 3];\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'q':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j += 4) {\n                            path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n                            control.x = point.x + numbers[j + 0];\n                            control.y = point.y + numbers[j + 1];\n                            point.x += numbers[j + 2];\n                            point.y += numbers[j + 3];\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 't':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n                            var rx = getReflection(point.x, control.x);\n                            var ry = getReflection(point.y, control.y);\n                            path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n                            control.x = rx;\n                            control.y = ry;\n                            point.x = point.x + numbers[j + 0];\n                            point.y = point.y + numbers[j + 1];\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'a':\n                        var numbers = parseFloats(data);\n                        for (var j = 0, jl = numbers.length; j < jl; j += 7) {\n                            var start = point.clone();\n                            point.x += numbers[j + 5];\n                            point.y += numbers[j + 6];\n                            control.x = point.x;\n                            control.y = point.y;\n                            parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n                            if (j === 0 && doSetFirstPoint === true)\n                                firstPoint.copy(point);\n                        }\n                        break;\n                    case 'Z':\n                    case 'z':\n                        path.currentPath.autoClose = true;\n                        if (path.currentPath.curves.length > 0) {\n                            point.copy(firstPoint);\n                            path.currentPath.currentPoint.copy(point);\n                            isFirstPoint = true;\n                        }\n                        break;\n                    default:\n                        console.warn(command);\n                    }\n                    doSetFirstPoint = false;\n                }\n                return path;\n            }\n            function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n                x_axis_rotation = x_axis_rotation * Math.PI / 180;\n                rx = Math.abs(rx);\n                ry = Math.abs(ry);\n                var dx2 = (start.x - end.x) / 2;\n                var dy2 = (start.y - end.y) / 2;\n                var x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n                var y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n                var rxs = rx * rx;\n                var rys = ry * ry;\n                var x1ps = x1p * x1p;\n                var y1ps = y1p * y1p;\n                var cr = x1ps / rxs + y1ps / rys;\n                if (cr > 1) {\n                    var s = Math.sqrt(cr);\n                    rx = s * rx;\n                    ry = s * ry;\n                    rxs = rx * rx;\n                    rys = ry * ry;\n                }\n                var dq = rxs * y1ps + rys * x1ps;\n                var pq = (rxs * rys - dq) / dq;\n                var q = Math.sqrt(Math.max(0, pq));\n                if (large_arc_flag === sweep_flag)\n                    q = -q;\n                var cxp = q * rx * y1p / ry;\n                var cyp = -q * ry * x1p / rx;\n                var cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n                var cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n                var theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n                var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n                path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n            }\n            function svgAngle(ux, uy, vx, vy) {\n                var dot = ux * vx + uy * vy;\n                var len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n                var ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));\n                if (ux * vy - uy * vx < 0)\n                    ang = -ang;\n                return ang;\n            }\n            function parseRectNode(node) {\n                var x = parseFloatWithUnits(node.getAttribute('x') || 0);\n                var y = parseFloatWithUnits(node.getAttribute('y') || 0);\n                var rx = parseFloatWithUnits(node.getAttribute('rx') || 0);\n                var ry = parseFloatWithUnits(node.getAttribute('ry') || 0);\n                var w = parseFloatWithUnits(node.getAttribute('width'));\n                var h = parseFloatWithUnits(node.getAttribute('height'));\n                var path = new THREE.ShapePath();\n                path.moveTo(x + 2 * rx, y);\n                path.lineTo(x + w - 2 * rx, y);\n                if (rx !== 0 || ry !== 0)\n                    path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry);\n                path.lineTo(x + w, y + h - 2 * ry);\n                if (rx !== 0 || ry !== 0)\n                    path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h);\n                path.lineTo(x + 2 * rx, y + h);\n                if (rx !== 0 || ry !== 0) {\n                    path.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry);\n                }\n                path.lineTo(x, y + 2 * ry);\n                if (rx !== 0 || ry !== 0) {\n                    path.bezierCurveTo(x, y, x, y, x + 2 * rx, y);\n                }\n                return path;\n            }\n            function parsePolygonNode(node) {\n                function iterator(match, a, b) {\n                    var x = parseFloatWithUnits(a);\n                    var y = parseFloatWithUnits(b);\n                    if (index === 0) {\n                        path.moveTo(x, y);\n                    } else {\n                        path.lineTo(x, y);\n                    }\n                    index++;\n                }\n                var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n                var path = new THREE.ShapePath();\n                var index = 0;\n                node.getAttribute('points').replace(regex, iterator);\n                path.currentPath.autoClose = true;\n                return path;\n            }\n            function parsePolylineNode(node) {\n                function iterator(match, a, b) {\n                    var x = parseFloatWithUnits(a);\n                    var y = parseFloatWithUnits(b);\n                    if (index === 0) {\n                        path.moveTo(x, y);\n                    } else {\n                        path.lineTo(x, y);\n                    }\n                    index++;\n                }\n                var regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n                var path = new THREE.ShapePath();\n                var index = 0;\n                node.getAttribute('points').replace(regex, iterator);\n                path.currentPath.autoClose = false;\n                return path;\n            }\n            function parseCircleNode(node) {\n                var x = parseFloatWithUnits(node.getAttribute('cx'));\n                var y = parseFloatWithUnits(node.getAttribute('cy'));\n                var r = parseFloatWithUnits(node.getAttribute('r'));\n                var subpath = new THREE.Path();\n                subpath.absarc(x, y, r, 0, Math.PI * 2);\n                var path = new THREE.ShapePath();\n                path.subPaths.push(subpath);\n                return path;\n            }\n            function parseEllipseNode(node) {\n                var x = parseFloatWithUnits(node.getAttribute('cx'));\n                var y = parseFloatWithUnits(node.getAttribute('cy'));\n                var rx = parseFloatWithUnits(node.getAttribute('rx'));\n                var ry = parseFloatWithUnits(node.getAttribute('ry'));\n                var subpath = new THREE.Path();\n                subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n                var path = new THREE.ShapePath();\n                path.subPaths.push(subpath);\n                return path;\n            }\n            function parseLineNode(node) {\n                var x1 = parseFloatWithUnits(node.getAttribute('x1'));\n                var y1 = parseFloatWithUnits(node.getAttribute('y1'));\n                var x2 = parseFloatWithUnits(node.getAttribute('x2'));\n                var y2 = parseFloatWithUnits(node.getAttribute('y2'));\n                var path = new THREE.ShapePath();\n                path.moveTo(x1, y1);\n                path.lineTo(x2, y2);\n                path.currentPath.autoClose = false;\n                return path;\n            }\n            function parseStyle(node, style) {\n                style = Object.assign({}, style);\n                function addStyle(svgName, jsName, adjustFunction) {\n                    if (adjustFunction === undefined)\n                        adjustFunction = function copy(v) {\n                            return v;\n                        };\n                    if (node.hasAttribute(svgName))\n                        style[jsName] = adjustFunction(node.getAttribute(svgName));\n                    if (node.style && node.style[svgName] !== '')\n                        style[jsName] = adjustFunction(node.style[svgName]);\n                }\n                function clamp(v) {\n                    return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n                }\n                function positive(v) {\n                    return Math.max(0, parseFloatWithUnits(v));\n                }\n                addStyle('fill', 'fill');\n                addStyle('fill-opacity', 'fillOpacity', clamp);\n                addStyle('stroke', 'stroke');\n                addStyle('stroke-opacity', 'strokeOpacity', clamp);\n                addStyle('stroke-width', 'strokeWidth', positive);\n                addStyle('stroke-linejoin', 'strokeLineJoin');\n                addStyle('stroke-linecap', 'strokeLineCap');\n                addStyle('stroke-miterlimit', 'strokeMiterLimit', positive);\n                return style;\n            }\n            function getReflection(a, b) {\n                return a - (b - a);\n            }\n            function parseFloats(string) {\n                var array = string.split(/[\\s,]+|(?=\\s?[+\\-])/);\n                for (var i = 0; i < array.length; i++) {\n                    var number = array[i];\n                    if (number.indexOf('.') !== number.lastIndexOf('.')) {\n                        var split = number.split('.');\n                        for (var s = 2; s < split.length; s++) {\n                            array.splice(i + s - 1, 0, '0.' + split[s]);\n                        }\n                    }\n                    array[i] = parseFloatWithUnits(number);\n                }\n                return array;\n            }\n            var units = [\n                'mm',\n                'cm',\n                'in',\n                'pt',\n                'pc',\n                'px'\n            ];\n            var unitConversion = {\n                'mm': {\n                    'mm': 1,\n                    'cm': 0.1,\n                    'in': 1 / 25.4,\n                    'pt': 72 / 25.4,\n                    'pc': 6 / 25.4,\n                    'px': -1\n                },\n                'cm': {\n                    'mm': 10,\n                    'cm': 1,\n                    'in': 1 / 2.54,\n                    'pt': 72 / 2.54,\n                    'pc': 6 / 2.54,\n                    'px': -1\n                },\n                'in': {\n                    'mm': 25.4,\n                    'cm': 2.54,\n                    'in': 1,\n                    'pt': 72,\n                    'pc': 6,\n                    'px': -1\n                },\n                'pt': {\n                    'mm': 25.4 / 72,\n                    'cm': 2.54 / 72,\n                    'in': 1 / 72,\n                    'pt': 1,\n                    'pc': 6 / 72,\n                    'px': -1\n                },\n                'pc': {\n                    'mm': 25.4 / 6,\n                    'cm': 2.54 / 6,\n                    'in': 1 / 6,\n                    'pt': 72 / 6,\n                    'pc': 1,\n                    'px': -1\n                },\n                'px': { 'px': 1 }\n            };\n            function parseFloatWithUnits(string) {\n                var theUnit = 'px';\n                if (typeof string === 'string' || string instanceof String) {\n                    for (var i = 0, n = units.length; i < n; i++) {\n                        var u = units[i];\n                        if (string.endsWith(u)) {\n                            theUnit = u;\n                            string = string.substring(0, string.length - u.length);\n                            break;\n                        }\n                    }\n                }\n                var scale = undefined;\n                if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n                    scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI;\n                } else {\n                    scale = unitConversion[theUnit][scope.defaultUnit];\n                    if (scale < 0) {\n                        scale = unitConversion[theUnit]['in'] * scope.defaultDPI;\n                    }\n                }\n                return scale * parseFloat(string);\n            }\n            function getNodeTransform(node) {\n                if (!node.hasAttribute('transform')) {\n                    return null;\n                }\n                var transform = parseNodeTransform(node);\n                if (transformStack.length > 0) {\n                    transform.premultiply(transformStack[transformStack.length - 1]);\n                }\n                currentTransform.copy(transform);\n                transformStack.push(transform);\n                return transform;\n            }\n            function parseNodeTransform(node) {\n                var transform = new THREE.Matrix3();\n                var currentTransform = tempTransform0;\n                var transformsTexts = node.getAttribute('transform').split(')');\n                for (var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n                    var transformText = transformsTexts[tIndex].trim();\n                    if (transformText === '')\n                        continue;\n                    var openParPos = transformText.indexOf('(');\n                    var closeParPos = transformText.length;\n                    if (openParPos > 0 && openParPos < closeParPos) {\n                        var transformType = transformText.substr(0, openParPos);\n                        var array = parseFloats(transformText.substr(openParPos + 1, closeParPos - openParPos - 1));\n                        currentTransform.identity();\n                        switch (transformType) {\n                        case 'translate':\n                            if (array.length >= 1) {\n                                var tx = array[0];\n                                var ty = tx;\n                                if (array.length >= 2) {\n                                    ty = array[1];\n                                }\n                                currentTransform.translate(tx, ty);\n                            }\n                            break;\n                        case 'rotate':\n                            if (array.length >= 1) {\n                                var angle = 0;\n                                var cx = 0;\n                                var cy = 0;\n                                angle = -array[0] * Math.PI / 180;\n                                if (array.length >= 3) {\n                                    cx = array[1];\n                                    cy = array[2];\n                                }\n                                tempTransform1.identity().translate(-cx, -cy);\n                                tempTransform2.identity().rotate(angle);\n                                tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                                tempTransform1.identity().translate(cx, cy);\n                                currentTransform.multiplyMatrices(tempTransform1, tempTransform3);\n                            }\n                            break;\n                        case 'scale':\n                            if (array.length >= 1) {\n                                var scaleX = array[0];\n                                var scaleY = scaleX;\n                                if (array.length >= 2) {\n                                    scaleY = array[1];\n                                }\n                                currentTransform.scale(scaleX, scaleY);\n                            }\n                            break;\n                        case 'skewX':\n                            if (array.length === 1) {\n                                currentTransform.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                            }\n                            break;\n                        case 'skewY':\n                            if (array.length === 1) {\n                                currentTransform.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                            }\n                            break;\n                        case 'matrix':\n                            if (array.length === 6) {\n                                currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                            }\n                            break;\n                        }\n                    }\n                    transform.premultiply(currentTransform);\n                }\n                return transform;\n            }\n            function transformPath(path, m) {\n                function transfVec2(v2) {\n                    tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n                    v2.set(tempV3.x, tempV3.y);\n                }\n                var isRotated = isTransformRotated(m);\n                var subPaths = path.subPaths;\n                for (var i = 0, n = subPaths.length; i < n; i++) {\n                    var subPath = subPaths[i];\n                    var curves = subPath.curves;\n                    for (var j = 0; j < curves.length; j++) {\n                        var curve = curves[j];\n                        if (curve.isLineCurve) {\n                            transfVec2(curve.v1);\n                            transfVec2(curve.v2);\n                        } else if (curve.isCubicBezierCurve) {\n                            transfVec2(curve.v0);\n                            transfVec2(curve.v1);\n                            transfVec2(curve.v2);\n                            transfVec2(curve.v3);\n                        } else if (curve.isQuadraticBezierCurve) {\n                            transfVec2(curve.v0);\n                            transfVec2(curve.v1);\n                            transfVec2(curve.v2);\n                        } else if (curve.isEllipseCurve) {\n                            if (isRotated) {\n                                console.warn('SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.');\n                            }\n                            tempV2.set(curve.aX, curve.aY);\n                            transfVec2(tempV2);\n                            curve.aX = tempV2.x;\n                            curve.aY = tempV2.y;\n                            curve.xRadius *= getTransformScaleX(m);\n                            curve.yRadius *= getTransformScaleY(m);\n                        }\n                    }\n                }\n            }\n            function isTransformRotated(m) {\n                return m.elements[1] !== 0 || m.elements[3] !== 0;\n            }\n            function getTransformScaleX(m) {\n                var te = m.elements;\n                return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n            }\n            function getTransformScaleY(m) {\n                var te = m.elements;\n                return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n            }\n            var paths = [];\n            var transformStack = [];\n            var tempTransform0 = new THREE.Matrix3();\n            var tempTransform1 = new THREE.Matrix3();\n            var tempTransform2 = new THREE.Matrix3();\n            var tempTransform3 = new THREE.Matrix3();\n            var tempV2 = new THREE.Vector2();\n            var tempV3 = new THREE.Vector3();\n            var currentTransform = new THREE.Matrix3();\n            var xml = new DOMParser().parseFromString(text, 'image/svg+xml');\n            parseNode(xml.documentElement, {\n                fill: '#000',\n                fillOpacity: 1,\n                strokeOpacity: 1,\n                strokeWidth: 1,\n                strokeLineJoin: 'miter',\n                strokeLineCap: 'butt',\n                strokeMiterLimit: 4\n            });\n            var data = {\n                paths: paths,\n                xml: xml.documentElement\n            };\n            return data;\n        }\n    });\n    SVGLoader.getStrokeStyle = function (width, color, lineJoin, lineCap, miterLimit) {\n        width = width !== undefined ? width : 1;\n        color = color !== undefined ? color : '#000';\n        lineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n        lineCap = lineCap !== undefined ? lineCap : 'butt';\n        miterLimit = miterLimit !== undefined ? miterLimit : 4;\n        return {\n            strokeColor: color,\n            strokeWidth: width,\n            strokeLineJoin: lineJoin,\n            strokeLineCap: lineCap,\n            strokeMiterLimit: miterLimit\n        };\n    };\n    SVGLoader.pointsToStroke = function (points, style, arcDivisions, minDistance) {\n        var vertices = [];\n        var normals = [];\n        var uvs = [];\n        if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n            return null;\n        }\n        var geometry = new THREE.BufferGeometry();\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n        geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\n        return geometry;\n    };\n    SVGLoader.pointsToStrokeWithBuffers = function () {\n        var tempV2_1 = new THREE.Vector2();\n        var tempV2_2 = new THREE.Vector2();\n        var tempV2_3 = new THREE.Vector2();\n        var tempV2_4 = new THREE.Vector2();\n        var tempV2_5 = new THREE.Vector2();\n        var tempV2_6 = new THREE.Vector2();\n        var tempV2_7 = new THREE.Vector2();\n        var lastPointL = new THREE.Vector2();\n        var lastPointR = new THREE.Vector2();\n        var point0L = new THREE.Vector2();\n        var point0R = new THREE.Vector2();\n        var currentPointL = new THREE.Vector2();\n        var currentPointR = new THREE.Vector2();\n        var nextPointL = new THREE.Vector2();\n        var nextPointR = new THREE.Vector2();\n        var innerPoint = new THREE.Vector2();\n        var outerPoint = new THREE.Vector2();\n        return function (points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n            arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n            minDistance = minDistance !== undefined ? minDistance : 0.001;\n            vertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n            points = removeDuplicatedPoints(points);\n            var numPoints = points.length;\n            if (numPoints < 2)\n                return 0;\n            var isClosed = points[0].equals(points[numPoints - 1]);\n            var currentPoint;\n            var previousPoint = points[0];\n            var nextPoint;\n            var strokeWidth2 = style.strokeWidth / 2;\n            var deltaU = 1 / (numPoints - 1);\n            var u0 = 0;\n            var innerSideModified;\n            var joinIsOnLeftSide;\n            var isMiter;\n            var initialJoinIsOnLeftSide = false;\n            var numVertices = 0;\n            var currentCoordinate = vertexOffset * 3;\n            var currentCoordinateUV = vertexOffset * 2;\n            getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n            lastPointL.copy(points[0]).sub(tempV2_1);\n            lastPointR.copy(points[0]).add(tempV2_1);\n            point0L.copy(lastPointL);\n            point0R.copy(lastPointR);\n            for (var iPoint = 1; iPoint < numPoints; iPoint++) {\n                currentPoint = points[iPoint];\n                if (iPoint === numPoints - 1) {\n                    if (isClosed) {\n                        nextPoint = points[1];\n                    } else\n                        nextPoint = undefined;\n                } else {\n                    nextPoint = points[iPoint + 1];\n                }\n                var normal1 = tempV2_1;\n                getNormal(previousPoint, currentPoint, normal1);\n                tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n                currentPointL.copy(currentPoint).sub(tempV2_3);\n                currentPointR.copy(currentPoint).add(tempV2_3);\n                var u1 = u0 + deltaU;\n                innerSideModified = false;\n                if (nextPoint !== undefined) {\n                    getNormal(currentPoint, nextPoint, tempV2_2);\n                    tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n                    nextPointL.copy(currentPoint).sub(tempV2_3);\n                    nextPointR.copy(currentPoint).add(tempV2_3);\n                    joinIsOnLeftSide = true;\n                    tempV2_3.subVectors(nextPoint, previousPoint);\n                    if (normal1.dot(tempV2_3) < 0) {\n                        joinIsOnLeftSide = false;\n                    }\n                    if (iPoint === 1)\n                        initialJoinIsOnLeftSide = joinIsOnLeftSide;\n                    tempV2_3.subVectors(nextPoint, currentPoint);\n                    tempV2_3.normalize();\n                    var dot = Math.abs(normal1.dot(tempV2_3));\n                    if (dot !== 0) {\n                        var miterSide = strokeWidth2 / dot;\n                        tempV2_3.multiplyScalar(-miterSide);\n                        tempV2_4.subVectors(currentPoint, previousPoint);\n                        tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n                        innerPoint.copy(tempV2_5).negate();\n                        var miterLength2 = tempV2_5.length();\n                        var segmentLengthPrev = tempV2_4.length();\n                        tempV2_4.divideScalar(segmentLengthPrev);\n                        tempV2_6.subVectors(nextPoint, currentPoint);\n                        var segmentLengthNext = tempV2_6.length();\n                        tempV2_6.divideScalar(segmentLengthNext);\n                        if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n                            innerSideModified = true;\n                        }\n                        outerPoint.copy(tempV2_5).add(currentPoint);\n                        innerPoint.add(currentPoint);\n                        isMiter = false;\n                        if (innerSideModified) {\n                            if (joinIsOnLeftSide) {\n                                nextPointR.copy(innerPoint);\n                                currentPointR.copy(innerPoint);\n                            } else {\n                                nextPointL.copy(innerPoint);\n                                currentPointL.copy(innerPoint);\n                            }\n                        } else {\n                            makeSegmentTriangles();\n                        }\n                        switch (style.strokeLineJoin) {\n                        case 'bevel':\n                            makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                            break;\n                        case 'round':\n                            createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                            if (joinIsOnLeftSide) {\n                                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n                            } else {\n                                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n                            }\n                            break;\n                        case 'miter':\n                        case 'miter-clip':\n                        default:\n                            var miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n                            if (miterFraction < 1) {\n                                if (style.strokeLineJoin !== 'miter-clip') {\n                                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                                    break;\n                                } else {\n                                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                                    if (joinIsOnLeftSide) {\n                                        tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                                        tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                                        addVertex(currentPointL, u1, 0);\n                                        addVertex(tempV2_6, u1, 0);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(tempV2_6, u1, 0);\n                                        addVertex(tempV2_7, u1, 0);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(tempV2_7, u1, 0);\n                                        addVertex(nextPointL, u1, 0);\n                                    } else {\n                                        tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                                        tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                                        addVertex(currentPointR, u1, 1);\n                                        addVertex(tempV2_6, u1, 1);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(tempV2_6, u1, 1);\n                                        addVertex(tempV2_7, u1, 1);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(tempV2_7, u1, 1);\n                                        addVertex(nextPointR, u1, 1);\n                                    }\n                                }\n                            } else {\n                                if (innerSideModified) {\n                                    if (joinIsOnLeftSide) {\n                                        addVertex(lastPointR, u0, 1);\n                                        addVertex(lastPointL, u0, 0);\n                                        addVertex(outerPoint, u1, 0);\n                                        addVertex(lastPointR, u0, 1);\n                                        addVertex(outerPoint, u1, 0);\n                                        addVertex(innerPoint, u1, 1);\n                                    } else {\n                                        addVertex(lastPointR, u0, 1);\n                                        addVertex(lastPointL, u0, 0);\n                                        addVertex(outerPoint, u1, 1);\n                                        addVertex(lastPointL, u0, 0);\n                                        addVertex(innerPoint, u1, 0);\n                                        addVertex(outerPoint, u1, 1);\n                                    }\n                                    if (joinIsOnLeftSide) {\n                                        nextPointL.copy(outerPoint);\n                                    } else {\n                                        nextPointR.copy(outerPoint);\n                                    }\n                                } else {\n                                    if (joinIsOnLeftSide) {\n                                        addVertex(currentPointL, u1, 0);\n                                        addVertex(outerPoint, u1, 0);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(outerPoint, u1, 0);\n                                        addVertex(nextPointL, u1, 0);\n                                    } else {\n                                        addVertex(currentPointR, u1, 1);\n                                        addVertex(outerPoint, u1, 1);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(currentPoint, u1, 0.5);\n                                        addVertex(outerPoint, u1, 1);\n                                        addVertex(nextPointR, u1, 1);\n                                    }\n                                }\n                                isMiter = true;\n                            }\n                            break;\n                        }\n                    } else {\n                        makeSegmentTriangles();\n                    }\n                } else {\n                    makeSegmentTriangles();\n                }\n                if (!isClosed && iPoint === numPoints - 1) {\n                    addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n                }\n                u0 = u1;\n                previousPoint = currentPoint;\n                lastPointL.copy(nextPointL);\n                lastPointR.copy(nextPointR);\n            }\n            if (!isClosed) {\n                addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n            } else if (innerSideModified && vertices) {\n                var lastOuter = outerPoint;\n                var lastInner = innerPoint;\n                if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n                    lastOuter = innerPoint;\n                    lastInner = outerPoint;\n                }\n                if (joinIsOnLeftSide) {\n                    if (isMiter || initialJoinIsOnLeftSide) {\n                        lastInner.toArray(vertices, 0 * 3);\n                        lastInner.toArray(vertices, 3 * 3);\n                        if (isMiter) {\n                            lastOuter.toArray(vertices, 1 * 3);\n                        }\n                    }\n                } else {\n                    if (isMiter || !initialJoinIsOnLeftSide) {\n                        lastInner.toArray(vertices, 1 * 3);\n                        lastInner.toArray(vertices, 3 * 3);\n                        if (isMiter) {\n                            lastOuter.toArray(vertices, 0 * 3);\n                        }\n                    }\n                }\n            }\n            return numVertices;\n            function getNormal(p1, p2, result) {\n                result.subVectors(p2, p1);\n                return result.set(-result.y, result.x).normalize();\n            }\n            function addVertex(position, u, v) {\n                if (vertices) {\n                    vertices[currentCoordinate] = position.x;\n                    vertices[currentCoordinate + 1] = position.y;\n                    vertices[currentCoordinate + 2] = 0;\n                    if (normals) {\n                        normals[currentCoordinate] = 0;\n                        normals[currentCoordinate + 1] = 0;\n                        normals[currentCoordinate + 2] = 1;\n                    }\n                    currentCoordinate += 3;\n                    if (uvs) {\n                        uvs[currentCoordinateUV] = u;\n                        uvs[currentCoordinateUV + 1] = v;\n                        currentCoordinateUV += 2;\n                    }\n                }\n                numVertices += 3;\n            }\n            function makeCircularSector(center, p1, p2, u, v) {\n                tempV2_1.copy(p1).sub(center).normalize();\n                tempV2_2.copy(p2).sub(center).normalize();\n                var angle = Math.PI;\n                var dot = tempV2_1.dot(tempV2_2);\n                if (Math.abs(dot) < 1)\n                    angle = Math.abs(Math.acos(dot));\n                angle /= arcDivisions;\n                tempV2_3.copy(p1);\n                for (var i = 0, il = arcDivisions - 1; i < il; i++) {\n                    tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n                    addVertex(tempV2_3, u, v);\n                    addVertex(tempV2_4, u, v);\n                    addVertex(center, u, 0.5);\n                    tempV2_3.copy(tempV2_4);\n                }\n                addVertex(tempV2_4, u, v);\n                addVertex(p2, u, v);\n                addVertex(center, u, 0.5);\n            }\n            function makeSegmentTriangles() {\n                addVertex(lastPointR, u0, 1);\n                addVertex(lastPointL, u0, 0);\n                addVertex(currentPointL, u1, 0);\n                addVertex(lastPointR, u0, 1);\n                addVertex(currentPointL, u1, 1);\n                addVertex(currentPointR, u1, 0);\n            }\n            function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n                if (innerSideModified) {\n                    if (joinIsOnLeftSide) {\n                        addVertex(lastPointR, u0, 1);\n                        addVertex(lastPointL, u0, 0);\n                        addVertex(currentPointL, u1, 0);\n                        addVertex(lastPointR, u0, 1);\n                        addVertex(currentPointL, u1, 0);\n                        addVertex(innerPoint, u1, 1);\n                        addVertex(currentPointL, u, 0);\n                        addVertex(nextPointL, u, 0);\n                        addVertex(innerPoint, u, 0.5);\n                    } else {\n                        addVertex(lastPointR, u0, 1);\n                        addVertex(lastPointL, u0, 0);\n                        addVertex(currentPointR, u1, 1);\n                        addVertex(lastPointL, u0, 0);\n                        addVertex(innerPoint, u1, 0);\n                        addVertex(currentPointR, u1, 1);\n                        addVertex(currentPointR, u, 1);\n                        addVertex(nextPointR, u, 0);\n                        addVertex(innerPoint, u, 0.5);\n                    }\n                } else {\n                    if (joinIsOnLeftSide) {\n                        addVertex(currentPointL, u, 0);\n                        addVertex(nextPointL, u, 0);\n                        addVertex(currentPoint, u, 0.5);\n                    } else {\n                        addVertex(currentPointR, u, 1);\n                        addVertex(nextPointR, u, 0);\n                        addVertex(currentPoint, u, 0.5);\n                    }\n                }\n            }\n            function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n                if (innerSideModified) {\n                    if (joinIsOnLeftSide) {\n                        addVertex(lastPointR, u0, 1);\n                        addVertex(lastPointL, u0, 0);\n                        addVertex(currentPointL, u1, 0);\n                        addVertex(lastPointR, u0, 1);\n                        addVertex(currentPointL, u1, 0);\n                        addVertex(innerPoint, u1, 1);\n                        addVertex(currentPointL, u0, 0);\n                        addVertex(currentPoint, u1, 0.5);\n                        addVertex(innerPoint, u1, 1);\n                        addVertex(currentPoint, u1, 0.5);\n                        addVertex(nextPointL, u0, 0);\n                        addVertex(innerPoint, u1, 1);\n                    } else {\n                        addVertex(lastPointR, u0, 1);\n                        addVertex(lastPointL, u0, 0);\n                        addVertex(currentPointR, u1, 1);\n                        addVertex(lastPointL, u0, 0);\n                        addVertex(innerPoint, u1, 0);\n                        addVertex(currentPointR, u1, 1);\n                        addVertex(currentPointR, u0, 1);\n                        addVertex(innerPoint, u1, 0);\n                        addVertex(currentPoint, u1, 0.5);\n                        addVertex(currentPoint, u1, 0.5);\n                        addVertex(innerPoint, u1, 0);\n                        addVertex(nextPointR, u0, 1);\n                    }\n                }\n            }\n            function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n                switch (style.strokeLineCap) {\n                case 'round':\n                    if (start) {\n                        makeCircularSector(center, p2, p1, u, 0.5);\n                    } else {\n                        makeCircularSector(center, p1, p2, u, 0.5);\n                    }\n                    break;\n                case 'square':\n                    if (start) {\n                        tempV2_1.subVectors(p1, center);\n                        tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n                        tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n                        tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n                        if (joinIsOnLeftSide) {\n                            tempV2_3.toArray(vertices, 1 * 3);\n                            tempV2_4.toArray(vertices, 0 * 3);\n                            tempV2_4.toArray(vertices, 3 * 3);\n                        } else {\n                            tempV2_3.toArray(vertices, 1 * 3);\n                            tempV2_3.toArray(vertices, 3 * 3);\n                            tempV2_4.toArray(vertices, 0 * 3);\n                        }\n                    } else {\n                        tempV2_1.subVectors(p2, center);\n                        tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n                        tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n                        tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n                        var vl = vertices.length;\n                        if (joinIsOnLeftSide) {\n                            tempV2_3.toArray(vertices, vl - 1 * 3);\n                            tempV2_4.toArray(vertices, vl - 2 * 3);\n                            tempV2_4.toArray(vertices, vl - 4 * 3);\n                        } else {\n                            tempV2_3.toArray(vertices, vl - 2 * 3);\n                            tempV2_4.toArray(vertices, vl - 1 * 3);\n                            tempV2_4.toArray(vertices, vl - 4 * 3);\n                        }\n                    }\n                    break;\n                case 'butt':\n                default:\n                    break;\n                }\n            }\n            function removeDuplicatedPoints(points) {\n                var dupPoints = false;\n                for (var i = 1, n = points.length - 1; i < n; i++) {\n                    if (points[i].distanceTo(points[i + 1]) < minDistance) {\n                        dupPoints = true;\n                        break;\n                    }\n                }\n                if (!dupPoints)\n                    return points;\n                var newPoints = [];\n                newPoints.push(points[0]);\n                for (var i = 1, n = points.length - 1; i < n; i++) {\n                    if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n                        newPoints.push(points[i]);\n                    }\n                }\n                newPoints.push(points[points.length - 1]);\n                return newPoints;\n            }\n        };\n    }();\n    return threex.loaders.SVGLoader = SVGLoader;\n});"]}