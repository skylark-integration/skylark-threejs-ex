{"version":3,"sources":["loaders/VRMLLoader.js"],"names":["define","THREE","chevrotain","VRMLLoader","Error","manager","Loader","call","this","VRMLLexer","tokens","lexer","Lexer","VRMLParser","tokenVocabulary","Parser","$","Version","LCurly","RCurly","LSquare","RSquare","Identifier","RouteIdentifier","StringLiteral","HexLiteral","NumberLiteral","TrueLiteral","FalseLiteral","NullLiteral","DEF","USE","ROUTE","TO","NodeName","RULE","SUBRULE","version","AT_LEAST_ONE","node","MANY","route","CONSUME","OPTION","def","field","OR2","ALT","singleFieldValue","multiFieldValue","OR","use","CONSUME2","performSelfAnalysis","Face","a","b","c","normal","Vector3","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","text","parse","data","nodeMap","buildNodeMap","fields","i","l","length","type","fieldValues","values","j","jl","getNode","identifier","build","isObject3D","isMaterial","clone","undefined","nodeName","name","object","Group","fieldName","parseFieldChildren","axis","angle","quaternion","setFromAxisAngle","scale","set","position","console","warn","buildGroupingNode","groundAngle","groundColor","skyAngle","skyColor","group","skyGeometry","SphereBufferGeometry","skyMaterial","MeshBasicMaterial","fog","side","BackSide","depthWrite","depthTest","paintFaces","toColorArray","vertexColors","color","setRGB","sky","Mesh","add","groundGeometry","Math","PI","groundMaterial","ground","renderOrder","buildBackgroundNode","geometry","material","attributes","_type","pointsMaterial","PointsMaterial","isMeshPhongMaterial","copy","emissive","Points","lineMaterial","LineBasicMaterial","LineSegments","_solid","FrontSide","DoubleSide","Object3D","visible","buildShapeNode","transformData","MeshPhongMaterial","materialData","diffuseColor","emissiveColor","shininess","specularColor","specular","transparency","opacity","transparent","textureNode","map","__type","TEXTURE_TYPE","INTENSITY_ALPHA","RGB","RGBA","center","rotation","repeat","offset","translation","buildAppearanceNode","Color","buildMaterialNode","texture","wrapS","RepeatWrapping","wrapT","textureLoader","ClampToEdgeWrapping","buildImageTextureNode","width","height","num_components","useAlpha","textureType","getTextureType","size","Uint8Array","r","g","k","parseHexColor","stride","DataTexture","RGBAFormat","RGBFormat","buildPixelTextureNode","Vector2","buildTextureTransformNode","coord","texCoord","colorIndex","coordIndex","normalIndex","texCoordIndex","ccw","solid","creaseAngle","colorPerVertex","normalPerVertex","colorNode","coordNode","normalNode","texCoordNode","BufferGeometry","positionAttribute","colorAttribute","normalAttribute","uvAttribute","triangulatedCoordIndex","triangulateFaceIndex","triangulatedColorIndex","computeAttributeFromIndexedData","toNonIndexedAttribute","Float32BufferAttribute","flattenFaceColors","flattenData","triangulatedFaceColors","triangulateFaceData","computeAttributeFromFaceData","triangulatedNormalIndex","flattenFaceNormals","triangulatedFaceNormals","index","faces","vertexNormals","face","vA","fromArray","vB","vC","cb","subVectors","ab","cross","normalize","push","normals","nA","weightedNormal","nB","nC","x","y","z","computeNormalAttribute","triangulatedTexCoordIndex","setAttribute","buildIndexedFaceSetNode","expandedLineIndex","expandLineIndex","expandedColorIndex","flattenLineColors","expandedLineColors","expandLineData","computeAttributeFromLineData","buildIndexedLineSetNode","buildPointSetNode","BoxBufferGeometry","buildBoxNode","radius","openEnded","ConeBufferGeometry","buildConeNode","CylinderBufferGeometry","buildCylinderNode","buildSphereNode","buildGeometricNode","buildNode","hex","INTENSITY","value","parseInt","substring","children","owner","indices","start","i1","i2","i3","triangulatedData","uvA","uvB","uvC","itemSize","array","faceData","lineData","attribute","array2","index2","vector","angleTo","colors","angles","topDown","thresholds","startAngle","point","setFromSphericalCoords","BufferAttribute","Float32Array","count","thresholdIndexA","thresholdIndexB","getX","fromBufferAttribute","t","thresholdA","thresholdB","abs","colorA","colorB","lerp","setXYZ","TextureLoader","resourcePath","setCrossOrigin","crossOrigin","tree","tokenData","createToken","pattern","longer_alt","RegExp","join","Comment","SKIPPED","token","createTokens","parser","visitor","BaseVRMLVisitor","VRMLToASTVisitor","validateVisitor","processField","ctx","visit","stringLiteral","image","replace","numberLiteral","parseFloat","hexLiteral","trueLiteral","falseLiteral","forEach","vrml","nodes","routes","result","FROM","createVisitor","getBaseCstVisitorConstructor","lexingResult","lex","input","cstOutput","errors","error","generateVRMLTree","indexOf","scene","Scene","parseTree","inputText","tokenize"],"mappings":"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","file":"../../loaders/VRMLLoader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE,chevrotain){\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\n\t/* global chevrotain */\n\n\tTHREE.VRMLLoader = ( function () {\n\n\t\t// dependency check\n\n\t\tif ( typeof chevrotain === 'undefined' ) {\n\n\t\t\tthrow Error( 'THREE.VRMLLoader: External library chevrotain.min.js required.' );\n\n\t\t}\n\n\t\t// class definitions\n\n\t\tfunction VRMLLoader( manager ) {\n\n\t\t\tTHREE.Loader.call( this, manager );\n\n\t\t}\n\n\t\tVRMLLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\t\tconstructor: VRMLLoader,\n\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tvar path = ( scope.path === '' ) ? THREE.LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\t\tloader.setPath( scope.path );\n\t\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t},\n\n\t\t\tparse: function ( data, path ) {\n\n\t\t\t\tvar nodeMap = {};\n\n\t\t\t\tfunction generateVRMLTree( data ) {\n\n\t\t\t\t\t// create lexer, parser and visitor\n\n\t\t\t\t\tvar tokenData = createTokens();\n\n\t\t\t\t\tvar lexer = new VRMLLexer( tokenData.tokens );\n\t\t\t\t\tvar parser = new VRMLParser( tokenData.tokenVocabulary );\n\t\t\t\t\tvar visitor = createVisitor( parser.getBaseCstVisitorConstructor() );\n\n\t\t\t\t\t// lexing\n\n\t\t\t\t\tvar lexingResult = lexer.lex( data );\n\t\t\t\t\tparser.input = lexingResult.tokens;\n\n\t\t\t\t\t// parsing\n\n\t\t\t\t\tvar cstOutput = parser.vrml();\n\n\t\t\t\t\tif ( parser.errors.length > 0 ) {\n\n\t\t\t\t\t\tconsole.error( parser.errors );\n\n\t\t\t\t\t\tthrow Error( 'THREE.VRMLLoader: Parsing errors detected.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// actions\n\n\t\t\t\t\tvar ast = visitor.visit( cstOutput );\n\n\t\t\t\t\treturn ast;\n\n\t\t\t\t}\n\n\t\t\t\tfunction createTokens() {\n\n\t\t\t\t\tvar createToken = chevrotain.createToken;\n\n\t\t\t\t\t// from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n\n\t\t\t\t\tvar RouteIdentifier = createToken( { name: 'RouteIdentifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/ } );\n\t\t\t\t\tvar Identifier = createToken( { name: 'Identifier', pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/, longer_alt: RouteIdentifier } );\n\n\t\t\t\t\t// from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n\t\t\t\t\tvar nodeTypes = [\n\t\t\t\t\t\t'Anchor', 'Billboard', 'Collision', 'Group', 'Transform', // grouping nodes\n\t\t\t\t\t\t'Inline', 'LOD', 'Switch', // special groups\n\t\t\t\t\t\t'AudioClip', 'DirectionalLight', 'PointLight', 'Script', 'Shape', 'Sound', 'SpotLight', 'WorldInfo', // common nodes\n\t\t\t\t\t\t'CylinderSensor', 'PlaneSensor', 'ProximitySensor', 'SphereSensor', 'TimeSensor', 'TouchSensor', 'VisibilitySensor', // sensors\n\t\t\t\t\t\t'Box', 'Cone', 'Cylinder', 'ElevationGrid', 'Extrusion', 'IndexedFaceSet', 'IndexedLineSet', 'PointSet', 'Sphere', // geometries\n\t\t\t\t\t\t'Color', 'Coordinate', 'Normal', 'TextureCoordinate', // geometric properties\n\t\t\t\t\t\t'Appearance', 'FontStyle', 'ImageTexture', 'Material', 'MovieTexture', 'PixelTexture', 'TextureTransform', // appearance\n\t\t\t\t\t\t'ColorInterpolator', 'CoordinateInterpolator', 'NormalInterpolator', 'OrientationInterpolator', 'PositionInterpolator', 'ScalarInterpolator', // interpolators\n\t\t\t\t\t\t'Background', 'Fog', 'NavigationInfo', 'Viewpoint', // bindable nodes\n\t\t\t\t\t\t'Text' // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n\t\t\t\t\t];\n\n\t\t\t\t\t//\n\n\t\t\t\t\tvar Version = createToken( {\n\t\t\t\t\t\tname: 'Version',\n\t\t\t\t\t\tpattern: /#VRML.*/,\n\t\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t\t} );\n\n\t\t\t\t\tvar NodeName = createToken( {\n\t\t\t\t\t\tname: 'NodeName',\n\t\t\t\t\t\tpattern: new RegExp( nodeTypes.join( '|' ) ),\n\t\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t\t} );\n\n\t\t\t\t\tvar DEF = createToken( {\n\t\t\t\t\t\tname: 'DEF',\n\t\t\t\t\t\tpattern: /DEF/,\n\t\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t\t} );\n\n\t\t\t\t\tvar USE = createToken( {\n\t\t\t\t\t\tname: 'USE',\n\t\t\t\t\t\tpattern: /USE/,\n\t\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t\t} );\n\n\t\t\t\t\tvar ROUTE = createToken( {\n\t\t\t\t\t\tname: 'ROUTE',\n\t\t\t\t\t\tpattern: /ROUTE/,\n\t\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t\t} );\n\n\t\t\t\t\tvar TO = createToken( {\n\t\t\t\t\t\tname: 'TO',\n\t\t\t\t\t\tpattern: /TO/,\n\t\t\t\t\t\tlonger_alt: Identifier\n\t\t\t\t\t} );\n\n\t\t\t\t\t//\n\n\t\t\t\t\tvar StringLiteral = createToken( { name: \"StringLiteral\", pattern: /\"(:?[^\\\\\"\\n\\r]+|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/ } );\n\t\t\t\t\tvar HexLiteral = createToken( { name: 'HexLiteral', pattern: /0[xX][0-9a-fA-F]+/ } );\n\t\t\t\t\tvar NumberLiteral = createToken( { name: 'NumberLiteral', pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/ } );\n\t\t\t\t\tvar TrueLiteral = createToken( { name: 'TrueLiteral', pattern: /TRUE/ } );\n\t\t\t\t\tvar FalseLiteral = createToken( { name: 'FalseLiteral', pattern: /FALSE/ } );\n\t\t\t\t\tvar NullLiteral = createToken( { name: 'NullLiteral', pattern: /NULL/ } );\n\t\t\t\t\tvar LSquare = createToken( { name: 'LSquare', pattern: /\\[/ } );\n\t\t\t\t\tvar RSquare = createToken( { name: 'RSquare', pattern: /]/ } );\n\t\t\t\t\tvar LCurly = createToken( { name: 'LCurly', pattern: /{/ } );\n\t\t\t\t\tvar RCurly = createToken( { name: 'RCurly', pattern: /}/ } );\n\t\t\t\t\tvar Comment = createToken( {\n\t\t\t\t\t\tname: 'Comment',\n\t\t\t\t\t\tpattern: /#.*/,\n\t\t\t\t\t\tgroup: chevrotain.Lexer.SKIPPED\n\t\t\t\t\t} );\n\n\t\t\t\t\t// commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n\t\t\t\t\tvar WhiteSpace = createToken( {\n\t\t\t\t\t\tname: 'WhiteSpace',\n\t\t\t\t\t\tpattern: /[ ,\\s]/,\n\t\t\t\t\t\tgroup: chevrotain.Lexer.SKIPPED\n\t\t\t\t\t} );\n\n\t\t\t\t\tvar tokens = [\n\t\t\t\t\t\tWhiteSpace,\n\t\t\t\t\t\t// keywords appear before the Identifier\n\t\t\t\t\t\tNodeName,\n\t\t\t\t\t\tDEF,\n\t\t\t\t\t\tUSE,\n\t\t\t\t\t\tROUTE,\n\t\t\t\t\t\tTO,\n\t\t\t\t\t\tTrueLiteral,\n\t\t\t\t\t\tFalseLiteral,\n\t\t\t\t\t\tNullLiteral,\n\t\t\t\t\t\t// the Identifier must appear after the keywords because all keywords are valid identifiers\n\t\t\t\t\t\tVersion,\n\t\t\t\t\t\tIdentifier,\n\t\t\t\t\t\tRouteIdentifier,\n\t\t\t\t\t\tStringLiteral,\n\t\t\t\t\t\tHexLiteral,\n\t\t\t\t\t\tNumberLiteral,\n\t\t\t\t\t\tLSquare,\n\t\t\t\t\t\tRSquare,\n\t\t\t\t\t\tLCurly,\n\t\t\t\t\t\tRCurly,\n\t\t\t\t\t\tComment\n\t\t\t\t\t];\n\n\t\t\t\t\tvar tokenVocabulary = {};\n\n\t\t\t\t\tfor ( var i = 0, l = tokens.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar token = tokens[ i ];\n\n\t\t\t\t\t\ttokenVocabulary[ token.name ] = token;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { tokens: tokens, tokenVocabulary: tokenVocabulary };\n\n\t\t\t\t}\n\n\n\t\t\t\tfunction createVisitor( BaseVRMLVisitor ) {\n\n\t\t\t\t\t// the visitor is created dynmaically based on the given base class\n\n\t\t\t\t\tfunction VRMLToASTVisitor() {\n\n\t\t\t\t\t\tBaseVRMLVisitor.call( this );\n\n\t\t\t\t\t\tthis.validateVisitor();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tVRMLToASTVisitor.prototype = Object.assign( Object.create( BaseVRMLVisitor.prototype ), {\n\n\t\t\t\t\t\tconstructor: VRMLToASTVisitor,\n\n\t\t\t\t\t\tvrml: function ( ctx ) {\n\n\t\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\t\tversion: this.visit( ctx.version ),\n\t\t\t\t\t\t\t\tnodes: [],\n\t\t\t\t\t\t\t\troutes: []\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.node.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar node = ctx.node[ i ];\n\n\t\t\t\t\t\t\t\tdata.nodes.push( this.visit( node ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( ctx.route ) {\n\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.route.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar route = ctx.route[ i ];\n\n\t\t\t\t\t\t\t\t\tdata.routes.push( this.visit( route ) );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tversion: function ( ctx ) {\n\n\t\t\t\t\t\t\treturn ctx.Version[ 0 ].image;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tnode: function ( ctx ) {\n\n\t\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\t\tname: ctx.NodeName[ 0 ].image,\n\t\t\t\t\t\t\t\tfields: []\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tif ( ctx.field ) {\n\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.field.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tvar field = ctx.field[ i ];\n\n\t\t\t\t\t\t\t\t\tdata.fields.push( this.visit( field ) );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// DEF\n\n\t\t\t\t\t\t\tif ( ctx.def ) {\n\n\t\t\t\t\t\t\t\tdata.DEF = this.visit( ctx.def[ 0 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tfield: function ( ctx ) {\n\n\t\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\t\tname: ctx.Identifier[ 0 ].image,\n\t\t\t\t\t\t\t\ttype: null,\n\t\t\t\t\t\t\t\tvalues: null\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tvar result;\n\n\t\t\t\t\t\t\t// SFValue\n\n\t\t\t\t\t\t\tif ( ctx.singleFieldValue ) {\n\n\t\t\t\t\t\t\t\tresult = this.visit( ctx.singleFieldValue[ 0 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// MFValue\n\n\t\t\t\t\t\t\tif ( ctx.multiFieldValue ) {\n\n\t\t\t\t\t\t\t\tresult = this.visit( ctx.multiFieldValue[ 0 ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdata.type = result.type;\n\t\t\t\t\t\t\tdata.values = result.values;\n\n\t\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tdef: function ( ctx ) {\n\n\t\t\t\t\t\t\treturn ctx.Identifier[ 0 ].image;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tuse: function ( ctx ) {\n\n\t\t\t\t\t\t\treturn { USE: ctx.Identifier[ 0 ].image };\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsingleFieldValue: function ( ctx ) {\n\n\t\t\t\t\t\t\treturn processField( this, ctx );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tmultiFieldValue: function ( ctx ) {\n\n\t\t\t\t\t\t\treturn processField( this, ctx );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\troute: function ( ctx ) {\n\n\t\t\t\t\t\t\tvar data = {\n\t\t\t\t\t\t\t\tFROM: ctx.RouteIdentifier[ 0 ].image,\n\t\t\t\t\t\t\t\tTO: ctx.RouteIdentifier[ 1 ].image\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\treturn data;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tfunction processField( scope, ctx ) {\n\n\t\t\t\t\t\tvar field = {\n\t\t\t\t\t\t\ttype: null,\n\t\t\t\t\t\t\tvalues: []\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif ( ctx.node ) {\n\n\t\t\t\t\t\t\tfield.type = 'node';\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.node.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar node = ctx.node[ i ];\n\n\t\t\t\t\t\t\t\tfield.values.push( scope.visit( node ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ctx.use ) {\n\n\t\t\t\t\t\t\tfield.type = 'use';\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.use.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar use = ctx.use[ i ];\n\n\t\t\t\t\t\t\t\tfield.values.push( scope.visit( use ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ctx.StringLiteral ) {\n\n\t\t\t\t\t\t\tfield.type = 'string';\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.StringLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar stringLiteral = ctx.StringLiteral[ i ];\n\n\t\t\t\t\t\t\t\tfield.values.push( stringLiteral.image.replace( /'|\"/g, '' ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ctx.NumberLiteral ) {\n\n\t\t\t\t\t\t\tfield.type = 'number';\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.NumberLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar numberLiteral = ctx.NumberLiteral[ i ];\n\n\t\t\t\t\t\t\t\tfield.values.push( parseFloat( numberLiteral.image ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ctx.HexLiteral ) {\n\n\t\t\t\t\t\t\tfield.type = 'hex';\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.HexLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar hexLiteral = ctx.HexLiteral[ i ];\n\n\t\t\t\t\t\t\t\tfield.values.push( hexLiteral.image );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ctx.TrueLiteral ) {\n\n\t\t\t\t\t\t\tfield.type = 'boolean';\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.TrueLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar trueLiteral = ctx.TrueLiteral[ i ];\n\n\t\t\t\t\t\t\t\tif ( trueLiteral.image === 'TRUE' ) field.values.push( true );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ctx.FalseLiteral ) {\n\n\t\t\t\t\t\t\tfield.type = 'boolean';\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = ctx.FalseLiteral.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar falseLiteral = ctx.FalseLiteral[ i ];\n\n\t\t\t\t\t\t\t\tif ( falseLiteral.image === 'FALSE' ) field.values.push( false );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ctx.NullLiteral ) {\n\n\t\t\t\t\t\t\tfield.type = 'null';\n\n\t\t\t\t\t\t\tctx.NullLiteral.forEach( function () {\n\n\t\t\t\t\t\t\t\tfield.values.push( null );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn field;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new VRMLToASTVisitor();\n\n\t\t\t\t}\n\n\t\t\t\tfunction parseTree( tree ) {\n\n\t\t\t\t\t// console.log( JSON.stringify( tree, null, 2 ) );\n\n\t\t\t\t\tvar nodes = tree.nodes;\n\t\t\t\t\tvar scene = new THREE.Scene();\n\n\t\t\t\t\t// first iteration: build nodemap based on DEF statements\n\n\t\t\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar node = nodes[ i ];\n\n\t\t\t\t\t\tbuildNodeMap( node );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// second iteration: build nodes\n\n\t\t\t\t\tfor ( var i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar node = nodes[ i ];\n\t\t\t\t\t\tvar object = getNode( node );\n\n\t\t\t\t\t\tif ( object instanceof THREE.Object3D ) scene.add( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn scene;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildNodeMap( node ) {\n\n\t\t\t\t\tif ( node.DEF ) {\n\n\t\t\t\t\t\tnodeMap[ node.DEF ] = node;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\n\t\t\t\t\t\tif ( field.type === 'node' ) {\n\n\t\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = fieldValues.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tbuildNodeMap( fieldValues[ j ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tfunction getNode( node ) {\n\n\t\t\t\t\t// handle case where a node refers to a different one\n\n\t\t\t\t\tif ( node.USE ) {\n\n\t\t\t\t\t\treturn resolveUSE( node.USE );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( node.build !== undefined ) return node.build;\n\n\t\t\t\t\tnode.build = buildNode( node );\n\n\t\t\t\t\treturn node.build;\n\n\t\t\t\t}\n\n\t\t\t\t// node builder\n\n\t\t\t\tfunction buildNode( node ) {\n\n\t\t\t\t\tvar nodeName = node.name;\n\t\t\t\t\tvar build;\n\n\t\t\t\t\tswitch ( nodeName ) {\n\n\t\t\t\t\t\tcase 'Group':\n\t\t\t\t\t\tcase 'Transform':\n\t\t\t\t\t\t\tbuild = buildGroupingNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Background':\n\t\t\t\t\t\t\tbuild = buildBackgroundNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Shape':\n\t\t\t\t\t\t\tbuild = buildShapeNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Appearance':\n\t\t\t\t\t\t\tbuild = buildAppearanceNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Material':\n\t\t\t\t\t\t\tbuild = buildMaterialNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ImageTexture':\n\t\t\t\t\t\t\tbuild = buildImageTextureNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'PixelTexture':\n\t\t\t\t\t\t\tbuild = buildPixelTextureNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TextureTransform':\n\t\t\t\t\t\t\tbuild = buildTextureTransformNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'IndexedFaceSet':\n\t\t\t\t\t\t\tbuild = buildIndexedFaceSetNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'IndexedLineSet':\n\t\t\t\t\t\t\tbuild = buildIndexedLineSetNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'PointSet':\n\t\t\t\t\t\t\tbuild = buildPointSetNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Box':\n\t\t\t\t\t\t\tbuild = buildBoxNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Cone':\n\t\t\t\t\t\t\tbuild = buildConeNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Cylinder':\n\t\t\t\t\t\t\tbuild = buildCylinderNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Sphere':\n\t\t\t\t\t\t\tbuild = buildSphereNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Color':\n\t\t\t\t\t\tcase 'Coordinate':\n\t\t\t\t\t\tcase 'Normal':\n\t\t\t\t\t\tcase 'TextureCoordinate':\n\t\t\t\t\t\t\tbuild = buildGeometricNode( node );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Anchor':\n\t\t\t\t\t\tcase 'Billboard':\n\t\t\t\t\t\tcase 'Collision':\n\n\t\t\t\t\t\tcase 'Inline':\n\t\t\t\t\t\tcase 'LOD':\n\t\t\t\t\t\tcase 'Switch':\n\n\t\t\t\t\t\tcase 'AudioClip':\n\t\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\tcase 'Script':\n\t\t\t\t\t\tcase 'Sound':\n\t\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\tcase 'WorldInfo':\n\n\t\t\t\t\t\tcase 'CylinderSensor':\n\t\t\t\t\t\tcase 'PlaneSensor':\n\t\t\t\t\t\tcase 'ProximitySensor':\n\t\t\t\t\t\tcase 'SphereSensor':\n\t\t\t\t\t\tcase 'TimeSensor':\n\t\t\t\t\t\tcase 'TouchSensor':\n\t\t\t\t\t\tcase 'VisibilitySensor':\n\n\t\t\t\t\t\tcase 'ElevationGrid':\n\t\t\t\t\t\tcase 'Extrusion':\n\t\t\t\t\t\tcase 'Text':\n\n\t\t\t\t\t\tcase 'FontStyle':\n\t\t\t\t\t\tcase 'MovieTexture':\n\n\t\t\t\t\t\tcase 'ColorInterpolator':\n\t\t\t\t\t\tcase 'CoordinateInterpolator':\n\t\t\t\t\t\tcase 'NormalInterpolator':\n\t\t\t\t\t\tcase 'OrientationInterpolator':\n\t\t\t\t\t\tcase 'PositionInterpolator':\n\t\t\t\t\t\tcase 'ScalarInterpolator':\n\n\t\t\t\t\t\tcase 'Fog':\n\t\t\t\t\t\tcase 'NavigationInfo':\n\t\t\t\t\t\tcase 'Viewpoint':\n\t\t\t\t\t\t\t// node not supported yet\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown node:', nodeName );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn build;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildGroupingNode( node ) {\n\n\t\t\t\t\tvar object = new THREE.Group();\n\n\t\t\t\t\t//\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\t\tcase 'center':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'children':\n\t\t\t\t\t\t\t\tparseFieldChildren( fieldValues, object );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\t\t\tvar axis = new THREE.Vector3( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\t\tvar angle = fieldValues[ 3 ];\n\t\t\t\t\t\t\t\tobject.quaternion.setFromAxisAngle( axis, angle );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\tobject.scale.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'scaleOrientation':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\t\t\tobject.position.set( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'bboxCenter':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'bboxSize':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildBackgroundNode( node ) {\n\n\t\t\t\t\tvar group = new THREE.Group();\n\n\t\t\t\t\tvar groundAngle, groundColor;\n\t\t\t\t\tvar skyAngle, skyColor;\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\t\tcase 'groundAngle':\n\t\t\t\t\t\t\t\tgroundAngle = fieldValues;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'groundColor':\n\t\t\t\t\t\t\t\tgroundColor = fieldValues;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'backUrl':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'bottomUrl':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'frontUrl':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'leftUrl':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'rightUrl':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'topUrl':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skyAngle':\n\t\t\t\t\t\t\t\tskyAngle = fieldValues;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skyColor':\n\t\t\t\t\t\t\t\tskyColor = fieldValues;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar radius = 10000;\n\n\t\t\t\t\t// sky\n\n\t\t\t\t\tif ( skyColor ) {\n\n\t\t\t\t\t\tvar skyGeometry = new THREE.SphereBufferGeometry( radius, 32, 16 );\n\t\t\t\t\t\tvar skyMaterial = new THREE.MeshBasicMaterial( { fog: false, side: THREE.BackSide, depthWrite: false, depthTest: false } );\n\n\t\t\t\t\t\tif ( skyColor.length > 3 ) {\n\n\t\t\t\t\t\t\tpaintFaces( skyGeometry, radius, skyAngle, toColorArray( skyColor ), true );\n\t\t\t\t\t\t\tskyMaterial.vertexColors = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tskyMaterial.color.setRGB( skyColor[ 0 ], skyColor[ 1 ], skyColor[ 2 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar sky = new THREE.Mesh( skyGeometry, skyMaterial );\n\t\t\t\t\t\tgroup.add( sky );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// ground\n\n\t\t\t\t\tif ( groundColor ) {\n\n\t\t\t\t\t\tif ( groundColor.length > 0 ) {\n\n\t\t\t\t\t\t\tvar groundGeometry = new THREE.SphereBufferGeometry( radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI );\n\t\t\t\t\t\t\tvar groundMaterial = new THREE.MeshBasicMaterial( { fog: false, side: THREE.BackSide, vertexColors: true, depthWrite: false, depthTest: false } );\n\n\t\t\t\t\t\t\tpaintFaces( groundGeometry, radius, groundAngle, toColorArray( groundColor ), false );\n\n\t\t\t\t\t\t\tvar ground = new THREE.Mesh( groundGeometry, groundMaterial );\n\t\t\t\t\t\t\tgroup.add( ground );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// render background group first\n\n\t\t\t\t\tgroup.renderOrder = - Infinity;\n\n\t\t\t\t\treturn group;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildShapeNode( node ) {\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\t// if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n\t\t\t\t\tvar material = new THREE.MeshBasicMaterial( { color: 0x000000 } );\n\t\t\t\t\tvar geometry;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\t\tcase 'appearance':\n\t\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\t\tmaterial = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'geometry':\n\t\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\t\tgeometry = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// build 3D object\n\n\t\t\t\t\tvar object;\n\n\t\t\t\t\tif ( geometry && geometry.attributes.position ) {\n\n\t\t\t\t\t\tvar type = geometry._type;\n\n\t\t\t\t\t\tif ( type === 'points' ) { // points\n\n\t\t\t\t\t\t\tvar pointsMaterial = new THREE.PointsMaterial( { color: 0xffffff } );\n\n\t\t\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\t\t\tpointsMaterial.vertexColors = true;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n\n\t\t\t\t\t\t\t\tif ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\t\t\t\t\tpointsMaterial.color.copy( material.emissive );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject = new THREE.Points( geometry, pointsMaterial );\n\n\t\t\t\t\t\t} else if ( type === 'line' ) { // lines\n\n\t\t\t\t\t\t\tvar lineMaterial = new THREE.LineBasicMaterial( { color: 0xffffff } );\n\n\t\t\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\t\t\tlineMaterial.vertexColors = true;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n\n\t\t\t\t\t\t\t\tif ( material.isMeshPhongMaterial ) {\n\n\t\t\t\t\t\t\t\t\tlineMaterial.color.copy( material.emissive );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject = new THREE.LineSegments( geometry, lineMaterial );\n\n\t\t\t\t\t\t} else { // consider meshes\n\n\t\t\t\t\t\t\t// check \"solid\" hint (it's placed in the geometry but affects the material)\n\n\t\t\t\t\t\t\tif ( geometry._solid !== undefined ) {\n\n\t\t\t\t\t\t\t\tmaterial.side = ( geometry._solid ) ? THREE.FrontSide : THREE.DoubleSide;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// check for vertex colors\n\n\t\t\t\t\t\t\tif ( geometry.attributes.color !== undefined ) {\n\n\t\t\t\t\t\t\t\tmaterial.vertexColors = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject = new THREE.Object3D();\n\n\t\t\t\t\t\t// if the geometry field is NULL or no vertices are defined the object is not drawn\n\n\t\t\t\t\t\tobject.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildAppearanceNode( node ) {\n\n\t\t\t\t\tvar material = new THREE.MeshPhongMaterial();\n\t\t\t\t\tvar transformData;\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\t\tcase 'material':\n\t\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\t\tvar materialData = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t\t\tif ( materialData.diffuseColor ) material.color.copy( materialData.diffuseColor );\n\t\t\t\t\t\t\t\t\tif ( materialData.emissiveColor ) material.emissive.copy( materialData.emissiveColor );\n\t\t\t\t\t\t\t\t\tif ( materialData.shininess ) material.shininess = materialData.shininess;\n\t\t\t\t\t\t\t\t\tif ( materialData.specularColor ) material.specular.copy( materialData.specularColor );\n\t\t\t\t\t\t\t\t\tif ( materialData.transparency ) material.opacity = 1 - materialData.transparency;\n\t\t\t\t\t\t\t\t\tif ( materialData.transparency > 0 ) material.transparent = true;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n\t\t\t\t\t\t\t\t\tmaterial = new THREE.MeshBasicMaterial( { color: 0x000000 } );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\t\t\tvar textureNode = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tif ( textureNode !== null ) {\n\n\t\t\t\t\t\t\t\t\tif ( textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture' ) {\n\n\t\t\t\t\t\t\t\t\t\tmaterial.map = getNode( textureNode );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// MovieTexture not supported yet\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'textureTransform':\n\t\t\t\t\t\t\t\tif ( fieldValues[ 0 ] !== null ) {\n\n\t\t\t\t\t\t\t\t\ttransformData = getNode( fieldValues[ 0 ] );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// only apply texture transform data if a texture was defined\n\n\t\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\t\t// respect VRML lighting model\n\n\t\t\t\t\t\tif ( material.map.__type ) {\n\n\t\t\t\t\t\t\tswitch ( material.map.__type ) {\n\n\t\t\t\t\t\t\t\tcase TEXTURE_TYPE.INTENSITY_ALPHA:\n\t\t\t\t\t\t\t\t\tmaterial.opacity = 1; // ignore transparency\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase TEXTURE_TYPE.RGB:\n\t\t\t\t\t\t\t\t\tmaterial.color.set( 0xffffff ); // ignore material color\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase TEXTURE_TYPE.RGBA:\n\t\t\t\t\t\t\t\t\tmaterial.color.set( 0xffffff ); // ignore material color\n\t\t\t\t\t\t\t\t\tmaterial.opacity = 1; // ignore transparency\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdelete material.map.__type;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// apply texture transform\n\n\t\t\t\t\t\tif ( transformData ) {\n\n\t\t\t\t\t\t\tmaterial.map.center.copy( transformData.center );\n\t\t\t\t\t\t\tmaterial.map.rotation = transformData.rotation;\n\t\t\t\t\t\t\tmaterial.map.repeat.copy( transformData.scale );\n\t\t\t\t\t\t\tmaterial.map.offset.copy( transformData.translation );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn material;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildMaterialNode( node ) {\n\n\t\t\t\t\tvar materialData = {};\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\t\tcase 'ambientIntensity':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'diffuseColor':\n\t\t\t\t\t\t\t\tmaterialData.diffuseColor = new THREE.Color( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'emissiveColor':\n\t\t\t\t\t\t\t\tmaterialData.emissiveColor = new THREE.Color( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\t\t\tmaterialData.shininess = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'specularColor':\n\t\t\t\t\t\t\t\tmaterialData.emissiveColor = new THREE.Color( fieldValues[ 0 ], fieldValues[ 1 ], fieldValues[ 2 ] );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\t\tmaterialData.transparency = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn materialData;\n\n\t\t\t\t}\n\n\t\t\t\tfunction parseHexColor( hex, textureType, color ) {\n\n\t\t\t\t\tswitch ( textureType ) {\n\n\t\t\t\t\t\tcase TEXTURE_TYPE.INTENSITY:\n\t\t\t\t\t\t\t// Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n\t\t\t\t\t\t\tvar value = parseInt( hex );\n\t\t\t\t\t\t\tcolor.r = value;\n\t\t\t\t\t\t\tcolor.g = value;\n\t\t\t\t\t\t\tcolor.b = value;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TEXTURE_TYPE.INTENSITY_ALPHA:\n\t\t\t\t\t\t\t// Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n\t\t\t\t\t\t\tvar value = parseInt( \"0x\" + hex.substring( 2, 4 ) );\n\t\t\t\t\t\t\tcolor.r = value;\n\t\t\t\t\t\t\tcolor.g = value;\n\t\t\t\t\t\t\tcolor.b = value;\n\t\t\t\t\t\t\tcolor.a = parseInt( \"0x\" + hex.substring( 4, 6 ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TEXTURE_TYPE.RGB:\n\t\t\t\t\t\t\t// RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n\t\t\t\t\t\t\tcolor.r = parseInt( \"0x\" + hex.substring( 2, 4 ) );\n\t\t\t\t\t\t\tcolor.g = parseInt( \"0x\" + hex.substring( 4, 6 ) );\n\t\t\t\t\t\t\tcolor.b = parseInt( \"0x\" + hex.substring( 6, 8 ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TEXTURE_TYPE.RGBA:\n\t\t\t\t\t\t\t// RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n\t\t\t\t\t\t\tcolor.r = parseInt( \"0x\" + hex.substring( 2, 4 ) );\n\t\t\t\t\t\t\tcolor.g = parseInt( \"0x\" + hex.substring( 4, 6 ) );\n\t\t\t\t\t\t\tcolor.b = parseInt( \"0x\" + hex.substring( 6, 8 ) );\n\t\t\t\t\t\t\tcolor.a = parseInt( \"0x\" + hex.substring( 8, 10 ) );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfunction getTextureType( num_components ) {\n\n\t\t\t\t\tvar type;\n\n\t\t\t\t\tswitch ( num_components ) {\n\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\ttype = TEXTURE_TYPE.INTENSITY;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\ttype = TEXTURE_TYPE.INTENSITY_ALPHA;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\ttype = TEXTURE_TYPE.RGB;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\ttype = TEXTURE_TYPE.RGBA;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn type;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildPixelTextureNode( node ) {\n\n\t\t\t\t\tvar texture;\n\t\t\t\t\tvar wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tvar wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\t\tcase 'image':\n\t\t\t\t\t\t\t\tvar width = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tvar height = fieldValues[ 1 ];\n\t\t\t\t\t\t\t\tvar num_components = fieldValues[ 2 ];\n\n\t\t\t\t\t\t\t\tvar useAlpha = ( num_components === 2 || num_components === 4 );\n\t\t\t\t\t\t\t\tvar textureType = getTextureType( num_components );\n\n\t\t\t\t\t\t\t\tvar size = ( ( useAlpha === true ) ? 4 : 3 ) * ( width * height );\n\t\t\t\t\t\t\t\tvar data = new Uint8Array( size );\n\n\t\t\t\t\t\t\t\tvar color = { r: 0, g: 0, b: 0, a: 0 };\n\n\t\t\t\t\t\t\t\tfor ( var j = 3, k = 0, jl = fieldValues.length; j < jl; j ++, k ++ ) {\n\n\t\t\t\t\t\t\t\t\tparseHexColor( fieldValues[ j ], textureType, color );\n\n\t\t\t\t\t\t\t\t\tif ( useAlpha === true ) {\n\n\t\t\t\t\t\t\t\t\t\tvar stride = k * 4;\n\n\t\t\t\t\t\t\t\t\t\tdata[ stride + 0 ] = color.r;\n\t\t\t\t\t\t\t\t\t\tdata[ stride + 1 ] = color.g;\n\t\t\t\t\t\t\t\t\t\tdata[ stride + 2 ] = color.b;\n\t\t\t\t\t\t\t\t\t\tdata[ stride + 3 ] = color.a;\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tvar stride = k * 3;\n\n\t\t\t\t\t\t\t\t\t\tdata[ stride + 0 ] = color.r;\n\t\t\t\t\t\t\t\t\t\tdata[ stride + 1 ] = color.g;\n\t\t\t\t\t\t\t\t\t\tdata[ stride + 2 ] = color.b;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttexture = new THREE.DataTexture( data, width, height, ( useAlpha === true ) ? THREE.RGBAFormat : THREE.RGBFormat );\n\t\t\t\t\t\t\t\ttexture.__type = textureType; // needed for material modifications\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'repeatS':\n\t\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapS = THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'repeatT':\n\t\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapT = THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texture ) {\n\n\t\t\t\t\t\ttexture.wrapS = wrapS;\n\t\t\t\t\t\ttexture.wrapT = wrapT;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn texture;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildImageTextureNode( node ) {\n\n\t\t\t\t\tvar texture;\n\t\t\t\t\tvar wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tvar wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\t\tcase 'url':\n\t\t\t\t\t\t\t\tvar url = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tif ( url ) texture = textureLoader.load( url );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'repeatS':\n\t\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapS = THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'repeatT':\n\t\t\t\t\t\t\t\tif ( fieldValues[ 0 ] === false ) wrapT = THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texture ) {\n\n\t\t\t\t\t\ttexture.wrapS = wrapS;\n\t\t\t\t\t\ttexture.wrapT = wrapT;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn texture;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildTextureTransformNode( node ) {\n\n\t\t\t\t\tvar transformData = {\n\t\t\t\t\t\tcenter: new THREE.Vector2(),\n\t\t\t\t\t\trotation: new THREE.Vector2(),\n\t\t\t\t\t\tscale: new THREE.Vector2(),\n\t\t\t\t\t\ttranslation: new THREE.Vector2()\n\t\t\t\t\t};\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\t\tcase 'center':\n\t\t\t\t\t\t\t\ttransformData.center.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\t\t\ttransformData.rotation = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\ttransformData.scale.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\t\t\ttransformData.translation.set( fieldValues[ 0 ], fieldValues[ 1 ] );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn transformData;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildGeometricNode( node ) {\n\n\t\t\t\t\treturn node.fields[ 0 ].values;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildIndexedFaceSetNode( node ) {\n\n\t\t\t\t\tvar color, coord, normal, texCoord;\n\t\t\t\t\tvar ccw = true, solid = true, creaseAngle = 0;\n\t\t\t\t\tvar colorIndex, coordIndex, normalIndex, texCoordIndex;\n\t\t\t\t\tvar colorPerVertex = true, normalPerVertex = true;\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\t\tvar colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\t\t\tvar coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'normal':\n\t\t\t\t\t\t\t\tvar normalNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\t\tif ( normalNode !== null ) {\n\n\t\t\t\t\t\t\t\t\tnormal = getNode( normalNode );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'texCoord':\n\t\t\t\t\t\t\t\tvar texCoordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\t\tif ( texCoordNode !== null ) {\n\n\t\t\t\t\t\t\t\t\ttexCoord = getNode( texCoordNode );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\t\t\tccw = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'colorIndex':\n\t\t\t\t\t\t\t\tcolorIndex = fieldValues;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'convex':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\t\t\t\tcoordIndex = fieldValues;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'creaseAngle':\n\t\t\t\t\t\t\t\tcreaseAngle = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'normalIndex':\n\t\t\t\t\t\t\t\tnormalIndex = fieldValues;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'normalPerVertex':\n\t\t\t\t\t\t\t\tnormalPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\t\t\tsolid = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'texCoordIndex':\n\t\t\t\t\t\t\t\ttexCoordIndex = fieldValues;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( coordIndex === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Missing coordIndex.' );\n\n\t\t\t\t\t\treturn new THREE.BufferGeometry(); // handle VRML files with incomplete geometry definition\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar triangulatedCoordIndex = triangulateFaceIndex( coordIndex, ccw );\n\n\t\t\t\t\tvar positionAttribute;\n\t\t\t\t\tvar colorAttribute;\n\t\t\t\t\tvar normalAttribute;\n\t\t\t\t\tvar uvAttribute;\n\n\t\t\t\t\tif ( color ) {\n\n\t\t\t\t\t\tif ( colorPerVertex === true ) {\n\n\t\t\t\t\t\t\tif ( colorIndex && colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t\t// if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\t\t\tvar triangulatedColorIndex = triangulateFaceIndex( colorIndex, ccw );\n\t\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedColorIndex, color, 3 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n\t\t\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new THREE.Float32BufferAttribute( color, 3 ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( colorIndex && colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t\t// if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n\n\t\t\t\t\t\t\t\tvar flattenFaceColors = flattenData( color, colorIndex );\n\t\t\t\t\t\t\t\tvar triangulatedFaceColors = triangulateFaceData( flattenFaceColors, coordIndex );\n\t\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n\n\t\t\t\t\t\t\t\tvar triangulatedFaceColors = triangulateFaceData( color, coordIndex );\n\t\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceColors );\n\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( normal ) {\n\n\t\t\t\t\t\tif ( normalPerVertex === true ) {\n\n\t\t\t\t\t\t\t// consider vertex normals\n\n\t\t\t\t\t\t\tif ( normalIndex && normalIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t\t// if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\t\t\tvar triangulatedNormalIndex = triangulateFaceIndex( normalIndex, ccw );\n\t\t\t\t\t\t\t\tnormalAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedNormalIndex, normal, 3 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n\n\t\t\t\t\t\t\t\tnormalAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new THREE.Float32BufferAttribute( normal, 3 ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// consider face normals\n\n\t\t\t\t\t\t\tif ( normalIndex && normalIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t\t// if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n\n\t\t\t\t\t\t\t\tvar flattenFaceNormals = flattenData( normal, normalIndex );\n\t\t\t\t\t\t\t\tvar triangulatedFaceNormals = triangulateFaceData( flattenFaceNormals, coordIndex );\n\t\t\t\t\t\t\t\tnormalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n\n\t\t\t\t\t\t\t\tvar triangulatedFaceNormals = triangulateFaceData( normal, coordIndex );\n\t\t\t\t\t\t\t\tnormalAttribute = computeAttributeFromFaceData( triangulatedCoordIndex, triangulatedFaceNormals );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n\n\t\t\t\t\t\tnormalAttribute = computeNormalAttribute( triangulatedCoordIndex, coord, creaseAngle );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( texCoord ) {\n\n\t\t\t\t\t\t// texture coordinates are always defined on vertex level\n\n\t\t\t\t\t\tif ( texCoordIndex && texCoordIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t// if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n\n\t\t\t\t\t\t\tvar triangulatedTexCoordIndex = triangulateFaceIndex( texCoordIndex, ccw );\n\t\t\t\t\t\t\tuvAttribute = computeAttributeFromIndexedData( triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2 );\n\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n\n\t\t\t\t\t\t\tuvAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new THREE.Float32BufferAttribute( texCoord, 2 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\t\tpositionAttribute = toNonIndexedAttribute( triangulatedCoordIndex, new THREE.Float32BufferAttribute( coord, 3 ) );\n\n\t\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\t\t\t\t\tgeometry.setAttribute( 'normal', normalAttribute );\n\n\t\t\t\t\t// optional attributes\n\n\t\t\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\t\t\t\t\tif ( uvAttribute ) geometry.setAttribute( 'uv', uvAttribute );\n\n\t\t\t\t\t// \"solid\" influences the material so let's store it for later use\n\n\t\t\t\t\tgeometry._solid = solid;\n\t\t\t\t\tgeometry._type = 'mesh';\n\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildIndexedLineSetNode( node ) {\n\n\t\t\t\t\tvar color, coord;\n\t\t\t\t\tvar colorIndex, coordIndex;\n\t\t\t\t\tvar colorPerVertex = true;\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\t\tvar colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\t\t\tvar coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'colorIndex':\n\t\t\t\t\t\t\t\tcolorIndex = fieldValues;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\t\t\tcolorPerVertex = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\t\t\t\tcoordIndex = fieldValues;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// build lines\n\n\t\t\t\t\tvar colorAttribute;\n\n\t\t\t\t\tvar expandedLineIndex = expandLineIndex( coordIndex ); // create an index for three.js's linesegment primitive\n\n\t\t\t\t\tif ( color ) {\n\n\t\t\t\t\t\tif ( colorPerVertex === true ) {\n\n\t\t\t\t\t\t\tif ( colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t\t// if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n\n\t\t\t\t\t\t\t\tvar expandedColorIndex = expandLineIndex( colorIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromIndexedData( expandedLineIndex, expandedColorIndex, color, 3 ); // compute data on vertex level\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n\n\t\t\t\t\t\t\t\tcolorAttribute = toNonIndexedAttribute( expandedLineIndex, new THREE.Float32BufferAttribute( color, 3 ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( colorIndex.length > 0 ) {\n\n\t\t\t\t\t\t\t\t// if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n\n\t\t\t\t\t\t\t\tvar flattenLineColors = flattenData( color, colorIndex ); // compute colors for each VRML primitve\n\t\t\t\t\t\t\t\tvar expandedLineColors = expandLineData( flattenLineColors, coordIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level\n\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n\t\t\t\t\t\t\t\tvar expandedLineColors = expandLineData( color, coordIndex ); // compute colors for each line segment (rendering primitve)\n\t\t\t\t\t\t\t\tcolorAttribute = computeAttributeFromLineData( expandedLineIndex, expandedLineColors ); // compute data on vertex level\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\t\tvar positionAttribute = toNonIndexedAttribute( expandedLineIndex, new THREE.Float32BufferAttribute( coord, 3 ) );\n\t\t\t\t\tgeometry.setAttribute( 'position', positionAttribute );\n\n\t\t\t\t\tif ( colorAttribute ) geometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t\t\tgeometry._type = 'line';\n\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildPointSetNode( node ) {\n\n\t\t\t\t\tvar geometry;\n\t\t\t\t\tvar color, coord;\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\t\tvar colorNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\t\tif ( colorNode !== null ) {\n\n\t\t\t\t\t\t\t\t\tcolor = getNode( colorNode );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'coord':\n\t\t\t\t\t\t\t\tvar coordNode = fieldValues[ 0 ];\n\n\t\t\t\t\t\t\t\tif ( coordNode !== null ) {\n\n\t\t\t\t\t\t\t\t\tcoord = getNode( coordNode );\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( coord, 3 ) );\n\t\t\t\t\tif ( color ) geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( color, 3 ) );\n\n\t\t\t\t\tgeometry._type = 'points';\n\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildBoxNode( node ) {\n\n\t\t\t\t\tvar size = new THREE.Vector3( 2, 2, 2 );\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\t\tcase 'size':\n\t\t\t\t\t\t\t\tsize.x = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tsize.y = fieldValues[ 1 ];\n\t\t\t\t\t\t\t\tsize.z = fieldValues[ 2 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar geometry = new THREE.BoxBufferGeometry( size.x, size.y, size.z );\n\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildConeNode( node ) {\n\n\t\t\t\t\tvar radius = 1, height = 2, openEnded = false;\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\t\tcase 'bottom':\n\t\t\t\t\t\t\t\topenEnded = ! fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'bottomRadius':\n\t\t\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'height':\n\t\t\t\t\t\t\t\theight = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'side':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar geometry = new THREE.ConeBufferGeometry( radius, height, 16, 1, openEnded );\n\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildCylinderNode( node ) {\n\n\t\t\t\t\tvar radius = 1, height = 2;\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\t\tcase 'bottom':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'height':\n\t\t\t\t\t\t\t\theight = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'side':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'top':\n\t\t\t\t\t\t\t\t// field not supported\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar geometry = new THREE.CylinderBufferGeometry( radius, radius, height, 16, 1 );\n\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t\tfunction buildSphereNode( node ) {\n\n\t\t\t\t\tvar radius = 1;\n\n\t\t\t\t\tvar fields = node.fields;\n\n\t\t\t\t\tfor ( var i = 0, l = fields.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar field = fields[ i ];\n\t\t\t\t\t\tvar fieldName = field.name;\n\t\t\t\t\t\tvar fieldValues = field.values;\n\n\t\t\t\t\t\tswitch ( fieldName ) {\n\n\t\t\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\t\t\tradius = fieldValues[ 0 ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.VRMLLoader: Unknown field:', fieldName );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar geometry = new THREE.SphereBufferGeometry( radius, 16, 16 );\n\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t\t// helper functions\n\n\t\t\t\tfunction resolveUSE( identifier ) {\n\n\t\t\t\t\tvar node = nodeMap[ identifier ];\n\t\t\t\t\tvar build = getNode( node );\n\n\t\t\t\t\t// because the same 3D objects can have different transformations, it's necessary to clone them.\n\t\t\t\t\t// materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n\t\t\t\t\t// any side effects\n\n\t\t\t\t\treturn ( build.isObject3D || build.isMaterial ) ? build.clone() : build;\n\n\t\t\t\t}\n\n\t\t\t\tfunction parseFieldChildren( children, owner ) {\n\n\t\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar object = getNode( children[ i ] );\n\n\t\t\t\t\t\tif ( object instanceof THREE.Object3D ) owner.add( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfunction triangulateFaceIndex( index, ccw ) {\n\n\t\t\t\t\tvar indices = [];\n\n\t\t\t\t\t// since face defintions can have more than three vertices, it's necessary to\n\t\t\t\t\t// perform a simple triangulation\n\n\t\t\t\t\tvar start = 0;\n\n\t\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar i1 = index[ start ];\n\t\t\t\t\t\tvar i2 = index[ i + ( ccw ? 1 : 2 ) ];\n\t\t\t\t\t\tvar i3 = index[ i + ( ccw ? 2 : 1 ) ];\n\n\t\t\t\t\t\tindices.push( i1, i2, i3 );\n\n\t\t\t\t\t\t// an index of -1 indicates that the current face has ended and the next one begins\n\n\t\t\t\t\t\tif ( index[ i + 3 ] === - 1 || i + 3 >= l ) {\n\n\t\t\t\t\t\t\ti += 3;\n\t\t\t\t\t\t\tstart = i + 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn indices;\n\n\t\t\t\t}\n\n\t\t\t\tfunction triangulateFaceData( data, index ) {\n\n\t\t\t\t\tvar triangulatedData = [];\n\n\t\t\t\t\tvar start = 0;\n\n\t\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar stride = start * 3;\n\n\t\t\t\t\t\tvar x = data[ stride ];\n\t\t\t\t\t\tvar y = data[ stride + 1 ];\n\t\t\t\t\t\tvar z = data[ stride + 2 ];\n\n\t\t\t\t\t\ttriangulatedData.push( x, y, z );\n\n\t\t\t\t\t\t// an index of -1 indicates that the current face has ended and the next one begins\n\n\t\t\t\t\t\tif ( index[ i + 3 ] === - 1 || i + 3 >= l ) {\n\n\t\t\t\t\t\t\ti += 3;\n\t\t\t\t\t\t\tstart ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn triangulatedData;\n\n\t\t\t\t}\n\n\t\t\t\tfunction flattenData( data, index ) {\n\n\t\t\t\t\tvar flattenData = [];\n\n\t\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar i1 = index[ i ];\n\n\t\t\t\t\t\tvar stride = i1 * 3;\n\n\t\t\t\t\t\tvar x = data[ stride ];\n\t\t\t\t\t\tvar y = data[ stride + 1 ];\n\t\t\t\t\t\tvar z = data[ stride + 2 ];\n\n\t\t\t\t\t\tflattenData.push( x, y, z );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn flattenData;\n\n\t\t\t\t}\n\n\t\t\t\tfunction expandLineIndex( index ) {\n\n\t\t\t\t\tvar indices = [];\n\n\t\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar i1 = index[ i ];\n\t\t\t\t\t\tvar i2 = index[ i + 1 ];\n\n\t\t\t\t\t\tindices.push( i1, i2 );\n\n\t\t\t\t\t\t// an index of -1 indicates that the current line has ended and the next one begins\n\n\t\t\t\t\t\tif ( index[ i + 2 ] === - 1 || i + 2 >= l ) {\n\n\t\t\t\t\t\t\ti += 2;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn indices;\n\n\t\t\t\t}\n\n\t\t\t\tfunction expandLineData( data, index ) {\n\n\t\t\t\t\tvar triangulatedData = [];\n\n\t\t\t\t\tvar start = 0;\n\n\t\t\t\t\tfor ( var i = 0, l = index.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar stride = start * 3;\n\n\t\t\t\t\t\tvar x = data[ stride ];\n\t\t\t\t\t\tvar y = data[ stride + 1 ];\n\t\t\t\t\t\tvar z = data[ stride + 2 ];\n\n\t\t\t\t\t\ttriangulatedData.push( x, y, z );\n\n\t\t\t\t\t\t// an index of -1 indicates that the current line has ended and the next one begins\n\n\t\t\t\t\t\tif ( index[ i + 2 ] === - 1 || i + 2 >= l ) {\n\n\t\t\t\t\t\t\ti += 2;\n\t\t\t\t\t\t\tstart ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn triangulatedData;\n\n\t\t\t\t}\n\n\t\t\t\tvar vA = new THREE.Vector3();\n\t\t\t\tvar vB = new THREE.Vector3();\n\t\t\t\tvar vC = new THREE.Vector3();\n\n\t\t\t\tvar uvA = new THREE.Vector2();\n\t\t\t\tvar uvB = new THREE.Vector2();\n\t\t\t\tvar uvC = new THREE.Vector2();\n\n\t\t\t\tfunction computeAttributeFromIndexedData( coordIndex, index, data, itemSize ) {\n\n\t\t\t\t\tvar array = [];\n\n\t\t\t\t\t// we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n\t\t\t\t\tfor ( var i = 0, l = coordIndex.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\tvar a = index[ i ];\n\t\t\t\t\t\tvar b = index[ i + 1 ];\n\t\t\t\t\t\tvar c = index[ i + 2 ];\n\n\t\t\t\t\t\tif ( itemSize === 2 ) {\n\n\t\t\t\t\t\t\tuvA.fromArray( data, a * itemSize );\n\t\t\t\t\t\t\tuvB.fromArray( data, b * itemSize );\n\t\t\t\t\t\t\tuvC.fromArray( data, c * itemSize );\n\n\t\t\t\t\t\t\tarray.push( uvA.x, uvA.y );\n\t\t\t\t\t\t\tarray.push( uvB.x, uvB.y );\n\t\t\t\t\t\t\tarray.push( uvC.x, uvC.y );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvA.fromArray( data, a * itemSize );\n\t\t\t\t\t\t\tvB.fromArray( data, b * itemSize );\n\t\t\t\t\t\t\tvC.fromArray( data, c * itemSize );\n\n\t\t\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\t\t\tarray.push( vB.x, vB.y, vB.z );\n\t\t\t\t\t\t\tarray.push( vC.x, vC.y, vC.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new THREE.Float32BufferAttribute( array, itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tfunction computeAttributeFromFaceData( index, faceData ) {\n\n\t\t\t\t\tvar array = [];\n\n\t\t\t\t\tfor ( var i = 0, j = 0, l = index.length; i < l; i += 3, j ++ ) {\n\n\t\t\t\t\t\tvA.fromArray( faceData, j * 3 );\n\n\t\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new THREE.Float32BufferAttribute( array, 3 );\n\n\t\t\t\t}\n\n\t\t\t\tfunction computeAttributeFromLineData( index, lineData ) {\n\n\t\t\t\t\tvar array = [];\n\n\t\t\t\t\tfor ( var i = 0, j = 0, l = index.length; i < l; i += 2, j ++ ) {\n\n\t\t\t\t\t\tvA.fromArray( lineData, j * 3 );\n\n\t\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\t\t\t\t\t\tarray.push( vA.x, vA.y, vA.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new THREE.Float32BufferAttribute( array, 3 );\n\n\t\t\t\t}\n\n\t\t\t\tfunction toNonIndexedAttribute( indices, attribute ) {\n\n\t\t\t\t\tvar array = attribute.array;\n\t\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\t\t\tvar index = 0, index2 = 0;\n\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new THREE.Float32BufferAttribute( array2, itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tvar ab = new THREE.Vector3();\n\t\t\t\tvar cb = new THREE.Vector3();\n\n\t\t\t\tfunction computeNormalAttribute( index, coord, creaseAngle ) {\n\n\t\t\t\t\tvar faces = [];\n\t\t\t\t\tvar vertexNormals = {};\n\n\t\t\t\t\t// prepare face and raw vertex normals\n\n\t\t\t\t\tfor ( var i = 0, l = index.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\tvar a = index[ i ];\n\t\t\t\t\t\tvar b = index[ i + 1 ];\n\t\t\t\t\t\tvar c = index[ i + 2 ];\n\n\t\t\t\t\t\tvar face = new Face( a, b, c );\n\n\t\t\t\t\t\tvA.fromArray( coord, a * 3 );\n\t\t\t\t\t\tvB.fromArray( coord, b * 3 );\n\t\t\t\t\t\tvC.fromArray( coord, c * 3 );\n\n\t\t\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tcb.normalize();\n\n\t\t\t\t\t\tface.normal.copy( cb );\n\n\t\t\t\t\t\tif ( vertexNormals[ a ] === undefined ) vertexNormals[ a ] = [];\n\t\t\t\t\t\tif ( vertexNormals[ b ] === undefined ) vertexNormals[ b ] = [];\n\t\t\t\t\t\tif ( vertexNormals[ c ] === undefined ) vertexNormals[ c ] = [];\n\n\t\t\t\t\t\tvertexNormals[ a ].push( face.normal );\n\t\t\t\t\t\tvertexNormals[ b ].push( face.normal );\n\t\t\t\t\t\tvertexNormals[ c ].push( face.normal );\n\n\t\t\t\t\t\tfaces.push( face );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// compute vertex normals and build final geometry\n\n\t\t\t\t\tvar normals = [];\n\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t\t\tvar nA = weightedNormal( vertexNormals[ face.a ], face.normal, creaseAngle );\n\t\t\t\t\t\tvar nB = weightedNormal( vertexNormals[ face.b ], face.normal, creaseAngle );\n\t\t\t\t\t\tvar nC = weightedNormal( vertexNormals[ face.c ], face.normal, creaseAngle );\n\n\t\t\t\t\t\tvA.fromArray( coord, face.a * 3 );\n\t\t\t\t\t\tvB.fromArray( coord, face.b * 3 );\n\t\t\t\t\t\tvC.fromArray( coord, face.c * 3 );\n\n\t\t\t\t\t\tnormals.push( nA.x, nA.y, nA.z );\n\t\t\t\t\t\tnormals.push( nB.x, nB.y, nB.z );\n\t\t\t\t\t\tnormals.push( nC.x, nC.y, nC.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new THREE.Float32BufferAttribute( normals, 3 );\n\n\t\t\t\t}\n\n\t\t\t\tfunction weightedNormal( normals, vector, creaseAngle ) {\n\n\t\t\t\t\tvar normal = new THREE.Vector3();\n\n\t\t\t\t\tif ( creaseAngle === 0 ) {\n\n\t\t\t\t\t\tnormal.copy( vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( var i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tif ( normals[ i ].angleTo( vector ) < creaseAngle ) {\n\n\t\t\t\t\t\t\t\tnormal.add( normals[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn normal.normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfunction toColorArray( colors ) {\n\n\t\t\t\t\tvar array = [];\n\n\t\t\t\t\tfor ( var i = 0, l = colors.length; i < l; i += 3 ) {\n\n\t\t\t\t\t\tarray.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn array;\n\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * Vertically paints the faces interpolating between the\n\t\t\t\t * specified colors at the specified angels. This is used for the Background\n\t\t\t\t * node, but could be applied to other nodes with multiple faces as well.\n\t\t\t\t *\n\t\t\t\t * When used with the Background node, default is directionIsDown is true if\n\t\t\t\t * interpolating the skyColor down from the Zenith. When interpolationg up from\n\t\t\t\t * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n\t\t\t\t *\n\t\t\t\t * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n\t\t\t\t * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n\t\t\t\t * is linear along the Y axis in any case.\n\t\t\t\t *\n\t\t\t\t * You must specify one more color than you have angles at the beginning of the colors array.\n\t\t\t\t * This is the color of the Zenith (the top of the shape).\n\t\t\t\t *\n\t\t\t\t * @param {BufferGeometry} geometry\n\t\t\t\t * @param {number} radius\n\t\t\t\t * @param {array} angles\n\t\t\t\t * @param {array} colors\n\t\t\t\t * @param {boolean} topDown - Whether to work top down or bottom up.\n\t\t\t\t */\n\t\t\t\tfunction paintFaces( geometry, radius, angles, colors, topDown ) {\n\n\t\t\t\t\t// compute threshold values\n\n\t\t\t\t\tvar thresholds = [];\n\t\t\t\t\tvar startAngle = ( topDown === true ) ? 0 : Math.PI;\n\n\t\t\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar angle = ( i === 0 ) ? 0 : angles[ i - 1 ];\n\t\t\t\t\t\tangle = ( topDown === true ) ? angle : ( startAngle - angle );\n\n\t\t\t\t\t\tvar point = new THREE.Vector3();\n\t\t\t\t\t\tpoint.setFromSphericalCoords( radius, angle, 0 );\n\n\t\t\t\t\t\tthresholds.push( point );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// generate vertex colors\n\n\t\t\t\t\tvar indices = geometry.index;\n\t\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\t\tvar colorAttribute = new THREE.BufferAttribute( new Float32Array( geometry.attributes.position.count * 3 ), 3 );\n\n\t\t\t\t\tvar position = new THREE.Vector3();\n\t\t\t\t\tvar color = new THREE.Color();\n\n\t\t\t\t\tfor ( var i = 0; i < indices.count; i ++ ) {\n\n\t\t\t\t\t\tvar index = indices.getX( i );\n\t\t\t\t\t\tposition.fromBufferAttribute( positionAttribute, index );\n\n\t\t\t\t\t\tvar thresholdIndexA, thresholdIndexB;\n\t\t\t\t\t\tvar t = 1;\n\n\t\t\t\t\t\tfor ( var j = 1; j < thresholds.length; j ++ ) {\n\n\t\t\t\t\t\t\tthresholdIndexA = j - 1;\n\t\t\t\t\t\t\tthresholdIndexB = j;\n\n\t\t\t\t\t\t\tvar thresholdA = thresholds[ thresholdIndexA ];\n\t\t\t\t\t\t\tvar thresholdB = thresholds[ thresholdIndexB ];\n\n\t\t\t\t\t\t\tif ( topDown === true ) {\n\n\t\t\t\t\t\t\t\t// interpolation for sky color\n\n\t\t\t\t\t\t\t\tif ( position.y <= thresholdA.y && position.y > thresholdB.y ) {\n\n\t\t\t\t\t\t\t\t\tt = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// interpolation for ground color\n\n\t\t\t\t\t\t\t\tif ( position.y >= thresholdA.y && position.y < thresholdB.y ) {\n\n\t\t\t\t\t\t\t\t\tt = Math.abs( thresholdA.y - position.y ) / Math.abs( thresholdA.y - thresholdB.y );\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar colorA = colors[ thresholdIndexA ];\n\t\t\t\t\t\tvar colorB = colors[ thresholdIndexB ];\n\n\t\t\t\t\t\tcolor.copy( colorA ).lerp( colorB, t );\n\n\t\t\t\t\t\tcolorAttribute.setXYZ( index, color.r, color.g, color.b );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute( 'color', colorAttribute );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar textureLoader = new THREE.TextureLoader( this.manager );\n\t\t\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\t\t// create JSON representing the tree structure of the VRML asset\n\n\t\t\t\tvar tree = generateVRMLTree( data );\n\n\t\t\t\t// check version (only 2.0 is supported)\n\n\t\t\t\tif ( tree.version.indexOf( 'V2.0' ) === - 1 ) {\n\n\t\t\t\t\tthrow Error( 'THREE.VRMLLexer: Version of VRML asset not supported.' );\n\n\t\t\t\t}\n\n\t\t\t\t// parse the tree structure to a three.js scene\n\n\t\t\t\tvar scene = parseTree( tree );\n\n\t\t\t\treturn scene;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tfunction VRMLLexer( tokens ) {\n\n\t\t\tthis.lexer = new chevrotain.Lexer( tokens );\n\n\t\t}\n\n\t\tVRMLLexer.prototype = {\n\n\t\t\tconstructor: VRMLLexer,\n\n\t\t\tlex: function ( inputText ) {\n\n\t\t\t\tvar lexingResult = this.lexer.tokenize( inputText );\n\n\t\t\t\tif ( lexingResult.errors.length > 0 ) {\n\n\t\t\t\t\tconsole.error( lexingResult.errors );\n\n\t\t\t\t\tthrow Error( 'THREE.VRMLLexer: Lexing errors detected.' );\n\n\t\t\t\t}\n\n\t\t\t\treturn lexingResult;\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction VRMLParser( tokenVocabulary ) {\n\n\t\t\tchevrotain.Parser.call( this, tokenVocabulary );\n\n\t\t\tvar $ = this;\n\n\t\t\tvar Version = tokenVocabulary[ 'Version' ];\n\t\t\tvar LCurly = tokenVocabulary[ 'LCurly' ];\n\t\t\tvar RCurly = tokenVocabulary[ 'RCurly' ];\n\t\t\tvar LSquare = tokenVocabulary[ 'LSquare' ];\n\t\t\tvar RSquare = tokenVocabulary[ 'RSquare' ];\n\t\t\tvar Identifier = tokenVocabulary[ 'Identifier' ];\n\t\t\tvar RouteIdentifier = tokenVocabulary[ 'RouteIdentifier' ];\n\t\t\tvar StringLiteral = tokenVocabulary[ 'StringLiteral' ];\n\t\t\tvar HexLiteral = tokenVocabulary[ 'HexLiteral' ];\n\t\t\tvar NumberLiteral = tokenVocabulary[ 'NumberLiteral' ];\n\t\t\tvar TrueLiteral = tokenVocabulary[ 'TrueLiteral' ];\n\t\t\tvar FalseLiteral = tokenVocabulary[ 'FalseLiteral' ];\n\t\t\tvar NullLiteral = tokenVocabulary[ 'NullLiteral' ];\n\t\t\tvar DEF = tokenVocabulary[ 'DEF' ];\n\t\t\tvar USE = tokenVocabulary[ 'USE' ];\n\t\t\tvar ROUTE = tokenVocabulary[ 'ROUTE' ];\n\t\t\tvar TO = tokenVocabulary[ 'TO' ];\n\t\t\tvar NodeName = tokenVocabulary[ 'NodeName' ];\n\n\t\t\t$.RULE( 'vrml', function () {\n\n\t\t\t\t$.SUBRULE( $.version );\n\t\t\t\t$.AT_LEAST_ONE( function () {\n\n\t\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t\t} );\n\t\t\t\t$.MANY( function () {\n\n\t\t\t\t\t$.SUBRULE( $.route );\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t\t$.RULE( 'version', function () {\n\n\t\t\t\t$.CONSUME( Version );\n\n\t\t\t} );\n\n\t\t\t$.RULE( 'node', function () {\n\n\t\t\t\t$.OPTION( function () {\n\n\t\t\t\t\t$.SUBRULE( $.def );\n\n\t\t\t\t} );\n\n\t\t\t\t$.CONSUME( NodeName );\n\t\t\t\t$.CONSUME( LCurly );\n\t\t\t\t$.MANY( function () {\n\n\t\t\t\t\t$.SUBRULE( $.field );\n\n\t\t\t\t} );\n\t\t\t\t$.CONSUME( RCurly );\n\n\t\t\t} );\n\n\t\t\t$.RULE( 'field', function () {\n\n\t\t\t\t$.CONSUME( Identifier );\n\n\t\t\t\t$.OR2( [\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.singleFieldValue );\n\n\t\t\t\t\t} },\n\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t$.SUBRULE( $.multiFieldValue );\n\n\t\t\t\t\t} }\n\t\t\t\t] );\n\n\t\t\t} );\n\n\t\t\t$.RULE( 'def', function () {\n\n\t\t\t\t$.CONSUME( DEF );\n\t\t\t\t$.CONSUME( Identifier );\n\n\t\t\t} );\n\n\t\t\t$.RULE( 'use', function () {\n\n\t\t\t\t$.CONSUME( USE );\n\t\t\t\t$.CONSUME( Identifier );\n\n\t\t\t} );\n\n\t\t\t$.RULE( 'singleFieldValue', function () {\n\n\t\t\t\t$.AT_LEAST_ONE( function () {\n\n\t\t\t\t\t$.OR( [\n\t\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t\t\t\t} },\n\t\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t\t$.SUBRULE( $.use );\n\n\t\t\t\t\t\t} },\n\t\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t\t$.CONSUME( StringLiteral );\n\n\t\t\t\t\t\t} },\n\t\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t\t$.CONSUME( HexLiteral );\n\n\t\t\t\t\t\t} },\n\t\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t\t$.CONSUME( NumberLiteral );\n\n\t\t\t\t\t\t} },\n\t\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t\t$.CONSUME( TrueLiteral );\n\n\t\t\t\t\t\t} },\n\t\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t\t$.CONSUME( FalseLiteral );\n\n\t\t\t\t\t\t} },\n\t\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t\t$.CONSUME( NullLiteral );\n\n\t\t\t\t\t\t} }\n\t\t\t\t\t] );\n\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t\t$.RULE( 'multiFieldValue', function () {\n\n\t\t\t\t$.CONSUME( LSquare );\n\t\t\t\t$.MANY( function () {\n\n\t\t\t\t\t$.OR( [\n\t\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t\t$.SUBRULE( $.node );\n\n\t\t\t\t\t\t} },\n\t\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t\t$.SUBRULE( $.use );\n\n\t\t\t\t\t\t} },\n\t\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t\t$.CONSUME( StringLiteral );\n\n\t\t\t\t\t\t} },\n\t\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t\t$.CONSUME( HexLiteral );\n\n\t\t\t\t\t\t} },\n\t\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t\t$.CONSUME( NumberLiteral );\n\n\t\t\t\t\t\t} },\n\t\t\t\t\t\t{ ALT: function () {\n\n\t\t\t\t\t\t\t$.CONSUME( NullLiteral );\n\n\t\t\t\t\t\t} }\n\t\t\t\t\t] );\n\n\t\t\t\t} );\n\t\t\t\t$.CONSUME( RSquare );\n\n\t\t\t} );\n\n\t\t\t$.RULE( 'route', function () {\n\n\t\t\t\t$.CONSUME( ROUTE );\n\t\t\t\t$.CONSUME( RouteIdentifier );\n\t\t\t\t$.CONSUME( TO );\n\t\t\t\t$.CONSUME2( RouteIdentifier );\n\n\t\t\t} );\n\n\t\t\tthis.performSelfAnalysis();\n\n\t\t}\n\n\t\tVRMLParser.prototype = Object.create( chevrotain.Parser.prototype );\n\t\tVRMLParser.prototype.constructor = VRMLParser;\n\n\t\tfunction Face( a, b, c ) {\n\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\t\tthis.normal = new THREE.Vector3();\n\n\t\t}\n\n\t\tvar TEXTURE_TYPE = {\n\t\t\tINTENSITY: 1,\n\t\t\tINTENSITY_ALPHA: 2,\n\t\t\tRGB: 3,\n\t\t\tRGBA: 4\n\t\t};\n\n\t\treturn VRMLLoader;\n\n\t} )();\n\t\n\treturn THREE.VRMLLoader;\n});\n"]}