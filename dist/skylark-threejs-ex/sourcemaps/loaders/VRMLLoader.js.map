{"version":3,"sources":["loaders/VRMLLoader.js"],"names":["define","THREE","chevrotain","Error","VRMLLoader","manager","Loader","call","this","VRMLLexer","tokens","lexer","Lexer","VRMLParser","tokenVocabulary","Parser","$","Version","LCurly","RCurly","LSquare","RSquare","Identifier","RouteIdentifier","StringLiteral","HexLiteral","NumberLiteral","TrueLiteral","FalseLiteral","NullLiteral","DEF","USE","ROUTE","TO","NodeName","RULE","SUBRULE","version","AT_LEAST_ONE","node","MANY","route","CONSUME","OPTION","def","field","OR2","ALT","singleFieldValue","multiFieldValue","OR","use","CONSUME2","performSelfAnalysis","Face","a","b","c","normal","Vector3","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","text","parse","data","nodeMap","buildNodeMap","fields","i","l","length","type","fieldValues","values","j","jl","getNode","identifier","build","isObject3D","isMaterial","clone","undefined","nodeName","name","object","Group","fieldName","parseFieldChildren","axis","angle","quaternion","setFromAxisAngle","scale","set","position","console","warn","buildGroupingNode","groundAngle","groundColor","skyAngle","skyColor","group","skyGeometry","SphereBufferGeometry","skyMaterial","MeshBasicMaterial","fog","side","BackSide","depthWrite","depthTest","paintFaces","toColorArray","vertexColors","color","setRGB","sky","Mesh","add","groundGeometry","Math","PI","groundMaterial","ground","renderOrder","buildBackgroundNode","geometry","material","attributes","_type","pointsMaterial","PointsMaterial","isMeshPhongMaterial","copy","emissive","Points","lineMaterial","LineBasicMaterial","LineSegments","_solid","FrontSide","DoubleSide","Object3D","visible","buildShapeNode","transformData","MeshPhongMaterial","materialData","diffuseColor","emissiveColor","shininess","specularColor","specular","transparency","opacity","transparent","textureNode","map","__type","TEXTURE_TYPE","INTENSITY_ALPHA","RGB","RGBA","center","rotation","repeat","offset","translation","buildAppearanceNode","Color","buildMaterialNode","texture","wrapS","RepeatWrapping","wrapT","textureLoader","ClampToEdgeWrapping","buildImageTextureNode","width","height","num_components","useAlpha","textureType","getTextureType","size","Uint8Array","r","g","k","parseHexColor","stride","DataTexture","RGBAFormat","RGBFormat","buildPixelTextureNode","Vector2","buildTextureTransformNode","coord","texCoord","colorIndex","coordIndex","normalIndex","texCoordIndex","ccw","solid","creaseAngle","colorPerVertex","normalPerVertex","colorNode","coordNode","normalNode","texCoordNode","BufferGeometry","positionAttribute","colorAttribute","normalAttribute","uvAttribute","triangulatedCoordIndex","triangulateFaceIndex","triangulatedColorIndex","computeAttributeFromIndexedData","toNonIndexedAttribute","Float32BufferAttribute","flattenFaceColors","flattenData","triangulatedFaceColors","triangulateFaceData","computeAttributeFromFaceData","triangulatedNormalIndex","flattenFaceNormals","triangulatedFaceNormals","index","faces","vertexNormals","face","vA","fromArray","vB","vC","cb","subVectors","ab","cross","normalize","push","normals","nA","weightedNormal","nB","nC","x","y","z","computeNormalAttribute","triangulatedTexCoordIndex","setAttribute","buildIndexedFaceSetNode","expandedLineIndex","expandLineIndex","expandedColorIndex","flattenLineColors","expandedLineColors","expandLineData","computeAttributeFromLineData","buildIndexedLineSetNode","buildPointSetNode","BoxBufferGeometry","buildBoxNode","radius","openEnded","ConeBufferGeometry","buildConeNode","CylinderBufferGeometry","buildCylinderNode","buildSphereNode","buildGeometricNode","buildNode","hex","INTENSITY","value","parseInt","substring","children","owner","indices","start","i1","i2","i3","triangulatedData","uvA","uvB","uvC","itemSize","array","faceData","lineData","attribute","array2","index2","vector","angleTo","colors","angles","topDown","thresholds","startAngle","point","setFromSphericalCoords","BufferAttribute","Float32Array","count","thresholdIndexA","thresholdIndexB","getX","fromBufferAttribute","t","thresholdA","thresholdB","abs","colorA","colorB","lerp","setXYZ","TextureLoader","resourcePath","setCrossOrigin","crossOrigin","tree","tokenData","createToken","pattern","longer_alt","RegExp","join","Comment","SKIPPED","token","createTokens","parser","visitor","BaseVRMLVisitor","VRMLToASTVisitor","validateVisitor","processField","ctx","visit","stringLiteral","image","replace","numberLiteral","parseFloat","hexLiteral","trueLiteral","falseLiteral","forEach","vrml","nodes","routes","result","FROM","createVisitor","getBaseCstVisitorConstructor","lexingResult","lex","input","cstOutput","errors","error","generateVRMLTree","indexOf","scene","Scene","parseTree","inputText","tokenize"],"mappings":"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","file":"../../loaders/VRMLLoader.js","sourcesContent":["define([\n    \"skylark-threejs\",\n//    '../libs/chevrotain.module.min'\n], function (THREE, chevrotain) {\n    'use strict';\n    var VRMLLoader = function () {\n        if (typeof chevrotain === 'undefined') {\n            throw Error('THREE.VRMLLoader: External library chevrotain.min.js required.');\n        }\n        function VRMLLoader(manager) {\n            THREE.Loader.call(this, manager);\n        }\n        VRMLLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {\n            constructor: VRMLLoader,\n            load: function (url, onLoad, onProgress, onError) {\n                var scope = this;\n                var path = scope.path === '' ? THREE.LoaderUtils.extractUrlBase(url) : scope.path;\n                var loader = new THREE.FileLoader(this.manager);\n                loader.setPath(scope.path);\n                loader.load(url, function (text) {\n                    onLoad(scope.parse(text, path));\n                }, onProgress, onError);\n            },\n            parse: function (data, path) {\n                var nodeMap = {};\n                function generateVRMLTree(data) {\n                    var tokenData = createTokens();\n                    var lexer = new VRMLLexer(tokenData.tokens);\n                    var parser = new VRMLParser(tokenData.tokenVocabulary);\n                    var visitor = createVisitor(parser.getBaseCstVisitorConstructor());\n                    var lexingResult = lexer.lex(data);\n                    parser.input = lexingResult.tokens;\n                    var cstOutput = parser.vrml();\n                    if (parser.errors.length > 0) {\n                        console.error(parser.errors);\n                        throw Error('THREE.VRMLLoader: Parsing errors detected.');\n                    }\n                    var ast = visitor.visit(cstOutput);\n                    return ast;\n                }\n                function createTokens() {\n                    var createToken = chevrotain.createToken;\n                    var RouteIdentifier = createToken({\n                        name: 'RouteIdentifier',\n                        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n                    });\n                    var Identifier = createToken({\n                        name: 'Identifier',\n                        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n                        longer_alt: RouteIdentifier\n                    });\n                    var nodeTypes = [\n                        'Anchor',\n                        'Billboard',\n                        'Collision',\n                        'Group',\n                        'Transform',\n                        'Inline',\n                        'LOD',\n                        'Switch',\n                        'AudioClip',\n                        'DirectionalLight',\n                        'PointLight',\n                        'Script',\n                        'Shape',\n                        'Sound',\n                        'SpotLight',\n                        'WorldInfo',\n                        'CylinderSensor',\n                        'PlaneSensor',\n                        'ProximitySensor',\n                        'SphereSensor',\n                        'TimeSensor',\n                        'TouchSensor',\n                        'VisibilitySensor',\n                        'Box',\n                        'Cone',\n                        'Cylinder',\n                        'ElevationGrid',\n                        'Extrusion',\n                        'IndexedFaceSet',\n                        'IndexedLineSet',\n                        'PointSet',\n                        'Sphere',\n                        'Color',\n                        'Coordinate',\n                        'Normal',\n                        'TextureCoordinate',\n                        'Appearance',\n                        'FontStyle',\n                        'ImageTexture',\n                        'Material',\n                        'MovieTexture',\n                        'PixelTexture',\n                        'TextureTransform',\n                        'ColorInterpolator',\n                        'CoordinateInterpolator',\n                        'NormalInterpolator',\n                        'OrientationInterpolator',\n                        'PositionInterpolator',\n                        'ScalarInterpolator',\n                        'Background',\n                        'Fog',\n                        'NavigationInfo',\n                        'Viewpoint',\n                        'Text'\n                    ];\n                    var Version = createToken({\n                        name: 'Version',\n                        pattern: /#VRML.*/,\n                        longer_alt: Identifier\n                    });\n                    var NodeName = createToken({\n                        name: 'NodeName',\n                        pattern: new RegExp(nodeTypes.join('|')),\n                        longer_alt: Identifier\n                    });\n                    var DEF = createToken({\n                        name: 'DEF',\n                        pattern: /DEF/,\n                        longer_alt: Identifier\n                    });\n                    var USE = createToken({\n                        name: 'USE',\n                        pattern: /USE/,\n                        longer_alt: Identifier\n                    });\n                    var ROUTE = createToken({\n                        name: 'ROUTE',\n                        pattern: /ROUTE/,\n                        longer_alt: Identifier\n                    });\n                    var TO = createToken({\n                        name: 'TO',\n                        pattern: /TO/,\n                        longer_alt: Identifier\n                    });\n                    var StringLiteral = createToken({\n                        name: 'StringLiteral',\n                        pattern: /\"(:?[^\\\\\"\\n\\r]+|\\\\(:?[bfnrtv\"\\\\/]|u[0-9a-fA-F]{4}))*\"/\n                    });\n                    var HexLiteral = createToken({\n                        name: 'HexLiteral',\n                        pattern: /0[xX][0-9a-fA-F]+/\n                    });\n                    var NumberLiteral = createToken({\n                        name: 'NumberLiteral',\n                        pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n                    });\n                    var TrueLiteral = createToken({\n                        name: 'TrueLiteral',\n                        pattern: /TRUE/\n                    });\n                    var FalseLiteral = createToken({\n                        name: 'FalseLiteral',\n                        pattern: /FALSE/\n                    });\n                    var NullLiteral = createToken({\n                        name: 'NullLiteral',\n                        pattern: /NULL/\n                    });\n                    var LSquare = createToken({\n                        name: 'LSquare',\n                        pattern: /\\[/\n                    });\n                    var RSquare = createToken({\n                        name: 'RSquare',\n                        pattern: /]/\n                    });\n                    var LCurly = createToken({\n                        name: 'LCurly',\n                        pattern: /{/\n                    });\n                    var RCurly = createToken({\n                        name: 'RCurly',\n                        pattern: /}/\n                    });\n                    var Comment = createToken({\n                        name: 'Comment',\n                        pattern: /#.*/,\n                        group: chevrotain.Lexer.SKIPPED\n                    });\n                    var WhiteSpace = createToken({\n                        name: 'WhiteSpace',\n                        pattern: /[ ,\\s]/,\n                        group: chevrotain.Lexer.SKIPPED\n                    });\n                    var tokens = [\n                        WhiteSpace,\n                        NodeName,\n                        DEF,\n                        USE,\n                        ROUTE,\n                        TO,\n                        TrueLiteral,\n                        FalseLiteral,\n                        NullLiteral,\n                        Version,\n                        Identifier,\n                        RouteIdentifier,\n                        StringLiteral,\n                        HexLiteral,\n                        NumberLiteral,\n                        LSquare,\n                        RSquare,\n                        LCurly,\n                        RCurly,\n                        Comment\n                    ];\n                    var tokenVocabulary = {};\n                    for (var i = 0, l = tokens.length; i < l; i++) {\n                        var token = tokens[i];\n                        tokenVocabulary[token.name] = token;\n                    }\n                    return {\n                        tokens: tokens,\n                        tokenVocabulary: tokenVocabulary\n                    };\n                }\n                function createVisitor(BaseVRMLVisitor) {\n                    function VRMLToASTVisitor() {\n                        BaseVRMLVisitor.call(this);\n                        this.validateVisitor();\n                    }\n                    VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n                        constructor: VRMLToASTVisitor,\n                        vrml: function (ctx) {\n                            var data = {\n                                version: this.visit(ctx.version),\n                                nodes: [],\n                                routes: []\n                            };\n                            for (var i = 0, l = ctx.node.length; i < l; i++) {\n                                var node = ctx.node[i];\n                                data.nodes.push(this.visit(node));\n                            }\n                            if (ctx.route) {\n                                for (var i = 0, l = ctx.route.length; i < l; i++) {\n                                    var route = ctx.route[i];\n                                    data.routes.push(this.visit(route));\n                                }\n                            }\n                            return data;\n                        },\n                        version: function (ctx) {\n                            return ctx.Version[0].image;\n                        },\n                        node: function (ctx) {\n                            var data = {\n                                name: ctx.NodeName[0].image,\n                                fields: []\n                            };\n                            if (ctx.field) {\n                                for (var i = 0, l = ctx.field.length; i < l; i++) {\n                                    var field = ctx.field[i];\n                                    data.fields.push(this.visit(field));\n                                }\n                            }\n                            if (ctx.def) {\n                                data.DEF = this.visit(ctx.def[0]);\n                            }\n                            return data;\n                        },\n                        field: function (ctx) {\n                            var data = {\n                                name: ctx.Identifier[0].image,\n                                type: null,\n                                values: null\n                            };\n                            var result;\n                            if (ctx.singleFieldValue) {\n                                result = this.visit(ctx.singleFieldValue[0]);\n                            }\n                            if (ctx.multiFieldValue) {\n                                result = this.visit(ctx.multiFieldValue[0]);\n                            }\n                            data.type = result.type;\n                            data.values = result.values;\n                            return data;\n                        },\n                        def: function (ctx) {\n                            return ctx.Identifier[0].image;\n                        },\n                        use: function (ctx) {\n                            return { USE: ctx.Identifier[0].image };\n                        },\n                        singleFieldValue: function (ctx) {\n                            return processField(this, ctx);\n                        },\n                        multiFieldValue: function (ctx) {\n                            return processField(this, ctx);\n                        },\n                        route: function (ctx) {\n                            var data = {\n                                FROM: ctx.RouteIdentifier[0].image,\n                                TO: ctx.RouteIdentifier[1].image\n                            };\n                            return data;\n                        }\n                    });\n                    function processField(scope, ctx) {\n                        var field = {\n                            type: null,\n                            values: []\n                        };\n                        if (ctx.node) {\n                            field.type = 'node';\n                            for (var i = 0, l = ctx.node.length; i < l; i++) {\n                                var node = ctx.node[i];\n                                field.values.push(scope.visit(node));\n                            }\n                        }\n                        if (ctx.use) {\n                            field.type = 'use';\n                            for (var i = 0, l = ctx.use.length; i < l; i++) {\n                                var use = ctx.use[i];\n                                field.values.push(scope.visit(use));\n                            }\n                        }\n                        if (ctx.StringLiteral) {\n                            field.type = 'string';\n                            for (var i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n                                var stringLiteral = ctx.StringLiteral[i];\n                                field.values.push(stringLiteral.image.replace(/'|\"/g, ''));\n                            }\n                        }\n                        if (ctx.NumberLiteral) {\n                            field.type = 'number';\n                            for (var i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n                                var numberLiteral = ctx.NumberLiteral[i];\n                                field.values.push(parseFloat(numberLiteral.image));\n                            }\n                        }\n                        if (ctx.HexLiteral) {\n                            field.type = 'hex';\n                            for (var i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n                                var hexLiteral = ctx.HexLiteral[i];\n                                field.values.push(hexLiteral.image);\n                            }\n                        }\n                        if (ctx.TrueLiteral) {\n                            field.type = 'boolean';\n                            for (var i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n                                var trueLiteral = ctx.TrueLiteral[i];\n                                if (trueLiteral.image === 'TRUE')\n                                    field.values.push(true);\n                            }\n                        }\n                        if (ctx.FalseLiteral) {\n                            field.type = 'boolean';\n                            for (var i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n                                var falseLiteral = ctx.FalseLiteral[i];\n                                if (falseLiteral.image === 'FALSE')\n                                    field.values.push(false);\n                            }\n                        }\n                        if (ctx.NullLiteral) {\n                            field.type = 'null';\n                            ctx.NullLiteral.forEach(function () {\n                                field.values.push(null);\n                            });\n                        }\n                        return field;\n                    }\n                    return new VRMLToASTVisitor();\n                }\n                function parseTree(tree) {\n                    var nodes = tree.nodes;\n                    var scene = new THREE.Scene();\n                    for (var i = 0, l = nodes.length; i < l; i++) {\n                        var node = nodes[i];\n                        buildNodeMap(node);\n                    }\n                    for (var i = 0, l = nodes.length; i < l; i++) {\n                        var node = nodes[i];\n                        var object = getNode(node);\n                        if (object instanceof THREE.Object3D)\n                            scene.add(object);\n                    }\n                    return scene;\n                }\n                function buildNodeMap(node) {\n                    if (node.DEF) {\n                        nodeMap[node.DEF] = node;\n                    }\n                    var fields = node.fields;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        if (field.type === 'node') {\n                            var fieldValues = field.values;\n                            for (var j = 0, jl = fieldValues.length; j < jl; j++) {\n                                buildNodeMap(fieldValues[j]);\n                            }\n                        }\n                    }\n                }\n                function getNode(node) {\n                    if (node.USE) {\n                        return resolveUSE(node.USE);\n                    }\n                    if (node.build !== undefined)\n                        return node.build;\n                    node.build = buildNode(node);\n                    return node.build;\n                }\n                function buildNode(node) {\n                    var nodeName = node.name;\n                    var build;\n                    switch (nodeName) {\n                    case 'Group':\n                    case 'Transform':\n                        build = buildGroupingNode(node);\n                        break;\n                    case 'Background':\n                        build = buildBackgroundNode(node);\n                        break;\n                    case 'Shape':\n                        build = buildShapeNode(node);\n                        break;\n                    case 'Appearance':\n                        build = buildAppearanceNode(node);\n                        break;\n                    case 'Material':\n                        build = buildMaterialNode(node);\n                        break;\n                    case 'ImageTexture':\n                        build = buildImageTextureNode(node);\n                        break;\n                    case 'PixelTexture':\n                        build = buildPixelTextureNode(node);\n                        break;\n                    case 'TextureTransform':\n                        build = buildTextureTransformNode(node);\n                        break;\n                    case 'IndexedFaceSet':\n                        build = buildIndexedFaceSetNode(node);\n                        break;\n                    case 'IndexedLineSet':\n                        build = buildIndexedLineSetNode(node);\n                        break;\n                    case 'PointSet':\n                        build = buildPointSetNode(node);\n                        break;\n                    case 'Box':\n                        build = buildBoxNode(node);\n                        break;\n                    case 'Cone':\n                        build = buildConeNode(node);\n                        break;\n                    case 'Cylinder':\n                        build = buildCylinderNode(node);\n                        break;\n                    case 'Sphere':\n                        build = buildSphereNode(node);\n                        break;\n                    case 'Color':\n                    case 'Coordinate':\n                    case 'Normal':\n                    case 'TextureCoordinate':\n                        build = buildGeometricNode(node);\n                        break;\n                    case 'Anchor':\n                    case 'Billboard':\n                    case 'Collision':\n                    case 'Inline':\n                    case 'LOD':\n                    case 'Switch':\n                    case 'AudioClip':\n                    case 'DirectionalLight':\n                    case 'PointLight':\n                    case 'Script':\n                    case 'Sound':\n                    case 'SpotLight':\n                    case 'WorldInfo':\n                    case 'CylinderSensor':\n                    case 'PlaneSensor':\n                    case 'ProximitySensor':\n                    case 'SphereSensor':\n                    case 'TimeSensor':\n                    case 'TouchSensor':\n                    case 'VisibilitySensor':\n                    case 'ElevationGrid':\n                    case 'Extrusion':\n                    case 'Text':\n                    case 'FontStyle':\n                    case 'MovieTexture':\n                    case 'ColorInterpolator':\n                    case 'CoordinateInterpolator':\n                    case 'NormalInterpolator':\n                    case 'OrientationInterpolator':\n                    case 'PositionInterpolator':\n                    case 'ScalarInterpolator':\n                    case 'Fog':\n                    case 'NavigationInfo':\n                    case 'Viewpoint':\n                        break;\n                    default:\n                        console.warn('THREE.VRMLLoader: Unknown node:', nodeName);\n                        break;\n                    }\n                    return build;\n                }\n                function buildGroupingNode(node) {\n                    var object = new THREE.Group();\n                    var fields = node.fields;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        var fieldName = field.name;\n                        var fieldValues = field.values;\n                        switch (fieldName) {\n                        case 'center':\n                            break;\n                        case 'children':\n                            parseFieldChildren(fieldValues, object);\n                            break;\n                        case 'rotation':\n                            var axis = new THREE.Vector3(fieldValues[0], fieldValues[1], fieldValues[2]);\n                            var angle = fieldValues[3];\n                            object.quaternion.setFromAxisAngle(axis, angle);\n                            break;\n                        case 'scale':\n                            object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n                            break;\n                        case 'scaleOrientation':\n                            break;\n                        case 'translation':\n                            object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n                            break;\n                        case 'bboxCenter':\n                            break;\n                        case 'bboxSize':\n                            break;\n                        default:\n                            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n                            break;\n                        }\n                    }\n                    return object;\n                }\n                function buildBackgroundNode(node) {\n                    var group = new THREE.Group();\n                    var groundAngle, groundColor;\n                    var skyAngle, skyColor;\n                    var fields = node.fields;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        var fieldName = field.name;\n                        var fieldValues = field.values;\n                        switch (fieldName) {\n                        case 'groundAngle':\n                            groundAngle = fieldValues;\n                            break;\n                        case 'groundColor':\n                            groundColor = fieldValues;\n                            break;\n                        case 'backUrl':\n                            break;\n                        case 'bottomUrl':\n                            break;\n                        case 'frontUrl':\n                            break;\n                        case 'leftUrl':\n                            break;\n                        case 'rightUrl':\n                            break;\n                        case 'topUrl':\n                            break;\n                        case 'skyAngle':\n                            skyAngle = fieldValues;\n                            break;\n                        case 'skyColor':\n                            skyColor = fieldValues;\n                            break;\n                        default:\n                            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n                            break;\n                        }\n                    }\n                    var radius = 10000;\n                    if (skyColor) {\n                        var skyGeometry = new THREE.SphereBufferGeometry(radius, 32, 16);\n                        var skyMaterial = new THREE.MeshBasicMaterial({\n                            fog: false,\n                            side: THREE.BackSide,\n                            depthWrite: false,\n                            depthTest: false\n                        });\n                        if (skyColor.length > 3) {\n                            paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n                            skyMaterial.vertexColors = true;\n                        } else {\n                            skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n                        }\n                        var sky = new THREE.Mesh(skyGeometry, skyMaterial);\n                        group.add(sky);\n                    }\n                    if (groundColor) {\n                        if (groundColor.length > 0) {\n                            var groundGeometry = new THREE.SphereBufferGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n                            var groundMaterial = new THREE.MeshBasicMaterial({\n                                fog: false,\n                                side: THREE.BackSide,\n                                vertexColors: true,\n                                depthWrite: false,\n                                depthTest: false\n                            });\n                            paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n                            var ground = new THREE.Mesh(groundGeometry, groundMaterial);\n                            group.add(ground);\n                        }\n                    }\n                    group.renderOrder = -Infinity;\n                    return group;\n                }\n                function buildShapeNode(node) {\n                    var fields = node.fields;\n                    var material = new THREE.MeshBasicMaterial({ color: 0 });\n                    var geometry;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        var fieldName = field.name;\n                        var fieldValues = field.values;\n                        switch (fieldName) {\n                        case 'appearance':\n                            if (fieldValues[0] !== null) {\n                                material = getNode(fieldValues[0]);\n                            }\n                            break;\n                        case 'geometry':\n                            if (fieldValues[0] !== null) {\n                                geometry = getNode(fieldValues[0]);\n                            }\n                            break;\n                        default:\n                            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n                            break;\n                        }\n                    }\n                    var object;\n                    if (geometry && geometry.attributes.position) {\n                        var type = geometry._type;\n                        if (type === 'points') {\n                            var pointsMaterial = new THREE.PointsMaterial({ color: 16777215 });\n                            if (geometry.attributes.color !== undefined) {\n                                pointsMaterial.vertexColors = true;\n                            } else {\n                                if (material.isMeshPhongMaterial) {\n                                    pointsMaterial.color.copy(material.emissive);\n                                }\n                            }\n                            object = new THREE.Points(geometry, pointsMaterial);\n                        } else if (type === 'line') {\n                            var lineMaterial = new THREE.LineBasicMaterial({ color: 16777215 });\n                            if (geometry.attributes.color !== undefined) {\n                                lineMaterial.vertexColors = true;\n                            } else {\n                                if (material.isMeshPhongMaterial) {\n                                    lineMaterial.color.copy(material.emissive);\n                                }\n                            }\n                            object = new THREE.LineSegments(geometry, lineMaterial);\n                        } else {\n                            if (geometry._solid !== undefined) {\n                                material.side = geometry._solid ? THREE.FrontSide : THREE.DoubleSide;\n                            }\n                            if (geometry.attributes.color !== undefined) {\n                                material.vertexColors = true;\n                            }\n                            object = new THREE.Mesh(geometry, material);\n                        }\n                    } else {\n                        object = new THREE.Object3D();\n                        object.visible = false;\n                    }\n                    return object;\n                }\n                function buildAppearanceNode(node) {\n                    var material = new THREE.MeshPhongMaterial();\n                    var transformData;\n                    var fields = node.fields;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        var fieldName = field.name;\n                        var fieldValues = field.values;\n                        switch (fieldName) {\n                        case 'material':\n                            if (fieldValues[0] !== null) {\n                                var materialData = getNode(fieldValues[0]);\n                                if (materialData.diffuseColor)\n                                    material.color.copy(materialData.diffuseColor);\n                                if (materialData.emissiveColor)\n                                    material.emissive.copy(materialData.emissiveColor);\n                                if (materialData.shininess)\n                                    material.shininess = materialData.shininess;\n                                if (materialData.specularColor)\n                                    material.specular.copy(materialData.specularColor);\n                                if (materialData.transparency)\n                                    material.opacity = 1 - materialData.transparency;\n                                if (materialData.transparency > 0)\n                                    material.transparent = true;\n                            } else {\n                                material = new THREE.MeshBasicMaterial({ color: 0 });\n                            }\n                            break;\n                        case 'texture':\n                            var textureNode = fieldValues[0];\n                            if (textureNode !== null) {\n                                if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\n                                    material.map = getNode(textureNode);\n                                } else {\n                                }\n                            }\n                            break;\n                        case 'textureTransform':\n                            if (fieldValues[0] !== null) {\n                                transformData = getNode(fieldValues[0]);\n                            }\n                            break;\n                        default:\n                            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n                            break;\n                        }\n                    }\n                    if (material.map) {\n                        if (material.map.__type) {\n                            switch (material.map.__type) {\n                            case TEXTURE_TYPE.INTENSITY_ALPHA:\n                                material.opacity = 1;\n                                break;\n                            case TEXTURE_TYPE.RGB:\n                                material.color.set(16777215);\n                                break;\n                            case TEXTURE_TYPE.RGBA:\n                                material.color.set(16777215);\n                                material.opacity = 1;\n                                break;\n                            default:\n                            }\n                            delete material.map.__type;\n                        }\n                        if (transformData) {\n                            material.map.center.copy(transformData.center);\n                            material.map.rotation = transformData.rotation;\n                            material.map.repeat.copy(transformData.scale);\n                            material.map.offset.copy(transformData.translation);\n                        }\n                    }\n                    return material;\n                }\n                function buildMaterialNode(node) {\n                    var materialData = {};\n                    var fields = node.fields;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        var fieldName = field.name;\n                        var fieldValues = field.values;\n                        switch (fieldName) {\n                        case 'ambientIntensity':\n                            break;\n                        case 'diffuseColor':\n                            materialData.diffuseColor = new THREE.Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n                            break;\n                        case 'emissiveColor':\n                            materialData.emissiveColor = new THREE.Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n                            break;\n                        case 'shininess':\n                            materialData.shininess = fieldValues[0];\n                            break;\n                        case 'specularColor':\n                            materialData.emissiveColor = new THREE.Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n                            break;\n                        case 'transparency':\n                            materialData.transparency = fieldValues[0];\n                            break;\n                        default:\n                            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n                            break;\n                        }\n                    }\n                    return materialData;\n                }\n                function parseHexColor(hex, textureType, color) {\n                    switch (textureType) {\n                    case TEXTURE_TYPE.INTENSITY:\n                        var value = parseInt(hex);\n                        color.r = value;\n                        color.g = value;\n                        color.b = value;\n                        break;\n                    case TEXTURE_TYPE.INTENSITY_ALPHA:\n                        var value = parseInt('0x' + hex.substring(2, 4));\n                        color.r = value;\n                        color.g = value;\n                        color.b = value;\n                        color.a = parseInt('0x' + hex.substring(4, 6));\n                        break;\n                    case TEXTURE_TYPE.RGB:\n                        color.r = parseInt('0x' + hex.substring(2, 4));\n                        color.g = parseInt('0x' + hex.substring(4, 6));\n                        color.b = parseInt('0x' + hex.substring(6, 8));\n                        break;\n                    case TEXTURE_TYPE.RGBA:\n                        color.r = parseInt('0x' + hex.substring(2, 4));\n                        color.g = parseInt('0x' + hex.substring(4, 6));\n                        color.b = parseInt('0x' + hex.substring(6, 8));\n                        color.a = parseInt('0x' + hex.substring(8, 10));\n                        break;\n                    default:\n                    }\n                }\n                function getTextureType(num_components) {\n                    var type;\n                    switch (num_components) {\n                    case 1:\n                        type = TEXTURE_TYPE.INTENSITY;\n                        break;\n                    case 2:\n                        type = TEXTURE_TYPE.INTENSITY_ALPHA;\n                        break;\n                    case 3:\n                        type = TEXTURE_TYPE.RGB;\n                        break;\n                    case 4:\n                        type = TEXTURE_TYPE.RGBA;\n                        break;\n                    default:\n                    }\n                    return type;\n                }\n                function buildPixelTextureNode(node) {\n                    var texture;\n                    var wrapS = THREE.RepeatWrapping;\n                    var wrapT = THREE.RepeatWrapping;\n                    var fields = node.fields;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        var fieldName = field.name;\n                        var fieldValues = field.values;\n                        switch (fieldName) {\n                        case 'image':\n                            var width = fieldValues[0];\n                            var height = fieldValues[1];\n                            var num_components = fieldValues[2];\n                            var useAlpha = num_components === 2 || num_components === 4;\n                            var textureType = getTextureType(num_components);\n                            var size = (useAlpha === true ? 4 : 3) * (width * height);\n                            var data = new Uint8Array(size);\n                            var color = {\n                                r: 0,\n                                g: 0,\n                                b: 0,\n                                a: 0\n                            };\n                            for (var j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n                                parseHexColor(fieldValues[j], textureType, color);\n                                if (useAlpha === true) {\n                                    var stride = k * 4;\n                                    data[stride + 0] = color.r;\n                                    data[stride + 1] = color.g;\n                                    data[stride + 2] = color.b;\n                                    data[stride + 3] = color.a;\n                                } else {\n                                    var stride = k * 3;\n                                    data[stride + 0] = color.r;\n                                    data[stride + 1] = color.g;\n                                    data[stride + 2] = color.b;\n                                }\n                            }\n                            texture = new THREE.DataTexture(data, width, height, useAlpha === true ? THREE.RGBAFormat : THREE.RGBFormat);\n                            texture.__type = textureType;\n                            break;\n                        case 'repeatS':\n                            if (fieldValues[0] === false)\n                                wrapS = THREE.ClampToEdgeWrapping;\n                            break;\n                        case 'repeatT':\n                            if (fieldValues[0] === false)\n                                wrapT = THREE.ClampToEdgeWrapping;\n                            break;\n                        default:\n                            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n                            break;\n                        }\n                    }\n                    if (texture) {\n                        texture.wrapS = wrapS;\n                        texture.wrapT = wrapT;\n                    }\n                    return texture;\n                }\n                function buildImageTextureNode(node) {\n                    var texture;\n                    var wrapS = THREE.RepeatWrapping;\n                    var wrapT = THREE.RepeatWrapping;\n                    var fields = node.fields;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        var fieldName = field.name;\n                        var fieldValues = field.values;\n                        switch (fieldName) {\n                        case 'url':\n                            var url = fieldValues[0];\n                            if (url)\n                                texture = textureLoader.load(url);\n                            break;\n                        case 'repeatS':\n                            if (fieldValues[0] === false)\n                                wrapS = THREE.ClampToEdgeWrapping;\n                            break;\n                        case 'repeatT':\n                            if (fieldValues[0] === false)\n                                wrapT = THREE.ClampToEdgeWrapping;\n                            break;\n                        default:\n                            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n                            break;\n                        }\n                    }\n                    if (texture) {\n                        texture.wrapS = wrapS;\n                        texture.wrapT = wrapT;\n                    }\n                    return texture;\n                }\n                function buildTextureTransformNode(node) {\n                    var transformData = {\n                        center: new THREE.Vector2(),\n                        rotation: new THREE.Vector2(),\n                        scale: new THREE.Vector2(),\n                        translation: new THREE.Vector2()\n                    };\n                    var fields = node.fields;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        var fieldName = field.name;\n                        var fieldValues = field.values;\n                        switch (fieldName) {\n                        case 'center':\n                            transformData.center.set(fieldValues[0], fieldValues[1]);\n                            break;\n                        case 'rotation':\n                            transformData.rotation = fieldValues[0];\n                            break;\n                        case 'scale':\n                            transformData.scale.set(fieldValues[0], fieldValues[1]);\n                            break;\n                        case 'translation':\n                            transformData.translation.set(fieldValues[0], fieldValues[1]);\n                            break;\n                        default:\n                            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n                            break;\n                        }\n                    }\n                    return transformData;\n                }\n                function buildGeometricNode(node) {\n                    return node.fields[0].values;\n                }\n                function buildIndexedFaceSetNode(node) {\n                    var color, coord, normal, texCoord;\n                    var ccw = true, solid = true, creaseAngle = 0;\n                    var colorIndex, coordIndex, normalIndex, texCoordIndex;\n                    var colorPerVertex = true, normalPerVertex = true;\n                    var fields = node.fields;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        var fieldName = field.name;\n                        var fieldValues = field.values;\n                        switch (fieldName) {\n                        case 'color':\n                            var colorNode = fieldValues[0];\n                            if (colorNode !== null) {\n                                color = getNode(colorNode);\n                            }\n                            break;\n                        case 'coord':\n                            var coordNode = fieldValues[0];\n                            if (coordNode !== null) {\n                                coord = getNode(coordNode);\n                            }\n                            break;\n                        case 'normal':\n                            var normalNode = fieldValues[0];\n                            if (normalNode !== null) {\n                                normal = getNode(normalNode);\n                            }\n                            break;\n                        case 'texCoord':\n                            var texCoordNode = fieldValues[0];\n                            if (texCoordNode !== null) {\n                                texCoord = getNode(texCoordNode);\n                            }\n                            break;\n                        case 'ccw':\n                            ccw = fieldValues[0];\n                            break;\n                        case 'colorIndex':\n                            colorIndex = fieldValues;\n                            break;\n                        case 'colorPerVertex':\n                            colorPerVertex = fieldValues[0];\n                            break;\n                        case 'convex':\n                            break;\n                        case 'coordIndex':\n                            coordIndex = fieldValues;\n                            break;\n                        case 'creaseAngle':\n                            creaseAngle = fieldValues[0];\n                            break;\n                        case 'normalIndex':\n                            normalIndex = fieldValues;\n                            break;\n                        case 'normalPerVertex':\n                            normalPerVertex = fieldValues[0];\n                            break;\n                        case 'solid':\n                            solid = fieldValues[0];\n                            break;\n                        case 'texCoordIndex':\n                            texCoordIndex = fieldValues;\n                            break;\n                        default:\n                            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n                            break;\n                        }\n                    }\n                    if (coordIndex === undefined) {\n                        console.warn('THREE.VRMLLoader: Missing coordIndex.');\n                        return new THREE.BufferGeometry();\n                    }\n                    var triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n                    var positionAttribute;\n                    var colorAttribute;\n                    var normalAttribute;\n                    var uvAttribute;\n                    if (color) {\n                        if (colorPerVertex === true) {\n                            if (colorIndex && colorIndex.length > 0) {\n                                var triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n                                colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n                            } else {\n                                colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new THREE.Float32BufferAttribute(color, 3));\n                            }\n                        } else {\n                            if (colorIndex && colorIndex.length > 0) {\n                                var flattenFaceColors = flattenData(color, colorIndex);\n                                var triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n                                colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n                            } else {\n                                var triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n                                colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n                            }\n                        }\n                    }\n                    if (normal) {\n                        if (normalPerVertex === true) {\n                            if (normalIndex && normalIndex.length > 0) {\n                                var triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n                                normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n                            } else {\n                                normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new THREE.Float32BufferAttribute(normal, 3));\n                            }\n                        } else {\n                            if (normalIndex && normalIndex.length > 0) {\n                                var flattenFaceNormals = flattenData(normal, normalIndex);\n                                var triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n                                normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n                            } else {\n                                var triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n                                normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n                            }\n                        }\n                    } else {\n                        normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n                    }\n                    if (texCoord) {\n                        if (texCoordIndex && texCoordIndex.length > 0) {\n                            var triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n                            uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n                        } else {\n                            uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new THREE.Float32BufferAttribute(texCoord, 2));\n                        }\n                    }\n                    var geometry = new THREE.BufferGeometry();\n                    positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new THREE.Float32BufferAttribute(coord, 3));\n                    geometry.setAttribute('position', positionAttribute);\n                    geometry.setAttribute('normal', normalAttribute);\n                    if (colorAttribute)\n                        geometry.setAttribute('color', colorAttribute);\n                    if (uvAttribute)\n                        geometry.setAttribute('uv', uvAttribute);\n                    geometry._solid = solid;\n                    geometry._type = 'mesh';\n                    return geometry;\n                }\n                function buildIndexedLineSetNode(node) {\n                    var color, coord;\n                    var colorIndex, coordIndex;\n                    var colorPerVertex = true;\n                    var fields = node.fields;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        var fieldName = field.name;\n                        var fieldValues = field.values;\n                        switch (fieldName) {\n                        case 'color':\n                            var colorNode = fieldValues[0];\n                            if (colorNode !== null) {\n                                color = getNode(colorNode);\n                            }\n                            break;\n                        case 'coord':\n                            var coordNode = fieldValues[0];\n                            if (coordNode !== null) {\n                                coord = getNode(coordNode);\n                            }\n                            break;\n                        case 'colorIndex':\n                            colorIndex = fieldValues;\n                            break;\n                        case 'colorPerVertex':\n                            colorPerVertex = fieldValues[0];\n                            break;\n                        case 'coordIndex':\n                            coordIndex = fieldValues;\n                            break;\n                        default:\n                            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n                            break;\n                        }\n                    }\n                    var colorAttribute;\n                    var expandedLineIndex = expandLineIndex(coordIndex);\n                    if (color) {\n                        if (colorPerVertex === true) {\n                            if (colorIndex.length > 0) {\n                                var expandedColorIndex = expandLineIndex(colorIndex);\n                                colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3);\n                            } else {\n                                colorAttribute = toNonIndexedAttribute(expandedLineIndex, new THREE.Float32BufferAttribute(color, 3));\n                            }\n                        } else {\n                            if (colorIndex.length > 0) {\n                                var flattenLineColors = flattenData(color, colorIndex);\n                                var expandedLineColors = expandLineData(flattenLineColors, coordIndex);\n                                colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors);\n                            } else {\n                                var expandedLineColors = expandLineData(color, coordIndex);\n                                colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors);\n                            }\n                        }\n                    }\n                    var geometry = new THREE.BufferGeometry();\n                    var positionAttribute = toNonIndexedAttribute(expandedLineIndex, new THREE.Float32BufferAttribute(coord, 3));\n                    geometry.setAttribute('position', positionAttribute);\n                    if (colorAttribute)\n                        geometry.setAttribute('color', colorAttribute);\n                    geometry._type = 'line';\n                    return geometry;\n                }\n                function buildPointSetNode(node) {\n                    var geometry;\n                    var color, coord;\n                    var fields = node.fields;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        var fieldName = field.name;\n                        var fieldValues = field.values;\n                        switch (fieldName) {\n                        case 'color':\n                            var colorNode = fieldValues[0];\n                            if (colorNode !== null) {\n                                color = getNode(colorNode);\n                            }\n                            break;\n                        case 'coord':\n                            var coordNode = fieldValues[0];\n                            if (coordNode !== null) {\n                                coord = getNode(coordNode);\n                            }\n                            break;\n                        default:\n                            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n                            break;\n                        }\n                    }\n                    var geometry = new THREE.BufferGeometry();\n                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(coord, 3));\n                    if (color)\n                        geometry.setAttribute('color', new THREE.Float32BufferAttribute(color, 3));\n                    geometry._type = 'points';\n                    return geometry;\n                }\n                function buildBoxNode(node) {\n                    var size = new THREE.Vector3(2, 2, 2);\n                    var fields = node.fields;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        var fieldName = field.name;\n                        var fieldValues = field.values;\n                        switch (fieldName) {\n                        case 'size':\n                            size.x = fieldValues[0];\n                            size.y = fieldValues[1];\n                            size.z = fieldValues[2];\n                            break;\n                        default:\n                            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n                            break;\n                        }\n                    }\n                    var geometry = new THREE.BoxBufferGeometry(size.x, size.y, size.z);\n                    return geometry;\n                }\n                function buildConeNode(node) {\n                    var radius = 1, height = 2, openEnded = false;\n                    var fields = node.fields;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        var fieldName = field.name;\n                        var fieldValues = field.values;\n                        switch (fieldName) {\n                        case 'bottom':\n                            openEnded = !fieldValues[0];\n                            break;\n                        case 'bottomRadius':\n                            radius = fieldValues[0];\n                            break;\n                        case 'height':\n                            height = fieldValues[0];\n                            break;\n                        case 'side':\n                            break;\n                        default:\n                            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n                            break;\n                        }\n                    }\n                    var geometry = new THREE.ConeBufferGeometry(radius, height, 16, 1, openEnded);\n                    return geometry;\n                }\n                function buildCylinderNode(node) {\n                    var radius = 1, height = 2;\n                    var fields = node.fields;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        var fieldName = field.name;\n                        var fieldValues = field.values;\n                        switch (fieldName) {\n                        case 'bottom':\n                            break;\n                        case 'radius':\n                            radius = fieldValues[0];\n                            break;\n                        case 'height':\n                            height = fieldValues[0];\n                            break;\n                        case 'side':\n                            break;\n                        case 'top':\n                            break;\n                        default:\n                            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n                            break;\n                        }\n                    }\n                    var geometry = new THREE.CylinderBufferGeometry(radius, radius, height, 16, 1);\n                    return geometry;\n                }\n                function buildSphereNode(node) {\n                    var radius = 1;\n                    var fields = node.fields;\n                    for (var i = 0, l = fields.length; i < l; i++) {\n                        var field = fields[i];\n                        var fieldName = field.name;\n                        var fieldValues = field.values;\n                        switch (fieldName) {\n                        case 'radius':\n                            radius = fieldValues[0];\n                            break;\n                        default:\n                            console.warn('THREE.VRMLLoader: Unknown field:', fieldName);\n                            break;\n                        }\n                    }\n                    var geometry = new THREE.SphereBufferGeometry(radius, 16, 16);\n                    return geometry;\n                }\n                function resolveUSE(identifier) {\n                    var node = nodeMap[identifier];\n                    var build = getNode(node);\n                    return build.isObject3D || build.isMaterial ? build.clone() : build;\n                }\n                function parseFieldChildren(children, owner) {\n                    for (var i = 0, l = children.length; i < l; i++) {\n                        var object = getNode(children[i]);\n                        if (object instanceof THREE.Object3D)\n                            owner.add(object);\n                    }\n                }\n                function triangulateFaceIndex(index, ccw) {\n                    var indices = [];\n                    var start = 0;\n                    for (var i = 0, l = index.length; i < l; i++) {\n                        var i1 = index[start];\n                        var i2 = index[i + (ccw ? 1 : 2)];\n                        var i3 = index[i + (ccw ? 2 : 1)];\n                        indices.push(i1, i2, i3);\n                        if (index[i + 3] === -1 || i + 3 >= l) {\n                            i += 3;\n                            start = i + 1;\n                        }\n                    }\n                    return indices;\n                }\n                function triangulateFaceData(data, index) {\n                    var triangulatedData = [];\n                    var start = 0;\n                    for (var i = 0, l = index.length; i < l; i++) {\n                        var stride = start * 3;\n                        var x = data[stride];\n                        var y = data[stride + 1];\n                        var z = data[stride + 2];\n                        triangulatedData.push(x, y, z);\n                        if (index[i + 3] === -1 || i + 3 >= l) {\n                            i += 3;\n                            start++;\n                        }\n                    }\n                    return triangulatedData;\n                }\n                function flattenData(data, index) {\n                    var flattenData = [];\n                    for (var i = 0, l = index.length; i < l; i++) {\n                        var i1 = index[i];\n                        var stride = i1 * 3;\n                        var x = data[stride];\n                        var y = data[stride + 1];\n                        var z = data[stride + 2];\n                        flattenData.push(x, y, z);\n                    }\n                    return flattenData;\n                }\n                function expandLineIndex(index) {\n                    var indices = [];\n                    for (var i = 0, l = index.length; i < l; i++) {\n                        var i1 = index[i];\n                        var i2 = index[i + 1];\n                        indices.push(i1, i2);\n                        if (index[i + 2] === -1 || i + 2 >= l) {\n                            i += 2;\n                        }\n                    }\n                    return indices;\n                }\n                function expandLineData(data, index) {\n                    var triangulatedData = [];\n                    var start = 0;\n                    for (var i = 0, l = index.length; i < l; i++) {\n                        var stride = start * 3;\n                        var x = data[stride];\n                        var y = data[stride + 1];\n                        var z = data[stride + 2];\n                        triangulatedData.push(x, y, z);\n                        if (index[i + 2] === -1 || i + 2 >= l) {\n                            i += 2;\n                            start++;\n                        }\n                    }\n                    return triangulatedData;\n                }\n                var vA = new THREE.Vector3();\n                var vB = new THREE.Vector3();\n                var vC = new THREE.Vector3();\n                var uvA = new THREE.Vector2();\n                var uvB = new THREE.Vector2();\n                var uvC = new THREE.Vector2();\n                function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\n                    var array = [];\n                    for (var i = 0, l = coordIndex.length; i < l; i += 3) {\n                        var a = index[i];\n                        var b = index[i + 1];\n                        var c = index[i + 2];\n                        if (itemSize === 2) {\n                            uvA.fromArray(data, a * itemSize);\n                            uvB.fromArray(data, b * itemSize);\n                            uvC.fromArray(data, c * itemSize);\n                            array.push(uvA.x, uvA.y);\n                            array.push(uvB.x, uvB.y);\n                            array.push(uvC.x, uvC.y);\n                        } else {\n                            vA.fromArray(data, a * itemSize);\n                            vB.fromArray(data, b * itemSize);\n                            vC.fromArray(data, c * itemSize);\n                            array.push(vA.x, vA.y, vA.z);\n                            array.push(vB.x, vB.y, vB.z);\n                            array.push(vC.x, vC.y, vC.z);\n                        }\n                    }\n                    return new THREE.Float32BufferAttribute(array, itemSize);\n                }\n                function computeAttributeFromFaceData(index, faceData) {\n                    var array = [];\n                    for (var i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n                        vA.fromArray(faceData, j * 3);\n                        array.push(vA.x, vA.y, vA.z);\n                        array.push(vA.x, vA.y, vA.z);\n                        array.push(vA.x, vA.y, vA.z);\n                    }\n                    return new THREE.Float32BufferAttribute(array, 3);\n                }\n                function computeAttributeFromLineData(index, lineData) {\n                    var array = [];\n                    for (var i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n                        vA.fromArray(lineData, j * 3);\n                        array.push(vA.x, vA.y, vA.z);\n                        array.push(vA.x, vA.y, vA.z);\n                    }\n                    return new THREE.Float32BufferAttribute(array, 3);\n                }\n                function toNonIndexedAttribute(indices, attribute) {\n                    var array = attribute.array;\n                    var itemSize = attribute.itemSize;\n                    var array2 = new array.constructor(indices.length * itemSize);\n                    var index = 0, index2 = 0;\n                    for (var i = 0, l = indices.length; i < l; i++) {\n                        index = indices[i] * itemSize;\n                        for (var j = 0; j < itemSize; j++) {\n                            array2[index2++] = array[index++];\n                        }\n                    }\n                    return new THREE.Float32BufferAttribute(array2, itemSize);\n                }\n                var ab = new THREE.Vector3();\n                var cb = new THREE.Vector3();\n                function computeNormalAttribute(index, coord, creaseAngle) {\n                    var faces = [];\n                    var vertexNormals = {};\n                    for (var i = 0, l = index.length; i < l; i += 3) {\n                        var a = index[i];\n                        var b = index[i + 1];\n                        var c = index[i + 2];\n                        var face = new Face(a, b, c);\n                        vA.fromArray(coord, a * 3);\n                        vB.fromArray(coord, b * 3);\n                        vC.fromArray(coord, c * 3);\n                        cb.subVectors(vC, vB);\n                        ab.subVectors(vA, vB);\n                        cb.cross(ab);\n                        cb.normalize();\n                        face.normal.copy(cb);\n                        if (vertexNormals[a] === undefined)\n                            vertexNormals[a] = [];\n                        if (vertexNormals[b] === undefined)\n                            vertexNormals[b] = [];\n                        if (vertexNormals[c] === undefined)\n                            vertexNormals[c] = [];\n                        vertexNormals[a].push(face.normal);\n                        vertexNormals[b].push(face.normal);\n                        vertexNormals[c].push(face.normal);\n                        faces.push(face);\n                    }\n                    var normals = [];\n                    for (var i = 0, l = faces.length; i < l; i++) {\n                        var face = faces[i];\n                        var nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle);\n                        var nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle);\n                        var nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle);\n                        vA.fromArray(coord, face.a * 3);\n                        vB.fromArray(coord, face.b * 3);\n                        vC.fromArray(coord, face.c * 3);\n                        normals.push(nA.x, nA.y, nA.z);\n                        normals.push(nB.x, nB.y, nB.z);\n                        normals.push(nC.x, nC.y, nC.z);\n                    }\n                    return new THREE.Float32BufferAttribute(normals, 3);\n                }\n                function weightedNormal(normals, vector, creaseAngle) {\n                    var normal = new THREE.Vector3();\n                    if (creaseAngle === 0) {\n                        normal.copy(vector);\n                    } else {\n                        for (var i = 0, l = normals.length; i < l; i++) {\n                            if (normals[i].angleTo(vector) < creaseAngle) {\n                                normal.add(normals[i]);\n                            }\n                        }\n                    }\n                    return normal.normalize();\n                }\n                function toColorArray(colors) {\n                    var array = [];\n                    for (var i = 0, l = colors.length; i < l; i += 3) {\n                        array.push(new THREE.Color(colors[i], colors[i + 1], colors[i + 2]));\n                    }\n                    return array;\n                }\n                function paintFaces(geometry, radius, angles, colors, topDown) {\n                    var thresholds = [];\n                    var startAngle = topDown === true ? 0 : Math.PI;\n                    for (var i = 0, l = colors.length; i < l; i++) {\n                        var angle = i === 0 ? 0 : angles[i - 1];\n                        angle = topDown === true ? angle : startAngle - angle;\n                        var point = new THREE.Vector3();\n                        point.setFromSphericalCoords(radius, angle, 0);\n                        thresholds.push(point);\n                    }\n                    var indices = geometry.index;\n                    var positionAttribute = geometry.attributes.position;\n                    var colorAttribute = new THREE.BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n                    var position = new THREE.Vector3();\n                    var color = new THREE.Color();\n                    for (var i = 0; i < indices.count; i++) {\n                        var index = indices.getX(i);\n                        position.fromBufferAttribute(positionAttribute, index);\n                        var thresholdIndexA, thresholdIndexB;\n                        var t = 1;\n                        for (var j = 1; j < thresholds.length; j++) {\n                            thresholdIndexA = j - 1;\n                            thresholdIndexB = j;\n                            var thresholdA = thresholds[thresholdIndexA];\n                            var thresholdB = thresholds[thresholdIndexB];\n                            if (topDown === true) {\n                                if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n                                    t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                                    break;\n                                }\n                            } else {\n                                if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n                                    t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                                    break;\n                                }\n                            }\n                        }\n                        var colorA = colors[thresholdIndexA];\n                        var colorB = colors[thresholdIndexB];\n                        color.copy(colorA).lerp(colorB, t);\n                        colorAttribute.setXYZ(index, color.r, color.g, color.b);\n                    }\n                    geometry.setAttribute('color', colorAttribute);\n                }\n                var textureLoader = new THREE.TextureLoader(this.manager);\n                textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n                var tree = generateVRMLTree(data);\n                if (tree.version.indexOf('V2.0') === -1) {\n                    throw Error('THREE.VRMLLexer: Version of VRML asset not supported.');\n                }\n                var scene = parseTree(tree);\n                return scene;\n            }\n        });\n        function VRMLLexer(tokens) {\n            this.lexer = new chevrotain.Lexer(tokens);\n        }\n        VRMLLexer.prototype = {\n            constructor: VRMLLexer,\n            lex: function (inputText) {\n                var lexingResult = this.lexer.tokenize(inputText);\n                if (lexingResult.errors.length > 0) {\n                    console.error(lexingResult.errors);\n                    throw Error('THREE.VRMLLexer: Lexing errors detected.');\n                }\n                return lexingResult;\n            }\n        };\n        function VRMLParser(tokenVocabulary) {\n            chevrotain.Parser.call(this, tokenVocabulary);\n            var $ = this;\n            var Version = tokenVocabulary['Version'];\n            var LCurly = tokenVocabulary['LCurly'];\n            var RCurly = tokenVocabulary['RCurly'];\n            var LSquare = tokenVocabulary['LSquare'];\n            var RSquare = tokenVocabulary['RSquare'];\n            var Identifier = tokenVocabulary['Identifier'];\n            var RouteIdentifier = tokenVocabulary['RouteIdentifier'];\n            var StringLiteral = tokenVocabulary['StringLiteral'];\n            var HexLiteral = tokenVocabulary['HexLiteral'];\n            var NumberLiteral = tokenVocabulary['NumberLiteral'];\n            var TrueLiteral = tokenVocabulary['TrueLiteral'];\n            var FalseLiteral = tokenVocabulary['FalseLiteral'];\n            var NullLiteral = tokenVocabulary['NullLiteral'];\n            var DEF = tokenVocabulary['DEF'];\n            var USE = tokenVocabulary['USE'];\n            var ROUTE = tokenVocabulary['ROUTE'];\n            var TO = tokenVocabulary['TO'];\n            var NodeName = tokenVocabulary['NodeName'];\n            $.RULE('vrml', function () {\n                $.SUBRULE($.version);\n                $.AT_LEAST_ONE(function () {\n                    $.SUBRULE($.node);\n                });\n                $.MANY(function () {\n                    $.SUBRULE($.route);\n                });\n            });\n            $.RULE('version', function () {\n                $.CONSUME(Version);\n            });\n            $.RULE('node', function () {\n                $.OPTION(function () {\n                    $.SUBRULE($.def);\n                });\n                $.CONSUME(NodeName);\n                $.CONSUME(LCurly);\n                $.MANY(function () {\n                    $.SUBRULE($.field);\n                });\n                $.CONSUME(RCurly);\n            });\n            $.RULE('field', function () {\n                $.CONSUME(Identifier);\n                $.OR2([\n                    {\n                        ALT: function () {\n                            $.SUBRULE($.singleFieldValue);\n                        }\n                    },\n                    {\n                        ALT: function () {\n                            $.SUBRULE($.multiFieldValue);\n                        }\n                    }\n                ]);\n            });\n            $.RULE('def', function () {\n                $.CONSUME(DEF);\n                $.CONSUME(Identifier);\n            });\n            $.RULE('use', function () {\n                $.CONSUME(USE);\n                $.CONSUME(Identifier);\n            });\n            $.RULE('singleFieldValue', function () {\n                $.AT_LEAST_ONE(function () {\n                    $.OR([\n                        {\n                            ALT: function () {\n                                $.SUBRULE($.node);\n                            }\n                        },\n                        {\n                            ALT: function () {\n                                $.SUBRULE($.use);\n                            }\n                        },\n                        {\n                            ALT: function () {\n                                $.CONSUME(StringLiteral);\n                            }\n                        },\n                        {\n                            ALT: function () {\n                                $.CONSUME(HexLiteral);\n                            }\n                        },\n                        {\n                            ALT: function () {\n                                $.CONSUME(NumberLiteral);\n                            }\n                        },\n                        {\n                            ALT: function () {\n                                $.CONSUME(TrueLiteral);\n                            }\n                        },\n                        {\n                            ALT: function () {\n                                $.CONSUME(FalseLiteral);\n                            }\n                        },\n                        {\n                            ALT: function () {\n                                $.CONSUME(NullLiteral);\n                            }\n                        }\n                    ]);\n                });\n            });\n            $.RULE('multiFieldValue', function () {\n                $.CONSUME(LSquare);\n                $.MANY(function () {\n                    $.OR([\n                        {\n                            ALT: function () {\n                                $.SUBRULE($.node);\n                            }\n                        },\n                        {\n                            ALT: function () {\n                                $.SUBRULE($.use);\n                            }\n                        },\n                        {\n                            ALT: function () {\n                                $.CONSUME(StringLiteral);\n                            }\n                        },\n                        {\n                            ALT: function () {\n                                $.CONSUME(HexLiteral);\n                            }\n                        },\n                        {\n                            ALT: function () {\n                                $.CONSUME(NumberLiteral);\n                            }\n                        },\n                        {\n                            ALT: function () {\n                                $.CONSUME(NullLiteral);\n                            }\n                        }\n                    ]);\n                });\n                $.CONSUME(RSquare);\n            });\n            $.RULE('route', function () {\n                $.CONSUME(ROUTE);\n                $.CONSUME(RouteIdentifier);\n                $.CONSUME(TO);\n                $.CONSUME2(RouteIdentifier);\n            });\n            this.performSelfAnalysis();\n        }\n        VRMLParser.prototype = Object.create(chevrotain.Parser.prototype);\n        VRMLParser.prototype.constructor = VRMLParser;\n        function Face(a, b, c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n            this.normal = new THREE.Vector3();\n        }\n        var TEXTURE_TYPE = {\n            INTENSITY: 1,\n            INTENSITY_ALPHA: 2,\n            RGB: 3,\n            RGBA: 4\n        };\n        return VRMLLoader;\n    }();\n    return VRMLLoader;\n});"]}