{"version":3,"sources":["loaders/DRACOLoader.js"],"names":["define","THREE","DRACOLoader","manager","Loader","call","this","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","position","normal","color","uv","defaultAttributeTypes","prototype","Object","assign","create","constructor","setDecoderPath","path","setDecoderConfig","config","setWorkerLimit","setVerbosity","console","warn","setDrawMode","setSkipDequantization","load","url","onLoad","onProgress","onError","loader","FileLoader","setPath","setResponseType","crossOrigin","setWithCredentials","buffer","taskConfig","attributeIDs","attributeTypes","useUniqueIDs","decodeGeometry","then","catch","decodeDracoFile","callback","attribute","type","undefined","BYTES_PER_ELEMENT","name","worker","taskKey","JSON","stringify","taskCache","has","cachedTask","get","key","promise","byteLength","Error","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","id","message","_createGeometry","geometry","finally","_releaseTask","set","geometryData","BufferGeometry","index","setIndex","BufferAttribute","array","i","attributes","length","itemSize","setAttribute","_loadLibrary","responseType","preload","_initDecoder","useJS","WebAssembly","librariesPending","push","all","libraries","jsContent","wasmBinary","fn","DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","Worker","_taskCosts","_taskLoad","onmessage","e","data","error","sort","a","b","debug","log","map","dispose","terminate","decodeAttribute","draco","decoder","dracoGeometry","attributeName","attributeType","dracoArray","numComponents","num_components","numValues","num_points","Float32Array","DracoFloat32Array","GetAttributeFloatForAllPoints","Int8Array","DracoInt8Array","GetAttributeInt8ForAllPoints","Int16Array","DracoInt16Array","GetAttributeInt16ForAllPoints","Int32Array","DracoInt32Array","GetAttributeInt32ForAllPoints","Uint8Array","DracoUInt8Array","GetAttributeUInt8ForAllPoints","Uint16Array","DracoUInt16Array","GetAttributeUInt16ForAllPoints","Uint32Array","DracoUInt32Array","GetAttributeUInt32ForAllPoints","GetValue","destroy","onModuleLoaded","DracoDecoderModule","module","Decoder","decoderBuffer","DecoderBuffer","Init","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","ptr","error_msg","attributeID","self","GetAttributeByUniqueId","GetAttributeId","GetAttribute","numFaces","num_faces","numIndices","indexArray","GetFaceFromMesh","j","buffers","attr","WeakMap","releaseDecoderModule","getDecoderModule"],"mappings":"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","file":"../../loaders/DRACOLoader.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var DRACOLoader = function (manager) {\n        THREE.Loader.call(this, manager);\n        this.decoderPath = '';\n        this.decoderConfig = {};\n        this.decoderBinary = null;\n        this.decoderPending = null;\n        this.workerLimit = 4;\n        this.workerPool = [];\n        this.workerNextTaskID = 1;\n        this.workerSourceURL = '';\n        this.defaultAttributeIDs = {\n            position: 'POSITION',\n            normal: 'NORMAL',\n            color: 'COLOR',\n            uv: 'TEX_COORD'\n        };\n        this.defaultAttributeTypes = {\n            position: 'Float32Array',\n            normal: 'Float32Array',\n            color: 'Float32Array',\n            uv: 'Float32Array'\n        };\n    };\n    DRACOLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {\n        constructor: DRACOLoader,\n        setDecoderPath: function (path) {\n            this.decoderPath = path;\n            return this;\n        },\n        setDecoderConfig: function (config) {\n            this.decoderConfig = config;\n            return this;\n        },\n        setWorkerLimit: function (workerLimit) {\n            this.workerLimit = workerLimit;\n            return this;\n        },\n        setVerbosity: function () {\n            console.warn('THREE.DRACOLoader: The .setVerbosity() method has been removed.');\n        },\n        setDrawMode: function () {\n            console.warn('THREE.DRACOLoader: The .setDrawMode() method has been removed.');\n        },\n        setSkipDequantization: function () {\n            console.warn('THREE.DRACOLoader: The .setSkipDequantization() method has been removed.');\n        },\n        load: function (url, onLoad, onProgress, onError) {\n            var loader = new THREE.FileLoader(this.manager);\n            loader.setPath(this.path);\n            loader.setResponseType('arraybuffer');\n            if (this.crossOrigin === 'use-credentials') {\n                loader.setWithCredentials(true);\n            }\n            loader.load(url, buffer => {\n                var taskConfig = {\n                    attributeIDs: this.defaultAttributeIDs,\n                    attributeTypes: this.defaultAttributeTypes,\n                    useUniqueIDs: false\n                };\n                this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n            }, onProgress, onError);\n        },\n        decodeDracoFile: function (buffer, callback, attributeIDs, attributeTypes) {\n            var taskConfig = {\n                attributeIDs: attributeIDs || this.defaultAttributeIDs,\n                attributeTypes: attributeTypes || this.defaultAttributeTypes,\n                useUniqueIDs: !!attributeIDs\n            };\n            this.decodeGeometry(buffer, taskConfig).then(callback);\n        },\n        decodeGeometry: function (buffer, taskConfig) {\n            for (var attribute in taskConfig.attributeTypes) {\n                var type = taskConfig.attributeTypes[attribute];\n                if (type.BYTES_PER_ELEMENT !== undefined) {\n                    taskConfig.attributeTypes[attribute] = type.name;\n                }\n            }\n            var taskKey = JSON.stringify(taskConfig);\n            if (DRACOLoader.taskCache.has(buffer)) {\n                var cachedTask = DRACOLoader.taskCache.get(buffer);\n                if (cachedTask.key === taskKey) {\n                    return cachedTask.promise;\n                } else if (buffer.byteLength === 0) {\n                    throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');\n                }\n            }\n            var worker;\n            var taskID = this.workerNextTaskID++;\n            var taskCost = buffer.byteLength;\n            var geometryPending = this._getWorker(taskID, taskCost).then(_worker => {\n                worker = _worker;\n                return new Promise((resolve, reject) => {\n                    worker._callbacks[taskID] = {\n                        resolve,\n                        reject\n                    };\n                    worker.postMessage({\n                        type: 'decode',\n                        id: taskID,\n                        taskConfig,\n                        buffer\n                    }, [buffer]);\n                });\n            }).then(message => this._createGeometry(message.geometry));\n            geometryPending.finally(() => {\n                if (worker && taskID) {\n                    this._releaseTask(worker, taskID);\n                }\n            });\n            DRACOLoader.taskCache.set(buffer, {\n                key: taskKey,\n                promise: geometryPending\n            });\n            return geometryPending;\n        },\n        _createGeometry: function (geometryData) {\n            var geometry = new THREE.BufferGeometry();\n            if (geometryData.index) {\n                geometry.setIndex(new THREE.BufferAttribute(geometryData.index.array, 1));\n            }\n            for (var i = 0; i < geometryData.attributes.length; i++) {\n                var attribute = geometryData.attributes[i];\n                var name = attribute.name;\n                var array = attribute.array;\n                var itemSize = attribute.itemSize;\n                geometry.setAttribute(name, new THREE.BufferAttribute(array, itemSize));\n            }\n            return geometry;\n        },\n        _loadLibrary: function (url, responseType) {\n            var loader = new THREE.FileLoader(this.manager);\n            loader.setPath(this.decoderPath);\n            loader.setResponseType(responseType);\n            return new Promise((resolve, reject) => {\n                loader.load(url, resolve, undefined, reject);\n            });\n        },\n        preload: function () {\n            this._initDecoder();\n            return this;\n        },\n        _initDecoder: function () {\n            if (this.decoderPending)\n                return this.decoderPending;\n            var useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n            var librariesPending = [];\n            if (useJS) {\n                librariesPending.push(this._loadLibrary('draco_decoder', 'text'));\n            } else {\n                librariesPending.push(this._loadLibrary('draco_wasm_wrapper', 'text'));\n                librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\n            }\n            this.decoderPending = Promise.all(librariesPending).then(libraries => {\n                var jsContent = libraries[0];\n                if (!useJS) {\n                    this.decoderConfig.wasmBinary = libraries[1];\n                }\n                var fn = DRACOLoader.DRACOWorker.toString();\n                var body = [\n                    '/* draco decoder */',\n                    jsContent,\n                    '',\n                    '/* worker */',\n                    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))\n                ].join('\\n');\n                this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n            });\n            return this.decoderPending;\n        },\n        _getWorker: function (taskID, taskCost) {\n            return this._initDecoder().then(() => {\n                if (this.workerPool.length < this.workerLimit) {\n                    var worker = new Worker(this.workerSourceURL);\n                    worker._callbacks = {};\n                    worker._taskCosts = {};\n                    worker._taskLoad = 0;\n                    worker.postMessage({\n                        type: 'init',\n                        decoderConfig: this.decoderConfig\n                    });\n                    worker.onmessage = function (e) {\n                        var message = e.data;\n                        switch (message.type) {\n                        case 'decode':\n                            worker._callbacks[message.id].resolve(message);\n                            break;\n                        case 'error':\n                            worker._callbacks[message.id].reject(message);\n                            break;\n                        default:\n                            console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n                        }\n                    };\n                    this.workerPool.push(worker);\n                } else {\n                    this.workerPool.sort(function (a, b) {\n                        return a._taskLoad > b._taskLoad ? -1 : 1;\n                    });\n                }\n                var worker = this.workerPool[this.workerPool.length - 1];\n                worker._taskCosts[taskID] = taskCost;\n                worker._taskLoad += taskCost;\n                return worker;\n            });\n        },\n        _releaseTask: function (worker, taskID) {\n            worker._taskLoad -= worker._taskCosts[taskID];\n            delete worker._callbacks[taskID];\n            delete worker._taskCosts[taskID];\n        },\n        debug: function () {\n            console.log('Task load: ', this.workerPool.map(worker => worker._taskLoad));\n        },\n        dispose: function () {\n            for (var i = 0; i < this.workerPool.length; ++i) {\n                this.workerPool[i].terminate();\n            }\n            this.workerPool.length = 0;\n            return this;\n        }\n    });\n    DRACOLoader.DRACOWorker = function () {\n        var decoderConfig;\n        var decoderPending;\n        onmessage = function (e) {\n            var message = e.data;\n            switch (message.type) {\n            case 'init':\n                decoderConfig = message.decoderConfig;\n                decoderPending = new Promise(function (resolve) {\n                    decoderConfig.onModuleLoaded = function (draco) {\n                        resolve({ draco: draco });\n                    };\n                    DracoDecoderModule(decoderConfig);\n                });\n                break;\n            case 'decode':\n                var buffer = message.buffer;\n                var taskConfig = message.taskConfig;\n                decoderPending.then(module => {\n                    var draco = module.draco;\n                    var decoder = new draco.Decoder();\n                    var decoderBuffer = new draco.DecoderBuffer();\n                    decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n                    try {\n                        var geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n                        var buffers = geometry.attributes.map(attr => attr.array.buffer);\n                        if (geometry.index)\n                            buffers.push(geometry.index.array.buffer);\n                        self.postMessage({\n                            type: 'decode',\n                            id: message.id,\n                            geometry\n                        }, buffers);\n                    } catch (error) {\n                        console.error(error);\n                        self.postMessage({\n                            type: 'error',\n                            id: message.id,\n                            error: error.message\n                        });\n                    } finally {\n                        draco.destroy(decoderBuffer);\n                        draco.destroy(decoder);\n                    }\n                });\n                break;\n            }\n        };\n        function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n            var attributeIDs = taskConfig.attributeIDs;\n            var attributeTypes = taskConfig.attributeTypes;\n            var dracoGeometry;\n            var decodingStatus;\n            var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n            if (geometryType === draco.TRIANGULAR_MESH) {\n                dracoGeometry = new draco.Mesh();\n                decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n            } else if (geometryType === draco.POINT_CLOUD) {\n                dracoGeometry = new draco.PointCloud();\n                decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n            } else {\n                throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\n            }\n            if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n                throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\n            }\n            var geometry = {\n                index: null,\n                attributes: []\n            };\n            for (var attributeName in attributeIDs) {\n                var attributeType = self[attributeTypes[attributeName]];\n                var attribute;\n                var attributeID;\n                if (taskConfig.useUniqueIDs) {\n                    attributeID = attributeIDs[attributeName];\n                    attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n                } else {\n                    attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n                    if (attributeID === -1)\n                        continue;\n                    attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n                }\n                geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n            }\n            if (geometryType === draco.TRIANGULAR_MESH) {\n                var numFaces = dracoGeometry.num_faces();\n                var numIndices = numFaces * 3;\n                var index = new Uint32Array(numIndices);\n                var indexArray = new draco.DracoInt32Array();\n                for (var i = 0; i < numFaces; ++i) {\n                    decoder.GetFaceFromMesh(dracoGeometry, i, indexArray);\n                    for (var j = 0; j < 3; ++j) {\n                        index[i * 3 + j] = indexArray.GetValue(j);\n                    }\n                }\n                geometry.index = {\n                    array: index,\n                    itemSize: 1\n                };\n                draco.destroy(indexArray);\n            }\n            draco.destroy(dracoGeometry);\n            return geometry;\n        }\n        function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n            var numComponents = attribute.num_components();\n            var numPoints = dracoGeometry.num_points();\n            var numValues = numPoints * numComponents;\n            var dracoArray;\n            var array;\n            switch (attributeType) {\n            case Float32Array:\n                dracoArray = new draco.DracoFloat32Array();\n                decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, dracoArray);\n                array = new Float32Array(numValues);\n                break;\n            case Int8Array:\n                dracoArray = new draco.DracoInt8Array();\n                decoder.GetAttributeInt8ForAllPoints(dracoGeometry, attribute, dracoArray);\n                array = new Int8Array(numValues);\n                break;\n            case Int16Array:\n                dracoArray = new draco.DracoInt16Array();\n                decoder.GetAttributeInt16ForAllPoints(dracoGeometry, attribute, dracoArray);\n                array = new Int16Array(numValues);\n                break;\n            case Int32Array:\n                dracoArray = new draco.DracoInt32Array();\n                decoder.GetAttributeInt32ForAllPoints(dracoGeometry, attribute, dracoArray);\n                array = new Int32Array(numValues);\n                break;\n            case Uint8Array:\n                dracoArray = new draco.DracoUInt8Array();\n                decoder.GetAttributeUInt8ForAllPoints(dracoGeometry, attribute, dracoArray);\n                array = new Uint8Array(numValues);\n                break;\n            case Uint16Array:\n                dracoArray = new draco.DracoUInt16Array();\n                decoder.GetAttributeUInt16ForAllPoints(dracoGeometry, attribute, dracoArray);\n                array = new Uint16Array(numValues);\n                break;\n            case Uint32Array:\n                dracoArray = new draco.DracoUInt32Array();\n                decoder.GetAttributeUInt32ForAllPoints(dracoGeometry, attribute, dracoArray);\n                array = new Uint32Array(numValues);\n                break;\n            default:\n                throw new Error('THREE.DRACOLoader: Unexpected attribute type.');\n            }\n            for (var i = 0; i < numValues; i++) {\n                array[i] = dracoArray.GetValue(i);\n            }\n            draco.destroy(dracoArray);\n            return {\n                name: attributeName,\n                array: array,\n                itemSize: numComponents\n            };\n        }\n    };\n    DRACOLoader.taskCache = new WeakMap();\n    DRACOLoader.setDecoderPath = function () {\n        console.warn('THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.');\n    };\n    DRACOLoader.setDecoderConfig = function () {\n        console.warn('THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.');\n    };\n    DRACOLoader.releaseDecoderModule = function () {\n        console.warn('THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.');\n    };\n    DRACOLoader.getDecoderModule = function () {\n        console.warn('THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.');\n    };\n    return DRACOLoader;\n});"]}