{"version":3,"sources":["loaders/LWOLoader.js"],"names":["define","THREE","LWO2Parser","IFFParser","this","IFF","LWO3Parser","debugger","Debugger","DataViewReader","buffer","dv","DataView","offset","active","depth","formList","isEven","num","stringOffset","string","length","lwoTree","LWOTreeParser","textureLoader","MaterialParser","GeometryParser","prototype","constructor","parseBlock","reader","closeForms","blockID","getIDTag","getUint32","byteLength","getUint16","dataOffset","parseForm","skipped","skip","parseSurfaceLwo2","parseClipLwo2","currentNode","getInt32","parseObjectTag","parseLayer","parsePoints","parseVertexMapping","getVariableLengthIndex","parsePolygonList","parseTagStrings","parsePolygonTagMapping","currentForm","description","getString","comment","channelName","wrap","w","h","index","imageIndex","referenceObject","referenceObjectID","currentSurface","surfaceShaderName","surfaceCustomAOVName","disabled","realName","refName","nodes","nodeName","push","inputNodeName","inputName","inputOutputName","fileName","textureChannel","maxSmoothingAngle","getFloat32","attributes","smooth","Color","value","getFloat32Array","Luminosity","Specular","Diffuse","Reflection","Glossiness","opacity","bumpStrength","side","reflectionMap","refractiveIndex","refractionMap","UVChannel","widthWrappingMode","heightWrappingMode","parseUnknownCHUNK","node","nodeID","log","currentFormEnd","parentForm","imageMapIndex","parse","tree","materials","layers","tags","textures","currentLayer","parseTopForm","undefined","format","parser","endOfFile","[object Object]","type","console","warn","skipForm","parseTextureNodeAttribute","parseEnvelope","parseClip","parseImage","referenceTexture","parseImageStateForm","parseSurfaceForm","parseValueForm","parseSubNode","setupForm","parseConnections","parseEntryForm","parseImageMap","parseXVAL","parseXVAL3","parseUnknownForm","from","to","LoaderUtils","decodeText","Uint8Array","name","surface","connections","source","valueType","getUint64","getFloat64","getFloat64Array","mipMapLevel","maps","map","scale","position","rotation","falloff","amplitude","uTiles","vTiles","setOffset","texture","tag","n_length","endOffset","x","y","z","objectTags","tagString","layer","number","flags","pivot","parsedLength","parent","currentPoints","i","discontinuous","finalOffset","remainingLength","parseUVMapping","parseMorphTargets","uvIndices","polyIndices","uvs","discontinuousUVs","indices","points","morphTargets","polygonDimensions","numverts","j","geometryData","vertexIndices","geometry","getStringArray","parseMaterialIndices","materialIndices","polygonIndex","materialIndex","data","size","error","getUint8","a","littleEndian","firstByte","currentChar","len","split","filter","Boolean","enable","nodeType","repeat","splice","LWOLoader","manager","parameters","Loader","call","resourcePath","Object","assign","create","load","url","onLoad","onProgress","onError","self","path","dir","indexOf","substr","extractParentUrl","modelName","pop","loader","FileLoader","setPath","setResponseType","iffBuffer","TextureLoader","setCrossOrigin","crossOrigin","defaultLayerName","meshes","parseLayers","finalMeshes","geometryParser","forEach","mesh","parseMesh","add","applyPivots","getMaterials","userData","matNames","duplicateUVs","Points","LineSegments","Mesh","traverse","child","parentPivot","namesArray","getMaterialByName","mat","spec","color","PointsMaterial","LineBasicMaterial","filtered","m","Array","isArray","material","aoMap","setAttribute","BufferAttribute","uv","array","parseMaterial","parseMaterialLwo2","materialData","params","getSide","flatShading","getSmooth","parseTextureNodes","parseAttributeImageMaps","parseAttributes","parseEnvMap","getMaterialType","MeshPhongMaterial","BackSide","FrontSide","DoubleSide","materialConnections","matNode","getNodeByRefName","envMap","textureNodes","loadTexture","wrapS","getWrappingType","wrapT","roughnessMap","roughness","specularMap","specular","emissiveMap","emissive","metalnessMap","metalness","alphaMap","transparent","normalMap","normalScale","Vector2","bumpMap","attribute","mapData","getTexturePathByIndex","fromArray","Transparency","bumpScale","refractionRatio","parsePhysicalAttributes","parseStandardAttributes","parsePhongAttributes","Clearcoat","clearcoat","clearcoatRoughness","Luminous","emissiveIntensity","Roughness","Metallic","multiplyScalar","reflectivity","combine","AddOperation","setScalar","lerp","clone","shininess","Math","pow","mapping","EquirectangularRefractionMapping","EquirectangularReflectionMapping","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","nodeData","MeshPhysicalMaterial","MeshStandardMaterial","geoData","BufferGeometry","Float32BufferAttribute","splitIndices","setIndex","parseGroups","computeVertexNormals","parseUVs","translate","remappedIndices","dim","k","elemSize","prevMaterialIndex","splitMaterialIndices","indexNum","indexPairs","prevStart","currentCount","currentIndex","addGroup","groups","remappedUVs","count","remappedPoints","slice","morphAttributes","morphPoints","morphIndices","morphTargetsRelative"],"mappings":"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","file":"../../loaders/LWOLoader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @version 1.1.1\n\t *\n\t * @author Lewy Blue https://github.com/looeee\n\t * @author Guilherme Avila https://github/sciecode\n\t *\n\t * @desc Load files in LWO3 and LWO2 format on Three.js\n\t *\n\t * LWO3 format specification:\n\t * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo3.html\n\t *\n\t * LWO2 format specification:\n\t * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo2.html\n\t *\n\t * Development and test repository:\n\t *\thttps://github.com/threejs/lwoloader\n\t *\n\t **/\n\n\tfunction LWO2Parser( IFFParser ) {\n\n\t\tthis.IFF = IFFParser;\n\n\t}\n\n\tLWO2Parser.prototype = {\n\n\t\tconstructor: LWO2Parser,\n\n\t\tparseBlock: function () {\n\n\t\t\tthis.IFF.debugger.offset = this.IFF.reader.offset;\n\t\t\tthis.IFF.debugger.closeForms();\n\n\t\t\tvar blockID = this.IFF.reader.getIDTag();\n\t\t\tvar length = this.IFF.reader.getUint32(); // size of data in bytes\n\t\t\tif ( length > this.IFF.reader.dv.byteLength - this.IFF.reader.offset ) {\n\n\t\t\t\tthis.IFF.reader.offset -= 4;\n\t\t\t\tlength = this.IFF.reader.getUint16();\n\n\t\t\t}\n\n\t\t\tthis.IFF.debugger.dataOffset = this.IFF.reader.offset;\n\t\t\tthis.IFF.debugger.length = length;\n\n\t\t\t// Data types may be found in either LWO2 OR LWO3 spec\n\t\t\tswitch ( blockID ) {\n\n\t\t\t\tcase 'FORM': // form blocks may consist of sub -chunks or sub-forms\n\t\t\t\t\tthis.IFF.parseForm( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\t// SKIPPED CHUNKS\n\t\t\t\t// if break; is called directly, the position in the lwoTree is not created\n\t\t\t\t// any sub chunks and forms are added to the parent form instead\n\t\t\t\t// MISC skipped\n\t\t\t\tcase 'ICON': // Thumbnail Icon Image\n\t\t\t\tcase 'VMPA': // Vertex Map Parameter\n\t\t\t\tcase 'BBOX': // bounding box\n\t\t\t\t// case 'VMMD':\n\t\t\t\t// case 'VTYP':\n\n\t\t\t\t// normal maps can be specified, normally on models imported from other applications. Currently ignored\n\t\t\t\tcase 'NORM':\n\n\t\t\t\t// ENVL FORM skipped\n\t\t\t\tcase 'PRE ':\n\t\t\t\tcase 'POST':\n\t\t\t\tcase 'KEY ':\n\t\t\t\tcase 'SPAN':\n\n\t\t\t\t// CLIP FORM skipped\n\t\t\t\tcase 'TIME':\n\t\t\t\tcase 'CLRS':\n\t\t\t\tcase 'CLRA':\n\t\t\t\tcase 'FILT':\n\t\t\t\tcase 'DITH':\n\t\t\t\tcase 'CONT':\n\t\t\t\tcase 'BRIT':\n\t\t\t\tcase 'SATR':\n\t\t\t\tcase 'HUE ':\n\t\t\t\tcase 'GAMM':\n\t\t\t\tcase 'NEGA':\n\t\t\t\tcase 'IFLT':\n\t\t\t\tcase 'PFLT':\n\n\t\t\t\t// Image Map Layer skipped\n\t\t\t\tcase 'PROJ':\n\t\t\t\tcase 'AXIS':\n\t\t\t\tcase 'AAST':\n\t\t\t\tcase 'PIXB':\n\t\t\t\tcase 'AUVO':\n\t\t\t\tcase 'STCK':\n\n\t\t\t\t// Procedural Textures skipped\n\t\t\t\tcase 'PROC':\n\t\t\t\tcase 'VALU':\n\t\t\t\tcase 'FUNC':\n\n\t\t\t\t// Gradient Textures skipped\n\t\t\t\tcase 'PNAM':\n\t\t\t\tcase 'INAM':\n\t\t\t\tcase 'GRST':\n\t\t\t\tcase 'GREN':\n\t\t\t\tcase 'GRPT':\n\t\t\t\tcase 'FKEY':\n\t\t\t\tcase 'IKEY':\n\n\t\t\t\t// Texture Mapping Form skipped\n\t\t\t\tcase 'CSYS':\n\n\t\t\t\t// Surface CHUNKs skipped\n\t\t\t\tcase 'OPAQ': // top level 'opacity' checkbox\n\t\t\t\tcase 'CMAP': // clip map\n\n\t\t\t\t// Surface node CHUNKS skipped\n\t\t\t\t// These mainly specify the node editor setup in LW\n\t\t\t\tcase 'NLOC':\n\t\t\t\tcase 'NZOM':\n\t\t\t\tcase 'NVER':\n\t\t\t\tcase 'NSRV':\n\t\t\t\tcase 'NVSK': // unknown\n\t\t\t\tcase 'NCRD':\n\t\t\t\tcase 'WRPW': // image wrap w ( for cylindrical and spherical projections)\n\t\t\t\tcase 'WRPH': // image wrap h\n\t\t\t\tcase 'NMOD':\n\t\t\t\tcase 'NPRW':\n\t\t\t\tcase 'NPLA':\n\t\t\t\tcase 'NODS':\n\t\t\t\tcase 'VERS':\n\t\t\t\tcase 'ENUM':\n\t\t\t\tcase 'TAG ':\n\t\t\t\tcase 'OPAC':\n\n\t\t\t\t// Car Material CHUNKS\n\t\t\t\tcase 'CGMD':\n\t\t\t\tcase 'CGTY':\n\t\t\t\tcase 'CGST':\n\t\t\t\tcase 'CGEN':\n\t\t\t\tcase 'CGTS':\n\t\t\t\tcase 'CGTE':\n\t\t\t\tcase 'OSMP':\n\t\t\t\tcase 'OMDE':\n\t\t\t\tcase 'OUTR':\n\t\t\t\tcase 'FLAG':\n\n\t\t\t\tcase 'TRNL':\n\t\t\t\tcase 'GLOW':\n\t\t\t\tcase 'GVAL': // glow intensity\n\t\t\t\tcase 'SHRP':\n\t\t\t\tcase 'RFOP':\n\t\t\t\tcase 'RSAN':\n\t\t\t\tcase 'TROP':\n\t\t\t\tcase 'RBLR':\n\t\t\t\tcase 'TBLR':\n\t\t\t\tcase 'CLRH':\n\t\t\t\tcase 'CLRF':\n\t\t\t\tcase 'ADTR':\n\t\t\t\tcase 'LINE':\n\t\t\t\tcase 'ALPH':\n\t\t\t\tcase 'VCOL':\n\t\t\t\tcase 'ENAB':\n\t\t\t\t\tthis.IFF.debugger.skipped = true;\n\t\t\t\t\tthis.IFF.reader.skip( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SURF':\n\t\t\t\t\tthis.IFF.parseSurfaceLwo2( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'CLIP':\n\t\t\t\t\tthis.IFF.parseClipLwo2( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Texture node chunks (not in spec)\n\t\t\t\tcase 'IPIX': // usePixelBlending\n\t\t\t\tcase 'IMIP': // useMipMaps\n\t\t\t\tcase 'IMOD': // imageBlendingMode\n\t\t\t\tcase 'AMOD': // unknown\n\t\t\t\tcase 'IINV': // imageInvertAlpha\n\t\t\t\tcase 'INCR': // imageInvertColor\n\t\t\t\tcase 'IAXS': // imageAxis ( for non-UV maps)\n\t\t\t\tcase 'IFOT': // imageFallofType\n\t\t\t\tcase 'ITIM': // timing for animated textures\n\t\t\t\tcase 'IWRL':\n\t\t\t\tcase 'IUTI':\n\t\t\t\tcase 'IINX':\n\t\t\t\tcase 'IINY':\n\t\t\t\tcase 'IINZ':\n\t\t\t\tcase 'IREF': // possibly a VX for reused texture nodes\n\t\t\t\t\tif ( length === 4 ) this.IFF.currentNode[ blockID ] = this.IFF.reader.getInt32();\n\t\t\t\t\telse this.IFF.reader.skip( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OTAG':\n\t\t\t\t\tthis.IFF.parseObjectTag();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LAYR':\n\t\t\t\t\tthis.IFF.parseLayer( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PNTS':\n\t\t\t\t\tthis.IFF.parsePoints( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'VMAP':\n\t\t\t\t\tthis.IFF.parseVertexMapping( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AUVU':\n\t\t\t\tcase 'AUVN':\n\t\t\t\t\tthis.IFF.reader.skip( length - 1 );\n\t\t\t\t\tthis.IFF.reader.getVariableLengthIndex(); // VX\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'POLS':\n\t\t\t\t\tthis.IFF.parsePolygonList( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TAGS':\n\t\t\t\t\tthis.IFF.parseTagStrings( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PTAG':\n\t\t\t\t\tthis.IFF.parsePolygonTagMapping( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'VMAD':\n\t\t\t\t\tthis.IFF.parseVertexMapping( length, true );\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Misc CHUNKS\n\t\t\t\tcase 'DESC': // Description Line\n\t\t\t\t\tthis.IFF.currentForm.description = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TEXT':\n\t\t\t\tcase 'CMNT':\n\t\t\t\tcase 'NCOM':\n\t\t\t\t\tthis.IFF.currentForm.comment = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Envelope Form\n\t\t\t\tcase 'NAME':\n\t\t\t\t\tthis.IFF.currentForm.channelName = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Image Map Layer\n\t\t\t\tcase 'WRAP':\n\t\t\t\t\tthis.IFF.currentForm.wrap = { w: this.IFF.reader.getUint16(), h: this.IFF.reader.getUint16() };\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IMAG':\n\t\t\t\t\tvar index = this.IFF.reader.getVariableLengthIndex();\n\t\t\t\t\tthis.IFF.currentForm.imageIndex = index;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Texture Mapping Form\n\t\t\t\tcase 'OREF':\n\t\t\t\t\tthis.IFF.currentForm.referenceObject = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ROID':\n\t\t\t\t\tthis.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Surface Blocks\n\t\t\t\tcase 'SSHN':\n\t\t\t\t\tthis.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AOVN':\n\t\t\t\t\tthis.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Nodal Blocks\n\t\t\t\tcase 'NSTA':\n\t\t\t\t\tthis.IFF.currentForm.disabled = this.IFF.reader.getUint16();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NRNM':\n\t\t\t\t\tthis.IFF.currentForm.realName = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NNME':\n\t\t\t\t\tthis.IFF.currentForm.refName = this.IFF.reader.getString();\n\t\t\t\t\tthis.IFF.currentSurface.nodes[ this.IFF.currentForm.refName ] = this.IFF.currentForm;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Nodal Blocks : connections\n\t\t\t\tcase 'INME':\n\t\t\t\t\tif ( ! this.IFF.currentForm.nodeName ) this.IFF.currentForm.nodeName = [];\n\t\t\t\t\tthis.IFF.currentForm.nodeName.push( this.IFF.reader.getString() );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IINN':\n\t\t\t\t\tif ( ! this.IFF.currentForm.inputNodeName ) this.IFF.currentForm.inputNodeName = [];\n\t\t\t\t\tthis.IFF.currentForm.inputNodeName.push( this.IFF.reader.getString() );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IINM':\n\t\t\t\t\tif ( ! this.IFF.currentForm.inputName ) this.IFF.currentForm.inputName = [];\n\t\t\t\t\tthis.IFF.currentForm.inputName.push( this.IFF.reader.getString() );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IONM':\n\t\t\t\t\tif ( ! this.IFF.currentForm.inputOutputName ) this.IFF.currentForm.inputOutputName = [];\n\t\t\t\t\tthis.IFF.currentForm.inputOutputName.push( this.IFF.reader.getString() );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'FNAM':\n\t\t\t\t\tthis.IFF.currentForm.fileName = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'CHAN': // NOTE: ENVL Forms may also have CHAN chunk, however ENVL is currently ignored\n\t\t\t\t\tif ( length === 4 ) this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();\n\t\t\t\t\telse this.IFF.reader.skip( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\t// LWO2 Spec chunks: these are needed since the SURF FORMs are often in LWO2 format\n\t\t\t\tcase 'SMAN':\n\t\t\t\t\tvar maxSmoothingAngle = this.IFF.reader.getFloat32();\n\t\t\t\t\tthis.IFF.currentSurface.attributes.smooth = ( maxSmoothingAngle < 0 ) ? false : true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// LWO2: Basic Surface Parameters\n\t\t\t\tcase 'COLR':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.Color = { value: this.IFF.reader.getFloat32Array( 3 ) };\n\t\t\t\t\tthis.IFF.reader.skip( 2 ); // VX: envelope\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LUMI':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.Luminosity = { value: this.IFF.reader.getFloat32() };\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SPEC':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.Specular = { value: this.IFF.reader.getFloat32() };\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DIFF':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.Diffuse = { value: this.IFF.reader.getFloat32() };\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'REFL':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.Reflection = { value: this.IFF.reader.getFloat32() };\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'GLOS':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.Glossiness = { value: this.IFF.reader.getFloat32() };\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TRAN':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'BUMP':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SIDE':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RIMG':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RIND':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TIMG':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IMAP':\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TMAP':\n\t\t\t\t\tthis.IFF.debugger.skipped = true;\n\t\t\t\t\tthis.IFF.reader.skip( length ); // needs implementing\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IUVI': // uv channel name\n\t\t\t\t\tthis.IFF.currentNode.UVChannel = this.IFF.reader.getString( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IUTL': // widthWrappingMode: 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n\t\t\t\t\tthis.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'IVTL': // heightWrappingMode\n\t\t\t\t\tthis.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();\n\t\t\t\t\tbreak;\n\n\t\t\t\t// LWO2 USE\n\t\t\t\tcase 'BLOK':\n\t\t\t\t\t// skip\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis.IFF.parseUnknownCHUNK( blockID, length );\n\n\t\t\t}\n\n\t\t\tif ( blockID != 'FORM' ) {\n\n\t\t\t\tthis.IFF.debugger.node = 1;\n\t\t\t\tthis.IFF.debugger.nodeID = blockID;\n\t\t\t\tthis.IFF.debugger.log();\n\n\t\t\t}\n\n\t\t\tif ( this.IFF.reader.offset >= this.IFF.currentFormEnd ) {\n\n\t\t\t\tthis.IFF.currentForm = this.IFF.parentForm;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction LWO3Parser( IFFParser ) {\n\n\t\tthis.IFF = IFFParser;\n\n\t}\n\n\tLWO3Parser.prototype = {\n\n\t\tconstructor: LWO3Parser,\n\n\t\tparseBlock: function () {\n\n\t\t\tthis.IFF.debugger.offset = this.IFF.reader.offset;\n\t\t\tthis.IFF.debugger.closeForms();\n\n\t\t\tvar blockID = this.IFF.reader.getIDTag();\n\t\t\tvar length = this.IFF.reader.getUint32(); // size of data in bytes\n\n\t\t\tthis.IFF.debugger.dataOffset = this.IFF.reader.offset;\n\t\t\tthis.IFF.debugger.length = length;\n\n\t\t\t// Data types may be found in either LWO2 OR LWO3 spec\n\t\t\tswitch ( blockID ) {\n\n\t\t\t\tcase 'FORM': // form blocks may consist of sub -chunks or sub-forms\n\t\t\t\t\tthis.IFF.parseForm( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\t// SKIPPED CHUNKS\n\t\t\t\t// MISC skipped\n\t\t\t\tcase 'ICON': // Thumbnail Icon Image\n\t\t\t\tcase 'VMPA': // Vertex Map Parameter\n\t\t\t\tcase 'BBOX': // bounding box\n\t\t\t\t// case 'VMMD':\n\t\t\t\t// case 'VTYP':\n\n\t\t\t\t// normal maps can be specified, normally on models imported from other applications. Currently ignored\n\t\t\t\tcase 'NORM':\n\n\t\t\t\t// ENVL FORM skipped\n\t\t\t\tcase 'PRE ':\n\t\t\t\tcase 'POST':\n\t\t\t\tcase 'KEY ':\n\t\t\t\tcase 'SPAN':\n\n\t\t\t\t// CLIP FORM skipped\n\t\t\t\tcase 'TIME':\n\t\t\t\tcase 'CLRS':\n\t\t\t\tcase 'CLRA':\n\t\t\t\tcase 'FILT':\n\t\t\t\tcase 'DITH':\n\t\t\t\tcase 'CONT':\n\t\t\t\tcase 'BRIT':\n\t\t\t\tcase 'SATR':\n\t\t\t\tcase 'HUE ':\n\t\t\t\tcase 'GAMM':\n\t\t\t\tcase 'NEGA':\n\t\t\t\tcase 'IFLT':\n\t\t\t\tcase 'PFLT':\n\n\t\t\t\t// Image Map Layer skipped\n\t\t\t\tcase 'PROJ':\n\t\t\t\tcase 'AXIS':\n\t\t\t\tcase 'AAST':\n\t\t\t\tcase 'PIXB':\n\t\t\t\tcase 'STCK':\n\n\t\t\t\t// Procedural Textures skipped\n\t\t\t\tcase 'VALU':\n\n\t\t\t\t// Gradient Textures skipped\n\t\t\t\tcase 'PNAM':\n\t\t\t\tcase 'INAM':\n\t\t\t\tcase 'GRST':\n\t\t\t\tcase 'GREN':\n\t\t\t\tcase 'GRPT':\n\t\t\t\tcase 'FKEY':\n\t\t\t\tcase 'IKEY':\n\n\t\t\t\t// Texture Mapping Form skipped\n\t\t\t\tcase 'CSYS':\n\n\t\t\t\t\t// Surface CHUNKs skipped\n\t\t\t\tcase 'OPAQ': // top level 'opacity' checkbox\n\t\t\t\tcase 'CMAP': // clip map\n\n\t\t\t\t// Surface node CHUNKS skipped\n\t\t\t\t// These mainly specify the node editor setup in LW\n\t\t\t\tcase 'NLOC':\n\t\t\t\tcase 'NZOM':\n\t\t\t\tcase 'NVER':\n\t\t\t\tcase 'NSRV':\n\t\t\t\tcase 'NCRD':\n\t\t\t\tcase 'NMOD':\n\t\t\t\tcase 'NSEL':\n\t\t\t\tcase 'NPRW':\n\t\t\t\tcase 'NPLA':\n\t\t\t\tcase 'VERS':\n\t\t\t\tcase 'ENUM':\n\t\t\t\tcase 'TAG ':\n\n\t\t\t\t// Car Material CHUNKS\n\t\t\t\tcase 'CGMD':\n\t\t\t\tcase 'CGTY':\n\t\t\t\tcase 'CGST':\n\t\t\t\tcase 'CGEN':\n\t\t\t\tcase 'CGTS':\n\t\t\t\tcase 'CGTE':\n\t\t\t\tcase 'OSMP':\n\t\t\t\tcase 'OMDE':\n\t\t\t\tcase 'OUTR':\n\t\t\t\tcase 'FLAG':\n\n\t\t\t\tcase 'TRNL':\n\t\t\t\tcase 'SHRP':\n\t\t\t\tcase 'RFOP':\n\t\t\t\tcase 'RSAN':\n\t\t\t\tcase 'TROP':\n\t\t\t\tcase 'RBLR':\n\t\t\t\tcase 'TBLR':\n\t\t\t\tcase 'CLRH':\n\t\t\t\tcase 'CLRF':\n\t\t\t\tcase 'ADTR':\n\t\t\t\tcase 'GLOW':\n\t\t\t\tcase 'LINE':\n\t\t\t\tcase 'ALPH':\n\t\t\t\tcase 'VCOL':\n\t\t\t\tcase 'ENAB':\n\t\t\t\t\tthis.IFF.debugger.skipped = true;\n\t\t\t\t\tthis.IFF.reader.skip( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Texture node chunks (not in spec)\n\t\t\t\tcase 'IPIX': // usePixelBlending\n\t\t\t\tcase 'IMIP': // useMipMaps\n\t\t\t\tcase 'IMOD': // imageBlendingMode\n\t\t\t\tcase 'AMOD': // unknown\n\t\t\t\tcase 'IINV': // imageInvertAlpha\n\t\t\t\tcase 'INCR': // imageInvertColor\n\t\t\t\tcase 'IAXS': // imageAxis ( for non-UV maps)\n\t\t\t\tcase 'IFOT': // imageFallofType\n\t\t\t\tcase 'ITIM': // timing for animated textures\n\t\t\t\tcase 'IWRL':\n\t\t\t\tcase 'IUTI':\n\t\t\t\tcase 'IINX':\n\t\t\t\tcase 'IINY':\n\t\t\t\tcase 'IINZ':\n\t\t\t\tcase 'IREF': // possibly a VX for reused texture nodes\n\t\t\t\t\tif ( length === 4 ) this.IFF.currentNode[ blockID ] = this.IFF.reader.getInt32();\n\t\t\t\t\telse this.IFF.reader.skip( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OTAG':\n\t\t\t\t\tthis.IFF.parseObjectTag();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LAYR':\n\t\t\t\t\tthis.IFF.parseLayer( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PNTS':\n\t\t\t\t\tthis.IFF.parsePoints( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'VMAP':\n\t\t\t\t\tthis.IFF.parseVertexMapping( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'POLS':\n\t\t\t\t\tthis.IFF.parsePolygonList( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TAGS':\n\t\t\t\t\tthis.IFF.parseTagStrings( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PTAG':\n\t\t\t\t\tthis.IFF.parsePolygonTagMapping( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'VMAD':\n\t\t\t\t\tthis.IFF.parseVertexMapping( length, true );\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Misc CHUNKS\n\t\t\t\tcase 'DESC': // Description Line\n\t\t\t\t\tthis.IFF.currentForm.description = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TEXT':\n\t\t\t\tcase 'CMNT':\n\t\t\t\tcase 'NCOM':\n\t\t\t\t\tthis.IFF.currentForm.comment = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Envelope Form\n\t\t\t\tcase 'NAME':\n\t\t\t\t\tthis.IFF.currentForm.channelName = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Image Map Layer\n\t\t\t\tcase 'WRAP':\n\t\t\t\t\tthis.IFF.currentForm.wrap = { w: this.IFF.reader.getUint16(), h: this.IFF.reader.getUint16() };\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IMAG':\n\t\t\t\t\tvar index = this.IFF.reader.getVariableLengthIndex();\n\t\t\t\t\tthis.IFF.currentForm.imageIndex = index;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Texture Mapping Form\n\t\t\t\tcase 'OREF':\n\t\t\t\t\tthis.IFF.currentForm.referenceObject = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ROID':\n\t\t\t\t\tthis.IFF.currentForm.referenceObjectID = this.IFF.reader.getUint32();\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Surface Blocks\n\t\t\t\tcase 'SSHN':\n\t\t\t\t\tthis.IFF.currentSurface.surfaceShaderName = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AOVN':\n\t\t\t\t\tthis.IFF.currentSurface.surfaceCustomAOVName = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Nodal Blocks\n\t\t\t\tcase 'NSTA':\n\t\t\t\t\tthis.IFF.currentForm.disabled = this.IFF.reader.getUint16();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NRNM':\n\t\t\t\t\tthis.IFF.currentForm.realName = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NNME':\n\t\t\t\t\tthis.IFF.currentForm.refName = this.IFF.reader.getString();\n\t\t\t\t\tthis.IFF.currentSurface.nodes[ this.IFF.currentForm.refName ] = this.IFF.currentForm;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Nodal Blocks : connections\n\t\t\t\tcase 'INME':\n\t\t\t\t\tif ( ! this.IFF.currentForm.nodeName ) this.IFF.currentForm.nodeName = [];\n\t\t\t\t\tthis.IFF.currentForm.nodeName.push( this.IFF.reader.getString() );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IINN':\n\t\t\t\t\tif ( ! this.IFF.currentForm.inputNodeName ) this.IFF.currentForm.inputNodeName = [];\n\t\t\t\t\tthis.IFF.currentForm.inputNodeName.push( this.IFF.reader.getString() );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IINM':\n\t\t\t\t\tif ( ! this.IFF.currentForm.inputName ) this.IFF.currentForm.inputName = [];\n\t\t\t\t\tthis.IFF.currentForm.inputName.push( this.IFF.reader.getString() );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IONM':\n\t\t\t\t\tif ( ! this.IFF.currentForm.inputOutputName ) this.IFF.currentForm.inputOutputName = [];\n\t\t\t\t\tthis.IFF.currentForm.inputOutputName.push( this.IFF.reader.getString() );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'FNAM':\n\t\t\t\t\tthis.IFF.currentForm.fileName = this.IFF.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'CHAN': // NOTE: ENVL Forms may also have CHAN chunk, however ENVL is currently ignored\n\t\t\t\t\tif ( length === 4 ) this.IFF.currentForm.textureChannel = this.IFF.reader.getIDTag();\n\t\t\t\t\telse this.IFF.reader.skip( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\t// LWO2 Spec chunks: these are needed since the SURF FORMs are often in LWO2 format\n\t\t\t\tcase 'SMAN':\n\t\t\t\t\tvar maxSmoothingAngle = this.IFF.reader.getFloat32();\n\t\t\t\t\tthis.IFF.currentSurface.attributes.smooth = ( maxSmoothingAngle < 0 ) ? false : true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// LWO2: Basic Surface Parameters\n\t\t\t\tcase 'COLR':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.Color = { value: this.IFF.reader.getFloat32Array( 3 ) };\n\t\t\t\t\tthis.IFF.reader.skip( 2 ); // VX: envelope\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LUMI':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.Luminosity = { value: this.IFF.reader.getFloat32() };\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SPEC':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.Specular = { value: this.IFF.reader.getFloat32() };\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DIFF':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.Diffuse = { value: this.IFF.reader.getFloat32() };\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'REFL':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.Reflection = { value: this.IFF.reader.getFloat32() };\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'GLOS':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.Glossiness = { value: this.IFF.reader.getFloat32() };\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TRAN':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.opacity = this.IFF.reader.getFloat32();\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'BUMP':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.bumpStrength = this.IFF.reader.getFloat32();\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SIDE':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.side = this.IFF.reader.getUint16();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RIMG':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.reflectionMap = this.IFF.reader.getVariableLengthIndex();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RIND':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.refractiveIndex = this.IFF.reader.getFloat32();\n\t\t\t\t\tthis.IFF.reader.skip( 2 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TIMG':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.refractionMap = this.IFF.reader.getVariableLengthIndex();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IMAP':\n\t\t\t\t\tthis.IFF.currentSurface.attributes.imageMapIndex = this.IFF.reader.getUint32();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IUVI': // uv channel name\n\t\t\t\t\tthis.IFF.currentNode.UVChannel = this.IFF.reader.getString( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IUTL': // widthWrappingMode: 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n\t\t\t\t\tthis.IFF.currentNode.widthWrappingMode = this.IFF.reader.getUint32();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'IVTL': // heightWrappingMode\n\t\t\t\t\tthis.IFF.currentNode.heightWrappingMode = this.IFF.reader.getUint32();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis.IFF.parseUnknownCHUNK( blockID, length );\n\n\t\t\t}\n\n\t\t\tif ( blockID != 'FORM' ) {\n\n\t\t\t\tthis.IFF.debugger.node = 1;\n\t\t\t\tthis.IFF.debugger.nodeID = blockID;\n\t\t\t\tthis.IFF.debugger.log();\n\n\t\t\t}\n\n\t\t\tif ( this.IFF.reader.offset >= this.IFF.currentFormEnd ) {\n\n\t\t\t\tthis.IFF.currentForm = this.IFF.parentForm;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\n\t/**\n\t * === IFFParser ===\n\t * - Parses data from the IFF buffer.\n\t * - LWO3 files are in IFF format and can contain the following data types, referred to by shorthand codes\n\t *\n\t * ATOMIC DATA TYPES\n\t *  ID Tag - 4x 7 bit uppercase ASCII chars: ID4\n\t *  signed integer, 1, 2, or 4 byte length: I1, I2, I4\n\t *  unsigned integer, 1, 2, or 4 byte length: U1, U2, U4\n\t *  float, 4 byte length: F4\n\t *  string, series of ASCII chars followed by null byte (If the length of the string including the null terminating byte is odd, an extra null is added so that the data that follows will begin on an even byte boundary): S0\n\t *\n\t * COMPOUND DATA TYPES\n\t *  Variable-length Index (index into an array or collection): U2 or U4 : VX\n\t *  Color (RGB): F4 + F4 + F4: COL12\n\t *  Coordinate (x, y, z): F4 + F4 + F4: VEC12\n\t *  Percentage F4 data type from 0->1 with 1 = 100%: FP4\n\t *  Angle in radian F4: ANG4\n\t *  Filename (string) S0: FNAM0\n\t *  XValue F4 + index (VX) + optional envelope( ENVL ): XVAL\n\t *  XValue vector VEC12 + index (VX) + optional envelope( ENVL ): XVAL3\n\t *\n\t *  The IFF file is arranged in chunks:\n\t *  CHUNK = ID4 + length (U4) + length X bytes of data + optional 0 pad byte\n\t *  optional 0 pad byte is there to ensure chunk ends on even boundary, not counted in size\n\t *\n\t * COMPOUND DATA TYPES\n\t * - Chunks are combined in Forms (collections of chunks)\n\t * - FORM = string 'FORM' (ID4) + length (U4) + type (ID4) + optional ( CHUNK | FORM )\n\t * - CHUNKS and FORMS are collectively referred to as blocks\n\t * - The entire file is contained in one top level FORM\n\t *\n\t **/\n\n\tfunction IFFParser( ) {\n\n\t\tthis.debugger = new Debugger();\n\t\t// this.debugger.enable(); // un-comment to log IFF hierarchy.\n\n\t}\n\n\tIFFParser.prototype = {\n\n\t\tconstructor: IFFParser,\n\n\t\tparse: function ( buffer ) {\n\n\t\t\tthis.reader = new DataViewReader( buffer );\n\n\t\t\tthis.tree = {\n\t\t\t\tmaterials: {},\n\t\t\t\tlayers: [],\n\t\t\t\ttags: [],\n\t\t\t\ttextures: [],\n\t\t\t};\n\n\t\t\t// start out at the top level to add any data before first layer is encountered\n\t\t\tthis.currentLayer = this.tree;\n\t\t\tthis.currentForm = this.tree;\n\n\t\t\tthis.parseTopForm();\n\n\t\t\tif ( this.tree.format === undefined ) return;\n\n\t\t\tif ( this.tree.format === 'LWO2' ) {\n\n\t\t\t\tthis.parser = new LWO2Parser( this );\n\t\t\t\twhile ( ! this.reader.endOfFile() ) this.parser.parseBlock();\n\n\t\t\t} else if ( this.tree.format === 'LWO3' ) {\n\n\t\t\t\tthis.parser = new LWO3Parser( this );\n\t\t\t\twhile ( ! this.reader.endOfFile() ) this.parser.parseBlock();\n\n\t\t\t}\n\n\t\t\tthis.debugger.offset = this.reader.offset;\n\t\t\tthis.debugger.closeForms();\n\n\t\t\treturn this.tree;\n\n\t\t},\n\n\t\tparseTopForm() {\n\n\t\t\tthis.debugger.offset = this.reader.offset;\n\n\t\t\tvar topForm = this.reader.getIDTag();\n\n\t\t\tif ( topForm !== 'FORM' ) {\n\n\t\t\t\tconsole.warn( \"LWOLoader: Top-level FORM missing.\" );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar length = this.reader.getUint32();\n\n\t\t\tthis.debugger.dataOffset = this.reader.offset;\n\t\t\tthis.debugger.length = length;\n\n\t\t\tvar type = this.reader.getIDTag();\n\n\t\t\tif ( type === 'LWO2' ) {\n\n\t\t\t\tthis.tree.format = type;\n\n\t\t\t} else if ( type === 'LWO3' ) {\n\n\t\t\t\tthis.tree.format = type;\n\n\t\t\t}\n\n\t\t\tthis.debugger.node = 0;\n\t\t\tthis.debugger.nodeID = type;\n\t\t\tthis.debugger.log();\n\n\t\t\treturn;\n\n\t\t},\n\n\n\t\t///\n\t\t// FORM PARSING METHODS\n\t\t///\n\n\t\t// Forms are organisational and can contain any number of sub chunks and sub forms\n\t\t// FORM ::= 'FORM'[ID4], length[U4], type[ID4], ( chunk[CHUNK] | form[FORM] ) * }\n\t\tparseForm( length ) {\n\n\t\t\tvar type = this.reader.getIDTag();\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\t// SKIPPED FORMS\n\t\t\t\t// if skipForm( length ) is called, the entire form and any sub forms and chunks are skipped\n\n\t\t\t\tcase 'ISEQ': // Image sequence\n\t\t\t\tcase 'ANIM': // plug in animation\n\t\t\t\tcase 'STCC': // Color-cycling Still\n\t\t\t\tcase 'VPVL':\n\t\t\t\tcase 'VPRM':\n\t\t\t\tcase 'NROT':\n\t\t\t\tcase 'WRPW': // image wrap w ( for cylindrical and spherical projections)\n\t\t\t\tcase 'WRPH': // image wrap h\n\t\t\t\tcase 'FUNC':\n\t\t\t\tcase 'FALL':\n\t\t\t\tcase 'OPAC':\n\t\t\t\tcase 'GRAD': // gradient texture\n\t\t\t\tcase 'ENVS':\n\t\t\t\tcase 'VMOP':\n\t\t\t\tcase 'VMBG':\n\n\t\t\t\t// Car Material FORMS\n\t\t\t\tcase 'OMAX':\n\t\t\t\tcase 'STEX':\n\t\t\t\tcase 'CKBG':\n\t\t\t\tcase 'CKEY':\n\t\t\t\tcase 'VMLA':\n\t\t\t\tcase 'VMLB':\n\t\t\t\t\tthis.debugger.skipped = true;\n\t\t\t\t\tthis.skipForm( length ); // not currently supported\n\t\t\t\t\tbreak;\n\n\t\t\t\t// if break; is called directly, the position in the lwoTree is not created\n\t\t\t\t// any sub chunks and forms are added to the parent form instead\n\t\t\t\tcase 'META':\n\t\t\t\tcase 'NNDS':\n\t\t\t\tcase 'NODS':\n\t\t\t\tcase 'NDTA':\n\t\t\t\tcase 'ADAT':\n\t\t\t\tcase 'AOVS':\n\t\t\t\tcase 'BLOK':\n\n\t\t\t\t// used by texture nodes\n\t\t\t\tcase 'IBGC': // imageBackgroundColor\n\t\t\t\tcase 'IOPC': // imageOpacity\n\t\t\t\tcase 'IIMG': // hold reference to image path\n\t\t\t\tcase 'TXTR':\n\t\t\t\t\t// this.setupForm( type, length );\n\t\t\t\t\tthis.debugger.length = 4;\n\t\t\t\t\tthis.debugger.skipped = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IFAL': // imageFallof\n\t\t\t\tcase 'ISCL': // imageScale\n\t\t\t\tcase 'IPOS': // imagePosition\n\t\t\t\tcase 'IROT': // imageRotation\n\t\t\t\tcase 'IBMP':\n\t\t\t\tcase 'IUTD':\n\t\t\t\tcase 'IVTD':\n\t\t\t\t\tthis.parseTextureNodeAttribute( type );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ENVL':\n\t\t\t\t\tthis.parseEnvelope( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// CLIP FORM AND SUB FORMS\n\n\t\t\t\tcase 'CLIP':\n\t\t\t\t\tif ( this.tree.format === 'LWO2' ) {\n\n\t\t\t\t\t\tthis.parseForm( length );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.parseClip( length );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'STIL':\n\t\t\t\t\tthis.parseImage();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'XREF': // clone of another STIL\n\t\t\t\t\tthis.reader.skip( 8 ); // unknown\n\t\t\t\t\tthis.currentForm.referenceTexture = {\n\t\t\t\t\t\tindex: this.reader.getUint32(),\n\t\t\t\t\t\trefName: this.reader.getString() // internal unique ref\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Not in spec, used by texture nodes\n\n\t\t\t\tcase 'IMST':\n\t\t\t\t\tthis.parseImageStateForm( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// SURF FORM AND SUB FORMS\n\n\t\t\t\tcase 'SURF':\n\t\t\t\t\tthis.parseSurfaceForm( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'VALU': // Not in spec\n\t\t\t\t\tthis.parseValueForm( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NTAG':\n\t\t\t\t\tthis.parseSubNode( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ATTR': // BSDF Node Attributes\n\t\t\t\tcase 'SATR': // Standard Node Attributes\n\t\t\t\t\tthis.setupForm( 'attributes', length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NCON':\n\t\t\t\t\tthis.parseConnections( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SSHA':\n\t\t\t\t\tthis.parentForm = this.currentForm;\n\t\t\t\t\tthis.currentForm = this.currentSurface;\n\t\t\t\t\tthis.setupForm( 'surfaceShader', length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SSHD':\n\t\t\t\t\tthis.setupForm( 'surfaceShaderData', length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ENTR': // Not in spec\n\t\t\t\t\tthis.parseEntryForm( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Image Map Layer\n\n\t\t\t\tcase 'IMAP':\n\t\t\t\t\tthis.parseImageMap( length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TAMP':\n\t\t\t\t\tthis.parseXVAL( 'amplitude', length );\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t//Texture Mapping Form\n\n\t\t\t\tcase 'TMAP':\n\t\t\t\t\tthis.setupForm( 'textureMap', length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'CNTR':\n\t\t\t\t\tthis.parseXVAL3( 'center', length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SIZE':\n\t\t\t\t\tthis.parseXVAL3( 'scale', length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ROTA':\n\t\t\t\t\tthis.parseXVAL3( 'rotation', length );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthis.parseUnknownForm( type, length );\n\n\t\t\t}\n\n\t\t\tthis.debugger.node = 0;\n\t\t\tthis.debugger.nodeID = type;\n\t\t\tthis.debugger.log();\n\n\t\t},\n\n\t\tsetupForm( type, length ) {\n\n\t\t\tif ( ! this.currentForm ) this.currentForm = this.currentNode;\n\n\t\t\tthis.currentFormEnd = this.reader.offset + length;\n\t\t\tthis.parentForm = this.currentForm;\n\n\t\t\tif ( ! this.currentForm[ type ] ) {\n\n\t\t\t\tthis.currentForm[ type ] = {};\n\t\t\t\tthis.currentForm = this.currentForm[ type ];\n\n\n\t\t\t} else {\n\n\t\t\t\t// should never see this unless there's a bug in the reader\n\t\t\t\tconsole.warn( 'LWOLoader: form already exists on parent: ', type, this.currentForm );\n\n\t\t\t\tthis.currentForm = this.currentForm[ type ];\n\n\t\t\t}\n\n\n\t\t},\n\n\t\tskipForm( length ) {\n\n\t\t\tthis.reader.skip( length - 4 );\n\n\t\t},\n\n\t\tparseUnknownForm( type, length ) {\n\n\t\t\tconsole.warn( 'LWOLoader: unknown FORM encountered: ' + type, length );\n\n\t\t\tprintBuffer( this.reader.dv.buffer, this.reader.offset, length - 4 );\n\t\t\tthis.reader.skip( length - 4 );\n\n\t\t},\n\n\t\tparseSurfaceForm( length ) {\n\n\t\t\tthis.reader.skip( 8 ); // unknown Uint32 x2\n\n\t\t\tvar name = this.reader.getString();\n\n\t\t\tvar surface = {\n\t\t\t\tattributes: {}, // LWO2 style non-node attributes will go here\n\t\t\t\tconnections: {},\n\t\t\t\tname: name,\n\t\t\t\tinputName: name,\n\t\t\t\tnodes: {},\n\t\t\t\tsource: this.reader.getString(),\n\t\t\t};\n\n\t\t\tthis.tree.materials[ name ] = surface;\n\t\t\tthis.currentSurface = surface;\n\n\t\t\tthis.parentForm = this.tree.materials;\n\t\t\tthis.currentForm = surface;\n\t\t\tthis.currentFormEnd = this.reader.offset + length;\n\n\t\t},\n\n\t\tparseSurfaceLwo2( length ) {\n\n\t\t\tvar name = this.reader.getString();\n\n\t\t\tvar surface = {\n\t\t\t\tattributes: {}, // LWO2 style non-node attributes will go here\n\t\t\t\tconnections: {},\n\t\t\t\tname: name,\n\t\t\t\tnodes: {},\n\t\t\t\tsource: this.reader.getString(),\n\t\t\t};\n\n\t\t\tthis.tree.materials[ name ] = surface;\n\t\t\tthis.currentSurface = surface;\n\n\t\t\tthis.parentForm = this.tree.materials;\n\t\t\tthis.currentForm = surface;\n\t\t\tthis.currentFormEnd = this.reader.offset + length;\n\n\t\t},\n\n\t\tparseSubNode( length ) {\n\n\t\t\t// parse the NRNM CHUNK of the subnode FORM to get\n\t\t\t// a meaningful name for the subNode\n\t\t\t// some subnodes can be renamed, but Input and Surface cannot\n\n\t\t\tthis.reader.skip( 8 ); // NRNM + length\n\t\t\tvar name = this.reader.getString();\n\n\t\t\tvar node = {\n\t\t\t\tname: name\n\t\t\t};\n\t\t\tthis.currentForm = node;\n\t\t\tthis.currentNode = node;\n\n\t\t\tthis.currentFormEnd = this.reader.offset + length;\n\n\n\t\t},\n\n\t\t// collect attributes from all nodes at the top level of a surface\n\t\tparseConnections( length ) {\n\n\t\t\tthis.currentFormEnd = this.reader.offset + length;\n\t\t\tthis.parentForm = this.currentForm;\n\n\t\t\tthis.currentForm = this.currentSurface.connections;\n\n\t\t},\n\n\t\t// surface node attribute data, e.g. specular, roughness etc\n\t\tparseEntryForm( length ) {\n\n\t\t\tthis.reader.skip( 8 ); // NAME + length\n\t\t\tvar name = this.reader.getString();\n\t\t\tthis.currentForm = this.currentNode.attributes;\n\n\t\t\tthis.setupForm( name, length );\n\n\t\t},\n\n\t\t// parse values from material - doesn't match up to other LWO3 data types\n\t\t// sub form of entry form\n\t\tparseValueForm() {\n\n\t\t\tthis.reader.skip( 8 ); // unknown + length\n\n\t\t\tvar valueType = this.reader.getString();\n\n\t\t\tif ( valueType === 'double' ) {\n\n\t\t\t\tthis.currentForm.value = this.reader.getUint64();\n\n\t\t\t} else if ( valueType === 'int' ) {\n\n\t\t\t\tthis.currentForm.value = this.reader.getUint32();\n\n\t\t\t} else if ( valueType === 'vparam' ) {\n\n\t\t\t\tthis.reader.skip( 24 );\n\t\t\t\tthis.currentForm.value = this.reader.getFloat64();\n\n\t\t\t} else if ( valueType === 'vparam3' ) {\n\n\t\t\t\tthis.reader.skip( 24 );\n\t\t\t\tthis.currentForm.value = this.reader.getFloat64Array( 3 );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// holds various data about texture node image state\n\t\t// Data other thanmipMapLevel unknown\n\t\tparseImageStateForm() {\n\n\t\t\tthis.reader.skip( 8 ); // unknown\n\n\t\t\tthis.currentForm.mipMapLevel = this.reader.getFloat32();\n\n\t\t},\n\n\t\t// LWO2 style image data node OR LWO3 textures defined at top level in editor (not as SURF node)\n\t\tparseImageMap( length ) {\n\n\t\t\tthis.currentFormEnd = this.reader.offset + length;\n\t\t\tthis.parentForm = this.currentForm;\n\n\t\t\tif ( ! this.currentForm.maps ) this.currentForm.maps = [];\n\n\t\t\tvar map = {};\n\t\t\tthis.currentForm.maps.push( map );\n\t\t\tthis.currentForm = map;\n\n\t\t\tthis.reader.skip( 10 ); // unknown, could be an issue if it contains a VX\n\n\t\t},\n\n\t\tparseTextureNodeAttribute( type ) {\n\n\t\t\tthis.reader.skip( 28 ); // FORM + length + VPRM + unknown + Uint32 x2 + float32\n\n\t\t\tthis.reader.skip( 20 ); // FORM + length + VPVL + float32 + Uint32\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'ISCL':\n\t\t\t\t\tthis.currentNode.scale = this.reader.getFloat32Array( 3 );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'IPOS':\n\t\t\t\t\tthis.currentNode.position = this.reader.getFloat32Array( 3 );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'IROT':\n\t\t\t\t\tthis.currentNode.rotation = this.reader.getFloat32Array( 3 );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'IFAL':\n\t\t\t\t\tthis.currentNode.falloff = this.reader.getFloat32Array( 3 );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IBMP':\n\t\t\t\t\tthis.currentNode.amplitude = this.reader.getFloat32();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'IUTD':\n\t\t\t\t\tthis.currentNode.uTiles = this.reader.getFloat32();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'IVTD':\n\t\t\t\t\tthis.currentNode.vTiles = this.reader.getFloat32();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.reader.skip( 2 ); // unknown\n\n\n\t\t},\n\n\t\t// ENVL forms are currently ignored\n\t\tparseEnvelope( length ) {\n\n\t\t\tthis.reader.skip( length - 4 ); // skipping  entirely for now\n\n\t\t},\n\n\t\t///\n\t\t// CHUNK PARSING METHODS\n\t\t///\n\n\t\t// clips can either be defined inside a surface node, or at the top\n\t\t// level and they have a different format in each case\n\t\tparseClip( length ) {\n\n\t\t\tvar tag = this.reader.getIDTag();\n\n\t\t\t// inside surface node\n\t\t\tif ( tag === 'FORM' ) {\n\n\t\t\t\tthis.reader.skip( 16 );\n\n\t\t\t\tthis.currentNode.fileName = this.reader.getString();\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// otherwise top level\n\t\t\tthis.reader.setOffset( this.reader.offset - 4 );\n\n\t\t\tthis.currentFormEnd = this.reader.offset + length;\n\t\t\tthis.parentForm = this.currentForm;\n\n\t\t\tthis.reader.skip( 8 ); // unknown\n\n\t\t\tvar texture = {\n\t\t\t\tindex: this.reader.getUint32()\n\t\t\t};\n\t\t\tthis.tree.textures.push( texture );\n\t\t\tthis.currentForm = texture;\n\n\t\t},\n\n\t\tparseClipLwo2( length ) {\n\n\t\t\tvar texture = {\n\t\t\t\tindex: this.reader.getUint32(),\n\t\t\t\tfileName: \"\"\n\t\t\t};\n\n\t\t\t// seach STIL block\n\t\t\twhile ( true ) {\n\n\t\t\t\tvar tag = this.reader.getIDTag();\n\t\t\t\tvar n_length = this.reader.getUint16();\n\t\t\t\tif ( tag === 'STIL' ) {\n\n\t\t\t\t\ttexture.fileName = this.reader.getString();\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( n_length >= length ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.tree.textures.push( texture );\n\t\t\tthis.currentForm = texture;\n\n\t\t},\n\n\t\tparseImage() {\n\n\t\t\tthis.reader.skip( 8 ); // unknown\n\t\t\tthis.currentForm.fileName = this.reader.getString();\n\n\t\t},\n\n\t\tparseXVAL( type, length ) {\n\n\t\t\tvar endOffset = this.reader.offset + length - 4;\n\t\t\tthis.reader.skip( 8 );\n\n\t\t\tthis.currentForm[ type ] = this.reader.getFloat32();\n\n\t\t\tthis.reader.setOffset( endOffset ); // set end offset directly to skip optional envelope\n\n\t\t},\n\n\t\tparseXVAL3( type, length ) {\n\n\t\t\tvar endOffset = this.reader.offset + length - 4;\n\t\t\tthis.reader.skip( 8 );\n\n\t\t\tthis.currentForm[ type ] = {\n\t\t\t\tx: this.reader.getFloat32(),\n\t\t\t\ty: this.reader.getFloat32(),\n\t\t\t\tz: this.reader.getFloat32(),\n\t\t\t};\n\n\t\t\tthis.reader.setOffset( endOffset );\n\n\t\t},\n\n\t\t// Tags associated with an object\n\t\t// OTAG { type[ID4], tag-string[S0] }\n\t\tparseObjectTag() {\n\n\t\t\tif ( ! this.tree.objectTags ) this.tree.objectTags = {};\n\n\t\t\tthis.tree.objectTags[ this.reader.getIDTag() ] = {\n\t\t\t\ttagString: this.reader.getString()\n\t\t\t};\n\n\t\t},\n\n\t\t// Signals the start of a new layer. All the data chunks which follow will be included in this layer until another layer chunk is encountered.\n\t\t// LAYR: number[U2], flags[U2], pivot[VEC12], name[S0], parent[U2]\n\t\tparseLayer( length ) {\n\n\t\t\tvar layer = {\n\t\t\t\tnumber: this.reader.getUint16(),\n\t\t\t\tflags: this.reader.getUint16(), // If the least significant bit of flags is set, the layer is hidden.\n\t\t\t\tpivot: this.reader.getFloat32Array( 3 ), // Note: this seems to be superflous, as the geometry is translated when pivot is present\n\t\t\t\tname: this.reader.getString(),\n\t\t\t};\n\n\t\t\tthis.tree.layers.push( layer );\n\t\t\tthis.currentLayer = layer;\n\n\t\t\tvar parsedLength = 16 + stringOffset( this.currentLayer.name ); // index ( 2 ) + flags( 2 ) + pivot( 12 ) + stringlength\n\n\t\t\t// if we have not reached then end of the layer block, there must be a parent defined\n\t\t\tthis.currentLayer.parent = ( parsedLength < length ) ? this.reader.getUint16() : - 1; // omitted or -1 for no parent\n\n\t\t},\n\n\t\t// VEC12 * ( F4 + F4 + F4 ) array of x,y,z vectors\n\t\t// Converting from left to right handed coordinate system:\n\t\t// x -> -x and switch material FrontSide -> BackSide\n\t\tparsePoints( length ) {\n\n\t\t\tthis.currentPoints = [];\n\t\t\tfor ( var i = 0; i < length / 4; i += 3 ) {\n\n\t\t\t\t// z -> -z to match three.js right handed coords\n\t\t\t\tthis.currentPoints.push( this.reader.getFloat32(), this.reader.getFloat32(), - this.reader.getFloat32() );\n\n\t\t\t}\n\n\t\t},\n\n\t\t// parse VMAP or VMAD\n\t\t// Associates a set of floating-point vectors with a set of points.\n\t\t// VMAP: { type[ID4], dimension[U2], name[S0], ( vert[VX], value[F4] # dimension ) * }\n\n\t\t// VMAD Associates a set of floating-point vectors with the vertices of specific polygons.\n\t\t// Similar to VMAP UVs, but associates with polygon vertices rather than points\n\t\t// to solve to problem of UV seams:  VMAD chunks are paired with VMAPs of the same name,\n\t\t// if they exist. The vector values in the VMAD will then replace those in the\n\t\t// corresponding VMAP, but only for calculations involving the specified polygons.\n\t\t// VMAD { type[ID4], dimension[U2], name[S0], ( vert[VX], poly[VX], value[F4] # dimension ) * }\n\t\tparseVertexMapping( length, discontinuous ) {\n\n\t\t\tvar finalOffset = this.reader.offset + length;\n\n\t\t\tvar channelName = this.reader.getString();\n\n\t\t\tif ( this.reader.offset === finalOffset ) {\n\n\t\t\t\t// then we are in a texture node and the VMAP chunk is just a reference to a UV channel name\n\t\t\t\tthis.currentForm.UVChannel = channelName;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t// otherwise reset to initial length and parse normal VMAP CHUNK\n\t\t\tthis.reader.setOffset( this.reader.offset - stringOffset( channelName ) );\n\n\t\t\tvar type = this.reader.getIDTag();\n\n\t\t\tthis.reader.getUint16(); // dimension\n\t\t\tvar name = this.reader.getString();\n\n\t\t\tvar remainingLength = length - 6 - stringOffset( name );\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'TXUV':\n\t\t\t\t\tthis.parseUVMapping( name, finalOffset, discontinuous );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'MORF':\n\t\t\t\tcase 'SPOT':\n\t\t\t\t\tthis.parseMorphTargets( name, finalOffset, type ); // can't be discontinuous\n\t\t\t\t\tbreak;\n\t\t\t\t// unsupported VMAPs\n\t\t\t\tcase 'APSL':\n\t\t\t\tcase 'NORM':\n\t\t\t\tcase 'WGHT':\n\t\t\t\tcase 'MNVW':\n\t\t\t\tcase 'PICK':\n\t\t\t\tcase 'RGB ':\n\t\t\t\tcase 'RGBA':\n\t\t\t\t\tthis.reader.skip( remainingLength );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn( 'LWOLoader: unknown vertex map type: ' + type );\n\t\t\t\t\tthis.reader.skip( remainingLength );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseUVMapping( name, finalOffset, discontinuous ) {\n\n\t\t\tvar uvIndices = [];\n\t\t\tvar polyIndices = [];\n\t\t\tvar uvs = [];\n\n\t\t\twhile ( this.reader.offset < finalOffset ) {\n\n\t\t\t\tuvIndices.push( this.reader.getVariableLengthIndex() );\n\n\t\t\t\tif ( discontinuous ) polyIndices.push( this.reader.getVariableLengthIndex() );\n\n\t\t\t\tuvs.push( this.reader.getFloat32(), this.reader.getFloat32() );\n\n\t\t\t}\n\n\t\t\tif ( discontinuous ) {\n\n\t\t\t\tif ( ! this.currentLayer.discontinuousUVs ) this.currentLayer.discontinuousUVs = {};\n\n\t\t\t\tthis.currentLayer.discontinuousUVs[ name ] = {\n\t\t\t\t\tuvIndices: uvIndices,\n\t\t\t\t\tpolyIndices: polyIndices,\n\t\t\t\t\tuvs: uvs,\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tif ( ! this.currentLayer.uvs ) this.currentLayer.uvs = {};\n\n\t\t\t\tthis.currentLayer.uvs[ name ] = {\n\t\t\t\t\tuvIndices: uvIndices,\n\t\t\t\t\tuvs: uvs,\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseMorphTargets( name, finalOffset, type ) {\n\n\t\t\tvar indices = [];\n\t\t\tvar points = [];\n\n\t\t\ttype = ( type === 'MORF' ) ? 'relative' : 'absolute';\n\n\t\t\twhile ( this.reader.offset < finalOffset ) {\n\n\t\t\t\tindices.push( this.reader.getVariableLengthIndex() );\n\t\t\t\t// z -> -z to match three.js right handed coords\n\t\t\t\tpoints.push( this.reader.getFloat32(), this.reader.getFloat32(), - this.reader.getFloat32() );\n\n\t\t\t}\n\n\t\t\tif ( ! this.currentLayer.morphTargets ) this.currentLayer.morphTargets = {};\n\n\t\t\tthis.currentLayer.morphTargets[ name ] = {\n\t\t\t\tindices: indices,\n\t\t\t\tpoints: points,\n\t\t\t\ttype: type,\n\t\t\t};\n\n\t\t},\n\n\t\t// A list of polygons for the current layer.\n\t\t// POLS { type[ID4], ( numvert+flags[U2], vert[VX] # numvert ) * }\n\t\tparsePolygonList( length ) {\n\n\t\t\tvar finalOffset = this.reader.offset + length;\n\t\t\tvar type = this.reader.getIDTag();\n\n\t\t\tvar indices = [];\n\n\t\t\t// hold a list of polygon sizes, to be split up later\n\t\t\tvar polygonDimensions = [];\n\n\t\t\twhile ( this.reader.offset < finalOffset ) {\n\n\t\t\t\tvar numverts = this.reader.getUint16();\n\n\t\t\t\t//var flags = numverts & 64512; // 6 high order bits are flags - ignoring for now\n\t\t\t\tnumverts = numverts & 1023; // remaining ten low order bits are vertex num\n\t\t\t\tpolygonDimensions.push( numverts );\n\n\t\t\t\tfor ( var j = 0; j < numverts; j ++ ) indices.push( this.reader.getVariableLengthIndex() );\n\n\t\t\t}\n\n\t\t\tvar geometryData = {\n\t\t\t\ttype: type,\n\t\t\t\tvertexIndices: indices,\n\t\t\t\tpolygonDimensions: polygonDimensions,\n\t\t\t\tpoints: this.currentPoints\n\t\t\t};\n\n\t\t\t// Note: assuming that all polys will be lines or points if the first is\n\t\t\tif ( polygonDimensions[ 0 ] === 1 ) geometryData.type = 'points';\n\t\t\telse if ( polygonDimensions[ 0 ] === 2 ) geometryData.type = 'lines';\n\n\t\t\tthis.currentLayer.geometry = geometryData;\n\n\t\t},\n\n\t\t// Lists the tag strings that can be associated with polygons by the PTAG chunk.\n\t\t// TAGS { tag-string[S0] * }\n\t\tparseTagStrings( length ) {\n\n\t\t\tthis.tree.tags = this.reader.getStringArray( length );\n\n\t\t},\n\n\t\t// Associates tags of a given type with polygons in the most recent POLS chunk.\n\t\t// PTAG { type[ID4], ( poly[VX], tag[U2] ) * }\n\t\tparsePolygonTagMapping( length ) {\n\n\t\t\tvar finalOffset = this.reader.offset + length;\n\t\t\tvar type = this.reader.getIDTag();\n\t\t\tif ( type === 'SURF' ) this.parseMaterialIndices( finalOffset );\n\t\t\telse { //PART, SMGP, COLR not supported\n\n\t\t\t\tthis.reader.skip( length - 4 );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseMaterialIndices( finalOffset ) {\n\n\t\t\t// array holds polygon index followed by material index\n\t\t\tthis.currentLayer.geometry.materialIndices = [];\n\n\t\t\twhile ( this.reader.offset < finalOffset ) {\n\n\t\t\t\tvar polygonIndex = this.reader.getVariableLengthIndex();\n\t\t\t\tvar materialIndex = this.reader.getUint16();\n\n\t\t\t\tthis.currentLayer.geometry.materialIndices.push( polygonIndex, materialIndex );\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseUnknownCHUNK( blockID, length ) {\n\n\t\t\tconsole.warn( 'LWOLoader: unknown chunk type: ' + blockID + ' length: ' + length );\n\n\t\t\t// print the chunk plus some bytes padding either side\n\t\t\t// printBuffer( this.reader.dv.buffer, this.reader.offset - 20, length + 40 );\n\n\t\t\tvar data = this.reader.getString( length );\n\n\t\t\tthis.currentForm[ blockID ] = data;\n\n\t\t}\n\n\t};\n\n\tfunction DataViewReader( buffer ) {\n\n\t\tthis.dv = new DataView( buffer );\n\t\tthis.offset = 0;\n\n\t}\n\n\tDataViewReader.prototype = {\n\n\t\tconstructor: DataViewReader,\n\n\t\tsize: function () {\n\n\t\t\treturn this.dv.buffer.byteLength;\n\n\t\t},\n\n\t\tsetOffset( offset ) {\n\n\t\t\tif ( offset > 0 && offset < this.dv.buffer.byteLength ) {\n\n\t\t\t\tthis.offset = offset;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'LWOLoader: invalid buffer offset' );\n\n\t\t\t}\n\n\t\t},\n\n\t\tendOfFile: function () {\n\n\t\t\tif ( this.offset >= this.size() ) return true;\n\t\t\treturn false;\n\n\t\t},\n\n\t\tskip: function ( length ) {\n\n\t\t\tthis.offset += length;\n\n\t\t},\n\n\t\tgetUint8: function () {\n\n\t\t\tvar value = this.dv.getUint8( this.offset );\n\t\t\tthis.offset += 1;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetUint16: function () {\n\n\t\t\tvar value = this.dv.getUint16( this.offset );\n\t\t\tthis.offset += 2;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetInt32: function () {\n\n\t\t\tvar value = this.dv.getInt32( this.offset, false );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetUint32: function () {\n\n\t\t\tvar value = this.dv.getUint32( this.offset, false );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetUint64: function () {\n\n\t\t\tvar low, high;\n\n\t\t\thigh = this.getUint32();\n\t\t\tlow = this.getUint32();\n\t\t\treturn high * 0x100000000 + low;\n\n\t\t},\n\n\t\tgetFloat32: function () {\n\n\t\t\tvar value = this.dv.getFloat32( this.offset, false );\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetFloat32Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getFloat32() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\tgetFloat64: function () {\n\n\t\t\tvar value = this.dv.getFloat64( this.offset, this.littleEndian );\n\t\t\tthis.offset += 8;\n\t\t\treturn value;\n\n\t\t},\n\n\t\tgetFloat64Array: function ( size ) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\ta.push( this.getFloat64() );\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t},\n\n\t\t// get variable-length index data type\n\t\t// VX ::= index[U2] | (index + 0xFF000000)[U4]\n\t\t// If the index value is less than 65,280 (0xFF00),then VX === U2\n\t\t// otherwise VX === U4 with bits 24-31 set\n\t\t// When reading an index, if the first byte encountered is 255 (0xFF), then\n\t\t// the four-byte form is being used and the first byte should be discarded or masked out.\n\t\tgetVariableLengthIndex() {\n\n\t\t\tvar firstByte = this.getUint8();\n\n\t\t\tif ( firstByte === 255 ) {\n\n\t\t\t\treturn this.getUint8() * 65536 + this.getUint8() * 256 + this.getUint8();\n\n\t\t\t}\n\n\t\t\treturn firstByte * 256 + this.getUint8();\n\n\t\t},\n\n\t\t// An ID tag is a sequence of 4 bytes containing 7-bit ASCII values\n\t\tgetIDTag() {\n\n\t\t\treturn this.getString( 4 );\n\n\t\t},\n\n\t\tgetString: function ( size ) {\n\n\t\t\tif ( size === 0 ) return;\n\n\t\t\t// note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n\t\t\tvar a = [];\n\n\t\t\tif ( size ) {\n\n\t\t\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\t\t\ta[ i ] = this.getUint8();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar currentChar;\n\t\t\t\tvar len = 0;\n\n\t\t\t\twhile ( currentChar !== 0 ) {\n\n\t\t\t\t\tcurrentChar = this.getUint8();\n\t\t\t\t\tif ( currentChar !== 0 ) a.push( currentChar );\n\t\t\t\t\tlen ++;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! isEven( len + 1 ) ) this.getUint8(); // if string with terminating nullbyte is uneven, extra nullbyte is added\n\n\t\t\t}\n\n\t\t\treturn THREE.LoaderUtils.decodeText( new Uint8Array( a ) );\n\n\t\t},\n\n\t\tgetStringArray: function ( size ) {\n\n\t\t\tvar a = this.getString( size );\n\t\t\ta = a.split( '\\0' );\n\n\t\t\treturn a.filter( Boolean ); // return array with any empty strings removed\n\n\t\t}\n\n\t};\n\n\t// ************** DEBUGGER  **************\n\n\tfunction Debugger( ) {\n\n\t\tthis.active = false;\n\t\tthis.depth = 0;\n\t\tthis.formList = [];\n\n\t}\n\n\tDebugger.prototype = {\n\n\t\tconstructor: Debugger,\n\n\t\tenable: function () {\n\n\t\t\tthis.active = true;\n\n\t\t},\n\n\t\tlog: function () {\n\n\t\t\tif ( ! this.active ) return;\n\n\t\t\tvar nodeType;\n\n\t\t\tswitch ( this.node ) {\n\n\t\t\t\tcase 0:\n\t\t\t\t\tnodeType = \"FORM\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tnodeType = \"CHK\";\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tnodeType = \"S-CHK\";\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconsole.log(\n\t\t\t\t\"| \".repeat( this.depth ) +\n\t\t\t\tnodeType,\n\t\t\t\tthis.nodeID,\n\t\t\t\t`( ${this.offset} ) -> ( ${this.dataOffset + this.length} )`,\n\t\t\t\t( ( this.node == 0 ) ? \" {\" : \"\" ),\n\t\t\t\t( ( this.skipped ) ? \"SKIPPED\" : \"\" ),\n\t\t\t\t( ( this.node == 0 && this.skipped ) ? \"}\" : \"\" )\n\t\t\t);\n\n\t\t\tif ( this.node == 0 && ! this.skipped ) {\n\n\t\t\t\tthis.depth += 1;\n\t\t\t\tthis.formList.push( this.dataOffset + this.length );\n\n\t\t\t}\n\n\t\t\tthis.skipped = false;\n\n\t\t},\n\n\t\tcloseForms: function () {\n\n\t\t\tif ( ! this.active ) return;\n\n\t\t\tfor ( var i = this.formList.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tif ( this.offset >= this.formList[ i ] ) {\n\n\t\t\t\t\tthis.depth -= 1;\n\t\t\t\t\tconsole.log( \"| \".repeat( this.depth ) + \"}\" );\n\t\t\t\t\tthis.formList.splice( - 1, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// ************** UTILITY FUNCTIONS **************\n\n\tfunction isEven( num ) {\n\n\t\treturn num % 2;\n\n\t}\n\n\t// calculate the length of the string in the buffer\n\t// this will be string.length + nullbyte + optional padbyte to make the length even\n\tfunction stringOffset( string ) {\n\n\t\treturn string.length + 1 + ( isEven( string.length + 1 ) ? 1 : 0 );\n\n\t}\n\n\t// for testing purposes, dump buffer to console\n\t// printBuffer( this.reader.dv.buffer, this.reader.offset, length );\n\tfunction printBuffer( buffer, from, to ) {\n\n\t\tconsole.log( THREE.LoaderUtils.decodeText( new Uint8Array( buffer, from, to ) ) );\n\n\t}\n\n\tvar lwoTree;\n\n\tTHREE.LWOLoader = function ( manager, parameters ) {\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tparameters = parameters || {};\n\n\t\tthis.resourcePath = ( parameters.resourcePath !== undefined ) ? parameters.resourcePath : '';\n\n\t};\n\n\tTHREE.LWOLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: THREE.LWOLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar self = this;\n\n\t\t\tvar path = ( self.path === '' ) ? extractParentUrl( url, 'Objects' ) : self.path;\n\n\t\t\t// give the mesh a default name based on the filename\n\t\t\tvar modelName = url.split( path ).pop().split( '.' )[ 0 ];\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setPath( self.path );\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\t// console.time( 'Total parsing: ' );\n\t\t\t\tonLoad( self.parse( buffer, path, modelName ) );\n\t\t\t\t// console.timeEnd( 'Total parsing: ' );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: function ( iffBuffer, path, modelName ) {\n\n\t\t\tlwoTree = new IFFParser().parse( iffBuffer );\n\n\t\t\t// console.log( 'lwoTree', lwoTree );\n\n\t\t\tvar textureLoader = new THREE.TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\t\treturn new LWOTreeParser( textureLoader ).parse( modelName );\n\n\t\t}\n\n\t} );\n\n\t// Parse the lwoTree object\n\tfunction LWOTreeParser( textureLoader ) {\n\n\t\tthis.textureLoader = textureLoader;\n\n\t}\n\n\tLWOTreeParser.prototype = {\n\n\t\tconstructor: LWOTreeParser,\n\n\t\tparse: function ( modelName ) {\n\n\t\t\tthis.materials = new MaterialParser( this.textureLoader ).parse();\n\t\t\tthis.defaultLayerName = modelName;\n\n\t\t\tthis.meshes = this.parseLayers();\n\n\t\t\treturn {\n\t\t\t\tmaterials: this.materials,\n\t\t\t\tmeshes: this.meshes,\n\t\t\t};\n\n\t\t},\n\n\t\tparseLayers() {\n\n\t\t\t// array of all meshes for building hierarchy\n\t\t\tvar meshes = [];\n\n\t\t\t// final array containing meshes with scene graph hierarchy set up\n\t\t\tvar finalMeshes = [];\n\n\t\t\tvar geometryParser = new GeometryParser();\n\n\t\t\tvar self = this;\n\t\t\tlwoTree.layers.forEach( function ( layer ) {\n\n\t\t\t\tvar geometry = geometryParser.parse( layer.geometry, layer );\n\n\t\t\t\tvar mesh = self.parseMesh( geometry, layer );\n\n\t\t\t\tmeshes[ layer.number ] = mesh;\n\n\t\t\t\tif ( layer.parent === - 1 ) finalMeshes.push( mesh );\n\t\t\t\telse meshes[ layer.parent ].add( mesh );\n\n\n\t\t\t} );\n\n\t\t\tthis.applyPivots( finalMeshes );\n\n\t\t\treturn finalMeshes;\n\n\t\t},\n\n\t\tparseMesh( geometry, layer ) {\n\n\t\t\tvar mesh;\n\n\t\t\tvar materials = this.getMaterials( geometry.userData.matNames, layer.geometry.type );\n\n\t\t\tthis.duplicateUVs( geometry, materials );\n\n\t\t\tif ( layer.geometry.type === 'points' ) mesh = new THREE.Points( geometry, materials );\n\t\t\telse if ( layer.geometry.type === 'lines' ) mesh = new THREE.LineSegments( geometry, materials );\n\t\t\telse mesh = new THREE.Mesh( geometry, materials );\n\n\t\t\tif ( layer.name ) mesh.name = layer.name;\n\t\t\telse mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n\n\t\t\tmesh.userData.pivot = layer.pivot;\n\n\t\t\treturn mesh;\n\n\t\t},\n\n\t\t// TODO: may need to be reversed in z to convert LWO to three.js coordinates\n\t\tapplyPivots( meshes ) {\n\n\t\t\tmeshes.forEach( function ( mesh ) {\n\n\t\t\t\tmesh.traverse( function ( child ) {\n\n\t\t\t\t\tvar pivot = child.userData.pivot;\n\n\t\t\t\t\tchild.position.x += pivot[ 0 ];\n\t\t\t\t\tchild.position.y += pivot[ 1 ];\n\t\t\t\t\tchild.position.z += pivot[ 2 ];\n\n\t\t\t\t\tif ( child.parent ) {\n\n\t\t\t\t\t\tvar parentPivot = child.parent.userData.pivot;\n\n\t\t\t\t\t\tchild.position.x -= parentPivot[ 0 ];\n\t\t\t\t\t\tchild.position.y -= parentPivot[ 1 ];\n\t\t\t\t\t\tchild.position.z -= parentPivot[ 2 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t},\n\n\t\tgetMaterials( namesArray, type ) {\n\n\t\t\tvar materials = [];\n\n\t\t\tvar self = this;\n\n\t\t\tnamesArray.forEach( function ( name, i ) {\n\n\t\t\t\tmaterials[ i ] = self.getMaterialByName( name );\n\n\t\t\t} );\n\n\t\t\t// convert materials to line or point mats if required\n\t\t\tif ( type === 'points' || type === 'lines' ) {\n\n\t\t\t\tmaterials.forEach( function ( mat, i ) {\n\n\t\t\t\t\tvar spec = {\n\t\t\t\t\t\tcolor: mat.color,\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( type === 'points' ) {\n\n\t\t\t\t\t\tspec.size = 0.1;\n\t\t\t\t\t\tspec.map = mat.map;\n\t\t\t\t\t\tspec.morphTargets = mat.morphTargets;\n\t\t\t\t\t\tmaterials[ i ] = new THREE.PointsMaterial( spec );\n\n\t\t\t\t\t} else if ( type === 'lines' ) {\n\n\t\t\t\t\t\tmaterials[ i ] = new THREE.LineBasicMaterial( spec );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// if there is only one material, return that directly instead of array\n\t\t\tvar filtered = materials.filter( Boolean );\n\t\t\tif ( filtered.length === 1 ) return filtered[ 0 ];\n\n\t\t\treturn materials;\n\n\t\t},\n\n\t\tgetMaterialByName( name ) {\n\n\t\t\treturn this.materials.filter( function ( m ) {\n\n\t\t\t\treturn m.name === name;\n\n\t\t\t} )[ 0 ];\n\n\t\t},\n\n\t\t// If the material has an aoMap, duplicate UVs\n\t\tduplicateUVs( geometry, materials ) {\n\n\t\t\tvar duplicateUVs = false;\n\n\t\t\tif ( ! Array.isArray( materials ) ) {\n\n\t\t\t\tif ( materials.aoMap ) duplicateUVs = true;\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.forEach( function ( material ) {\n\n\t\t\t\t\tif ( material.aoMap ) duplicateUVs = true;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( ! duplicateUVs ) return;\n\n\t\t\tgeometry.setAttribute( 'uv2', new THREE.BufferAttribute( geometry.attributes.uv.array, 2 ) );\n\n\t\t},\n\n\t};\n\n\tfunction MaterialParser( textureLoader ) {\n\n\t\tthis.textureLoader = textureLoader;\n\n\t}\n\n\tMaterialParser.prototype = {\n\n\t\tconstructor: MaterialParser,\n\n\t\tparse: function () {\n\n\t\t\tvar materials = [];\n\t\t\tthis.textures = {};\n\n\t\t\tfor ( var name in lwoTree.materials ) {\n\n\t\t\t\tif ( lwoTree.format === 'LWO3' ) {\n\n\t\t\t\t\tmaterials.push( this.parseMaterial( lwoTree.materials[ name ], name, lwoTree.textures ) );\n\n\t\t\t\t} else if ( lwoTree.format === 'LWO2' ) {\n\n\t\t\t\t\tmaterials.push( this.parseMaterialLwo2( lwoTree.materials[ name ], name, lwoTree.textures ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t},\n\n\t\tparseMaterial( materialData, name, textures ) {\n\n\t\t\tvar params = {\n\t\t\t\tname: name,\n\t\t\t\tside: this.getSide( materialData.attributes ),\n\t\t\t\tflatShading: this.getSmooth( materialData.attributes ),\n\t\t\t};\n\n\t\t\tvar connections = this.parseConnections( materialData.connections, materialData.nodes );\n\n\t\t\tvar maps = this.parseTextureNodes( connections.maps );\n\n\t\t\tthis.parseAttributeImageMaps( connections.attributes, textures, maps, materialData.maps );\n\n\t\t\tvar attributes = this.parseAttributes( connections.attributes, maps );\n\n\t\t\tthis.parseEnvMap( connections, maps, attributes );\n\n\t\t\tparams = Object.assign( maps, params );\n\t\t\tparams = Object.assign( params, attributes );\n\n\t\t\tvar materialType = this.getMaterialType( connections.attributes );\n\n\t\t\treturn new materialType( params );\n\n\t\t},\n\n\t\tparseMaterialLwo2( materialData, name/*, textures*/ ) {\n\n\t\t\tvar params = {\n\t\t\t\tname: name,\n\t\t\t\tside: this.getSide( materialData.attributes ),\n\t\t\t\tflatShading: this.getSmooth( materialData.attributes ),\n\t\t\t};\n\n\t\t\tvar attributes = this.parseAttributes( materialData.attributes, {} );\n\t\t\tparams = Object.assign( params, attributes );\n\t\t\treturn new THREE.MeshPhongMaterial( params );\n\n\t\t},\n\n\t\t// Note: converting from left to right handed coords by switching x -> -x in vertices, and\n\t\t// then switching mat FrontSide -> BackSide\n\t\t// NB: this means that THREE.FrontSide and THREE.BackSide have been switched!\n\t\tgetSide( attributes ) {\n\n\t\t\tif ( ! attributes.side ) return THREE.BackSide;\n\n\t\t\tswitch ( attributes.side ) {\n\n\t\t\t\tcase 0:\n\t\t\t\tcase 1:\n\t\t\t\t\treturn THREE.BackSide;\n\t\t\t\tcase 2: return THREE.FrontSide;\n\t\t\t\tcase 3: return THREE.DoubleSide;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetSmooth( attributes ) {\n\n\t\t\tif ( ! attributes.smooth ) return true;\n\t\t\treturn ! attributes.smooth;\n\n\t\t},\n\n\t\tparseConnections( connections, nodes ) {\n\n\t\t\tvar materialConnections = {\n\t\t\t\tmaps: {}\n\t\t\t};\n\n\t\t\tvar inputName = connections.inputName;\n\t\t\tvar inputNodeName = connections.inputNodeName;\n\t\t\tvar nodeName = connections.nodeName;\n\n\t\t\tvar self = this;\n\t\t\tinputName.forEach( function ( name, index ) {\n\n\t\t\t\tif ( name === 'Material' ) {\n\n\t\t\t\t\tvar matNode = self.getNodeByRefName( inputNodeName[ index ], nodes );\n\t\t\t\t\tmaterialConnections.attributes = matNode.attributes;\n\t\t\t\t\tmaterialConnections.envMap = matNode.fileName;\n\t\t\t\t\tmaterialConnections.name = inputNodeName[ index ];\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tnodeName.forEach( function ( name, index ) {\n\n\t\t\t\tif ( name === materialConnections.name ) {\n\n\t\t\t\t\tmaterialConnections.maps[ inputName[ index ] ] = self.getNodeByRefName( inputNodeName[ index ], nodes );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn materialConnections;\n\n\t\t},\n\n\t\tgetNodeByRefName( refName, nodes ) {\n\n\t\t\tfor ( var name in nodes ) {\n\n\t\t\t\tif ( nodes[ name ].refName === refName ) return nodes[ name ];\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseTextureNodes( textureNodes ) {\n\n\t\t\tvar maps = {};\n\n\t\t\tfor ( var name in textureNodes ) {\n\n\t\t\t\tvar node = textureNodes[ name ];\n\t\t\t\tvar path = node.fileName;\n\n\t\t\t\tif ( ! path ) return;\n\n\t\t\t\tvar texture = this.loadTexture( path );\n\n\t\t\t\tif ( node.widthWrappingMode !== undefined ) texture.wrapS = this.getWrappingType( node.widthWrappingMode );\n\t\t\t\tif ( node.heightWrappingMode !== undefined ) texture.wrapT = this.getWrappingType( node.heightWrappingMode );\n\n\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\tcase 'Color':\n\t\t\t\t\t\tmaps.map = texture;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Roughness':\n\t\t\t\t\t\tmaps.roughnessMap = texture;\n\t\t\t\t\t\tmaps.roughness = 0.5;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Specular':\n\t\t\t\t\t\tmaps.specularMap = texture;\n\t\t\t\t\t\tmaps.specular = 0xffffff;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Luminous':\n\t\t\t\t\t\tmaps.emissiveMap = texture;\n\t\t\t\t\t\tmaps.emissive = 0x808080;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Luminous Color':\n\t\t\t\t\t\tmaps.emissive = 0x808080;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Metallic':\n\t\t\t\t\t\tmaps.metalnessMap = texture;\n\t\t\t\t\t\tmaps.metalness = 0.5;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Transparency':\n\t\t\t\t\tcase 'Alpha':\n\t\t\t\t\t\tmaps.alphaMap = texture;\n\t\t\t\t\t\tmaps.transparent = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Normal':\n\t\t\t\t\t\tmaps.normalMap = texture;\n\t\t\t\t\t\tif ( node.amplitude !== undefined ) maps.normalScale = new THREE.Vector2( node.amplitude, node.amplitude );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Bump':\n\t\t\t\t\t\tmaps.bumpMap = texture;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// LWO BSDF materials can have both spec and rough, but this is not valid in three\n\t\t\tif ( maps.roughnessMap && maps.specularMap ) delete maps.specularMap;\n\n\t\t\treturn maps;\n\n\t\t},\n\n\t\t// maps can also be defined on individual material attributes, parse those here\n\t\t// This occurs on Standard (Phong) surfaces\n\t\tparseAttributeImageMaps( attributes, textures, maps ) {\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tvar attribute = attributes[ name ];\n\n\t\t\t\tif ( attribute.maps ) {\n\n\t\t\t\t\tvar mapData = attribute.maps[ 0 ];\n\n\t\t\t\t\tvar path = this.getTexturePathByIndex( mapData.imageIndex, textures );\n\t\t\t\t\tif ( ! path ) return;\n\n\t\t\t\t\tvar texture = this.loadTexture( path );\n\n\t\t\t\t\tif ( mapData.wrap !== undefined ) texture.wrapS = this.getWrappingType( mapData.wrap.w );\n\t\t\t\t\tif ( mapData.wrap !== undefined ) texture.wrapT = this.getWrappingType( mapData.wrap.h );\n\n\t\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\t\tcase 'Color':\n\t\t\t\t\t\t\tmaps.map = texture;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Diffuse':\n\t\t\t\t\t\t\tmaps.aoMap = texture;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Roughness':\n\t\t\t\t\t\t\tmaps.roughnessMap = texture;\n\t\t\t\t\t\t\tmaps.roughness = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Specular':\n\t\t\t\t\t\t\tmaps.specularMap = texture;\n\t\t\t\t\t\t\tmaps.specular = 0xffffff;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Luminosity':\n\t\t\t\t\t\t\tmaps.emissiveMap = texture;\n\t\t\t\t\t\t\tmaps.emissive = 0x808080;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Metallic':\n\t\t\t\t\t\t\tmaps.metalnessMap = texture;\n\t\t\t\t\t\t\tmaps.metalness = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Transparency':\n\t\t\t\t\t\tcase 'Alpha':\n\t\t\t\t\t\t\tmaps.alphaMap = texture;\n\t\t\t\t\t\t\tmaps.transparent = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Normal':\n\t\t\t\t\t\t\tmaps.normalMap = texture;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Bump':\n\t\t\t\t\t\t\tmaps.bumpMap = texture;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseAttributes( attributes, maps ) {\n\n\t\t\tvar params = {};\n\n\t\t\t// don't use color data if color map is present\n\t\t\tif ( attributes.Color && ! maps.map ) {\n\n\t\t\t\tparams.color = new THREE.Color().fromArray( attributes.Color.value );\n\n\t\t\t} else params.color = new THREE.Color();\n\n\n\t\t\tif ( attributes.Transparency && attributes.Transparency.value !== 0 ) {\n\n\t\t\t\tparams.opacity = 1 - attributes.Transparency.value;\n\t\t\t\tparams.transparent = true;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ 'Bump Height' ] ) params.bumpScale = attributes[ 'Bump Height' ].value * 0.1;\n\n\t\t\tif ( attributes[ 'Refraction Index' ] ) params.refractionRatio = 1 / attributes[ 'Refraction Index' ].value;\n\n\t\t\tthis.parsePhysicalAttributes( params, attributes, maps );\n\t\t\tthis.parseStandardAttributes( params, attributes, maps );\n\t\t\tthis.parsePhongAttributes( params, attributes, maps );\n\n\t\t\treturn params;\n\n\t\t},\n\n\t\tparsePhysicalAttributes( params, attributes/*, maps*/ ) {\n\n\t\t\tif ( attributes.Clearcoat && attributes.Clearcoat.value > 0 ) {\n\n\t\t\t\tparams.clearcoat = attributes.Clearcoat.value;\n\n\t\t\t\tif ( attributes[ 'Clearcoat Gloss' ] ) {\n\n\t\t\t\t\tparams.clearcoatRoughness = 0.5 * ( 1 - attributes[ 'Clearcoat Gloss' ].value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tparseStandardAttributes( params, attributes, maps ) {\n\n\n\t\t\tif ( attributes.Luminous ) {\n\n\t\t\t\tparams.emissiveIntensity = attributes.Luminous.value;\n\n\t\t\t\tif ( attributes[ 'Luminous Color' ] && ! maps.emissive ) {\n\n\t\t\t\t\tparams.emissive = new THREE.Color().fromArray( attributes[ 'Luminous Color' ].value );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tparams.emissive = new THREE.Color( 0x808080 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( attributes.Roughness && ! maps.roughnessMap ) params.roughness = attributes.Roughness.value;\n\t\t\tif ( attributes.Metallic && ! maps.metalnessMap ) params.metalness = attributes.Metallic.value;\n\n\t\t},\n\n\t\tparsePhongAttributes( params, attributes, maps ) {\n\n\t\t\tif ( attributes.Diffuse ) params.color.multiplyScalar( attributes.Diffuse.value );\n\n\t\t\tif ( attributes.Reflection ) {\n\n\t\t\t\tparams.reflectivity = attributes.Reflection.value;\n\t\t\t\tparams.combine = THREE.AddOperation;\n\n\t\t\t}\n\n\t\t\tif ( attributes.Luminosity ) {\n\n\t\t\t\tparams.emissiveIntensity = attributes.Luminosity.value;\n\n\t\t\t\tif ( ! maps.emissiveMap && ! maps.map ) {\n\n\t\t\t\t\tparams.emissive = params.color;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tparams.emissive = new THREE.Color( 0x808080 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n\t\t\tif ( ! attributes.Roughness && attributes.Specular && ! maps.specularMap ) {\n\n\t\t\t\tif ( attributes[ 'Color Highlight' ] ) {\n\n\t\t\t\t\tparams.specular = new THREE.Color().setScalar( attributes.Specular.value ).lerp( params.color.clone().multiplyScalar( attributes.Specular.value ), attributes[ 'Color Highlight' ].value );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tparams.specular = new THREE.Color().setScalar( attributes.Specular.value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( params.specular && attributes.Glossiness ) params.shininess = 7 + Math.pow( 2, attributes.Glossiness.value * 12 + 2 );\n\n\t\t},\n\n\t\tparseEnvMap( connections, maps, attributes ) {\n\n\t\t\tif ( connections.envMap ) {\n\n\t\t\t\tvar envMap = this.loadTexture( connections.envMap );\n\n\t\t\t\tif ( attributes.transparent && attributes.opacity < 0.999 ) {\n\n\t\t\t\t\tenvMap.mapping = THREE.EquirectangularRefractionMapping;\n\n\t\t\t\t\t// Reflectivity and refraction mapping don't work well together in Phong materials\n\t\t\t\t\tif ( attributes.reflectivity !== undefined ) {\n\n\t\t\t\t\t\tdelete attributes.reflectivity;\n\t\t\t\t\t\tdelete attributes.combine;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.metalness !== undefined ) {\n\n\t\t\t\t\t\tdelete attributes.metalness;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else envMap.mapping = THREE.EquirectangularReflectionMapping;\n\n\t\t\t\tmaps.envMap = envMap;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// get texture defined at top level by its index\n\t\tgetTexturePathByIndex( index ) {\n\n\t\t\tvar fileName = '';\n\n\t\t\tif ( ! lwoTree.textures ) return fileName;\n\n\t\t\tlwoTree.textures.forEach( function ( texture ) {\n\n\t\t\t\tif ( texture.index === index ) fileName = texture.fileName;\n\n\t\t\t} );\n\n\t\t\treturn fileName;\n\n\t\t},\n\n\t\tloadTexture( path ) {\n\n\t\t\tif ( ! path ) return null;\n\n\t\t\tvar texture;\n\n\t\t\ttexture = this.textureLoader.load(\n\t\t\t\tpath,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t\tfunction () {\n\n\t\t\t\t\tconsole.warn( 'LWOLoader: non-standard resource hierarchy. Use \\`resourcePath\\` parameter to specify root content directory.' );\n\n\t\t\t\t}\n\t\t\t);\n\n\t\t\treturn texture;\n\n\t\t},\n\n\t\t// 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n\t\tgetWrappingType( num ) {\n\n\t\t\tswitch ( num ) {\n\n\t\t\t\tcase 0:\n\t\t\t\t\tconsole.warn( 'LWOLoader: \"Reset\" texture wrapping type is not supported in three.js' );\n\t\t\t\t\treturn THREE.ClampToEdgeWrapping;\n\t\t\t\tcase 1: return THREE.RepeatWrapping;\n\t\t\t\tcase 2: return THREE.MirroredRepeatWrapping;\n\t\t\t\tcase 3: return THREE.ClampToEdgeWrapping;\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetMaterialType( nodeData ) {\n\n\t\t\tif ( nodeData.Clearcoat && nodeData.Clearcoat.value > 0 ) return THREE.MeshPhysicalMaterial;\n\t\t\tif ( nodeData.Roughness ) return THREE.MeshStandardMaterial;\n\t\t\treturn THREE.MeshPhongMaterial;\n\n\t\t}\n\n\t};\n\n\tfunction GeometryParser() {}\n\n\tGeometryParser.prototype = {\n\n\t\tconstructor: GeometryParser,\n\n\t\tparse( geoData, layer ) {\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( geoData.points, 3 ) );\n\n\t\t\tvar indices = this.splitIndices( geoData.vertexIndices, geoData.polygonDimensions );\n\t\t\tgeometry.setIndex( indices );\n\n\t\t\tthis.parseGroups( geometry, geoData );\n\n\t\t\tgeometry.computeVertexNormals();\n\n\t\t\tthis.parseUVs( geometry, layer, indices );\n\t\t\tthis.parseMorphTargets( geometry, layer, indices );\n\n\t\t\t// TODO: z may need to be reversed to account for coordinate system change\n\t\t\tgeometry.translate( - layer.pivot[ 0 ], - layer.pivot[ 1 ], - layer.pivot[ 2 ] );\n\n\t\t\t// var userData = geometry.userData;\n\t\t\t// geometry = geometry.toNonIndexed()\n\t\t\t// geometry.userData = userData;\n\n\t\t\treturn geometry;\n\n\t\t},\n\n\t\t// split quads into tris\n\t\tsplitIndices( indices, polygonDimensions ) {\n\n\t\t\tvar remappedIndices = [];\n\n\t\t\tvar i = 0;\n\t\t\tpolygonDimensions.forEach( function ( dim ) {\n\n\t\t\t\tif ( dim < 4 ) {\n\n\t\t\t\t\tfor ( var k = 0; k < dim; k ++ ) remappedIndices.push( indices[ i + k ] );\n\n\t\t\t\t} else if ( dim === 4 ) {\n\n\t\t\t\t\tremappedIndices.push(\n\t\t\t\t\t\tindices[ i ],\n\t\t\t\t\t\tindices[ i + 1 ],\n\t\t\t\t\t\tindices[ i + 2 ],\n\n\t\t\t\t\t\tindices[ i ],\n\t\t\t\t\t\tindices[ i + 2 ],\n\t\t\t\t\t\tindices[ i + 3 ]\n\n\t\t\t\t\t);\n\n\t\t\t\t} else if ( dim > 4 ) {\n\n\t\t\t\t\tfor ( var k = 1; k < dim - 1; k ++ ) {\n\n\t\t\t\t\t\tremappedIndices.push( indices[ i ], indices[ i + k ], indices[ i + k + 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.warn( 'LWOLoader: polygons with greater than 4 sides are not supported' );\n\n\t\t\t\t}\n\n\t\t\t\ti += dim;\n\n\t\t\t} );\n\n\t\t\treturn remappedIndices;\n\n\t\t},\n\n\t\t// NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n\t\tparseGroups( geometry, geoData ) {\n\n\t\t\tvar tags = lwoTree.tags;\n\t\t\tvar matNames = [];\n\n\t\t\tvar elemSize = 3;\n\t\t\tif ( geoData.type === 'lines' ) elemSize = 2;\n\t\t\tif ( geoData.type === 'points' ) elemSize = 1;\n\n\t\t\tvar remappedIndices = this.splitMaterialIndices( geoData.polygonDimensions, geoData.materialIndices );\n\n\t\t\tvar indexNum = 0; // create new indices in numerical order\n\t\t\tvar indexPairs = {}; // original indices mapped to numerical indices\n\n\t\t\tvar prevMaterialIndex;\n\n\t\t\tvar prevStart = 0;\n\t\t\tvar currentCount = 0;\n\n\t\t\tfor ( var i = 0; i < remappedIndices.length; i += 2 ) {\n\n\t\t\t\tvar materialIndex = remappedIndices[ i + 1 ];\n\n\t\t\t\tif ( i === 0 ) matNames[ indexNum ] = tags[ materialIndex ];\n\n\t\t\t\tif ( prevMaterialIndex === undefined ) prevMaterialIndex = materialIndex;\n\n\t\t\t\tif ( materialIndex !== prevMaterialIndex ) {\n\n\t\t\t\t\tvar currentIndex;\n\t\t\t\t\tif ( indexPairs[ tags[ prevMaterialIndex ] ] ) {\n\n\t\t\t\t\t\tcurrentIndex = indexPairs[ tags[ prevMaterialIndex ] ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcurrentIndex = indexNum;\n\t\t\t\t\t\tindexPairs[ tags[ prevMaterialIndex ] ] = indexNum;\n\t\t\t\t\t\tmatNames[ indexNum ] = tags[ prevMaterialIndex ];\n\t\t\t\t\t\tindexNum ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.addGroup( prevStart, currentCount, currentIndex );\n\n\t\t\t\t\tprevStart += currentCount;\n\n\t\t\t\t\tprevMaterialIndex = materialIndex;\n\t\t\t\t\tcurrentCount = 0;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCount += elemSize;\n\n\t\t\t}\n\n\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\tif ( geometry.groups.length > 0 ) {\n\n\t\t\t\tvar currentIndex;\n\t\t\t\tif ( indexPairs[ tags[ materialIndex ] ] ) {\n\n\t\t\t\t\tcurrentIndex = indexPairs[ tags[ materialIndex ] ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentIndex = indexNum;\n\t\t\t\t\tindexPairs[ tags[ materialIndex ] ] = indexNum;\n\t\t\t\t\tmatNames[ indexNum ] = tags[ materialIndex ];\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addGroup( prevStart, currentCount, currentIndex );\n\n\t\t\t}\n\n\t\t\t// Mat names from TAGS chunk, used to build up an array of materials for this geometry\n\t\t\tgeometry.userData.matNames = matNames;\n\n\t\t},\n\n\t\tsplitMaterialIndices( polygonDimensions, indices ) {\n\n\t\t\tvar remappedIndices = [];\n\n\t\t\tpolygonDimensions.forEach( function ( dim, i ) {\n\n\t\t\t\tif ( dim <= 3 ) {\n\n\t\t\t\t\tremappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ] );\n\n\t\t\t\t} else if ( dim === 4 ) {\n\n\t\t\t\t\tremappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ], indices[ i * 2 ], indices[ i * 2 + 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t // ignore > 4 for now\n\t\t\t\t\tfor ( var k = 0; k < dim - 2; k ++ ) {\n\n\t\t\t\t\t\tremappedIndices.push( indices[ i * 2 ], indices[ i * 2 + 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn remappedIndices;\n\n\t\t},\n\n\t\t// UV maps:\n\t\t// 1: are defined via index into an array of points, not into a geometry\n\t\t// - the geometry is also defined by an index into this array, but the indexes may not match\n\t\t// 2: there can be any number of UV maps for a single geometry. Here these are combined,\n\t\t// \twith preference given to the first map encountered\n\t\t// 3: UV maps can be partial - that is, defined for only a part of the geometry\n\t\t// 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n\t\t// UV maps are defined as partially VMAP and partially VMAD\n\t\t// VMADs are currently not supported\n\t\tparseUVs( geometry, layer ) {\n\n\t\t\t// start by creating a UV map set to zero for the whole geometry\n\t\t\tvar remappedUVs = Array.from( Array( geometry.attributes.position.count * 2 ), function () {\n\n\t\t\t\treturn 0;\n\n\t\t\t} );\n\n\t\t\tfor ( var name in layer.uvs ) {\n\n\t\t\t\tvar uvs = layer.uvs[ name ].uvs;\n\t\t\t\tvar uvIndices = layer.uvs[ name ].uvIndices;\n\n\t\t\t\tuvIndices.forEach( function ( i, j ) {\n\n\t\t\t\t\tremappedUVs[ i * 2 ] = uvs[ j * 2 ];\n\t\t\t\t\tremappedUVs[ i * 2 + 1 ] = uvs[ j * 2 + 1 ];\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( remappedUVs, 2 ) );\n\n\t\t},\n\n\t\tparseMorphTargets( geometry, layer ) {\n\n\t\t\tvar num = 0;\n\t\t\tfor ( var name in layer.morphTargets ) {\n\n\t\t\t\tvar remappedPoints = geometry.attributes.position.array.slice();\n\n\t\t\t\tif ( ! geometry.morphAttributes.position ) geometry.morphAttributes.position = [];\n\n\t\t\t\tvar morphPoints = layer.morphTargets[ name ].points;\n\t\t\t\tvar morphIndices = layer.morphTargets[ name ].indices;\n\t\t\t\tvar type = layer.morphTargets[ name ].type;\n\n\t\t\t\tmorphIndices.forEach( function ( i, j ) {\n\n\t\t\t\t\tif ( type === 'relative' ) {\n\n\t\t\t\t\t\tremappedPoints[ i * 3 ] += morphPoints[ j * 3 ];\n\t\t\t\t\t\tremappedPoints[ i * 3 + 1 ] += morphPoints[ j * 3 + 1 ];\n\t\t\t\t\t\tremappedPoints[ i * 3 + 2 ] += morphPoints[ j * 3 + 2 ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tremappedPoints[ i * 3 ] = morphPoints[ j * 3 ];\n\t\t\t\t\t\tremappedPoints[ i * 3 + 1 ] = morphPoints[ j * 3 + 1 ];\n\t\t\t\t\t\tremappedPoints[ i * 3 + 2 ] = morphPoints[ j * 3 + 2 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tgeometry.morphAttributes.position[ num ] = new THREE.Float32BufferAttribute( remappedPoints, 3 );\n\t\t\t\tgeometry.morphAttributes.position[ num ].name = name;\n\n\t\t\t\tnum ++;\n\n\t\t\t}\n\n\t\t\tgeometry.morphTargetsRelative = false;\n\n\t\t},\n\n\t};\n\n\n\t// ************** UTILITY FUNCTIONS **************\n\n\tfunction extractParentUrl( url, dir ) {\n\n\t\tvar index = url.indexOf( dir );\n\n\t\tif ( index === - 1 ) return './';\n\n\t\treturn url.substr( 0, index );\n\n\t}\n\t\n\treturn THREE.LWOLoader;\n});\n"]}