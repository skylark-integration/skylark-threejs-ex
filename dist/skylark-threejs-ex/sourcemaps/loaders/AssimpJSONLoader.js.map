{"version":3,"sources":["loaders/AssimpJSONLoader.js"],"names":["define","THREE","threex","AssimpJSONLoader","manager","this","undefined","DefaultLoadingManager","prototype","constructor","crossOrigin","load","url","onLoad","onProgress","onError","scope","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","text","json","JSON","parse","metadata","__metadata__","format","version","value","setResourcePath","resourcePath","setCrossOrigin","parseList","handler","meshes","Array","length","i","call","textureLoader","TextureLoader","l","face","geometry","BufferGeometry","indices","vertices","normals","uvs","texturecoords","colors","faces","push","setIndex","addAttribute","Float32BufferAttribute","computeBoundingSphere","materials","material","MeshPhongMaterial","properties","property","key","semantic","keyname","texture","wrapS","wrapT","RepeatWrapping","name","color","fromArray","specular","emissive","shininess","flatShading","opacity","transparent","parseObject","node","idx","obj","Object3D","matrix","Matrix4","transformation","transpose","decompose","position","quaternion","scale","add","Mesh","materialindex","children","rootnode","loaders"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAgBH,SAASC,EAAkBC,GAE1BC,KAAKD,aAAwBE,IAAZF,EAA0BA,EAAUH,EAAMM,sBAuR5D,OAnRAJ,EAAiBK,WAEhBC,YAAaN,EAEbO,YAAa,YAEbC,KAAM,SAAWC,EAAKC,EAAQC,EAAYC,GAEzC,IAAIC,EAAQX,KAERY,OAAwBX,IAAfU,EAAMC,KAAuBhB,EAAMiB,YAAYC,eAAgBP,GAAQI,EAAMC,KAEtFG,EAAS,IAAInB,EAAMoB,WAAYhB,KAAKD,SACxCgB,EAAOE,QAASN,EAAMC,MACtBG,EAAOT,KAAMC,EAAK,SAAWW,GAE5B,IAAIC,EAAOC,KAAKC,MAAOH,GACnBI,EAAWH,EAAKI,aAKpB,QAAyB,IAAbD,EAA2B,CAItC,GAAyB,gBAApBA,EAASE,OAGb,YADAd,EAAS,+CAKH,GAAKY,EAASG,QAAU,KAAOH,EAASG,SAAW,IAGzD,YADAf,EAAS,kEAOXF,EAAQG,EAAMU,MAAOF,EAAMP,KAEzBH,EAAYC,IAIhBO,QAAS,SAAWS,GAGnB,OADA1B,KAAKY,KAAOc,EACL1B,MAIR2B,gBAAiB,SAAWD,GAG3B,OADA1B,KAAK4B,aAAeF,EACb1B,MAIR6B,eAAgB,SAAWH,GAG1B,OADA1B,KAAKK,YAAcqB,EACZ1B,MAIRqB,MAAO,SAAWF,EAAMP,GAEvB,SAASkB,EAAWX,EAAMY,GAIzB,IAFA,IAAIC,EAAS,IAAIC,MAAOd,EAAKe,QAEnBC,EAAI,EAAGA,EAAIhB,EAAKe,SAAWC,EAEpCH,EAAQG,GAAMJ,EAAQK,KAAMpC,KAAMmB,EAAMgB,IAIzC,OAAOH,EAuLR,IAAIK,EAAgB,IAAIzC,EAAM0C,cAAetC,KAAKD,SAClDsC,EAAcpB,QAASjB,KAAK4B,cAAgBhB,GAAOiB,eAAgB7B,KAAKK,aAExE,IAAI2B,EAASF,EAAWX,EAAKa,OAtL7B,SAAoBb,GAEnB,IAEIgB,EAAGI,EAAGC,EAFNC,EAAW,IAAI7C,EAAM8C,eAIrBC,KAEAC,EAAWzB,EAAKyB,aAChBC,EAAU1B,EAAK0B,YACfC,EAAM3B,EAAK4B,kBACXC,EAAS7B,EAAK6B,WAIlB,IAFAF,EAAMA,EAAK,OAELX,EAAI,EAAGI,EAAIpB,EAAK8B,MAAMf,OAAQC,EAAII,EAAGJ,IAE1CK,EAAOrB,EAAK8B,MAAOd,GACnBQ,EAAQO,KAAMV,EAAM,GAAKA,EAAM,GAAKA,EAAM,IA2B3C,OAvBAC,EAASU,SAAUR,GACnBF,EAASW,aAAc,WAAY,IAAIxD,EAAMyD,uBAAwBT,EAAU,IAE1EC,EAAQX,OAAS,GAErBO,EAASW,aAAc,SAAU,IAAIxD,EAAMyD,uBAAwBR,EAAS,IAIxEC,EAAIZ,OAAS,GAEjBO,EAASW,aAAc,KAAM,IAAIxD,EAAMyD,uBAAwBP,EAAK,IAIhEE,EAAOd,OAAS,GAEpBO,EAASW,aAAc,QAAS,IAAIxD,EAAMyD,uBAAwBL,EAAQ,IAI3EP,EAASa,wBAEFb,IA0IJc,EAAYzB,EAAWX,EAAKoC,UAtIhC,SAAwBpC,GAEvB,IAAIqC,EAAW,IAAI5D,EAAM6D,kBAEzB,IAAM,IAAItB,KAAKhB,EAAKuC,WAAa,CAEhC,IAAIC,EAAWxC,EAAKuC,WAAYvB,GAC5ByB,EAAMD,EAASC,IACflC,EAAQiC,EAASjC,MAErB,OAASkC,GAER,IAAK,YAEJ,IAAIC,EAAWF,EAASE,SAUxB,GAAkB,IAAbA,GAA+B,IAAbA,GAA+B,IAAbA,GAA+B,IAAbA,GAA+B,IAAbA,EAAiB,CAE7F,IAAIC,EAEJ,OAASD,GAER,KAAK,EACJC,EAAU,MACV,MACD,KAAK,EACJA,EAAU,cACV,MACD,KAAK,EACJA,EAAU,cACV,MACD,KAAK,EACJA,EAAU,UACV,MACD,KAAK,EACJA,EAAU,YAKZ,IAAIC,EAAU1B,EAAc/B,KAAMoB,GAKlCqC,EAAQC,MAAQD,EAAQE,MAAQrE,EAAMsE,eAEtCV,EAAUM,GAAYC,EAIvB,MAID,IAAK,YACJP,EAASW,KAAOzC,EAChB,MAED,IAAK,eACJ8B,EAASY,MAAMC,UAAW3C,GAC1B,MAED,IAAK,gBACJ8B,EAASc,SAASD,UAAW3C,GAC7B,MAED,IAAK,gBACJ8B,EAASe,SAASF,UAAW3C,GAC7B,MAED,IAAK,iBACJ8B,EAASgB,UAAY9C,EACrB,MAED,IAAK,gBAEJ8B,EAASiB,YAA0B,IAAV/C,EACzB,MAED,IAAK,eACCA,EAAQ,IAEZ8B,EAASkB,QAAUhD,EACnB8B,EAASmB,aAAc,IAS3B,OAAOnB,IAkCR,OA9BA,SAASoB,EAAazD,EAAM0D,EAAM7C,EAAQuB,GAEzC,IAAgCpB,EAAG2C,EAA/BC,EAAM,IAAInF,EAAMoF,SAMpB,IAJAD,EAAIZ,KAAOU,EAAKV,MAAQ,GACxBY,EAAIE,QAAS,IAAIrF,EAAMsF,SAAUb,UAAWQ,EAAKM,gBAAiBC,YAClEL,EAAIE,OAAOI,UAAWN,EAAIO,SAAUP,EAAIQ,WAAYR,EAAIS,OAElDrD,EAAI,EAAG0C,EAAK7C,QAAUG,EAAI0C,EAAK7C,OAAOE,OAAQC,IAEnD2C,EAAMD,EAAK7C,OAAQG,GACnB4C,EAAIU,IAAK,IAAI7F,EAAM8F,KAAM1D,EAAQ8C,GAAOvB,EAAWpC,EAAKa,OAAQ8C,GAAMa,iBAIvE,IAAMxD,EAAI,EAAG0C,EAAKe,UAAYzD,EAAI0C,EAAKe,SAAS1D,OAAQC,IAEvD4C,EAAIU,IAAKb,EAAazD,EAAM0D,EAAKe,SAAUzD,GAAKH,EAAQuB,IAIzD,OAAOwB,EASDH,CAAazD,EAAMA,EAAK0E,SAAU7D,EAAQuB,KAM5C1D,EAAOiG,QAAQhG,iBAAmBA","file":"../../loaders/AssimpJSONLoader.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n\r\n\t/**\r\n\t * @author Alexander Gessler / http://www.greentoken.de/\r\n\t * https://github.com/acgessler\r\n\t *\r\n\t * Loader for models imported with Open Asset Import Library (http://assimp.sf.net)\r\n\t * through assimp2json (https://github.com/acgessler/assimp2json).\r\n\t *\r\n\t * Supports any input format that assimp supports, including 3ds, obj, dae, blend,\r\n\t * fbx, x, ms3d, lwo (and many more).\r\n\t *\r\n\t * See webgl_loader_assimp2json example.\r\n\t */\r\n\r\n\tfunction AssimpJSONLoader( manager ) {\r\n\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n\t};\r\n\r\n\tAssimpJSONLoader.prototype = {\r\n\r\n\t\tconstructor: AssimpJSONLoader,\r\n\r\n\t\tcrossOrigin: 'anonymous',\r\n\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tvar path = ( scope.path === undefined ) ? THREE.LoaderUtils.extractUrlBase( url ) : scope.path;\r\n\r\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\r\n\t\t\tloader.setPath( scope.path );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\t\tvar json = JSON.parse( text );\r\n\t\t\t\tvar metadata = json.__metadata__;\r\n\r\n\t\t\t\t// check if __metadata__ meta header is present\r\n\t\t\t\t// this header is used to disambiguate between different JSON-based file formats\r\n\r\n\t\t\t\tif ( typeof metadata !== 'undefined' ) {\r\n\r\n\t\t\t\t\t// check if assimp2json at all\r\n\r\n\t\t\t\t\tif ( metadata.format !== 'assimp2json' ) {\r\n\r\n\t\t\t\t\t\tonError( 'AssimpJSONLoader: Not an assimp2json scene.' );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t// check major format version\r\n\r\n\t\t\t\t\t} else if ( metadata.version < 100 && metadata.version >= 200 ) {\r\n\r\n\t\t\t\t\t\tonError( 'AssimpJSONLoader: Unsupported assimp2json file format version.' );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tonLoad( scope.parse( json, path ) );\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t},\r\n\r\n\t\tsetPath: function ( value ) {\r\n\r\n\t\t\tthis.path = value;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetResourcePath: function ( value ) {\r\n\r\n\t\t\tthis.resourcePath = value;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\t\tthis.crossOrigin = value;\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tparse: function ( json, path ) {\r\n\r\n\t\t\tfunction parseList( json, handler ) {\r\n\r\n\t\t\t\tvar meshes = new Array( json.length );\r\n\r\n\t\t\t\tfor ( var i = 0; i < json.length; ++ i ) {\r\n\r\n\t\t\t\t\tmeshes[ i ] = handler.call( this, json[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn meshes;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseMesh( json ) {\r\n\r\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\t\t\t\tvar i, l, face;\r\n\r\n\t\t\t\tvar indices = [];\r\n\r\n\t\t\t\tvar vertices = json.vertices || [];\r\n\t\t\t\tvar normals = json.normals || [];\r\n\t\t\t\tvar uvs = json.texturecoords || [];\r\n\t\t\t\tvar colors = json.colors || [];\r\n\r\n\t\t\t\tuvs = uvs[ 0 ] || []; // only support for a single set of uvs\r\n\r\n\t\t\t\tfor ( i = 0, l = json.faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tface = json.faces[ i ];\r\n\t\t\t\t\tindices.push( face[ 0 ], face[ 1 ], face[ 2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.setIndex( indices );\r\n\t\t\t\tgeometry.addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\r\n\r\n\t\t\t\tif ( normals.length > 0 ) {\r\n\r\n\t\t\t\t\tgeometry.addAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( uvs.length > 0 ) {\r\n\r\n\t\t\t\t\tgeometry.addAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( colors.length > 0 ) {\r\n\r\n\t\t\t\t\tgeometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.computeBoundingSphere();\r\n\r\n\t\t\t\treturn geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseMaterial( json ) {\r\n\r\n\t\t\t\tvar material = new THREE.MeshPhongMaterial();\r\n\r\n\t\t\t\tfor ( var i in json.properties ) {\r\n\r\n\t\t\t\t\tvar property = json.properties[ i ];\r\n\t\t\t\t\tvar key = property.key;\r\n\t\t\t\t\tvar value = property.value;\r\n\r\n\t\t\t\t\tswitch ( key ) {\r\n\r\n\t\t\t\t\t\tcase '$tex.file': {\r\n\r\n\t\t\t\t\t\t\tvar semantic = property.semantic;\r\n\r\n\t\t\t\t\t\t\t// prop.semantic gives the type of the texture\r\n\t\t\t\t\t\t\t// 1: diffuse\r\n\t\t\t\t\t\t\t// 2: specular map\r\n\t\t\t\t\t\t\t// 4: emissive map\r\n\t\t\t\t\t\t\t// 5: height map (bumps)\r\n\t\t\t\t\t\t\t// 6: normal map\r\n\t\t\t\t\t\t\t// more values (i.e. environment, etc) are known by assimp and may be relevant\r\n\r\n\t\t\t\t\t\t\tif ( semantic === 1 || semantic === 2 || semantic === 4 || semantic === 5 || semantic === 6 ) {\r\n\r\n\t\t\t\t\t\t\t\tvar keyname;\r\n\r\n\t\t\t\t\t\t\t\tswitch ( semantic ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\t\t\t\t\tkeyname = 'map';\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\t\t\t\tkeyname = 'specularMap';\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\t\t\t\tkeyname = 'emissiveMap';\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\tcase 5:\r\n\t\t\t\t\t\t\t\t\t\tkeyname = 'bumpMap';\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\tcase 6:\r\n\t\t\t\t\t\t\t\t\t\tkeyname = 'normalMap';\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tvar texture = textureLoader.load( value );\r\n\r\n\t\t\t\t\t\t\t\t// TODO: read texture settings from assimp.\r\n\t\t\t\t\t\t\t\t// Wrapping is the default, though.\r\n\r\n\t\t\t\t\t\t\t\ttexture.wrapS = texture.wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t\t\t\t\t\tmaterial[ keyname ] = texture;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcase '?mat.name':\r\n\t\t\t\t\t\t\tmaterial.name = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase '$clr.diffuse':\r\n\t\t\t\t\t\t\tmaterial.color.fromArray( value );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase '$clr.specular':\r\n\t\t\t\t\t\t\tmaterial.specular.fromArray( value );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase '$clr.emissive':\r\n\t\t\t\t\t\t\tmaterial.emissive.fromArray( value );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase '$mat.shininess':\r\n\t\t\t\t\t\t\tmaterial.shininess = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase '$mat.shadingm':\r\n\t\t\t\t\t\t\t// aiShadingMode_Flat\r\n\t\t\t\t\t\t\tmaterial.flatShading = ( value === 1 ) ? true : false;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase '$mat.opacity':\r\n\t\t\t\t\t\t\tif ( value < 1 ) {\r\n\r\n\t\t\t\t\t\t\t\tmaterial.opacity = value;\r\n\t\t\t\t\t\t\t\tmaterial.transparent = true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn material;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseObject( json, node, meshes, materials ) {\r\n\r\n\t\t\t\tvar obj = new THREE.Object3D(),\ti, idx;\r\n\r\n\t\t\t\tobj.name = node.name || '';\r\n\t\t\t\tobj.matrix = new THREE.Matrix4().fromArray( node.transformation ).transpose();\r\n\t\t\t\tobj.matrix.decompose( obj.position, obj.quaternion, obj.scale );\r\n\r\n\t\t\t\tfor ( i = 0; node.meshes && i < node.meshes.length; i ++ ) {\r\n\r\n\t\t\t\t\tidx = node.meshes[ i ];\r\n\t\t\t\t\tobj.add( new THREE.Mesh( meshes[ idx ], materials[ json.meshes[ idx ].materialindex ] ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0; node.children && i < node.children.length; i ++ ) {\r\n\r\n\t\t\t\t\tobj.add( parseObject( json, node.children[ i ], meshes, materials ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn obj;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar textureLoader = new THREE.TextureLoader( this.manager );\r\n\t\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\r\n\r\n\t\t\tvar meshes = parseList( json.meshes, parseMesh );\r\n\t\t\tvar materials = parseList( json.materials, parseMaterial );\r\n\t\t\treturn parseObject( json, json.rootnode, meshes, materials );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\t\r\n\treturn threex.loaders.AssimpJSONLoader = AssimpJSONLoader;\r\n});"]}