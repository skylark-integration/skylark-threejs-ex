{"version":3,"sources":["loaders/MMDLoader.js"],"names":["define","THREE","MMDParser","MMDLoader","manager","Loader","call","this","loader","FileLoader","parser","meshBuilder","MeshBuilder","animationBuilder","AnimationBuilder","prototype","Object","assign","create","constructor","setAnimationPath","animationPath","load","url","onLoad","onProgress","onError","resourcePath","builder","setCrossOrigin","crossOrigin","path","LoaderUtils","extractUrlBase","modelExtension","_extractExtension","toLowerCase","data","build","Error","loadAnimation","object","loadVMD","vmd","isCamera","buildCameraAnimation","loadWithAnimation","modelUrl","vmdUrl","scope","mesh","animation","loadPMD","_getParser","setMimeType","undefined","setPath","setResponseType","buffer","parsePmd","loadPMX","parsePmx","urls","Array","isArray","vmds","vmdNum","length","i","il","push","parseVmd","mergeVmds","loadVPD","isUnicode","text","parseVpd","index","lastIndexOf","slice","Parser","DEFAULT_TOON_TEXTURES","geometryBuilder","GeometryBuilder","materialBuilder","MaterialBuilder","textureLoader","TextureLoader","tgaLoader","CubicBezierInterpolation","parameterPositions","sampleValues","sampleSize","resultBuffer","params","Interpolant","interpolationParams","geometry","material","setResourcePath","SkinnedMesh","skeleton","Skeleton","bone","gbone","bones","Bone","name","position","fromArray","pos","quaternion","rotq","scl","scale","parent","add","updateMatrixWorld","initBones","bind","positions","uvs","normals","indices","groups","skinIndices","skinWeights","morphTargets","morphPositions","iks","grants","rigidBodies","constraints","offset","boneTypeTable","metadata","vertexCount","v","vertices","j","jl","normal","uv","faceCount","face","faces","materialCount","materials","count","rigidBodyCount","body","value","boneIndex","type","Math","max","boneCount","boneData","parentIndex","rigidBodyType","format","ikCount","param","target","ik","effector","iteration","maxAngle","links","link","enabled","indexOf","limitation","Vector3","angleLimitation","rotationMin","lowerLimitationAngle","rotationMax","upperLimitationAngle","tmp1","tmp2","grant","ratio","isLocal","affectRotation","affectPosition","transformationClass","sort","a","b","updateAttributes","attribute","morph","elementCount","element","elements","morphs","array","morphCount","Float32BufferAttribute","morph2","rigidBody","key","constraintCount","constraint","bodyA","rigidBodyIndex1","bodyB","rigidBodyIndex2","BufferGeometry","setAttribute","Uint16BufferAttribute","setIndex","addGroup","morphAttributes","morphTargetsRelative","userData","MMD","computeBoundingSphere","textures","color","Color","diffuse","opacity","specular","emissive","ambient","shininess","transparent","skinning","fog","blending","CustomBlending","blendSrc","SrcAlphaFactor","blendDst","OneMinusSrcAlphaFactor","blendSrcAlpha","blendDstAlpha","DstAlphaFactor","flag","side","DoubleSide","FrontSide","fileName","fileNames","split","map","_loadTexture","extension","envMap","sphericalReflectionMapping","combine","MultiplyOperation","AddOperation","toonFileName","toonIndex","toonTextures","gradientMap","isToonTexture","isDefaultToonTexture","_isDefaultToonTexture","outlineParameters","thickness","edgeFlag","alpha","visible","isDefaultToon","textureIndex","envTextureIndex","envFlag","toonFlag","edgeSize","edgeColor","_checkImageTransparency","multiplyScalar","MeshToonMaterial","checkAlphaMorph","_getTGALoader","TGALoader","test","filePath","fullPath","parseInt","match","e","console","warn","getHandler","texture","t","image","_getRotatedImage","magFilter","NearestFilter","minFilter","flipY","wrapS","RepeatWrapping","wrapT","readyCallbacks","mapping","SphericalReflectionMapping","canvas","document","createElement","context","getContext","width","height","clearRect","translate","rotate","PI","drawImage","getImageData","groupIndex","getAlphaByUv","x","round","y","imageData","createImageData","group","centerUV","detectImageTransparency","attributes","start","tracks","buildSkeletalAnimation","tracks2","buildMorphAnimation","AnimationClip","pushInterpolation","interpolation","motions","boneNameDictionary","motionCount","motion","boneName","frameNum","times","rotations","pInterpolations","rInterpolations","basePosition","getBoneByName","toArray","time","rotation","targetName","_createTrack","VectorKeyframeTrack","QuaternionKeyframeTrack","morphTargetDictionary","morphName","values","weight","NumberKeyframeTrack","pushVector3","vec","z","cameras","q","centers","quaternions","fovs","cInterpolations","qInterpolations","fInterpolations","Quaternion","euler","Euler","center","rot","distance","fov","set","setFromEuler","applyQuaternion","w","node","typedKeyframeTrack","interpolations","stride","interpolateStride","aheadIndex","endIndex","track","createInterpolant","result","getValueSize","Float32Array","interpolate_","i1","t0","t1","valueSize","offset1","offset0","weight1","x1","x2","y1","y2","_calculate","slerpFlat","sst3","stt3","ttt","c","s","math","ft","abs"],"mappings":"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","file":"../../loaders/MMDLoader.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"../utils/mmdparser\",\n\t\"../loaders/TGALoader\"\n],function(THREE,MMDParser){\n\t/**\n\t * @author takahiro / https://github.com/takahirox\n\t *\n\t * Dependencies\n\t *  - mmd-parser https://github.com/takahirox/mmd-parser\n\t *  - THREE.TGALoader\n\t *  - THREE.OutlineEffect\n\t *\n\t * MMDLoader creates Three.js Objects from MMD resources as\n\t * PMD, PMX, VMD, and VPD files.\n\t *\n\t * PMD/PMX is a model data format, VMD is a motion data format\n\t * VPD is a posing data format used in MMD(Miku Miku Dance).\n\t *\n\t * MMD official site\n\t *  - https://sites.google.com/view/evpvp/\n\t *\n\t * PMD, VMD format (in Japanese)\n\t *  - http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4\n\t *\n\t * PMX format\n\t *  - https://gist.github.com/felixjones/f8a06bd48f9da9a4539f\n\t *\n\t * TODO\n\t *  - light motion in vmd support.\n\t *  - SDEF support.\n\t *  - uv/material/bone morphing support.\n\t *  - more precise grant skinning support.\n\t *  - shadow support.\n\t */\n\n\tTHREE.MMDLoader = ( function () {\n\n\t\t/**\n\t\t * @param {THREE.LoadingManager} manager\n\t\t */\n\t\tfunction MMDLoader( manager ) {\n\n\t\t\tTHREE.Loader.call( this, manager );\n\n\t\t\tthis.loader = new THREE.FileLoader( this.manager );\n\n\t\t\tthis.parser = null; // lazy generation\n\t\t\tthis.meshBuilder = new MeshBuilder( this.manager );\n\t\t\tthis.animationBuilder = new AnimationBuilder();\n\n\t\t}\n\n\t\tMMDLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\t\tconstructor: MMDLoader,\n\n\t\t\t/**\n\t\t\t * @param {string} animationPath\n\t\t\t * @return {THREE.MMDLoader}\n\t\t\t */\n\t\t\tsetAnimationPath: function ( animationPath ) {\n\n\t\t\t\tthis.animationPath = animationPath;\n\t\t\t\treturn this;\n\n\t\t\t},\n\n\t\t\t// Load MMD assets as Three.js Object\n\n\t\t\t/**\n\t\t\t * Loads Model file (.pmd or .pmx) as a THREE.SkinnedMesh.\n\t\t\t *\n\t\t\t * @param {string} url - url to Model(.pmd or .pmx) file\n\t\t\t * @param {function} onLoad\n\t\t\t * @param {function} onProgress\n\t\t\t * @param {function} onError\n\t\t\t */\n\t\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar builder = this.meshBuilder.setCrossOrigin( this.crossOrigin );\n\n\t\t\t\t// resource path\n\n\t\t\t\tvar resourcePath;\n\n\t\t\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\t\t\tresourcePath = this.resourcePath;\n\n\t\t\t\t} else if ( this.path !== '' ) {\n\n\t\t\t\t\tresourcePath = this.path;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresourcePath = THREE.LoaderUtils.extractUrlBase( url );\n\n\t\t\t\t}\n\n\t\t\t\tvar modelExtension = this._extractExtension( url ).toLowerCase();\n\n\t\t\t\t// Should I detect by seeing header?\n\t\t\t\tif ( modelExtension !== 'pmd' && modelExtension !== 'pmx' ) {\n\n\t\t\t\t\tif ( onError ) onError( new Error( 'THREE.MMDLoader: Unknown model file extension .' + modelExtension + '.' ) );\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tthis[ modelExtension === 'pmd' ? 'loadPMD' : 'loadPMX' ]( url, function ( data ) {\n\n\t\t\t\t\tonLoad(\tbuilder.build( data, resourcePath, onProgress, onError )\t);\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Loads Motion file(s) (.vmd) as a THREE.AnimationClip.\n\t\t\t * If two or more files are specified, they'll be merged.\n\t\t\t *\n\t\t\t * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n\t\t\t * @param {THREE.SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n\t\t\t * @param {function} onLoad\n\t\t\t * @param {function} onProgress\n\t\t\t * @param {function} onError\n\t\t\t */\n\t\t\tloadAnimation: function ( url, object, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar builder = this.animationBuilder;\n\n\t\t\t\tthis.loadVMD( url, function ( vmd ) {\n\n\t\t\t\t\tonLoad( object.isCamera\n\t\t\t\t\t\t? builder.buildCameraAnimation( vmd )\n\t\t\t\t\t\t: builder.build( vmd, object ) );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Loads mode file and motion file(s) as an object containing\n\t\t\t * a THREE.SkinnedMesh and a THREE.AnimationClip.\n\t\t\t * Tracks of THREE.AnimationClip are fitting to the model.\n\t\t\t *\n\t\t\t * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n\t\t\t * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n\t\t\t * @param {function} onLoad\n\t\t\t * @param {function} onProgress\n\t\t\t * @param {function} onError\n\t\t\t */\n\t\t\tloadWithAnimation: function ( modelUrl, vmdUrl, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tthis.load( modelUrl, function ( mesh ) {\n\n\t\t\t\t\tscope.loadAnimation( vmdUrl, mesh, function ( animation ) {\n\n\t\t\t\t\t\tonLoad( {\n\t\t\t\t\t\t\tmesh: mesh,\n\t\t\t\t\t\t\tanimation: animation\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}, onProgress, onError );\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t},\n\n\t\t\t// Load MMD assets as Object data parsed by MMDParser\n\n\t\t\t/**\n\t\t\t * Loads .pmd file as an Object.\n\t\t\t *\n\t\t\t * @param {string} url - url to .pmd file\n\t\t\t * @param {function} onLoad\n\t\t\t * @param {function} onProgress\n\t\t\t * @param {function} onError\n\t\t\t */\n\t\t\tloadPMD: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar parser = this._getParser();\n\n\t\t\t\tthis.loader\n\t\t\t\t\t.setMimeType( undefined )\n\t\t\t\t\t.setPath( this.path )\n\t\t\t\t\t.setResponseType( 'arraybuffer' )\n\t\t\t\t\t.load( url, function ( buffer ) {\n\n\t\t\t\t\t\tonLoad( parser.parsePmd( buffer, true ) );\n\n\t\t\t\t\t}, onProgress, onError );\n\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Loads .pmx file as an Object.\n\t\t\t *\n\t\t\t * @param {string} url - url to .pmx file\n\t\t\t * @param {function} onLoad\n\t\t\t * @param {function} onProgress\n\t\t\t * @param {function} onError\n\t\t\t */\n\t\t\tloadPMX: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar parser = this._getParser();\n\n\t\t\t\tthis.loader\n\t\t\t\t\t.setMimeType( undefined )\n\t\t\t\t\t.setPath( this.path )\n\t\t\t\t\t.setResponseType( 'arraybuffer' )\n\t\t\t\t\t.load( url, function ( buffer ) {\n\n\t\t\t\t\t\tonLoad( parser.parsePmx( buffer, true ) );\n\n\t\t\t\t\t}, onProgress, onError );\n\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Loads .vmd file as an Object. If two or more files are specified\n\t\t\t * they'll be merged.\n\t\t\t *\n\t\t\t * @param {string|Array<string>} url - url(s) to .vmd file(s)\n\t\t\t * @param {function} onLoad\n\t\t\t * @param {function} onProgress\n\t\t\t * @param {function} onError\n\t\t\t */\n\t\t\tloadVMD: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar urls = Array.isArray( url ) ? url : [ url ];\n\n\t\t\t\tvar vmds = [];\n\t\t\t\tvar vmdNum = urls.length;\n\n\t\t\t\tvar parser = this._getParser();\n\n\t\t\t\tthis.loader\n\t\t\t\t\t.setMimeType( undefined )\n\t\t\t\t\t.setPath( this.animationPath )\n\t\t\t\t\t.setResponseType( 'arraybuffer' );\n\n\t\t\t\tfor ( var i = 0, il = urls.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.loader.load( urls[ i ], function ( buffer ) {\n\n\t\t\t\t\t\tvmds.push( parser.parseVmd( buffer, true ) );\n\n\t\t\t\t\t\tif ( vmds.length === vmdNum ) onLoad( parser.mergeVmds( vmds ) );\n\n\t\t\t\t\t}, onProgress, onError );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Loads .vpd file as an Object.\n\t\t\t *\n\t\t\t * @param {string} url - url to .vpd file\n\t\t\t * @param {boolean} isUnicode\n\t\t\t * @param {function} onLoad\n\t\t\t * @param {function} onProgress\n\t\t\t * @param {function} onError\n\t\t\t */\n\t\t\tloadVPD: function ( url, isUnicode, onLoad, onProgress, onError ) {\n\n\t\t\t\tvar parser = this._getParser();\n\n\t\t\t\tthis.loader\n\t\t\t\t\t.setMimeType( isUnicode ? undefined : 'text/plain; charset=shift_jis' )\n\t\t\t\t\t.setPath( this.animationPath )\n\t\t\t\t\t.setResponseType( 'text' )\n\t\t\t\t\t.load( url, function ( text ) {\n\n\t\t\t\t\t\tonLoad( parser.parseVpd( text, true ) );\n\n\t\t\t\t\t}, onProgress, onError );\n\n\t\t\t},\n\n\t\t\t// private methods\n\n\t\t\t_extractExtension: function ( url ) {\n\n\t\t\t\tvar index = url.lastIndexOf( '.' );\n\t\t\t\treturn index < 0 ? '' : url.slice( index + 1 );\n\n\t\t\t},\n\n\t\t\t_getParser: function () {\n\n\t\t\t\tif ( this.parser === null ) {\n\n\t\t\t\t\tif ( typeof MMDParser === 'undefined' ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.MMDLoader: Import MMDParser https://github.com/takahirox/mmd-parser' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.parser = new MMDParser.Parser();\n\n\t\t\t\t}\n\n\t\t\t\treturn this.parser;\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Utilities\n\n\t\t/*\n\t\t * base64 encoded defalut toon textures toon00.bmp - toon10.bmp.\n\t\t * We don't need to request external toon image files.\n\t\t * This idea is from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n\t\t */\n\t\tvar DEFAULT_TOON_TEXTURES = [\n\t\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n\t\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==',\n\t\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC',\n\t\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==',\n\t\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==',\n\t\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=',\n\t\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=',\n\t\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n\t\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n\t\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n\t\t\t'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII='\n\t\t];\n\n\t\t// Builders. They build Three.js object from Object data parsed by MMDParser.\n\n\t\t/**\n\t\t * @param {THREE.LoadingManager} manager\n\t\t */\n\t\tfunction MeshBuilder( manager ) {\n\n\t\t\tthis.geometryBuilder = new GeometryBuilder();\n\t\t\tthis.materialBuilder = new MaterialBuilder( manager );\n\n\t\t}\n\n\t\tMeshBuilder.prototype = {\n\n\t\t\tconstructor: MeshBuilder,\n\n\t\t\tcrossOrigin: 'anonymous',\n\n\t\t\t/**\n\t\t\t * @param {string} crossOrigin\n\t\t\t * @return {MeshBuilder}\n\t\t\t */\n\t\t\tsetCrossOrigin: function ( crossOrigin ) {\n\n\t\t\t\tthis.crossOrigin = crossOrigin;\n\t\t\t\treturn this;\n\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @param {Object} data - parsed PMD/PMX data\n\t\t\t * @param {string} resourcePath\n\t\t\t * @param {function} onProgress\n\t\t\t * @param {function} onError\n\t\t\t * @return {THREE.SkinnedMesh}\n\t\t\t */\n\t\t\tbuild: function ( data, resourcePath, onProgress, onError ) {\n\n\t\t\t\tvar geometry = this.geometryBuilder.build( data );\n\t\t\t\tvar material = this.materialBuilder\n\t\t\t\t\t.setCrossOrigin( this.crossOrigin )\n\t\t\t\t\t.setResourcePath( resourcePath )\n\t\t\t\t\t.build( data, geometry, onProgress, onError );\n\n\t\t\t\tvar mesh = new THREE.SkinnedMesh( geometry, material );\n\n\t\t\t\tvar skeleton = new THREE.Skeleton( initBones( mesh ) );\n\t\t\t\tmesh.bind( skeleton );\n\n\t\t\t\t// console.log( mesh ); // for console debug\n\n\t\t\t\treturn mesh;\n\n\t\t\t}\n\n\t\t};\n\n\t\t// TODO: Try to remove this function\n\n\t\tfunction initBones( mesh ) {\n\n\t\t\tvar geometry = mesh.geometry;\n\n\t\t\tvar bones = [], bone, gbone;\n\t\t\tvar i, il;\n\n\t\t\tif ( geometry && geometry.bones !== undefined ) {\n\n\t\t\t\t// first, create array of 'Bone' objects from geometry data\n\n\t\t\t\tfor ( i = 0, il = geometry.bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tgbone = geometry.bones[ i ];\n\n\t\t\t\t\t// create new 'Bone' object\n\n\t\t\t\t\tbone = new THREE.Bone();\n\t\t\t\t\tbones.push( bone );\n\n\t\t\t\t\t// apply values\n\n\t\t\t\t\tbone.name = gbone.name;\n\t\t\t\t\tbone.position.fromArray( gbone.pos );\n\t\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\n\t\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\n\n\t\t\t\t}\n\n\t\t\t\t// second, create bone hierarchy\n\n\t\t\t\tfor ( i = 0, il = geometry.bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tgbone = geometry.bones[ i ];\n\n\t\t\t\t\tif ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {\n\n\t\t\t\t\t\t// subsequent bones in the hierarchy\n\n\t\t\t\t\t\tbones[ gbone.parent ].add( bones[ i ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// topmost bone, immediate child of the skinned mesh\n\n\t\t\t\t\t\tmesh.add( bones[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// now the bones are part of the scene graph and children of the skinned mesh.\n\t\t\t// let's update the corresponding matrices\n\n\t\t\tmesh.updateMatrixWorld( true );\n\n\t\t\treturn bones;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction GeometryBuilder() {\n\n\t\t}\n\n\t\tGeometryBuilder.prototype = {\n\n\t\t\tconstructor: GeometryBuilder,\n\n\t\t\t/**\n\t\t\t * @param {Object} data - parsed PMD/PMX data\n\t\t\t * @return {THREE.BufferGeometry}\n\t\t\t */\n\t\t\tbuild: function ( data ) {\n\n\t\t\t\t// for geometry\n\t\t\t\tvar positions = [];\n\t\t\t\tvar uvs = [];\n\t\t\t\tvar normals = [];\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tvar groups = [];\n\n\t\t\t\tvar bones = [];\n\t\t\t\tvar skinIndices = [];\n\t\t\t\tvar skinWeights = [];\n\n\t\t\t\tvar morphTargets = [];\n\t\t\t\tvar morphPositions = [];\n\n\t\t\t\tvar iks = [];\n\t\t\t\tvar grants = [];\n\n\t\t\t\tvar rigidBodies = [];\n\t\t\t\tvar constraints = [];\n\n\t\t\t\t// for work\n\t\t\t\tvar offset = 0;\n\t\t\t\tvar boneTypeTable = {};\n\n\t\t\t\t// positions, normals, uvs, skinIndices, skinWeights\n\n\t\t\t\tfor ( var i = 0; i < data.metadata.vertexCount; i ++ ) {\n\n\t\t\t\t\tvar v = data.vertices[ i ];\n\n\t\t\t\t\tfor ( var j = 0, jl = v.position.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tpositions.push( v.position[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var j = 0, jl = v.normal.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tnormals.push( v.normal[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var j = 0, jl = v.uv.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tuvs.push( v.uv[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\tskinIndices.push( v.skinIndices.length - 1 >= j ? v.skinIndices[ j ] : 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\tskinWeights.push( v.skinWeights.length - 1 >= j ? v.skinWeights[ j ] : 0.0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// indices\n\n\t\t\t\tfor ( var i = 0; i < data.metadata.faceCount; i ++ ) {\n\n\t\t\t\t\tvar face = data.faces[ i ];\n\n\t\t\t\t\tfor ( var j = 0, jl = face.indices.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tindices.push( face.indices[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// groups\n\n\t\t\t\tfor ( var i = 0; i < data.metadata.materialCount; i ++ ) {\n\n\t\t\t\t\tvar material = data.materials[ i ];\n\n\t\t\t\t\tgroups.push( {\n\t\t\t\t\t\toffset: offset * 3,\n\t\t\t\t\t\tcount: material.faceCount * 3\n\t\t\t\t\t} );\n\n\t\t\t\t\toffset += material.faceCount;\n\n\t\t\t\t}\n\n\t\t\t\t// bones\n\n\t\t\t\tfor ( var i = 0; i < data.metadata.rigidBodyCount; i ++ ) {\n\n\t\t\t\t\tvar body = data.rigidBodies[ i ];\n\t\t\t\t\tvar value = boneTypeTable[ body.boneIndex ];\n\n\t\t\t\t\t// keeps greater number if already value is set without any special reasons\n\t\t\t\t\tvalue = value === undefined ? body.type : Math.max( body.type, value );\n\n\t\t\t\t\tboneTypeTable[ body.boneIndex ] = value;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < data.metadata.boneCount; i ++ ) {\n\n\t\t\t\t\tvar boneData = data.bones[ i ];\n\n\t\t\t\t\tvar bone = {\n\t\t\t\t\t\tparent: boneData.parentIndex,\n\t\t\t\t\t\tname: boneData.name,\n\t\t\t\t\t\tpos: boneData.position.slice( 0, 3 ),\n\t\t\t\t\t\trotq: [ 0, 0, 0, 1 ],\n\t\t\t\t\t\tscl: [ 1, 1, 1 ],\n\t\t\t\t\t\trigidBodyType: boneTypeTable[ i ] !== undefined ? boneTypeTable[ i ] : - 1\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( bone.parent !== - 1 ) {\n\n\t\t\t\t\t\tbone.pos[ 0 ] -= data.bones[ bone.parent ].position[ 0 ];\n\t\t\t\t\t\tbone.pos[ 1 ] -= data.bones[ bone.parent ].position[ 1 ];\n\t\t\t\t\t\tbone.pos[ 2 ] -= data.bones[ bone.parent ].position[ 2 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbones.push( bone );\n\n\t\t\t\t}\n\n\t\t\t\t// iks\n\n\t\t\t\t// TODO: remove duplicated codes between PMD and PMX\n\t\t\t\tif ( data.metadata.format === 'pmd' ) {\n\n\t\t\t\t\tfor ( var i = 0; i < data.metadata.ikCount; i ++ ) {\n\n\t\t\t\t\t\tvar ik = data.iks[ i ];\n\n\t\t\t\t\t\tvar param = {\n\t\t\t\t\t\t\ttarget: ik.target,\n\t\t\t\t\t\t\teffector: ik.effector,\n\t\t\t\t\t\t\titeration: ik.iteration,\n\t\t\t\t\t\t\tmaxAngle: ik.maxAngle * 4,\n\t\t\t\t\t\t\tlinks: []\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor ( var j = 0, jl = ik.links.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar link = {};\n\t\t\t\t\t\t\tlink.index = ik.links[ j ].index;\n\t\t\t\t\t\t\tlink.enabled = true;\n\n\t\t\t\t\t\t\tif ( data.bones[ link.index ].name.indexOf( 'ひざ' ) >= 0 ) {\n\n\t\t\t\t\t\t\t\tlink.limitation = new THREE.Vector3( 1.0, 0.0, 0.0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tparam.links.push( link );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tiks.push( param );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var i = 0; i < data.metadata.boneCount; i ++ ) {\n\n\t\t\t\t\t\tvar ik = data.bones[ i ].ik;\n\n\t\t\t\t\t\tif ( ik === undefined ) continue;\n\n\t\t\t\t\t\tvar param = {\n\t\t\t\t\t\t\ttarget: i,\n\t\t\t\t\t\t\teffector: ik.effector,\n\t\t\t\t\t\t\titeration: ik.iteration,\n\t\t\t\t\t\t\tmaxAngle: ik.maxAngle,\n\t\t\t\t\t\t\tlinks: []\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor ( var j = 0, jl = ik.links.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar link = {};\n\t\t\t\t\t\t\tlink.index = ik.links[ j ].index;\n\t\t\t\t\t\t\tlink.enabled = true;\n\n\t\t\t\t\t\t\tif ( ik.links[ j ].angleLimitation === 1 ) {\n\n\t\t\t\t\t\t\t\t// Revert if rotationMin/Max doesn't work well\n\t\t\t\t\t\t\t\t// link.limitation = new THREE.Vector3( 1.0, 0.0, 0.0 );\n\n\t\t\t\t\t\t\t\tvar rotationMin = ik.links[ j ].lowerLimitationAngle;\n\t\t\t\t\t\t\t\tvar rotationMax = ik.links[ j ].upperLimitationAngle;\n\n\t\t\t\t\t\t\t\t// Convert Left to Right coordinate by myself because\n\t\t\t\t\t\t\t\t// MMDParser doesn't convert. It's a MMDParser's bug\n\n\t\t\t\t\t\t\t\tvar tmp1 = - rotationMax[ 0 ];\n\t\t\t\t\t\t\t\tvar tmp2 = - rotationMax[ 1 ];\n\t\t\t\t\t\t\t\trotationMax[ 0 ] = - rotationMin[ 0 ];\n\t\t\t\t\t\t\t\trotationMax[ 1 ] = - rotationMin[ 1 ];\n\t\t\t\t\t\t\t\trotationMin[ 0 ] = tmp1;\n\t\t\t\t\t\t\t\trotationMin[ 1 ] = tmp2;\n\n\t\t\t\t\t\t\t\tlink.rotationMin = new THREE.Vector3().fromArray( rotationMin );\n\t\t\t\t\t\t\t\tlink.rotationMax = new THREE.Vector3().fromArray( rotationMax );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tparam.links.push( link );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tiks.push( param );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// grants\n\n\t\t\t\tif ( data.metadata.format === 'pmx' ) {\n\n\t\t\t\t\tfor ( var i = 0; i < data.metadata.boneCount; i ++ ) {\n\n\t\t\t\t\t\tvar boneData = data.bones[ i ];\n\t\t\t\t\t\tvar grant = boneData.grant;\n\n\t\t\t\t\t\tif ( grant === undefined ) continue;\n\n\t\t\t\t\t\tvar param = {\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tparentIndex: grant.parentIndex,\n\t\t\t\t\t\t\tratio: grant.ratio,\n\t\t\t\t\t\t\tisLocal: grant.isLocal,\n\t\t\t\t\t\t\taffectRotation: grant.affectRotation,\n\t\t\t\t\t\t\taffectPosition: grant.affectPosition,\n\t\t\t\t\t\t\ttransformationClass: boneData.transformationClass\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tgrants.push( param );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgrants.sort( function ( a, b ) {\n\n\t\t\t\t\t\treturn a.transformationClass - b.transformationClass;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\t// morph\n\n\t\t\t\tfunction updateAttributes( attribute, morph, ratio ) {\n\n\t\t\t\t\tfor ( var i = 0; i < morph.elementCount; i ++ ) {\n\n\t\t\t\t\t\tvar element = morph.elements[ i ];\n\n\t\t\t\t\t\tvar index;\n\n\t\t\t\t\t\tif ( data.metadata.format === 'pmd' ) {\n\n\t\t\t\t\t\t\tindex = data.morphs[ 0 ].elements[ element.index ].index;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tindex = element.index;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tattribute.array[ index * 3 + 0 ] += element.position[ 0 ] * ratio;\n\t\t\t\t\t\tattribute.array[ index * 3 + 1 ] += element.position[ 1 ] * ratio;\n\t\t\t\t\t\tattribute.array[ index * 3 + 2 ] += element.position[ 2 ] * ratio;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < data.metadata.morphCount; i ++ ) {\n\n\t\t\t\t\tvar morph = data.morphs[ i ];\n\t\t\t\t\tvar params = { name: morph.name };\n\n\t\t\t\t\tvar attribute = new THREE.Float32BufferAttribute( data.metadata.vertexCount * 3, 3 );\n\t\t\t\t\tattribute.name = morph.name;\n\n\t\t\t\t\tfor ( var j = 0; j < data.metadata.vertexCount * 3; j ++ ) {\n\n\t\t\t\t\t\tattribute.array[ j ] = positions[ j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data.metadata.format === 'pmd' ) {\n\n\t\t\t\t\t\tif ( i !== 0 ) {\n\n\t\t\t\t\t\t\tupdateAttributes( attribute, morph, 1.0 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( morph.type === 0 ) { // group\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < morph.elementCount; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar morph2 = data.morphs[ morph.elements[ j ].index ];\n\t\t\t\t\t\t\t\tvar ratio = morph.elements[ j ].ratio;\n\n\t\t\t\t\t\t\t\tif ( morph2.type === 1 ) {\n\n\t\t\t\t\t\t\t\t\tupdateAttributes( attribute, morph2, ratio );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// TODO: implement\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( morph.type === 1 ) { // vertex\n\n\t\t\t\t\t\t\tupdateAttributes( attribute, morph, 1.0 );\n\n\t\t\t\t\t\t} else if ( morph.type === 2 ) { // bone\n\n\t\t\t\t\t\t\t// TODO: implement\n\n\t\t\t\t\t\t} else if ( morph.type === 3 ) { // uv\n\n\t\t\t\t\t\t\t// TODO: implement\n\n\t\t\t\t\t\t} else if ( morph.type === 4 ) { // additional uv1\n\n\t\t\t\t\t\t\t// TODO: implement\n\n\t\t\t\t\t\t} else if ( morph.type === 5 ) { // additional uv2\n\n\t\t\t\t\t\t\t// TODO: implement\n\n\t\t\t\t\t\t} else if ( morph.type === 6 ) { // additional uv3\n\n\t\t\t\t\t\t\t// TODO: implement\n\n\t\t\t\t\t\t} else if ( morph.type === 7 ) { // additional uv4\n\n\t\t\t\t\t\t\t// TODO: implement\n\n\t\t\t\t\t\t} else if ( morph.type === 8 ) { // material\n\n\t\t\t\t\t\t\t// TODO: implement\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmorphTargets.push( params );\n\t\t\t\t\tmorphPositions.push( attribute );\n\n\t\t\t\t}\n\n\t\t\t\t// rigid bodies from rigidBodies field.\n\n\t\t\t\tfor ( var i = 0; i < data.metadata.rigidBodyCount; i ++ ) {\n\n\t\t\t\t\tvar rigidBody = data.rigidBodies[ i ];\n\t\t\t\t\tvar params = {};\n\n\t\t\t\t\tfor ( var key in rigidBody ) {\n\n\t\t\t\t\t\tparams[ key ] = rigidBody[ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * RigidBody position parameter in PMX seems global position\n\t\t\t\t\t * while the one in PMD seems offset from corresponding bone.\n\t\t\t\t\t * So unify being offset.\n\t\t\t\t\t */\n\t\t\t\t\tif ( data.metadata.format === 'pmx' ) {\n\n\t\t\t\t\t\tif ( params.boneIndex !== - 1 ) {\n\n\t\t\t\t\t\t\tvar bone = data.bones[ params.boneIndex ];\n\t\t\t\t\t\t\tparams.position[ 0 ] -= bone.position[ 0 ];\n\t\t\t\t\t\t\tparams.position[ 1 ] -= bone.position[ 1 ];\n\t\t\t\t\t\t\tparams.position[ 2 ] -= bone.position[ 2 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\trigidBodies.push( params );\n\n\t\t\t\t}\n\n\t\t\t\t// constraints from constraints field.\n\n\t\t\t\tfor ( var i = 0; i < data.metadata.constraintCount; i ++ ) {\n\n\t\t\t\t\tvar constraint = data.constraints[ i ];\n\t\t\t\t\tvar params = {};\n\n\t\t\t\t\tfor ( var key in constraint ) {\n\n\t\t\t\t\t\tparams[ key ] = constraint[ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar bodyA = rigidBodies[ params.rigidBodyIndex1 ];\n\t\t\t\t\tvar bodyB = rigidBodies[ params.rigidBodyIndex2 ];\n\n\t\t\t\t\t// Refer to http://www20.atpages.jp/katwat/wp/?p=4135\n\t\t\t\t\tif ( bodyA.type !== 0 && bodyB.type === 2 ) {\n\n\t\t\t\t\t\tif ( bodyA.boneIndex !== - 1 && bodyB.boneIndex !== - 1 &&\n\t\t\t\t\t\t     data.bones[ bodyB.boneIndex ].parentIndex === bodyA.boneIndex ) {\n\n\t\t\t\t\t\t\tbodyB.type = 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconstraints.push( params );\n\n\t\t\t\t}\n\n\t\t\t\t// build BufferGeometry.\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n\t\t\t\tgeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );\n\t\t\t\tgeometry.setAttribute( 'skinIndex', new THREE.Uint16BufferAttribute( skinIndices, 4 ) );\n\t\t\t\tgeometry.setAttribute( 'skinWeight', new THREE.Float32BufferAttribute( skinWeights, 4 ) );\n\t\t\t\tgeometry.setIndex( indices );\n\n\t\t\t\tfor ( var i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tgeometry.addGroup( groups[ i ].offset, groups[ i ].count, i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.bones = bones;\n\n\t\t\t\tgeometry.morphTargets = morphTargets;\n\t\t\t\tgeometry.morphAttributes.position = morphPositions;\n\t\t\t\tgeometry.morphTargetsRelative = false;\n\n\t\t\t\tgeometry.userData.MMD = {\n\t\t\t\t\tbones: bones,\n\t\t\t\t\tiks: iks,\n\t\t\t\t\tgrants: grants,\n\t\t\t\t\trigidBodies: rigidBodies,\n\t\t\t\t\tconstraints: constraints,\n\t\t\t\t\tformat: data.metadata.format\n\t\t\t\t};\n\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t};\n\n\t\t//\n\n\t\t/**\n\t\t * @param {THREE.LoadingManager} manager\n\t\t */\n\t\tfunction MaterialBuilder( manager ) {\n\n\t\t\tthis.manager = manager;\n\n\t\t\tthis.textureLoader = new THREE.TextureLoader( this.manager );\n\t\t\tthis.tgaLoader = null; // lazy generation\n\n\t\t}\n\n\t\tMaterialBuilder.prototype = {\n\n\t\t\tconstructor: MaterialBuilder,\n\n\t\t\tcrossOrigin: 'anonymous',\n\n\t\t\tresourcePath: undefined,\n\n\t\t\t/**\n\t\t\t * @param {string} crossOrigin\n\t\t\t * @return {MaterialBuilder}\n\t\t\t */\n\t\t\tsetCrossOrigin: function ( crossOrigin ) {\n\n\t\t\t\tthis.crossOrigin = crossOrigin;\n\t\t\t\treturn this;\n\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @param {string} resourcePath\n\t\t\t * @return {MaterialBuilder}\n\t\t\t */\n\t\t\tsetResourcePath: function ( resourcePath ) {\n\n\t\t\t\tthis.resourcePath = resourcePath;\n\t\t\t\treturn this;\n\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @param {Object} data - parsed PMD/PMX data\n\t\t\t * @param {THREE.BufferGeometry} geometry - some properties are dependend on geometry\n\t\t\t * @param {function} onProgress\n\t\t\t * @param {function} onError\n\t\t\t * @return {Array<THREE.MeshToonMaterial>}\n\t\t\t */\n\t\t\tbuild: function ( data, geometry /*, onProgress, onError */ ) {\n\n\t\t\t\tvar materials = [];\n\n\t\t\t\tvar textures = {};\n\n\t\t\t\tthis.textureLoader.setCrossOrigin( this.crossOrigin );\n\n\t\t\t\t// materials\n\n\t\t\t\tfor ( var i = 0; i < data.metadata.materialCount; i ++ ) {\n\n\t\t\t\t\tvar material = data.materials[ i ];\n\n\t\t\t\t\tvar params = { userData: {} };\n\n\t\t\t\t\tif ( material.name !== undefined ) params.name = material.name;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Color\n\t\t\t\t\t *\n\t\t\t\t\t * MMD         MeshToonMaterial\n\t\t\t\t\t * diffuse  -  color\n\t\t\t\t\t * specular -  specular\n\t\t\t\t\t * ambient  -  emissive * a\n\t\t\t\t\t *               (a = 1.0 without map texture or 0.2 with map texture)\n\t\t\t\t\t *\n\t\t\t\t\t * MeshToonMaterial doesn't have ambient. Set it to emissive instead.\n\t\t\t\t\t * It'll be too bright if material has map texture so using coef 0.2.\n\t\t\t\t\t */\n\t\t\t\t\tparams.color = new THREE.Color().fromArray( material.diffuse );\n\t\t\t\t\tparams.opacity = material.diffuse[ 3 ];\n\t\t\t\t\tparams.specular = new THREE.Color().fromArray( material.specular );\n\t\t\t\t\tparams.emissive = new THREE.Color().fromArray( material.ambient );\n\t\t\t\t\tparams.shininess = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\t\t\t\t\tparams.transparent = params.opacity !== 1.0;\n\n\t\t\t\t\t//\n\n\t\t\t\t\tparams.skinning = geometry.bones.length > 0 ? true : false;\n\t\t\t\t\tparams.morphTargets = geometry.morphTargets.length > 0 ? true : false;\n\t\t\t\t\tparams.fog = true;\n\n\t\t\t\t\t// blend\n\n\t\t\t\t\tparams.blending = THREE.CustomBlending;\n\t\t\t\t\tparams.blendSrc = THREE.SrcAlphaFactor;\n\t\t\t\t\tparams.blendDst = THREE.OneMinusSrcAlphaFactor;\n\t\t\t\t\tparams.blendSrcAlpha = THREE.SrcAlphaFactor;\n\t\t\t\t\tparams.blendDstAlpha = THREE.DstAlphaFactor;\n\n\t\t\t\t\t// side\n\n\t\t\t\t\tif ( data.metadata.format === 'pmx' && ( material.flag & 0x1 ) === 1 ) {\n\n\t\t\t\t\t\tparams.side = THREE.DoubleSide;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tparams.side = params.opacity === 1.0 ? THREE.FrontSide : THREE.DoubleSide;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( data.metadata.format === 'pmd' ) {\n\n\t\t\t\t\t\t// map, envMap\n\n\t\t\t\t\t\tif ( material.fileName ) {\n\n\t\t\t\t\t\t\tvar fileName = material.fileName;\n\t\t\t\t\t\t\tvar fileNames = fileName.split( '*' );\n\n\t\t\t\t\t\t\t// fileNames[ 0 ]: mapFileName\n\t\t\t\t\t\t\t// fileNames[ 1 ]: envMapFileName( optional )\n\n\t\t\t\t\t\t\tparams.map = this._loadTexture( fileNames[ 0 ], textures );\n\n\t\t\t\t\t\t\tif ( fileNames.length > 1 ) {\n\n\t\t\t\t\t\t\t\tvar extension = fileNames[ 1 ].slice( - 4 ).toLowerCase();\n\n\t\t\t\t\t\t\t\tparams.envMap = this._loadTexture(\n\t\t\t\t\t\t\t\t\tfileNames[ 1 ],\n\t\t\t\t\t\t\t\t\ttextures,\n\t\t\t\t\t\t\t\t\t{ sphericalReflectionMapping: true }\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tparams.combine = extension === '.sph'\n\t\t\t\t\t\t\t\t\t? THREE.MultiplyOperation\n\t\t\t\t\t\t\t\t\t: THREE.AddOperation;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// gradientMap\n\n\t\t\t\t\t\tvar toonFileName = ( material.toonIndex === - 1 )\n\t\t\t\t\t\t\t? 'toon00.bmp'\n\t\t\t\t\t\t\t: data.toonTextures[ material.toonIndex ].fileName;\n\n\t\t\t\t\t\tparams.gradientMap = this._loadTexture(\n\t\t\t\t\t\t\ttoonFileName,\n\t\t\t\t\t\t\ttextures,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tisToonTexture: true,\n\t\t\t\t\t\t\t\tisDefaultToonTexture: this._isDefaultToonTexture( toonFileName )\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// parameters for OutlineEffect\n\n\t\t\t\t\t\tparams.userData.outlineParameters = {\n\t\t\t\t\t\t\tthickness: material.edgeFlag === 1 ? 0.003 : 0.0,\n\t\t\t\t\t\t\tcolor: [ 0, 0, 0 ],\n\t\t\t\t\t\t\talpha: 1.0,\n\t\t\t\t\t\t\tvisible: material.edgeFlag === 1\n\t\t\t\t\t\t};\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// map\n\n\t\t\t\t\t\tif ( material.textureIndex !== - 1 ) {\n\n\t\t\t\t\t\t\tparams.map = this._loadTexture( data.textures[ material.textureIndex ], textures );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// envMap TODO: support m.envFlag === 3\n\n\t\t\t\t\t\tif ( material.envTextureIndex !== - 1 && ( material.envFlag === 1 || material.envFlag == 2 ) ) {\n\n\t\t\t\t\t\t\tparams.envMap = this._loadTexture(\n\t\t\t\t\t\t\t\tdata.textures[ material.envTextureIndex ],\n\t\t\t\t\t\t\t\ttextures, { sphericalReflectionMapping: true }\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tparams.combine = material.envFlag === 1\n\t\t\t\t\t\t\t\t? THREE.MultiplyOperation\n\t\t\t\t\t\t\t\t: THREE.AddOperation;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// gradientMap\n\n\t\t\t\t\t\tvar toonFileName, isDefaultToon;\n\n\t\t\t\t\t\tif ( material.toonIndex === - 1 || material.toonFlag !== 0 ) {\n\n\t\t\t\t\t\t\ttoonFileName = 'toon' + ( '0' + ( material.toonIndex + 1 ) ).slice( - 2 ) + '.bmp';\n\t\t\t\t\t\t\tisDefaultToon = true;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttoonFileName = data.textures[ material.toonIndex ];\n\t\t\t\t\t\t\tisDefaultToon = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparams.gradientMap = this._loadTexture(\n\t\t\t\t\t\t\ttoonFileName,\n\t\t\t\t\t\t\ttextures,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tisToonTexture: true,\n\t\t\t\t\t\t\t\tisDefaultToonTexture: isDefaultToon\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// parameters for OutlineEffect\n\t\t\t\t\t\tparams.userData.outlineParameters = {\n\t\t\t\t\t\t\tthickness: material.edgeSize / 300, // TODO: better calculation?\n\t\t\t\t\t\t\tcolor: material.edgeColor.slice( 0, 3 ),\n\t\t\t\t\t\t\talpha: material.edgeColor[ 3 ],\n\t\t\t\t\t\t\tvisible: ( material.flag & 0x10 ) !== 0 && material.edgeSize > 0.0\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( params.map !== undefined ) {\n\n\t\t\t\t\t\tif ( ! params.transparent ) {\n\n\t\t\t\t\t\t\tthis._checkImageTransparency( params.map, geometry, i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparams.emissive.multiplyScalar( 0.2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterials.push( new THREE.MeshToonMaterial( params ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.metadata.format === 'pmx' ) {\n\n\t\t\t\t\t// set transparent true if alpha morph is defined.\n\n\t\t\t\t\tfunction checkAlphaMorph( elements, materials ) {\n\n\t\t\t\t\t\tfor ( var i = 0, il = elements.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\tvar element = elements[ i ];\n\n\t\t\t\t\t\t\tif ( element.index === - 1 ) continue;\n\n\t\t\t\t\t\t\tvar material = materials[ element.index ];\n\n\t\t\t\t\t\t\tif ( material.opacity !== element.diffuse[ 3 ] ) {\n\n\t\t\t\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0, il = data.morphs.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar morph = data.morphs[ i ];\n\t\t\t\t\t\tvar elements = morph.elements;\n\n\t\t\t\t\t\tif ( morph.type === 0 ) {\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = elements.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar morph2 = data.morphs[ elements[ j ].index ];\n\n\t\t\t\t\t\t\t\tif ( morph2.type !== 8 ) continue;\n\n\t\t\t\t\t\t\t\tcheckAlphaMorph( morph2.elements, materials );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( morph.type === 8 ) {\n\n\t\t\t\t\t\t\tcheckAlphaMorph( elements, materials );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn materials;\n\n\t\t\t},\n\n\t\t\t// private methods\n\n\t\t\t_getTGALoader: function () {\n\n\t\t\t\tif ( this.tgaLoader === null ) {\n\n\t\t\t\t\tif ( THREE.TGALoader === undefined ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.MMDLoader: Import THREE.TGALoader' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.tgaLoader = new THREE.TGALoader( this.manager );\n\n\t\t\t\t}\n\n\t\t\t\treturn this.tgaLoader;\n\n\t\t\t},\n\n\t\t\t_isDefaultToonTexture: function ( name ) {\n\n\t\t\t\tif ( name.length !== 10 ) return false;\n\n\t\t\t\treturn /toon(10|0[0-9])\\.bmp/.test( name );\n\n\t\t\t},\n\n\t\t\t_loadTexture: function ( filePath, textures, params, onProgress, onError ) {\n\n\t\t\t\tparams = params || {};\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tvar fullPath;\n\n\t\t\t\tif ( params.isDefaultToonTexture === true ) {\n\n\t\t\t\t\tvar index;\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tindex = parseInt( filePath.match( /toon([0-9]{2})\\.bmp$/ )[ 1 ] );\n\n\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.MMDLoader: ' + filePath + ' seems like a '\n\t\t\t\t\t\t\t+ 'not right default texture path. Using toon00.bmp instead.' );\n\n\t\t\t\t\t\tindex = 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfullPath = DEFAULT_TOON_TEXTURES[ index ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfullPath = this.resourcePath + filePath;\n\n\t\t\t\t}\n\n\t\t\t\tif ( textures[ fullPath ] !== undefined ) return textures[ fullPath ];\n\n\t\t\t\tvar loader = this.manager.getHandler( fullPath );\n\n\t\t\t\tif ( loader === null ) {\n\n\t\t\t\t\tloader = ( filePath.slice( - 4 ).toLowerCase() === '.tga' )\n\t\t\t\t\t\t? this._getTGALoader()\n\t\t\t\t\t\t: this.textureLoader;\n\n\t\t\t\t}\n\n\t\t\t\tvar texture = loader.load( fullPath, function ( t ) {\n\n\t\t\t\t\t// MMD toon texture is Axis-Y oriented\n\t\t\t\t\t// but Three.js gradient map is Axis-X oriented.\n\t\t\t\t\t// So here replaces the toon texture image with the rotated one.\n\t\t\t\t\tif ( params.isToonTexture === true ) {\n\n\t\t\t\t\t\tt.image = scope._getRotatedImage( t.image );\n\n\t\t\t\t\t\tt.magFilter = THREE.NearestFilter;\n\t\t\t\t\t\tt.minFilter = THREE.NearestFilter;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tt.flipY = false;\n\t\t\t\t\tt.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tt.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t\tfor ( var i = 0; i < texture.readyCallbacks.length; i ++ ) {\n\n\t\t\t\t\t\ttexture.readyCallbacks[ i ]( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete texture.readyCallbacks;\n\n\t\t\t\t}, onProgress, onError );\n\n\t\t\t\tif ( params.sphericalReflectionMapping === true ) {\n\n\t\t\t\t\ttexture.mapping = THREE.SphericalReflectionMapping;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.readyCallbacks = [];\n\n\t\t\t\ttextures[ fullPath ] = texture;\n\n\t\t\t\treturn texture;\n\n\t\t\t},\n\n\t\t\t_getRotatedImage: function ( image ) {\n\n\t\t\t\tvar canvas = document.createElement( 'canvas' );\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\n\t\t\t\tvar width = image.width;\n\t\t\t\tvar height = image.height;\n\n\t\t\t\tcanvas.width = width;\n\t\t\t\tcanvas.height = height;\n\n\t\t\t\tcontext.clearRect( 0, 0, width, height );\n\t\t\t\tcontext.translate( width / 2.0, height / 2.0 );\n\t\t\t\tcontext.rotate( 0.5 * Math.PI ); // 90.0 * Math.PI / 180.0\n\t\t\t\tcontext.translate( - width / 2.0, - height / 2.0 );\n\t\t\t\tcontext.drawImage( image, 0, 0 );\n\n\t\t\t\treturn context.getImageData( 0, 0, width, height );\n\n\t\t\t},\n\n\t\t\t// Check if the partial image area used by the texture is transparent.\n\t\t\t_checkImageTransparency: function ( map, geometry, groupIndex ) {\n\n\t\t\t\tmap.readyCallbacks.push( function ( texture ) {\n\n\t\t\t\t\t// Is there any efficient ways?\n\t\t\t\t\tfunction createImageData( image ) {\n\n\t\t\t\t\t\tvar canvas = document.createElement( 'canvas' );\n\t\t\t\t\t\tcanvas.width = image.width;\n\t\t\t\t\t\tcanvas.height = image.height;\n\n\t\t\t\t\t\tvar context = canvas.getContext( '2d' );\n\t\t\t\t\t\tcontext.drawImage( image, 0, 0 );\n\n\t\t\t\t\t\treturn context.getImageData( 0, 0, canvas.width, canvas.height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction detectImageTransparency( image, uvs, indices ) {\n\n\t\t\t\t\t\tvar width = image.width;\n\t\t\t\t\t\tvar height = image.height;\n\t\t\t\t\t\tvar data = image.data;\n\t\t\t\t\t\tvar threshold = 253;\n\n\t\t\t\t\t\tif ( data.length / ( width * height ) !== 4 ) return false;\n\n\t\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t\t\t\tvar centerUV = { x: 0.0, y: 0.0 };\n\n\t\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\t\tvar index = indices[ i * 3 + j ];\n\t\t\t\t\t\t\t\tvar uv = { x: uvs[ index * 2 + 0 ], y: uvs[ index * 2 + 1 ] };\n\n\t\t\t\t\t\t\t\tif ( getAlphaByUv( image, uv ) < threshold ) return true;\n\n\t\t\t\t\t\t\t\tcenterUV.x += uv.x;\n\t\t\t\t\t\t\t\tcenterUV.y += uv.y;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcenterUV.x /= 3;\n\t\t\t\t\t\t\tcenterUV.y /= 3;\n\n\t\t\t\t\t\t\tif ( getAlphaByUv( image, centerUV ) < threshold ) return true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * This method expects\n\t\t\t\t\t *   texture.flipY = false\n\t\t\t\t\t *   texture.wrapS = THREE.RepeatWrapping\n\t\t\t\t\t *   texture.wrapT = THREE.RepeatWrapping\n\t\t\t\t\t * TODO: more precise\n\t\t\t\t\t */\n\t\t\t\t\tfunction getAlphaByUv( image, uv ) {\n\n\t\t\t\t\t\tvar width = image.width;\n\t\t\t\t\t\tvar height = image.height;\n\n\t\t\t\t\t\tvar x = Math.round( uv.x * width ) % width;\n\t\t\t\t\t\tvar y = Math.round( uv.y * height ) % height;\n\n\t\t\t\t\t\tif ( x < 0 ) x += width;\n\t\t\t\t\t\tif ( y < 0 ) y += height;\n\n\t\t\t\t\t\tvar index = y * width + x;\n\n\t\t\t\t\t\treturn image.data[ index * 4 + 3 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar imageData = texture.image.data !== undefined\n\t\t\t\t\t\t? texture.image\n\t\t\t\t\t\t: createImageData( texture.image );\n\n\t\t\t\t\tvar group = geometry.groups[ groupIndex ];\n\n\t\t\t\t\tif ( detectImageTransparency(\n\t\t\t\t\t\timageData,\n\t\t\t\t\t\tgeometry.attributes.uv.array,\n\t\t\t\t\t\tgeometry.index.array.slice( group.start, group.start + group.count ) ) ) {\n\n\t\t\t\t\t\tmap.transparent = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t};\n\n\t\t//\n\n\t\tfunction AnimationBuilder() {\n\n\t\t}\n\n\t\tAnimationBuilder.prototype = {\n\n\t\t\tconstructor: AnimationBuilder,\n\n\t\t\t/**\n\t\t\t * @param {Object} vmd - parsed VMD data\n\t\t\t * @param {THREE.SkinnedMesh} mesh - tracks will be fitting to mesh\n\t\t\t * @return {THREE.AnimationClip}\n\t\t\t */\n\t\t\tbuild: function ( vmd, mesh ) {\n\n\t\t\t\t// combine skeletal and morph animations\n\n\t\t\t\tvar tracks = this.buildSkeletalAnimation( vmd, mesh ).tracks;\n\t\t\t\tvar tracks2 = this.buildMorphAnimation( vmd, mesh ).tracks;\n\n\t\t\t\tfor ( var i = 0, il = tracks2.length; i < il; i ++ ) {\n\n\t\t\t\t\ttracks.push( tracks2[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn new THREE.AnimationClip( '', - 1, tracks );\n\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @param {Object} vmd - parsed VMD data\n\t\t\t * @param {THREE.SkinnedMesh} mesh - tracks will be fitting to mesh\n\t\t\t * @return {THREE.AnimationClip}\n\t\t\t */\n\t\t\tbuildSkeletalAnimation: function ( vmd, mesh ) {\n\n\t\t\t\tfunction pushInterpolation( array, interpolation, index ) {\n\n\t\t\t\t\tarray.push( interpolation[ index + 0 ] / 127 ); // x1\n\t\t\t\t\tarray.push( interpolation[ index + 8 ] / 127 ); // x2\n\t\t\t\t\tarray.push( interpolation[ index + 4 ] / 127 ); // y1\n\t\t\t\t\tarray.push( interpolation[ index + 12 ] / 127 ); // y2\n\n\t\t\t\t}\n\n\t\t\t\tvar tracks = [];\n\n\t\t\t\tvar motions = {};\n\t\t\t\tvar bones = mesh.skeleton.bones;\n\t\t\t\tvar boneNameDictionary = {};\n\n\t\t\t\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tboneNameDictionary[ bones[ i ].name ] = true;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < vmd.metadata.motionCount; i ++ ) {\n\n\t\t\t\t\tvar motion = vmd.motions[ i ];\n\t\t\t\t\tvar boneName = motion.boneName;\n\n\t\t\t\t\tif ( boneNameDictionary[ boneName ] === undefined ) continue;\n\n\t\t\t\t\tmotions[ boneName ] = motions[ boneName ] || [];\n\t\t\t\t\tmotions[ boneName ].push( motion );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var key in motions ) {\n\n\t\t\t\t\tvar array = motions[ key ];\n\n\t\t\t\t\tarray.sort( function ( a, b ) {\n\n\t\t\t\t\t\treturn a.frameNum - b.frameNum;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar positions = [];\n\t\t\t\t\tvar rotations = [];\n\t\t\t\t\tvar pInterpolations = [];\n\t\t\t\t\tvar rInterpolations = [];\n\n\t\t\t\t\tvar basePosition = mesh.skeleton.getBoneByName( key ).position.toArray();\n\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar time = array[ i ].frameNum / 30;\n\t\t\t\t\t\tvar position = array[ i ].position;\n\t\t\t\t\t\tvar rotation = array[ i ].rotation;\n\t\t\t\t\t\tvar interpolation = array[ i ].interpolation;\n\n\t\t\t\t\t\ttimes.push( time );\n\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) positions.push( basePosition[ j ] + position[ j ] );\n\t\t\t\t\t\tfor ( var j = 0; j < 4; j ++ ) rotations.push( rotation[ j ] );\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) pushInterpolation( pInterpolations, interpolation, j );\n\n\t\t\t\t\t\tpushInterpolation( rInterpolations, interpolation, 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar targetName = '.bones[' + key + ']';\n\n\t\t\t\t\ttracks.push( this._createTrack( targetName + '.position', THREE.VectorKeyframeTrack, times, positions, pInterpolations ) );\n\t\t\t\t\ttracks.push( this._createTrack( targetName + '.quaternion', THREE.QuaternionKeyframeTrack, times, rotations, rInterpolations ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn new THREE.AnimationClip( '', - 1, tracks );\n\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @param {Object} vmd - parsed VMD data\n\t\t\t * @param {THREE.SkinnedMesh} mesh - tracks will be fitting to mesh\n\t\t\t * @return {THREE.AnimationClip}\n\t\t\t */\n\t\t\tbuildMorphAnimation: function ( vmd, mesh ) {\n\n\t\t\t\tvar tracks = [];\n\n\t\t\t\tvar morphs = {};\n\t\t\t\tvar morphTargetDictionary = mesh.morphTargetDictionary;\n\n\t\t\t\tfor ( var i = 0; i < vmd.metadata.morphCount; i ++ ) {\n\n\t\t\t\t\tvar morph = vmd.morphs[ i ];\n\t\t\t\t\tvar morphName = morph.morphName;\n\n\t\t\t\t\tif ( morphTargetDictionary[ morphName ] === undefined ) continue;\n\n\t\t\t\t\tmorphs[ morphName ] = morphs[ morphName ] || [];\n\t\t\t\t\tmorphs[ morphName ].push( morph );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var key in morphs ) {\n\n\t\t\t\t\tvar array = morphs[ key ];\n\n\t\t\t\t\tarray.sort( function ( a, b ) {\n\n\t\t\t\t\t\treturn a.frameNum - b.frameNum;\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tvar times = [];\n\t\t\t\t\tvar values = [];\n\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\ttimes.push( array[ i ].frameNum / 30 );\n\t\t\t\t\t\tvalues.push( array[ i ].weight );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new THREE.NumberKeyframeTrack( '.morphTargetInfluences[' + morphTargetDictionary[ key ] + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn new THREE.AnimationClip( '', - 1, tracks );\n\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * @param {Object} vmd - parsed VMD data\n\t\t\t * @return {THREE.AnimationClip}\n\t\t\t */\n\t\t\tbuildCameraAnimation: function ( vmd ) {\n\n\t\t\t\tfunction pushVector3( array, vec ) {\n\n\t\t\t\t\tarray.push( vec.x );\n\t\t\t\t\tarray.push( vec.y );\n\t\t\t\t\tarray.push( vec.z );\n\n\t\t\t\t}\n\n\t\t\t\tfunction pushQuaternion( array, q ) {\n\n\t\t\t\t\tarray.push( q.x );\n\t\t\t\t\tarray.push( q.y );\n\t\t\t\t\tarray.push( q.z );\n\t\t\t\t\tarray.push( q.w );\n\n\t\t\t\t}\n\n\t\t\t\tfunction pushInterpolation( array, interpolation, index ) {\n\n\t\t\t\t\tarray.push( interpolation[ index * 4 + 0 ] / 127 ); // x1\n\t\t\t\t\tarray.push( interpolation[ index * 4 + 1 ] / 127 ); // x2\n\t\t\t\t\tarray.push( interpolation[ index * 4 + 2 ] / 127 ); // y1\n\t\t\t\t\tarray.push( interpolation[ index * 4 + 3 ] / 127 ); // y2\n\n\t\t\t\t}\n\n\t\t\t\tvar tracks = [];\n\n\t\t\t\tvar cameras = vmd.cameras === undefined ? [] : vmd.cameras.slice();\n\n\t\t\t\tcameras.sort( function ( a, b ) {\n\n\t\t\t\t\treturn a.frameNum - b.frameNum;\n\n\t\t\t\t} );\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar centers = [];\n\t\t\t\tvar quaternions = [];\n\t\t\t\tvar positions = [];\n\t\t\t\tvar fovs = [];\n\n\t\t\t\tvar cInterpolations = [];\n\t\t\t\tvar qInterpolations = [];\n\t\t\t\tvar pInterpolations = [];\n\t\t\t\tvar fInterpolations = [];\n\n\t\t\t\tvar quaternion = new THREE.Quaternion();\n\t\t\t\tvar euler = new THREE.Euler();\n\t\t\t\tvar position = new THREE.Vector3();\n\t\t\t\tvar center = new THREE.Vector3();\n\n\t\t\t\tfor ( var i = 0, il = cameras.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar motion = cameras[ i ];\n\n\t\t\t\t\tvar time = motion.frameNum / 30;\n\t\t\t\t\tvar pos = motion.position;\n\t\t\t\t\tvar rot = motion.rotation;\n\t\t\t\t\tvar distance = motion.distance;\n\t\t\t\t\tvar fov = motion.fov;\n\t\t\t\t\tvar interpolation = motion.interpolation;\n\n\t\t\t\t\ttimes.push( time );\n\n\t\t\t\t\tposition.set( 0, 0, - distance );\n\t\t\t\t\tcenter.set( pos[ 0 ], pos[ 1 ], pos[ 2 ] );\n\n\t\t\t\t\teuler.set( - rot[ 0 ], - rot[ 1 ], - rot[ 2 ] );\n\t\t\t\t\tquaternion.setFromEuler( euler );\n\n\t\t\t\t\tposition.add( center );\n\t\t\t\t\tposition.applyQuaternion( quaternion );\n\n\t\t\t\t\tpushVector3( centers, center );\n\t\t\t\t\tpushQuaternion( quaternions, quaternion );\n\t\t\t\t\tpushVector3( positions, position );\n\n\t\t\t\t\tfovs.push( fov );\n\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tpushInterpolation( cInterpolations, interpolation, j );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpushInterpolation( qInterpolations, interpolation, 3 );\n\n\t\t\t\t\t// use the same parameter for x, y, z axis.\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tpushInterpolation( pInterpolations, interpolation, 4 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpushInterpolation( fInterpolations, interpolation, 5 );\n\n\t\t\t\t}\n\n\t\t\t\tvar tracks = [];\n\n\t\t\t\t// I expect an object whose name 'target' exists under THREE.Camera\n\t\t\t\ttracks.push( this._createTrack( 'target.position', THREE.VectorKeyframeTrack, times, centers, cInterpolations ) );\n\n\t\t\t\ttracks.push( this._createTrack( '.quaternion', THREE.QuaternionKeyframeTrack, times, quaternions, qInterpolations ) );\n\t\t\t\ttracks.push( this._createTrack( '.position', THREE.VectorKeyframeTrack, times, positions, pInterpolations ) );\n\t\t\t\ttracks.push( this._createTrack( '.fov', THREE.NumberKeyframeTrack, times, fovs, fInterpolations ) );\n\n\t\t\t\treturn new THREE.AnimationClip( '', - 1, tracks );\n\n\t\t\t},\n\n\t\t\t// private method\n\n\t\t\t_createTrack: function ( node, typedKeyframeTrack, times, values, interpolations ) {\n\n\t\t\t\t/*\n\t\t\t\t * optimizes here not to let KeyframeTrackPrototype optimize\n\t\t\t\t * because KeyframeTrackPrototype optimizes times and values but\n\t\t\t\t * doesn't optimize interpolations.\n\t\t\t\t */\n\t\t\t\tif ( times.length > 2 ) {\n\n\t\t\t\t\ttimes = times.slice();\n\t\t\t\t\tvalues = values.slice();\n\t\t\t\t\tinterpolations = interpolations.slice();\n\n\t\t\t\t\tvar stride = values.length / times.length;\n\t\t\t\t\tvar interpolateStride = interpolations.length / times.length;\n\n\t\t\t\t\tvar index = 1;\n\n\t\t\t\t\tfor ( var aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex ++ ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < stride; i ++ ) {\n\n\t\t\t\t\t\t\tif ( values[ index * stride + i ] !== values[ ( index - 1 ) * stride + i ] ||\n\t\t\t\t\t\t\t\tvalues[ index * stride + i ] !== values[ aheadIndex * stride + i ] ) {\n\n\t\t\t\t\t\t\t\tindex ++;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( aheadIndex > index ) {\n\n\t\t\t\t\t\t\ttimes[ index ] = times[ aheadIndex ];\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < stride; i ++ ) {\n\n\t\t\t\t\t\t\t\tvalues[ index * stride + i ] = values[ aheadIndex * stride + i ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < interpolateStride; i ++ ) {\n\n\t\t\t\t\t\t\t\tinterpolations[ index * interpolateStride + i ] = interpolations[ aheadIndex * interpolateStride + i ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttimes.length = index + 1;\n\t\t\t\t\tvalues.length = ( index + 1 ) * stride;\n\t\t\t\t\tinterpolations.length = ( index + 1 ) * interpolateStride;\n\n\t\t\t\t}\n\n\t\t\t\tvar track = new typedKeyframeTrack( node, times, values );\n\n\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodCubicBezier( result ) {\n\n\t\t\t\t\treturn new CubicBezierInterpolation( this.times, this.values, this.getValueSize(), result, new Float32Array( interpolations ) );\n\n\t\t\t\t};\n\n\t\t\t\treturn track;\n\n\t\t\t}\n\n\t\t};\n\n\t\t// interpolation\n\n\t\tfunction CubicBezierInterpolation( parameterPositions, sampleValues, sampleSize, resultBuffer, params ) {\n\n\t\t\tTHREE.Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\t\tthis.interpolationParams = params;\n\n\t\t}\n\n\t\tCubicBezierInterpolation.prototype = Object.assign( Object.create( THREE.Interpolant.prototype ), {\n\n\t\t\tconstructor: CubicBezierInterpolation,\n\n\t\t\tinterpolate_: function ( i1, t0, t, t1 ) {\n\n\t\t\t\tvar result = this.resultBuffer;\n\t\t\t\tvar values = this.sampleValues;\n\t\t\t\tvar stride = this.valueSize;\n\t\t\t\tvar params = this.interpolationParams;\n\n\t\t\t\tvar offset1 = i1 * stride;\n\t\t\t\tvar offset0 = offset1 - stride;\n\n\t\t\t\t// No interpolation if next key frame is in one frame in 30fps.\n\t\t\t\t// This is from MMD animation spec.\n\t\t\t\t// '1.5' is for precision loss. times are Float32 in Three.js Animation system.\n\t\t\t\tvar weight1 = ( ( t1 - t0 ) < 1 / 30 * 1.5 ) ? 0.0 : ( t - t0 ) / ( t1 - t0 );\n\n\t\t\t\tif ( stride === 4 ) { // Quaternion\n\n\t\t\t\t\tvar x1 = params[ i1 * 4 + 0 ];\n\t\t\t\t\tvar x2 = params[ i1 * 4 + 1 ];\n\t\t\t\t\tvar y1 = params[ i1 * 4 + 2 ];\n\t\t\t\t\tvar y2 = params[ i1 * 4 + 3 ];\n\n\t\t\t\t\tvar ratio = this._calculate( x1, x2, y1, y2, weight1 );\n\n\t\t\t\t\tTHREE.Quaternion.slerpFlat( result, 0, values, offset0, values, offset1, ratio );\n\n\t\t\t\t} else if ( stride === 3 ) { // Vector3\n\n\t\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\n\n\t\t\t\t\t\tvar x1 = params[ i1 * 12 + i * 4 + 0 ];\n\t\t\t\t\t\tvar x2 = params[ i1 * 12 + i * 4 + 1 ];\n\t\t\t\t\t\tvar y1 = params[ i1 * 12 + i * 4 + 2 ];\n\t\t\t\t\t\tvar y2 = params[ i1 * 12 + i * 4 + 3 ];\n\n\t\t\t\t\t\tvar ratio = this._calculate( x1, x2, y1, y2, weight1 );\n\n\t\t\t\t\t\tresult[ i ] = values[ offset0 + i ] * ( 1 - ratio ) + values[ offset1 + i ] * ratio;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else { // Number\n\n\t\t\t\t\tvar x1 = params[ i1 * 4 + 0 ];\n\t\t\t\t\tvar x2 = params[ i1 * 4 + 1 ];\n\t\t\t\t\tvar y1 = params[ i1 * 4 + 2 ];\n\t\t\t\t\tvar y2 = params[ i1 * 4 + 3 ];\n\n\t\t\t\t\tvar ratio = this._calculate( x1, x2, y1, y2, weight1 );\n\n\t\t\t\t\tresult[ 0 ] = values[ offset0 ] * ( 1 - ratio ) + values[ offset1 ] * ratio;\n\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\n\t\t\t},\n\n\t\t\t_calculate: function ( x1, x2, y1, y2, x ) {\n\n\t\t\t\t/*\n\t\t\t\t * Cubic Bezier curves\n\t\t\t\t *   https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves\n\t\t\t\t *\n\t\t\t\t * B(t) = ( 1 - t ) ^ 3 * P0\n\t\t\t\t *      + 3 * ( 1 - t ) ^ 2 * t * P1\n\t\t\t\t *      + 3 * ( 1 - t ) * t^2 * P2\n\t\t\t\t *      + t ^ 3 * P3\n\t\t\t\t *      ( 0 <= t <= 1 )\n\t\t\t\t *\n\t\t\t\t * MMD uses Cubic Bezier curves for bone and camera animation interpolation.\n\t\t\t\t *   http://d.hatena.ne.jp/edvakf/20111016/1318716097\n\t\t\t\t *\n\t\t\t\t *    x = ( 1 - t ) ^ 3 * x0\n\t\t\t\t *      + 3 * ( 1 - t ) ^ 2 * t * x1\n\t\t\t\t *      + 3 * ( 1 - t ) * t^2 * x2\n\t\t\t\t *      + t ^ 3 * x3\n\t\t\t\t *    y = ( 1 - t ) ^ 3 * y0\n\t\t\t\t *      + 3 * ( 1 - t ) ^ 2 * t * y1\n\t\t\t\t *      + 3 * ( 1 - t ) * t^2 * y2\n\t\t\t\t *      + t ^ 3 * y3\n\t\t\t\t *      ( x0 = 0, y0 = 0 )\n\t\t\t\t *      ( x3 = 1, y3 = 1 )\n\t\t\t\t *      ( 0 <= t, x1, x2, y1, y2 <= 1 )\n\t\t\t\t *\n\t\t\t\t * Here solves this equation with Bisection method,\n\t\t\t\t *   https://en.wikipedia.org/wiki/Bisection_method\n\t\t\t\t * gets t, and then calculate y.\n\t\t\t\t *\n\t\t\t\t * f(t) = 3 * ( 1 - t ) ^ 2 * t * x1\n\t\t\t\t *      + 3 * ( 1 - t ) * t^2 * x2\n\t\t\t\t *      + t ^ 3 - x = 0\n\t\t\t\t *\n\t\t\t\t * (Another option: Newton's method\n\t\t\t\t *    https://en.wikipedia.org/wiki/Newton%27s_method)\n\t\t\t\t */\n\n\t\t\t\tvar c = 0.5;\n\t\t\t\tvar t = c;\n\t\t\t\tvar s = 1.0 - t;\n\t\t\t\tvar loop = 15;\n\t\t\t\tvar eps = 1e-5;\n\t\t\t\tvar math = Math;\n\n\t\t\t\tvar sst3, stt3, ttt;\n\n\t\t\t\tfor ( var i = 0; i < loop; i ++ ) {\n\n\t\t\t\t\tsst3 = 3.0 * s * s * t;\n\t\t\t\t\tstt3 = 3.0 * s * t * t;\n\t\t\t\t\tttt = t * t * t;\n\n\t\t\t\t\tvar ft = ( sst3 * x1 ) + ( stt3 * x2 ) + ( ttt ) - x;\n\n\t\t\t\t\tif ( math.abs( ft ) < eps ) break;\n\n\t\t\t\t\tc /= 2.0;\n\n\t\t\t\t\tt += ( ft < 0 ) ? c : - c;\n\t\t\t\t\ts = 1.0 - t;\n\n\t\t\t\t}\n\n\t\t\t\treturn ( sst3 * y1 ) + ( stt3 * y2 ) + ttt;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn MMDLoader;\n\n\t} )();\n\t\n\treturn THREE.MMDLoader;\n});\n"]}