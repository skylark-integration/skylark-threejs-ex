{"version":3,"sources":["loaders/obj2/shared/MeshReceiver.js"],"names":["define","THREE","MeshReceiver","materialHandler","this","logging","enabled","debug","callbacks","onProgress","onMeshAlter","prototype","constructor","setLogging","_setCallbacks","undefined","Function","buildMeshes","meshPayload","material","materialName","key","meshName","params","buffers","bufferGeometry","BufferGeometry","vertices","setAttribute","BufferAttribute","Float32Array","indices","setIndex","Uint32Array","colors","normals","computeVertexNormals","uvs","skinIndex","Uint16Array","skinWeight","materialNames","materials","createMultiMaterial","multiMaterial","multiMaterials","getMaterial","push","materialGroup","materialGroups","addGroup","start","count","index","mesh","callbackOnMeshAlterResult","meshes","useOrgMesh","geometryType","detail","isDisregardMesh","providesAlteredMeshes","i","computeBoundingSphere","Mesh","LineSegments","Points","name","progressMessage","length","meshNames","progress","numericalValue","toFixed"],"mappings":"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","file":"../../../../loaders/obj2/shared/MeshReceiver.js","sourcesContent":["define([\n    'skylark-threejs'\n], function (THREE) {\n    'use strict';\n    const MeshReceiver = function (materialHandler) {\n        this.logging = {\n            enabled: false,\n            debug: false\n        };\n        this.callbacks = {\n            onProgress: null,\n            onMeshAlter: null\n        };\n        this.materialHandler = materialHandler;\n    };\n    MeshReceiver.prototype = {\n        constructor: MeshReceiver,\n        setLogging: function (enabled, debug) {\n            this.logging.enabled = enabled === true;\n            this.logging.debug = debug === true;\n        },\n        _setCallbacks: function (onProgress, onMeshAlter) {\n            if (onProgress !== null && onProgress !== undefined && onProgress instanceof Function) {\n                this.callbacks.onProgress = onProgress;\n            }\n            if (onMeshAlter !== null && onMeshAlter !== undefined && onMeshAlter instanceof Function) {\n                this.callbacks.onMeshAlter = onMeshAlter;\n            }\n        },\n        buildMeshes: function (meshPayload) {\n            let meshName = meshPayload.params.meshName;\n            let buffers = meshPayload.buffers;\n            let bufferGeometry = new THREE.BufferGeometry();\n            if (buffers.vertices !== undefined && buffers.vertices !== null) {\n                bufferGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(buffers.vertices), 3));\n            }\n            if (buffers.indices !== undefined && buffers.indices !== null) {\n                bufferGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(buffers.indices), 1));\n            }\n            if (buffers.colors !== undefined && buffers.colors !== null) {\n                bufferGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(buffers.colors), 3));\n            }\n            if (buffers.normals !== undefined && buffers.normals !== null) {\n                bufferGeometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(buffers.normals), 3));\n            } else {\n                bufferGeometry.computeVertexNormals();\n            }\n            if (buffers.uvs !== undefined && buffers.uvs !== null) {\n                bufferGeometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(buffers.uvs), 2));\n            }\n            if (buffers.skinIndex !== undefined && buffers.skinIndex !== null) {\n                bufferGeometry.setAttribute('skinIndex', new THREE.BufferAttribute(new Uint16Array(buffers.skinIndex), 4));\n            }\n            if (buffers.skinWeight !== undefined && buffers.skinWeight !== null) {\n                bufferGeometry.setAttribute('skinWeight', new THREE.BufferAttribute(new Float32Array(buffers.skinWeight), 4));\n            }\n            let material, materialName, key;\n            let materialNames = meshPayload.materials.materialNames;\n            let createMultiMaterial = meshPayload.materials.multiMaterial;\n            let multiMaterials = [];\n            for (key in materialNames) {\n                materialName = materialNames[key];\n                material = this.materialHandler.getMaterial(materialName);\n                if (createMultiMaterial)\n                    multiMaterials.push(material);\n            }\n            if (createMultiMaterial) {\n                material = multiMaterials;\n                let materialGroups = meshPayload.materials.materialGroups;\n                let materialGroup;\n                for (key in materialGroups) {\n                    materialGroup = materialGroups[key];\n                    bufferGeometry.addGroup(materialGroup.start, materialGroup.count, materialGroup.index);\n                }\n            }\n            let meshes = [];\n            let mesh;\n            let callbackOnMeshAlterResult;\n            let useOrgMesh = true;\n            let geometryType = meshPayload.geometryType === null ? 0 : meshPayload.geometryType;\n            if (this.callbacks.onMeshAlter) {\n                callbackOnMeshAlterResult = this.callbacks.onMeshAlter({\n                    detail: {\n                        meshName: meshName,\n                        bufferGeometry: bufferGeometry,\n                        material: material,\n                        geometryType: geometryType\n                    }\n                });\n            }\n            if (callbackOnMeshAlterResult) {\n                if (callbackOnMeshAlterResult.isDisregardMesh()) {\n                    useOrgMesh = false;\n                } else if (callbackOnMeshAlterResult.providesAlteredMeshes()) {\n                    for (let i in callbackOnMeshAlterResult.meshes) {\n                        meshes.push(callbackOnMeshAlterResult.meshes[i]);\n                    }\n                    useOrgMesh = false;\n                }\n            }\n            if (useOrgMesh) {\n                if (meshPayload.computeBoundingSphere)\n                    bufferGeometry.computeBoundingSphere();\n                if (geometryType === 0) {\n                    mesh = new THREE.Mesh(bufferGeometry, material);\n                } else if (geometryType === 1) {\n                    mesh = new THREE.LineSegments(bufferGeometry, material);\n                } else {\n                    mesh = new THREE.Points(bufferGeometry, material);\n                }\n                mesh.name = meshName;\n                meshes.push(mesh);\n            }\n            let progressMessage = meshPayload.params.meshName;\n            if (meshes.length > 0) {\n                let meshNames = [];\n                for (let i in meshes) {\n                    mesh = meshes[i];\n                    meshNames[i] = mesh.name;\n                }\n                progressMessage += ': Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;\n                progressMessage += ' (' + (meshPayload.progress.numericalValue * 100).toFixed(2) + '%)';\n            } else {\n                progressMessage += ': Not adding mesh: ' + meshName;\n                progressMessage += ' (' + (meshPayload.progress.numericalValue * 100).toFixed(2) + '%)';\n            }\n            if (this.callbacks.onProgress) {\n                this.callbacks.onProgress('progress', progressMessage, meshPayload.progress.numericalValue);\n            }\n            return meshes;\n        }\n    };\n\n    return  MeshReceiver;\n});"]}