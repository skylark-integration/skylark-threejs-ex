{"version":3,"sources":["loaders/obj2/shared/MeshReceiver.js"],"names":["define","THREE","MeshReceiver","materialHandler","this","logging","enabled","debug","callbacks","onProgress","onMeshAlter","prototype","constructor","setLogging","_setCallbacks","undefined","Function","buildMeshes","meshPayload","material","materialName","key","meshName","params","buffers","bufferGeometry","BufferGeometry","vertices","setAttribute","BufferAttribute","Float32Array","indices","setIndex","Uint32Array","colors","normals","computeVertexNormals","uvs","skinIndex","Uint16Array","skinWeight","materialNames","materials","createMultiMaterial","multiMaterial","multiMaterials","getMaterial","push","materialGroup","materialGroups","addGroup","start","count","index","mesh","callbackOnMeshAlterResult","meshes","useOrgMesh","geometryType","detail","isDisregardMesh","providesAlteredMeshes","i","computeBoundingSphere","Mesh","LineSegments","Points","name","progressMessage","length","meshNames","progress","numericalValue","toFixed"],"mappings":"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","file":"../../../../loaders/obj2/shared/MeshReceiver.js","sourcesContent":["define([\r\n    'skylark-threejs'\r\n], function (THREE) {\r\n    'use strict';\r\n    const MeshReceiver = function (materialHandler) {\r\n        this.logging = {\r\n            enabled: false,\r\n            debug: false\r\n        };\r\n        this.callbacks = {\r\n            onProgress: null,\r\n            onMeshAlter: null\r\n        };\r\n        this.materialHandler = materialHandler;\r\n    };\r\n    MeshReceiver.prototype = {\r\n        constructor: MeshReceiver,\r\n        setLogging: function (enabled, debug) {\r\n            this.logging.enabled = enabled === true;\r\n            this.logging.debug = debug === true;\r\n        },\r\n        _setCallbacks: function (onProgress, onMeshAlter) {\r\n            if (onProgress !== null && onProgress !== undefined && onProgress instanceof Function) {\r\n                this.callbacks.onProgress = onProgress;\r\n            }\r\n            if (onMeshAlter !== null && onMeshAlter !== undefined && onMeshAlter instanceof Function) {\r\n                this.callbacks.onMeshAlter = onMeshAlter;\r\n            }\r\n        },\r\n        buildMeshes: function (meshPayload) {\r\n            let meshName = meshPayload.params.meshName;\r\n            let buffers = meshPayload.buffers;\r\n            let bufferGeometry = new THREE.BufferGeometry();\r\n            if (buffers.vertices !== undefined && buffers.vertices !== null) {\r\n                bufferGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(buffers.vertices), 3));\r\n            }\r\n            if (buffers.indices !== undefined && buffers.indices !== null) {\r\n                bufferGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(buffers.indices), 1));\r\n            }\r\n            if (buffers.colors !== undefined && buffers.colors !== null) {\r\n                bufferGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(buffers.colors), 3));\r\n            }\r\n            if (buffers.normals !== undefined && buffers.normals !== null) {\r\n                bufferGeometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(buffers.normals), 3));\r\n            } else {\r\n                bufferGeometry.computeVertexNormals();\r\n            }\r\n            if (buffers.uvs !== undefined && buffers.uvs !== null) {\r\n                bufferGeometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(buffers.uvs), 2));\r\n            }\r\n            if (buffers.skinIndex !== undefined && buffers.skinIndex !== null) {\r\n                bufferGeometry.setAttribute('skinIndex', new THREE.BufferAttribute(new Uint16Array(buffers.skinIndex), 4));\r\n            }\r\n            if (buffers.skinWeight !== undefined && buffers.skinWeight !== null) {\r\n                bufferGeometry.setAttribute('skinWeight', new THREE.BufferAttribute(new Float32Array(buffers.skinWeight), 4));\r\n            }\r\n            let material, materialName, key;\r\n            let materialNames = meshPayload.materials.materialNames;\r\n            let createMultiMaterial = meshPayload.materials.multiMaterial;\r\n            let multiMaterials = [];\r\n            for (key in materialNames) {\r\n                materialName = materialNames[key];\r\n                material = this.materialHandler.getMaterial(materialName);\r\n                if (createMultiMaterial)\r\n                    multiMaterials.push(material);\r\n            }\r\n            if (createMultiMaterial) {\r\n                material = multiMaterials;\r\n                let materialGroups = meshPayload.materials.materialGroups;\r\n                let materialGroup;\r\n                for (key in materialGroups) {\r\n                    materialGroup = materialGroups[key];\r\n                    bufferGeometry.addGroup(materialGroup.start, materialGroup.count, materialGroup.index);\r\n                }\r\n            }\r\n            let meshes = [];\r\n            let mesh;\r\n            let callbackOnMeshAlterResult;\r\n            let useOrgMesh = true;\r\n            let geometryType = meshPayload.geometryType === null ? 0 : meshPayload.geometryType;\r\n            if (this.callbacks.onMeshAlter) {\r\n                callbackOnMeshAlterResult = this.callbacks.onMeshAlter({\r\n                    detail: {\r\n                        meshName: meshName,\r\n                        bufferGeometry: bufferGeometry,\r\n                        material: material,\r\n                        geometryType: geometryType\r\n                    }\r\n                });\r\n            }\r\n            if (callbackOnMeshAlterResult) {\r\n                if (callbackOnMeshAlterResult.isDisregardMesh()) {\r\n                    useOrgMesh = false;\r\n                } else if (callbackOnMeshAlterResult.providesAlteredMeshes()) {\r\n                    for (let i in callbackOnMeshAlterResult.meshes) {\r\n                        meshes.push(callbackOnMeshAlterResult.meshes[i]);\r\n                    }\r\n                    useOrgMesh = false;\r\n                }\r\n            }\r\n            if (useOrgMesh) {\r\n                if (meshPayload.computeBoundingSphere)\r\n                    bufferGeometry.computeBoundingSphere();\r\n                if (geometryType === 0) {\r\n                    mesh = new THREE.Mesh(bufferGeometry, material);\r\n                } else if (geometryType === 1) {\r\n                    mesh = new THREE.LineSegments(bufferGeometry, material);\r\n                } else {\r\n                    mesh = new THREE.Points(bufferGeometry, material);\r\n                }\r\n                mesh.name = meshName;\r\n                meshes.push(mesh);\r\n            }\r\n            let progressMessage = meshPayload.params.meshName;\r\n            if (meshes.length > 0) {\r\n                let meshNames = [];\r\n                for (let i in meshes) {\r\n                    mesh = meshes[i];\r\n                    meshNames[i] = mesh.name;\r\n                }\r\n                progressMessage += ': Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;\r\n                progressMessage += ' (' + (meshPayload.progress.numericalValue * 100).toFixed(2) + '%)';\r\n            } else {\r\n                progressMessage += ': Not adding mesh: ' + meshName;\r\n                progressMessage += ' (' + (meshPayload.progress.numericalValue * 100).toFixed(2) + '%)';\r\n            }\r\n            if (this.callbacks.onProgress) {\r\n                this.callbacks.onProgress('progress', progressMessage, meshPayload.progress.numericalValue);\r\n            }\r\n            return meshes;\r\n        }\r\n    };\r\n\r\n    return  MeshReceiver;\r\n});"]}