{"version":3,"sources":["loaders/obj2/OBJLoader2Parser.js"],"names":["define","OBJLoader2Parser","this","logging","enabled","debug","scope","callbacks","onProgress","text","_onProgress","onAssetAvailable","payload","_onAssetAvailable","onError","errorMessage","_onError","onLoad","object3d","message","_onLoad","contentRef","legacyMode","materials","materialPerSmoothingGroup","useOAsMesh","useIndices","disregardNormals","vertices","colors","normals","uvs","rawMesh","objectName","groupName","activeMtlName","mtllibName","faceType","subGroups","subGroupInUse","smoothingGroup","splitMaterials","normalized","real","counts","doubleIndicesCount","faceCount","mtlCount","smoothingGroupCount","inputObjectCount","outputObjectCount","globalCounts","faces","lineByte","currentByte","totalBytes","prototype","constructor","_resetRawMesh","_pushSmoothingGroup","setMaterialPerSmoothingGroup","setUseOAsMesh","setUseIndices","setDisregardNormals","setMaterials","Object","assign","setCallbackOnAssetAvailable","undefined","Function","setCallbackOnProgress","setCallbackOnError","setCallbackOnLoad","console","log","error","setLogging","_configure","matKeys","keys","printedConfig","length","join","name","info","execute","arrayBuffer","time","arrayBufferView","Uint8Array","byteLength","buffer","Array","code","word","bufferPointer","slashesCount","i","_processLine","String","fromCharCode","_finalizeParsing","timeEnd","executeLegacy","char","bufferLength","lineDesignation","reconstructString","content","start","stop","line","trim","push","parseFloat","_checkFaceType","_buildFace","_processCompletedMesh","mtlName","_checkSubGroup","smoothingGroupInt","parseInt","isNaN","smoothCheck","index","materialName","indexMappingsCount","indexMappings","indices","faceIndexV","faceIndexU","faceIndexN","updateSubGroupInUse","faceIndexVi","indexPointerV","indexPointerC","faceIndexUi","indexPointerU","faceIndexNi","indexPointerN","mappingName","indicesPointer","_createRawMeshReport","_finalizeRawMesh","meshOutputGroup","meshOutputGroupTemp","absoluteVertexCount","absoluteIndexMappingsCount","absoluteIndexCount","absoluteColorCount","absoluteNormalCount","absoluteUvCount","result","haveMesh","_buildMesh","progressBytesPercent","toFixed","meshOutputGroups","vertexFA","Float32Array","selectedMaterialIndex","materialGroup","materialOrg","material","materialNameOrg","indexUA","Uint32Array","colorFA","normalFA","uvFA","haveVertexColors","materialNames","createMultiMaterial","materialIndex","materialIndexMapping","materialGroups","vertexFAOffset","indexUAOffset","colorFAOffset","normalFAOffset","uvFAOffset","materialGroupOffset","materialGroupLength","oodIndex","hasOwnProperty","materialCloneInstructions","materialProperties","vertexColors","flatShading","cmd","type","matCheck","count","set","materialIndexLine","createdReport","progress","numericalValue","params","meshName","multiMaterial","buffers","geometryType","parserFinalReport"],"mappings":";;;;;;;AAAAA,OAAO,WACH,aACA,MAAMC,EAAmB,WACrBC,KAAKC,SACDC,SAAS,EACTC,OAAO,GAEX,IAAIC,EAAQJ,KACZA,KAAKK,WACDC,WAAY,SAAUC,GAClBH,EAAMI,YAAYD,IAEtBE,iBAAkB,SAAUC,GACxBN,EAAMO,kBAAkBD,IAE5BE,QAAS,SAAUC,GACfT,EAAMU,SAASD,IAEnBE,OAAQ,SAAUC,EAAUC,GACxBb,EAAMc,QAAQF,EAAUC,KAGhCjB,KAAKmB,WAAa,KAClBnB,KAAKoB,YAAa,EAClBpB,KAAKqB,aACLrB,KAAKsB,2BAA4B,EACjCtB,KAAKuB,YAAa,EAClBvB,KAAKwB,YAAa,EAClBxB,KAAKyB,kBAAmB,EACxBzB,KAAK0B,YACL1B,KAAK2B,UACL3B,KAAK4B,WACL5B,KAAK6B,OACL7B,KAAK8B,SACDC,WAAY,GACZC,UAAW,GACXC,cAAe,GACfC,WAAY,GACZC,UAAW,EACXC,aACAC,cAAe,KACfC,gBACIC,gBAAgB,EAChBC,YAAa,EACbC,MAAO,GAEXC,QACIC,mBAAoB,EACpBC,UAAW,EACXC,SAAU,EACVC,oBAAqB,IAG7B9C,KAAK+C,iBAAmB,EACxB/C,KAAKgD,kBAAoB,EACzBhD,KAAKiD,cACDvB,SAAU,EACVwB,MAAO,EACPP,mBAAoB,EACpBQ,SAAU,EACVC,YAAa,EACbC,WAAY,IA+kBpB,OA5kBAtD,EAAiBuD,WACbC,YAAaxD,EACbyD,cAAe,WACXxD,KAAK8B,QAAQM,aACbpC,KAAK8B,QAAQO,cAAgB,KAC7BrC,KAAK8B,QAAQQ,eAAeE,YAAc,EAC1CxC,KAAK8B,QAAQQ,eAAeG,MAAQ,EACpCzC,KAAKyD,oBAAoB,GACzBzD,KAAK8B,QAAQY,OAAOC,mBAAqB,EACzC3C,KAAK8B,QAAQY,OAAOE,UAAY,EAChC5C,KAAK8B,QAAQY,OAAOG,SAAW,EAC/B7C,KAAK8B,QAAQY,OAAOI,oBAAsB,GAE9CY,6BAA8B,SAAUpC,GAEpC,OADAtB,KAAKsB,2BAA0D,IAA9BA,EAC1BtB,MAEX2D,cAAe,SAAUpC,GAErB,OADAvB,KAAKuB,YAA4B,IAAfA,EACXvB,MAEX4D,cAAe,SAAUpC,GAErB,OADAxB,KAAKwB,YAA4B,IAAfA,EACXxB,MAEX6D,oBAAqB,SAAUpC,GAE3B,OADAzB,KAAKyB,kBAAwC,IAArBA,EACjBzB,MAEX8D,aAAc,SAAUzC,GACpBrB,KAAKqB,UAAY0C,OAAOC,UAAW3C,IAEvC4C,4BAA6B,SAAUxD,GAInC,OAHyB,OAArBA,QAAkDyD,IAArBzD,GAAkCA,aAA4B0D,WAC3FnE,KAAKK,UAAUI,iBAAmBA,GAE/BT,MAEXoE,sBAAuB,SAAU9D,GAI7B,OAHmB,OAAfA,QAAsC4D,IAAf5D,GAA4BA,aAAsB6D,WACzEnE,KAAKK,UAAUC,WAAaA,GAEzBN,MAEXqE,mBAAoB,SAAUzD,GAI1B,OAHgB,OAAZA,QAAgCsD,IAAZtD,GAAyBA,aAAmBuD,WAChEnE,KAAKK,UAAUO,QAAUA,GAEtBZ,MAEXsE,kBAAmB,SAAUvD,GAIzB,OAHe,OAAXA,QAA8BmD,IAAXnD,GAAwBA,aAAkBoD,WAC7DnE,KAAKK,UAAUU,OAASA,GAErBf,MAEXQ,YAAa,SAAUD,GACnB,IAAIU,EAAUV,GAAc,GACxBP,KAAKC,QAAQC,SAAWF,KAAKC,QAAQE,OACrCoE,QAAQC,IAAIvD,IAGpBH,SAAU,SAAUD,GACZb,KAAKC,QAAQC,SAAWF,KAAKC,QAAQE,OACrCoE,QAAQE,MAAM5D,IAGtBF,kBAAmB,SAAUD,GACzB,IAAIG,EAAe,qFAEnB,MADAb,KAAKK,UAAUO,QAAQC,GACjBA,GAEVK,QAAS,SAAUF,EAAUC,GACzBsD,QAAQC,IAAI,+CAAiDvD,IAEjEyD,WAAY,SAAUxE,EAASC,GAG3B,OAFAH,KAAKC,QAAQC,SAAsB,IAAZA,EACvBF,KAAKC,QAAQE,OAAkB,IAAVA,EACdH,MAEX2E,WAAY,WAER,GADA3E,KAAKyD,oBAAoB,GACrBzD,KAAKC,QAAQC,QAAS,CACtB,IAAI0E,EAAUb,OAAOc,KAAK7E,KAAKqB,WAE3ByD,EAAgB,mCADLF,EAAQG,OAAS,EAAI,6BAA+BH,EAAQI,KAAK,YAAc,2BAC3B,kCAAoChF,KAAKsB,0BAA4B,mBAAqBtB,KAAKuB,WAAa,mBAAqBvB,KAAKwB,WAAa,yBAA2BxB,KAAKyB,iBACtPqD,GAAiB,6BAA+B9E,KAAKK,UAAUC,WAAW2E,KAC1EH,GAAiB,mCAAqC9E,KAAKK,UAAUI,iBAAiBwE,KACtFH,GAAiB,0BAA4B9E,KAAKK,UAAUO,QAAQqE,KACpEV,QAAQW,KAAKJ,KAGrBK,QAAS,SAAUC,GACXpF,KAAKC,QAAQC,SACbqE,QAAQc,KAAK,4BACjBrF,KAAK2E,aACL,IAAIW,EAAkB,IAAIC,WAAWH,GACrCpF,KAAKmB,WAAamE,EAClB,IAAIP,EAASO,EAAgBE,WAC7BxF,KAAKiD,aAAaI,WAAa0B,EAC/B,IAAIU,EAAS,IAAIC,MAAM,KACvB,IAAK,IAAIC,EAAMC,EAAO,GAAIC,EAAgB,EAAGC,EAAe,EAAGC,EAAI,EAAGA,EAAIhB,EAAQgB,IAE9E,OADAJ,EAAOL,EAAgBS,IAEvB,KAAK,GACGH,EAAKb,OAAS,IACdU,EAAOI,KAAmBD,GAC9BA,EAAO,GACP,MACJ,KAAK,GACGA,EAAKb,OAAS,IACdU,EAAOI,KAAmBD,GAC9BE,IACAF,EAAO,GACP,MACJ,KAAK,GACGA,EAAKb,OAAS,IACdU,EAAOI,KAAmBD,GAC9BA,EAAO,GACP5F,KAAKiD,aAAaE,SAAWnD,KAAKiD,aAAaG,YAC/CpD,KAAKiD,aAAaG,YAAc2C,EAChC/F,KAAKgG,aAAaP,EAAQI,EAAeC,GACzCD,EAAgB,EAChBC,EAAe,EACf,MACJ,KAAK,GACD,MACJ,QACIF,GAAQK,OAAOC,aAAaP,GAIpC3F,KAAKmG,mBACDnG,KAAKC,QAAQC,SACbqE,QAAQ6B,QAAQ,6BAExBC,cAAe,SAAU9F,GACjBP,KAAKC,QAAQC,SACbqE,QAAQc,KAAK,kCACjBrF,KAAK2E,aACL3E,KAAKoB,YAAa,EAClBpB,KAAKmB,WAAaZ,EAClB,IAAIwE,EAASxE,EAAKwE,OAClB/E,KAAKiD,aAAaI,WAAa0B,EAC/B,IAAIU,EAAS,IAAIC,MAAM,KACvB,IAAK,IAAIY,EAAMV,EAAO,GAAIC,EAAgB,EAAGC,EAAe,EAAGC,EAAI,EAAGA,EAAIhB,EAAQgB,IAE9E,OADAO,EAAO/F,EAAKwF,IAEZ,IAAK,IACGH,EAAKb,OAAS,IACdU,EAAOI,KAAmBD,GAC9BA,EAAO,GACP,MACJ,IAAK,IACGA,EAAKb,OAAS,IACdU,EAAOI,KAAmBD,GAC9BE,IACAF,EAAO,GACP,MACJ,IAAK,KACGA,EAAKb,OAAS,IACdU,EAAOI,KAAmBD,GAC9BA,EAAO,GACP5F,KAAKiD,aAAaE,SAAWnD,KAAKiD,aAAaG,YAC/CpD,KAAKiD,aAAaG,YAAc2C,EAChC/F,KAAKgG,aAAaP,EAAQI,EAAeC,GACzCD,EAAgB,EAChBC,EAAe,EACf,MACJ,IAAK,KACD,MACJ,QACIF,GAAQU,EAGhBtG,KAAKmG,mBACDnG,KAAKC,QAAQC,SACbqE,QAAQ6B,QAAQ,mCAExBJ,aAAc,SAAUP,EAAQI,EAAeC,GAC3C,GAAID,EAAgB,EAChB,OACJ,IAeIU,EAAcxB,EAAQgB,EAAGS,EAfzBC,EAAoB,SAAUC,EAAStF,EAAYuF,EAAOC,GAC1D,IAAIC,EAAO,GACX,GAAID,EAAOD,EAAO,CACd,IAAIZ,EACJ,GAAI3E,EACA,IAAK2E,EAAIY,EAAOZ,EAAIa,EAAMb,IACtBc,GAAQH,EAAQX,QAEpB,IAAKA,EAAIY,EAAOZ,EAAIa,EAAMb,IACtBc,GAAQZ,OAAOC,aAAaQ,EAAQX,IAE5Cc,EAAOA,EAAKC,OAEhB,OAAOD,GAIX,OADAL,EAAkBf,EAAO,IAEzB,IAAK,IACDzF,KAAK0B,SAASqF,KAAKC,WAAWvB,EAAO,KACrCzF,KAAK0B,SAASqF,KAAKC,WAAWvB,EAAO,KACrCzF,KAAK0B,SAASqF,KAAKC,WAAWvB,EAAO,KACjCI,EAAgB,IAChB7F,KAAK2B,OAAOoF,KAAKC,WAAWvB,EAAO,KACnCzF,KAAK2B,OAAOoF,KAAKC,WAAWvB,EAAO,KACnCzF,KAAK2B,OAAOoF,KAAKC,WAAWvB,EAAO,MAEvC,MACJ,IAAK,KACDzF,KAAK6B,IAAIkF,KAAKC,WAAWvB,EAAO,KAChCzF,KAAK6B,IAAIkF,KAAKC,WAAWvB,EAAO,KAChC,MACJ,IAAK,KACDzF,KAAK4B,QAAQmF,KAAKC,WAAWvB,EAAO,KACpCzF,KAAK4B,QAAQmF,KAAKC,WAAWvB,EAAO,KACpCzF,KAAK4B,QAAQmF,KAAKC,WAAWvB,EAAO,KACpC,MACJ,IAAK,IAED,GADAc,EAAeV,EAAgB,EACV,IAAjBC,EAEA,IADA9F,KAAKiH,eAAe,GACflB,EAAI,EAAGhB,EAASwB,EAAcR,EAAIhB,EAAQgB,IAC3C/F,KAAKkH,WAAWzB,EAAO,IACvBzF,KAAKkH,WAAWzB,EAAOM,IACvB/F,KAAKkH,WAAWzB,EAAOM,EAAI,SAE5B,GAAIQ,IAAgC,EAAfT,EAExB,IADA9F,KAAKiH,eAAe,GACflB,EAAI,EAAGhB,EAASwB,EAAe,EAAGR,EAAIhB,EAAQgB,GAAK,EACpD/F,KAAKkH,WAAWzB,EAAO,GAAIA,EAAO,IAClCzF,KAAKkH,WAAWzB,EAAOM,GAAIN,EAAOM,EAAI,IACtC/F,KAAKkH,WAAWzB,EAAOM,EAAI,GAAIN,EAAOM,EAAI,SAE3C,GAAmB,EAAfQ,GAAoC,EAAfT,EAE5B,IADA9F,KAAKiH,eAAe,GACflB,EAAI,EAAGhB,EAASwB,EAAe,EAAGR,EAAIhB,EAAQgB,GAAK,EACpD/F,KAAKkH,WAAWzB,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC7CzF,KAAKkH,WAAWzB,EAAOM,GAAIN,EAAOM,EAAI,GAAIN,EAAOM,EAAI,IACrD/F,KAAKkH,WAAWzB,EAAOM,EAAI,GAAIN,EAAOM,EAAI,GAAIN,EAAOM,EAAI,SAI7D,IADA/F,KAAKiH,eAAe,GACflB,EAAI,EAAGhB,EAASwB,EAAe,EAAGR,EAAIhB,EAAQgB,GAAK,EACpD/F,KAAKkH,WAAWzB,EAAO,QAAIvB,EAAWuB,EAAO,IAC7CzF,KAAKkH,WAAWzB,EAAOM,QAAI7B,EAAWuB,EAAOM,EAAI,IACjD/F,KAAKkH,WAAWzB,EAAOM,EAAI,QAAI7B,EAAWuB,EAAOM,EAAI,IAG7D,MACJ,IAAK,IACL,IAAK,IAED,IADAQ,EAAeV,EAAgB,KACK,EAAfC,EAEjB,IADA9F,KAAKiH,eAAe,GACflB,EAAI,EAAGhB,EAASwB,EAAe,EAAGR,EAAIhB,EAAQgB,GAAK,EACpD/F,KAAKkH,WAAWzB,EAAOM,GAAIN,EAAOM,EAAI,SAG1C,IADA/F,KAAKiH,eAAmC,MAApBT,EAA0B,EAAI,GAC7CT,EAAI,EAAGhB,EAASwB,EAAe,EAAGR,EAAIhB,EAAQgB,IAC/C/F,KAAKkH,WAAWzB,EAAOM,IAE/B,MACJ,IAAK,IACD/F,KAAKyD,oBAAoBgC,EAAO,IAChC,MACJ,IAAK,IACDzF,KAAKmH,wBACLnH,KAAK8B,QAAQE,UAAYyE,EAAkBzG,KAAKmB,WAAYnB,KAAKoB,WAAYpB,KAAKiD,aAAaE,SAAW,EAAGnD,KAAKiD,aAAaG,aAC/H,MACJ,IAAK,IACGpD,KAAKuB,YACLvB,KAAKmH,wBACTnH,KAAK8B,QAAQC,WAAa0E,EAAkBzG,KAAKmB,WAAYnB,KAAKoB,WAAYpB,KAAKiD,aAAaE,SAAW,EAAGnD,KAAKiD,aAAaG,aAChI,MACJ,IAAK,SACDpD,KAAK8B,QAAQI,WAAauE,EAAkBzG,KAAKmB,WAAYnB,KAAKoB,WAAYpB,KAAKiD,aAAaE,SAAW,EAAGnD,KAAKiD,aAAaG,aAChI,MACJ,IAAK,SACD,IAAIgE,EAAUX,EAAkBzG,KAAKmB,WAAYnB,KAAKoB,WAAYpB,KAAKiD,aAAaE,SAAW,EAAGnD,KAAKiD,aAAaG,aACpG,KAAZgE,GAAkBpH,KAAK8B,QAAQG,gBAAkBmF,IACjDpH,KAAK8B,QAAQG,cAAgBmF,EAC7BpH,KAAK8B,QAAQY,OAAOG,WACpB7C,KAAKqH,oBAOjB5D,oBAAqB,SAAUnB,GAC3B,IAAIgF,EAAoBC,SAASjF,GAC7BkF,MAAMF,KACNA,EAAuC,QAAnBhF,EAA2B,EAAI,GAEvD,IAAImF,EAAczH,KAAK8B,QAAQQ,eAAeE,WAC9CxC,KAAK8B,QAAQQ,eAAeE,WAAaxC,KAAK8B,QAAQQ,eAAeC,eAAiB+E,EAA0C,IAAtBA,EAA0B,EAAI,EACxItH,KAAK8B,QAAQQ,eAAeG,KAAO6E,EAC/BG,IAAgBH,IAChBtH,KAAK8B,QAAQY,OAAOI,sBACpB9C,KAAKqH,mBAGbJ,eAAgB,SAAU9E,GAClBnC,KAAK8B,QAAQK,WAAaA,IAC1BnC,KAAKmH,wBACLnH,KAAK8B,QAAQK,SAAWA,EACxBnC,KAAKqH,mBAGbA,eAAgB,WACZ,IAAIK,EAAQ1H,KAAK8B,QAAQG,cAAgB,IAAMjC,KAAK8B,QAAQQ,eAAeE,WAC3ExC,KAAK8B,QAAQO,cAAgBrC,KAAK8B,QAAQM,UAAUsF,QACjBxD,IAA/BlE,KAAK8B,QAAQO,eAA8D,OAA/BrC,KAAK8B,QAAQO,gBACzDrC,KAAK8B,QAAQO,eACTqF,MAAOA,EACP3F,WAAY/B,KAAK8B,QAAQC,WACzBC,UAAWhC,KAAK8B,QAAQE,UACxB2F,aAAc3H,KAAK8B,QAAQG,cAC3BK,eAAgBtC,KAAK8B,QAAQQ,eAAeE,WAC5Cd,YACAkG,mBAAoB,EACpBC,iBACAC,WACAnG,UACAE,OACAD,YAEJ5B,KAAK8B,QAAQM,UAAUsF,GAAS1H,KAAK8B,QAAQO,gBAGrD6E,WAAY,SAAUa,EAAYC,EAAYC,GAC1C,IAAI5F,EAAgBrC,KAAK8B,QAAQO,cAC7BjC,EAAQJ,KACRkI,EAAsB,WACtB,IAAIC,EAAcZ,SAASQ,GACvBK,EAAgB,GAAKD,EAAc,EAAIA,EAAc,EAAIA,EAAc/H,EAAMsB,SAASqD,OAAS,GAC/FsD,EAAgBjI,EAAMuB,OAAOoD,OAAS,EAAIqD,EAAgB,KAC1D1G,EAAWW,EAAcX,SAI7B,GAHAA,EAASqF,KAAK3G,EAAMsB,SAAS0G,MAC7B1G,EAASqF,KAAK3G,EAAMsB,SAAS0G,MAC7B1G,EAASqF,KAAK3G,EAAMsB,SAAS0G,IACP,OAAlBC,EAAwB,CACxB,IAAI1G,EAASU,EAAcV,OAC3BA,EAAOoF,KAAK3G,EAAMuB,OAAO0G,MACzB1G,EAAOoF,KAAK3G,EAAMuB,OAAO0G,MACzB1G,EAAOoF,KAAK3G,EAAMuB,OAAO0G,IAE7B,GAAIL,EAAY,CACZ,IAAIM,EAAcf,SAASS,GACvBO,EAAgB,GAAKD,EAAc,EAAIA,EAAc,EAAIA,EAAclI,EAAMyB,IAAIkD,OAAS,GAC1FlD,EAAMQ,EAAcR,IACxBA,EAAIkF,KAAK3G,EAAMyB,IAAI0G,MACnB1G,EAAIkF,KAAK3G,EAAMyB,IAAI0G,IAEvB,GAAIN,IAAe7H,EAAMqB,iBAAkB,CACvC,IAAI+G,EAAcjB,SAASU,GACvBQ,EAAgB,GAAKD,EAAc,EAAIA,EAAc,EAAIA,EAAcpI,EAAMwB,QAAQmD,OAAS,GAC9FnD,EAAUS,EAAcT,QAC5BA,EAAQmF,KAAK3G,EAAMwB,QAAQ6G,MAC3B7G,EAAQmF,KAAK3G,EAAMwB,QAAQ6G,MAC3B7G,EAAQmF,KAAK3G,EAAMwB,QAAQ6G,MAGnC,GAAIzI,KAAKwB,WAAY,CACbxB,KAAKyB,mBACLwG,OAAa/D,GACjB,IAAIwE,EAAcX,GAAcC,EAAa,IAAMA,EAAa,OAASC,EAAa,IAAMA,EAAa,MACrGU,EAAiBtG,EAAcwF,cAAca,QAC1BxE,IAAnByE,GAAmD,OAAnBA,GAChCA,EAAiB3I,KAAK8B,QAAQO,cAAcX,SAASqD,OAAS,EAC9DmD,IACA7F,EAAcwF,cAAca,GAAeC,EAC3CtG,EAAcuF,sBAEd5H,KAAK8B,QAAQY,OAAOC,qBAExBN,EAAcyF,QAAQf,KAAK4B,QAE3BT,IAEJlI,KAAK8B,QAAQY,OAAOE,aAExBgG,qBAAsB,SAAU7F,GAC5B,MAAO,wBAA0BA,EAAmB,oBAAsB/C,KAAK8B,QAAQC,WAAa,mBAAqB/B,KAAK8B,QAAQE,UAAY,oBAAsBhC,KAAK8B,QAAQI,WAAa,qBAAuBlC,KAAK0B,SAASqD,OAAS,EAAI,qBAAuB/E,KAAK4B,QAAQmD,OAAS,EAAI,iBAAmB/E,KAAK6B,IAAIkD,OAAS,EAAI,6BAA+B/E,KAAK8B,QAAQY,OAAOI,oBAAsB,uBAAyB9C,KAAK8B,QAAQY,OAAOG,SAAW,mCAAqC7C,KAAK8B,QAAQM,UAAU2C,QAE/gB8D,iBAAkB,WACd,IACIC,EAOAhB,EARAiB,KAEAC,EAAsB,EACtBC,EAA6B,EAC7BC,EAAqB,EACrBC,EAAqB,EACrBC,EAAsB,EACtBC,EAAkB,EAEtB,IAAK,IAAIpE,KAAQjF,KAAK8B,QAAQM,UAE1B,IADA0G,EAAkB9I,KAAK8B,QAAQM,UAAU6C,IACrBvD,SAASqD,OAAS,EAAG,CAErC,IADA+C,EAAUgB,EAAgBhB,SACd/C,OAAS,GAAKkE,EAA6B,EACnD,IAAK,IAAIlD,EAAI,EAAGA,EAAI+B,EAAQ/C,OAAQgB,IAChC+B,EAAQ/B,GAAK+B,EAAQ/B,GAAKkD,EAGlCF,EAAoBhC,KAAK+B,GACzBE,GAAuBF,EAAgBpH,SAASqD,OAChDkE,GAA8BH,EAAgBlB,mBAC9CsB,GAAsBJ,EAAgBhB,QAAQ/C,OAC9CoE,GAAsBL,EAAgBnH,OAAOoD,OAC7CsE,GAAmBP,EAAgBjH,IAAIkD,OACvCqE,GAAuBN,EAAgBlH,QAAQmD,OAGvD,IAAIuE,EAAS,KAcb,OAbIP,EAAoBhE,OAAS,IAC7BuE,GACIrE,KAAiC,KAA3BjF,KAAK8B,QAAQE,UAAmBhC,KAAK8B,QAAQE,UAAYhC,KAAK8B,QAAQC,WAC5EK,UAAW2G,EACXC,oBAAqBA,EACrBE,mBAAoBA,EACpBC,mBAAoBA,EACpBC,oBAAqBA,EACrBC,gBAAiBA,EACjBzG,UAAW5C,KAAK8B,QAAQY,OAAOE,UAC/BD,mBAAoB3C,KAAK8B,QAAQY,OAAOC,qBAGzC2G,GAEXnC,sBAAuB,WACnB,IAAImC,EAAStJ,KAAK6I,mBACdU,EAAsB,OAAXD,EACf,GAAIC,EAAU,CACNvJ,KAAK2B,OAAOoD,OAAS,GAAK/E,KAAK2B,OAAOoD,SAAW/E,KAAK0B,SAASqD,QAC/D/E,KAAKK,UAAUO,QAAQ,+EAEvBZ,KAAKC,QAAQC,SAAWF,KAAKC,QAAQE,OACrCoE,QAAQpE,MAAMH,KAAK4I,qBAAqB5I,KAAK+C,mBACjD/C,KAAK+C,mBACL/C,KAAKwJ,WAAWF,GAChB,IAAIG,EAAuBzJ,KAAKiD,aAAaG,YAAcpD,KAAKiD,aAAaI,WAC7ErD,KAAKQ,YAAY,iBAAmBR,KAAK8B,QAAQC,WAAa,MAAQ/B,KAAK8B,QAAQE,UAAiB,sBAA+C,IAAvByH,GAA4BC,QAAQ,GAAK,KACrK1J,KAAKwD,gBAET,OAAO+F,GAEXC,WAAY,SAAUF,GAClB,IAAIK,EAAmBL,EAAOlH,UAC1BwH,EAAW,IAAIC,aAAaP,EAAON,qBACvChJ,KAAKiD,aAAavB,UAAY4H,EAAON,oBAAsB,EAC3DhJ,KAAKiD,aAAaC,OAASoG,EAAO1G,UAClC5C,KAAKiD,aAAaN,oBAAsB2G,EAAO3G,mBAC/C,IAKImG,EAKAgB,EACAC,EASAC,EAAaC,EAAUtC,EAAcuC,EApBrCC,EAAUb,EAAOJ,mBAAqB,EAAI,IAAIkB,YAAYd,EAAOJ,oBAAsB,KACvFmB,EAAUf,EAAOH,mBAAqB,EAAI,IAAIU,aAAaP,EAAOH,oBAAsB,KACxFmB,EAAWhB,EAAOF,oBAAsB,EAAI,IAAIS,aAAaP,EAAOF,qBAAuB,KAC3FmB,EAAOjB,EAAOD,gBAAkB,EAAI,IAAIQ,aAAaP,EAAOD,iBAAmB,KAC/EmB,EAA+B,OAAZH,EAEnBI,KACAC,EAAsBf,EAAiB5E,OAAS,EAChD4F,EAAgB,EAChBC,KAGAC,KACAC,EAAiB,EACjBC,EAAgB,EAChBC,EAAgB,EAChBC,EAAiB,EACjBC,EAAa,EACbC,EAAsB,EACtBC,EAAsB,EAE1B,IAAK,IAAIC,KAAY1B,EACjB,GAAKA,EAAiB2B,eAAeD,GAArC,CAkBA,GAfAnB,GADApB,EAAkBa,EAAiB0B,IACD1D,aAE9BA,EADA3H,KAAK8B,QAAQK,SAAW,EACT+H,GAAmBM,EAAmB,eAAiB,KAA0C,IAAnC1B,EAAgBxG,eAAuB,QAAU,IAErF,IAA1BtC,KAAK8B,QAAQK,SAAiB,uBAAyB,sBAE1E6H,EAAchK,KAAKqB,UAAU6I,GAC7BD,EAAWjK,KAAKqB,UAAUsG,QACLzD,IAAhB8F,GAA6C,OAAhBA,QAAuC9F,IAAb+F,GAAuC,OAAbA,IAClFtC,EAAe6C,EAAmB,6BAA+B,kBACjEP,EAAWjK,KAAKqB,UAAUsG,GACtB3H,KAAKC,QAAQC,SACbqE,QAAQW,KAAK,iBAAmB4D,EAAgB/G,WAAa,IAAM+G,EAAgB9G,UAAY,6CAA+CkI,EAAkB,iBAAmBvC,EAAe,YAGzLzD,IAAb+F,GAAuC,OAAbA,EAAmB,CAC7C,IAAIsB,GACArB,gBAAiBA,EACjBvC,aAAcA,EACd6D,oBACIC,aAAcjB,EAAmB,EAAI,EACrCkB,YAAgD,IAAnC5C,EAAgBxG,iBAGjC5B,GACAiL,IAAK,iBACLC,KAAM,WACNvK,WAAakK,0BAA2BA,IAE5CvL,KAAKK,UAAUI,iBAAiBC,GAChC,IAAImL,EAAW7L,KAAKqB,UAAUsG,QACbzD,IAAb2H,GAAuC,OAAbA,IAC1B7L,KAAKqB,UAAUsG,GAAgB4D,GAwCvC,GArCIb,IACAZ,EAAwBc,EAAqBjD,MAEzCmC,EAAwBa,EACxBC,EAAqBjD,GAAgBgD,EACrCF,EAAc1D,KAAKY,GACnBgD,KAGJZ,GACIpD,MAAOwE,EACPW,MAHJV,EAAsBpL,KAAKwB,WAAasH,EAAgBhB,QAAQ/C,OAAS+D,EAAgBpH,SAASqD,OAAS,EAIvG2C,MAAOoC,GAEXe,EAAe9D,KAAKgD,GACpBoB,GAAuBC,GAEvBX,EAAc1D,KAAKY,GAEvBiC,EAASmC,IAAIjD,EAAgBpH,SAAUoJ,GACvCA,GAAkBhC,EAAgBpH,SAASqD,OACvCoF,IACAA,EAAQ4B,IAAIjD,EAAgBhB,QAASiD,GACrCA,GAAiBjC,EAAgBhB,QAAQ/C,QAEzCsF,IACAA,EAAQ0B,IAAIjD,EAAgBnH,OAAQqJ,GACpCA,GAAiBlC,EAAgBnH,OAAOoD,QAExCuF,IACAA,EAASyB,IAAIjD,EAAgBlH,QAASqJ,GACtCA,GAAkBnC,EAAgBlH,QAAQmD,QAE1CwF,IACAA,EAAKwB,IAAIjD,EAAgBjH,IAAKqJ,GAC9BA,GAAcpC,EAAgBjH,IAAIkD,QAElC/E,KAAKC,QAAQC,SAAWF,KAAKC,QAAQE,MAAO,CAC5C,IAAI6L,OAA8C9H,IAA1B4F,GAAiE,OAA1BA,EAAiC,GAAK,wBAA0BA,EAC3HmC,EAAgB,wBAA0BjM,KAAKgD,kBAAoB,oBAAsB8F,EAAgB9G,UAAY,gBAAkB8G,EAAgBpB,MAAQ,mBAAqB1H,KAAK8B,QAAQK,SAAW,uBAAyB2G,EAAgBnB,aAAe,yBAA2BmB,EAAgBxG,eAAiB0J,EAAoB,qBAAuBlD,EAAgB/G,WAAa,oBAAsB+G,EAAgBpH,SAASqD,OAAS,EAAI,mBAAqB+D,EAAgBhB,QAAQ/C,OAAS,kBAAoB+D,EAAgBnH,OAAOoD,OAAS,EAAI,eAAiB+D,EAAgBjH,IAAIkD,OAAS,EAAI,mBAAqB+D,EAAgBlH,QAAQmD,OAAS,EAC9pBR,QAAQpE,MAAM8L,IAGtBjM,KAAKgD,oBACLhD,KAAKK,UAAUI,kBACXkL,IAAK,iBACLC,KAAM,OACNM,UAAYC,eAAgBnM,KAAKiD,aAAaG,YAAcpD,KAAKiD,aAAaI,YAC9E+I,QAAUC,SAAU/C,EAAOrE,MAC3B5D,WACIiL,cAAe5B,EACfD,cAAeA,EACfI,eAAgBA,GAEpB0B,SACI7K,SAAUkI,EACV9B,QAASqC,EACTxI,OAAQ0I,EACRzI,QAAS0I,EACTzI,IAAK0I,GAETiC,aAAcxM,KAAK8B,QAAQK,SAAW,EAAI,EAA8B,IAA1BnC,KAAK8B,QAAQK,SAAiB,EAAI,IAChFyH,EAASnE,QAAqB,OAAZ0E,GAAoBA,EAAQ1E,QAAU,KAAkB,OAAZ4E,GAAoBA,EAAQ5E,QAAU,KAAmB,OAAb6E,GAAqBA,EAAS7E,QAAU,KAAe,OAAT8E,GAAiBA,EAAK9E,QAAU,OAEhMU,iBAAkB,WAGd,GAFInG,KAAKC,QAAQC,SACbqE,QAAQW,KAAK,+BAAiClF,KAAKgD,mBACnDhD,KAAKmH,yBAA2BnH,KAAKC,QAAQC,QAAS,CACtD,IAAIuM,EAAoB,iCAAwCzM,KAAKiD,aAAavB,SAAW,cAAgB1B,KAAKiD,aAAaC,MAAQ,6BAA+BlD,KAAKiD,aAAaN,mBACxL4B,QAAQW,KAAKuH,MAKlB1M","file":"../../../loaders/obj2/OBJLoader2Parser.js","sourcesContent":["define(function () {\r\n    'use strict';\r\n    const OBJLoader2Parser = function () {\r\n        this.logging = {\r\n            enabled: false,\r\n            debug: false\r\n        };\r\n        let scope = this;\r\n        this.callbacks = {\r\n            onProgress: function (text) {\r\n                scope._onProgress(text);\r\n            },\r\n            onAssetAvailable: function (payload) {\r\n                scope._onAssetAvailable(payload);\r\n            },\r\n            onError: function (errorMessage) {\r\n                scope._onError(errorMessage);\r\n            },\r\n            onLoad: function (object3d, message) {\r\n                scope._onLoad(object3d, message);\r\n            }\r\n        };\r\n        this.contentRef = null;\r\n        this.legacyMode = false;\r\n        this.materials = {};\r\n        this.materialPerSmoothingGroup = false;\r\n        this.useOAsMesh = false;\r\n        this.useIndices = false;\r\n        this.disregardNormals = false;\r\n        this.vertices = [];\r\n        this.colors = [];\r\n        this.normals = [];\r\n        this.uvs = [];\r\n        this.rawMesh = {\r\n            objectName: '',\r\n            groupName: '',\r\n            activeMtlName: '',\r\n            mtllibName: '',\r\n            faceType: -1,\r\n            subGroups: [],\r\n            subGroupInUse: null,\r\n            smoothingGroup: {\r\n                splitMaterials: false,\r\n                normalized: -1,\r\n                real: -1\r\n            },\r\n            counts: {\r\n                doubleIndicesCount: 0,\r\n                faceCount: 0,\r\n                mtlCount: 0,\r\n                smoothingGroupCount: 0\r\n            }\r\n        };\r\n        this.inputObjectCount = 1;\r\n        this.outputObjectCount = 1;\r\n        this.globalCounts = {\r\n            vertices: 0,\r\n            faces: 0,\r\n            doubleIndicesCount: 0,\r\n            lineByte: 0,\r\n            currentByte: 0,\r\n            totalBytes: 0\r\n        };\r\n    };\r\n    OBJLoader2Parser.prototype = {\r\n        constructor: OBJLoader2Parser,\r\n        _resetRawMesh: function () {\r\n            this.rawMesh.subGroups = [];\r\n            this.rawMesh.subGroupInUse = null;\r\n            this.rawMesh.smoothingGroup.normalized = -1;\r\n            this.rawMesh.smoothingGroup.real = -1;\r\n            this._pushSmoothingGroup(1);\r\n            this.rawMesh.counts.doubleIndicesCount = 0;\r\n            this.rawMesh.counts.faceCount = 0;\r\n            this.rawMesh.counts.mtlCount = 0;\r\n            this.rawMesh.counts.smoothingGroupCount = 0;\r\n        },\r\n        setMaterialPerSmoothingGroup: function (materialPerSmoothingGroup) {\r\n            this.materialPerSmoothingGroup = materialPerSmoothingGroup === true;\r\n            return this;\r\n        },\r\n        setUseOAsMesh: function (useOAsMesh) {\r\n            this.useOAsMesh = useOAsMesh === true;\r\n            return this;\r\n        },\r\n        setUseIndices: function (useIndices) {\r\n            this.useIndices = useIndices === true;\r\n            return this;\r\n        },\r\n        setDisregardNormals: function (disregardNormals) {\r\n            this.disregardNormals = disregardNormals === true;\r\n            return this;\r\n        },\r\n        setMaterials: function (materials) {\r\n            this.materials = Object.assign({}, materials);\r\n        },\r\n        setCallbackOnAssetAvailable: function (onAssetAvailable) {\r\n            if (onAssetAvailable !== null && onAssetAvailable !== undefined && onAssetAvailable instanceof Function) {\r\n                this.callbacks.onAssetAvailable = onAssetAvailable;\r\n            }\r\n            return this;\r\n        },\r\n        setCallbackOnProgress: function (onProgress) {\r\n            if (onProgress !== null && onProgress !== undefined && onProgress instanceof Function) {\r\n                this.callbacks.onProgress = onProgress;\r\n            }\r\n            return this;\r\n        },\r\n        setCallbackOnError: function (onError) {\r\n            if (onError !== null && onError !== undefined && onError instanceof Function) {\r\n                this.callbacks.onError = onError;\r\n            }\r\n            return this;\r\n        },\r\n        setCallbackOnLoad: function (onLoad) {\r\n            if (onLoad !== null && onLoad !== undefined && onLoad instanceof Function) {\r\n                this.callbacks.onLoad = onLoad;\r\n            }\r\n            return this;\r\n        },\r\n        _onProgress: function (text) {\r\n            let message = text ? text : '';\r\n            if (this.logging.enabled && this.logging.debug) {\r\n                console.log(message);\r\n            }\r\n        },\r\n        _onError: function (errorMessage) {\r\n            if (this.logging.enabled && this.logging.debug) {\r\n                console.error(errorMessage);\r\n            }\r\n        },\r\n        _onAssetAvailable: function (payload) {\r\n            let errorMessage = 'OBJLoader2Parser does not provide implementation for onAssetAvailable. Aborting...';\r\n            this.callbacks.onError(errorMessage);\r\n            throw errorMessage;\r\n        },\r\n        _onLoad: function (object3d, message) {\r\n            console.log('You reached parser default onLoad callback: ' + message);\r\n        },\r\n        setLogging: function (enabled, debug) {\r\n            this.logging.enabled = enabled === true;\r\n            this.logging.debug = debug === true;\r\n            return this;\r\n        },\r\n        _configure: function () {\r\n            this._pushSmoothingGroup(1);\r\n            if (this.logging.enabled) {\r\n                let matKeys = Object.keys(this.materials);\r\n                let matNames = matKeys.length > 0 ? '\\n\\tmaterialNames:\\n\\t\\t- ' + matKeys.join('\\n\\t\\t- ') : '\\n\\tmaterialNames: None';\r\n                let printedConfig = 'OBJLoader.Parser configuration:' + matNames + '\\n\\tmaterialPerSmoothingGroup: ' + this.materialPerSmoothingGroup + '\\n\\tuseOAsMesh: ' + this.useOAsMesh + '\\n\\tuseIndices: ' + this.useIndices + '\\n\\tdisregardNormals: ' + this.disregardNormals;\r\n                printedConfig += '\\n\\tcallbacks.onProgress: ' + this.callbacks.onProgress.name;\r\n                printedConfig += '\\n\\tcallbacks.onAssetAvailable: ' + this.callbacks.onAssetAvailable.name;\r\n                printedConfig += '\\n\\tcallbacks.onError: ' + this.callbacks.onError.name;\r\n                console.info(printedConfig);\r\n            }\r\n        },\r\n        execute: function (arrayBuffer) {\r\n            if (this.logging.enabled)\r\n                console.time('OBJLoader2Parser.execute');\r\n            this._configure();\r\n            let arrayBufferView = new Uint8Array(arrayBuffer);\r\n            this.contentRef = arrayBufferView;\r\n            let length = arrayBufferView.byteLength;\r\n            this.globalCounts.totalBytes = length;\r\n            let buffer = new Array(128);\r\n            for (let code, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i++) {\r\n                code = arrayBufferView[i];\r\n                switch (code) {\r\n                case 32:\r\n                    if (word.length > 0)\r\n                        buffer[bufferPointer++] = word;\r\n                    word = '';\r\n                    break;\r\n                case 47:\r\n                    if (word.length > 0)\r\n                        buffer[bufferPointer++] = word;\r\n                    slashesCount++;\r\n                    word = '';\r\n                    break;\r\n                case 10:\r\n                    if (word.length > 0)\r\n                        buffer[bufferPointer++] = word;\r\n                    word = '';\r\n                    this.globalCounts.lineByte = this.globalCounts.currentByte;\r\n                    this.globalCounts.currentByte = i;\r\n                    this._processLine(buffer, bufferPointer, slashesCount);\r\n                    bufferPointer = 0;\r\n                    slashesCount = 0;\r\n                    break;\r\n                case 13:\r\n                    break;\r\n                default:\r\n                    word += String.fromCharCode(code);\r\n                    break;\r\n                }\r\n            }\r\n            this._finalizeParsing();\r\n            if (this.logging.enabled)\r\n                console.timeEnd('OBJLoader2Parser.execute');\r\n        },\r\n        executeLegacy: function (text) {\r\n            if (this.logging.enabled)\r\n                console.time('OBJLoader2Parser.executeLegacy');\r\n            this._configure();\r\n            this.legacyMode = true;\r\n            this.contentRef = text;\r\n            let length = text.length;\r\n            this.globalCounts.totalBytes = length;\r\n            let buffer = new Array(128);\r\n            for (let char, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i++) {\r\n                char = text[i];\r\n                switch (char) {\r\n                case ' ':\r\n                    if (word.length > 0)\r\n                        buffer[bufferPointer++] = word;\r\n                    word = '';\r\n                    break;\r\n                case '/':\r\n                    if (word.length > 0)\r\n                        buffer[bufferPointer++] = word;\r\n                    slashesCount++;\r\n                    word = '';\r\n                    break;\r\n                case '\\n':\r\n                    if (word.length > 0)\r\n                        buffer[bufferPointer++] = word;\r\n                    word = '';\r\n                    this.globalCounts.lineByte = this.globalCounts.currentByte;\r\n                    this.globalCounts.currentByte = i;\r\n                    this._processLine(buffer, bufferPointer, slashesCount);\r\n                    bufferPointer = 0;\r\n                    slashesCount = 0;\r\n                    break;\r\n                case '\\r':\r\n                    break;\r\n                default:\r\n                    word += char;\r\n                }\r\n            }\r\n            this._finalizeParsing();\r\n            if (this.logging.enabled)\r\n                console.timeEnd('OBJLoader2Parser.executeLegacy');\r\n        },\r\n        _processLine: function (buffer, bufferPointer, slashesCount) {\r\n            if (bufferPointer < 1)\r\n                return;\r\n            let reconstructString = function (content, legacyMode, start, stop) {\r\n                let line = '';\r\n                if (stop > start) {\r\n                    let i;\r\n                    if (legacyMode) {\r\n                        for (i = start; i < stop; i++)\r\n                            line += content[i];\r\n                    } else {\r\n                        for (i = start; i < stop; i++)\r\n                            line += String.fromCharCode(content[i]);\r\n                    }\r\n                    line = line.trim();\r\n                }\r\n                return line;\r\n            };\r\n            let bufferLength, length, i, lineDesignation;\r\n            lineDesignation = buffer[0];\r\n            switch (lineDesignation) {\r\n            case 'v':\r\n                this.vertices.push(parseFloat(buffer[1]));\r\n                this.vertices.push(parseFloat(buffer[2]));\r\n                this.vertices.push(parseFloat(buffer[3]));\r\n                if (bufferPointer > 4) {\r\n                    this.colors.push(parseFloat(buffer[4]));\r\n                    this.colors.push(parseFloat(buffer[5]));\r\n                    this.colors.push(parseFloat(buffer[6]));\r\n                }\r\n                break;\r\n            case 'vt':\r\n                this.uvs.push(parseFloat(buffer[1]));\r\n                this.uvs.push(parseFloat(buffer[2]));\r\n                break;\r\n            case 'vn':\r\n                this.normals.push(parseFloat(buffer[1]));\r\n                this.normals.push(parseFloat(buffer[2]));\r\n                this.normals.push(parseFloat(buffer[3]));\r\n                break;\r\n            case 'f':\r\n                bufferLength = bufferPointer - 1;\r\n                if (slashesCount === 0) {\r\n                    this._checkFaceType(0);\r\n                    for (i = 2, length = bufferLength; i < length; i++) {\r\n                        this._buildFace(buffer[1]);\r\n                        this._buildFace(buffer[i]);\r\n                        this._buildFace(buffer[i + 1]);\r\n                    }\r\n                } else if (bufferLength === slashesCount * 2) {\r\n                    this._checkFaceType(1);\r\n                    for (i = 3, length = bufferLength - 2; i < length; i += 2) {\r\n                        this._buildFace(buffer[1], buffer[2]);\r\n                        this._buildFace(buffer[i], buffer[i + 1]);\r\n                        this._buildFace(buffer[i + 2], buffer[i + 3]);\r\n                    }\r\n                } else if (bufferLength * 2 === slashesCount * 3) {\r\n                    this._checkFaceType(2);\r\n                    for (i = 4, length = bufferLength - 3; i < length; i += 3) {\r\n                        this._buildFace(buffer[1], buffer[2], buffer[3]);\r\n                        this._buildFace(buffer[i], buffer[i + 1], buffer[i + 2]);\r\n                        this._buildFace(buffer[i + 3], buffer[i + 4], buffer[i + 5]);\r\n                    }\r\n                } else {\r\n                    this._checkFaceType(3);\r\n                    for (i = 3, length = bufferLength - 2; i < length; i += 2) {\r\n                        this._buildFace(buffer[1], undefined, buffer[2]);\r\n                        this._buildFace(buffer[i], undefined, buffer[i + 1]);\r\n                        this._buildFace(buffer[i + 2], undefined, buffer[i + 3]);\r\n                    }\r\n                }\r\n                break;\r\n            case 'l':\r\n            case 'p':\r\n                bufferLength = bufferPointer - 1;\r\n                if (bufferLength === slashesCount * 2) {\r\n                    this._checkFaceType(4);\r\n                    for (i = 1, length = bufferLength + 1; i < length; i += 2)\r\n                        this._buildFace(buffer[i], buffer[i + 1]);\r\n                } else {\r\n                    this._checkFaceType(lineDesignation === 'l' ? 5 : 6);\r\n                    for (i = 1, length = bufferLength + 1; i < length; i++)\r\n                        this._buildFace(buffer[i]);\r\n                }\r\n                break;\r\n            case 's':\r\n                this._pushSmoothingGroup(buffer[1]);\r\n                break;\r\n            case 'g':\r\n                this._processCompletedMesh();\r\n                this.rawMesh.groupName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);\r\n                break;\r\n            case 'o':\r\n                if (this.useOAsMesh)\r\n                    this._processCompletedMesh();\r\n                this.rawMesh.objectName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);\r\n                break;\r\n            case 'mtllib':\r\n                this.rawMesh.mtllibName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);\r\n                break;\r\n            case 'usemtl':\r\n                let mtlName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);\r\n                if (mtlName !== '' && this.rawMesh.activeMtlName !== mtlName) {\r\n                    this.rawMesh.activeMtlName = mtlName;\r\n                    this.rawMesh.counts.mtlCount++;\r\n                    this._checkSubGroup();\r\n                }\r\n                break;\r\n            default:\r\n                break;\r\n            }\r\n        },\r\n        _pushSmoothingGroup: function (smoothingGroup) {\r\n            let smoothingGroupInt = parseInt(smoothingGroup);\r\n            if (isNaN(smoothingGroupInt)) {\r\n                smoothingGroupInt = smoothingGroup === 'off' ? 0 : 1;\r\n            }\r\n            let smoothCheck = this.rawMesh.smoothingGroup.normalized;\r\n            this.rawMesh.smoothingGroup.normalized = this.rawMesh.smoothingGroup.splitMaterials ? smoothingGroupInt : smoothingGroupInt === 0 ? 0 : 1;\r\n            this.rawMesh.smoothingGroup.real = smoothingGroupInt;\r\n            if (smoothCheck !== smoothingGroupInt) {\r\n                this.rawMesh.counts.smoothingGroupCount++;\r\n                this._checkSubGroup();\r\n            }\r\n        },\r\n        _checkFaceType: function (faceType) {\r\n            if (this.rawMesh.faceType !== faceType) {\r\n                this._processCompletedMesh();\r\n                this.rawMesh.faceType = faceType;\r\n                this._checkSubGroup();\r\n            }\r\n        },\r\n        _checkSubGroup: function () {\r\n            let index = this.rawMesh.activeMtlName + '|' + this.rawMesh.smoothingGroup.normalized;\r\n            this.rawMesh.subGroupInUse = this.rawMesh.subGroups[index];\r\n            if (this.rawMesh.subGroupInUse === undefined || this.rawMesh.subGroupInUse === null) {\r\n                this.rawMesh.subGroupInUse = {\r\n                    index: index,\r\n                    objectName: this.rawMesh.objectName,\r\n                    groupName: this.rawMesh.groupName,\r\n                    materialName: this.rawMesh.activeMtlName,\r\n                    smoothingGroup: this.rawMesh.smoothingGroup.normalized,\r\n                    vertices: [],\r\n                    indexMappingsCount: 0,\r\n                    indexMappings: [],\r\n                    indices: [],\r\n                    colors: [],\r\n                    uvs: [],\r\n                    normals: []\r\n                };\r\n                this.rawMesh.subGroups[index] = this.rawMesh.subGroupInUse;\r\n            }\r\n        },\r\n        _buildFace: function (faceIndexV, faceIndexU, faceIndexN) {\r\n            let subGroupInUse = this.rawMesh.subGroupInUse;\r\n            let scope = this;\r\n            let updateSubGroupInUse = function () {\r\n                let faceIndexVi = parseInt(faceIndexV);\r\n                let indexPointerV = 3 * (faceIndexVi > 0 ? faceIndexVi - 1 : faceIndexVi + scope.vertices.length / 3);\r\n                let indexPointerC = scope.colors.length > 0 ? indexPointerV : null;\r\n                let vertices = subGroupInUse.vertices;\r\n                vertices.push(scope.vertices[indexPointerV++]);\r\n                vertices.push(scope.vertices[indexPointerV++]);\r\n                vertices.push(scope.vertices[indexPointerV]);\r\n                if (indexPointerC !== null) {\r\n                    let colors = subGroupInUse.colors;\r\n                    colors.push(scope.colors[indexPointerC++]);\r\n                    colors.push(scope.colors[indexPointerC++]);\r\n                    colors.push(scope.colors[indexPointerC]);\r\n                }\r\n                if (faceIndexU) {\r\n                    let faceIndexUi = parseInt(faceIndexU);\r\n                    let indexPointerU = 2 * (faceIndexUi > 0 ? faceIndexUi - 1 : faceIndexUi + scope.uvs.length / 2);\r\n                    let uvs = subGroupInUse.uvs;\r\n                    uvs.push(scope.uvs[indexPointerU++]);\r\n                    uvs.push(scope.uvs[indexPointerU]);\r\n                }\r\n                if (faceIndexN && !scope.disregardNormals) {\r\n                    let faceIndexNi = parseInt(faceIndexN);\r\n                    let indexPointerN = 3 * (faceIndexNi > 0 ? faceIndexNi - 1 : faceIndexNi + scope.normals.length / 3);\r\n                    let normals = subGroupInUse.normals;\r\n                    normals.push(scope.normals[indexPointerN++]);\r\n                    normals.push(scope.normals[indexPointerN++]);\r\n                    normals.push(scope.normals[indexPointerN]);\r\n                }\r\n            };\r\n            if (this.useIndices) {\r\n                if (this.disregardNormals)\r\n                    faceIndexN = undefined;\r\n                let mappingName = faceIndexV + (faceIndexU ? '_' + faceIndexU : '_n') + (faceIndexN ? '_' + faceIndexN : '_n');\r\n                let indicesPointer = subGroupInUse.indexMappings[mappingName];\r\n                if (indicesPointer === undefined || indicesPointer === null) {\r\n                    indicesPointer = this.rawMesh.subGroupInUse.vertices.length / 3;\r\n                    updateSubGroupInUse();\r\n                    subGroupInUse.indexMappings[mappingName] = indicesPointer;\r\n                    subGroupInUse.indexMappingsCount++;\r\n                } else {\r\n                    this.rawMesh.counts.doubleIndicesCount++;\r\n                }\r\n                subGroupInUse.indices.push(indicesPointer);\r\n            } else {\r\n                updateSubGroupInUse();\r\n            }\r\n            this.rawMesh.counts.faceCount++;\r\n        },\r\n        _createRawMeshReport: function (inputObjectCount) {\r\n            return 'Input Object number: ' + inputObjectCount + '\\n\\tObject name: ' + this.rawMesh.objectName + '\\n\\tGroup name: ' + this.rawMesh.groupName + '\\n\\tMtllib name: ' + this.rawMesh.mtllibName + '\\n\\tVertex count: ' + this.vertices.length / 3 + '\\n\\tNormal count: ' + this.normals.length / 3 + '\\n\\tUV count: ' + this.uvs.length / 2 + '\\n\\tSmoothingGroup count: ' + this.rawMesh.counts.smoothingGroupCount + '\\n\\tMaterial count: ' + this.rawMesh.counts.mtlCount + '\\n\\tReal MeshOutputGroup count: ' + this.rawMesh.subGroups.length;\r\n        },\r\n        _finalizeRawMesh: function () {\r\n            let meshOutputGroupTemp = [];\r\n            let meshOutputGroup;\r\n            let absoluteVertexCount = 0;\r\n            let absoluteIndexMappingsCount = 0;\r\n            let absoluteIndexCount = 0;\r\n            let absoluteColorCount = 0;\r\n            let absoluteNormalCount = 0;\r\n            let absoluteUvCount = 0;\r\n            let indices;\r\n            for (let name in this.rawMesh.subGroups) {\r\n                meshOutputGroup = this.rawMesh.subGroups[name];\r\n                if (meshOutputGroup.vertices.length > 0) {\r\n                    indices = meshOutputGroup.indices;\r\n                    if (indices.length > 0 && absoluteIndexMappingsCount > 0) {\r\n                        for (let i = 0; i < indices.length; i++) {\r\n                            indices[i] = indices[i] + absoluteIndexMappingsCount;\r\n                        }\r\n                    }\r\n                    meshOutputGroupTemp.push(meshOutputGroup);\r\n                    absoluteVertexCount += meshOutputGroup.vertices.length;\r\n                    absoluteIndexMappingsCount += meshOutputGroup.indexMappingsCount;\r\n                    absoluteIndexCount += meshOutputGroup.indices.length;\r\n                    absoluteColorCount += meshOutputGroup.colors.length;\r\n                    absoluteUvCount += meshOutputGroup.uvs.length;\r\n                    absoluteNormalCount += meshOutputGroup.normals.length;\r\n                }\r\n            }\r\n            let result = null;\r\n            if (meshOutputGroupTemp.length > 0) {\r\n                result = {\r\n                    name: this.rawMesh.groupName !== '' ? this.rawMesh.groupName : this.rawMesh.objectName,\r\n                    subGroups: meshOutputGroupTemp,\r\n                    absoluteVertexCount: absoluteVertexCount,\r\n                    absoluteIndexCount: absoluteIndexCount,\r\n                    absoluteColorCount: absoluteColorCount,\r\n                    absoluteNormalCount: absoluteNormalCount,\r\n                    absoluteUvCount: absoluteUvCount,\r\n                    faceCount: this.rawMesh.counts.faceCount,\r\n                    doubleIndicesCount: this.rawMesh.counts.doubleIndicesCount\r\n                };\r\n            }\r\n            return result;\r\n        },\r\n        _processCompletedMesh: function () {\r\n            let result = this._finalizeRawMesh();\r\n            let haveMesh = result !== null;\r\n            if (haveMesh) {\r\n                if (this.colors.length > 0 && this.colors.length !== this.vertices.length) {\r\n                    this.callbacks.onError('Vertex Colors were detected, but vertex count and color count do not match!');\r\n                }\r\n                if (this.logging.enabled && this.logging.debug)\r\n                    console.debug(this._createRawMeshReport(this.inputObjectCount));\r\n                this.inputObjectCount++;\r\n                this._buildMesh(result);\r\n                let progressBytesPercent = this.globalCounts.currentByte / this.globalCounts.totalBytes;\r\n                this._onProgress('Completed [o: ' + this.rawMesh.objectName + ' g:' + this.rawMesh.groupName + '' + '] Total progress: ' + (progressBytesPercent * 100).toFixed(2) + '%');\r\n                this._resetRawMesh();\r\n            }\r\n            return haveMesh;\r\n        },\r\n        _buildMesh: function (result) {\r\n            let meshOutputGroups = result.subGroups;\r\n            let vertexFA = new Float32Array(result.absoluteVertexCount);\r\n            this.globalCounts.vertices += result.absoluteVertexCount / 3;\r\n            this.globalCounts.faces += result.faceCount;\r\n            this.globalCounts.doubleIndicesCount += result.doubleIndicesCount;\r\n            let indexUA = result.absoluteIndexCount > 0 ? new Uint32Array(result.absoluteIndexCount) : null;\r\n            let colorFA = result.absoluteColorCount > 0 ? new Float32Array(result.absoluteColorCount) : null;\r\n            let normalFA = result.absoluteNormalCount > 0 ? new Float32Array(result.absoluteNormalCount) : null;\r\n            let uvFA = result.absoluteUvCount > 0 ? new Float32Array(result.absoluteUvCount) : null;\r\n            let haveVertexColors = colorFA !== null;\r\n            let meshOutputGroup;\r\n            let materialNames = [];\r\n            let createMultiMaterial = meshOutputGroups.length > 1;\r\n            let materialIndex = 0;\r\n            let materialIndexMapping = [];\r\n            let selectedMaterialIndex;\r\n            let materialGroup;\r\n            let materialGroups = [];\r\n            let vertexFAOffset = 0;\r\n            let indexUAOffset = 0;\r\n            let colorFAOffset = 0;\r\n            let normalFAOffset = 0;\r\n            let uvFAOffset = 0;\r\n            let materialGroupOffset = 0;\r\n            let materialGroupLength = 0;\r\n            let materialOrg, material, materialName, materialNameOrg;\r\n            for (let oodIndex in meshOutputGroups) {\r\n                if (!meshOutputGroups.hasOwnProperty(oodIndex))\r\n                    continue;\r\n                meshOutputGroup = meshOutputGroups[oodIndex];\r\n                materialNameOrg = meshOutputGroup.materialName;\r\n                if (this.rawMesh.faceType < 4) {\r\n                    materialName = materialNameOrg + (haveVertexColors ? '_vertexColor' : '') + (meshOutputGroup.smoothingGroup === 0 ? '_flat' : '');\r\n                } else {\r\n                    materialName = this.rawMesh.faceType === 6 ? 'defaultPointMaterial' : 'defaultLineMaterial';\r\n                }\r\n                materialOrg = this.materials[materialNameOrg];\r\n                material = this.materials[materialName];\r\n                if ((materialOrg === undefined || materialOrg === null) && (material === undefined || material === null)) {\r\n                    materialName = haveVertexColors ? 'defaultVertexColorMaterial' : 'defaultMaterial';\r\n                    material = this.materials[materialName];\r\n                    if (this.logging.enabled) {\r\n                        console.info('object_group \"' + meshOutputGroup.objectName + '_' + meshOutputGroup.groupName + '\" was defined with unresolvable material \"' + materialNameOrg + '\"! Assigning \"' + materialName + '\".');\r\n                    }\r\n                }\r\n                if (material === undefined || material === null) {\r\n                    let materialCloneInstructions = {\r\n                        materialNameOrg: materialNameOrg,\r\n                        materialName: materialName,\r\n                        materialProperties: {\r\n                            vertexColors: haveVertexColors ? 2 : 0,\r\n                            flatShading: meshOutputGroup.smoothingGroup === 0\r\n                        }\r\n                    };\r\n                    let payload = {\r\n                        cmd: 'assetAvailable',\r\n                        type: 'material',\r\n                        materials: { materialCloneInstructions: materialCloneInstructions }\r\n                    };\r\n                    this.callbacks.onAssetAvailable(payload);\r\n                    let matCheck = this.materials[materialName];\r\n                    if (matCheck === undefined || matCheck === null) {\r\n                        this.materials[materialName] = materialCloneInstructions;\r\n                    }\r\n                }\r\n                if (createMultiMaterial) {\r\n                    selectedMaterialIndex = materialIndexMapping[materialName];\r\n                    if (!selectedMaterialIndex) {\r\n                        selectedMaterialIndex = materialIndex;\r\n                        materialIndexMapping[materialName] = materialIndex;\r\n                        materialNames.push(materialName);\r\n                        materialIndex++;\r\n                    }\r\n                    materialGroupLength = this.useIndices ? meshOutputGroup.indices.length : meshOutputGroup.vertices.length / 3;\r\n                    materialGroup = {\r\n                        start: materialGroupOffset,\r\n                        count: materialGroupLength,\r\n                        index: selectedMaterialIndex\r\n                    };\r\n                    materialGroups.push(materialGroup);\r\n                    materialGroupOffset += materialGroupLength;\r\n                } else {\r\n                    materialNames.push(materialName);\r\n                }\r\n                vertexFA.set(meshOutputGroup.vertices, vertexFAOffset);\r\n                vertexFAOffset += meshOutputGroup.vertices.length;\r\n                if (indexUA) {\r\n                    indexUA.set(meshOutputGroup.indices, indexUAOffset);\r\n                    indexUAOffset += meshOutputGroup.indices.length;\r\n                }\r\n                if (colorFA) {\r\n                    colorFA.set(meshOutputGroup.colors, colorFAOffset);\r\n                    colorFAOffset += meshOutputGroup.colors.length;\r\n                }\r\n                if (normalFA) {\r\n                    normalFA.set(meshOutputGroup.normals, normalFAOffset);\r\n                    normalFAOffset += meshOutputGroup.normals.length;\r\n                }\r\n                if (uvFA) {\r\n                    uvFA.set(meshOutputGroup.uvs, uvFAOffset);\r\n                    uvFAOffset += meshOutputGroup.uvs.length;\r\n                }\r\n                if (this.logging.enabled && this.logging.debug) {\r\n                    let materialIndexLine = selectedMaterialIndex === undefined || selectedMaterialIndex === null ? '' : '\\n\\t\\tmaterialIndex: ' + selectedMaterialIndex;\r\n                    let createdReport = '\\tOutput Object no.: ' + this.outputObjectCount + '\\n\\t\\tgroupName: ' + meshOutputGroup.groupName + '\\n\\t\\tIndex: ' + meshOutputGroup.index + '\\n\\t\\tfaceType: ' + this.rawMesh.faceType + '\\n\\t\\tmaterialName: ' + meshOutputGroup.materialName + '\\n\\t\\tsmoothingGroup: ' + meshOutputGroup.smoothingGroup + materialIndexLine + '\\n\\t\\tobjectName: ' + meshOutputGroup.objectName + '\\n\\t\\t#vertices: ' + meshOutputGroup.vertices.length / 3 + '\\n\\t\\t#indices: ' + meshOutputGroup.indices.length + '\\n\\t\\t#colors: ' + meshOutputGroup.colors.length / 3 + '\\n\\t\\t#uvs: ' + meshOutputGroup.uvs.length / 2 + '\\n\\t\\t#normals: ' + meshOutputGroup.normals.length / 3;\r\n                    console.debug(createdReport);\r\n                }\r\n            }\r\n            this.outputObjectCount++;\r\n            this.callbacks.onAssetAvailable({\r\n                cmd: 'assetAvailable',\r\n                type: 'mesh',\r\n                progress: { numericalValue: this.globalCounts.currentByte / this.globalCounts.totalBytes },\r\n                params: { meshName: result.name },\r\n                materials: {\r\n                    multiMaterial: createMultiMaterial,\r\n                    materialNames: materialNames,\r\n                    materialGroups: materialGroups\r\n                },\r\n                buffers: {\r\n                    vertices: vertexFA,\r\n                    indices: indexUA,\r\n                    colors: colorFA,\r\n                    normals: normalFA,\r\n                    uvs: uvFA\r\n                },\r\n                geometryType: this.rawMesh.faceType < 4 ? 0 : this.rawMesh.faceType === 6 ? 2 : 1\r\n            }, [vertexFA.buffer], indexUA !== null ? [indexUA.buffer] : null, colorFA !== null ? [colorFA.buffer] : null, normalFA !== null ? [normalFA.buffer] : null, uvFA !== null ? [uvFA.buffer] : null);\r\n        },\r\n        _finalizeParsing: function () {\r\n            if (this.logging.enabled)\r\n                console.info('Global output object count: ' + this.outputObjectCount);\r\n            if (this._processCompletedMesh() && this.logging.enabled) {\r\n                let parserFinalReport = 'Overall counts: ' + '\\n\\tVertices: ' + this.globalCounts.vertices + '\\n\\tFaces: ' + this.globalCounts.faces + '\\n\\tMultiple definitions: ' + this.globalCounts.doubleIndicesCount;\r\n                console.info(parserFinalReport);\r\n            }\r\n        }\r\n    };\r\n\r\n    return OBJLoader2Parser;\r\n});"]}