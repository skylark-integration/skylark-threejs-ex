{"version":3,"sources":["loaders/DDSLoader.js"],"names":["define","THREE","DDSLoader","manager","CompressedTextureLoader","call","this","prototype","Object","assign","create","constructor","parse","buffer","loadMipmaps","dds","mipmaps","width","height","format","mipmapCount","fourCCToInt32","value","charCodeAt","loadARGBMip","dataOffset","dataLength","srcBuffer","Uint8Array","byteArray","dst","src","y","x","b","g","r","a","blockBytes","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","FOURCC_ETC1","header","Int32Array","console","error","fourCC","isRGBAUncompressed","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_ETC1_Format","String","fromCharCode","RGBAFormat","Math","max","caps2","isCubemap","faces","face","i","length","mipmap","data","push"],"mappings":"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","file":"../../loaders/DDSLoader.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tTHREE.DDSLoader = function ( manager ) {\n\n\t\tTHREE.CompressedTextureLoader.call( this, manager );\n\n\t};\n\n\tTHREE.DDSLoader.prototype = Object.assign( Object.create( THREE.CompressedTextureLoader.prototype ), {\n\n\t\tconstructor: THREE.DDSLoader,\n\n\t\tparse: function ( buffer, loadMipmaps ) {\n\n\t\t\tvar dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n\n\t\t\t// Adapted from @toji's DDS utils\n\t\t\t// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n\t\t\t// All values and structures referenced from:\n\t\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n\t\t\tvar DDS_MAGIC = 0x20534444;\n\n\t\t\tvar DDSD_CAPS = 0x1,\n\t\t\t\tDDSD_HEIGHT = 0x2,\n\t\t\t\tDDSD_WIDTH = 0x4,\n\t\t\t\tDDSD_PITCH = 0x8,\n\t\t\t\tDDSD_PIXELFORMAT = 0x1000,\n\t\t\t\tDDSD_MIPMAPCOUNT = 0x20000,\n\t\t\t\tDDSD_LINEARSIZE = 0x80000,\n\t\t\t\tDDSD_DEPTH = 0x800000;\n\n\t\t\tvar DDSCAPS_COMPLEX = 0x8,\n\t\t\t\tDDSCAPS_MIPMAP = 0x400000,\n\t\t\t\tDDSCAPS_TEXTURE = 0x1000;\n\n\t\t\tvar DDSCAPS2_CUBEMAP = 0x200,\n\t\t\t\tDDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n\t\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n\t\t\t\tDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n\t\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n\t\t\t\tDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n\t\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n\t\t\t\tDDSCAPS2_VOLUME = 0x200000;\n\n\t\t\tvar DDPF_ALPHAPIXELS = 0x1,\n\t\t\t\tDDPF_ALPHA = 0x2,\n\t\t\t\tDDPF_FOURCC = 0x4,\n\t\t\t\tDDPF_RGB = 0x40,\n\t\t\t\tDDPF_YUV = 0x200,\n\t\t\t\tDDPF_LUMINANCE = 0x20000;\n\n\t\t\tfunction fourCCToInt32( value ) {\n\n\t\t\t\treturn value.charCodeAt( 0 ) +\n\t\t\t\t\t( value.charCodeAt( 1 ) << 8 ) +\n\t\t\t\t\t( value.charCodeAt( 2 ) << 16 ) +\n\t\t\t\t\t( value.charCodeAt( 3 ) << 24 );\n\n\t\t\t}\n\n\t\t\tfunction int32ToFourCC( value ) {\n\n\t\t\t\treturn String.fromCharCode(\n\t\t\t\t\tvalue & 0xff,\n\t\t\t\t\t( value >> 8 ) & 0xff,\n\t\t\t\t\t( value >> 16 ) & 0xff,\n\t\t\t\t\t( value >> 24 ) & 0xff\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tfunction loadARGBMip( buffer, dataOffset, width, height ) {\n\n\t\t\t\tvar dataLength = width * height * 4;\n\t\t\t\tvar srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\n\t\t\t\tvar byteArray = new Uint8Array( dataLength );\n\t\t\t\tvar dst = 0;\n\t\t\t\tvar src = 0;\n\t\t\t\tfor ( var y = 0; y < height; y ++ ) {\n\n\t\t\t\t\tfor ( var x = 0; x < width; x ++ ) {\n\n\t\t\t\t\t\tvar b = srcBuffer[ src ]; src ++;\n\t\t\t\t\t\tvar g = srcBuffer[ src ]; src ++;\n\t\t\t\t\t\tvar r = srcBuffer[ src ]; src ++;\n\t\t\t\t\t\tvar a = srcBuffer[ src ]; src ++;\n\t\t\t\t\t\tbyteArray[ dst ] = r; dst ++;\t//r\n\t\t\t\t\t\tbyteArray[ dst ] = g; dst ++;\t//g\n\t\t\t\t\t\tbyteArray[ dst ] = b; dst ++;\t//b\n\t\t\t\t\t\tbyteArray[ dst ] = a; dst ++;\t//a\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn byteArray;\n\n\t\t\t}\n\n\t\t\tvar FOURCC_DXT1 = fourCCToInt32( \"DXT1\" );\n\t\t\tvar FOURCC_DXT3 = fourCCToInt32( \"DXT3\" );\n\t\t\tvar FOURCC_DXT5 = fourCCToInt32( \"DXT5\" );\n\t\t\tvar FOURCC_ETC1 = fourCCToInt32( \"ETC1\" );\n\n\t\t\tvar headerLengthInt = 31; // The header length in 32 bit ints\n\n\t\t\t// Offsets into the header array\n\n\t\t\tvar off_magic = 0;\n\n\t\t\tvar off_size = 1;\n\t\t\tvar off_flags = 2;\n\t\t\tvar off_height = 3;\n\t\t\tvar off_width = 4;\n\n\t\t\tvar off_mipmapCount = 7;\n\n\t\t\tvar off_pfFlags = 20;\n\t\t\tvar off_pfFourCC = 21;\n\t\t\tvar off_RGBBitCount = 22;\n\t\t\tvar off_RBitMask = 23;\n\t\t\tvar off_GBitMask = 24;\n\t\t\tvar off_BBitMask = 25;\n\t\t\tvar off_ABitMask = 26;\n\n\t\t\tvar off_caps = 27;\n\t\t\tvar off_caps2 = 28;\n\t\t\tvar off_caps3 = 29;\n\t\t\tvar off_caps4 = 30;\n\n\t\t\t// Parse header\n\n\t\t\tvar header = new Int32Array( buffer, 0, headerLengthInt );\n\n\t\t\tif ( header[ off_magic ] !== DDS_MAGIC ) {\n\n\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' );\n\t\t\t\treturn dds;\n\n\t\t\t}\n\n\t\t\tif ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {\n\n\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.' );\n\t\t\t\treturn dds;\n\n\t\t\t}\n\n\t\t\tvar blockBytes;\n\n\t\t\tvar fourCC = header[ off_pfFourCC ];\n\n\t\t\tvar isRGBAUncompressed = false;\n\n\t\t\tswitch ( fourCC ) {\n\n\t\t\t\tcase FOURCC_DXT1:\n\n\t\t\t\t\tblockBytes = 8;\n\t\t\t\t\tdds.format = THREE.RGB_S3TC_DXT1_Format;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FOURCC_DXT3:\n\n\t\t\t\t\tblockBytes = 16;\n\t\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT3_Format;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FOURCC_DXT5:\n\n\t\t\t\t\tblockBytes = 16;\n\t\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT5_Format;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FOURCC_ETC1:\n\n\t\t\t\t\tblockBytes = 8;\n\t\t\t\t\tdds.format = THREE.RGB_ETC1_Format;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( header[ off_RGBBitCount ] === 32\n\t\t\t\t\t\t&& header[ off_RBitMask ] & 0xff0000\n\t\t\t\t\t\t&& header[ off_GBitMask ] & 0xff00\n\t\t\t\t\t\t&& header[ off_BBitMask ] & 0xff\n\t\t\t\t\t\t&& header[ off_ABitMask ] & 0xff000000 ) {\n\n\t\t\t\t\t\tisRGBAUncompressed = true;\n\t\t\t\t\t\tblockBytes = 64;\n\t\t\t\t\t\tdds.format = THREE.RGBAFormat;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );\n\t\t\t\t\t\treturn dds;\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdds.mipmapCount = 1;\n\n\t\t\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\n\n\t\t\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\n\n\t\t\t}\n\n\t\t\tvar caps2 = header[ off_caps2 ];\n\t\t\tdds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n\t\t\tif ( dds.isCubemap && (\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ||\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ||\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ||\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ||\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ||\n\t\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ )\n\t\t\t) ) {\n\n\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Incomplete cubemap faces' );\n\t\t\t\treturn dds;\n\n\t\t\t}\n\n\t\t\tdds.width = header[ off_width ];\n\t\t\tdds.height = header[ off_height ];\n\n\t\t\tvar dataOffset = header[ off_size ] + 4;\n\n\t\t\t// Extract mipmaps buffers\n\n\t\t\tvar faces = dds.isCubemap ? 6 : 1;\n\n\t\t\tfor ( var face = 0; face < faces; face ++ ) {\n\n\t\t\t\tvar width = dds.width;\n\t\t\t\tvar height = dds.height;\n\n\t\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\t\tif ( isRGBAUncompressed ) {\n\n\t\t\t\t\t\tvar byteArray = loadARGBMip( buffer, dataOffset, width, height );\n\t\t\t\t\t\tvar dataLength = byteArray.length;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\n\t\t\t\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataLength );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar mipmap = { \"data\": byteArray, \"width\": width, \"height\": height };\n\t\t\t\t\tdds.mipmaps.push( mipmap );\n\n\t\t\t\t\tdataOffset += dataLength;\n\n\t\t\t\t\twidth = Math.max( width >> 1, 1 );\n\t\t\t\t\theight = Math.max( height >> 1, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dds;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.DDSLoader;\n});\n"]}