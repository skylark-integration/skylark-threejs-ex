{"version":3,"sources":["lights/LightProbeGenerator.js"],"names":["define","THREE","LightProbeGenerator","fromCubeTexture","cubeTexture","norm","lengthSq","weight","totalWeight","coord","Vector3","dir","color","Color","shBasis","sh","SphericalHarmonics3","shCoefficients","coefficients","faceIndex","image","width","height","canvas","document","createElement","context","getContext","drawImage","imageData","getImageData","data","imageWidth","pixelSize","i","il","length","setRGB","convertColorToLinear","encoding","pixelIndex","col","row","Math","floor","set","sqrt","copy","normalize","getBasisAt","j","x","r","y","g","z","b","PI","LightProbe","fromCubeRenderTarget","renderer","cubeRenderTarget","Uint8Array","readRenderTargetPixels","texture","sRGBEncoding","convertSRGBToLinear","LinearEncoding","console","warn"],"mappings":";;;;;;;AAAAA,QACC,mBACC,SAASC,GAKVA,EAAMC,qBAGLC,gBAAiB,SAAWC,GAe3B,IAbA,IAAIC,EAAMC,EAAUC,EAAQC,EAAc,EAEtCC,EAAQ,IAAIR,EAAMS,QAElBC,EAAM,IAAIV,EAAMS,QAEhBE,EAAQ,IAAIX,EAAMY,MAElBC,GAAY,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAEpCC,EAAK,IAAId,EAAMe,oBACfC,EAAiBF,EAAGG,aAEdC,EAAY,EAAGA,EAAY,EAAGA,IAAe,CAEtD,IAAIC,EAAQhB,EAAYgB,MAAOD,GAE3BE,EAAQD,EAAMC,MACdC,EAASF,EAAME,OAEfC,EAASC,SAASC,cAAe,UAErCF,EAAOF,MAAQA,EACfE,EAAOD,OAASA,EAEhB,IAAII,EAAUH,EAAOI,WAAY,MAEjCD,EAAQE,UAAWR,EAAO,EAAG,EAAGC,EAAOC,GAUvC,IARA,IAAIO,EAAYH,EAAQI,aAAc,EAAG,EAAGT,EAAOC,GAE/CS,EAAOF,EAAUE,KAEjBC,EAAaH,EAAUR,MAEvBY,EAAY,EAAID,EAEVE,EAAI,EAAGC,EAAKJ,EAAKK,OAAQF,EAAIC,EAAID,GAAK,EAAI,CAGnDtB,EAAMyB,OAAQN,EAAMG,GAAM,IAAKH,EAAMG,EAAI,GAAM,IAAKH,EAAMG,EAAI,GAAM,KAGpEI,EAAsB1B,EAAOR,EAAYmC,UAIzC,IAAIC,EAAaN,EAAI,EAEjBO,GAAcD,EAAaR,EAAa,IAAQC,EAAxC,EAERS,EAAM,GAAMC,KAAKC,MAAOJ,EAAaR,GAAe,IAAQC,EAEhE,OAASd,GAER,KAAK,EAAGV,EAAMoC,KAAO,EAAGH,GAAOD,GAAO,MAEtC,KAAK,EAAGhC,EAAMoC,IAAK,EAAGH,EAAKD,GAAO,MAElC,KAAK,EAAGhC,EAAMoC,KAAOJ,EAAK,GAAKC,GAAO,MAEtC,KAAK,EAAGjC,EAAMoC,KAAOJ,GAAO,EAAGC,GAAO,MAEtC,KAAK,EAAGjC,EAAMoC,KAAOJ,EAAKC,EAAK,GAAK,MAEpC,KAAK,EAAGjC,EAAMoC,IAAKJ,EAAKC,GAAO,GAMhCpC,EAAWG,EAAMH,WAIjBE,GAFAD,EAAS,GAAMoC,KAAKG,KAAMxC,GAAaA,GAKvCK,EAAIoC,KAAMtC,GAAQuC,YAGlB/C,EAAMe,oBAAoBiC,WAAYtC,EAAKG,GAG3C,IAAM,IAAIoC,EAAI,EAAGA,EAAI,EAAGA,IAEvBjC,EAAgBiC,GAAIC,GAAKrC,EAASoC,GAAMtC,EAAMwC,EAAI7C,EAClDU,EAAgBiC,GAAIG,GAAKvC,EAASoC,GAAMtC,EAAM0C,EAAI/C,EAClDU,EAAgBiC,GAAIK,GAAKzC,EAASoC,GAAMtC,EAAM4C,EAAIjD,GASrDF,EAAS,EAAIsC,KAAKc,GAAOjD,EAEzB,IAAU0C,EAAI,EAAGA,EAAI,EAAGA,IAEvBjC,EAAgBiC,GAAIC,GAAK9C,EACzBY,EAAgBiC,GAAIG,GAAKhD,EACzBY,EAAgBiC,GAAIK,GAAKlD,EAI1B,OAAO,IAAIJ,EAAMyD,WAAY3C,IAI9B4C,qBAAsB,SAAWC,EAAUC,GAgB1C,IAbA,IAAIxD,EAAMC,EAAUC,EAAQC,EAAc,EAEtCC,EAAQ,IAAIR,EAAMS,QAElBC,EAAM,IAAIV,EAAMS,QAEhBE,EAAQ,IAAIX,EAAMY,MAElBC,GAAY,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAEpCC,EAAK,IAAId,EAAMe,oBACfC,EAAiBF,EAAGG,aAEdC,EAAY,EAAGA,EAAY,EAAGA,IAAe,CAEtD,IAAIa,EAAa6B,EAAiBxC,MAC9BU,EAAO,IAAI+B,WAAY9B,EAAaA,EAAa,GACrD4B,EAASG,uBAAwBF,EAAkB,EAAG,EAAG7B,EAAYA,EAAYD,EAAMZ,GAIvF,IAFA,IAAIc,EAAY,EAAID,EAEVE,EAAI,EAAGC,EAAKJ,EAAKK,OAAQF,EAAIC,EAAID,GAAK,EAAI,CAGnDtB,EAAMyB,OAAQN,EAAMG,GAAM,IAAKH,EAAMG,EAAI,GAAM,IAAKH,EAAMG,EAAI,GAAM,KAGpEI,EAAsB1B,EAAOiD,EAAiBG,QAAQzB,UAItD,IAAIC,EAAaN,EAAI,EAEjBO,GAAcD,EAAaR,EAAa,IAAQC,EAAxC,EAERS,EAAM,GAAMC,KAAKC,MAAOJ,EAAaR,GAAe,IAAQC,EAEhE,OAASd,GAER,KAAK,EAAGV,EAAMoC,IAAK,EAAGH,GAAOD,GAAO,MAEpC,KAAK,EAAGhC,EAAMoC,KAAO,EAAGH,EAAKD,GAAO,MAEpC,KAAK,EAAGhC,EAAMoC,IAAKJ,EAAK,GAAKC,GAAO,MAEpC,KAAK,EAAGjC,EAAMoC,IAAKJ,GAAO,EAAGC,GAAO,MAEpC,KAAK,EAAGjC,EAAMoC,IAAKJ,EAAKC,EAAK,GAAK,MAElC,KAAK,EAAGjC,EAAMoC,KAAOJ,EAAKC,GAAO,GAMlCpC,EAAWG,EAAMH,WAIjBE,GAFAD,EAAS,GAAMoC,KAAKG,KAAMxC,GAAaA,GAKvCK,EAAIoC,KAAMtC,GAAQuC,YAGlB/C,EAAMe,oBAAoBiC,WAAYtC,EAAKG,GAG3C,IAAM,IAAIoC,EAAI,EAAGA,EAAI,EAAGA,IAEvBjC,EAAgBiC,GAAIC,GAAKrC,EAASoC,GAAMtC,EAAMwC,EAAI7C,EAClDU,EAAgBiC,GAAIG,GAAKvC,EAASoC,GAAMtC,EAAM0C,EAAI/C,EAClDU,EAAgBiC,GAAIK,GAAKzC,EAASoC,GAAMtC,EAAM4C,EAAIjD,GASrDF,EAAS,EAAIsC,KAAKc,GAAOjD,EAEzB,IAAU0C,EAAI,EAAGA,EAAI,EAAGA,IAEvBjC,EAAgBiC,GAAIC,GAAK9C,EACzBY,EAAgBiC,GAAIG,GAAKhD,EACzBY,EAAgBiC,GAAIK,GAAKlD,EAI1B,OAAO,IAAIJ,EAAMyD,WAAY3C,KAM/B,IAAIuB,EAAuB,SAAW1B,EAAO2B,GAE5C,OAASA,GAER,KAAKtC,EAAMgE,aAEVrD,EAAMsD,sBACN,MAED,KAAKjE,EAAMkE,eAEV,MAED,QAECC,QAAQC,KAAM,4FAKhB,OAAOzD,GAIR,OAAOX,EAAMC","file":"../../lights/LightProbeGenerator.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\n\tTHREE.LightProbeGenerator = {\n\n\t\t// https://www.ppsloan.org/publications/StupidSH36.pdf\n\t\tfromCubeTexture: function ( cubeTexture ) {\n\n\t\t\tvar norm, lengthSq, weight, totalWeight = 0;\n\n\t\t\tvar coord = new THREE.Vector3();\n\n\t\t\tvar dir = new THREE.Vector3();\n\n\t\t\tvar color = new THREE.Color();\n\n\t\t\tvar shBasis = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\n\n\t\t\tvar sh = new THREE.SphericalHarmonics3();\n\t\t\tvar shCoefficients = sh.coefficients;\n\n\t\t\tfor ( var faceIndex = 0; faceIndex < 6; faceIndex ++ ) {\n\n\t\t\t\tvar image = cubeTexture.image[ faceIndex ];\n\n\t\t\t\tvar width = image.width;\n\t\t\t\tvar height = image.height;\n\n\t\t\t\tvar canvas = document.createElement( 'canvas' );\n\n\t\t\t\tcanvas.width = width;\n\t\t\t\tcanvas.height = height;\n\n\t\t\t\tvar context = canvas.getContext( '2d' );\n\n\t\t\t\tcontext.drawImage( image, 0, 0, width, height );\n\n\t\t\t\tvar imageData = context.getImageData( 0, 0, width, height );\n\n\t\t\t\tvar data = imageData.data;\n\n\t\t\t\tvar imageWidth = imageData.width; // assumed to be square\n\n\t\t\t\tvar pixelSize = 2 / imageWidth;\n\n\t\t\t\tfor ( var i = 0, il = data.length; i < il; i += 4 ) { // RGBA assumed\n\n\t\t\t\t\t// pixel color\n\t\t\t\t\tcolor.setRGB( data[ i ] / 255, data[ i + 1 ] / 255, data[ i + 2 ] / 255 );\n\n\t\t\t\t\t// convert to linear color space\n\t\t\t\t\tconvertColorToLinear( color, cubeTexture.encoding );\n\n\t\t\t\t\t// pixel coordinate on unit cube\n\n\t\t\t\t\tvar pixelIndex = i / 4;\n\n\t\t\t\t\tvar col = - 1 + ( pixelIndex % imageWidth + 0.5 ) * pixelSize;\n\n\t\t\t\t\tvar row = 1 - ( Math.floor( pixelIndex / imageWidth ) + 0.5 ) * pixelSize;\n\n\t\t\t\t\tswitch ( faceIndex ) {\n\n\t\t\t\t\t\tcase 0: coord.set( - 1, row, - col ); break;\n\n\t\t\t\t\t\tcase 1: coord.set( 1, row, col ); break;\n\n\t\t\t\t\t\tcase 2: coord.set( - col, 1, - row ); break;\n\n\t\t\t\t\t\tcase 3: coord.set( - col, - 1, row ); break;\n\n\t\t\t\t\t\tcase 4: coord.set( - col, row, 1 ); break;\n\n\t\t\t\t\t\tcase 5: coord.set( col, row, - 1 ); break;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// weight assigned to this pixel\n\n\t\t\t\t\tlengthSq = coord.lengthSq();\n\n\t\t\t\t\tweight = 4 / ( Math.sqrt( lengthSq ) * lengthSq );\n\n\t\t\t\t\ttotalWeight += weight;\n\n\t\t\t\t\t// direction vector to this pixel\n\t\t\t\t\tdir.copy( coord ).normalize();\n\n\t\t\t\t\t// evaluate SH basis functions in direction dir\n\t\t\t\t\tTHREE.SphericalHarmonics3.getBasisAt( dir, shBasis );\n\n\t\t\t\t\t// accummuulate\n\t\t\t\t\tfor ( var j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\t\tshCoefficients[ j ].x += shBasis[ j ] * color.r * weight;\n\t\t\t\t\t\tshCoefficients[ j ].y += shBasis[ j ] * color.g * weight;\n\t\t\t\t\t\tshCoefficients[ j ].z += shBasis[ j ] * color.b * weight;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normalize\n\t\t\tnorm = ( 4 * Math.PI ) / totalWeight;\n\n\t\t\tfor ( var j = 0; j < 9; j ++ ) {\n\n\t\t\t\tshCoefficients[ j ].x *= norm;\n\t\t\t\tshCoefficients[ j ].y *= norm;\n\t\t\t\tshCoefficients[ j ].z *= norm;\n\n\t\t\t}\n\n\t\t\treturn new THREE.LightProbe( sh );\n\n\t\t},\n\n\t\tfromCubeRenderTarget: function ( renderer, cubeRenderTarget ) {\n\n\t\t\t// The renderTarget must be set to RGBA in order to make readRenderTargetPixels works\n\t\t\tvar norm, lengthSq, weight, totalWeight = 0;\n\n\t\t\tvar coord = new THREE.Vector3();\n\n\t\t\tvar dir = new THREE.Vector3();\n\n\t\t\tvar color = new THREE.Color();\n\n\t\t\tvar shBasis = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\n\n\t\t\tvar sh = new THREE.SphericalHarmonics3();\n\t\t\tvar shCoefficients = sh.coefficients;\n\n\t\t\tfor ( var faceIndex = 0; faceIndex < 6; faceIndex ++ ) {\n\n\t\t\t\tvar imageWidth = cubeRenderTarget.width; // assumed to be square\n\t\t\t\tvar data = new Uint8Array( imageWidth * imageWidth * 4 );\n\t\t\t\trenderer.readRenderTargetPixels( cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex );\n\n\t\t\t\tvar pixelSize = 2 / imageWidth;\n\n\t\t\t\tfor ( var i = 0, il = data.length; i < il; i += 4 ) { // RGBA assumed\n\n\t\t\t\t\t// pixel color\n\t\t\t\t\tcolor.setRGB( data[ i ] / 255, data[ i + 1 ] / 255, data[ i + 2 ] / 255 );\n\n\t\t\t\t\t// convert to linear color space\n\t\t\t\t\tconvertColorToLinear( color, cubeRenderTarget.texture.encoding );\n\n\t\t\t\t\t// pixel coordinate on unit cube\n\n\t\t\t\t\tvar pixelIndex = i / 4;\n\n\t\t\t\t\tvar col = - 1 + ( pixelIndex % imageWidth + 0.5 ) * pixelSize;\n\n\t\t\t\t\tvar row = 1 - ( Math.floor( pixelIndex / imageWidth ) + 0.5 ) * pixelSize;\n\n\t\t\t\t\tswitch ( faceIndex ) {\n\n\t\t\t\t\t\tcase 0: coord.set( 1, row, - col ); break;\n\n\t\t\t\t\t\tcase 1: coord.set( - 1, row, col ); break;\n\n\t\t\t\t\t\tcase 2: coord.set( col, 1, - row ); break;\n\n\t\t\t\t\t\tcase 3: coord.set( col, - 1, row ); break;\n\n\t\t\t\t\t\tcase 4: coord.set( col, row, 1 ); break;\n\n\t\t\t\t\t\tcase 5: coord.set( - col, row, - 1 ); break;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// weight assigned to this pixel\n\n\t\t\t\t\tlengthSq = coord.lengthSq();\n\n\t\t\t\t\tweight = 4 / ( Math.sqrt( lengthSq ) * lengthSq );\n\n\t\t\t\t\ttotalWeight += weight;\n\n\t\t\t\t\t// direction vector to this pixel\n\t\t\t\t\tdir.copy( coord ).normalize();\n\n\t\t\t\t\t// evaluate SH basis functions in direction dir\n\t\t\t\t\tTHREE.SphericalHarmonics3.getBasisAt( dir, shBasis );\n\n\t\t\t\t\t// accummuulate\n\t\t\t\t\tfor ( var j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\t\tshCoefficients[ j ].x += shBasis[ j ] * color.r * weight;\n\t\t\t\t\t\tshCoefficients[ j ].y += shBasis[ j ] * color.g * weight;\n\t\t\t\t\t\tshCoefficients[ j ].z += shBasis[ j ] * color.b * weight;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normalize\n\t\t\tnorm = ( 4 * Math.PI ) / totalWeight;\n\n\t\t\tfor ( var j = 0; j < 9; j ++ ) {\n\n\t\t\t\tshCoefficients[ j ].x *= norm;\n\t\t\t\tshCoefficients[ j ].y *= norm;\n\t\t\t\tshCoefficients[ j ].z *= norm;\n\n\t\t\t}\n\n\t\t\treturn new THREE.LightProbe( sh );\n\n\t\t}\n\n\t};\n\n\tvar convertColorToLinear = function ( color, encoding ) {\n\n\t\tswitch ( encoding ) {\n\n\t\t\tcase THREE.sRGBEncoding:\n\n\t\t\t\tcolor.convertSRGBToLinear();\n\t\t\t\tbreak;\n\n\t\t\tcase THREE.LinearEncoding:\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn( 'WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.' );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn color;\n\n\t};\n\t\n\treturn THREE.LightProbeGenerator;\n});\n"]}