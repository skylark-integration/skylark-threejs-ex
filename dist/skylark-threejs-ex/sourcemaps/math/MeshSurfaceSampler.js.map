{"version":3,"sources":["math/MeshSurfaceSampler.js"],"names":["define","THREE","_face","Triangle","MeshSurfaceSampler","mesh","geometry","isBufferGeometry","attributes","position","itemSize","Error","index","console","warn","toNonIndexed","this","positionAttribute","getAttribute","weightAttribute","distribution","prototype","constructor","setWeightAttribute","name","build","faceWeights","Float32Array","count","i","faceWeight","getX","a","fromBufferAttribute","b","c","getArea","cumulativeTotal","length","sample","targetPosition","targetNormal","faceIndex","binarySearch","Math","random","sampleFace","x","dist","start","end","mid","floor","u","v","set","addScaledVector","getNormal"],"mappings":";;;;;;;AAAAA,QACI,mBACD,SAAUC,GACT,aAsFA,OArFyB,WACrB,IAAIC,EAAQ,IAAID,EAAME,SACtB,SAASC,EAAmBC,GACxB,IAAIC,EAAWD,EAAKC,SACpB,IAAKA,EAASC,kBAA8D,IAA1CD,EAASE,WAAWC,SAASC,SAC3D,MAAM,IAAIC,MAAM,oEAEhBL,EAASM,QACTC,QAAQC,KAAK,gFACbR,EAAWA,EAASS,gBAExBC,KAAKV,SAAWA,EAChBU,KAAKC,kBAAoBD,KAAKV,SAASY,aAAa,YACpDF,KAAKG,gBAAkB,KACvBH,KAAKI,aAAe,KAqExB,OAnEAhB,EAAmBiB,WACfC,YAAalB,EACbmB,mBAAoB,SAAUC,GAE1B,OADAR,KAAKG,gBAAkBK,EAAOR,KAAKV,SAASY,aAAaM,GAAQ,KAC1DR,MAEXS,MAAO,WAIH,IAHA,IAAIR,EAAoBD,KAAKC,kBACzBE,EAAkBH,KAAKG,gBACvBO,EAAc,IAAIC,aAAaV,EAAkBW,MAAQ,GACpDC,EAAI,EAAGA,EAAIZ,EAAkBW,MAAOC,GAAK,EAAG,CACjD,IAAIC,EAAa,EACbX,IACAW,EAAaX,EAAgBY,KAAKF,GAAKV,EAAgBY,KAAKF,EAAI,GAAKV,EAAgBY,KAAKF,EAAI,IAElG3B,EAAM8B,EAAEC,oBAAoBhB,EAAmBY,GAC/C3B,EAAMgC,EAAED,oBAAoBhB,EAAmBY,EAAI,GACnD3B,EAAMiC,EAAEF,oBAAoBhB,EAAmBY,EAAI,GACnDC,GAAc5B,EAAMkC,UACpBV,EAAYG,EAAI,GAAKC,EAEzBd,KAAKI,aAAe,IAAIO,aAAaV,EAAkBW,MAAQ,GAC/D,IAAIS,EAAkB,EACtB,IAASR,EAAI,EAAGA,EAAIH,EAAYY,OAAQT,IACpCQ,GAAmBX,EAAYG,GAC/Bb,KAAKI,aAAaS,GAAKQ,EAE3B,OAAOrB,MAEXuB,OAAQ,SAAUC,EAAgBC,GAC9B,IAAIJ,EAAkBrB,KAAKI,aAAaJ,KAAKI,aAAakB,OAAS,GAC/DI,EAAY1B,KAAK2B,aAAaC,KAAKC,SAAWR,GAClD,OAAOrB,KAAK8B,WAAWJ,EAAWF,EAAgBC,IAEtDE,aAAc,SAAUI,GAKpB,IAJA,IAAIC,EAAOhC,KAAKI,aACZ6B,EAAQ,EACRC,EAAMF,EAAKV,OAAS,EACpB1B,GAAS,EACNqC,GAASC,GAAK,CACjB,IAAIC,EAAMP,KAAKQ,OAAOH,EAAQC,GAAO,GACrC,GAAY,IAARC,GAAaH,EAAKG,EAAM,IAAMJ,GAAKC,EAAKG,GAAOJ,EAAG,CAClDnC,EAAQuC,EACR,MACOJ,EAAIC,EAAKG,GAChBD,EAAMC,EAAM,EAEZF,EAAQE,EAAM,EAGtB,OAAOvC,GAEXkC,WAAY,SAAUJ,EAAWF,EAAgBC,GAC7C,IAAIY,EAAIT,KAAKC,SACTS,EAAIV,KAAKC,SAUb,OATIQ,EAAIC,EAAI,IACRD,EAAI,EAAIA,EACRC,EAAI,EAAIA,GAEZpD,EAAM8B,EAAEC,oBAAoBjB,KAAKC,kBAA+B,EAAZyB,GACpDxC,EAAMgC,EAAED,oBAAoBjB,KAAKC,kBAA+B,EAAZyB,EAAgB,GACpExC,EAAMiC,EAAEF,oBAAoBjB,KAAKC,kBAA+B,EAAZyB,EAAgB,GACpEF,EAAee,IAAI,EAAG,EAAG,GAAGC,gBAAgBtD,EAAM8B,EAAGqB,GAAGG,gBAAgBtD,EAAMgC,EAAGoB,GAAGE,gBAAgBtD,EAAMiC,EAAG,GAAKkB,EAAIC,IACtHpD,EAAMuD,UAAUhB,GACTzB,OAGRZ,EAnFc","file":"../../math/MeshSurfaceSampler.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var MeshSurfaceSampler = function () {\n        var _face = new THREE.Triangle();\n        function MeshSurfaceSampler(mesh) {\n            var geometry = mesh.geometry;\n            if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {\n                throw new Error('THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.');\n            }\n            if (geometry.index) {\n                console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.');\n                geometry = geometry.toNonIndexed();\n            }\n            this.geometry = geometry;\n            this.positionAttribute = this.geometry.getAttribute('position');\n            this.weightAttribute = null;\n            this.distribution = null;\n        }\n        MeshSurfaceSampler.prototype = {\n            constructor: MeshSurfaceSampler,\n            setWeightAttribute: function (name) {\n                this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n                return this;\n            },\n            build: function () {\n                var positionAttribute = this.positionAttribute;\n                var weightAttribute = this.weightAttribute;\n                var faceWeights = new Float32Array(positionAttribute.count / 3);\n                for (var i = 0; i < positionAttribute.count; i += 3) {\n                    var faceWeight = 1;\n                    if (weightAttribute) {\n                        faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\n                    }\n                    _face.a.fromBufferAttribute(positionAttribute, i);\n                    _face.b.fromBufferAttribute(positionAttribute, i + 1);\n                    _face.c.fromBufferAttribute(positionAttribute, i + 2);\n                    faceWeight *= _face.getArea();\n                    faceWeights[i / 3] = faceWeight;\n                }\n                this.distribution = new Float32Array(positionAttribute.count / 3);\n                var cumulativeTotal = 0;\n                for (var i = 0; i < faceWeights.length; i++) {\n                    cumulativeTotal += faceWeights[i];\n                    this.distribution[i] = cumulativeTotal;\n                }\n                return this;\n            },\n            sample: function (targetPosition, targetNormal) {\n                var cumulativeTotal = this.distribution[this.distribution.length - 1];\n                var faceIndex = this.binarySearch(Math.random() * cumulativeTotal);\n                return this.sampleFace(faceIndex, targetPosition, targetNormal);\n            },\n            binarySearch: function (x) {\n                var dist = this.distribution;\n                var start = 0;\n                var end = dist.length - 1;\n                var index = -1;\n                while (start <= end) {\n                    var mid = Math.floor((start + end) / 2);\n                    if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n                        index = mid;\n                        break;\n                    } else if (x < dist[mid]) {\n                        end = mid - 1;\n                    } else {\n                        start = mid + 1;\n                    }\n                }\n                return index;\n            },\n            sampleFace: function (faceIndex, targetPosition, targetNormal) {\n                var u = Math.random();\n                var v = Math.random();\n                if (u + v > 1) {\n                    u = 1 - u;\n                    v = 1 - v;\n                }\n                _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\n                _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\n                _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\n                targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n                _face.getNormal(targetNormal);\n                return this;\n            }\n        };\n        return MeshSurfaceSampler;\n    }();\n    return  MeshSurfaceSampler;\n});"]}