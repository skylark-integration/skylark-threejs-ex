{"version":3,"sources":["math/MeshSurfaceSampler.js"],"names":["define","THREE","threex","MeshSurfaceSampler","_face","Triangle","mesh","geometry","isBufferGeometry","attributes","position","itemSize","Error","index","console","warn","toNonIndexed","this","positionAttribute","getAttribute","weightAttribute","distribution","prototype","constructor","setWeightAttribute","name","build","faceWeights","Float32Array","count","i","faceWeight","getX","a","fromBufferAttribute","b","c","getArea","cumulativeTotal","length","sample","targetPosition","targetNormal","faceIndex","binarySearch","Math","random","sampleFace","x","dist","start","end","mid","floor","u","v","set","addScaledVector","getNormal","math"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,EAAqB,WACrB,IAAIC,EAAQ,IAAIH,EAAMI,SACtB,SAASF,EAAmBG,GACxB,IAAIC,EAAWD,EAAKC,SACpB,IAAKA,EAASC,kBAA8D,IAA1CD,EAASE,WAAWC,SAASC,SAC3D,MAAM,IAAIC,MAAM,oEAEhBL,EAASM,QACTC,QAAQC,KAAK,gFACbR,EAAWA,EAASS,gBAExBC,KAAKV,SAAWA,EAChBU,KAAKC,kBAAoBD,KAAKV,SAASY,aAAa,YACpDF,KAAKG,gBAAkB,KACvBH,KAAKI,aAAe,KAqExB,OAnEAlB,EAAmBmB,WACfC,YAAapB,EACbqB,mBAAoB,SAAUC,GAE1B,OADAR,KAAKG,gBAAkBK,EAAOR,KAAKV,SAASY,aAAaM,GAAQ,KAC1DR,MAEXS,MAAO,WAIH,IAHA,IAAIR,EAAoBD,KAAKC,kBACzBE,EAAkBH,KAAKG,gBACvBO,EAAc,IAAIC,aAAaV,EAAkBW,MAAQ,GACpDC,EAAI,EAAGA,EAAIZ,EAAkBW,MAAOC,GAAK,EAAG,CACjD,IAAIC,EAAa,EACbX,IACAW,EAAaX,EAAgBY,KAAKF,GAAKV,EAAgBY,KAAKF,EAAI,GAAKV,EAAgBY,KAAKF,EAAI,IAElG1B,EAAM6B,EAAEC,oBAAoBhB,EAAmBY,GAC/C1B,EAAM+B,EAAED,oBAAoBhB,EAAmBY,EAAI,GACnD1B,EAAMgC,EAAEF,oBAAoBhB,EAAmBY,EAAI,GACnDC,GAAc3B,EAAMiC,UACpBV,EAAYG,EAAI,GAAKC,EAEzBd,KAAKI,aAAe,IAAIO,aAAaV,EAAkBW,MAAQ,GAC/D,IAAIS,EAAkB,EACtB,IAASR,EAAI,EAAGA,EAAIH,EAAYY,OAAQT,IACpCQ,GAAmBX,EAAYG,GAC/Bb,KAAKI,aAAaS,GAAKQ,EAE3B,OAAOrB,MAEXuB,OAAQ,SAAUC,EAAgBC,GAC9B,IAAIJ,EAAkBrB,KAAKI,aAAaJ,KAAKI,aAAakB,OAAS,GAC/DI,EAAY1B,KAAK2B,aAAaC,KAAKC,SAAWR,GAClD,OAAOrB,KAAK8B,WAAWJ,EAAWF,EAAgBC,IAEtDE,aAAc,SAAUI,GAKpB,IAJA,IAAIC,EAAOhC,KAAKI,aACZ6B,EAAQ,EACRC,EAAMF,EAAKV,OAAS,EACpB1B,GAAS,EACNqC,GAASC,GAAK,CACjB,IAAIC,EAAMP,KAAKQ,OAAOH,EAAQC,GAAO,GACrC,GAAY,IAARC,GAAaH,EAAKG,EAAM,IAAMJ,GAAKC,EAAKG,GAAOJ,EAAG,CAClDnC,EAAQuC,EACR,MACOJ,EAAIC,EAAKG,GAChBD,EAAMC,EAAM,EAEZF,EAAQE,EAAM,EAGtB,OAAOvC,GAEXkC,WAAY,SAAUJ,EAAWF,EAAgBC,GAC7C,IAAIY,EAAIT,KAAKC,SACTS,EAAIV,KAAKC,SAUb,OATIQ,EAAIC,EAAI,IACRD,EAAI,EAAIA,EACRC,EAAI,EAAIA,GAEZnD,EAAM6B,EAAEC,oBAAoBjB,KAAKC,kBAA+B,EAAZyB,GACpDvC,EAAM+B,EAAED,oBAAoBjB,KAAKC,kBAA+B,EAAZyB,EAAgB,GACpEvC,EAAMgC,EAAEF,oBAAoBjB,KAAKC,kBAA+B,EAAZyB,EAAgB,GACpEF,EAAee,IAAI,EAAG,EAAG,GAAGC,gBAAgBrD,EAAM6B,EAAGqB,GAAGG,gBAAgBrD,EAAM+B,EAAGoB,GAAGE,gBAAgBrD,EAAMgC,EAAG,GAAKkB,EAAIC,IACtHnD,EAAMsD,UAAUhB,GACTzB,OAGRd,EAnFc,GAqFzB,OAAQD,EAAOyD,KAAKxD,mBAAqBA","file":"../../math/MeshSurfaceSampler.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var MeshSurfaceSampler = function () {\r\n        var _face = new THREE.Triangle();\r\n        function MeshSurfaceSampler(mesh) {\r\n            var geometry = mesh.geometry;\r\n            if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {\r\n                throw new Error('THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.');\r\n            }\r\n            if (geometry.index) {\r\n                console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.');\r\n                geometry = geometry.toNonIndexed();\r\n            }\r\n            this.geometry = geometry;\r\n            this.positionAttribute = this.geometry.getAttribute('position');\r\n            this.weightAttribute = null;\r\n            this.distribution = null;\r\n        }\r\n        MeshSurfaceSampler.prototype = {\r\n            constructor: MeshSurfaceSampler,\r\n            setWeightAttribute: function (name) {\r\n                this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\r\n                return this;\r\n            },\r\n            build: function () {\r\n                var positionAttribute = this.positionAttribute;\r\n                var weightAttribute = this.weightAttribute;\r\n                var faceWeights = new Float32Array(positionAttribute.count / 3);\r\n                for (var i = 0; i < positionAttribute.count; i += 3) {\r\n                    var faceWeight = 1;\r\n                    if (weightAttribute) {\r\n                        faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\r\n                    }\r\n                    _face.a.fromBufferAttribute(positionAttribute, i);\r\n                    _face.b.fromBufferAttribute(positionAttribute, i + 1);\r\n                    _face.c.fromBufferAttribute(positionAttribute, i + 2);\r\n                    faceWeight *= _face.getArea();\r\n                    faceWeights[i / 3] = faceWeight;\r\n                }\r\n                this.distribution = new Float32Array(positionAttribute.count / 3);\r\n                var cumulativeTotal = 0;\r\n                for (var i = 0; i < faceWeights.length; i++) {\r\n                    cumulativeTotal += faceWeights[i];\r\n                    this.distribution[i] = cumulativeTotal;\r\n                }\r\n                return this;\r\n            },\r\n            sample: function (targetPosition, targetNormal) {\r\n                var cumulativeTotal = this.distribution[this.distribution.length - 1];\r\n                var faceIndex = this.binarySearch(Math.random() * cumulativeTotal);\r\n                return this.sampleFace(faceIndex, targetPosition, targetNormal);\r\n            },\r\n            binarySearch: function (x) {\r\n                var dist = this.distribution;\r\n                var start = 0;\r\n                var end = dist.length - 1;\r\n                var index = -1;\r\n                while (start <= end) {\r\n                    var mid = Math.floor((start + end) / 2);\r\n                    if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\r\n                        index = mid;\r\n                        break;\r\n                    } else if (x < dist[mid]) {\r\n                        end = mid - 1;\r\n                    } else {\r\n                        start = mid + 1;\r\n                    }\r\n                }\r\n                return index;\r\n            },\r\n            sampleFace: function (faceIndex, targetPosition, targetNormal) {\r\n                var u = Math.random();\r\n                var v = Math.random();\r\n                if (u + v > 1) {\r\n                    u = 1 - u;\r\n                    v = 1 - v;\r\n                }\r\n                _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\r\n                _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\r\n                _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\r\n                targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\r\n                _face.getNormal(targetNormal);\r\n                return this;\r\n            }\r\n        };\r\n        return MeshSurfaceSampler;\r\n    }();\r\n    return  threex.math.MeshSurfaceSampler = MeshSurfaceSampler;\r\n});"]}