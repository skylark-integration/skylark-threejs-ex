{"version":3,"sources":["math/MeshSurfaceSampler.js"],"names":["define","THREE","threex","MeshSurfaceSampler","_face","Triangle","mesh","geometry","isBufferGeometry","attributes","position","itemSize","Error","index","console","warn","toNonIndexed","this","positionAttribute","getAttribute","weightAttribute","distribution","prototype","constructor","setWeightAttribute","name","build","faceWeights","Float32Array","count","i","faceWeight","getX","a","fromBufferAttribute","b","c","getArea","cumulativeTotal","length","sample","targetPosition","targetNormal","faceIndex","binarySearch","Math","random","sampleFace","x","dist","start","end","mid","floor","u","v","set","addScaledVector","getNormal","math"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,EAAqB,WACrB,IAAIC,EAAQ,IAAIH,EAAMI,SACtB,SAASF,EAAmBG,GACxB,IAAIC,EAAWD,EAAKC,SACpB,IAAKA,EAASC,kBAA8D,IAA1CD,EAASE,WAAWC,SAASC,SAC3D,MAAM,IAAIC,MAAM,oEAEhBL,EAASM,QACTC,QAAQC,KAAK,gFACbR,EAAWA,EAASS,gBAExBC,KAAKV,SAAWA,EAChBU,KAAKC,kBAAoBD,KAAKV,SAASY,aAAa,YACpDF,KAAKG,gBAAkB,KACvBH,KAAKI,aAAe,KAqExB,OAnEAlB,EAAmBmB,WACfC,YAAapB,EACbqB,mBAAoB,SAAUC,GAE1B,OADAR,KAAKG,gBAAkBK,EAAOR,KAAKV,SAASY,aAAaM,GAAQ,KAC1DR,MAEXS,MAAO,WAIH,IAHA,IAAIR,EAAoBD,KAAKC,kBACzBE,EAAkBH,KAAKG,gBACvBO,EAAc,IAAIC,aAAaV,EAAkBW,MAAQ,GACpDC,EAAI,EAAGA,EAAIZ,EAAkBW,MAAOC,GAAK,EAAG,CACjD,IAAIC,EAAa,EACbX,IACAW,EAAaX,EAAgBY,KAAKF,GAAKV,EAAgBY,KAAKF,EAAI,GAAKV,EAAgBY,KAAKF,EAAI,IAElG1B,EAAM6B,EAAEC,oBAAoBhB,EAAmBY,GAC/C1B,EAAM+B,EAAED,oBAAoBhB,EAAmBY,EAAI,GACnD1B,EAAMgC,EAAEF,oBAAoBhB,EAAmBY,EAAI,GACnDC,GAAc3B,EAAMiC,UACpBV,EAAYG,EAAI,GAAKC,EAEzBd,KAAKI,aAAe,IAAIO,aAAaV,EAAkBW,MAAQ,GAC/D,IAAIS,EAAkB,EACtB,IAASR,EAAI,EAAGA,EAAIH,EAAYY,OAAQT,IACpCQ,GAAmBX,EAAYG,GAC/Bb,KAAKI,aAAaS,GAAKQ,EAE3B,OAAOrB,MAEXuB,OAAQ,SAAUC,EAAgBC,GAC9B,IAAIJ,EAAkBrB,KAAKI,aAAaJ,KAAKI,aAAakB,OAAS,GAC/DI,EAAY1B,KAAK2B,aAAaC,KAAKC,SAAWR,GAClD,OAAOrB,KAAK8B,WAAWJ,EAAWF,EAAgBC,IAEtDE,aAAc,SAAUI,GAKpB,IAJA,IAAIC,EAAOhC,KAAKI,aACZ6B,EAAQ,EACRC,EAAMF,EAAKV,OAAS,EACpB1B,GAAS,EACNqC,GAASC,GAAK,CACjB,IAAIC,EAAMP,KAAKQ,OAAOH,EAAQC,GAAO,GACrC,GAAY,IAARC,GAAaH,EAAKG,EAAM,IAAMJ,GAAKC,EAAKG,GAAOJ,EAAG,CAClDnC,EAAQuC,EACR,MACOJ,EAAIC,EAAKG,GAChBD,EAAMC,EAAM,EAEZF,EAAQE,EAAM,EAGtB,OAAOvC,GAEXkC,WAAY,SAAUJ,EAAWF,EAAgBC,GAC7C,IAAIY,EAAIT,KAAKC,SACTS,EAAIV,KAAKC,SAUb,OATIQ,EAAIC,EAAI,IACRD,EAAI,EAAIA,EACRC,EAAI,EAAIA,GAEZnD,EAAM6B,EAAEC,oBAAoBjB,KAAKC,kBAA+B,EAAZyB,GACpDvC,EAAM+B,EAAED,oBAAoBjB,KAAKC,kBAA+B,EAAZyB,EAAgB,GACpEvC,EAAMgC,EAAEF,oBAAoBjB,KAAKC,kBAA+B,EAAZyB,EAAgB,GACpEF,EAAee,IAAI,EAAG,EAAG,GAAGC,gBAAgBrD,EAAM6B,EAAGqB,GAAGG,gBAAgBrD,EAAM+B,EAAGoB,GAAGE,gBAAgBrD,EAAMgC,EAAG,GAAKkB,EAAIC,IACtHnD,EAAMsD,UAAUhB,GACTzB,OAGRd,EAnFc,GAqFzB,OAAQD,EAAOyD,KAAKxD,mBAAqBA","file":"../../math/MeshSurfaceSampler.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    var MeshSurfaceSampler = function () {\n        var _face = new THREE.Triangle();\n        function MeshSurfaceSampler(mesh) {\n            var geometry = mesh.geometry;\n            if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {\n                throw new Error('THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.');\n            }\n            if (geometry.index) {\n                console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.');\n                geometry = geometry.toNonIndexed();\n            }\n            this.geometry = geometry;\n            this.positionAttribute = this.geometry.getAttribute('position');\n            this.weightAttribute = null;\n            this.distribution = null;\n        }\n        MeshSurfaceSampler.prototype = {\n            constructor: MeshSurfaceSampler,\n            setWeightAttribute: function (name) {\n                this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n                return this;\n            },\n            build: function () {\n                var positionAttribute = this.positionAttribute;\n                var weightAttribute = this.weightAttribute;\n                var faceWeights = new Float32Array(positionAttribute.count / 3);\n                for (var i = 0; i < positionAttribute.count; i += 3) {\n                    var faceWeight = 1;\n                    if (weightAttribute) {\n                        faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\n                    }\n                    _face.a.fromBufferAttribute(positionAttribute, i);\n                    _face.b.fromBufferAttribute(positionAttribute, i + 1);\n                    _face.c.fromBufferAttribute(positionAttribute, i + 2);\n                    faceWeight *= _face.getArea();\n                    faceWeights[i / 3] = faceWeight;\n                }\n                this.distribution = new Float32Array(positionAttribute.count / 3);\n                var cumulativeTotal = 0;\n                for (var i = 0; i < faceWeights.length; i++) {\n                    cumulativeTotal += faceWeights[i];\n                    this.distribution[i] = cumulativeTotal;\n                }\n                return this;\n            },\n            sample: function (targetPosition, targetNormal) {\n                var cumulativeTotal = this.distribution[this.distribution.length - 1];\n                var faceIndex = this.binarySearch(Math.random() * cumulativeTotal);\n                return this.sampleFace(faceIndex, targetPosition, targetNormal);\n            },\n            binarySearch: function (x) {\n                var dist = this.distribution;\n                var start = 0;\n                var end = dist.length - 1;\n                var index = -1;\n                while (start <= end) {\n                    var mid = Math.floor((start + end) / 2);\n                    if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n                        index = mid;\n                        break;\n                    } else if (x < dist[mid]) {\n                        end = mid - 1;\n                    } else {\n                        start = mid + 1;\n                    }\n                }\n                return index;\n            },\n            sampleFace: function (faceIndex, targetPosition, targetNormal) {\n                var u = Math.random();\n                var v = Math.random();\n                if (u + v > 1) {\n                    u = 1 - u;\n                    v = 1 - v;\n                }\n                _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\n                _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\n                _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\n                targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n                _face.getNormal(targetNormal);\n                return this;\n            }\n        };\n        return MeshSurfaceSampler;\n    }();\n    return  threex.math.MeshSurfaceSampler = MeshSurfaceSampler;\n});"]}