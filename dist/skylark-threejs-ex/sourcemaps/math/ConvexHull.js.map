{"version":3,"sources":["math/ConvexHull.js"],"names":["define","THREE","line3","plane","closestPoint","triangle","Visible","v1","Vector3","ConvexHull","this","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","Face","normal","midpoint","area","constant","outside","mark","edge","HalfEdge","vertex","face","prev","next","twin","VertexNode","point","head","tail","Object","assign","prototype","setFromPoints","points","Array","isArray","console","error","length","makeEmpty","i","l","push","compute","setFromObject","object","updateMatrixWorld","traverse","node","geometry","undefined","isGeometry","clone","applyMatrix4","matrixWorld","isBufferGeometry","attribute","attributes","position","count","fromBufferAttribute","containsPoint","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","vN","origin","vD","dot","direction","t","Math","min","max","at","intersectsRay","addVertexToFace","append","insertBefore","removeVertexFromFace","remove","removeAllVerticesFromFace","start","end","removeSubList","deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","distance","computeExtremes","j","minVertices","maxVertices","copy","getComponent","setComponent","Number","EPSILON","abs","x","y","z","computeInitialHull","Line3","Plane","v0","v2","v3","extremes","index","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","create","getEdge","setTwin","reindexFaces","activeFaces","nextVertexToAdd","eyeVertex","eyeFace","computeHorizon","eyePoint","crossEdge","horizon","twinEdge","oppositeFace","addAdjoiningFace","horizonEdge","addNewFaces","firstSideEdge","previousSideEdge","sideEdge","addVertexToHull","clear","cleanup","a","b","c","e0","e1","e2","Triangle","getNormal","getMidpoint","getArea","distanceTo","lengthSquared","last","insertAfter"],"mappings":"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","file":"../../math/ConvexHull.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var ConvexHull = function () {\n        var Visible = 0;\n        var Deleted = 1;\n        var v1 = new THREE.Vector3();\n        function ConvexHull() {\n            this.tolerance = -1;\n            this.faces = [];\n            this.newFaces = [];\n            this.assigned = new VertexList();\n            this.unassigned = new VertexList();\n            this.vertices = [];\n        }\n        Object.assign(ConvexHull.prototype, {\n            setFromPoints: function (points) {\n                if (Array.isArray(points) !== true) {\n                    console.error('THREE.ConvexHull: Points parameter is not an array.');\n                }\n                if (points.length < 4) {\n                    console.error('THREE.ConvexHull: The algorithm needs at least four points.');\n                }\n                this.makeEmpty();\n                for (var i = 0, l = points.length; i < l; i++) {\n                    this.vertices.push(new VertexNode(points[i]));\n                }\n                this.compute();\n                return this;\n            },\n            setFromObject: function (object) {\n                var points = [];\n                object.updateMatrixWorld(true);\n                object.traverse(function (node) {\n                    var i, l, point;\n                    var geometry = node.geometry;\n                    if (geometry !== undefined) {\n                        if (geometry.isGeometry) {\n                            var vertices = geometry.vertices;\n                            for (i = 0, l = vertices.length; i < l; i++) {\n                                point = vertices[i].clone();\n                                point.applyMatrix4(node.matrixWorld);\n                                points.push(point);\n                            }\n                        } else if (geometry.isBufferGeometry) {\n                            var attribute = geometry.attributes.position;\n                            if (attribute !== undefined) {\n                                for (i = 0, l = attribute.count; i < l; i++) {\n                                    point = new THREE.Vector3();\n                                    point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n                                    points.push(point);\n                                }\n                            }\n                        }\n                    }\n                });\n                return this.setFromPoints(points);\n            },\n            containsPoint: function (point) {\n                var faces = this.faces;\n                for (var i = 0, l = faces.length; i < l; i++) {\n                    var face = faces[i];\n                    if (face.distanceToPoint(point) > this.tolerance)\n                        return false;\n                }\n                return true;\n            },\n            intersectRay: function (ray, target) {\n                var faces = this.faces;\n                var tNear = -Infinity;\n                var tFar = Infinity;\n                for (var i = 0, l = faces.length; i < l; i++) {\n                    var face = faces[i];\n                    var vN = face.distanceToPoint(ray.origin);\n                    var vD = face.normal.dot(ray.direction);\n                    if (vN > 0 && vD >= 0)\n                        return null;\n                    var t = vD !== 0 ? -vN / vD : 0;\n                    if (t <= 0)\n                        continue;\n                    if (vD > 0) {\n                        tFar = Math.min(t, tFar);\n                    } else {\n                        tNear = Math.max(t, tNear);\n                    }\n                    if (tNear > tFar) {\n                        return null;\n                    }\n                }\n                if (tNear !== -Infinity) {\n                    ray.at(tNear, target);\n                } else {\n                    ray.at(tFar, target);\n                }\n                return target;\n            },\n            intersectsRay: function (ray) {\n                return this.intersectRay(ray, v1) !== null;\n            },\n            makeEmpty: function () {\n                this.faces = [];\n                this.vertices = [];\n                return this;\n            },\n            addVertexToFace: function (vertex, face) {\n                vertex.face = face;\n                if (face.outside === null) {\n                    this.assigned.append(vertex);\n                } else {\n                    this.assigned.insertBefore(face.outside, vertex);\n                }\n                face.outside = vertex;\n                return this;\n            },\n            removeVertexFromFace: function (vertex, face) {\n                if (vertex === face.outside) {\n                    if (vertex.next !== null && vertex.next.face === face) {\n                        face.outside = vertex.next;\n                    } else {\n                        face.outside = null;\n                    }\n                }\n                this.assigned.remove(vertex);\n                return this;\n            },\n            removeAllVerticesFromFace: function (face) {\n                if (face.outside !== null) {\n                    var start = face.outside;\n                    var end = face.outside;\n                    while (end.next !== null && end.next.face === face) {\n                        end = end.next;\n                    }\n                    this.assigned.removeSubList(start, end);\n                    start.prev = end.next = null;\n                    face.outside = null;\n                    return start;\n                }\n            },\n            deleteFaceVertices: function (face, absorbingFace) {\n                var faceVertices = this.removeAllVerticesFromFace(face);\n                if (faceVertices !== undefined) {\n                    if (absorbingFace === undefined) {\n                        this.unassigned.appendChain(faceVertices);\n                    } else {\n                        var vertex = faceVertices;\n                        do {\n                            var nextVertex = vertex.next;\n                            var distance = absorbingFace.distanceToPoint(vertex.point);\n                            if (distance > this.tolerance) {\n                                this.addVertexToFace(vertex, absorbingFace);\n                            } else {\n                                this.unassigned.append(vertex);\n                            }\n                            vertex = nextVertex;\n                        } while (vertex !== null);\n                    }\n                }\n                return this;\n            },\n            resolveUnassignedPoints: function (newFaces) {\n                if (this.unassigned.isEmpty() === false) {\n                    var vertex = this.unassigned.first();\n                    do {\n                        var nextVertex = vertex.next;\n                        var maxDistance = this.tolerance;\n                        var maxFace = null;\n                        for (var i = 0; i < newFaces.length; i++) {\n                            var face = newFaces[i];\n                            if (face.mark === Visible) {\n                                var distance = face.distanceToPoint(vertex.point);\n                                if (distance > maxDistance) {\n                                    maxDistance = distance;\n                                    maxFace = face;\n                                }\n                                if (maxDistance > 1000 * this.tolerance)\n                                    break;\n                            }\n                        }\n                        if (maxFace !== null) {\n                            this.addVertexToFace(vertex, maxFace);\n                        }\n                        vertex = nextVertex;\n                    } while (vertex !== null);\n                }\n                return this;\n            },\n            computeExtremes: function () {\n                var min = new THREE.Vector3();\n                var max = new THREE.Vector3();\n                var minVertices = [];\n                var maxVertices = [];\n                var i, l, j;\n                for (i = 0; i < 3; i++) {\n                    minVertices[i] = maxVertices[i] = this.vertices[0];\n                }\n                min.copy(this.vertices[0].point);\n                max.copy(this.vertices[0].point);\n                for (i = 0, l = this.vertices.length; i < l; i++) {\n                    var vertex = this.vertices[i];\n                    var point = vertex.point;\n                    for (j = 0; j < 3; j++) {\n                        if (point.getComponent(j) < min.getComponent(j)) {\n                            min.setComponent(j, point.getComponent(j));\n                            minVertices[j] = vertex;\n                        }\n                    }\n                    for (j = 0; j < 3; j++) {\n                        if (point.getComponent(j) > max.getComponent(j)) {\n                            max.setComponent(j, point.getComponent(j));\n                            maxVertices[j] = vertex;\n                        }\n                    }\n                }\n                this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n                return {\n                    min: minVertices,\n                    max: maxVertices\n                };\n            },\n            computeInitialHull: function () {\n                var line3, plane, closestPoint;\n                return function computeInitialHull() {\n                    if (line3 === undefined) {\n                        line3 = new THREE.Line3();\n                        plane = new THREE.Plane();\n                        closestPoint = new THREE.Vector3();\n                    }\n                    var vertex, vertices = this.vertices;\n                    var extremes = this.computeExtremes();\n                    var min = extremes.min;\n                    var max = extremes.max;\n                    var v0, v1, v2, v3;\n                    var i, l, j;\n                    var distance, maxDistance = 0;\n                    var index = 0;\n                    for (i = 0; i < 3; i++) {\n                        distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n                        if (distance > maxDistance) {\n                            maxDistance = distance;\n                            index = i;\n                        }\n                    }\n                    v0 = min[index];\n                    v1 = max[index];\n                    maxDistance = 0;\n                    line3.set(v0.point, v1.point);\n                    for (i = 0, l = this.vertices.length; i < l; i++) {\n                        vertex = vertices[i];\n                        if (vertex !== v0 && vertex !== v1) {\n                            line3.closestPointToPoint(vertex.point, true, closestPoint);\n                            distance = closestPoint.distanceToSquared(vertex.point);\n                            if (distance > maxDistance) {\n                                maxDistance = distance;\n                                v2 = vertex;\n                            }\n                        }\n                    }\n                    maxDistance = -1;\n                    plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n                    for (i = 0, l = this.vertices.length; i < l; i++) {\n                        vertex = vertices[i];\n                        if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n                            distance = Math.abs(plane.distanceToPoint(vertex.point));\n                            if (distance > maxDistance) {\n                                maxDistance = distance;\n                                v3 = vertex;\n                            }\n                        }\n                    }\n                    var faces = [];\n                    if (plane.distanceToPoint(v3.point) < 0) {\n                        faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2));\n                        for (i = 0; i < 3; i++) {\n                            j = (i + 1) % 3;\n                            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));\n                            faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n                        }\n                    } else {\n                        faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0));\n                        for (i = 0; i < 3; i++) {\n                            j = (i + 1) % 3;\n                            faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));\n                            faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));\n                        }\n                    }\n                    for (i = 0; i < 4; i++) {\n                        this.faces.push(faces[i]);\n                    }\n                    for (i = 0, l = vertices.length; i < l; i++) {\n                        vertex = vertices[i];\n                        if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n                            maxDistance = this.tolerance;\n                            var maxFace = null;\n                            for (j = 0; j < 4; j++) {\n                                distance = this.faces[j].distanceToPoint(vertex.point);\n                                if (distance > maxDistance) {\n                                    maxDistance = distance;\n                                    maxFace = this.faces[j];\n                                }\n                            }\n                            if (maxFace !== null) {\n                                this.addVertexToFace(vertex, maxFace);\n                            }\n                        }\n                    }\n                    return this;\n                };\n            }(),\n            reindexFaces: function () {\n                var activeFaces = [];\n                for (var i = 0; i < this.faces.length; i++) {\n                    var face = this.faces[i];\n                    if (face.mark === Visible) {\n                        activeFaces.push(face);\n                    }\n                }\n                this.faces = activeFaces;\n                return this;\n            },\n            nextVertexToAdd: function () {\n                if (this.assigned.isEmpty() === false) {\n                    var eyeVertex, maxDistance = 0;\n                    var eyeFace = this.assigned.first().face;\n                    var vertex = eyeFace.outside;\n                    do {\n                        var distance = eyeFace.distanceToPoint(vertex.point);\n                        if (distance > maxDistance) {\n                            maxDistance = distance;\n                            eyeVertex = vertex;\n                        }\n                        vertex = vertex.next;\n                    } while (vertex !== null && vertex.face === eyeFace);\n                    return eyeVertex;\n                }\n            },\n            computeHorizon: function (eyePoint, crossEdge, face, horizon) {\n                this.deleteFaceVertices(face);\n                face.mark = Deleted;\n                var edge;\n                if (crossEdge === null) {\n                    edge = crossEdge = face.getEdge(0);\n                } else {\n                    edge = crossEdge.next;\n                }\n                do {\n                    var twinEdge = edge.twin;\n                    var oppositeFace = twinEdge.face;\n                    if (oppositeFace.mark === Visible) {\n                        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n                            this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n                        } else {\n                            horizon.push(edge);\n                        }\n                    }\n                    edge = edge.next;\n                } while (edge !== crossEdge);\n                return this;\n            },\n            addAdjoiningFace: function (eyeVertex, horizonEdge) {\n                var face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n                this.faces.push(face);\n                face.getEdge(-1).setTwin(horizonEdge.twin);\n                return face.getEdge(0);\n            },\n            addNewFaces: function (eyeVertex, horizon) {\n                this.newFaces = [];\n                var firstSideEdge = null;\n                var previousSideEdge = null;\n                for (var i = 0; i < horizon.length; i++) {\n                    var horizonEdge = horizon[i];\n                    var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n                    if (firstSideEdge === null) {\n                        firstSideEdge = sideEdge;\n                    } else {\n                        sideEdge.next.setTwin(previousSideEdge);\n                    }\n                    this.newFaces.push(sideEdge.face);\n                    previousSideEdge = sideEdge;\n                }\n                firstSideEdge.next.setTwin(previousSideEdge);\n                return this;\n            },\n            addVertexToHull: function (eyeVertex) {\n                var horizon = [];\n                this.unassigned.clear();\n                this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n                this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n                this.addNewFaces(eyeVertex, horizon);\n                this.resolveUnassignedPoints(this.newFaces);\n                return this;\n            },\n            cleanup: function () {\n                this.assigned.clear();\n                this.unassigned.clear();\n                this.newFaces = [];\n                return this;\n            },\n            compute: function () {\n                var vertex;\n                this.computeInitialHull();\n                while ((vertex = this.nextVertexToAdd()) !== undefined) {\n                    this.addVertexToHull(vertex);\n                }\n                this.reindexFaces();\n                this.cleanup();\n                return this;\n            }\n        });\n        function Face() {\n            this.normal = new THREE.Vector3();\n            this.midpoint = new THREE.Vector3();\n            this.area = 0;\n            this.constant = 0;\n            this.outside = null;\n            this.mark = Visible;\n            this.edge = null;\n        }\n        Object.assign(Face, {\n            create: function (a, b, c) {\n                var face = new Face();\n                var e0 = new HalfEdge(a, face);\n                var e1 = new HalfEdge(b, face);\n                var e2 = new HalfEdge(c, face);\n                e0.next = e2.prev = e1;\n                e1.next = e0.prev = e2;\n                e2.next = e1.prev = e0;\n                face.edge = e0;\n                return face.compute();\n            }\n        });\n        Object.assign(Face.prototype, {\n            getEdge: function (i) {\n                var edge = this.edge;\n                while (i > 0) {\n                    edge = edge.next;\n                    i--;\n                }\n                while (i < 0) {\n                    edge = edge.prev;\n                    i++;\n                }\n                return edge;\n            },\n            compute: function () {\n                var triangle;\n                return function compute() {\n                    if (triangle === undefined)\n                        triangle = new THREE.Triangle();\n                    var a = this.edge.tail();\n                    var b = this.edge.head();\n                    var c = this.edge.next.head();\n                    triangle.set(a.point, b.point, c.point);\n                    triangle.getNormal(this.normal);\n                    triangle.getMidpoint(this.midpoint);\n                    this.area = triangle.getArea();\n                    this.constant = this.normal.dot(this.midpoint);\n                    return this;\n                };\n            }(),\n            distanceToPoint: function (point) {\n                return this.normal.dot(point) - this.constant;\n            }\n        });\n        function HalfEdge(vertex, face) {\n            this.vertex = vertex;\n            this.prev = null;\n            this.next = null;\n            this.twin = null;\n            this.face = face;\n        }\n        Object.assign(HalfEdge.prototype, {\n            head: function () {\n                return this.vertex;\n            },\n            tail: function () {\n                return this.prev ? this.prev.vertex : null;\n            },\n            length: function () {\n                var head = this.head();\n                var tail = this.tail();\n                if (tail !== null) {\n                    return tail.point.distanceTo(head.point);\n                }\n                return -1;\n            },\n            lengthSquared: function () {\n                var head = this.head();\n                var tail = this.tail();\n                if (tail !== null) {\n                    return tail.point.distanceToSquared(head.point);\n                }\n                return -1;\n            },\n            setTwin: function (edge) {\n                this.twin = edge;\n                edge.twin = this;\n                return this;\n            }\n        });\n        function VertexNode(point) {\n            this.point = point;\n            this.prev = null;\n            this.next = null;\n            this.face = null;\n        }\n        function VertexList() {\n            this.head = null;\n            this.tail = null;\n        }\n        Object.assign(VertexList.prototype, {\n            first: function () {\n                return this.head;\n            },\n            last: function () {\n                return this.tail;\n            },\n            clear: function () {\n                this.head = this.tail = null;\n                return this;\n            },\n            insertBefore: function (target, vertex) {\n                vertex.prev = target.prev;\n                vertex.next = target;\n                if (vertex.prev === null) {\n                    this.head = vertex;\n                } else {\n                    vertex.prev.next = vertex;\n                }\n                target.prev = vertex;\n                return this;\n            },\n            insertAfter: function (target, vertex) {\n                vertex.prev = target;\n                vertex.next = target.next;\n                if (vertex.next === null) {\n                    this.tail = vertex;\n                } else {\n                    vertex.next.prev = vertex;\n                }\n                target.next = vertex;\n                return this;\n            },\n            append: function (vertex) {\n                if (this.head === null) {\n                    this.head = vertex;\n                } else {\n                    this.tail.next = vertex;\n                }\n                vertex.prev = this.tail;\n                vertex.next = null;\n                this.tail = vertex;\n                return this;\n            },\n            appendChain: function (vertex) {\n                if (this.head === null) {\n                    this.head = vertex;\n                } else {\n                    this.tail.next = vertex;\n                }\n                vertex.prev = this.tail;\n                while (vertex.next !== null) {\n                    vertex = vertex.next;\n                }\n                this.tail = vertex;\n                return this;\n            },\n            remove: function (vertex) {\n                if (vertex.prev === null) {\n                    this.head = vertex.next;\n                } else {\n                    vertex.prev.next = vertex.next;\n                }\n                if (vertex.next === null) {\n                    this.tail = vertex.prev;\n                } else {\n                    vertex.next.prev = vertex.prev;\n                }\n                return this;\n            },\n            removeSubList: function (a, b) {\n                if (a.prev === null) {\n                    this.head = b.next;\n                } else {\n                    a.prev.next = b.next;\n                }\n                if (b.next === null) {\n                    this.tail = a.prev;\n                } else {\n                    b.next.prev = a.prev;\n                }\n                return this;\n            },\n            isEmpty: function () {\n                return this.head === null;\n            }\n        });\n        return ConvexHull;\n    }();\n\n    return ConvexHull;\n});"]}