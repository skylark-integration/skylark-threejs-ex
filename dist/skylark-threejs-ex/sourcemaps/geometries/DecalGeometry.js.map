{"version":3,"sources":["geometries/DecalGeometry.js"],"names":["define","THREE","DecalGeometry","mesh","position","orientation","size","BufferGeometry","call","this","vertices","normals","uvs","plane","Vector3","projectorMatrix","Matrix4","makeRotationFromEuler","setPosition","projectorMatrixInverse","getInverse","pushDecalVertex","decalVertices","vertex","normal","applyMatrix4","matrixWorld","transformDirection","push","DecalVertex","clone","clipGeometry","inVertices","outVertices","s","Math","abs","dot","i","length","v1Out","v2Out","v3Out","nV1","nV2","nV3","nV4","d1","clip","v0","v1","p","d0","s0","x","y","z","geometry","isGeometry","fromGeometry","copy","positionAttribute","attributes","normalAttribute","index","count","fromBufferAttribute","getX","set","decalVertex","generate","setAttribute","Float32BufferAttribute","prototype","Object","create","constructor"],"mappings":"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","file":"../../geometries/DecalGeometry.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var DecalGeometry = function (mesh, position, orientation, size) {\n        THREE.BufferGeometry.call(this);\n        var vertices = [];\n        var normals = [];\n        var uvs = [];\n        var plane = new THREE.Vector3();\n        var projectorMatrix = new THREE.Matrix4();\n        projectorMatrix.makeRotationFromEuler(orientation);\n        projectorMatrix.setPosition(position);\n        var projectorMatrixInverse = new THREE.Matrix4().getInverse(projectorMatrix);\n        generate();\n        this.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n        this.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n        this.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\n        function generate() {\n            var i;\n            var geometry = new THREE.BufferGeometry();\n            var decalVertices = [];\n            var vertex = new THREE.Vector3();\n            var normal = new THREE.Vector3();\n            if (mesh.geometry.isGeometry) {\n                geometry.fromGeometry(mesh.geometry);\n            } else {\n                geometry.copy(mesh.geometry);\n            }\n            var positionAttribute = geometry.attributes.position;\n            var normalAttribute = geometry.attributes.normal;\n            if (geometry.index !== null) {\n                var index = geometry.index;\n                for (i = 0; i < index.count; i++) {\n                    vertex.fromBufferAttribute(positionAttribute, index.getX(i));\n                    normal.fromBufferAttribute(normalAttribute, index.getX(i));\n                    pushDecalVertex(decalVertices, vertex, normal);\n                }\n            } else {\n                for (i = 0; i < positionAttribute.count; i++) {\n                    vertex.fromBufferAttribute(positionAttribute, i);\n                    normal.fromBufferAttribute(normalAttribute, i);\n                    pushDecalVertex(decalVertices, vertex, normal);\n                }\n            }\n            decalVertices = clipGeometry(decalVertices, plane.set(1, 0, 0));\n            decalVertices = clipGeometry(decalVertices, plane.set(-1, 0, 0));\n            decalVertices = clipGeometry(decalVertices, plane.set(0, 1, 0));\n            decalVertices = clipGeometry(decalVertices, plane.set(0, -1, 0));\n            decalVertices = clipGeometry(decalVertices, plane.set(0, 0, 1));\n            decalVertices = clipGeometry(decalVertices, plane.set(0, 0, -1));\n            for (i = 0; i < decalVertices.length; i++) {\n                var decalVertex = decalVertices[i];\n                uvs.push(0.5 + decalVertex.position.x / size.x, 0.5 + decalVertex.position.y / size.y);\n                decalVertex.position.applyMatrix4(projectorMatrix);\n                vertices.push(decalVertex.position.x, decalVertex.position.y, decalVertex.position.z);\n                normals.push(decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z);\n            }\n        }\n        function pushDecalVertex(decalVertices, vertex, normal) {\n            vertex.applyMatrix4(mesh.matrixWorld);\n            vertex.applyMatrix4(projectorMatrixInverse);\n            normal.transformDirection(mesh.matrixWorld);\n            decalVertices.push(new DecalVertex(vertex.clone(), normal.clone()));\n        }\n        function clipGeometry(inVertices, plane) {\n            var outVertices = [];\n            var s = 0.5 * Math.abs(size.dot(plane));\n            for (var i = 0; i < inVertices.length; i += 3) {\n                var v1Out, v2Out, v3Out, total = 0;\n                var nV1, nV2, nV3, nV4;\n                var d1 = inVertices[i + 0].position.dot(plane) - s;\n                var d2 = inVertices[i + 1].position.dot(plane) - s;\n                var d3 = inVertices[i + 2].position.dot(plane) - s;\n                v1Out = d1 > 0;\n                v2Out = d2 > 0;\n                v3Out = d3 > 0;\n                total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n                switch (total) {\n                case 0: {\n                        outVertices.push(inVertices[i]);\n                        outVertices.push(inVertices[i + 1]);\n                        outVertices.push(inVertices[i + 2]);\n                        break;\n                    }\n                case 1: {\n                        if (v1Out) {\n                            nV1 = inVertices[i + 1];\n                            nV2 = inVertices[i + 2];\n                            nV3 = clip(inVertices[i], nV1, plane, s);\n                            nV4 = clip(inVertices[i], nV2, plane, s);\n                        }\n                        if (v2Out) {\n                            nV1 = inVertices[i];\n                            nV2 = inVertices[i + 2];\n                            nV3 = clip(inVertices[i + 1], nV1, plane, s);\n                            nV4 = clip(inVertices[i + 1], nV2, plane, s);\n                            outVertices.push(nV3);\n                            outVertices.push(nV2.clone());\n                            outVertices.push(nV1.clone());\n                            outVertices.push(nV2.clone());\n                            outVertices.push(nV3.clone());\n                            outVertices.push(nV4);\n                            break;\n                        }\n                        if (v3Out) {\n                            nV1 = inVertices[i];\n                            nV2 = inVertices[i + 1];\n                            nV3 = clip(inVertices[i + 2], nV1, plane, s);\n                            nV4 = clip(inVertices[i + 2], nV2, plane, s);\n                        }\n                        outVertices.push(nV1.clone());\n                        outVertices.push(nV2.clone());\n                        outVertices.push(nV3);\n                        outVertices.push(nV4);\n                        outVertices.push(nV3.clone());\n                        outVertices.push(nV2.clone());\n                        break;\n                    }\n                case 2: {\n                        if (!v1Out) {\n                            nV1 = inVertices[i].clone();\n                            nV2 = clip(nV1, inVertices[i + 1], plane, s);\n                            nV3 = clip(nV1, inVertices[i + 2], plane, s);\n                            outVertices.push(nV1);\n                            outVertices.push(nV2);\n                            outVertices.push(nV3);\n                        }\n                        if (!v2Out) {\n                            nV1 = inVertices[i + 1].clone();\n                            nV2 = clip(nV1, inVertices[i + 2], plane, s);\n                            nV3 = clip(nV1, inVertices[i], plane, s);\n                            outVertices.push(nV1);\n                            outVertices.push(nV2);\n                            outVertices.push(nV3);\n                        }\n                        if (!v3Out) {\n                            nV1 = inVertices[i + 2].clone();\n                            nV2 = clip(nV1, inVertices[i], plane, s);\n                            nV3 = clip(nV1, inVertices[i + 1], plane, s);\n                            outVertices.push(nV1);\n                            outVertices.push(nV2);\n                            outVertices.push(nV3);\n                        }\n                        break;\n                    }\n                case 3: {\n                        break;\n                    }\n                }\n            }\n            return outVertices;\n        }\n        function clip(v0, v1, p, s) {\n            var d0 = v0.position.dot(p) - s;\n            var d1 = v1.position.dot(p) - s;\n            var s0 = d0 / (d0 - d1);\n            var v = new DecalVertex(new THREE.Vector3(v0.position.x + s0 * (v1.position.x - v0.position.x), v0.position.y + s0 * (v1.position.y - v0.position.y), v0.position.z + s0 * (v1.position.z - v0.position.z)), new THREE.Vector3(v0.normal.x + s0 * (v1.normal.x - v0.normal.x), v0.normal.y + s0 * (v1.normal.y - v0.normal.y), v0.normal.z + s0 * (v1.normal.z - v0.normal.z)));\n            return v;\n        }\n    };\n    DecalGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);\n    DecalGeometry.prototype.constructor = DecalGeometry;\n    return DecalGeometry;\n});"]}