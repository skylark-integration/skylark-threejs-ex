{"version":3,"sources":["geometries/DecalGeometry.js"],"names":["define","THREE","DecalGeometry","mesh","position","orientation","size","BufferGeometry","call","this","vertices","normals","uvs","plane","Vector3","projectorMatrix","Matrix4","makeRotationFromEuler","setPosition","projectorMatrixInverse","getInverse","pushDecalVertex","decalVertices","vertex","normal","applyMatrix4","matrixWorld","transformDirection","push","DecalVertex","clone","clipGeometry","inVertices","outVertices","s","Math","abs","dot","i","length","v1Out","v2Out","v3Out","nV1","nV2","nV3","nV4","d1","clip","v0","v1","p","d0","s0","x","y","z","geometry","isGeometry","fromGeometry","copy","positionAttribute","attributes","normalAttribute","index","count","fromBufferAttribute","getX","set","decalVertex","generate","setAttribute","Float32BufferAttribute","prototype","Object","create","constructor"],"mappings":"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","file":"../../geometries/DecalGeometry.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t * @author spite / https://github.com/spite\n\t *\n\t * You can use this geometry to create a decal mesh, that serves different kinds of purposes.\n\t * e.g. adding unique details to models, performing dynamic visual environmental changes or covering seams.\n\t *\n\t * Constructor parameter:\n\t *\n\t * mesh — Any mesh object\n\t * position — Position of the decal projector\n\t * orientation — Orientation of the decal projector\n\t * size — Size of the decal projector\n\t *\n\t * reference: http://blog.wolfire.com/2009/06/how-to-project-decals/\n\t *\n\t */\n\n\tTHREE.DecalGeometry = function ( mesh, position, orientation, size ) {\n\n\t\tTHREE.BufferGeometry.call( this );\n\n\t\t// buffers\n\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n\n\t\t// helpers\n\n\t\tvar plane = new THREE.Vector3();\n\n\t\t// this matrix represents the transformation of the decal projector\n\n\t\tvar projectorMatrix = new THREE.Matrix4();\n\t\tprojectorMatrix.makeRotationFromEuler( orientation );\n\t\tprojectorMatrix.setPosition( position );\n\n\t\tvar projectorMatrixInverse = new THREE.Matrix4().getInverse( projectorMatrix );\n\n\t\t// generate buffers\n\n\t\tgenerate();\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction generate() {\n\n\t\t\tvar i;\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\tvar decalVertices = [];\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvar normal = new THREE.Vector3();\n\n\t\t\t// handle different geometry types\n\n\t\t\tif ( mesh.geometry.isGeometry ) {\n\n\t\t\t\tgeometry.fromGeometry( mesh.geometry );\n\n\t\t\t} else {\n\n\t\t\t\tgeometry.copy( mesh.geometry );\n\n\t\t\t}\n\n\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\tvar normalAttribute = geometry.attributes.normal;\n\n\t\t\t// first, create an array of 'DecalVertex' objects\n\t\t\t// three consecutive 'DecalVertex' objects represent a single face\n\t\t\t//\n\t\t\t// this data structure will be later used to perform the clipping\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// indexed BufferGeometry\n\n\t\t\t\tvar index = geometry.index;\n\n\t\t\t\tfor ( i = 0; i < index.count; i ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( positionAttribute, index.getX( i ) );\n\t\t\t\t\tnormal.fromBufferAttribute( normalAttribute, index.getX( i ) );\n\n\t\t\t\t\tpushDecalVertex( decalVertices, vertex, normal );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tfor ( i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\t\t\tvertex.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t\tnormal.fromBufferAttribute( normalAttribute, i );\n\n\t\t\t\t\tpushDecalVertex( decalVertices, vertex, normal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// second, clip the geometry so that it doesn't extend out from the projector\n\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 1, 0, 0 ) );\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( - 1, 0, 0 ) );\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, 1, 0 ) );\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, - 1, 0 ) );\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, 0, 1 ) );\n\t\t\tdecalVertices = clipGeometry( decalVertices, plane.set( 0, 0, - 1 ) );\n\n\t\t\t// third, generate final vertices, normals and uvs\n\n\t\t\tfor ( i = 0; i < decalVertices.length; i ++ ) {\n\n\t\t\t\tvar decalVertex = decalVertices[ i ];\n\n\t\t\t\t// create texture coordinates (we are still in projector space)\n\n\t\t\t\tuvs.push(\n\t\t\t\t\t0.5 + ( decalVertex.position.x / size.x ),\n\t\t\t\t\t0.5 + ( decalVertex.position.y / size.y )\n\t\t\t\t);\n\n\t\t\t\t// transform the vertex back to world space\n\n\t\t\t\tdecalVertex.position.applyMatrix4( projectorMatrix );\n\n\t\t\t\t// now create vertex and normal buffer data\n\n\t\t\t\tvertices.push( decalVertex.position.x, decalVertex.position.y, decalVertex.position.z );\n\t\t\t\tnormals.push( decalVertex.normal.x, decalVertex.normal.y, decalVertex.normal.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushDecalVertex( decalVertices, vertex, normal ) {\n\n\t\t\t// transform the vertex to world space, then to projector space\n\n\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\t\t\tvertex.applyMatrix4( projectorMatrixInverse );\n\n\t\t\tnormal.transformDirection( mesh.matrixWorld );\n\n\t\t\tdecalVertices.push( new THREE.DecalVertex( vertex.clone(), normal.clone() ) );\n\n\t\t}\n\n\t\tfunction clipGeometry( inVertices, plane ) {\n\n\t\t\tvar outVertices = [];\n\n\t\t\tvar s = 0.5 * Math.abs( size.dot( plane ) );\n\n\t\t\t// a single iteration clips one face,\n\t\t\t// which consists of three consecutive 'DecalVertex' objects\n\n\t\t\tfor ( var i = 0; i < inVertices.length; i += 3 ) {\n\n\t\t\t\tvar v1Out, v2Out, v3Out, total = 0;\n\t\t\t\tvar nV1, nV2, nV3, nV4;\n\n\t\t\t\tvar d1 = inVertices[ i + 0 ].position.dot( plane ) - s;\n\t\t\t\tvar d2 = inVertices[ i + 1 ].position.dot( plane ) - s;\n\t\t\t\tvar d3 = inVertices[ i + 2 ].position.dot( plane ) - s;\n\n\t\t\t\tv1Out = d1 > 0;\n\t\t\t\tv2Out = d2 > 0;\n\t\t\t\tv3Out = d3 > 0;\n\n\t\t\t\t// calculate, how many vertices of the face lie outside of the clipping plane\n\n\t\t\t\ttotal = ( v1Out ? 1 : 0 ) + ( v2Out ? 1 : 0 ) + ( v3Out ? 1 : 0 );\n\n\t\t\t\tswitch ( total ) {\n\n\t\t\t\t\tcase 0: {\n\n\t\t\t\t\t\t// the entire face lies inside of the plane, no clipping needed\n\n\t\t\t\t\t\toutVertices.push( inVertices[ i ] );\n\t\t\t\t\t\toutVertices.push( inVertices[ i + 1 ] );\n\t\t\t\t\t\toutVertices.push( inVertices[ i + 2 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 1: {\n\n\t\t\t\t\t\t// one vertex lies outside of the plane, perform clipping\n\n\t\t\t\t\t\tif ( v1Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i + 1 ];\n\t\t\t\t\t\t\tnV2 = inVertices[ i + 2 ];\n\t\t\t\t\t\t\tnV3 = clip( inVertices[ i ], nV1, plane, s );\n\t\t\t\t\t\t\tnV4 = clip( inVertices[ i ], nV2, plane, s );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( v2Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i ];\n\t\t\t\t\t\t\tnV2 = inVertices[ i + 2 ];\n\t\t\t\t\t\t\tnV3 = clip( inVertices[ i + 1 ], nV1, plane, s );\n\t\t\t\t\t\t\tnV4 = clip( inVertices[ i + 1 ], nV2, plane, s );\n\n\t\t\t\t\t\t\toutVertices.push( nV3 );\n\t\t\t\t\t\t\toutVertices.push( nV2.clone() );\n\t\t\t\t\t\t\toutVertices.push( nV1.clone() );\n\n\t\t\t\t\t\t\toutVertices.push( nV2.clone() );\n\t\t\t\t\t\t\toutVertices.push( nV3.clone() );\n\t\t\t\t\t\t\toutVertices.push( nV4 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( v3Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i ];\n\t\t\t\t\t\t\tnV2 = inVertices[ i + 1 ];\n\t\t\t\t\t\t\tnV3 = clip( inVertices[ i + 2 ], nV1, plane, s );\n\t\t\t\t\t\t\tnV4 = clip( inVertices[ i + 2 ], nV2, plane, s );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toutVertices.push( nV1.clone() );\n\t\t\t\t\t\toutVertices.push( nV2.clone() );\n\t\t\t\t\t\toutVertices.push( nV3 );\n\n\t\t\t\t\t\toutVertices.push( nV4 );\n\t\t\t\t\t\toutVertices.push( nV3.clone() );\n\t\t\t\t\t\toutVertices.push( nV2.clone() );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 2: {\n\n\t\t\t\t\t\t// two vertices lies outside of the plane, perform clipping\n\n\t\t\t\t\t\tif ( ! v1Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i ].clone();\n\t\t\t\t\t\t\tnV2 = clip( nV1, inVertices[ i + 1 ], plane, s );\n\t\t\t\t\t\t\tnV3 = clip( nV1, inVertices[ i + 2 ], plane, s );\n\t\t\t\t\t\t\toutVertices.push( nV1 );\n\t\t\t\t\t\t\toutVertices.push( nV2 );\n\t\t\t\t\t\t\toutVertices.push( nV3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! v2Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i + 1 ].clone();\n\t\t\t\t\t\t\tnV2 = clip( nV1, inVertices[ i + 2 ], plane, s );\n\t\t\t\t\t\t\tnV3 = clip( nV1, inVertices[ i ], plane, s );\n\t\t\t\t\t\t\toutVertices.push( nV1 );\n\t\t\t\t\t\t\toutVertices.push( nV2 );\n\t\t\t\t\t\t\toutVertices.push( nV3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! v3Out ) {\n\n\t\t\t\t\t\t\tnV1 = inVertices[ i + 2 ].clone();\n\t\t\t\t\t\t\tnV2 = clip( nV1, inVertices[ i ], plane, s );\n\t\t\t\t\t\t\tnV3 = clip( nV1, inVertices[ i + 1 ], plane, s );\n\t\t\t\t\t\t\toutVertices.push( nV1 );\n\t\t\t\t\t\t\toutVertices.push( nV2 );\n\t\t\t\t\t\t\toutVertices.push( nV3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 3: {\n\n\t\t\t\t\t\t// the entire face lies outside of the plane, so let's discard the corresponding vertices\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn outVertices;\n\n\t\t}\n\n\t\tfunction clip( v0, v1, p, s ) {\n\n\t\t\tvar d0 = v0.position.dot( p ) - s;\n\t\t\tvar d1 = v1.position.dot( p ) - s;\n\n\t\t\tvar s0 = d0 / ( d0 - d1 );\n\n\t\t\tvar v = new THREE.DecalVertex(\n\t\t\t\tnew THREE.Vector3(\n\t\t\t\t\tv0.position.x + s0 * ( v1.position.x - v0.position.x ),\n\t\t\t\t\tv0.position.y + s0 * ( v1.position.y - v0.position.y ),\n\t\t\t\t\tv0.position.z + s0 * ( v1.position.z - v0.position.z )\n\t\t\t\t),\n\t\t\t\tnew THREE.Vector3(\n\t\t\t\t\tv0.normal.x + s0 * ( v1.normal.x - v0.normal.x ),\n\t\t\t\t\tv0.normal.y + s0 * ( v1.normal.y - v0.normal.y ),\n\t\t\t\t\tv0.normal.z + s0 * ( v1.normal.z - v0.normal.z )\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// need to clip more values (texture coordinates)? do it this way:\n\t\t\t// intersectpoint.value = a.value + s * ( b.value - a.value );\n\n\t\t\treturn v;\n\n\t\t}\n\n\t};\n\n\tTHREE.DecalGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tTHREE.DecalGeometry.prototype.constructor = THREE.DecalGeometry;\n\n\t// helper\n\n\tTHREE.DecalVertex = function ( position, normal ) {\n\n\t\tthis.position = position;\n\t\tthis.normal = normal;\n\n\t};\n\n\tTHREE.DecalVertex.prototype.clone = function () {\n\n\t\treturn new this.constructor( this.position.clone(), this.normal.clone() );\n\n\t};\n\t\n\treturn THREE.DecalGeometry;\n});\n"]}