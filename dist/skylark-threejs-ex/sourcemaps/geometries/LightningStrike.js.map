{"version":3,"sources":["geometries/LightningStrike.js"],"names":["define","THREE","LightningStrike","rayParameters","BufferGeometry","call","this","type","init","copyParameters","createMesh","prototype","Object","create","constructor","isLightningStrike","RAY_INITIALIZED","RAY_UNBORN","RAY_PROPAGATING","RAY_STEADY","RAY_VANISHING","RAY_EXTINGUISHED","COS30DEG","Math","cos","PI","SIN30DEG","sin","createRandomGenerator","seeds","i","push","random","generator","currentSeed","value","getSeed","setSeed","seed","floor","dest","source","vecCopy","v","clone","sourceOffset","undefined","Vector3","destOffset","timeScale","roughness","straightness","up0","up1","radius0","radius1","radius0Factor","radius1Factor","minRadius","isEternal","birthTime","deathTime","propagationTimeFactor","vanishingTimeFactor","subrayPeriod","subrayDutyCycle","maxIterations","isStatic","ramification","maxSubrayRecursion","recursionProbability","generateUVs","randomGenerator","noiseSeed","onDecideSubrayCreation","onSubrayCreation","update","time","updateMesh","subrays","endPropagationTime","state","beginVanishingTime","visible","seedGenerator","createDefaultSubrayCreationCallbacks","maxSubrays","ceil","pow","max","maxRaySegments","createSubray","raySegments","createSegment","timeFraction","currentSegmentCallback","currentCreateTriangleVertices","createTriangleVerticesWithUVs","createTriangleVerticesWithoutUVs","numSubrays","currentSubray","currentSegmentIndex","isInitialSegment","subrayProbability","currentVertex","currentIndex","currentCoordinate","currentUVCoordinate","vertices","uvs","indices","positionAttribute","uvsAttribute","simplexX","SimplexNoise","simplexY","simplexZ","forwards","forwardsFill","side","down","middlePos","middleLinPos","newPos","vPos","cross1","maxDrawableSegmentsPerSubRay","maxVerts","maxIndices","Float32Array","Uint32Array","fillMesh","setIndex","Uint32BufferAttribute","Float32BufferAttribute","setAttribute","index","usage","DynamicDrawUsage","array","drawRange","count","needsUpdate","scope","fractalRay","segment","subray","recursion","createPrism","fraction0","fraction1","addNewSubray","initSubray","pos0","copy","pos1","segmentCallback","subrayIndex","MathUtils","lerp","random1","linPos0","set","multiplyScalar","linPos1","getNewSegment","iteration","positionVariationFactor","fractalRayRecursive","subVectors","lForwards","length","middleRadius","middleFraction","timeDimension","lerpVectors","p","noise4d","x","y","z","add","newSegment1","newSegment2","crossVectors","normalize","createPrismFaces","pos","up","radius","sub","u","uv","vertex","lightningStrike","period","dutyCycle","phase0","phase","currentCycle","childSubraySeed","probability","childSubray","parentSeed","min","vec1Pos","vec2Forward","vec3Side","vec4Up","parentSubray","subrayCylinderPosition","subrayConePosition","heightFactor","sideWidthFactor","minSideWidthFactor","angle"],"mappings":"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","file":"../../geometries/LightningStrike.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"../math/SimplexNoise\"\n],function(THREE){\n\t/**\n\t * @author yomboprime https://github.com/yomboprime\n\t *\n\t * @fileoverview LightningStrike object for creating lightning strikes and voltaic arcs.\n\t *\n\t *\n\t * Usage\n\t *\n\t * var myRay = new THREE.LightningStrike( paramsObject );\n\t * var myRayMesh = new THREE.Mesh( myRay, myMaterial );\n\t * scene.add( myRayMesh );\n\t * ...\n\t * myRay.update( currentTime );\n\t *\n\t * The \"currentTime\" can vary its rate, go forwards, backwards or even jump, but it cannot be negative.\n\t *\n\t * You should normally leave the ray position to (0, 0, 0). You should control it by changing the sourceOffset and destOffset parameters.\n\t *\n\t *\n\t * LightningStrike parameters\n\t *\n\t * The paramsObject can contain any of the following parameters.\n\t *\n\t * Legend:\n\t * 'LightningStrike' (also called 'ray'): An independent voltaic arc with its ramifications and defined with a set of parameters.\n\t * 'Subray': A ramification of the ray. It is not a LightningStrike object.\n\t * 'Segment': A linear segment piece of a subray.\n\t * 'Leaf segment': A ray segment which cannot be smaller.\n\t *\n\t *\n\t * The following parameters can be changed any time and if they vary smoothly, the ray form will also change smoothly:\n\t *\n\t * @param {Vector3} sourceOffset The point where the ray starts.\n\t *\n\t * @param {Vector3} destOffset The point where the ray ends.\n\t *\n\t * @param {double} timeScale The rate at wich the ray form changes in time. Default: 1\n\t *\n\t * @param {double} roughness From 0 to 1. The higher the value, the more wrinkled is the ray. Default: 0.9\n\t *\n\t * @param {double} straightness From 0 to 1. The higher the value, the more straight will be a subray path. Default: 0.7\n\t *\n\t * @param {Vector3} up0 Ray 'up' direction at the ray starting point. Must be normalized. It should be perpendicular to the ray forward direction but it doesn't matter much.\n\t *\n\t * @param {Vector3} up1 Like the up0 parameter but at the end of the ray. Must be normalized.\n\t *\n\t * @param {double} radius0 Radius of the main ray trunk at the start point. Default: 1\n\t *\n\t * @param {double} radius1 Radius of the main ray trunk at the end point. Default: 1\n\t *\n\t * @param {double} radius0Factor The radius0 of a subray is this factor times the radius0 of its parent subray. Default: 0.5\n\t *\n\t * @param {double} radius1Factor The radius1 of a subray is this factor times the radius1 of its parent subray. Default: 0.2\n\t *\n\t * @param {minRadius} Minimum value a subray radius0 or radius1 can get. Default: 0.1\n\t *\n\t *\n\t * The following parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n\t *\n\t * @param {boolean} isEternal If true the ray never extinguishes. Otherwise its life is controlled by the 'birthTime' and 'deathTime' parameters. Default: true if any of those two parameters is undefined.\n\t *\n\t * @param {double} birthTime The time at which the ray starts its life and begins propagating. Only if isEternal is false. Default: None.\n\t *\n\t * @param {double} deathTime The time at which the ray ends vanishing and its life. Only if isEternal is false. Default: None.\n\t *\n\t * @param {double} propagationTimeFactor From 0 to 1. Lifetime factor at which the ray ends propagating and enters the steady phase. For example, 0.1 means it is propagating 1/10 of its lifetime. Default: 0.1\n\t *\n\t * @param {double} vanishingTimeFactor From 0 to 1. Lifetime factor at which the ray ends the steady phase and begins vanishing. For example, 0.9 means it is vanishing 1/10 of its lifetime. Default: 0.9\n\t *\n\t * @param {double} subrayPeriod Subrays cycle periodically. This is their time period. Default: 4\n\t *\n\t * @param {double} subrayDutyCycle From 0 to 1. This is the fraction of time a subray is active. Default: 0.6\n\t *\n\t *\n\t * These parameters cannot change after lightning creation:\n\t *\n\t * @param {integer} maxIterations: Greater than 0. The number of ray's leaf segments is 2**maxIterations. Default: 9\n\t *\n\t * @param {boolean} isStatic Set to true only for rays which won't change over time and are not attached to moving objects (Rare case). It is used to set the vertex buffers non-dynamic. You can omit calling update() for these rays.\n\t *\n\t * @param {integer} ramification Greater than 0. Maximum number of child subrays a subray can have. Default: 5\n\t *\n\t * @param {integer} maxSubrayRecursion Greater than 0. Maximum level of recursion (subray descendant generations). Default: 3\n\t *\n\t * @param {double} recursionProbability From 0 to 1. The lower the value, the less chance each new generation of subrays has to generate new subrays. Default: 0.6\n\t *\n\t * @param {boolean} generateUVs If true, the ray geometry will have uv coordinates generated. u runs along the ray, and v across its perimeter. Default: false.\n\t *\n\t * @param {Object} randomGenerator Set here your random number generator which will seed the SimplexNoise and other decisions during ray tree creation.\n\t * It can be used to generate repeatable rays. For that, set also the noiseSeed parameter, and each ray created with that generator and seed pair will be identical in time.\n\t * The randomGenerator parameter should be an object with a random() function similar to Math.random, but seedable.\n\t * It must have also a getSeed() method, which returns the current seed, and a setSeed( seed ) method, which accepts as seed a fractional number from 0 to 1, as well as any other number.\n\t * The default value is an internal generator for some uses and Math.random for others (It is non-repeatable even if noiseSeed is supplied)\n\t *\n\t * @param {double} noiseSeed Seed used to make repeatable rays (see the randomGenerator)\n\t *\n\t * @param {function} onDecideSubrayCreation Set this to change the callback which decides subray creation. You can look at the default callback in the code (createDefaultSubrayCreationCallbacks)for more info.\n\t *\n\t * @param {function} onSubrayCreation This is another callback, more simple than the previous one. It can be used to adapt the form of subrays or other parameters once a subray has been created and initialized. It is used in the examples to adapt subrays to a sphere or to a plane.\n\t *\n\t *\n\t*/\n\n\tTHREE.LightningStrike = function ( rayParameters ) {\n\n\t\tTHREE.BufferGeometry.call( this );\n\n\t\tthis.type = 'LightningStrike';\n\n\t\t// Set parameters, and set undefined parameters to default values\n\t\trayParameters = rayParameters || {};\n\t\tthis.init( THREE.LightningStrike.copyParameters( rayParameters, rayParameters ) );\n\n\t\t// Creates and populates the mesh\n\t\tthis.createMesh();\n\n\t};\n\n\tTHREE.LightningStrike.prototype = Object.create( THREE.BufferGeometry.prototype );\n\n\tTHREE.LightningStrike.prototype.constructor = THREE.LightningStrike;\n\n\tTHREE.LightningStrike.prototype.isLightningStrike = true;\n\n\t// Ray states\n\tTHREE.LightningStrike.RAY_INITIALIZED = 0;\n\tTHREE.LightningStrike.RAY_UNBORN = 1;\n\tTHREE.LightningStrike.RAY_PROPAGATING = 2;\n\tTHREE.LightningStrike.RAY_STEADY = 3;\n\tTHREE.LightningStrike.RAY_VANISHING = 4;\n\tTHREE.LightningStrike.RAY_EXTINGUISHED = 5;\n\n\tTHREE.LightningStrike.COS30DEG = Math.cos( 30 * Math.PI / 180 );\n\tTHREE.LightningStrike.SIN30DEG = Math.sin( 30 * Math.PI / 180 );\n\n\tTHREE.LightningStrike.createRandomGenerator = function () {\n\n\t\tvar numSeeds = 2053;\n\t\tvar seeds = [];\n\n\t\tfor ( var i = 0; i < numSeeds; i ++ ) {\n\n\t\t\tseeds.push( Math.random() );\n\n\t\t}\n\n\t\tvar generator = {\n\n\t\t\tcurrentSeed: 0,\n\n\t\t\trandom: function () {\n\n\t\t\t\tvar value = seeds[ generator.currentSeed ];\n\n\t\t\t\tgenerator.currentSeed = ( generator.currentSeed + 1 ) % numSeeds;\n\n\t\t\t\treturn value;\n\n\t\t\t},\n\n\t\t\tgetSeed: function () {\n\n\t\t\t\treturn generator.currentSeed / numSeeds;\n\n\t\t\t},\n\n\t\t\tsetSeed: function ( seed ) {\n\n\t\t\t\tgenerator.currentSeed = Math.floor( seed * numSeeds ) % numSeeds;\n\n\t\t\t}\n\n\t\t};\n\n\t\treturn generator;\n\n\t};\n\n\tTHREE.LightningStrike.copyParameters = function ( dest, source ) {\n\n\t\tsource = source || {};\n\t\tdest = dest || {};\n\n\t\tvar vecCopy = function ( v ) {\n\n\t\t\tif ( source === dest ) {\n\n\t\t\t\treturn v;\n\n\t\t\t} else {\n\n\t\t\t\treturn v.clone();\n\n\t\t\t}\n\n\t\t};\n\n\t\tdest.sourceOffset = source.sourceOffset !== undefined ? vecCopy( source.sourceOffset ) : new THREE.Vector3( 0, 100, 0 ),\n\t\tdest.destOffset = source.destOffset !== undefined ? vecCopy( source.destOffset ) : new THREE.Vector3( 0, 0, 0 ),\n\n\t\tdest.timeScale = source.timeScale !== undefined ? source.timeScale : 1,\n\t\tdest.roughness = source.roughness !== undefined ? source.roughness : 0.9,\n\t\tdest.straightness = source.straightness !== undefined ? source.straightness : 0.7,\n\n\t\tdest.up0 = source.up0 !== undefined ? vecCopy( source.up0 ) : new THREE.Vector3( 0, 0, 1 );\n\t\tdest.up1 = source.up1 !== undefined ? vecCopy( source.up1 ) : new THREE.Vector3( 0, 0, 1 ),\n\t\tdest.radius0 = source.radius0 !== undefined ? source.radius0 : 1,\n\t\tdest.radius1 = source.radius1 !== undefined ? source.radius1 : 1,\n\t\tdest.radius0Factor = source.radius0Factor !== undefined ? source.radius0Factor : 0.5,\n\t\tdest.radius1Factor = source.radius1Factor !== undefined ? source.radius1Factor : 0.2,\n\t\tdest.minRadius = source.minRadius !== undefined ? source.minRadius : 0.2,\n\n\t\t// These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n\n\t\tdest.isEternal = source.isEternal !== undefined ? source.isEternal : ( source.birthTime === undefined || source.deathTime === undefined ),\n\t\tdest.birthTime = source.birthTime,\n\t\tdest.deathTime = source.deathTime,\n\t\tdest.propagationTimeFactor = source.propagationTimeFactor !== undefined ? source.propagationTimeFactor : 0.1,\n\t\tdest.vanishingTimeFactor = source.vanishingTimeFactor !== undefined ? source.vanishingTimeFactor : 0.9,\n\t\tdest.subrayPeriod = source.subrayPeriod !== undefined ? source.subrayPeriod : 4,\n\t\tdest.subrayDutyCycle = source.subrayDutyCycle !== undefined ? source.subrayDutyCycle : 0.6;\n\n\t\t// These parameters cannot change after lightning creation:\n\n\t\tdest.maxIterations = source.maxIterations !== undefined ? source.maxIterations : 9;\n\t\tdest.isStatic = source.isStatic !== undefined ? source.isStatic : false;\n\t\tdest.ramification = source.ramification !== undefined ? source.ramification : 5;\n\t\tdest.maxSubrayRecursion = source.maxSubrayRecursion !== undefined ? source.maxSubrayRecursion : 3;\n\t\tdest.recursionProbability = source.recursionProbability !== undefined ? source.recursionProbability : 0.6;\n\t\tdest.generateUVs = source.generateUVs !== undefined ? source.generateUVs : false;\n\t\tdest.randomGenerator = source.randomGenerator,\n\t\tdest.noiseSeed = source.noiseSeed,\n\t\tdest.onDecideSubrayCreation = source.onDecideSubrayCreation,\n\t\tdest.onSubrayCreation = source.onSubrayCreation;\n\n\t\treturn dest;\n\n\t};\n\n\tTHREE.LightningStrike.prototype.update = function ( time ) {\n\n\t\tif ( this.isStatic ) return;\n\n\t\tif ( this.rayParameters.isEternal || ( this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime ) ) {\n\n\t\t\tthis.updateMesh( time );\n\n\t\t\tif ( time < this.subrays[ 0 ].endPropagationTime ) {\n\n\t\t\t\tthis.state = THREE.LightningStrike.RAY_PROPAGATING;\n\n\t\t\t} else if ( time > this.subrays[ 0 ].beginVanishingTime ) {\n\n\t\t\t\tthis.state = THREE.LightningStrike.RAY_VANISHING;\n\n\t\t\t} else {\n\n\t\t\t\tthis.state = THREE.LightningStrike.RAY_STEADY;\n\n\t\t\t}\n\n\t\t\tthis.visible = true;\n\n\t\t} else {\n\n\t\t\tthis.visible = false;\n\n\t\t\tif ( time < this.rayParameters.birthTime ) {\n\n\t\t\t\tthis.state = THREE.LightningStrike.RAY_UNBORN;\n\n\t\t\t} else {\n\n\t\t\t\tthis.state = THREE.LightningStrike.RAY_EXTINGUISHED;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tTHREE.LightningStrike.prototype.init = function ( rayParameters ) {\n\n\t\t// Init all the state from the parameters\n\n\t\tthis.rayParameters = rayParameters;\n\n\t\t// These parameters cannot change after lightning creation:\n\n\t\tthis.maxIterations = rayParameters.maxIterations !== undefined ? Math.floor( rayParameters.maxIterations ) : 9;\n\t\trayParameters.maxIterations = this.maxIterations;\n\t\tthis.isStatic = rayParameters.isStatic !== undefined ? rayParameters.isStatic : false;\n\t\trayParameters.isStatic = this.isStatic;\n\t\tthis.ramification = rayParameters.ramification !== undefined ? Math.floor( rayParameters.ramification ) : 5;\n\t\trayParameters.ramification = this.ramification;\n\t\tthis.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== undefined ? Math.floor( rayParameters.maxSubrayRecursion ) : 3;\n\t\trayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\n\t\tthis.recursionProbability = rayParameters.recursionProbability !== undefined ? rayParameters.recursionProbability : 0.6;\n\t\trayParameters.recursionProbability = this.recursionProbability;\n\t\tthis.generateUVs = rayParameters.generateUVs !== undefined ? rayParameters.generateUVs : false;\n\t\trayParameters.generateUVs = this.generateUVs;\n\n\t\t// Random generator\n\t\tif ( rayParameters.randomGenerator !== undefined ) {\n\n\t\t\tthis.randomGenerator = rayParameters.randomGenerator;\n\t\t\tthis.seedGenerator = rayParameters.randomGenerator;\n\n\t\t\tif ( rayParameters.noiseSeed !== undefined ) {\n\n\t\t\t\tthis.seedGenerator.setSeed( rayParameters.noiseSeed );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.randomGenerator = THREE.LightningStrike.createRandomGenerator();\n\t\t\tthis.seedGenerator = Math;\n\n\t\t}\n\n\t\t// Ray creation callbacks\n\t\tif ( rayParameters.onDecideSubrayCreation !== undefined ) {\n\n\t\t\tthis.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\n\n\t\t} else {\n\n\t\t\tthis.createDefaultSubrayCreationCallbacks();\n\n\t\t\tif ( rayParameters.onSubrayCreation !== undefined ) {\n\n\t\t\t\tthis.onSubrayCreation = rayParameters.onSubrayCreation;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Internal state\n\n\t\tthis.state = THREE.LightningStrike.RAY_INITIALIZED;\n\n\t\tthis.maxSubrays = Math.ceil( 1 + Math.pow( this.ramification, Math.max( 0, this.maxSubrayRecursion - 1 ) ) );\n\t\trayParameters.maxSubrays = this.maxSubrays;\n\n\t\tthis.maxRaySegments = 2 * ( 1 << this.maxIterations );\n\n\t\tthis.subrays = [];\n\n\t\tfor ( var i = 0; i < this.maxSubrays; i ++ ) {\n\n\t\t\tthis.subrays.push( this.createSubray() );\n\n\t\t}\n\n\t\tthis.raySegments = [];\n\n\t\tfor ( var i = 0; i < this.maxRaySegments; i ++ ) {\n\n\t\t\tthis.raySegments.push( this.createSegment() );\n\n\t\t}\n\n\t\tthis.time = 0;\n\t\tthis.timeFraction = 0;\n\t\tthis.currentSegmentCallback = null;\n\t\tthis.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\n\t\tthis.numSubrays = 0;\n\t\tthis.currentSubray = null;\n\t\tthis.currentSegmentIndex = 0;\n\t\tthis.isInitialSegment = false;\n\t\tthis.subrayProbability = 0;\n\n\t\tthis.currentVertex = 0;\n\t\tthis.currentIndex = 0;\n\t\tthis.currentCoordinate = 0;\n\t\tthis.currentUVCoordinate = 0;\n\t\tthis.vertices = null;\n\t\tthis.uvs = null;\n\t\tthis.indices = null;\n\t\tthis.positionAttribute = null;\n\t\tthis.uvsAttribute = null;\n\n\t\tthis.simplexX = new THREE.SimplexNoise( this.seedGenerator );\n\t\tthis.simplexY = new THREE.SimplexNoise( this.seedGenerator );\n\t\tthis.simplexZ = new THREE.SimplexNoise( this.seedGenerator );\n\n\t\t// Temp vectors\n\t\tthis.forwards = new THREE.Vector3();\n\t\tthis.forwardsFill = new THREE.Vector3();\n\t\tthis.side = new THREE.Vector3();\n\t\tthis.down = new THREE.Vector3();\n\t\tthis.middlePos = new THREE.Vector3();\n\t\tthis.middleLinPos = new THREE.Vector3();\n\t\tthis.newPos = new THREE.Vector3();\n\t\tthis.vPos = new THREE.Vector3();\n\t\tthis.cross1 = new THREE.Vector3();\n\n\t};\n\n\tTHREE.LightningStrike.prototype.createMesh = function () {\n\n\t\tvar maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\n\n\t\tvar maxVerts = 3 * ( maxDrawableSegmentsPerSubRay + 1 ) * this.maxSubrays;\n\t\tvar maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\n\n\t\tthis.vertices = new Float32Array( maxVerts * 3 );\n\t\tthis.indices = new Uint32Array( maxIndices );\n\t\tif ( this.generateUVs ) {\n\n\t\t\tthis.uvs = new Float32Array( maxVerts * 2 );\n\n\t\t}\n\n\t\t// Populate the mesh\n\t\tthis.fillMesh( 0 );\n\n\t\tthis.setIndex( new THREE.Uint32BufferAttribute( this.indices, 1 ) );\n\n\t\tthis.positionAttribute = new THREE.Float32BufferAttribute( this.vertices, 3 );\n\t\tthis.setAttribute( 'position', this.positionAttribute );\n\n\t\tif ( this.generateUVs ) {\n\n\t\t\tthis.uvsAttribute = new THREE.Float32BufferAttribute( new Float32Array( this.uvs ), 2 );\n\t\t\tthis.setAttribute( 'uv', this.uvsAttribute );\n\n\t\t}\n\n\t\tif ( ! this.isStatic ) {\n\n\t\t\tthis.index.usage = THREE.DynamicDrawUsage;\n\t\t\tthis.positionAttribute.usage = THREE.DynamicDrawUsage;\n\t\t\tif ( this.generateUVs ) {\n\n\t\t\t\tthis.uvsAttribute.usage = THREE.DynamicDrawUsage;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Store buffers for later modification\n\t\tthis.vertices = this.positionAttribute.array;\n\t\tthis.indices = this.index.array;\n\t\tif ( this.generateUVs ) {\n\n\t\t\tthis.uvs = this.uvsAttribute.array;\n\n\t\t}\n\n\t};\n\n\tTHREE.LightningStrike.prototype.updateMesh = function ( time ) {\n\n\t\tthis.fillMesh( time );\n\n\t\tthis.drawRange.count = this.currentIndex;\n\n\t\tthis.index.needsUpdate = true;\n\n\t\tthis.positionAttribute.needsUpdate = true;\n\n\t\tif ( this.generateUVs ) {\n\n\t\t\tthis.uvsAttribute.needsUpdate = true;\n\n\t\t}\n\n\t};\n\n\tTHREE.LightningStrike.prototype.fillMesh = function ( time ) {\n\n\t\tvar scope = this;\n\n\t\tthis.currentVertex = 0;\n\t\tthis.currentIndex = 0;\n\t\tthis.currentCoordinate = 0;\n\t\tthis.currentUVCoordinate = 0;\n\n\t\tthis.fractalRay( time, function fillVertices( segment ) {\n\n\t\t\tvar subray = scope.currentSubray;\n\n\t\t\tif ( time < subray.birthTime ) { //&& ( ! this.rayParameters.isEternal || scope.currentSubray.recursion > 0 ) ) {\n\n\t\t\t\treturn;\n\n\t\t\t} else if ( this.rayParameters.isEternal && scope.currentSubray.recursion == 0 ) {\n\n\t\t\t\t// Eternal rays don't propagate nor vanish, but its subrays do\n\n\t\t\t\tscope.createPrism( segment );\n\n\t\t\t\tscope.onDecideSubrayCreation( segment, scope );\n\n\t\t\t} else if ( time < subray.endPropagationTime ) {\n\n\t\t\t\tif ( scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor ) {\n\n\t\t\t\t\t// Ray propagation has arrived to this segment\n\n\t\t\t\t\tscope.createPrism( segment );\n\n\t\t\t\t\tscope.onDecideSubrayCreation( segment, scope );\n\n\t\t\t\t}\n\n\t\t\t} else if ( time < subray.beginVanishingTime ) {\n\n\t\t\t\t// Ray is steady (nor propagating nor vanishing)\n\n\t\t\t\tscope.createPrism( segment );\n\n\t\t\t\tscope.onDecideSubrayCreation( segment, scope );\n\n\t\t\t} else {\n\n\t\t\t\tif ( scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * ( 1 - subray.vanishingTimeFactor ) ) {\n\n\t\t\t\t\t// Segment has not yet vanished\n\n\t\t\t\t\tscope.createPrism( segment );\n\n\t\t\t\t}\n\n\t\t\t\tscope.onDecideSubrayCreation( segment, scope );\n\n\t\t\t}\n\n\t\t} );\n\n\t};\n\n\tTHREE.LightningStrike.prototype.addNewSubray = function ( /*rayParameters*/ ) {\n\n\t\treturn this.subrays[ this.numSubrays ++ ];\n\n\t};\n\n\tTHREE.LightningStrike.prototype.initSubray = function ( subray, rayParameters ) {\n\n\t\tsubray.pos0.copy( rayParameters.sourceOffset );\n\t\tsubray.pos1.copy( rayParameters.destOffset );\n\t\tsubray.up0.copy( rayParameters.up0 );\n\t\tsubray.up1.copy( rayParameters.up1 );\n\t\tsubray.radius0 = rayParameters.radius0;\n\t\tsubray.radius1 = rayParameters.radius1;\n\t\tsubray.birthTime = rayParameters.birthTime;\n\t\tsubray.deathTime = rayParameters.deathTime;\n\t\tsubray.timeScale = rayParameters.timeScale;\n\t\tsubray.roughness = rayParameters.roughness;\n\t\tsubray.straightness = rayParameters.straightness;\n\t\tsubray.propagationTimeFactor = rayParameters.propagationTimeFactor;\n\t\tsubray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\n\n\t\tsubray.maxIterations = this.maxIterations;\n\t\tsubray.seed = rayParameters.noiseSeed !== undefined ? rayParameters.noiseSeed : 0;\n\t\tsubray.recursion = 0;\n\n\t};\n\n\tTHREE.LightningStrike.prototype.fractalRay = function ( time, segmentCallback ) {\n\n\t\tthis.time = time;\n\t\tthis.currentSegmentCallback = segmentCallback;\n\t\tthis.numSubrays = 0;\n\n\t\t// Add the top level subray\n\t\tthis.initSubray( this.addNewSubray(), this.rayParameters );\n\n\t\t// Process all subrays that are being generated until consuming all of them\n\t\tfor ( var subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex ++ ) {\n\n\t\t\tvar subray = this.subrays[ subrayIndex ];\n\t\t\tthis.currentSubray = subray;\n\n\t\t\tthis.randomGenerator.setSeed( subray.seed );\n\n\t\t\tsubray.endPropagationTime = THREE.MathUtils.lerp( subray.birthTime, subray.deathTime, subray.propagationTimeFactor );\n\t\t\tsubray.beginVanishingTime = THREE.MathUtils.lerp( subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor );\n\n\t\t\tvar random1 = this.randomGenerator.random;\n\t\t\tsubray.linPos0.set( random1(), random1(), random1() ).multiplyScalar( 1000 );\n\t\t\tsubray.linPos1.set( random1(), random1(), random1() ).multiplyScalar( 1000 );\n\n\t\t\tthis.timeFraction = ( time - subray.birthTime ) / ( subray.deathTime - subray.birthTime );\n\n\t\t\tthis.currentSegmentIndex = 0;\n\t\t\tthis.isInitialSegment = true;\n\n\t\t\tvar segment = this.getNewSegment();\n\t\t\tsegment.iteration = 0;\n\t\t\tsegment.pos0.copy( subray.pos0 );\n\t\t\tsegment.pos1.copy( subray.pos1 );\n\t\t\tsegment.linPos0.copy( subray.linPos0 );\n\t\t\tsegment.linPos1.copy( subray.linPos1 );\n\t\t\tsegment.up0.copy( subray.up0 );\n\t\t\tsegment.up1.copy( subray.up1 );\n\t\t\tsegment.radius0 = subray.radius0;\n\t\t\tsegment.radius1 = subray.radius1;\n\t\t\tsegment.fraction0 = 0;\n\t\t\tsegment.fraction1 = 1;\n\t\t\tsegment.positionVariationFactor = 1 - subray.straightness;\n\n\t\t\tthis.subrayProbability = this.ramification * Math.pow( this.recursionProbability, subray.recursion ) / ( 1 << subray.maxIterations );\n\n\t\t\tthis.fractalRayRecursive( segment );\n\n\t\t}\n\n\t\tthis.currentSegmentCallback = null;\n\t\tthis.currentSubray = null;\n\n\t};\n\n\tTHREE.LightningStrike.prototype.fractalRayRecursive = function ( segment ) {\n\n\t\t// Leave recursion condition\n\t\tif ( segment.iteration >= this.currentSubray.maxIterations ) {\n\n\t\t\tthis.currentSegmentCallback( segment );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Interpolation\n\t\tthis.forwards.subVectors( segment.pos1, segment.pos0 );\n\t\tvar lForwards = this.forwards.length();\n\n\t\tif ( lForwards < 0.000001 ) {\n\n\t\t\tthis.forwards.set( 0, 0, 0.01 );\n\t\t\tlForwards = this.forwards.length();\n\n\t\t}\n\n\t\tvar middleRadius = ( segment.radius0 + segment.radius1 ) * 0.5;\n\t\tvar middleFraction = ( segment.fraction0 + segment.fraction1 ) * 0.5;\n\n\t\tvar timeDimension = this.time * this.currentSubray.timeScale * Math.pow( 2, segment.iteration );\n\n\t\tthis.middlePos.lerpVectors( segment.pos0, segment.pos1, 0.5 );\n\t\tthis.middleLinPos.lerpVectors( segment.linPos0, segment.linPos1, 0.5 );\n\t\tvar p = this.middleLinPos;\n\n\t\t// Noise\n\t\tthis.newPos.set( this.simplexX.noise4d( p.x, p.y, p.z, timeDimension ),\n\t\t\tthis.simplexY.noise4d( p.x, p.y, p.z, timeDimension ),\n\t\t\tthis.simplexZ.noise4d( p.x, p.y, p.z, timeDimension ) );\n\n\t\tthis.newPos.multiplyScalar( segment.positionVariationFactor * lForwards );\n\t\tthis.newPos.add( this.middlePos );\n\n\t\t// Recursion\n\n\t\tvar newSegment1 = this.getNewSegment();\n\t\tnewSegment1.pos0.copy( segment.pos0 );\n\t\tnewSegment1.pos1.copy( this.newPos );\n\t\tnewSegment1.linPos0.copy( segment.linPos0 );\n\t\tnewSegment1.linPos1.copy( this.middleLinPos );\n\t\tnewSegment1.up0.copy( segment.up0 );\n\t\tnewSegment1.up1.copy( segment.up1 );\n\t\tnewSegment1.radius0 = segment.radius0;\n\t\tnewSegment1.radius1 = middleRadius;\n\t\tnewSegment1.fraction0 = segment.fraction0;\n\t\tnewSegment1.fraction1 = middleFraction;\n\t\tnewSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n\t\tnewSegment1.iteration = segment.iteration + 1;\n\n\t\tvar newSegment2 = this.getNewSegment();\n\t\tnewSegment2.pos0.copy( this.newPos );\n\t\tnewSegment2.pos1.copy( segment.pos1 );\n\t\tnewSegment2.linPos0.copy( this.middleLinPos );\n\t\tnewSegment2.linPos1.copy( segment.linPos1 );\n\t\tthis.cross1.crossVectors( segment.up0, this.forwards.normalize() );\n\t\tnewSegment2.up0.crossVectors( this.forwards, this.cross1 ).normalize();\n\t\tnewSegment2.up1.copy( segment.up1 );\n\t\tnewSegment2.radius0 = middleRadius;\n\t\tnewSegment2.radius1 = segment.radius1;\n\t\tnewSegment2.fraction0 = middleFraction;\n\t\tnewSegment2.fraction1 = segment.fraction1;\n\t\tnewSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n\t\tnewSegment2.iteration = segment.iteration + 1;\n\n\t\tthis.fractalRayRecursive( newSegment1 );\n\n\t\tthis.fractalRayRecursive( newSegment2 );\n\n\t};\n\n\tTHREE.LightningStrike.prototype.createPrism = function ( segment ) {\n\n\t\t// Creates one triangular prism and its vertices at the segment\n\n\t\tthis.forwardsFill.subVectors( segment.pos1, segment.pos0 ).normalize();\n\n\t\tif ( this.isInitialSegment ) {\n\n\t\t\tthis.currentCreateTriangleVertices( segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0 );\n\n\t\t\tthis.isInitialSegment = false;\n\n\t\t}\n\n\t\tthis.currentCreateTriangleVertices( segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1 );\n\n\t\tthis.createPrismFaces();\n\n\t};\n\n\tTHREE.LightningStrike.prototype.createTriangleVerticesWithoutUVs = function ( pos, up, forwards, radius ) {\n\n\t\t// Create an equilateral triangle (only vertices)\n\n\t\tthis.side.crossVectors( up, forwards ).multiplyScalar( radius * THREE.LightningStrike.COS30DEG );\n\t\tthis.down.copy( up ).multiplyScalar( - radius * THREE.LightningStrike.SIN30DEG );\n\n\t\tvar p = this.vPos;\n\t\tvar v = this.vertices;\n\n\t\tp.copy( pos ).sub( this.side ).add( this.down );\n\n\t\tv[ this.currentCoordinate ++ ] = p.x;\n\t\tv[ this.currentCoordinate ++ ] = p.y;\n\t\tv[ this.currentCoordinate ++ ] = p.z;\n\n\t\tp.copy( pos ).add( this.side ).add( this.down );\n\n\t\tv[ this.currentCoordinate ++ ] = p.x;\n\t\tv[ this.currentCoordinate ++ ] = p.y;\n\t\tv[ this.currentCoordinate ++ ] = p.z;\n\n\t\tp.copy( up ).multiplyScalar( radius ).add( pos );\n\n\t\tv[ this.currentCoordinate ++ ] = p.x;\n\t\tv[ this.currentCoordinate ++ ] = p.y;\n\t\tv[ this.currentCoordinate ++ ] = p.z;\n\n\t\tthis.currentVertex += 3;\n\n\t};\n\n\tTHREE.LightningStrike.prototype.createTriangleVerticesWithUVs = function ( pos, up, forwards, radius, u ) {\n\n\t\t// Create an equilateral triangle (only vertices)\n\n\t\tthis.side.crossVectors( up, forwards ).multiplyScalar( radius * THREE.LightningStrike.COS30DEG );\n\t\tthis.down.copy( up ).multiplyScalar( - radius * THREE.LightningStrike.SIN30DEG );\n\n\t\tvar p = this.vPos;\n\t\tvar v = this.vertices;\n\t\tvar uv = this.uvs;\n\n\t\tp.copy( pos ).sub( this.side ).add( this.down );\n\n\t\tv[ this.currentCoordinate ++ ] = p.x;\n\t\tv[ this.currentCoordinate ++ ] = p.y;\n\t\tv[ this.currentCoordinate ++ ] = p.z;\n\n\t\tuv[ this.currentUVCoordinate ++ ] = u;\n\t\tuv[ this.currentUVCoordinate ++ ] = 0;\n\n\t\tp.copy( pos ).add( this.side ).add( this.down );\n\n\t\tv[ this.currentCoordinate ++ ] = p.x;\n\t\tv[ this.currentCoordinate ++ ] = p.y;\n\t\tv[ this.currentCoordinate ++ ] = p.z;\n\n\t\tuv[ this.currentUVCoordinate ++ ] = u;\n\t\tuv[ this.currentUVCoordinate ++ ] = 0.5;\n\n\t\tp.copy( up ).multiplyScalar( radius ).add( pos );\n\n\t\tv[ this.currentCoordinate ++ ] = p.x;\n\t\tv[ this.currentCoordinate ++ ] = p.y;\n\t\tv[ this.currentCoordinate ++ ] = p.z;\n\n\t\tuv[ this.currentUVCoordinate ++ ] = u;\n\t\tuv[ this.currentUVCoordinate ++ ] = 1;\n\n\t\tthis.currentVertex += 3;\n\n\t};\n\n\tTHREE.LightningStrike.prototype.createPrismFaces = function ( vertex/*, index*/ ) {\n\n\t\tvar indices = this.indices;\n\t\tvar vertex = this.currentVertex - 6;\n\n\t\tindices[ this.currentIndex ++ ] = vertex + 1;\n\t\tindices[ this.currentIndex ++ ] = vertex + 2;\n\t\tindices[ this.currentIndex ++ ] = vertex + 5;\n\t\tindices[ this.currentIndex ++ ] = vertex + 1;\n\t\tindices[ this.currentIndex ++ ] = vertex + 5;\n\t\tindices[ this.currentIndex ++ ] = vertex + 4;\n\t\tindices[ this.currentIndex ++ ] = vertex + 0;\n\t\tindices[ this.currentIndex ++ ] = vertex + 1;\n\t\tindices[ this.currentIndex ++ ] = vertex + 4;\n\t\tindices[ this.currentIndex ++ ] = vertex + 0;\n\t\tindices[ this.currentIndex ++ ] = vertex + 4;\n\t\tindices[ this.currentIndex ++ ] = vertex + 3;\n\t\tindices[ this.currentIndex ++ ] = vertex + 2;\n\t\tindices[ this.currentIndex ++ ] = vertex + 0;\n\t\tindices[ this.currentIndex ++ ] = vertex + 3;\n\t\tindices[ this.currentIndex ++ ] = vertex + 2;\n\t\tindices[ this.currentIndex ++ ] = vertex + 3;\n\t\tindices[ this.currentIndex ++ ] = vertex + 5;\n\n\t};\n\n\tTHREE.LightningStrike.prototype.createDefaultSubrayCreationCallbacks = function () {\n\n\t\tvar random1 = this.randomGenerator.random;\n\n\t\tthis.onDecideSubrayCreation = function ( segment, lightningStrike ) {\n\n\t\t\t// Decide subrays creation at parent (sub)ray segment\n\n\t\t\tvar subray = lightningStrike.currentSubray;\n\n\t\t\tvar period = lightningStrike.rayParameters.subrayPeriod;\n\t\t\tvar dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\n\n\t\t\tvar phase0 = ( lightningStrike.rayParameters.isEternal && subray.recursion == 0 ) ? - random1() * period : THREE.MathUtils.lerp( subray.birthTime, subray.endPropagationTime, segment.fraction0 ) - random1() * period;\n\n\t\t\tvar phase = lightningStrike.time - phase0;\n\t\t\tvar currentCycle = Math.floor( phase / period );\n\n\t\t\tvar childSubraySeed = random1() * ( currentCycle + 1 );\n\n\t\t\tvar isActive = phase % period <= dutyCycle * period;\n\n\t\t\tvar probability = 0;\n\n\t\t\tif ( isActive ) {\n\n\t\t\t\tprobability = lightningStrike.subrayProbability;\n\t\t\t\t// Distribution test: probability *= segment.fraction0 > 0.5 && segment.fraction0 < 0.9 ? 1 / 0.4 : 0;\n\n\t\t\t}\n\n\t\t\tif ( subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability ) {\n\n\t\t\t\tvar childSubray = lightningStrike.addNewSubray();\n\n\t\t\t\tvar parentSeed = lightningStrike.randomGenerator.getSeed();\n\t\t\t\tchildSubray.seed = childSubraySeed;\n\t\t\t\tlightningStrike.randomGenerator.setSeed( childSubraySeed );\n\n\t\t\t\tchildSubray.recursion = subray.recursion + 1;\n\t\t\t\tchildSubray.maxIterations = Math.max( 1, subray.maxIterations - 1 );\n\n\t\t\t\tchildSubray.linPos0.set( random1(), random1(), random1() ).multiplyScalar( 1000 );\n\t\t\t\tchildSubray.linPos1.set( random1(), random1(), random1() ).multiplyScalar( 1000 );\n\t\t\t\tchildSubray.up0.copy( subray.up0 );\n\t\t\t\tchildSubray.up1.copy( subray.up1 );\n\t\t\t\tchildSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\n\t\t\t\tchildSubray.radius1 = Math.min( lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor );\n\n\t\t\t\tchildSubray.birthTime = phase0 + ( currentCycle ) * period;\n\t\t\t\tchildSubray.deathTime = childSubray.birthTime + period * dutyCycle;\n\n\t\t\t\tif ( ! lightningStrike.rayParameters.isEternal && subray.recursion == 0 ) {\n\n\t\t\t\t\tchildSubray.birthTime = Math.max( childSubray.birthTime, subray.birthTime );\n\t\t\t\t\tchildSubray.deathTime = Math.min( childSubray.deathTime, subray.deathTime );\n\n\t\t\t\t}\n\n\t\t\t\tchildSubray.timeScale = subray.timeScale * 2;\n\t\t\t\tchildSubray.roughness = subray.roughness;\n\t\t\t\tchildSubray.straightness = subray.straightness;\n\t\t\t\tchildSubray.propagationTimeFactor = subray.propagationTimeFactor;\n\t\t\t\tchildSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\n\n\t\t\t\tlightningStrike.onSubrayCreation( segment, subray, childSubray, lightningStrike );\n\n\t\t\t\tlightningStrike.randomGenerator.setSeed( parentSeed );\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar vec1Pos = new THREE.Vector3();\n\t\tvar vec2Forward = new THREE.Vector3();\n\t\tvar vec3Side = new THREE.Vector3();\n\t\tvar vec4Up = new THREE.Vector3();\n\n\t\tthis.onSubrayCreation = function ( segment, parentSubray, childSubray, lightningStrike ) {\n\n\t\t\t// Decide childSubray origin and destination positions (pos0 and pos1) and possibly other properties of childSubray\n\n\t\t\t// Just use the default cone position generator\n\t\t\tlightningStrike.subrayCylinderPosition( segment, parentSubray, childSubray, 0.5, 0.6, 0.2 );\n\n\t\t};\n\n\t\tthis.subrayConePosition = function ( segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor ) {\n\n\t\t\t// Sets childSubray pos0 and pos1 in a cone\n\n\t\t\tchildSubray.pos0.copy( segment.pos0 );\n\n\t\t\tvec1Pos.subVectors( parentSubray.pos1, parentSubray.pos0 );\n\t\t\tvec2Forward.copy( vec1Pos ).normalize();\n\t\t\tvec1Pos.multiplyScalar( segment.fraction0 + ( 1 - segment.fraction0 ) * ( random1() * heightFactor ) );\n\t\t\tvar length = vec1Pos.length();\n\t\t\tvec3Side.crossVectors( parentSubray.up0, vec2Forward );\n\t\t\tvar angle = 2 * Math.PI * random1();\n\t\t\tvec3Side.multiplyScalar( Math.cos( angle ) );\n\t\t\tvec4Up.copy( parentSubray.up0 ).multiplyScalar( Math.sin( angle ) );\n\n\t\t\tchildSubray.pos1.copy( vec3Side ).add( vec4Up ).multiplyScalar( length * sideWidthFactor * ( minSideWidthFactor + random1() * ( 1 - minSideWidthFactor ) ) ).add( vec1Pos ).add( parentSubray.pos0 );\n\n\t\t};\n\n\t\tthis.subrayCylinderPosition = function ( segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor ) {\n\n\t\t\t// Sets childSubray pos0 and pos1 in a cylinder\n\n\t\t\tchildSubray.pos0.copy( segment.pos0 );\n\n\t\t\tvec1Pos.subVectors( parentSubray.pos1, parentSubray.pos0 );\n\t\t\tvec2Forward.copy( vec1Pos ).normalize();\n\t\t\tvec1Pos.multiplyScalar( segment.fraction0 + ( 1 - segment.fraction0 ) * ( ( 2 * random1() - 1 ) * heightFactor ) );\n\t\t\tvar length = vec1Pos.length();\n\t\t\tvec3Side.crossVectors( parentSubray.up0, vec2Forward );\n\t\t\tvar angle = 2 * Math.PI * random1();\n\t\t\tvec3Side.multiplyScalar( Math.cos( angle ) );\n\t\t\tvec4Up.copy( parentSubray.up0 ).multiplyScalar( Math.sin( angle ) );\n\n\t\t\tchildSubray.pos1.copy( vec3Side ).add( vec4Up ).multiplyScalar( length * sideWidthFactor * ( minSideWidthFactor + random1() * ( 1 - minSideWidthFactor ) ) ).add( vec1Pos ).add( parentSubray.pos0 );\n\n\t\t};\n\n\t};\n\n\tTHREE.LightningStrike.prototype.createSubray = function () {\n\n\t\treturn {\n\n\t\t\tseed: 0,\n\t\t\tmaxIterations: 0,\n\t\t\trecursion: 0,\n\t\t\tpos0: new THREE.Vector3(),\n\t\t\tpos1: new THREE.Vector3(),\n\t\t\tlinPos0: new THREE.Vector3(),\n\t\t\tlinPos1: new THREE.Vector3(),\n\t\t\tup0: new THREE.Vector3(),\n\t\t\tup1: new THREE.Vector3(),\n\t\t\tradius0: 0,\n\t\t\tradius1: 0,\n\t\t\tbirthTime: 0,\n\t\t\tdeathTime: 0,\n\t\t\ttimeScale: 0,\n\t\t\troughness: 0,\n\t\t\tstraightness: 0,\n\t\t\tpropagationTimeFactor: 0,\n\t\t\tvanishingTimeFactor: 0,\n\t\t\tendPropagationTime: 0,\n\t\t\tbeginVanishingTime: 0\n\n\t\t};\n\n\t};\n\n\tTHREE.LightningStrike.prototype.createSegment = function () {\n\n\t\treturn {\n\t\t\titeration: 0,\n\t\t\tpos0: new THREE.Vector3(),\n\t\t\tpos1: new THREE.Vector3(),\n\t\t\tlinPos0: new THREE.Vector3(),\n\t\t\tlinPos1: new THREE.Vector3(),\n\t\t\tup0: new THREE.Vector3(),\n\t\t\tup1: new THREE.Vector3(),\n\t\t\tradius0: 0,\n\t\t\tradius1: 0,\n\t\t\tfraction0: 0,\n\t\t\tfraction1: 0,\n\t\t\tpositionVariationFactor: 0\n\t\t};\n\n\t};\n\n\tTHREE.LightningStrike.prototype.getNewSegment = function () {\n\n\t\treturn this.raySegments[ this.currentSegmentIndex ++ ];\n\n\t};\n\n\tTHREE.LightningStrike.prototype.copy = function ( source ) {\n\n\t\tTHREE.BufferGeometry.prototype.copy.call( this, source );\n\n\t\tthis.init( THREE.LightningStrike.copyParameters( {}, source.rayParameters ) );\n\n\t\treturn this;\n\n\t};\n\n\tTHREE.LightningStrike.prototype.clone = function () {\n\n\t\treturn new this.constructor( THREE.LightningStrike.copyParameters( {}, this.rayParameters ) );\n\n\t};\n\t\n\treturn THREE.LightningStrike;\n});\n"]}