{"version":3,"sources":["webxr/XRControllerModelFactory.js"],"names":["define","THREE","threex","GLTFLoader","motion","DEFAULT_PROFILES_PATH","XRControllerModel","Object3D","call","this","motionController","envMap","addAssetSceneToControllerModel","controllerModel","scene","Object","values","components","forEach","component","type","touchPointNodeName","visualResponses","MotionControllerConstants","ComponentType","TOUCHPAD","touchPointNode","getObjectByName","sphereGeometry","SphereGeometry","material","MeshBasicMaterial","color","sphere","Mesh","add","console","warn","id","visualResponse","valueNodeName","minNodeName","maxNodeName","valueNodeProperty","Constants","VisualResponseProperty","TRANSFORM","minNode","maxNode","valueNode","findNodes","traverse","child","isMesh","needsUpdate","prototype","assign","create","constructor","setEnvironmentMap","updateMatrixWorld","force","updateFromGamepad","value","VISIBILITY","visible","Quaternion","slerp","quaternion","position","lerpVectors","XRControllerModelFactory","gltfLoader","path","_assetCache","createControllerModel","controller","addEventListener","event","xrInputSource","data","targetRayMode","gamepad","fetchProfile","then","profile","assetPath","c","MotionController","cachedAsset","assetUrl","clone","Error","setPath","load","asset","catch","err","remove","webxr"],"mappings":"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","file":"../../webxr/XRControllerModelFactory.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\",\r\n    '../loaders/GLTFLoader',\r\n    '../utils/motion'\r\n], function (\r\n    THREE, \r\n    threex,\r\n    GLTFLoader, \r\n    motion\r\n) {\r\n    'use strict';\r\n    const DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';\r\n    const DEFAULT_PROFILE = 'generic-trigger';\r\n    function XRControllerModel() {\r\n        THREE.Object3D.call(this);\r\n        this.motionController = null;\r\n        this.envMap = null;\r\n    }\r\n    XRControllerModel.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {\r\n        constructor: XRControllerModel,\r\n        setEnvironmentMap: function (envMap) {\r\n            if (this.envMap == envMap) {\r\n                return this;\r\n            }\r\n            this.envMap = envMap;\r\n            this.traverse(child => {\r\n                if (child.isMesh) {\r\n                    child.material.envMap = this.envMap;\r\n                    child.material.needsUpdate = true;\r\n                }\r\n            });\r\n            return this;\r\n        },\r\n        updateMatrixWorld: function (force) {\r\n            THREE.Object3D.prototype.updateMatrixWorld.call(this, force);\r\n            if (!this.motionController)\r\n                return;\r\n            this.motionController.updateFromGamepad();\r\n            Object.values(this.motionController.components).forEach(component => {\r\n                Object.values(component.visualResponses).forEach(visualResponse => {\r\n                    const {valueNode, minNode, maxNode, value, valueNodeProperty} = visualResponse;\r\n                    if (!valueNode)\r\n                        return;\r\n                    if (valueNodeProperty === motion.Constants.VisualResponseProperty.VISIBILITY) {\r\n                        valueNode.visible = value;\r\n                    } else if (valueNodeProperty === motion.Constants.VisualResponseProperty.TRANSFORM) {\r\n                        THREE.Quaternion.slerp(minNode.quaternion, maxNode.quaternion, valueNode.quaternion, value);\r\n                        valueNode.position.lerpVectors(minNode.position, maxNode.position, value);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    });\r\n    function findNodes(motionController, scene) {\r\n        Object.values(motionController.components).forEach(component => {\r\n            const {type, touchPointNodeName, visualResponses} = component;\r\n            if (type === MotionControllerConstants.ComponentType.TOUCHPAD) {\r\n                component.touchPointNode = scene.getObjectByName(touchPointNodeName);\r\n                if (component.touchPointNode) {\r\n                    const sphereGeometry = new THREE.SphereGeometry(0.001);\r\n                    const material = new THREE.MeshBasicMaterial({ color: 255 });\r\n                    const sphere = new THREE.Mesh(sphereGeometry, material);\r\n                    component.touchPointNode.add(sphere);\r\n                } else {\r\n                    console.warn(`Could not find touch dot, ${ component.touchPointNodeName }, in touchpad component ${ component.id }`);\r\n                }\r\n            }\r\n            Object.values(visualResponses).forEach(visualResponse => {\r\n                const {valueNodeName, minNodeName, maxNodeName, valueNodeProperty} = visualResponse;\r\n                if (valueNodeProperty === motion.Constants.VisualResponseProperty.TRANSFORM) {\r\n                    visualResponse.minNode = scene.getObjectByName(minNodeName);\r\n                    visualResponse.maxNode = scene.getObjectByName(maxNodeName);\r\n                    if (!visualResponse.minNode) {\r\n                        console.warn(`Could not find ${ minNodeName } in the model`);\r\n                        return;\r\n                    }\r\n                    if (!visualResponse.maxNode) {\r\n                        console.warn(`Could not find ${ maxNodeName } in the model`);\r\n                        return;\r\n                    }\r\n                }\r\n                visualResponse.valueNode = scene.getObjectByName(valueNodeName);\r\n                if (!visualResponse.valueNode) {\r\n                    console.warn(`Could not find ${ valueNodeName } in the model`);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    function addAssetSceneToControllerModel(controllerModel, scene) {\r\n        findNodes(controllerModel.motionController, scene);\r\n        if (controllerModel.envMap) {\r\n            scene.traverse(child => {\r\n                if (child.isMesh) {\r\n                    child.material.envMap = controllerModel.envMap;\r\n                    child.material.needsUpdate = true;\r\n                }\r\n            });\r\n        }\r\n        controllerModel.add(scene);\r\n    }\r\n    var XRControllerModelFactory = function () {\r\n        function XRControllerModelFactory(gltfLoader = null) {\r\n            this.gltfLoader = gltfLoader;\r\n            this.path = DEFAULT_PROFILES_PATH;\r\n            this._assetCache = {};\r\n            if (!this.gltfLoader) {\r\n                this.gltfLoader = new GLTFLoader();\r\n            }\r\n        }\r\n        XRControllerModelFactory.prototype = {\r\n            constructor: XRControllerModelFactory,\r\n            createControllerModel: function (controller) {\r\n                const controllerModel = new XRControllerModel();\r\n                let scene = null;\r\n                controller.addEventListener('connected', event => {\r\n                    const xrInputSource = event.data;\r\n                    if (xrInputSource.targetRayMode !== 'tracked-pointer' || !xrInputSource.gamepad)\r\n                        return;\r\n                    motion.fetchProfile(xrInputSource, this.path, DEFAULT_PROFILE).then(({profile, assetPath}) => {\r\n                        controllerModel.motionController = new c.MotionController(xrInputSource, profile, assetPath);\r\n                        let cachedAsset = this._assetCache[controllerModel.motionController.assetUrl];\r\n                        if (cachedAsset) {\r\n                            scene = cachedAsset.scene.clone();\r\n                            addAssetSceneToControllerModel(controllerModel, scene);\r\n                        } else {\r\n                            if (!this.gltfLoader) {\r\n                                throw new Error(`GLTFLoader not set.`);\r\n                            }\r\n                            this.gltfLoader.setPath('');\r\n                            this.gltfLoader.load(controllerModel.motionController.assetUrl, asset => {\r\n                                this._assetCache[controllerModel.motionController.assetUrl] = asset;\r\n                                scene = asset.scene.clone();\r\n                                addAssetSceneToControllerModel(controllerModel, scene);\r\n                            }, null, () => {\r\n                                throw new Error(`Asset ${ controllerModel.motionController.assetUrl } missing or malformed.`);\r\n                            });\r\n                        }\r\n                    }).catch(err => {\r\n                        console.warn(err);\r\n                    });\r\n                });\r\n                controller.addEventListener('disconnected', () => {\r\n                    controllerModel.motionController = null;\r\n                    controllerModel.remove(scene);\r\n                    scene = null;\r\n                });\r\n                return controllerModel;\r\n            }\r\n        };\r\n        return XRControllerModelFactory;\r\n    }();\r\n    return threex.webxr.XRControllerModelFactory = XRControllerModelFactory;\r\n});"]}