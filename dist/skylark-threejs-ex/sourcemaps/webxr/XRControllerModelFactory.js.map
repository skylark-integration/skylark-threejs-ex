{"version":3,"sources":["webxr/XRControllerModelFactory.js"],"names":["define","THREE","GLTFLoader","motion","DEFAULT_PROFILES_PATH","XRControllerModel","Object3D","call","this","motionController","envMap","addAssetSceneToControllerModel","controllerModel","scene","Object","values","components","forEach","component","type","touchPointNodeName","visualResponses","MotionControllerConstants","ComponentType","TOUCHPAD","touchPointNode","getObjectByName","sphereGeometry","SphereGeometry","material","MeshBasicMaterial","color","sphere","Mesh","add","console","warn","id","visualResponse","valueNodeName","minNodeName","maxNodeName","valueNodeProperty","Constants","VisualResponseProperty","TRANSFORM","minNode","maxNode","valueNode","findNodes","traverse","child","isMesh","needsUpdate","prototype","assign","create","constructor","setEnvironmentMap","updateMatrixWorld","force","updateFromGamepad","value","VISIBILITY","visible","Quaternion","slerp","quaternion","position","lerpVectors","XRControllerModelFactory","gltfLoader","path","_assetCache","createControllerModel","controller","addEventListener","event","xrInputSource","data","targetRayMode","gamepad","fetchProfile","then","profile","assetPath","c","MotionController","cachedAsset","assetUrl","clone","Error","setPath","load","asset","catch","err","remove"],"mappings":"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","file":"../../webxr/XRControllerModelFactory.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    '../loaders/GLTFLoader',\n    '../utils/motion'\n], function (\n    THREE, \n    GLTFLoader, \n    motion\n) {\n    'use strict';\n    const DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';\n    const DEFAULT_PROFILE = 'generic-trigger';\n    function XRControllerModel() {\n        THREE.Object3D.call(this);\n        this.motionController = null;\n        this.envMap = null;\n    }\n    XRControllerModel.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {\n        constructor: XRControllerModel,\n        setEnvironmentMap: function (envMap) {\n            if (this.envMap == envMap) {\n                return this;\n            }\n            this.envMap = envMap;\n            this.traverse(child => {\n                if (child.isMesh) {\n                    child.material.envMap = this.envMap;\n                    child.material.needsUpdate = true;\n                }\n            });\n            return this;\n        },\n        updateMatrixWorld: function (force) {\n            THREE.Object3D.prototype.updateMatrixWorld.call(this, force);\n            if (!this.motionController)\n                return;\n            this.motionController.updateFromGamepad();\n            Object.values(this.motionController.components).forEach(component => {\n                Object.values(component.visualResponses).forEach(visualResponse => {\n                    const {valueNode, minNode, maxNode, value, valueNodeProperty} = visualResponse;\n                    if (!valueNode)\n                        return;\n                    if (valueNodeProperty === motion.Constants.VisualResponseProperty.VISIBILITY) {\n                        valueNode.visible = value;\n                    } else if (valueNodeProperty === motion.Constants.VisualResponseProperty.TRANSFORM) {\n                        THREE.Quaternion.slerp(minNode.quaternion, maxNode.quaternion, valueNode.quaternion, value);\n                        valueNode.position.lerpVectors(minNode.position, maxNode.position, value);\n                    }\n                });\n            });\n        }\n    });\n    function findNodes(motionController, scene) {\n        Object.values(motionController.components).forEach(component => {\n            const {type, touchPointNodeName, visualResponses} = component;\n            if (type === MotionControllerConstants.ComponentType.TOUCHPAD) {\n                component.touchPointNode = scene.getObjectByName(touchPointNodeName);\n                if (component.touchPointNode) {\n                    const sphereGeometry = new THREE.SphereGeometry(0.001);\n                    const material = new THREE.MeshBasicMaterial({ color: 255 });\n                    const sphere = new THREE.Mesh(sphereGeometry, material);\n                    component.touchPointNode.add(sphere);\n                } else {\n                    console.warn(`Could not find touch dot, ${ component.touchPointNodeName }, in touchpad component ${ component.id }`);\n                }\n            }\n            Object.values(visualResponses).forEach(visualResponse => {\n                const {valueNodeName, minNodeName, maxNodeName, valueNodeProperty} = visualResponse;\n                if (valueNodeProperty === motion.Constants.VisualResponseProperty.TRANSFORM) {\n                    visualResponse.minNode = scene.getObjectByName(minNodeName);\n                    visualResponse.maxNode = scene.getObjectByName(maxNodeName);\n                    if (!visualResponse.minNode) {\n                        console.warn(`Could not find ${ minNodeName } in the model`);\n                        return;\n                    }\n                    if (!visualResponse.maxNode) {\n                        console.warn(`Could not find ${ maxNodeName } in the model`);\n                        return;\n                    }\n                }\n                visualResponse.valueNode = scene.getObjectByName(valueNodeName);\n                if (!visualResponse.valueNode) {\n                    console.warn(`Could not find ${ valueNodeName } in the model`);\n                }\n            });\n        });\n    }\n    function addAssetSceneToControllerModel(controllerModel, scene) {\n        findNodes(controllerModel.motionController, scene);\n        if (controllerModel.envMap) {\n            scene.traverse(child => {\n                if (child.isMesh) {\n                    child.material.envMap = controllerModel.envMap;\n                    child.material.needsUpdate = true;\n                }\n            });\n        }\n        controllerModel.add(scene);\n    }\n    var XRControllerModelFactory = function () {\n        function XRControllerModelFactory(gltfLoader = null) {\n            this.gltfLoader = gltfLoader;\n            this.path = DEFAULT_PROFILES_PATH;\n            this._assetCache = {};\n            if (!this.gltfLoader) {\n                this.gltfLoader = new GLTFLoader();\n            }\n        }\n        XRControllerModelFactory.prototype = {\n            constructor: XRControllerModelFactory,\n            createControllerModel: function (controller) {\n                const controllerModel = new XRControllerModel();\n                let scene = null;\n                controller.addEventListener('connected', event => {\n                    const xrInputSource = event.data;\n                    if (xrInputSource.targetRayMode !== 'tracked-pointer' || !xrInputSource.gamepad)\n                        return;\n                    motion.fetchProfile(xrInputSource, this.path, DEFAULT_PROFILE).then(({profile, assetPath}) => {\n                        controllerModel.motionController = new c.MotionController(xrInputSource, profile, assetPath);\n                        let cachedAsset = this._assetCache[controllerModel.motionController.assetUrl];\n                        if (cachedAsset) {\n                            scene = cachedAsset.scene.clone();\n                            addAssetSceneToControllerModel(controllerModel, scene);\n                        } else {\n                            if (!this.gltfLoader) {\n                                throw new Error(`GLTFLoader not set.`);\n                            }\n                            this.gltfLoader.setPath('');\n                            this.gltfLoader.load(controllerModel.motionController.assetUrl, asset => {\n                                this._assetCache[controllerModel.motionController.assetUrl] = asset;\n                                scene = asset.scene.clone();\n                                addAssetSceneToControllerModel(controllerModel, scene);\n                            }, null, () => {\n                                throw new Error(`Asset ${ controllerModel.motionController.assetUrl } missing or malformed.`);\n                            });\n                        }\n                    }).catch(err => {\n                        console.warn(err);\n                    });\n                });\n                controller.addEventListener('disconnected', () => {\n                    controllerModel.motionController = null;\n                    controllerModel.remove(scene);\n                    scene = null;\n                });\n                return controllerModel;\n            }\n        };\n        return XRControllerModelFactory;\n    }();\n    return XRControllerModelFactory;\n});"]}