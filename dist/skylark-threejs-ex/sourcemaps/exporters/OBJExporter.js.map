{"version":3,"sources":["exporters/OBJExporter.js"],"names":["define","THREE","threex","OBJExporter","prototype","constructor","parse","object","i","j","k","l","m","output","indexVertex","indexVertexUvs","indexNormals","vertex","Vector3","normal","uv","Vector2","face","traverse","child","Mesh","mesh","nbVertex","nbNormals","nbVertexUvs","geometry","normalMatrixWorld","Matrix3","Geometry","BufferGeometry","setFromObject","vertices","getAttribute","normals","uvs","indices","getIndex","name","material","undefined","count","x","getX","y","getY","z","getZ","applyMatrix4","matrixWorld","getNormalMatrix","applyMatrix3","normalize","join","console","warn","parseMesh","Line","line","type","parseLine","exporters"],"mappings":"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","file":"../../exporters/OBJExporter.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var OBJExporter = function () {\r\n    };\r\n    OBJExporter.prototype = {\r\n        constructor: OBJExporter,\r\n        parse: function (object) {\r\n            var output = '';\r\n            var indexVertex = 0;\r\n            var indexVertexUvs = 0;\r\n            var indexNormals = 0;\r\n            var vertex = new THREE.Vector3();\r\n            var normal = new THREE.Vector3();\r\n            var uv = new THREE.Vector2();\r\n            var i, j, k, l, m, face = [];\r\n            var parseMesh = function (mesh) {\r\n                var nbVertex = 0;\r\n                var nbNormals = 0;\r\n                var nbVertexUvs = 0;\r\n                var geometry = mesh.geometry;\r\n                var normalMatrixWorld = new THREE.Matrix3();\r\n                if (geometry instanceof THREE.Geometry) {\r\n                    geometry = new THREE.BufferGeometry().setFromObject(mesh);\r\n                }\r\n                if (geometry instanceof THREE.BufferGeometry) {\r\n                    var vertices = geometry.getAttribute('position');\r\n                    var normals = geometry.getAttribute('normal');\r\n                    var uvs = geometry.getAttribute('uv');\r\n                    var indices = geometry.getIndex();\r\n                    output += 'o ' + mesh.name + '\\n';\r\n                    if (mesh.material && mesh.material.name) {\r\n                        output += 'usemtl ' + mesh.material.name + '\\n';\r\n                    }\r\n                    if (vertices !== undefined) {\r\n                        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\r\n                            vertex.x = vertices.getX(i);\r\n                            vertex.y = vertices.getY(i);\r\n                            vertex.z = vertices.getZ(i);\r\n                            vertex.applyMatrix4(mesh.matrixWorld);\r\n                            output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\r\n                        }\r\n                    }\r\n                    if (uvs !== undefined) {\r\n                        for (i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\r\n                            uv.x = uvs.getX(i);\r\n                            uv.y = uvs.getY(i);\r\n                            output += 'vt ' + uv.x + ' ' + uv.y + '\\n';\r\n                        }\r\n                    }\r\n                    if (normals !== undefined) {\r\n                        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\r\n                        for (i = 0, l = normals.count; i < l; i++, nbNormals++) {\r\n                            normal.x = normals.getX(i);\r\n                            normal.y = normals.getY(i);\r\n                            normal.z = normals.getZ(i);\r\n                            normal.applyMatrix3(normalMatrixWorld).normalize();\r\n                            output += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\r\n                        }\r\n                    }\r\n                    if (indices !== null) {\r\n                        for (i = 0, l = indices.count; i < l; i += 3) {\r\n                            for (m = 0; m < 3; m++) {\r\n                                j = indices.getX(i + m) + 1;\r\n                                face[m] = indexVertex + j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + j : '') + (normals ? '/' + (indexNormals + j) : '') : '');\r\n                            }\r\n                            output += 'f ' + face.join(' ') + '\\n';\r\n                        }\r\n                    } else {\r\n                        for (i = 0, l = vertices.count; i < l; i += 3) {\r\n                            for (m = 0; m < 3; m++) {\r\n                                j = i + m + 1;\r\n                                face[m] = indexVertex + j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + j : '') + (normals ? '/' + (indexNormals + j) : '') : '');\r\n                            }\r\n                            output += 'f ' + face.join(' ') + '\\n';\r\n                        }\r\n                    }\r\n                } else {\r\n                    console.warn('THREE.OBJExporter.parseMesh(): geometry type unsupported', geometry);\r\n                }\r\n                indexVertex += nbVertex;\r\n                indexVertexUvs += nbVertexUvs;\r\n                indexNormals += nbNormals;\r\n            };\r\n            var parseLine = function (line) {\r\n                var nbVertex = 0;\r\n                var geometry = line.geometry;\r\n                var type = line.type;\r\n                if (geometry instanceof THREE.Geometry) {\r\n                    geometry = new THREE.BufferGeometry().setFromObject(line);\r\n                }\r\n                if (geometry instanceof THREE.BufferGeometry) {\r\n                    var vertices = geometry.getAttribute('position');\r\n                    output += 'o ' + line.name + '\\n';\r\n                    if (vertices !== undefined) {\r\n                        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\r\n                            vertex.x = vertices.getX(i);\r\n                            vertex.y = vertices.getY(i);\r\n                            vertex.z = vertices.getZ(i);\r\n                            vertex.applyMatrix4(line.matrixWorld);\r\n                            output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\r\n                        }\r\n                    }\r\n                    if (type === 'Line') {\r\n                        output += 'l ';\r\n                        for (j = 1, l = vertices.count; j <= l; j++) {\r\n                            output += indexVertex + j + ' ';\r\n                        }\r\n                        output += '\\n';\r\n                    }\r\n                    if (type === 'LineSegments') {\r\n                        for (j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\r\n                            output += 'l ' + (indexVertex + j) + ' ' + (indexVertex + k) + '\\n';\r\n                        }\r\n                    }\r\n                } else {\r\n                    console.warn('THREE.OBJExporter.parseLine(): geometry type unsupported', geometry);\r\n                }\r\n                indexVertex += nbVertex;\r\n            };\r\n            object.traverse(function (child) {\r\n                if (child instanceof THREE.Mesh) {\r\n                    parseMesh(child);\r\n                }\r\n                if (child instanceof THREE.Line) {\r\n                    parseLine(child);\r\n                }\r\n            });\r\n            return output;\r\n        }\r\n    };\r\n\r\n    return threex.exporters.OBJExporter = OBJExporter;\r\n});"]}