{"version":3,"sources":["exporters/OBJExporter.js"],"names":["define","THREE","OBJExporter","prototype","constructor","parse","object","i","j","k","l","m","output","indexVertex","indexVertexUvs","indexNormals","vertex","Vector3","normal","uv","Vector2","face","traverse","child","Mesh","mesh","nbVertex","nbNormals","nbVertexUvs","geometry","normalMatrixWorld","Matrix3","Geometry","BufferGeometry","setFromObject","vertices","getAttribute","normals","uvs","indices","getIndex","name","material","undefined","count","x","getX","y","getY","z","getZ","applyMatrix4","matrixWorld","getNormalMatrix","applyMatrix3","normalize","join","console","warn","parseMesh","Line","line","type","parseLine"],"mappings":"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","file":"../../exporters/OBJExporter.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var OBJExporter = function () {\n    };\n    OBJExporter.prototype = {\n        constructor: OBJExporter,\n        parse: function (object) {\n            var output = '';\n            var indexVertex = 0;\n            var indexVertexUvs = 0;\n            var indexNormals = 0;\n            var vertex = new THREE.Vector3();\n            var normal = new THREE.Vector3();\n            var uv = new THREE.Vector2();\n            var i, j, k, l, m, face = [];\n            var parseMesh = function (mesh) {\n                var nbVertex = 0;\n                var nbNormals = 0;\n                var nbVertexUvs = 0;\n                var geometry = mesh.geometry;\n                var normalMatrixWorld = new THREE.Matrix3();\n                if (geometry instanceof THREE.Geometry) {\n                    geometry = new THREE.BufferGeometry().setFromObject(mesh);\n                }\n                if (geometry instanceof THREE.BufferGeometry) {\n                    var vertices = geometry.getAttribute('position');\n                    var normals = geometry.getAttribute('normal');\n                    var uvs = geometry.getAttribute('uv');\n                    var indices = geometry.getIndex();\n                    output += 'o ' + mesh.name + '\\n';\n                    if (mesh.material && mesh.material.name) {\n                        output += 'usemtl ' + mesh.material.name + '\\n';\n                    }\n                    if (vertices !== undefined) {\n                        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n                            vertex.x = vertices.getX(i);\n                            vertex.y = vertices.getY(i);\n                            vertex.z = vertices.getZ(i);\n                            vertex.applyMatrix4(mesh.matrixWorld);\n                            output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n                        }\n                    }\n                    if (uvs !== undefined) {\n                        for (i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n                            uv.x = uvs.getX(i);\n                            uv.y = uvs.getY(i);\n                            output += 'vt ' + uv.x + ' ' + uv.y + '\\n';\n                        }\n                    }\n                    if (normals !== undefined) {\n                        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n                        for (i = 0, l = normals.count; i < l; i++, nbNormals++) {\n                            normal.x = normals.getX(i);\n                            normal.y = normals.getY(i);\n                            normal.z = normals.getZ(i);\n                            normal.applyMatrix3(normalMatrixWorld).normalize();\n                            output += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n                        }\n                    }\n                    if (indices !== null) {\n                        for (i = 0, l = indices.count; i < l; i += 3) {\n                            for (m = 0; m < 3; m++) {\n                                j = indices.getX(i + m) + 1;\n                                face[m] = indexVertex + j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + j : '') + (normals ? '/' + (indexNormals + j) : '') : '');\n                            }\n                            output += 'f ' + face.join(' ') + '\\n';\n                        }\n                    } else {\n                        for (i = 0, l = vertices.count; i < l; i += 3) {\n                            for (m = 0; m < 3; m++) {\n                                j = i + m + 1;\n                                face[m] = indexVertex + j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + j : '') + (normals ? '/' + (indexNormals + j) : '') : '');\n                            }\n                            output += 'f ' + face.join(' ') + '\\n';\n                        }\n                    }\n                } else {\n                    console.warn('THREE.OBJExporter.parseMesh(): geometry type unsupported', geometry);\n                }\n                indexVertex += nbVertex;\n                indexVertexUvs += nbVertexUvs;\n                indexNormals += nbNormals;\n            };\n            var parseLine = function (line) {\n                var nbVertex = 0;\n                var geometry = line.geometry;\n                var type = line.type;\n                if (geometry instanceof THREE.Geometry) {\n                    geometry = new THREE.BufferGeometry().setFromObject(line);\n                }\n                if (geometry instanceof THREE.BufferGeometry) {\n                    var vertices = geometry.getAttribute('position');\n                    output += 'o ' + line.name + '\\n';\n                    if (vertices !== undefined) {\n                        for (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n                            vertex.x = vertices.getX(i);\n                            vertex.y = vertices.getY(i);\n                            vertex.z = vertices.getZ(i);\n                            vertex.applyMatrix4(line.matrixWorld);\n                            output += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n                        }\n                    }\n                    if (type === 'Line') {\n                        output += 'l ';\n                        for (j = 1, l = vertices.count; j <= l; j++) {\n                            output += indexVertex + j + ' ';\n                        }\n                        output += '\\n';\n                    }\n                    if (type === 'LineSegments') {\n                        for (j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n                            output += 'l ' + (indexVertex + j) + ' ' + (indexVertex + k) + '\\n';\n                        }\n                    }\n                } else {\n                    console.warn('THREE.OBJExporter.parseLine(): geometry type unsupported', geometry);\n                }\n                indexVertex += nbVertex;\n            };\n            object.traverse(function (child) {\n                if (child instanceof THREE.Mesh) {\n                    parseMesh(child);\n                }\n                if (child instanceof THREE.Line) {\n                    parseLine(child);\n                }\n            });\n            return output;\n        }\n    };\n\n    return OBJExporter;\n});"]}