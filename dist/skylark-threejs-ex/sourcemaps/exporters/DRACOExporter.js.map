{"version":3,"sources":["exporters/DRACOExporter.js"],"names":["define","THREE","threex","DRACOExporter","prototype","constructor","parse","geometry","options","undefined","DracoEncoderModule","Error","decodeSpeed","encodeSpeed","encoderMethod","MESH_EDGEBREAKER_ENCODING","quantization","exportUvs","exportNormals","exportColor","dracoEncoder","encoder","Encoder","builder","MeshBuilder","mesh","Mesh","isGeometry","bufferGeometry","BufferGeometry","fromGeometry","isBufferGeometry","vertices","getAttribute","AddFloatAttributeToMesh","POSITION","count","itemSize","array","faces","getIndex","AddFacesToMesh","Uint32Array","Uint16Array","i","length","normals","NORMAL","uvs","TEX_COORD","colors","COLOR","encodedData","DracoInt8Array","SetSpeedOptions","SetEncodingMethod","SetAttributeQuantization","EncodeMeshToDracoBuffer","destroy","outputData","Int8Array","ArrayBuffer","GetValue","MESH_SEQUENTIAL_ENCODING","POINT_CLOUD","TRIANGULAR_MESH","INVALID","GENERIC","exporters"],"mappings":"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","file":"../../exporters/DRACOExporter.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    var DRACOExporter = function () {\n    };\n    DRACOExporter.prototype = {\n        constructor: DRACOExporter,\n        parse: function (geometry, options) {\n            if (DracoEncoderModule === undefined) {\n                throw new Error('THREE.DRACOExporter: required the draco_decoder to work.');\n            }\n            if (options === undefined) {\n                options = {\n                    decodeSpeed: 5,\n                    encodeSpeed: 5,\n                    encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n                    quantization: [\n                        16,\n                        8,\n                        8,\n                        8,\n                        8\n                    ],\n                    exportUvs: true,\n                    exportNormals: true,\n                    exportColor: false\n                };\n            }\n            var dracoEncoder = DracoEncoderModule();\n            var encoder = new dracoEncoder.Encoder();\n            var builder = new dracoEncoder.MeshBuilder();\n            var mesh = new dracoEncoder.Mesh();\n            if (geometry.isGeometry === true) {\n                var bufferGeometry = new THREE.BufferGeometry();\n                bufferGeometry.fromGeometry(geometry);\n                geometry = bufferGeometry;\n            }\n            if (geometry.isBufferGeometry !== true) {\n                throw new Error('THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.Geometry or BufferGeometry instance.');\n            }\n            var vertices = geometry.getAttribute('position');\n            builder.AddFloatAttributeToMesh(mesh, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n            var faces = geometry.getIndex();\n            if (faces !== null) {\n                builder.AddFacesToMesh(mesh, faces.count, faces.array);\n            } else {\n                var faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n                for (var i = 0; i < faces.length; i++) {\n                    faces[i] = i;\n                }\n                builder.AddFacesToMesh(mesh, vertices.count, faces);\n            }\n            if (options.exportNormals === true) {\n                var normals = geometry.getAttribute('normal');\n                if (normals !== undefined) {\n                    builder.AddFloatAttributeToMesh(mesh, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\n                }\n            }\n            if (options.exportUvs === true) {\n                var uvs = geometry.getAttribute('uv');\n                if (uvs !== undefined) {\n                    builder.AddFloatAttributeToMesh(mesh, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n                }\n            }\n            if (options.exportColor === true) {\n                var colors = geometry.getAttribute('color');\n                if (colors !== undefined) {\n                    builder.AddFloatAttributeToMesh(mesh, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n                }\n            }\n            var encodedData = new dracoEncoder.DracoInt8Array();\n            encoder.SetSpeedOptions(options.encodeSpeed || 5, options.decodeSpeed || 5);\n            if (options.encoderMethod !== undefined) {\n                encoder.SetEncodingMethod(options.encoderMethod);\n            }\n            if (options.quantization !== undefined) {\n                for (var i = 0; i < 5; i++) {\n                    if (options.quantization[i] !== undefined) {\n                        encoder.SetAttributeQuantization(i, options.quantization[i]);\n                    }\n                }\n            }\n            var length = encoder.EncodeMeshToDracoBuffer(mesh, encodedData);\n            dracoEncoder.destroy(mesh);\n            if (length === 0) {\n                throw new Error('THREE.DRACOExporter: Draco encoding failed.');\n            }\n            var outputData = new Int8Array(new ArrayBuffer(length));\n            for (var i = 0; i < length; i++) {\n                outputData[i] = encodedData.GetValue(i);\n            }\n            dracoEncoder.destroy(encodedData);\n            dracoEncoder.destroy(encoder);\n            dracoEncoder.destroy(builder);\n            return outputData;\n        }\n    };\n    DRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;\n    DRACOExporter.MESH_SEQUENTIAL_ENCODING = 0;\n    DRACOExporter.POINT_CLOUD = 0;\n    DRACOExporter.TRIANGULAR_MESH = 1;\n    DRACOExporter.INVALID = -1;\n    DRACOExporter.POSITION = 0;\n    DRACOExporter.NORMAL = 1;\n    DRACOExporter.COLOR = 2;\n    DRACOExporter.TEX_COORD = 3;\n    DRACOExporter.GENERIC = 4;\n\n    return threex.exporters.DRACOExporter = DRACOExporter;\n});"]}