{"version":3,"sources":["exporters/DRACOExporter.js"],"names":["define","THREE","DRACOExporter","prototype","constructor","parse","geometry","options","undefined","DracoEncoderModule","Error","decodeSpeed","encodeSpeed","encoderMethod","MESH_EDGEBREAKER_ENCODING","quantization","exportUvs","exportNormals","exportColor","dracoEncoder","encoder","Encoder","builder","MeshBuilder","mesh","Mesh","isGeometry","bufferGeometry","BufferGeometry","fromGeometry","isBufferGeometry","vertices","getAttribute","AddFloatAttributeToMesh","POSITION","count","itemSize","array","faces","getIndex","AddFacesToMesh","Uint32Array","Uint16Array","i","length","normals","NORMAL","uvs","TEX_COORD","colors","COLOR","encodedData","DracoInt8Array","SetSpeedOptions","SetEncodingMethod","SetAttributeQuantization","EncodeMeshToDracoBuffer","destroy","outputData","Int8Array","ArrayBuffer","GetValue","MESH_SEQUENTIAL_ENCODING","POINT_CLOUD","TRIANGULAR_MESH","INVALID","GENERIC"],"mappings":"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","file":"../../exporters/DRACOExporter.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * Export draco compressed files from threejs geometry objects.\n\t *\n\t * Draco files are compressed and usually are smaller than conventional 3D file formats.\n\t *\n\t * The exporter receives a options object containing\n\t *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\n\t *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\n\t *  - encoderMethod\n\t *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\n\t *  - exportUvs\n\t *  - exportNormals\n\t *\n\t * @class DRACOExporter\n\t * @author tentone\n\t */\n\n\t/* global DracoEncoderModule */\n\n\tTHREE.DRACOExporter = function () {};\n\n\tTHREE.DRACOExporter.prototype = {\n\n\t\tconstructor: THREE.DRACOExporter,\n\n\t\tparse: function ( geometry, options ) {\n\n\n\t\t\tif ( DracoEncoderModule === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.DRACOExporter: required the draco_decoder to work.' );\n\n\t\t\t}\n\n\t\t\tif ( options === undefined ) {\n\n\t\t\t\toptions = {\n\n\t\t\t\t\tdecodeSpeed: 5,\n\t\t\t\t\tencodeSpeed: 5,\n\t\t\t\t\tencoderMethod: THREE.DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n\t\t\t\t\tquantization: [ 16, 8, 8, 8, 8 ],\n\t\t\t\t\texportUvs: true,\n\t\t\t\t\texportNormals: true,\n\t\t\t\t\texportColor: false,\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tvar dracoEncoder = DracoEncoderModule();\n\t\t\tvar encoder = new dracoEncoder.Encoder();\n\t\t\tvar builder = new dracoEncoder.MeshBuilder();\n\t\t\tvar mesh = new dracoEncoder.Mesh();\n\n\t\t\tif ( geometry.isGeometry === true ) {\n\n\t\t\t\tvar bufferGeometry = new THREE.BufferGeometry();\n\t\t\t\tbufferGeometry.fromGeometry( geometry );\n\t\t\t\tgeometry = bufferGeometry;\n\n\t\t\t}\n\n\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.Geometry or THREE.BufferGeometry instance.' );\n\n\t\t\t}\n\n\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\t\t\tbuilder.AddFloatAttributeToMesh( mesh, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array );\n\n\t\t\tvar faces = geometry.getIndex();\n\n\t\t\tif ( faces !== null ) {\n\n\t\t\t\tbuilder.AddFacesToMesh( mesh, faces.count, faces.array );\n\n\t\t\t} else {\n\n\t\t\t\tvar faces = new ( vertices.count > 65535 ? Uint32Array : Uint16Array )( vertices.count );\n\n\t\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\t\tfaces[ i ] = i;\n\n\t\t\t\t}\n\n\t\t\t\tbuilder.AddFacesToMesh( mesh, vertices.count, faces );\n\n\t\t\t}\n\n\t\t\tif ( options.exportNormals === true ) {\n\n\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\n\n\t\t\t\tif ( normals !== undefined ) {\n\n\t\t\t\t\tbuilder.AddFloatAttributeToMesh( mesh, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.exportUvs === true ) {\n\n\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\n\n\t\t\t\tif ( uvs !== undefined ) {\n\n\t\t\t\t\tbuilder.AddFloatAttributeToMesh( mesh, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.exportColor === true ) {\n\n\t\t\t\tvar colors = geometry.getAttribute( 'color' );\n\n\t\t\t\tif ( colors !== undefined ) {\n\n\t\t\t\t\tbuilder.AddFloatAttributeToMesh( mesh, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//Compress using draco encoder\n\n\t\t\tvar encodedData = new dracoEncoder.DracoInt8Array();\n\n\t\t\t//Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n\t\t\tencoder.SetSpeedOptions( options.encodeSpeed || 5, options.decodeSpeed || 5 );\n\n\t\t\t// Sets the desired encoding method for a given geometry.\n\n\t\t\tif ( options.encoderMethod !== undefined ) {\n\n\t\t\t\tencoder.SetEncodingMethod( options.encoderMethod );\n\n\t\t\t}\n\n\t\t\t// Sets the quantization (number of bits used to represent) compression options for a named attribute.\n\t\t\t// The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n\t\t\tif ( options.quantization !== undefined ) {\n\n\t\t\t\tfor ( var i = 0; i < 5; i ++ ) {\n\n\t\t\t\t\tif ( options.quantization[ i ] !== undefined ) {\n\n\t\t\t\t\t\tencoder.SetAttributeQuantization( i, options.quantization[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar length = encoder.EncodeMeshToDracoBuffer( mesh, encodedData );\n\t\t\tdracoEncoder.destroy( mesh );\n\n\t\t\tif ( length === 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.DRACOExporter: Draco encoding failed.' );\n\n\t\t\t}\n\n\t\t\t//Copy encoded data to buffer.\n\t\t\tvar outputData = new Int8Array( new ArrayBuffer( length ) );\n\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\toutputData[ i ] = encodedData.GetValue( i );\n\n\t\t\t}\n\n\t\t\tdracoEncoder.destroy( encodedData );\n\t\t\tdracoEncoder.destroy( encoder );\n\t\t\tdracoEncoder.destroy( builder );\n\n\t\t\treturn outputData;\n\n\t\t}\n\n\t};\n\n\t// Encoder methods\n\n\tTHREE.DRACOExporter.MESH_EDGEBREAKER_ENCODING = 1;\n\tTHREE.DRACOExporter.MESH_SEQUENTIAL_ENCODING = 0;\n\n\t// Geometry type\n\n\tTHREE.DRACOExporter.POINT_CLOUD = 0;\n\tTHREE.DRACOExporter.TRIANGULAR_MESH = 1;\n\n\t// Attribute type\n\n\tTHREE.DRACOExporter.INVALID = - 1;\n\tTHREE.DRACOExporter.POSITION = 0;\n\tTHREE.DRACOExporter.NORMAL = 1;\n\tTHREE.DRACOExporter.COLOR = 2;\n\tTHREE.DRACOExporter.TEX_COORD = 3;\n\tTHREE.DRACOExporter.GENERIC = 4;\n\t\n\treturn THREE.DRACOExporter;\n});\n"]}