{"version":3,"sources":["exporters/GLTFExporter.js"],"names":["define","THREE","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","UNSIGNED_BYTE","UNSIGNED_SHORT","FLOAT","UNSIGNED_INT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","THREE_TO_WEBGL","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","PATH_PROPERTIES","scale","position","quaternion","morphTargetInfluences","GLTFExporter","prototype","constructor","parse","input","onDone","options","DEFAULT_OPTIONS","binary","trs","onlyVisible","truncateDrawRange","embedImages","maxTextureSize","Infinity","animations","forceIndices","forcePowerOfTwoTextures","includeCustomExtensions","Object","assign","length","cachedCanvas","outputJSON","asset","version","generator","byteOffset","buffers","pending","nodeMap","Map","skins","extensionsUsed","cachedData","meshes","attributes","attributesNormalized","materials","textures","images","uids","uid","getUID","object","has","set","get","equalArray","array1","array2","every","element","index","getPaddedBufferSize","bufferSize","Math","ceil","getPaddedArrayBuffer","arrayBuffer","paddingByte","paddedLength","byteLength","array","Uint8Array","i","buffer","serializeUserData","gltfProperty","keys","userData","json","JSON","stringify","gltfExtensions","extensionName","undefined","extensions","extras","error","console","warn","name","message","applyTextureTransform","mapDef","texture","didTransform","transformDef","offset","x","y","toArray","rotation","repeat","processBuffer","push","processAccessor","attribute","geometry","start","count","componentType","Float32Array","Uint32Array","Uint16Array","Error","end","end2","drawRange","max","min","bufferViewTarget","minMax","output","Array","itemSize","fill","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","a","value","getMinMax","bufferView","target","componentSize","bufferViews","dataView","DataView","ArrayBuffer","setFloat32","setUint32","setUint16","setUint8","gltfBufferView","byteStride","id","processBufferView","gltfAccessor","type","1","2","3","4","16","accessors","processImage","image","format","flipY","cachedImages","mimeType","RGBAFormat","key","toString","gltfImage","canvas","document","createElement","width","height","MathUtils","isPowerOfTwo","floorPowerOfTwo","ctx","getContext","translate","drawImage","Promise","resolve","toBlob","blob","reader","window","FileReader","readAsArrayBuffer","onloadend","result","processBufferViewImage","then","bufferViewIndex","uri","toDataURL","src","processTexture","map","gltfTexture","sampler","samplers","gltfSampler","magFilter","minFilter","wrapS","wrapT","processSampler","source","processMaterial","material","isShaderMaterial","gltfMaterial","pbrMetallicRoughness","isMeshBasicMaterial","KHR_materials_unlit","isGLTFSpecularGlossinessMaterial","KHR_materials_pbrSpecularGlossiness","isMeshStandardMaterial","color","concat","opacity","baseColorFactor","metallicFactor","metalness","roughnessFactor","roughness","diffuseFactor","specularFactor","specular","glossinessFactor","glossiness","metalnessMap","roughnessMap","metalRoughMapDef","metallicRoughnessTexture","baseColorMapDef","diffuseTexture","baseColorTexture","specularMap","specularMapDef","specularGlossinessTexture","emissive","clone","multiplyScalar","emissiveIntensity","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","texCoord","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","DoubleSide","doubleSided","processMesh","mesh","meshCacheKeyParts","uuid","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","isBufferGeometry","BufferGeometry","setFromObject","gltfMesh","primitives","targets","nameConversion","uv","uv2","skinWeight","skinIndex","originalNormal","getAttribute","normal","v","Vector3","il","abs","fromArray","isNormalizedNormalAttribute","setAttribute","z","setX","normalize","createNormalizedNormalAttribute","modifiedAttribute","attributeName","substr","toUpperCase","test","BufferAttribute","normalized","accessor","weights","targetNames","reverseDictionary","morphTargetDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","j","jl","setXYZ","getX","getY","getZ","isMultiMaterial","groups","didForceIndices","indices","setIndex","materialIndex","primitive","cacheKey","processAnimation","clip","root","tracks","Utils","mergeMorphTargetTracks","channels","track","trackBinding","PropertyBinding","parseTrackName","trackNode","findNode","nodeName","trackProperty","propertyName","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","interpolation","outputItemSize","values","times","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","getInterpolation","InterpolateDiscrete","node","path","processSkin","nodes","rootJoint","bones","joints","inverseBindMatrices","boneInverses","skin","processNode","gltfNode","translation","matrixAutoUpdate","updateMatrix","matrix","elements","String","isMesh","isCamera","camera","cameras","isOrtho","isOrthographicCamera","gltfCamera","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","processCamera","isDirectionalLight","isPointLight","isSpotLight","lights","light","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","processLight","isLight","children","child","visible","nodeIndex","processScene","scene","scenes","gltfScene","objectsWithoutScene","Scene","objects","processObjects","processInput","all","Blob","extensionsUsedList","size","binaryChunk","binaryChunkPrefix","jsonChunk","text","TextEncoder","encode","charCodeAt","stringToArrayBuffer","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","insertKeyframe","time","valueSize","getValueSize","TimeBufferType","ValueBufferType","interpolant","evaluate","slice","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","setInterpolation","InterpolateLinear","mergedTrack","targetCount","targetIndex","sourceInterpolant","keyframeIndex","this"],"mappings":"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","file":"../../exporters/GLTFExporter.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var WEBGL_CONSTANTS = {\n        POINTS: 0,\n        LINES: 1,\n        LINE_LOOP: 2,\n        LINE_STRIP: 3,\n        TRIANGLES: 4,\n        TRIANGLE_STRIP: 5,\n        TRIANGLE_FAN: 6,\n        UNSIGNED_BYTE: 5121,\n        UNSIGNED_SHORT: 5123,\n        FLOAT: 5126,\n        UNSIGNED_INT: 5125,\n        ARRAY_BUFFER: 34962,\n        ELEMENT_ARRAY_BUFFER: 34963,\n        NEAREST: 9728,\n        LINEAR: 9729,\n        NEAREST_MIPMAP_NEAREST: 9984,\n        LINEAR_MIPMAP_NEAREST: 9985,\n        NEAREST_MIPMAP_LINEAR: 9986,\n        LINEAR_MIPMAP_LINEAR: 9987,\n        CLAMP_TO_EDGE: 33071,\n        MIRRORED_REPEAT: 33648,\n        REPEAT: 10497\n    };\n    var THREE_TO_WEBGL = {};\n    THREE_TO_WEBGL[THREE.NearestFilter] = WEBGL_CONSTANTS.NEAREST;\n    THREE_TO_WEBGL[THREE.NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\n    THREE_TO_WEBGL[THREE.NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\n    THREE_TO_WEBGL[THREE.LinearFilter] = WEBGL_CONSTANTS.LINEAR;\n    THREE_TO_WEBGL[THREE.LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\n    THREE_TO_WEBGL[THREE.LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n    THREE_TO_WEBGL[THREE.ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\n    THREE_TO_WEBGL[THREE.RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\n    THREE_TO_WEBGL[THREE.MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n    var PATH_PROPERTIES = {\n        scale: 'scale',\n        position: 'translation',\n        quaternion: 'rotation',\n        morphTargetInfluences: 'weights'\n    };\n    var GLTFExporter = function () {\n    };\n    GLTFExporter.prototype = {\n        constructor: GLTFExporter,\n        parse: function (input, onDone, options) {\n            var DEFAULT_OPTIONS = {\n                binary: false,\n                trs: false,\n                onlyVisible: true,\n                truncateDrawRange: true,\n                embedImages: true,\n                maxTextureSize: Infinity,\n                animations: [],\n                forceIndices: false,\n                forcePowerOfTwoTextures: false,\n                includeCustomExtensions: false\n            };\n            options = Object.assign({}, DEFAULT_OPTIONS, options);\n            if (options.animations.length > 0) {\n                options.trs = true;\n            }\n            var outputJSON = {\n                asset: {\n                    version: '2.0',\n                    generator: 'GLTFExporter'\n                }\n            };\n            var byteOffset = 0;\n            var buffers = [];\n            var pending = [];\n            var nodeMap = new Map();\n            var skins = [];\n            var extensionsUsed = {};\n            var cachedData = {\n                meshes: new Map(),\n                attributes: new Map(),\n                attributesNormalized: new Map(),\n                materials: new Map(),\n                textures: new Map(),\n                images: new Map()\n            };\n            var cachedCanvas;\n            var uids = new Map();\n            var uid = 0;\n            function getUID(object) {\n                if (!uids.has(object))\n                    uids.set(object, uid++);\n                return uids.get(object);\n            }\n            function equalArray(array1, array2) {\n                return array1.length === array2.length && array1.every(function (element, index) {\n                    return element === array2[index];\n                });\n            }\n            function stringToArrayBuffer(text) {\n                if (window.TextEncoder !== undefined) {\n                    return new TextEncoder().encode(text).buffer;\n                }\n                var array = new Uint8Array(new ArrayBuffer(text.length));\n                for (var i = 0, il = text.length; i < il; i++) {\n                    var value = text.charCodeAt(i);\n                    array[i] = value > 255 ? 32 : value;\n                }\n                return array.buffer;\n            }\n            function getMinMax(attribute, start, count) {\n                var output = {\n                    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n                    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n                };\n                for (var i = start; i < start + count; i++) {\n                    for (var a = 0; a < attribute.itemSize; a++) {\n                        var value = attribute.array[i * attribute.itemSize + a];\n                        output.min[a] = Math.min(output.min[a], value);\n                        output.max[a] = Math.max(output.max[a], value);\n                    }\n                }\n                return output;\n            }\n            function isPowerOfTwo(image) {\n                return THREE.MathUtils.isPowerOfTwo(image.width) && THREE.MathUtils.isPowerOfTwo(image.height);\n            }\n            function isNormalizedNormalAttribute(normal) {\n                if (cachedData.attributesNormalized.has(normal)) {\n                    return false;\n                }\n                var v = new THREE.Vector3();\n                for (var i = 0, il = normal.count; i < il; i++) {\n                    if (Math.abs(v.fromArray(normal.array, i * 3).length() - 1) > 0.0005)\n                        return false;\n                }\n                return true;\n            }\n            function createNormalizedNormalAttribute(normal) {\n                if (cachedData.attributesNormalized.has(normal)) {\n                    return cachedData.attributesNormalized.get(normal);\n                }\n                var attribute = normal.clone();\n                var v = new THREE.Vector3();\n                for (var i = 0, il = attribute.count; i < il; i++) {\n                    v.fromArray(attribute.array, i * 3);\n                    if (v.x === 0 && v.y === 0 && v.z === 0) {\n                        v.setX(1);\n                    } else {\n                        v.normalize();\n                    }\n                    v.toArray(attribute.array, i * 3);\n                }\n                cachedData.attributesNormalized.set(normal, attribute);\n                return attribute;\n            }\n            function getPaddedBufferSize(bufferSize) {\n                return Math.ceil(bufferSize / 4) * 4;\n            }\n            function getPaddedArrayBuffer(arrayBuffer, paddingByte) {\n                paddingByte = paddingByte || 0;\n                var paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n                if (paddedLength !== arrayBuffer.byteLength) {\n                    var array = new Uint8Array(paddedLength);\n                    array.set(new Uint8Array(arrayBuffer));\n                    if (paddingByte !== 0) {\n                        for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {\n                            array[i] = paddingByte;\n                        }\n                    }\n                    return array.buffer;\n                }\n                return arrayBuffer;\n            }\n            function serializeUserData(object, gltfProperty) {\n                if (Object.keys(object.userData).length === 0) {\n                    return;\n                }\n                try {\n                    var json = JSON.parse(JSON.stringify(object.userData));\n                    if (options.includeCustomExtensions && json.gltfExtensions) {\n                        if (gltfProperty.extensions === undefined) {\n                            gltfProperty.extensions = {};\n                        }\n                        for (var extensionName in json.gltfExtensions) {\n                            gltfProperty.extensions[extensionName] = json.gltfExtensions[extensionName];\n                            extensionsUsed[extensionName] = true;\n                        }\n                        delete json.gltfExtensions;\n                    }\n                    if (Object.keys(json).length > 0) {\n                        gltfProperty.extras = json;\n                    }\n                } catch (error) {\n                    console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' \" + \"won't be serialized because of JSON.stringify error - \" + error.message);\n                }\n            }\n            function applyTextureTransform(mapDef, texture) {\n                var didTransform = false;\n                var transformDef = {};\n                if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n                    transformDef.offset = texture.offset.toArray();\n                    didTransform = true;\n                }\n                if (texture.rotation !== 0) {\n                    transformDef.rotation = texture.rotation;\n                    didTransform = true;\n                }\n                if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n                    transformDef.scale = texture.repeat.toArray();\n                    didTransform = true;\n                }\n                if (didTransform) {\n                    mapDef.extensions = mapDef.extensions || {};\n                    mapDef.extensions['KHR_texture_transform'] = transformDef;\n                    extensionsUsed['KHR_texture_transform'] = true;\n                }\n            }\n            function processBuffer(buffer) {\n                if (!outputJSON.buffers) {\n                    outputJSON.buffers = [{ byteLength: 0 }];\n                }\n                buffers.push(buffer);\n                return 0;\n            }\n            function processBufferView(attribute, componentType, start, count, target) {\n                if (!outputJSON.bufferViews) {\n                    outputJSON.bufferViews = [];\n                }\n                var componentSize;\n                if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n                    componentSize = 1;\n                } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n                    componentSize = 2;\n                } else {\n                    componentSize = 4;\n                }\n                var byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n                var dataView = new DataView(new ArrayBuffer(byteLength));\n                var offset = 0;\n                for (var i = start; i < start + count; i++) {\n                    for (var a = 0; a < attribute.itemSize; a++) {\n                        var value = attribute.array[i * attribute.itemSize + a];\n                        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n                            dataView.setFloat32(offset, value, true);\n                        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n                            dataView.setUint32(offset, value, true);\n                        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n                            dataView.setUint16(offset, value, true);\n                        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n                            dataView.setUint8(offset, value);\n                        }\n                        offset += componentSize;\n                    }\n                }\n                var gltfBufferView = {\n                    buffer: processBuffer(dataView.buffer),\n                    byteOffset: byteOffset,\n                    byteLength: byteLength\n                };\n                if (target !== undefined)\n                    gltfBufferView.target = target;\n                if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n                    gltfBufferView.byteStride = attribute.itemSize * componentSize;\n                }\n                byteOffset += byteLength;\n                outputJSON.bufferViews.push(gltfBufferView);\n                var output = {\n                    id: outputJSON.bufferViews.length - 1,\n                    byteLength: 0\n                };\n                return output;\n            }\n            function processBufferViewImage(blob) {\n                if (!outputJSON.bufferViews) {\n                    outputJSON.bufferViews = [];\n                }\n                return new Promise(function (resolve) {\n                    var reader = new window.FileReader();\n                    reader.readAsArrayBuffer(blob);\n                    reader.onloadend = function () {\n                        var buffer = getPaddedArrayBuffer(reader.result);\n                        var bufferView = {\n                            buffer: processBuffer(buffer),\n                            byteOffset: byteOffset,\n                            byteLength: buffer.byteLength\n                        };\n                        byteOffset += buffer.byteLength;\n                        outputJSON.bufferViews.push(bufferView);\n                        resolve(outputJSON.bufferViews.length - 1);\n                    };\n                });\n            }\n            function processAccessor(attribute, geometry, start, count) {\n                var types = {\n                    1: 'SCALAR',\n                    2: 'VEC2',\n                    3: 'VEC3',\n                    4: 'VEC4',\n                    16: 'MAT4'\n                };\n                var componentType;\n                if (attribute.array.constructor === Float32Array) {\n                    componentType = WEBGL_CONSTANTS.FLOAT;\n                } else if (attribute.array.constructor === Uint32Array) {\n                    componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n                } else if (attribute.array.constructor === Uint16Array) {\n                    componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n                } else if (attribute.array.constructor === Uint8Array) {\n                    componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n                } else {\n                    throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n                }\n                if (start === undefined)\n                    start = 0;\n                if (count === undefined)\n                    count = attribute.count;\n                if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n                    var end = start + count;\n                    var end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n                    start = Math.max(start, geometry.drawRange.start);\n                    count = Math.min(end, end2) - start;\n                    if (count < 0)\n                        count = 0;\n                }\n                if (count === 0) {\n                    return null;\n                }\n                var minMax = getMinMax(attribute, start, count);\n                var bufferViewTarget;\n                if (geometry !== undefined) {\n                    bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n                }\n                var bufferView = processBufferView(attribute, componentType, start, count, bufferViewTarget);\n                var gltfAccessor = {\n                    bufferView: bufferView.id,\n                    byteOffset: bufferView.byteOffset,\n                    componentType: componentType,\n                    count: count,\n                    max: minMax.max,\n                    min: minMax.min,\n                    type: types[attribute.itemSize]\n                };\n                if (!outputJSON.accessors) {\n                    outputJSON.accessors = [];\n                }\n                outputJSON.accessors.push(gltfAccessor);\n                return outputJSON.accessors.length - 1;\n            }\n            function processImage(image, format, flipY) {\n                if (!cachedData.images.has(image)) {\n                    cachedData.images.set(image, {});\n                }\n                var cachedImages = cachedData.images.get(image);\n                var mimeType = format === THREE.RGBAFormat ? 'image/png' : 'image/jpeg';\n                var key = mimeType + ':flipY/' + flipY.toString();\n                if (cachedImages[key] !== undefined) {\n                    return cachedImages[key];\n                }\n                if (!outputJSON.images) {\n                    outputJSON.images = [];\n                }\n                var gltfImage = { mimeType: mimeType };\n                if (options.embedImages) {\n                    var canvas = cachedCanvas = cachedCanvas || document.createElement('canvas');\n                    canvas.width = Math.min(image.width, options.maxTextureSize);\n                    canvas.height = Math.min(image.height, options.maxTextureSize);\n                    if (options.forcePowerOfTwoTextures && !isPowerOfTwo(canvas)) {\n                        console.warn('GLTFExporter: Resized non-power-of-two image.', image);\n                        canvas.width = THREE.MathUtils.floorPowerOfTwo(canvas.width);\n                        canvas.height = THREE.MathUtils.floorPowerOfTwo(canvas.height);\n                    }\n                    var ctx = canvas.getContext('2d');\n                    if (flipY === true) {\n                        ctx.translate(0, canvas.height);\n                        ctx.scale(1, -1);\n                    }\n                    ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n                    if (options.binary === true) {\n                        pending.push(new Promise(function (resolve) {\n                            canvas.toBlob(function (blob) {\n                                processBufferViewImage(blob).then(function (bufferViewIndex) {\n                                    gltfImage.bufferView = bufferViewIndex;\n                                    resolve();\n                                });\n                            }, mimeType);\n                        }));\n                    } else {\n                        gltfImage.uri = canvas.toDataURL(mimeType);\n                    }\n                } else {\n                    gltfImage.uri = image.src;\n                }\n                outputJSON.images.push(gltfImage);\n                var index = outputJSON.images.length - 1;\n                cachedImages[key] = index;\n                return index;\n            }\n            function processSampler(map) {\n                if (!outputJSON.samplers) {\n                    outputJSON.samplers = [];\n                }\n                var gltfSampler = {\n                    magFilter: THREE_TO_WEBGL[map.magFilter],\n                    minFilter: THREE_TO_WEBGL[map.minFilter],\n                    wrapS: THREE_TO_WEBGL[map.wrapS],\n                    wrapT: THREE_TO_WEBGL[map.wrapT]\n                };\n                outputJSON.samplers.push(gltfSampler);\n                return outputJSON.samplers.length - 1;\n            }\n            function processTexture(map) {\n                if (cachedData.textures.has(map)) {\n                    return cachedData.textures.get(map);\n                }\n                if (!outputJSON.textures) {\n                    outputJSON.textures = [];\n                }\n                var gltfTexture = {\n                    sampler: processSampler(map),\n                    source: processImage(map.image, map.format, map.flipY)\n                };\n                if (map.name) {\n                    gltfTexture.name = map.name;\n                }\n                outputJSON.textures.push(gltfTexture);\n                var index = outputJSON.textures.length - 1;\n                cachedData.textures.set(map, index);\n                return index;\n            }\n            function processMaterial(material) {\n                if (cachedData.materials.has(material)) {\n                    return cachedData.materials.get(material);\n                }\n                if (material.isShaderMaterial) {\n                    console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n                    return null;\n                }\n                if (!outputJSON.materials) {\n                    outputJSON.materials = [];\n                }\n                var gltfMaterial = { pbrMetallicRoughness: {} };\n                if (material.isMeshBasicMaterial) {\n                    gltfMaterial.extensions = { KHR_materials_unlit: {} };\n                    extensionsUsed['KHR_materials_unlit'] = true;\n                } else if (material.isGLTFSpecularGlossinessMaterial) {\n                    gltfMaterial.extensions = { KHR_materials_pbrSpecularGlossiness: {} };\n                    extensionsUsed['KHR_materials_pbrSpecularGlossiness'] = true;\n                } else if (!material.isMeshStandardMaterial) {\n                    console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n                }\n                var color = material.color.toArray().concat([material.opacity]);\n                if (!equalArray(color, [\n                        1,\n                        1,\n                        1,\n                        1\n                    ])) {\n                    gltfMaterial.pbrMetallicRoughness.baseColorFactor = color;\n                }\n                if (material.isMeshStandardMaterial) {\n                    gltfMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;\n                    gltfMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;\n                } else if (material.isMeshBasicMaterial) {\n                    gltfMaterial.pbrMetallicRoughness.metallicFactor = 0;\n                    gltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.9;\n                } else {\n                    gltfMaterial.pbrMetallicRoughness.metallicFactor = 0.5;\n                    gltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.5;\n                }\n                if (material.isGLTFSpecularGlossinessMaterial) {\n                    if (gltfMaterial.pbrMetallicRoughness.baseColorFactor) {\n                        gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor = gltfMaterial.pbrMetallicRoughness.baseColorFactor;\n                    }\n                    var specularFactor = [\n                        1,\n                        1,\n                        1\n                    ];\n                    material.specular.toArray(specularFactor, 0);\n                    gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor = specularFactor;\n                    gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor = material.glossiness;\n                }\n                if (material.metalnessMap || material.roughnessMap) {\n                    if (material.metalnessMap === material.roughnessMap) {\n                        var metalRoughMapDef = { index: processTexture(material.metalnessMap) };\n                        applyTextureTransform(metalRoughMapDef, material.metalnessMap);\n                        gltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n                    } else {\n                        console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\n                    }\n                }\n                if (material.map) {\n                    var baseColorMapDef = { index: processTexture(material.map) };\n                    applyTextureTransform(baseColorMapDef, material.map);\n                    if (material.isGLTFSpecularGlossinessMaterial) {\n                        gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.diffuseTexture = baseColorMapDef;\n                    }\n                    gltfMaterial.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n                }\n                if (material.isGLTFSpecularGlossinessMaterial && material.specularMap) {\n                    var specularMapDef = { index: processTexture(material.specularMap) };\n                    applyTextureTransform(specularMapDef, material.specularMap);\n                    gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.specularGlossinessTexture = specularMapDef;\n                }\n                if (material.emissive) {\n                    var emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity).toArray();\n                    if (!equalArray(emissive, [\n                            0,\n                            0,\n                            0\n                        ])) {\n                        gltfMaterial.emissiveFactor = emissive;\n                    }\n                    if (material.emissiveMap) {\n                        var emissiveMapDef = { index: processTexture(material.emissiveMap) };\n                        applyTextureTransform(emissiveMapDef, material.emissiveMap);\n                        gltfMaterial.emissiveTexture = emissiveMapDef;\n                    }\n                }\n                if (material.normalMap) {\n                    var normalMapDef = { index: processTexture(material.normalMap) };\n                    if (material.normalScale && material.normalScale.x !== -1) {\n                        if (material.normalScale.x !== material.normalScale.y) {\n                            console.warn('THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.');\n                        }\n                        normalMapDef.scale = material.normalScale.x;\n                    }\n                    applyTextureTransform(normalMapDef, material.normalMap);\n                    gltfMaterial.normalTexture = normalMapDef;\n                }\n                if (material.aoMap) {\n                    var occlusionMapDef = {\n                        index: processTexture(material.aoMap),\n                        texCoord: 1\n                    };\n                    if (material.aoMapIntensity !== 1) {\n                        occlusionMapDef.strength = material.aoMapIntensity;\n                    }\n                    applyTextureTransform(occlusionMapDef, material.aoMap);\n                    gltfMaterial.occlusionTexture = occlusionMapDef;\n                }\n                if (material.transparent) {\n                    gltfMaterial.alphaMode = 'BLEND';\n                } else {\n                    if (material.alphaTest > 0) {\n                        gltfMaterial.alphaMode = 'MASK';\n                        gltfMaterial.alphaCutoff = material.alphaTest;\n                    }\n                }\n                if (material.side === THREE.DoubleSide) {\n                    gltfMaterial.doubleSided = true;\n                }\n                if (material.name !== '') {\n                    gltfMaterial.name = material.name;\n                }\n                serializeUserData(material, gltfMaterial);\n                outputJSON.materials.push(gltfMaterial);\n                var index = outputJSON.materials.length - 1;\n                cachedData.materials.set(material, index);\n                return index;\n            }\n            function processMesh(mesh) {\n                var meshCacheKeyParts = [mesh.geometry.uuid];\n                if (Array.isArray(mesh.material)) {\n                    for (var i = 0, l = mesh.material.length; i < l; i++) {\n                        meshCacheKeyParts.push(mesh.material[i].uuid);\n                    }\n                } else {\n                    meshCacheKeyParts.push(mesh.material.uuid);\n                }\n                var meshCacheKey = meshCacheKeyParts.join(':');\n                if (cachedData.meshes.has(meshCacheKey)) {\n                    return cachedData.meshes.get(meshCacheKey);\n                }\n                var geometry = mesh.geometry;\n                var mode;\n                if (mesh.isLineSegments) {\n                    mode = WEBGL_CONSTANTS.LINES;\n                } else if (mesh.isLineLoop) {\n                    mode = WEBGL_CONSTANTS.LINE_LOOP;\n                } else if (mesh.isLine) {\n                    mode = WEBGL_CONSTANTS.LINE_STRIP;\n                } else if (mesh.isPoints) {\n                    mode = WEBGL_CONSTANTS.POINTS;\n                } else {\n                    mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n                }\n                if (!geometry.isBufferGeometry) {\n                    console.warn('GLTFExporter: Exporting THREE.Geometry will increase file size. Use BufferGeometry instead.');\n                    geometry = new THREE.BufferGeometry().setFromObject(mesh);\n                }\n                var gltfMesh = {};\n                var attributes = {};\n                var primitives = [];\n                var targets = [];\n                var nameConversion = {\n                    uv: 'TEXCOORD_0',\n                    uv2: 'TEXCOORD_1',\n                    color: 'COLOR_0',\n                    skinWeight: 'WEIGHTS_0',\n                    skinIndex: 'JOINTS_0'\n                };\n                var originalNormal = geometry.getAttribute('normal');\n                if (originalNormal !== undefined && !isNormalizedNormalAttribute(originalNormal)) {\n                    console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n                    geometry.setAttribute('normal', createNormalizedNormalAttribute(originalNormal));\n                }\n                var modifiedAttribute = null;\n                for (var attributeName in geometry.attributes) {\n                    if (attributeName.substr(0, 5) === 'morph')\n                        continue;\n                    var attribute = geometry.attributes[attributeName];\n                    attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n                    var validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n                    if (!validVertexAttributes.test(attributeName)) {\n                        attributeName = '_' + attributeName;\n                    }\n                    if (cachedData.attributes.has(getUID(attribute))) {\n                        attributes[attributeName] = cachedData.attributes.get(getUID(attribute));\n                        continue;\n                    }\n                    modifiedAttribute = null;\n                    var array = attribute.array;\n                    if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n                        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n                        modifiedAttribute = new THREE.BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n                    }\n                    var accessor = processAccessor(modifiedAttribute || attribute, geometry);\n                    if (accessor !== null) {\n                        attributes[attributeName] = accessor;\n                        cachedData.attributes.set(getUID(attribute), accessor);\n                    }\n                }\n                if (originalNormal !== undefined)\n                    geometry.setAttribute('normal', originalNormal);\n                if (Object.keys(attributes).length === 0) {\n                    return null;\n                }\n                if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n                    var weights = [];\n                    var targetNames = [];\n                    var reverseDictionary = {};\n                    if (mesh.morphTargetDictionary !== undefined) {\n                        for (var key in mesh.morphTargetDictionary) {\n                            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n                        }\n                    }\n                    for (var i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n                        var target = {};\n                        var warned = false;\n                        for (var attributeName in geometry.morphAttributes) {\n                            if (attributeName !== 'position' && attributeName !== 'normal') {\n                                if (!warned) {\n                                    console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n                                    warned = true;\n                                }\n                                continue;\n                            }\n                            var attribute = geometry.morphAttributes[attributeName][i];\n                            var gltfAttributeName = attributeName.toUpperCase();\n                            var baseAttribute = geometry.attributes[attributeName];\n                            if (cachedData.attributes.has(getUID(attribute))) {\n                                target[gltfAttributeName] = cachedData.attributes.get(getUID(attribute));\n                                continue;\n                            }\n                            var relativeAttribute = attribute.clone();\n                            if (!geometry.morphTargetsRelative) {\n                                for (var j = 0, jl = attribute.count; j < jl; j++) {\n                                    relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\n                                }\n                            }\n                            target[gltfAttributeName] = processAccessor(relativeAttribute, geometry);\n                            cachedData.attributes.set(getUID(baseAttribute), target[gltfAttributeName]);\n                        }\n                        targets.push(target);\n                        weights.push(mesh.morphTargetInfluences[i]);\n                        if (mesh.morphTargetDictionary !== undefined)\n                            targetNames.push(reverseDictionary[i]);\n                    }\n                    gltfMesh.weights = weights;\n                    if (targetNames.length > 0) {\n                        gltfMesh.extras = {};\n                        gltfMesh.extras.targetNames = targetNames;\n                    }\n                }\n                var forceIndices = options.forceIndices;\n                var isMultiMaterial = Array.isArray(mesh.material);\n                if (isMultiMaterial && geometry.groups.length === 0)\n                    return null;\n                if (!forceIndices && geometry.index === null && isMultiMaterial) {\n                    console.warn('THREE.GLTFExporter: Creating index for non-indexed multi-material mesh.');\n                    forceIndices = true;\n                }\n                var didForceIndices = false;\n                if (geometry.index === null && forceIndices) {\n                    var indices = [];\n                    for (var i = 0, il = geometry.attributes.position.count; i < il; i++) {\n                        indices[i] = i;\n                    }\n                    geometry.setIndex(indices);\n                    didForceIndices = true;\n                }\n                var materials = isMultiMaterial ? mesh.material : [mesh.material];\n                var groups = isMultiMaterial ? geometry.groups : [{\n                        materialIndex: 0,\n                        start: undefined,\n                        count: undefined\n                    }];\n                for (var i = 0, il = groups.length; i < il; i++) {\n                    var primitive = {\n                        mode: mode,\n                        attributes: attributes\n                    };\n                    serializeUserData(geometry, primitive);\n                    if (targets.length > 0)\n                        primitive.targets = targets;\n                    if (geometry.index !== null) {\n                        var cacheKey = getUID(geometry.index);\n                        if (groups[i].start !== undefined || groups[i].count !== undefined) {\n                            cacheKey += ':' + groups[i].start + ':' + groups[i].count;\n                        }\n                        if (cachedData.attributes.has(cacheKey)) {\n                            primitive.indices = cachedData.attributes.get(cacheKey);\n                        } else {\n                            primitive.indices = processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n                            cachedData.attributes.set(cacheKey, primitive.indices);\n                        }\n                        if (primitive.indices === null)\n                            delete primitive.indices;\n                    }\n                    var material = processMaterial(materials[groups[i].materialIndex]);\n                    if (material !== null) {\n                        primitive.material = material;\n                    }\n                    primitives.push(primitive);\n                }\n                if (didForceIndices) {\n                    geometry.setIndex(null);\n                }\n                gltfMesh.primitives = primitives;\n                if (!outputJSON.meshes) {\n                    outputJSON.meshes = [];\n                }\n                outputJSON.meshes.push(gltfMesh);\n                var index = outputJSON.meshes.length - 1;\n                cachedData.meshes.set(meshCacheKey, index);\n                return index;\n            }\n            function processCamera(camera) {\n                if (!outputJSON.cameras) {\n                    outputJSON.cameras = [];\n                }\n                var isOrtho = camera.isOrthographicCamera;\n                var gltfCamera = { type: isOrtho ? 'orthographic' : 'perspective' };\n                if (isOrtho) {\n                    gltfCamera.orthographic = {\n                        xmag: camera.right * 2,\n                        ymag: camera.top * 2,\n                        zfar: camera.far <= 0 ? 0.001 : camera.far,\n                        znear: camera.near < 0 ? 0 : camera.near\n                    };\n                } else {\n                    gltfCamera.perspective = {\n                        aspectRatio: camera.aspect,\n                        yfov: THREE.MathUtils.degToRad(camera.fov),\n                        zfar: camera.far <= 0 ? 0.001 : camera.far,\n                        znear: camera.near < 0 ? 0 : camera.near\n                    };\n                }\n                if (camera.name !== '') {\n                    gltfCamera.name = camera.type;\n                }\n                outputJSON.cameras.push(gltfCamera);\n                return outputJSON.cameras.length - 1;\n            }\n            function processAnimation(clip, root) {\n                if (!outputJSON.animations) {\n                    outputJSON.animations = [];\n                }\n                clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n                var tracks = clip.tracks;\n                var channels = [];\n                var samplers = [];\n                for (var i = 0; i < tracks.length; ++i) {\n                    var track = tracks[i];\n                    var trackBinding = THREE.PropertyBinding.parseTrackName(track.name);\n                    var trackNode = THREE.PropertyBinding.findNode(root, trackBinding.nodeName);\n                    var trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n                    if (trackBinding.objectName === 'bones') {\n                        if (trackNode.isSkinnedMesh === true) {\n                            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n                        } else {\n                            trackNode = undefined;\n                        }\n                    }\n                    if (!trackNode || !trackProperty) {\n                        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n                        return null;\n                    }\n                    var inputItemSize = 1;\n                    var outputItemSize = track.values.length / track.times.length;\n                    if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n                        outputItemSize /= trackNode.morphTargetInfluences.length;\n                    }\n                    var interpolation;\n                    if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n                        interpolation = 'CUBICSPLINE';\n                        outputItemSize /= 3;\n                    } else if (track.getInterpolation() === THREE.InterpolateDiscrete) {\n                        interpolation = 'STEP';\n                    } else {\n                        interpolation = 'LINEAR';\n                    }\n                    samplers.push({\n                        input: processAccessor(new THREE.BufferAttribute(track.times, inputItemSize)),\n                        output: processAccessor(new THREE.BufferAttribute(track.values, outputItemSize)),\n                        interpolation: interpolation\n                    });\n                    channels.push({\n                        sampler: samplers.length - 1,\n                        target: {\n                            node: nodeMap.get(trackNode),\n                            path: trackProperty\n                        }\n                    });\n                }\n                outputJSON.animations.push({\n                    name: clip.name || 'clip_' + outputJSON.animations.length,\n                    samplers: samplers,\n                    channels: channels\n                });\n                return outputJSON.animations.length - 1;\n            }\n            function processSkin(object) {\n                var node = outputJSON.nodes[nodeMap.get(object)];\n                var skeleton = object.skeleton;\n                if (skeleton === undefined)\n                    return null;\n                var rootJoint = object.skeleton.bones[0];\n                if (rootJoint === undefined)\n                    return null;\n                var joints = [];\n                var inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n                for (var i = 0; i < skeleton.bones.length; ++i) {\n                    joints.push(nodeMap.get(skeleton.bones[i]));\n                    skeleton.boneInverses[i].toArray(inverseBindMatrices, i * 16);\n                }\n                if (outputJSON.skins === undefined) {\n                    outputJSON.skins = [];\n                }\n                outputJSON.skins.push({\n                    inverseBindMatrices: processAccessor(new THREE.BufferAttribute(inverseBindMatrices, 16)),\n                    joints: joints,\n                    skeleton: nodeMap.get(rootJoint)\n                });\n                var skinIndex = node.skin = outputJSON.skins.length - 1;\n                return skinIndex;\n            }\n            function processLight(light) {\n                var lightDef = {};\n                if (light.name)\n                    lightDef.name = light.name;\n                lightDef.color = light.color.toArray();\n                lightDef.intensity = light.intensity;\n                if (light.isDirectionalLight) {\n                    lightDef.type = 'directional';\n                } else if (light.isPointLight) {\n                    lightDef.type = 'point';\n                    if (light.distance > 0)\n                        lightDef.range = light.distance;\n                } else if (light.isSpotLight) {\n                    lightDef.type = 'spot';\n                    if (light.distance > 0)\n                        lightDef.range = light.distance;\n                    lightDef.spot = {};\n                    lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;\n                    lightDef.spot.outerConeAngle = light.angle;\n                }\n                if (light.decay !== undefined && light.decay !== 2) {\n                    console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n                }\n                if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n                    console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n                }\n                var lights = outputJSON.extensions['KHR_lights_punctual'].lights;\n                lights.push(lightDef);\n                return lights.length - 1;\n            }\n            function processNode(object) {\n                if (!outputJSON.nodes) {\n                    outputJSON.nodes = [];\n                }\n                var gltfNode = {};\n                if (options.trs) {\n                    var rotation = object.quaternion.toArray();\n                    var position = object.position.toArray();\n                    var scale = object.scale.toArray();\n                    if (!equalArray(rotation, [\n                            0,\n                            0,\n                            0,\n                            1\n                        ])) {\n                        gltfNode.rotation = rotation;\n                    }\n                    if (!equalArray(position, [\n                            0,\n                            0,\n                            0\n                        ])) {\n                        gltfNode.translation = position;\n                    }\n                    if (!equalArray(scale, [\n                            1,\n                            1,\n                            1\n                        ])) {\n                        gltfNode.scale = scale;\n                    }\n                } else {\n                    if (object.matrixAutoUpdate) {\n                        object.updateMatrix();\n                    }\n                    if (!equalArray(object.matrix.elements, [\n                            1,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1,\n                            0,\n                            0,\n                            0,\n                            0,\n                            1\n                        ])) {\n                        gltfNode.matrix = object.matrix.elements;\n                    }\n                }\n                if (object.name !== '') {\n                    gltfNode.name = String(object.name);\n                }\n                serializeUserData(object, gltfNode);\n                if (object.isMesh || object.isLine || object.isPoints) {\n                    var mesh = processMesh(object);\n                    if (mesh !== null) {\n                        gltfNode.mesh = mesh;\n                    }\n                } else if (object.isCamera) {\n                    gltfNode.camera = processCamera(object);\n                } else if (object.isDirectionalLight || object.isPointLight || object.isSpotLight) {\n                    if (!extensionsUsed['KHR_lights_punctual']) {\n                        outputJSON.extensions = outputJSON.extensions || {};\n                        outputJSON.extensions['KHR_lights_punctual'] = { lights: [] };\n                        extensionsUsed['KHR_lights_punctual'] = true;\n                    }\n                    gltfNode.extensions = gltfNode.extensions || {};\n                    gltfNode.extensions['KHR_lights_punctual'] = { light: processLight(object) };\n                } else if (object.isLight) {\n                    console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', object);\n                    return null;\n                }\n                if (object.isSkinnedMesh) {\n                    skins.push(object);\n                }\n                if (object.children.length > 0) {\n                    var children = [];\n                    for (var i = 0, l = object.children.length; i < l; i++) {\n                        var child = object.children[i];\n                        if (child.visible || options.onlyVisible === false) {\n                            var node = processNode(child);\n                            if (node !== null) {\n                                children.push(node);\n                            }\n                        }\n                    }\n                    if (children.length > 0) {\n                        gltfNode.children = children;\n                    }\n                }\n                outputJSON.nodes.push(gltfNode);\n                var nodeIndex = outputJSON.nodes.length - 1;\n                nodeMap.set(object, nodeIndex);\n                return nodeIndex;\n            }\n            function processScene(scene) {\n                if (!outputJSON.scenes) {\n                    outputJSON.scenes = [];\n                    outputJSON.scene = 0;\n                }\n                var gltfScene = {};\n                if (scene.name !== '') {\n                    gltfScene.name = scene.name;\n                }\n                outputJSON.scenes.push(gltfScene);\n                var nodes = [];\n                for (var i = 0, l = scene.children.length; i < l; i++) {\n                    var child = scene.children[i];\n                    if (child.visible || options.onlyVisible === false) {\n                        var node = processNode(child);\n                        if (node !== null) {\n                            nodes.push(node);\n                        }\n                    }\n                }\n                if (nodes.length > 0) {\n                    gltfScene.nodes = nodes;\n                }\n                serializeUserData(scene, gltfScene);\n            }\n            function processObjects(objects) {\n                var scene = new THREE.Scene();\n                scene.name = 'AuxScene';\n                for (var i = 0; i < objects.length; i++) {\n                    scene.children.push(objects[i]);\n                }\n                processScene(scene);\n            }\n            function processInput(input) {\n                input = input instanceof Array ? input : [input];\n                var objectsWithoutScene = [];\n                for (var i = 0; i < input.length; i++) {\n                    if (input[i] instanceof THREE.Scene) {\n                        processScene(input[i]);\n                    } else {\n                        objectsWithoutScene.push(input[i]);\n                    }\n                }\n                if (objectsWithoutScene.length > 0) {\n                    processObjects(objectsWithoutScene);\n                }\n                for (var i = 0; i < skins.length; ++i) {\n                    processSkin(skins[i]);\n                }\n                for (var i = 0; i < options.animations.length; ++i) {\n                    processAnimation(options.animations[i], input[0]);\n                }\n            }\n            processInput(input);\n            Promise.all(pending).then(function () {\n                var blob = new Blob(buffers, { type: 'application/octet-stream' });\n                var extensionsUsedList = Object.keys(extensionsUsed);\n                if (extensionsUsedList.length > 0)\n                    outputJSON.extensionsUsed = extensionsUsedList;\n                if (outputJSON.buffers && outputJSON.buffers.length > 0)\n                    outputJSON.buffers[0].byteLength = blob.size;\n                if (options.binary === true) {\n                    var GLB_HEADER_BYTES = 12;\n                    var GLB_HEADER_MAGIC = 1179937895;\n                    var GLB_VERSION = 2;\n                    var GLB_CHUNK_PREFIX_BYTES = 8;\n                    var GLB_CHUNK_TYPE_JSON = 1313821514;\n                    var GLB_CHUNK_TYPE_BIN = 5130562;\n                    var reader = new window.FileReader();\n                    reader.readAsArrayBuffer(blob);\n                    reader.onloadend = function () {\n                        var binaryChunk = getPaddedArrayBuffer(reader.result);\n                        var binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n                        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n                        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n                        var jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(outputJSON)), 32);\n                        var jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n                        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n                        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n                        var header = new ArrayBuffer(GLB_HEADER_BYTES);\n                        var headerView = new DataView(header);\n                        headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n                        headerView.setUint32(4, GLB_VERSION, true);\n                        var totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n                        headerView.setUint32(8, totalByteLength, true);\n                        var glbBlob = new Blob([\n                            header,\n                            jsonChunkPrefix,\n                            jsonChunk,\n                            binaryChunkPrefix,\n                            binaryChunk\n                        ], { type: 'application/octet-stream' });\n                        var glbReader = new window.FileReader();\n                        glbReader.readAsArrayBuffer(glbBlob);\n                        glbReader.onloadend = function () {\n                            onDone(glbReader.result);\n                        };\n                    };\n                } else {\n                    if (outputJSON.buffers && outputJSON.buffers.length > 0) {\n                        var reader = new window.FileReader();\n                        reader.readAsDataURL(blob);\n                        reader.onloadend = function () {\n                            var base64data = reader.result;\n                            outputJSON.buffers[0].uri = base64data;\n                            onDone(outputJSON);\n                        };\n                    } else {\n                        onDone(outputJSON);\n                    }\n                }\n            });\n        }\n    };\n    GLTFExporter.Utils = {\n        insertKeyframe: function (track, time) {\n            var tolerance = 0.001;\n            var valueSize = track.getValueSize();\n            var times = new track.TimeBufferType(track.times.length + 1);\n            var values = new track.ValueBufferType(track.values.length + valueSize);\n            var interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n            var index;\n            if (track.times.length === 0) {\n                times[0] = time;\n                for (var i = 0; i < valueSize; i++) {\n                    values[i] = 0;\n                }\n                index = 0;\n            } else if (time < track.times[0]) {\n                if (Math.abs(track.times[0] - time) < tolerance)\n                    return 0;\n                times[0] = time;\n                times.set(track.times, 1);\n                values.set(interpolant.evaluate(time), 0);\n                values.set(track.values, valueSize);\n                index = 0;\n            } else if (time > track.times[track.times.length - 1]) {\n                if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n                    return track.times.length - 1;\n                }\n                times[times.length - 1] = time;\n                times.set(track.times, 0);\n                values.set(track.values, 0);\n                values.set(interpolant.evaluate(time), track.values.length);\n                index = times.length - 1;\n            } else {\n                for (var i = 0; i < track.times.length; i++) {\n                    if (Math.abs(track.times[i] - time) < tolerance)\n                        return i;\n                    if (track.times[i] < time && track.times[i + 1] > time) {\n                        times.set(track.times.slice(0, i + 1), 0);\n                        times[i + 1] = time;\n                        times.set(track.times.slice(i + 1), i + 2);\n                        values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n                        values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n                        values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n                        index = i + 1;\n                        break;\n                    }\n                }\n            }\n            track.times = times;\n            track.values = values;\n            return index;\n        },\n        mergeMorphTargetTracks: function (clip, root) {\n            var tracks = [];\n            var mergedTracks = {};\n            var sourceTracks = clip.tracks;\n            for (var i = 0; i < sourceTracks.length; ++i) {\n                var sourceTrack = sourceTracks[i];\n                var sourceTrackBinding = THREE.PropertyBinding.parseTrackName(sourceTrack.name);\n                var sourceTrackNode = THREE.PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n                if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n                    tracks.push(sourceTrack);\n                    continue;\n                }\n                if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n                    if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n                        throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n                    }\n                    console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n                    sourceTrack = sourceTrack.clone();\n                    sourceTrack.setInterpolation(THREE.InterpolateLinear);\n                }\n                var targetCount = sourceTrackNode.morphTargetInfluences.length;\n                var targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n                if (targetIndex === undefined) {\n                    throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\n                }\n                var mergedTrack;\n                if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n                    mergedTrack = sourceTrack.clone();\n                    var values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n                    for (var j = 0; j < mergedTrack.times.length; j++) {\n                        values[j * targetCount + targetIndex] = mergedTrack.values[j];\n                    }\n                    mergedTrack.name = '.morphTargetInfluences';\n                    mergedTrack.values = values;\n                    mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n                    tracks.push(mergedTrack);\n                    continue;\n                }\n                var sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n                mergedTrack = mergedTracks[sourceTrackNode.uuid];\n                for (var j = 0; j < mergedTrack.times.length; j++) {\n                    mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n                }\n                for (var j = 0; j < sourceTrack.times.length; j++) {\n                    var keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n                    mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n                }\n            }\n            clip.tracks = tracks;\n            return clip;\n        }\n    };\n    return GLTFExporter;\n});"]}