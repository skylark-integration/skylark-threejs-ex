{"version":3,"sources":["exporters/GLTFExporter.js"],"names":["define","THREE","threex","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","UNSIGNED_BYTE","UNSIGNED_SHORT","FLOAT","UNSIGNED_INT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","THREE_TO_WEBGL","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","PATH_PROPERTIES","scale","position","quaternion","morphTargetInfluences","GLTFExporter","prototype","constructor","parse","input","onDone","options","DEFAULT_OPTIONS","binary","trs","onlyVisible","truncateDrawRange","embedImages","maxTextureSize","Infinity","animations","forceIndices","forcePowerOfTwoTextures","includeCustomExtensions","Object","assign","length","cachedCanvas","outputJSON","asset","version","generator","byteOffset","buffers","pending","nodeMap","Map","skins","extensionsUsed","cachedData","meshes","attributes","attributesNormalized","materials","textures","images","uids","uid","getUID","object","has","set","get","equalArray","array1","array2","every","element","index","getPaddedBufferSize","bufferSize","Math","ceil","getPaddedArrayBuffer","arrayBuffer","paddingByte","paddedLength","byteLength","array","Uint8Array","i","buffer","serializeUserData","gltfProperty","keys","userData","json","JSON","stringify","gltfExtensions","extensionName","undefined","extensions","extras","error","console","warn","name","message","applyTextureTransform","mapDef","texture","didTransform","transformDef","offset","x","y","toArray","rotation","repeat","processBuffer","push","processAccessor","attribute","geometry","start","count","componentType","Float32Array","Uint32Array","Uint16Array","Error","end","end2","drawRange","max","min","bufferViewTarget","minMax","output","Array","itemSize","fill","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","a","value","getMinMax","bufferView","target","componentSize","bufferViews","dataView","DataView","ArrayBuffer","setFloat32","setUint32","setUint16","setUint8","gltfBufferView","byteStride","id","processBufferView","gltfAccessor","type","1","2","3","4","16","accessors","processImage","image","format","flipY","cachedImages","mimeType","RGBAFormat","key","toString","gltfImage","canvas","document","createElement","width","height","MathUtils","isPowerOfTwo","floorPowerOfTwo","ctx","getContext","translate","drawImage","Promise","resolve","toBlob","blob","reader","window","FileReader","readAsArrayBuffer","onloadend","result","processBufferViewImage","then","bufferViewIndex","uri","toDataURL","src","processTexture","map","gltfTexture","sampler","samplers","gltfSampler","magFilter","minFilter","wrapS","wrapT","processSampler","source","processMaterial","material","isShaderMaterial","gltfMaterial","pbrMetallicRoughness","isMeshBasicMaterial","KHR_materials_unlit","isGLTFSpecularGlossinessMaterial","KHR_materials_pbrSpecularGlossiness","isMeshStandardMaterial","color","concat","opacity","baseColorFactor","metallicFactor","metalness","roughnessFactor","roughness","diffuseFactor","specularFactor","specular","glossinessFactor","glossiness","metalnessMap","roughnessMap","metalRoughMapDef","metallicRoughnessTexture","baseColorMapDef","diffuseTexture","baseColorTexture","specularMap","specularMapDef","specularGlossinessTexture","emissive","clone","multiplyScalar","emissiveIntensity","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","texCoord","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","DoubleSide","doubleSided","processMesh","mesh","meshCacheKeyParts","uuid","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","isBufferGeometry","BufferGeometry","setFromObject","gltfMesh","primitives","targets","nameConversion","uv","uv2","skinWeight","skinIndex","originalNormal","getAttribute","normal","v","Vector3","il","abs","fromArray","isNormalizedNormalAttribute","setAttribute","z","setX","normalize","createNormalizedNormalAttribute","modifiedAttribute","attributeName","substr","toUpperCase","test","BufferAttribute","normalized","accessor","weights","targetNames","reverseDictionary","morphTargetDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","j","jl","setXYZ","getX","getY","getZ","isMultiMaterial","groups","didForceIndices","indices","setIndex","materialIndex","primitive","cacheKey","processAnimation","clip","root","tracks","Utils","mergeMorphTargetTracks","channels","track","trackBinding","PropertyBinding","parseTrackName","trackNode","findNode","nodeName","trackProperty","propertyName","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","interpolation","outputItemSize","values","times","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","getInterpolation","InterpolateDiscrete","node","path","processSkin","nodes","rootJoint","bones","joints","inverseBindMatrices","boneInverses","skin","processNode","gltfNode","translation","matrixAutoUpdate","updateMatrix","matrix","elements","String","isMesh","isCamera","camera","cameras","isOrtho","isOrthographicCamera","gltfCamera","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","processCamera","isDirectionalLight","isPointLight","isSpotLight","lights","light","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","processLight","isLight","children","child","visible","nodeIndex","processScene","scene","scenes","gltfScene","objectsWithoutScene","Scene","objects","processObjects","processInput","all","Blob","extensionsUsedList","size","binaryChunk","binaryChunkPrefix","jsonChunk","text","TextEncoder","encode","charCodeAt","stringToArrayBuffer","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","insertKeyframe","time","valueSize","getValueSize","TimeBufferType","ValueBufferType","interpolant","evaluate","slice","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","setInterpolation","InterpolateLinear","mergedTrack","targetCount","targetIndex","sourceInterpolant","keyframeIndex","this","exporters"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,IAAIC,GACAC,OAAQ,EACRC,MAAO,EACPC,UAAW,EACXC,WAAY,EACZC,UAAW,EACXC,eAAgB,EAChBC,aAAc,EACdC,cAAe,KACfC,eAAgB,KAChBC,MAAO,KACPC,aAAc,KACdC,aAAc,MACdC,qBAAsB,MACtBC,QAAS,KACTC,OAAQ,KACRC,uBAAwB,KACxBC,sBAAuB,KACvBC,sBAAuB,KACvBC,qBAAsB,KACtBC,cAAe,MACfC,gBAAiB,MACjBC,OAAQ,OAERC,KACJA,EAAezB,EAAM0B,eAAiBxB,EAAgBc,QACtDS,EAAezB,EAAM2B,4BAA8BzB,EAAgBgB,uBACnEO,EAAezB,EAAM4B,2BAA6B1B,EAAgBkB,sBAClEK,EAAezB,EAAM6B,cAAgB3B,EAAgBe,OACrDQ,EAAezB,EAAM8B,2BAA6B5B,EAAgBiB,sBAClEM,EAAezB,EAAM+B,0BAA4B7B,EAAgBmB,qBACjEI,EAAezB,EAAMgC,qBAAuB9B,EAAgBoB,cAC5DG,EAAezB,EAAMiC,gBAAkB/B,EAAgBsB,OACvDC,EAAezB,EAAMkC,wBAA0BhC,EAAgBqB,gBAC/D,IAAIY,GACAC,MAAO,QACPC,SAAU,cACVC,WAAY,WACZC,sBAAuB,WAEvBC,EAAe,aA2oCnB,OAzoCAA,EAAaC,WACTC,YAAaF,EACbG,MAAO,SAAUC,EAAOC,EAAQC,GAC5B,IAAIC,GACAC,QAAQ,EACRC,KAAK,EACLC,aAAa,EACbC,mBAAmB,EACnBC,aAAa,EACbC,eAAgBC,EAAAA,EAChBC,cACAC,cAAc,EACdC,yBAAyB,EACzBC,yBAAyB,IAE7BZ,EAAUa,OAAOC,UAAWb,EAAiBD,IACjCS,WAAWM,OAAS,IAC5Bf,EAAQG,KAAM,GAElB,IAoBIa,EApBAC,GACAC,OACIC,QAAS,MACTC,UAAW,iBAGfC,EAAa,EACbC,KACAC,KACAC,EAAU,IAAIC,IACdC,KACAC,KACAC,GACAC,OAAQ,IAAIJ,IACZK,WAAY,IAAIL,IAChBM,qBAAsB,IAAIN,IAC1BO,UAAW,IAAIP,IACfQ,SAAU,IAAIR,IACdS,OAAQ,IAAIT,KAGZU,EAAO,IAAIV,IACXW,EAAM,EACV,SAASC,EAAOC,GAGZ,OAFKH,EAAKI,IAAID,IACVH,EAAKK,IAAIF,EAAQF,KACdD,EAAKM,IAAIH,GAEpB,SAASI,EAAWC,EAAQC,GACxB,OAAOD,EAAO5B,SAAW6B,EAAO7B,QAAU4B,EAAOE,MAAM,SAAUC,EAASC,GACtE,OAAOD,IAAYF,EAAOG,KA4DlC,SAASC,EAAoBC,GACzB,OAAmC,EAA5BC,KAAKC,KAAKF,EAAa,GAElC,SAASG,EAAqBC,EAAaC,GACvCA,EAAcA,GAAe,EAC7B,IAAIC,EAAeP,EAAoBK,EAAYG,YACnD,GAAID,IAAiBF,EAAYG,WAAY,CACzC,IAAIC,EAAQ,IAAIC,WAAWH,GAE3B,GADAE,EAAMjB,IAAI,IAAIkB,WAAWL,IACL,IAAhBC,EACA,IAAK,IAAIK,EAAIN,EAAYG,WAAYG,EAAIJ,EAAcI,IACnDF,EAAME,GAAKL,EAGnB,OAAOG,EAAMG,OAEjB,OAAOP,EAEX,SAASQ,EAAkBvB,EAAQwB,GAC/B,GAA4C,IAAxCjD,OAAOkD,KAAKzB,EAAO0B,UAAUjD,OAGjC,IACI,IAAIkD,EAAOC,KAAKrE,MAAMqE,KAAKC,UAAU7B,EAAO0B,WAC5C,GAAIhE,EAAQY,yBAA2BqD,EAAKG,eAAgB,CAIxD,IAAK,IAAIC,UAHuBC,IAA5BR,EAAaS,aACbT,EAAaS,eAESN,EAAKG,eAC3BN,EAAaS,WAAWF,GAAiBJ,EAAKG,eAAeC,GAC7D1C,EAAe0C,IAAiB,SAE7BJ,EAAKG,eAEZvD,OAAOkD,KAAKE,GAAMlD,OAAS,IAC3B+C,EAAaU,OAASP,GAE5B,MAAOQ,GACLC,QAAQC,KAAK,oCAAsCrC,EAAOsC,KAAO,2DAAkEH,EAAMI,UAGjJ,SAASC,EAAsBC,EAAQC,GACnC,IAAIC,GAAe,EACfC,KACqB,IAArBF,EAAQG,OAAOC,GAAgC,IAArBJ,EAAQG,OAAOE,IACzCH,EAAaC,OAASH,EAAQG,OAAOG,UACrCL,GAAe,GAEM,IAArBD,EAAQO,WACRL,EAAaK,SAAWP,EAAQO,SAChCN,GAAe,GAEM,IAArBD,EAAQQ,OAAOJ,GAAgC,IAArBJ,EAAQQ,OAAOH,IACzCH,EAAa5F,MAAQ0F,EAAQQ,OAAOF,UACpCL,GAAe,GAEfA,IACAF,EAAOR,WAAaQ,EAAOR,eAC3BQ,EAAOR,WAAkC,sBAAIW,EAC7CvD,EAAsC,uBAAI,GAGlD,SAAS8D,EAAc7B,GAKnB,OAJK3C,EAAWK,UACZL,EAAWK,UAAakC,WAAY,KAExClC,EAAQoE,KAAK9B,GACN,EAsEX,SAAS+B,EAAgBC,EAAWC,EAAUC,EAAOC,GACjD,IAOIC,EACJ,GAAIJ,EAAUnC,MAAM7D,cAAgBqG,aAChCD,EAAgB5I,EAAgBU,WAC7B,GAAI8H,EAAUnC,MAAM7D,cAAgBsG,YACvCF,EAAgB5I,EAAgBW,kBAC7B,GAAI6H,EAAUnC,MAAM7D,cAAgBuG,YACvCH,EAAgB5I,EAAgBS,mBAC7B,CAAA,GAAI+H,EAAUnC,MAAM7D,cAAgB8D,WAGvC,MAAM,IAAI0C,MAAM,mEAFhBJ,EAAgB5I,EAAgBQ,cAQpC,QAJc0G,IAAVwB,IACAA,EAAQ,QACExB,IAAVyB,IACAA,EAAQH,EAAUG,OAClB/F,EAAQK,wBAAkCiE,IAAbuB,GAA6C,OAAnBA,EAAS9C,MAAgB,CAChF,IAAIsD,EAAMP,EAAQC,EACdO,EAAOT,EAASU,UAAUR,QAAUvF,EAAAA,EAAWoF,EAAUG,MAAQF,EAASU,UAAUT,MAAQD,EAASU,UAAUR,MACnHD,EAAQ5C,KAAKsD,IAAIV,EAAOD,EAASU,UAAUT,QAC3CC,EAAQ7C,KAAKuD,IAAIJ,EAAKC,GAAQR,GAClB,IACRC,EAAQ,GAEhB,GAAc,IAAVA,EACA,OAAO,KAEX,IACIW,EADAC,EA1NR,SAAmBf,EAAWE,EAAOC,GAKjC,IAJA,IAAIa,GACAH,IAAK,IAAII,MAAMjB,EAAUkB,UAAUC,KAAKC,OAAOC,mBAC/CT,IAAK,IAAIK,MAAMjB,EAAUkB,UAAUC,KAAKC,OAAOE,oBAE1CvD,EAAImC,EAAOnC,EAAImC,EAAQC,EAAOpC,IACnC,IAAK,IAAIwD,EAAI,EAAGA,EAAIvB,EAAUkB,SAAUK,IAAK,CACzC,IAAIC,EAAQxB,EAAUnC,MAAME,EAAIiC,EAAUkB,SAAWK,GACrDP,EAAOH,IAAIU,GAAKjE,KAAKuD,IAAIG,EAAOH,IAAIU,GAAIC,GACxCR,EAAOJ,IAAIW,GAAKjE,KAAKsD,IAAII,EAAOJ,IAAIW,GAAIC,GAGhD,OAAOR,EA8MMS,CAAUzB,EAAWE,EAAOC,QAExBzB,IAAbuB,IACAa,EAAmBd,IAAcC,EAAS9C,MAAQ3F,EAAgBa,qBAAuBb,EAAgBY,cAE7G,IAAIsJ,EA5GR,SAA2B1B,EAAWI,EAAeF,EAAOC,EAAOwB,GAI/D,IAAIC,EAHCvG,EAAWwG,cACZxG,EAAWwG,gBAIXD,EADAxB,IAAkB5I,EAAgBQ,cAClB,EACToI,IAAkB5I,EAAgBS,eACzB,EAEA,EAKpB,IAHA,IAAI2F,EAAaR,EAAoB+C,EAAQH,EAAUkB,SAAWU,GAC9DE,EAAW,IAAIC,SAAS,IAAIC,YAAYpE,IACxC2B,EAAS,EACJxB,EAAImC,EAAOnC,EAAImC,EAAQC,EAAOpC,IACnC,IAAK,IAAIwD,EAAI,EAAGA,EAAIvB,EAAUkB,SAAUK,IAAK,CACzC,IAAIC,EAAQxB,EAAUnC,MAAME,EAAIiC,EAAUkB,SAAWK,GACjDnB,IAAkB5I,EAAgBU,MAClC4J,EAASG,WAAW1C,EAAQiC,GAAO,GAC5BpB,IAAkB5I,EAAgBW,aACzC2J,EAASI,UAAU3C,EAAQiC,GAAO,GAC3BpB,IAAkB5I,EAAgBS,eACzC6J,EAASK,UAAU5C,EAAQiC,GAAO,GAC3BpB,IAAkB5I,EAAgBQ,eACzC8J,EAASM,SAAS7C,EAAQiC,GAE9BjC,GAAUqC,EAGlB,IAAIS,GACArE,OAAQ6B,EAAciC,EAAS9D,QAC/BvC,WAAYA,EACZmC,WAAYA,GAahB,YAXec,IAAXiD,IACAU,EAAeV,OAASA,GACxBA,IAAWnK,EAAgBY,eAC3BiK,EAAeC,WAAatC,EAAUkB,SAAWU,GAErDnG,GAAcmC,EACdvC,EAAWwG,YAAY/B,KAAKuC,IAExBE,GAAIlH,EAAWwG,YAAY1G,OAAS,EACpCyC,WAAY,GAgEC4E,CAAkBxC,EAAWI,EAAeF,EAAOC,EAAOW,GACvE2B,GACAf,WAAYA,EAAWa,GACvB9G,WAAYiG,EAAWjG,WACvB2E,cAAeA,EACfD,MAAOA,EACPS,IAAKG,EAAOH,IACZC,IAAKE,EAAOF,IACZ6B,MA9CAC,EAAG,SACHC,EAAG,OACHC,EAAG,OACHC,EAAG,OACHC,GAAI,QA0CQ/C,EAAUkB,WAM1B,OAJK7F,EAAW2H,YACZ3H,EAAW2H,cAEf3H,EAAW2H,UAAUlD,KAAK2C,GACnBpH,EAAW2H,UAAU7H,OAAS,EAEzC,SAAS8H,EAAaC,EAAOC,EAAQC,GAC5BpH,EAAWM,OAAOK,IAAIuG,IACvBlH,EAAWM,OAAOM,IAAIsG,MAE1B,IAAIG,EAAerH,EAAWM,OAAOO,IAAIqG,GACrCI,EAAWH,IAAW7L,EAAMiM,WAAa,YAAc,aACvDC,EAAMF,EAAW,UAAYF,EAAMK,WACvC,QAA0B/E,IAAtB2E,EAAaG,GACb,OAAOH,EAAaG,GAEnBnI,EAAWiB,SACZjB,EAAWiB,WAEf,IAAIoH,GAAcJ,SAAUA,GAC5B,GAAIlJ,EAAQM,YAAa,CACrB,IAAIiJ,EAASvI,EAAeA,GAAgBwI,SAASC,cAAc,UACnEF,EAAOG,MAAQxG,KAAKuD,IAAIqC,EAAMY,MAAO1J,EAAQO,gBAC7CgJ,EAAOI,OAASzG,KAAKuD,IAAIqC,EAAMa,OAAQ3J,EAAQO,gBAC3CP,EAAQW,0BAnPpB,SAAsBmI,GAClB,OAAO5L,EAAM0M,UAAUC,aAAaf,EAAMY,QAAUxM,EAAM0M,UAAUC,aAAaf,EAAMa,QAkP3CE,CAAaN,KACjD7E,QAAQC,KAAK,gDAAiDmE,GAC9DS,EAAOG,MAAQxM,EAAM0M,UAAUE,gBAAgBP,EAAOG,OACtDH,EAAOI,OAASzM,EAAM0M,UAAUE,gBAAgBP,EAAOI,SAE3D,IAAII,EAAMR,EAAOS,WAAW,OACd,IAAVhB,IACAe,EAAIE,UAAU,EAAGV,EAAOI,QACxBI,EAAIzK,MAAM,GAAI,IAElByK,EAAIG,UAAUpB,EAAO,EAAG,EAAGS,EAAOG,MAAOH,EAAOI,SACzB,IAAnB3J,EAAQE,OACRqB,EAAQmE,KAAK,IAAIyE,QAAQ,SAAUC,GAC/Bb,EAAOc,OAAO,SAAUC,IA3GxC,SAAgCA,GAI5B,OAHKrJ,EAAWwG,cACZxG,EAAWwG,gBAER,IAAI0C,QAAQ,SAAUC,GACzB,IAAIG,EAAS,IAAIC,OAAOC,WACxBF,EAAOG,kBAAkBJ,GACzBC,EAAOI,UAAY,WACf,IAAI/G,EAASR,EAAqBmH,EAAOK,QACrCtD,GACA1D,OAAQ6B,EAAc7B,GACtBvC,WAAYA,EACZmC,WAAYI,EAAOJ,YAEvBnC,GAAcuC,EAAOJ,WACrBvC,EAAWwG,YAAY/B,KAAK4B,GAC5B8C,EAAQnJ,EAAWwG,YAAY1G,OAAS,OA4FhC8J,CAAuBP,GAAMQ,KAAK,SAAUC,GACxCzB,EAAUhC,WAAayD,EACvBX,OAELlB,MAGPI,EAAU0B,IAAMzB,EAAO0B,UAAU/B,QAGrCI,EAAU0B,IAAMlC,EAAMoC,IAE1BjK,EAAWiB,OAAOwD,KAAK4D,GACvB,IAAIvG,EAAQ9B,EAAWiB,OAAOnB,OAAS,EAEvC,OADAkI,EAAaG,GAAOrG,EACbA,EAeX,SAASoI,EAAeC,GACpB,GAAIxJ,EAAWK,SAASM,IAAI6I,GACxB,OAAOxJ,EAAWK,SAASQ,IAAI2I,GAE9BnK,EAAWgB,WACZhB,EAAWgB,aAEf,IAAIoJ,GACAC,QArBR,SAAwBF,GACfnK,EAAWsK,WACZtK,EAAWsK,aAEf,IAAIC,GACAC,UAAW9M,EAAeyM,EAAIK,WAC9BC,UAAW/M,EAAeyM,EAAIM,WAC9BC,MAAOhN,EAAeyM,EAAIO,OAC1BC,MAAOjN,EAAeyM,EAAIQ,QAG9B,OADA3K,EAAWsK,SAAS7F,KAAK8F,GAClBvK,EAAWsK,SAASxK,OAAS,EAUvB8K,CAAeT,GACxBU,OAAQjD,EAAauC,EAAItC,MAAOsC,EAAIrC,OAAQqC,EAAIpC,QAEhDoC,EAAIxG,OACJyG,EAAYzG,KAAOwG,EAAIxG,MAE3B3D,EAAWgB,SAASyD,KAAK2F,GACzB,IAAItI,EAAQ9B,EAAWgB,SAASlB,OAAS,EAEzC,OADAa,EAAWK,SAASO,IAAI4I,EAAKrI,GACtBA,EAEX,SAASgJ,EAAgBC,GACrB,GAAIpK,EAAWI,UAAUO,IAAIyJ,GACzB,OAAOpK,EAAWI,UAAUS,IAAIuJ,GAEpC,GAAIA,EAASC,iBAET,OADAvH,QAAQC,KAAK,qDACN,KAEN1D,EAAWe,YACZf,EAAWe,cAEf,IAAIkK,GAAiBC,yBACjBH,EAASI,qBACTF,EAAa3H,YAAe8H,wBAC5B1K,EAAoC,qBAAI,GACjCqK,EAASM,kCAChBJ,EAAa3H,YAAegI,wCAC5B5K,EAAoD,qCAAI,GAChDqK,EAASQ,wBACjB9H,QAAQC,KAAK,iFAEjB,IAAI8H,EAAQT,EAASS,MAAMnH,UAAUoH,QAAQV,EAASW,UAmBtD,GAlBKjK,EAAW+J,GACR,EACA,EACA,EACA,MAEJP,EAAaC,qBAAqBS,gBAAkBH,GAEpDT,EAASQ,wBACTN,EAAaC,qBAAqBU,eAAiBb,EAASc,UAC5DZ,EAAaC,qBAAqBY,gBAAkBf,EAASgB,WACtDhB,EAASI,qBAChBF,EAAaC,qBAAqBU,eAAiB,EACnDX,EAAaC,qBAAqBY,gBAAkB,KAEpDb,EAAaC,qBAAqBU,eAAiB,GACnDX,EAAaC,qBAAqBY,gBAAkB,IAEpDf,EAASM,iCAAkC,CACvCJ,EAAaC,qBAAqBS,kBAClCV,EAAa3H,WAAWgI,oCAAoCU,cAAgBf,EAAaC,qBAAqBS,iBAElH,IAAIM,GACA,EACA,EACA,GAEJlB,EAASmB,SAAS7H,QAAQ4H,EAAgB,GAC1ChB,EAAa3H,WAAWgI,oCAAoCW,eAAiBA,EAC7EhB,EAAa3H,WAAWgI,oCAAoCa,iBAAmBpB,EAASqB,WAE5F,GAAIrB,EAASsB,cAAgBtB,EAASuB,aAClC,GAAIvB,EAASsB,eAAiBtB,EAASuB,aAAc,CACjD,IAAIC,GAAqBzK,MAAOoI,EAAea,EAASsB,eACxDxI,EAAsB0I,EAAkBxB,EAASsB,cACjDpB,EAAaC,qBAAqBsB,yBAA2BD,OAE7D9I,QAAQC,KAAK,qGAGrB,GAAIqH,EAASZ,IAAK,CACd,IAAIsC,GAAoB3K,MAAOoI,EAAea,EAASZ,MACvDtG,EAAsB4I,EAAiB1B,EAASZ,KAC5CY,EAASM,mCACTJ,EAAa3H,WAAWgI,oCAAoCoB,eAAiBD,GAEjFxB,EAAaC,qBAAqByB,iBAAmBF,EAEzD,GAAI1B,EAASM,kCAAoCN,EAAS6B,YAAa,CACnE,IAAIC,GAAmB/K,MAAOoI,EAAea,EAAS6B,cACtD/I,EAAsBgJ,EAAgB9B,EAAS6B,aAC/C3B,EAAa3H,WAAWgI,oCAAoCwB,0BAA4BD,EAE5F,GAAI9B,EAASgC,SAAU,CACnB,IAAIA,EAAWhC,EAASgC,SAASC,QAAQC,eAAelC,EAASmC,mBAAmB7I,UAQpF,GAPK5C,EAAWsL,GACR,EACA,EACA,MAEJ9B,EAAakC,eAAiBJ,GAE9BhC,EAASqC,YAAa,CACtB,IAAIC,GAAmBvL,MAAOoI,EAAea,EAASqC,cACtDvJ,EAAsBwJ,EAAgBtC,EAASqC,aAC/CnC,EAAaqC,gBAAkBD,GAGvC,GAAItC,EAASwC,UAAW,CACpB,IAAIC,GAAiB1L,MAAOoI,EAAea,EAASwC,YAChDxC,EAAS0C,cAA2C,IAA5B1C,EAAS0C,YAAYtJ,IACzC4G,EAAS0C,YAAYtJ,IAAM4G,EAAS0C,YAAYrJ,GAChDX,QAAQC,KAAK,0FAEjB8J,EAAanP,MAAQ0M,EAAS0C,YAAYtJ,GAE9CN,EAAsB2J,EAAczC,EAASwC,WAC7CtC,EAAayC,cAAgBF,EAEjC,GAAIzC,EAAS4C,MAAO,CAChB,IAAIC,GACA9L,MAAOoI,EAAea,EAAS4C,OAC/BE,SAAU,GAEkB,IAA5B9C,EAAS+C,iBACTF,EAAgBG,SAAWhD,EAAS+C,gBAExCjK,EAAsB+J,EAAiB7C,EAAS4C,OAChD1C,EAAa+C,iBAAmBJ,EAEhC7C,EAASkD,YACThD,EAAaiD,UAAY,QAErBnD,EAASoD,UAAY,IACrBlD,EAAaiD,UAAY,OACzBjD,EAAamD,YAAcrD,EAASoD,WAGxCpD,EAASsD,OAASpS,EAAMqS,aACxBrD,EAAasD,aAAc,GAET,KAAlBxD,EAASpH,OACTsH,EAAatH,KAAOoH,EAASpH,MAEjCf,EAAkBmI,EAAUE,GAC5BjL,EAAWe,UAAU0D,KAAKwG,GAC1B,IAAInJ,EAAQ9B,EAAWe,UAAUjB,OAAS,EAE1C,OADAa,EAAWI,UAAUQ,IAAIwJ,EAAUjJ,GAC5BA,EAEX,SAAS0M,EAAYC,GACjB,IAAIC,GAAqBD,EAAK7J,SAAS+J,MACvC,GAAI/I,MAAMgJ,QAAQH,EAAK1D,UACnB,IAAK,IAAIrI,EAAI,EAAGmM,EAAIJ,EAAK1D,SAASjL,OAAQ4C,EAAImM,EAAGnM,IAC7CgM,EAAkBjK,KAAKgK,EAAK1D,SAASrI,GAAGiM,WAG5CD,EAAkBjK,KAAKgK,EAAK1D,SAAS4D,MAEzC,IAAIG,EAAeJ,EAAkBK,KAAK,KAC1C,GAAIpO,EAAWC,OAAOU,IAAIwN,GACtB,OAAOnO,EAAWC,OAAOY,IAAIsN,GAEjC,IACIE,EADApK,EAAW6J,EAAK7J,SAGhBoK,EADAP,EAAKQ,eACE9S,EAAgBE,MAChBoS,EAAKS,WACL/S,EAAgBG,UAChBmS,EAAKU,OACLhT,EAAgBI,WAChBkS,EAAKW,SACLjT,EAAgBC,OAEhBqS,EAAK1D,SAASsE,UAAYlT,EAAgBE,MAAQF,EAAgBK,UAExEoI,EAAS0K,mBACV7L,QAAQC,KAAK,+FACbkB,GAAW,IAAI3I,EAAMsT,gBAAiBC,cAAcf,IAExD,IAAIgB,KACA5O,KACA6O,KACAC,KACAC,GACAC,GAAI,aACJC,IAAK,aACLtE,MAAO,UACPuE,WAAY,YACZC,UAAW,YAEXC,EAAiBrL,EAASsL,aAAa,eACpB7M,IAAnB4M,GA7dR,SAAqCE,GACjC,GAAIxP,EAAWG,qBAAqBQ,IAAI6O,GACpC,OAAO,EAGX,IADA,IAAIC,EAAI,IAAInU,EAAMoU,QACT3N,EAAI,EAAG4N,EAAKH,EAAOrL,MAAOpC,EAAI4N,EAAI5N,IACvC,GAAIT,KAAKsO,IAAIH,EAAEI,UAAUL,EAAO3N,MAAW,EAAJE,GAAO5C,SAAW,GAAK,KAC1D,OAAO,EAEf,OAAO,EAod8B2Q,CAA4BR,KAC7DxM,QAAQC,KAAK,yFACbkB,EAAS8L,aAAa,SApd9B,SAAyCP,GACrC,GAAIxP,EAAWG,qBAAqBQ,IAAI6O,GACpC,OAAOxP,EAAWG,qBAAqBU,IAAI2O,GAI/C,IAFA,IAAIxL,EAAYwL,EAAOnD,QACnBoD,EAAI,IAAInU,EAAMoU,QACT3N,EAAI,EAAG4N,EAAK3L,EAAUG,MAAOpC,EAAI4N,EAAI5N,IAC1C0N,EAAEI,UAAU7L,EAAUnC,MAAW,EAAJE,GACjB,IAAR0N,EAAEjM,GAAmB,IAARiM,EAAEhM,GAAmB,IAARgM,EAAEO,EAC5BP,EAAEQ,KAAK,GAEPR,EAAES,YAENT,EAAE/L,QAAQM,EAAUnC,MAAW,EAAJE,GAG/B,OADA/B,EAAWG,qBAAqBS,IAAI4O,EAAQxL,GACrCA,EAoc6BmM,CAAgCb,KAEpE,IAAIc,EAAoB,KACxB,IAAK,IAAIC,KAAiBpM,EAAS/D,WAC/B,GAAmC,UAA/BmQ,EAAcC,OAAO,EAAG,GAA5B,CAEA,IAAItM,EAAYC,EAAS/D,WAAWmQ,GACpCA,EAAgBpB,EAAeoB,IAAkBA,EAAcE,cAK/D,GAJ4B,4EACDC,KAAKH,KAC5BA,EAAgB,IAAMA,GAEtBrQ,EAAWE,WAAWS,IAAIF,EAAOuD,IACjC9D,EAAWmQ,GAAiBrQ,EAAWE,WAAWW,IAAIJ,EAAOuD,QADjE,CAIAoM,EAAoB,KACpB,IAAIvO,EAAQmC,EAAUnC,MACA,aAAlBwO,GAAkCxO,aAAiB0C,aAAkB1C,aAAiBC,aACtFgB,QAAQC,KAAK,yEACbqN,EAAoB,IAAI9U,EAAMmV,gBAAgB,IAAIlM,YAAY1C,GAAQmC,EAAUkB,SAAUlB,EAAU0M,aAExG,IAAIC,EAAW5M,EAAgBqM,GAAqBpM,EAAWC,GAC9C,OAAb0M,IACAzQ,EAAWmQ,GAAiBM,EAC5B3Q,EAAWE,WAAWU,IAAIH,EAAOuD,GAAY2M,KAKrD,QAFuBjO,IAAnB4M,GACArL,EAAS8L,aAAa,SAAUT,GACG,IAAnCrQ,OAAOkD,KAAKjC,GAAYf,OACxB,OAAO,KAEX,QAAmCuD,IAA/BoL,EAAKjQ,uBAAuCiQ,EAAKjQ,sBAAsBsB,OAAS,EAAG,CACnF,IAAIyR,KACAC,KACAC,KACJ,QAAmCpO,IAA/BoL,EAAKiD,sBACL,IAAK,IAAIvJ,KAAOsG,EAAKiD,sBACjBD,EAAkBhD,EAAKiD,sBAAsBvJ,IAAQA,EAG7D,IAASzF,EAAI,EAAGA,EAAI+L,EAAKjQ,sBAAsBsB,SAAU4C,EAAG,CACxD,IAAI4D,KACAqL,GAAS,EACb,IAAK,IAAIX,KAAiBpM,EAASgN,gBAC/B,GAAsB,aAAlBZ,GAAkD,WAAlBA,EAApC,CAOIrM,EAAYC,EAASgN,gBAAgBZ,GAAetO,GAAxD,IACImP,EAAoBb,EAAcE,cAClCY,EAAgBlN,EAAS/D,WAAWmQ,GACxC,GAAIrQ,EAAWE,WAAWS,IAAIF,EAAOuD,IACjC2B,EAAOuL,GAAqBlR,EAAWE,WAAWW,IAAIJ,EAAOuD,QADjE,CAIA,IAAIoN,EAAoBpN,EAAUqI,QAClC,IAAKpI,EAASoN,qBACV,IAAK,IAAIC,EAAI,EAAGC,EAAKvN,EAAUG,MAAOmN,EAAIC,EAAID,IAC1CF,EAAkBI,OAAOF,EAAGtN,EAAUyN,KAAKH,GAAKH,EAAcM,KAAKH,GAAItN,EAAU0N,KAAKJ,GAAKH,EAAcO,KAAKJ,GAAItN,EAAU2N,KAAKL,GAAKH,EAAcQ,KAAKL,IAGjK3L,EAAOuL,GAAqBnN,EAAgBqN,EAAmBnN,GAC/DjE,EAAWE,WAAWU,IAAIH,EAAO0Q,GAAgBxL,EAAOuL,UApB/CF,IACDlO,QAAQC,KAAK,+DACbiO,GAAS,GAoBrBhC,EAAQlL,KAAK6B,GACbiL,EAAQ9M,KAAKgK,EAAKjQ,sBAAsBkE,SACLW,IAA/BoL,EAAKiD,uBACLF,EAAY/M,KAAKgN,EAAkB/O,IAE3C+M,EAAS8B,QAAUA,EACfC,EAAY1R,OAAS,IACrB2P,EAASlM,UACTkM,EAASlM,OAAOiO,YAAcA,GAGtC,IAAI/R,EAAeV,EAAQU,aACvB8S,EAAkB3M,MAAMgJ,QAAQH,EAAK1D,UACzC,GAAIwH,GAA8C,IAA3B3N,EAAS4N,OAAO1S,OACnC,OAAO,MACNL,GAAmC,OAAnBmF,EAAS9C,OAAkByQ,IAC5C9O,QAAQC,KAAK,2EACbjE,GAAe,GAEnB,IAAIgT,GAAkB,EACtB,GAAuB,OAAnB7N,EAAS9C,OAAkBrC,EAAc,CAEzC,IADA,IAAIiT,KACYpC,GAAP5N,EAAI,EAAQkC,EAAS/D,WAAWvC,SAASwG,OAAOpC,EAAI4N,EAAI5N,IAC7DgQ,EAAQhQ,GAAKA,EAEjBkC,EAAS+N,SAASD,GAClBD,GAAkB,EAEtB,IAAI1R,EAAYwR,EAAkB9D,EAAK1D,UAAY0D,EAAK1D,UACpDyH,EAASD,EAAkB3N,EAAS4N,SAChCI,cAAe,EACf/N,WAAOxB,EACPyB,WAAOzB,IAEf,IAASX,EAAI,EAAG4N,EAAKkC,EAAO1S,OAAQ4C,EAAI4N,EAAI5N,IAAK,CAC7C,IAAImQ,GACA7D,KAAMA,EACNnO,WAAYA,GAKhB,GAHA+B,EAAkBgC,EAAUiO,GACxBlD,EAAQ7P,OAAS,IACjB+S,EAAUlD,QAAUA,GACD,OAAnB/K,EAAS9C,MAAgB,CACzB,IAAIgR,EAAW1R,EAAOwD,EAAS9C,YACPuB,IAApBmP,EAAO9P,GAAGmC,YAA2CxB,IAApBmP,EAAO9P,GAAGoC,QAC3CgO,GAAY,IAAMN,EAAO9P,GAAGmC,MAAQ,IAAM2N,EAAO9P,GAAGoC,OAEpDnE,EAAWE,WAAWS,IAAIwR,GAC1BD,EAAUH,QAAU/R,EAAWE,WAAWW,IAAIsR,IAE9CD,EAAUH,QAAUhO,EAAgBE,EAAS9C,MAAO8C,EAAU4N,EAAO9P,GAAGmC,MAAO2N,EAAO9P,GAAGoC,OACzFnE,EAAWE,WAAWU,IAAIuR,EAAUD,EAAUH,UAExB,OAAtBG,EAAUH,gBACHG,EAAUH,QAEzB,IAAI3H,EAAWD,EAAgB/J,EAAUyR,EAAO9P,GAAGkQ,gBAClC,OAAb7H,IACA8H,EAAU9H,SAAWA,GAEzB2E,EAAWjL,KAAKoO,GAEhBJ,GACA7N,EAAS+N,SAAS,MAEtBlD,EAASC,WAAaA,EACjB1P,EAAWY,SACZZ,EAAWY,WAEfZ,EAAWY,OAAO6D,KAAKgL,GACvB,IAAI3N,EAAQ9B,EAAWY,OAAOd,OAAS,EAEvC,OADAa,EAAWC,OAAOW,IAAIuN,EAAchN,GAC7BA,EA6BX,SAASiR,EAAiBC,EAAMC,GACvBjT,EAAWR,aACZQ,EAAWR,eAMf,IAHA,IAAI0T,GADJF,EAAOvU,EAAa0U,MAAMC,uBAAuBJ,EAAKhG,QAASiG,IAC7CC,OACdG,KACA/I,KACK5H,EAAI,EAAGA,EAAIwQ,EAAOpT,SAAU4C,EAAG,CACpC,IAAI4Q,EAAQJ,EAAOxQ,GACf6Q,EAAetX,EAAMuX,gBAAgBC,eAAeH,EAAM3P,MAC1D+P,EAAYzX,EAAMuX,gBAAgBG,SAASV,EAAMM,EAAaK,UAC9DC,EAAgBzV,EAAgBmV,EAAaO,cAQjD,GAPgC,UAA5BP,EAAaQ,aAETL,GAD4B,IAA5BA,EAAUM,cACEN,EAAUO,SAASC,cAAcX,EAAaY,kBAE9C9Q,IAGfqQ,IAAcG,EAEf,OADApQ,QAAQC,KAAK,6DAA8D4P,EAAM3P,MAC1E,KAEX,IAKIyQ,EAJAC,EAAiBf,EAAMgB,OAAOxU,OAASwT,EAAMiB,MAAMzU,OACnD+T,IAAkBzV,EAAgBI,wBAClC6V,GAAkBX,EAAUlV,sBAAsBsB,SAGoB,IAAtEwT,EAAMkB,kBAAkBC,2CACxBL,EAAgB,cAChBC,GAAkB,GAElBD,EADOd,EAAMoB,qBAAuBzY,EAAM0Y,oBAC1B,OAEA,SAEpBrK,EAAS7F,MACL5F,MAAO6F,EAAgB,IAAIzI,EAAMmV,gBAAgBkC,EAAMiB,MAfvC,IAgBhB5O,OAAQjB,EAAgB,IAAIzI,EAAMmV,gBAAgBkC,EAAMgB,OAAQD,IAChED,cAAeA,IAEnBf,EAAS5O,MACL4F,QAASC,EAASxK,OAAS,EAC3BwG,QACIsO,KAAMrU,EAAQiB,IAAIkS,GAClBmB,KAAMhB,KASlB,OALA7T,EAAWR,WAAWiF,MAClBd,KAAMqP,EAAKrP,MAAQ,QAAU3D,EAAWR,WAAWM,OACnDwK,SAAUA,EACV+I,SAAUA,IAEPrT,EAAWR,WAAWM,OAAS,EAE1C,SAASgV,EAAYzT,GACjB,IAAIuT,EAAO5U,EAAW+U,MAAMxU,EAAQiB,IAAIH,IACpC4S,EAAW5S,EAAO4S,SACtB,QAAiB5Q,IAAb4Q,EACA,OAAO,KACX,IAAIe,EAAY3T,EAAO4S,SAASgB,MAAM,GACtC,QAAkB5R,IAAd2R,EACA,OAAO,KAGX,IAFA,IAAIE,KACAC,EAAsB,IAAInQ,aAAqC,GAAxBiP,EAASgB,MAAMnV,QACjD4C,EAAI,EAAGA,EAAIuR,EAASgB,MAAMnV,SAAU4C,EACzCwS,EAAOzQ,KAAKlE,EAAQiB,IAAIyS,EAASgB,MAAMvS,KACvCuR,EAASmB,aAAa1S,GAAG2B,QAAQ8Q,EAAyB,GAAJzS,GAW1D,YATyBW,IAArBrD,EAAWS,QACXT,EAAWS,UAEfT,EAAWS,MAAMgE,MACb0Q,oBAAqBzQ,EAAgB,IAAIzI,EAAMmV,gBAAgB+D,EAAqB,KACpFD,OAAQA,EACRjB,SAAU1T,EAAQiB,IAAIwT,KAEVJ,EAAKS,KAAOrV,EAAWS,MAAMX,OAAS,EAiC1D,SAASwV,EAAYjU,GACZrB,EAAW+U,QACZ/U,EAAW+U,UAEf,IAAIQ,KACJ,GAAIxW,EAAQG,IAAK,CACb,IAAIoF,EAAWjD,EAAO9C,WAAW8F,UAC7B/F,EAAW+C,EAAO/C,SAAS+F,UAC3BhG,EAAQgD,EAAOhD,MAAMgG,UACpB5C,EAAW6C,GACR,EACA,EACA,EACA,MAEJiR,EAASjR,SAAWA,GAEnB7C,EAAWnD,GACR,EACA,EACA,MAEJiX,EAASC,YAAclX,GAEtBmD,EAAWpD,GACR,EACA,EACA,MAEJkX,EAASlX,MAAQA,QAGjBgD,EAAOoU,kBACPpU,EAAOqU,eAENjU,EAAWJ,EAAOsU,OAAOC,UACtB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,MAEJL,EAASI,OAAStU,EAAOsU,OAAOC,UAOxC,GAJoB,KAAhBvU,EAAOsC,OACP4R,EAAS5R,KAAOkS,OAAOxU,EAAOsC,OAElCf,EAAkBvB,EAAQkU,GACtBlU,EAAOyU,QAAUzU,EAAO8N,QAAU9N,EAAO+N,SAAU,CACnD,IAAIX,EAAOD,EAAYnN,GACV,OAAToN,IACA8G,EAAS9G,KAAOA,QAEjB,GAAIpN,EAAO0U,SACdR,EAASS,OA9MjB,SAAuBA,GACdhW,EAAWiW,UACZjW,EAAWiW,YAEf,IAAIC,EAAUF,EAAOG,qBACjBC,GAAe/O,KAAM6O,EAAU,eAAiB,eAoBpD,OAnBIA,EACAE,EAAWC,cACPC,KAAqB,EAAfN,EAAOO,MACbC,KAAmB,EAAbR,EAAOS,IACbC,KAAMV,EAAOW,KAAO,EAAI,KAAQX,EAAOW,IACvCC,MAAOZ,EAAOa,KAAO,EAAI,EAAIb,EAAOa,MAGxCT,EAAWU,aACPC,YAAaf,EAAOgB,OACpBC,KAAMhb,EAAM0M,UAAUuO,SAASlB,EAAOmB,KACtCT,KAAMV,EAAOW,KAAO,EAAI,KAAQX,EAAOW,IACvCC,MAAOZ,EAAOa,KAAO,EAAI,EAAIb,EAAOa,MAGxB,KAAhBb,EAAOrS,OACPyS,EAAWzS,KAAOqS,EAAO3O,MAE7BrH,EAAWiW,QAAQxR,KAAK2R,GACjBpW,EAAWiW,QAAQnW,OAAS,EAqLbsX,CAAc/V,QAC7B,GAAIA,EAAOgW,oBAAsBhW,EAAOiW,cAAgBjW,EAAOkW,YAC7D7W,EAAoC,sBACrCV,EAAWsD,WAAatD,EAAWsD,eACnCtD,EAAWsD,WAAgC,qBAAMkU,WACjD9W,EAAoC,qBAAI,GAE5C6U,EAASjS,WAAaiS,EAASjS,eAC/BiS,EAASjS,WAAgC,qBAAMmU,MAxGvD,SAAsBA,GAClB,IAAIC,KACAD,EAAM9T,OACN+T,EAAS/T,KAAO8T,EAAM9T,MAC1B+T,EAASlM,MAAQiM,EAAMjM,MAAMnH,UAC7BqT,EAASC,UAAYF,EAAME,UACvBF,EAAMJ,mBACNK,EAASrQ,KAAO,cACToQ,EAAMH,cACbI,EAASrQ,KAAO,QACZoQ,EAAMG,SAAW,IACjBF,EAASG,MAAQJ,EAAMG,WACpBH,EAAMF,cACbG,EAASrQ,KAAO,OACZoQ,EAAMG,SAAW,IACjBF,EAASG,MAAQJ,EAAMG,UAC3BF,EAASI,QACTJ,EAASI,KAAKC,gBAAkBN,EAAMO,SAAW,GAAKP,EAAMQ,OAAS,EACrEP,EAASI,KAAKI,eAAiBT,EAAMQ,YAErB5U,IAAhBoU,EAAMU,OAAuC,IAAhBV,EAAMU,OACnC1U,QAAQC,KAAK,sGAEb+T,EAAMnR,QAAWmR,EAAMnR,OAAO8R,SAAWX,GAAqC,IAA5BA,EAAMnR,OAAOhI,SAAS6F,GAAuC,IAA5BsT,EAAMnR,OAAOhI,SAAS8F,IAAwC,IAA7BqT,EAAMnR,OAAOhI,SAASqS,GAC1IlN,QAAQC,KAAK,mIAEjB,IAAI8T,EAASxX,EAAWsD,WAAgC,oBAAEkU,OAE1D,OADAA,EAAO/S,KAAKiT,GACLF,EAAO1X,OAAS,EA4EmCuY,CAAahX,SAChE,GAAIA,EAAOiX,QAEd,OADA7U,QAAQC,KAAK,8EAA+ErC,GACrF,KAKX,GAHIA,EAAO2S,eACPvT,EAAMgE,KAAKpD,GAEXA,EAAOkX,SAASzY,OAAS,EAAG,CAE5B,IADA,IAAIyY,KACK7V,EAAI,EAAGmM,EAAIxN,EAAOkX,SAASzY,OAAQ4C,EAAImM,EAAGnM,IAAK,CACpD,IAAI8V,EAAQnX,EAAOkX,SAAS7V,GAC5B,GAAI8V,EAAMC,UAAmC,IAAxB1Z,EAAQI,YAAuB,CAChD,IAAIyV,EAAOU,EAAYkD,GACV,OAAT5D,GACA2D,EAAS9T,KAAKmQ,IAItB2D,EAASzY,OAAS,IAClByV,EAASgD,SAAWA,GAG5BvY,EAAW+U,MAAMtQ,KAAK8Q,GACtB,IAAImD,EAAY1Y,EAAW+U,MAAMjV,OAAS,EAE1C,OADAS,EAAQgB,IAAIF,EAAQqX,GACbA,EAEX,SAASC,EAAaC,GACb5Y,EAAW6Y,SACZ7Y,EAAW6Y,UACX7Y,EAAW4Y,MAAQ,GAEvB,IAAIE,KACe,KAAfF,EAAMjV,OACNmV,EAAUnV,KAAOiV,EAAMjV,MAE3B3D,EAAW6Y,OAAOpU,KAAKqU,GAEvB,IADA,IAAI/D,KACKrS,EAAI,EAAGmM,EAAI+J,EAAML,SAASzY,OAAQ4C,EAAImM,EAAGnM,IAAK,CACnD,IAAI8V,EAAQI,EAAML,SAAS7V,GAC3B,GAAI8V,EAAMC,UAAmC,IAAxB1Z,EAAQI,YAAuB,CAChD,IAAIyV,EAAOU,EAAYkD,GACV,OAAT5D,GACAG,EAAMtQ,KAAKmQ,IAInBG,EAAMjV,OAAS,IACfgZ,EAAU/D,MAAQA,GAEtBnS,EAAkBgW,EAAOE,IAU7B,SAAsBja,GAClBA,EAAQA,aAAiB+G,MAAQ/G,GAASA,GAE1C,IADA,IAAIka,KACKrW,EAAI,EAAGA,EAAI7D,EAAMiB,OAAQ4C,IAC1B7D,EAAM6D,aAAczG,EAAM+c,MAC1BL,EAAa9Z,EAAM6D,IAEnBqW,EAAoBtU,KAAK5F,EAAM6D,IAMvC,IAHIqW,EAAoBjZ,OAAS,GAlBrC,SAAwBmZ,GACpB,IAAIL,EAAQ,IAAI3c,EAAM+c,MACtBJ,EAAMjV,KAAO,WACb,IAAK,IAAIjB,EAAI,EAAGA,EAAIuW,EAAQnZ,OAAQ4C,IAChCkW,EAAML,SAAS9T,KAAKwU,EAAQvW,IAEhCiW,EAAaC,GAaTM,CAAeH,GAEVrW,EAAI,EAAGA,EAAIjC,EAAMX,SAAU4C,EAChCoS,EAAYrU,EAAMiC,IAEtB,IAASA,EAAI,EAAGA,EAAI3D,EAAQS,WAAWM,SAAU4C,EAC7CqQ,EAAiBhU,EAAQS,WAAWkD,GAAI7D,EAAM,IAGtDsa,CAAata,GACbqK,QAAQkQ,IAAI9Y,GAASuJ,KAAK,WACtB,IAAIR,EAAO,IAAIgQ,KAAKhZ,GAAWgH,KAAM,6BACjCiS,EAAqB1Z,OAAOkD,KAAKpC,GAKrC,GAJI4Y,EAAmBxZ,OAAS,IAC5BE,EAAWU,eAAiB4Y,GAC5BtZ,EAAWK,SAAWL,EAAWK,QAAQP,OAAS,IAClDE,EAAWK,QAAQ,GAAGkC,WAAa8G,EAAKkQ,OACrB,IAAnBxa,EAAQE,OAAiB,EAOrBqK,EAAS,IAAIC,OAAOC,YACjBC,kBAAkBJ,GACzBC,EAAOI,UAAY,WACf,IAAI8P,EAAcrX,EAAqBmH,EAAOK,QAC1C8P,EAAoB,IAAI/S,SAAS,IAAIC,YAPhB,IAQzB8S,EAAkB5S,UAAU,EAAG2S,EAAYjX,YAAY,GACvDkX,EAAkB5S,UAAU,EAPP,SAO8B,GACnD,IAAI6S,EAAYvX,EAv8B5B,SAA6BwX,GACzB,QAA2BtW,IAAvBkG,OAAOqQ,YACP,OAAO,IAAIA,aAAcC,OAAOF,GAAMhX,OAG1C,IADA,IAAIH,EAAQ,IAAIC,WAAW,IAAIkE,YAAYgT,EAAK7Z,SACvC4C,EAAI,EAAG4N,EAAKqJ,EAAK7Z,OAAQ4C,EAAI4N,EAAI5N,IAAK,CAC3C,IAAIyD,EAAQwT,EAAKG,WAAWpX,GAC5BF,EAAME,GAAKyD,EAAQ,IAAM,GAAKA,EAElC,OAAO3D,EAAMG,OA87BgCoX,CAAoB9W,KAAKC,UAAUlD,IAAc,IAClFga,EAAkB,IAAItT,SAAS,IAAIC,YAXd,IAYzBqT,EAAgBnT,UAAU,EAAG6S,EAAUnX,YAAY,GACnDyX,EAAgBnT,UAAU,EAZJ,YAY4B,GAClD,IAAIoT,EAAS,IAAItT,YAjBE,IAkBfuT,EAAa,IAAIxT,SAASuT,GAC9BC,EAAWrT,UAAU,EAlBF,YAkBuB,GAC1CqT,EAAWrT,UAAU,EAlBP,GAkBuB,GACrC,IAAIsT,EArBe,GAqBsBH,EAAgBzX,WAAamX,EAAUnX,WAAakX,EAAkBlX,WAAaiX,EAAYjX,WACxI2X,EAAWrT,UAAU,EAAGsT,GAAiB,GACzC,IAAIC,EAAU,IAAIf,MACdY,EACAD,EACAN,EACAD,EACAD,IACCnS,KAAM,6BACPgT,EAAY,IAAI9Q,OAAOC,WAC3B6Q,EAAU5Q,kBAAkB2Q,GAC5BC,EAAU3Q,UAAY,WAClB5K,EAAOub,EAAU1Q,cAGtB,CAEC,IAAIL,EADR,GAAItJ,EAAWK,SAAWL,EAAWK,QAAQP,OAAS,GAC9CwJ,EAAS,IAAIC,OAAOC,YACjB8Q,cAAcjR,GACrBC,EAAOI,UAAY,WACf,IAAI6Q,EAAajR,EAAOK,OACxB3J,EAAWK,QAAQ,GAAG0J,IAAMwQ,EAC5Bzb,EAAOkB,SAGXlB,EAAOkB,QAM3BvB,EAAa0U,OACTqH,eAAgB,SAAUlH,EAAOmH,GAC7B,IAKI3Y,EAJA4Y,EAAYpH,EAAMqH,eAClBpG,EAAQ,IAAIjB,EAAMsH,eAAetH,EAAMiB,MAAMzU,OAAS,GACtDwU,EAAS,IAAIhB,EAAMuH,gBAAgBvH,EAAMgB,OAAOxU,OAAS4a,GACzDI,EAAcxH,EAAMkB,kBAAkB,IAAIlB,EAAMuH,gBAAgBH,IAEpE,GAA2B,IAAvBpH,EAAMiB,MAAMzU,OAAc,CAC1ByU,EAAM,GAAKkG,EACX,IAAK,IAAI/X,EAAI,EAAGA,EAAIgY,EAAWhY,IAC3B4R,EAAO5R,GAAK,EAEhBZ,EAAQ,OACL,GAAI2Y,EAAOnH,EAAMiB,MAAM,GAAI,CAC9B,GAAItS,KAAKsO,IAAI+C,EAAMiB,MAAM,GAAKkG,GAblB,KAcR,OAAO,EACXlG,EAAM,GAAKkG,EACXlG,EAAMhT,IAAI+R,EAAMiB,MAAO,GACvBD,EAAO/S,IAAIuZ,EAAYC,SAASN,GAAO,GACvCnG,EAAO/S,IAAI+R,EAAMgB,OAAQoG,GACzB5Y,EAAQ,OACL,GAAI2Y,EAAOnH,EAAMiB,MAAMjB,EAAMiB,MAAMzU,OAAS,GAAI,CACnD,GAAImC,KAAKsO,IAAI+C,EAAMiB,MAAMjB,EAAMiB,MAAMzU,OAAS,GAAK2a,GArBvC,KAsBR,OAAOnH,EAAMiB,MAAMzU,OAAS,EAEhCyU,EAAMA,EAAMzU,OAAS,GAAK2a,EAC1BlG,EAAMhT,IAAI+R,EAAMiB,MAAO,GACvBD,EAAO/S,IAAI+R,EAAMgB,OAAQ,GACzBA,EAAO/S,IAAIuZ,EAAYC,SAASN,GAAOnH,EAAMgB,OAAOxU,QACpDgC,EAAQyS,EAAMzU,OAAS,OAEvB,IAAS4C,EAAI,EAAGA,EAAI4Q,EAAMiB,MAAMzU,OAAQ4C,IAAK,CACzC,GAAIT,KAAKsO,IAAI+C,EAAMiB,MAAM7R,GAAK+X,GA/BtB,KAgCJ,OAAO/X,EACX,GAAI4Q,EAAMiB,MAAM7R,GAAK+X,GAAQnH,EAAMiB,MAAM7R,EAAI,GAAK+X,EAAM,CACpDlG,EAAMhT,IAAI+R,EAAMiB,MAAMyG,MAAM,EAAGtY,EAAI,GAAI,GACvC6R,EAAM7R,EAAI,GAAK+X,EACflG,EAAMhT,IAAI+R,EAAMiB,MAAMyG,MAAMtY,EAAI,GAAIA,EAAI,GACxC4R,EAAO/S,IAAI+R,EAAMgB,OAAO0G,MAAM,GAAItY,EAAI,GAAKgY,GAAY,GACvDpG,EAAO/S,IAAIuZ,EAAYC,SAASN,IAAQ/X,EAAI,GAAKgY,GACjDpG,EAAO/S,IAAI+R,EAAMgB,OAAO0G,OAAOtY,EAAI,GAAKgY,IAAahY,EAAI,GAAKgY,GAC9D5Y,EAAQY,EAAI,EACZ,OAMZ,OAFA4Q,EAAMiB,MAAQA,EACdjB,EAAMgB,OAASA,EACRxS,GAEXsR,uBAAwB,SAAUJ,EAAMC,GAIpC,IAHA,IAAIC,KACA+H,KACAC,EAAelI,EAAKE,OACfxQ,EAAI,EAAGA,EAAIwY,EAAapb,SAAU4C,EAAG,CAC1C,IAAIyY,EAAcD,EAAaxY,GAC3B0Y,EAAqBnf,EAAMuX,gBAAgBC,eAAe0H,EAAYxX,MACtE0X,EAAkBpf,EAAMuX,gBAAgBG,SAASV,EAAMmI,EAAmBxH,UAC9E,GAAwC,0BAApCwH,EAAmBtH,mBAAiFzQ,IAArC+X,EAAmBE,cAAtF,CAIA,GAAIH,EAAY3G,oBAAsB2G,EAAYI,kCAAoCJ,EAAY3G,oBAAsB2G,EAAYK,+BAAgC,CAChK,GAAIL,EAAY3G,kBAAkBC,0CAC9B,MAAM,IAAItP,MAAM,gFAEpB1B,QAAQC,KAAK,iGACbyX,EAAcA,EAAYnO,SACdyO,iBAAiBxf,EAAMyf,mBAEvC,IAKIC,EALAC,EAAcP,EAAgB7c,sBAAsBsB,OACpD+b,EAAcR,EAAgB3J,sBAAsB0J,EAAmBE,eAC3E,QAAoBjY,IAAhBwY,EACA,MAAM,IAAI1W,MAAM,oDAAsDiW,EAAmBE,eAG7F,QAA2CjY,IAAvC4X,EAAaI,EAAgB1M,MAAjC,CAYA,IAAImN,EAAoBX,EAAY3G,kBAAkB,IAAI2G,EAAYN,gBAAgB,IACtFc,EAAcV,EAAaI,EAAgB1M,MAC3C,IAASsD,EAAI,EAAGA,EAAI0J,EAAYpH,MAAMzU,OAAQmS,IAC1C0J,EAAYrH,OAAOrC,EAAI2J,EAAcC,GAAeC,EAAkBf,SAASY,EAAYpH,MAAMtC,IAErG,IAASA,EAAI,EAAGA,EAAIkJ,EAAY5G,MAAMzU,OAAQmS,IAAK,CAC/C,IAAI8J,EAAgBC,KAAKxB,eAAemB,EAAaR,EAAY5G,MAAMtC,IACvE0J,EAAYrH,OAAOyH,EAAgBH,EAAcC,GAAeV,EAAY7G,OAAOrC,QAnBvF,CAGI,IADA,IAAIqC,EAAS,KADbqH,EAAcR,EAAYnO,SACG6N,iBAAgBe,EAAcD,EAAYpH,MAAMzU,QACpEmS,EAAI,EAAGA,EAAI0J,EAAYpH,MAAMzU,OAAQmS,IAC1CqC,EAAOrC,EAAI2J,EAAcC,GAAeF,EAAYrH,OAAOrC,GAE/D0J,EAAYhY,KAAO,yBACnBgY,EAAYrH,OAASA,EACrB2G,EAAaI,EAAgB1M,MAAQgN,EACrCzI,EAAOzO,KAAKkX,SA1BZzI,EAAOzO,KAAK0W,GAwCpB,OADAnI,EAAKE,OAASA,EACPF,IAGR9W,EAAO+f,UAAUxd,aAAeA","file":"../../exporters/GLTFExporter.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var WEBGL_CONSTANTS = {\r\n        POINTS: 0,\r\n        LINES: 1,\r\n        LINE_LOOP: 2,\r\n        LINE_STRIP: 3,\r\n        TRIANGLES: 4,\r\n        TRIANGLE_STRIP: 5,\r\n        TRIANGLE_FAN: 6,\r\n        UNSIGNED_BYTE: 5121,\r\n        UNSIGNED_SHORT: 5123,\r\n        FLOAT: 5126,\r\n        UNSIGNED_INT: 5125,\r\n        ARRAY_BUFFER: 34962,\r\n        ELEMENT_ARRAY_BUFFER: 34963,\r\n        NEAREST: 9728,\r\n        LINEAR: 9729,\r\n        NEAREST_MIPMAP_NEAREST: 9984,\r\n        LINEAR_MIPMAP_NEAREST: 9985,\r\n        NEAREST_MIPMAP_LINEAR: 9986,\r\n        LINEAR_MIPMAP_LINEAR: 9987,\r\n        CLAMP_TO_EDGE: 33071,\r\n        MIRRORED_REPEAT: 33648,\r\n        REPEAT: 10497\r\n    };\r\n    var THREE_TO_WEBGL = {};\r\n    THREE_TO_WEBGL[THREE.NearestFilter] = WEBGL_CONSTANTS.NEAREST;\r\n    THREE_TO_WEBGL[THREE.NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\r\n    THREE_TO_WEBGL[THREE.NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\r\n    THREE_TO_WEBGL[THREE.LinearFilter] = WEBGL_CONSTANTS.LINEAR;\r\n    THREE_TO_WEBGL[THREE.LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\r\n    THREE_TO_WEBGL[THREE.LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\r\n    THREE_TO_WEBGL[THREE.ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\r\n    THREE_TO_WEBGL[THREE.RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\r\n    THREE_TO_WEBGL[THREE.MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\r\n    var PATH_PROPERTIES = {\r\n        scale: 'scale',\r\n        position: 'translation',\r\n        quaternion: 'rotation',\r\n        morphTargetInfluences: 'weights'\r\n    };\r\n    var GLTFExporter = function () {\r\n    };\r\n    GLTFExporter.prototype = {\r\n        constructor: GLTFExporter,\r\n        parse: function (input, onDone, options) {\r\n            var DEFAULT_OPTIONS = {\r\n                binary: false,\r\n                trs: false,\r\n                onlyVisible: true,\r\n                truncateDrawRange: true,\r\n                embedImages: true,\r\n                maxTextureSize: Infinity,\r\n                animations: [],\r\n                forceIndices: false,\r\n                forcePowerOfTwoTextures: false,\r\n                includeCustomExtensions: false\r\n            };\r\n            options = Object.assign({}, DEFAULT_OPTIONS, options);\r\n            if (options.animations.length > 0) {\r\n                options.trs = true;\r\n            }\r\n            var outputJSON = {\r\n                asset: {\r\n                    version: '2.0',\r\n                    generator: 'GLTFExporter'\r\n                }\r\n            };\r\n            var byteOffset = 0;\r\n            var buffers = [];\r\n            var pending = [];\r\n            var nodeMap = new Map();\r\n            var skins = [];\r\n            var extensionsUsed = {};\r\n            var cachedData = {\r\n                meshes: new Map(),\r\n                attributes: new Map(),\r\n                attributesNormalized: new Map(),\r\n                materials: new Map(),\r\n                textures: new Map(),\r\n                images: new Map()\r\n            };\r\n            var cachedCanvas;\r\n            var uids = new Map();\r\n            var uid = 0;\r\n            function getUID(object) {\r\n                if (!uids.has(object))\r\n                    uids.set(object, uid++);\r\n                return uids.get(object);\r\n            }\r\n            function equalArray(array1, array2) {\r\n                return array1.length === array2.length && array1.every(function (element, index) {\r\n                    return element === array2[index];\r\n                });\r\n            }\r\n            function stringToArrayBuffer(text) {\r\n                if (window.TextEncoder !== undefined) {\r\n                    return new TextEncoder().encode(text).buffer;\r\n                }\r\n                var array = new Uint8Array(new ArrayBuffer(text.length));\r\n                for (var i = 0, il = text.length; i < il; i++) {\r\n                    var value = text.charCodeAt(i);\r\n                    array[i] = value > 255 ? 32 : value;\r\n                }\r\n                return array.buffer;\r\n            }\r\n            function getMinMax(attribute, start, count) {\r\n                var output = {\r\n                    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\r\n                    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\r\n                };\r\n                for (var i = start; i < start + count; i++) {\r\n                    for (var a = 0; a < attribute.itemSize; a++) {\r\n                        var value = attribute.array[i * attribute.itemSize + a];\r\n                        output.min[a] = Math.min(output.min[a], value);\r\n                        output.max[a] = Math.max(output.max[a], value);\r\n                    }\r\n                }\r\n                return output;\r\n            }\r\n            function isPowerOfTwo(image) {\r\n                return THREE.MathUtils.isPowerOfTwo(image.width) && THREE.MathUtils.isPowerOfTwo(image.height);\r\n            }\r\n            function isNormalizedNormalAttribute(normal) {\r\n                if (cachedData.attributesNormalized.has(normal)) {\r\n                    return false;\r\n                }\r\n                var v = new THREE.Vector3();\r\n                for (var i = 0, il = normal.count; i < il; i++) {\r\n                    if (Math.abs(v.fromArray(normal.array, i * 3).length() - 1) > 0.0005)\r\n                        return false;\r\n                }\r\n                return true;\r\n            }\r\n            function createNormalizedNormalAttribute(normal) {\r\n                if (cachedData.attributesNormalized.has(normal)) {\r\n                    return cachedData.attributesNormalized.get(normal);\r\n                }\r\n                var attribute = normal.clone();\r\n                var v = new THREE.Vector3();\r\n                for (var i = 0, il = attribute.count; i < il; i++) {\r\n                    v.fromArray(attribute.array, i * 3);\r\n                    if (v.x === 0 && v.y === 0 && v.z === 0) {\r\n                        v.setX(1);\r\n                    } else {\r\n                        v.normalize();\r\n                    }\r\n                    v.toArray(attribute.array, i * 3);\r\n                }\r\n                cachedData.attributesNormalized.set(normal, attribute);\r\n                return attribute;\r\n            }\r\n            function getPaddedBufferSize(bufferSize) {\r\n                return Math.ceil(bufferSize / 4) * 4;\r\n            }\r\n            function getPaddedArrayBuffer(arrayBuffer, paddingByte) {\r\n                paddingByte = paddingByte || 0;\r\n                var paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\r\n                if (paddedLength !== arrayBuffer.byteLength) {\r\n                    var array = new Uint8Array(paddedLength);\r\n                    array.set(new Uint8Array(arrayBuffer));\r\n                    if (paddingByte !== 0) {\r\n                        for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {\r\n                            array[i] = paddingByte;\r\n                        }\r\n                    }\r\n                    return array.buffer;\r\n                }\r\n                return arrayBuffer;\r\n            }\r\n            function serializeUserData(object, gltfProperty) {\r\n                if (Object.keys(object.userData).length === 0) {\r\n                    return;\r\n                }\r\n                try {\r\n                    var json = JSON.parse(JSON.stringify(object.userData));\r\n                    if (options.includeCustomExtensions && json.gltfExtensions) {\r\n                        if (gltfProperty.extensions === undefined) {\r\n                            gltfProperty.extensions = {};\r\n                        }\r\n                        for (var extensionName in json.gltfExtensions) {\r\n                            gltfProperty.extensions[extensionName] = json.gltfExtensions[extensionName];\r\n                            extensionsUsed[extensionName] = true;\r\n                        }\r\n                        delete json.gltfExtensions;\r\n                    }\r\n                    if (Object.keys(json).length > 0) {\r\n                        gltfProperty.extras = json;\r\n                    }\r\n                } catch (error) {\r\n                    console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' \" + \"won't be serialized because of JSON.stringify error - \" + error.message);\r\n                }\r\n            }\r\n            function applyTextureTransform(mapDef, texture) {\r\n                var didTransform = false;\r\n                var transformDef = {};\r\n                if (texture.offset.x !== 0 || texture.offset.y !== 0) {\r\n                    transformDef.offset = texture.offset.toArray();\r\n                    didTransform = true;\r\n                }\r\n                if (texture.rotation !== 0) {\r\n                    transformDef.rotation = texture.rotation;\r\n                    didTransform = true;\r\n                }\r\n                if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\r\n                    transformDef.scale = texture.repeat.toArray();\r\n                    didTransform = true;\r\n                }\r\n                if (didTransform) {\r\n                    mapDef.extensions = mapDef.extensions || {};\r\n                    mapDef.extensions['KHR_texture_transform'] = transformDef;\r\n                    extensionsUsed['KHR_texture_transform'] = true;\r\n                }\r\n            }\r\n            function processBuffer(buffer) {\r\n                if (!outputJSON.buffers) {\r\n                    outputJSON.buffers = [{ byteLength: 0 }];\r\n                }\r\n                buffers.push(buffer);\r\n                return 0;\r\n            }\r\n            function processBufferView(attribute, componentType, start, count, target) {\r\n                if (!outputJSON.bufferViews) {\r\n                    outputJSON.bufferViews = [];\r\n                }\r\n                var componentSize;\r\n                if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\r\n                    componentSize = 1;\r\n                } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\r\n                    componentSize = 2;\r\n                } else {\r\n                    componentSize = 4;\r\n                }\r\n                var byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\r\n                var dataView = new DataView(new ArrayBuffer(byteLength));\r\n                var offset = 0;\r\n                for (var i = start; i < start + count; i++) {\r\n                    for (var a = 0; a < attribute.itemSize; a++) {\r\n                        var value = attribute.array[i * attribute.itemSize + a];\r\n                        if (componentType === WEBGL_CONSTANTS.FLOAT) {\r\n                            dataView.setFloat32(offset, value, true);\r\n                        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\r\n                            dataView.setUint32(offset, value, true);\r\n                        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\r\n                            dataView.setUint16(offset, value, true);\r\n                        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\r\n                            dataView.setUint8(offset, value);\r\n                        }\r\n                        offset += componentSize;\r\n                    }\r\n                }\r\n                var gltfBufferView = {\r\n                    buffer: processBuffer(dataView.buffer),\r\n                    byteOffset: byteOffset,\r\n                    byteLength: byteLength\r\n                };\r\n                if (target !== undefined)\r\n                    gltfBufferView.target = target;\r\n                if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\r\n                    gltfBufferView.byteStride = attribute.itemSize * componentSize;\r\n                }\r\n                byteOffset += byteLength;\r\n                outputJSON.bufferViews.push(gltfBufferView);\r\n                var output = {\r\n                    id: outputJSON.bufferViews.length - 1,\r\n                    byteLength: 0\r\n                };\r\n                return output;\r\n            }\r\n            function processBufferViewImage(blob) {\r\n                if (!outputJSON.bufferViews) {\r\n                    outputJSON.bufferViews = [];\r\n                }\r\n                return new Promise(function (resolve) {\r\n                    var reader = new window.FileReader();\r\n                    reader.readAsArrayBuffer(blob);\r\n                    reader.onloadend = function () {\r\n                        var buffer = getPaddedArrayBuffer(reader.result);\r\n                        var bufferView = {\r\n                            buffer: processBuffer(buffer),\r\n                            byteOffset: byteOffset,\r\n                            byteLength: buffer.byteLength\r\n                        };\r\n                        byteOffset += buffer.byteLength;\r\n                        outputJSON.bufferViews.push(bufferView);\r\n                        resolve(outputJSON.bufferViews.length - 1);\r\n                    };\r\n                });\r\n            }\r\n            function processAccessor(attribute, geometry, start, count) {\r\n                var types = {\r\n                    1: 'SCALAR',\r\n                    2: 'VEC2',\r\n                    3: 'VEC3',\r\n                    4: 'VEC4',\r\n                    16: 'MAT4'\r\n                };\r\n                var componentType;\r\n                if (attribute.array.constructor === Float32Array) {\r\n                    componentType = WEBGL_CONSTANTS.FLOAT;\r\n                } else if (attribute.array.constructor === Uint32Array) {\r\n                    componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\r\n                } else if (attribute.array.constructor === Uint16Array) {\r\n                    componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\r\n                } else if (attribute.array.constructor === Uint8Array) {\r\n                    componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\r\n                } else {\r\n                    throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\r\n                }\r\n                if (start === undefined)\r\n                    start = 0;\r\n                if (count === undefined)\r\n                    count = attribute.count;\r\n                if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\r\n                    var end = start + count;\r\n                    var end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\r\n                    start = Math.max(start, geometry.drawRange.start);\r\n                    count = Math.min(end, end2) - start;\r\n                    if (count < 0)\r\n                        count = 0;\r\n                }\r\n                if (count === 0) {\r\n                    return null;\r\n                }\r\n                var minMax = getMinMax(attribute, start, count);\r\n                var bufferViewTarget;\r\n                if (geometry !== undefined) {\r\n                    bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\r\n                }\r\n                var bufferView = processBufferView(attribute, componentType, start, count, bufferViewTarget);\r\n                var gltfAccessor = {\r\n                    bufferView: bufferView.id,\r\n                    byteOffset: bufferView.byteOffset,\r\n                    componentType: componentType,\r\n                    count: count,\r\n                    max: minMax.max,\r\n                    min: minMax.min,\r\n                    type: types[attribute.itemSize]\r\n                };\r\n                if (!outputJSON.accessors) {\r\n                    outputJSON.accessors = [];\r\n                }\r\n                outputJSON.accessors.push(gltfAccessor);\r\n                return outputJSON.accessors.length - 1;\r\n            }\r\n            function processImage(image, format, flipY) {\r\n                if (!cachedData.images.has(image)) {\r\n                    cachedData.images.set(image, {});\r\n                }\r\n                var cachedImages = cachedData.images.get(image);\r\n                var mimeType = format === THREE.RGBAFormat ? 'image/png' : 'image/jpeg';\r\n                var key = mimeType + ':flipY/' + flipY.toString();\r\n                if (cachedImages[key] !== undefined) {\r\n                    return cachedImages[key];\r\n                }\r\n                if (!outputJSON.images) {\r\n                    outputJSON.images = [];\r\n                }\r\n                var gltfImage = { mimeType: mimeType };\r\n                if (options.embedImages) {\r\n                    var canvas = cachedCanvas = cachedCanvas || document.createElement('canvas');\r\n                    canvas.width = Math.min(image.width, options.maxTextureSize);\r\n                    canvas.height = Math.min(image.height, options.maxTextureSize);\r\n                    if (options.forcePowerOfTwoTextures && !isPowerOfTwo(canvas)) {\r\n                        console.warn('GLTFExporter: Resized non-power-of-two image.', image);\r\n                        canvas.width = THREE.MathUtils.floorPowerOfTwo(canvas.width);\r\n                        canvas.height = THREE.MathUtils.floorPowerOfTwo(canvas.height);\r\n                    }\r\n                    var ctx = canvas.getContext('2d');\r\n                    if (flipY === true) {\r\n                        ctx.translate(0, canvas.height);\r\n                        ctx.scale(1, -1);\r\n                    }\r\n                    ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\r\n                    if (options.binary === true) {\r\n                        pending.push(new Promise(function (resolve) {\r\n                            canvas.toBlob(function (blob) {\r\n                                processBufferViewImage(blob).then(function (bufferViewIndex) {\r\n                                    gltfImage.bufferView = bufferViewIndex;\r\n                                    resolve();\r\n                                });\r\n                            }, mimeType);\r\n                        }));\r\n                    } else {\r\n                        gltfImage.uri = canvas.toDataURL(mimeType);\r\n                    }\r\n                } else {\r\n                    gltfImage.uri = image.src;\r\n                }\r\n                outputJSON.images.push(gltfImage);\r\n                var index = outputJSON.images.length - 1;\r\n                cachedImages[key] = index;\r\n                return index;\r\n            }\r\n            function processSampler(map) {\r\n                if (!outputJSON.samplers) {\r\n                    outputJSON.samplers = [];\r\n                }\r\n                var gltfSampler = {\r\n                    magFilter: THREE_TO_WEBGL[map.magFilter],\r\n                    minFilter: THREE_TO_WEBGL[map.minFilter],\r\n                    wrapS: THREE_TO_WEBGL[map.wrapS],\r\n                    wrapT: THREE_TO_WEBGL[map.wrapT]\r\n                };\r\n                outputJSON.samplers.push(gltfSampler);\r\n                return outputJSON.samplers.length - 1;\r\n            }\r\n            function processTexture(map) {\r\n                if (cachedData.textures.has(map)) {\r\n                    return cachedData.textures.get(map);\r\n                }\r\n                if (!outputJSON.textures) {\r\n                    outputJSON.textures = [];\r\n                }\r\n                var gltfTexture = {\r\n                    sampler: processSampler(map),\r\n                    source: processImage(map.image, map.format, map.flipY)\r\n                };\r\n                if (map.name) {\r\n                    gltfTexture.name = map.name;\r\n                }\r\n                outputJSON.textures.push(gltfTexture);\r\n                var index = outputJSON.textures.length - 1;\r\n                cachedData.textures.set(map, index);\r\n                return index;\r\n            }\r\n            function processMaterial(material) {\r\n                if (cachedData.materials.has(material)) {\r\n                    return cachedData.materials.get(material);\r\n                }\r\n                if (material.isShaderMaterial) {\r\n                    console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\r\n                    return null;\r\n                }\r\n                if (!outputJSON.materials) {\r\n                    outputJSON.materials = [];\r\n                }\r\n                var gltfMaterial = { pbrMetallicRoughness: {} };\r\n                if (material.isMeshBasicMaterial) {\r\n                    gltfMaterial.extensions = { KHR_materials_unlit: {} };\r\n                    extensionsUsed['KHR_materials_unlit'] = true;\r\n                } else if (material.isGLTFSpecularGlossinessMaterial) {\r\n                    gltfMaterial.extensions = { KHR_materials_pbrSpecularGlossiness: {} };\r\n                    extensionsUsed['KHR_materials_pbrSpecularGlossiness'] = true;\r\n                } else if (!material.isMeshStandardMaterial) {\r\n                    console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\r\n                }\r\n                var color = material.color.toArray().concat([material.opacity]);\r\n                if (!equalArray(color, [\r\n                        1,\r\n                        1,\r\n                        1,\r\n                        1\r\n                    ])) {\r\n                    gltfMaterial.pbrMetallicRoughness.baseColorFactor = color;\r\n                }\r\n                if (material.isMeshStandardMaterial) {\r\n                    gltfMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;\r\n                    gltfMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;\r\n                } else if (material.isMeshBasicMaterial) {\r\n                    gltfMaterial.pbrMetallicRoughness.metallicFactor = 0;\r\n                    gltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.9;\r\n                } else {\r\n                    gltfMaterial.pbrMetallicRoughness.metallicFactor = 0.5;\r\n                    gltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.5;\r\n                }\r\n                if (material.isGLTFSpecularGlossinessMaterial) {\r\n                    if (gltfMaterial.pbrMetallicRoughness.baseColorFactor) {\r\n                        gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor = gltfMaterial.pbrMetallicRoughness.baseColorFactor;\r\n                    }\r\n                    var specularFactor = [\r\n                        1,\r\n                        1,\r\n                        1\r\n                    ];\r\n                    material.specular.toArray(specularFactor, 0);\r\n                    gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor = specularFactor;\r\n                    gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor = material.glossiness;\r\n                }\r\n                if (material.metalnessMap || material.roughnessMap) {\r\n                    if (material.metalnessMap === material.roughnessMap) {\r\n                        var metalRoughMapDef = { index: processTexture(material.metalnessMap) };\r\n                        applyTextureTransform(metalRoughMapDef, material.metalnessMap);\r\n                        gltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\r\n                    } else {\r\n                        console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\r\n                    }\r\n                }\r\n                if (material.map) {\r\n                    var baseColorMapDef = { index: processTexture(material.map) };\r\n                    applyTextureTransform(baseColorMapDef, material.map);\r\n                    if (material.isGLTFSpecularGlossinessMaterial) {\r\n                        gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.diffuseTexture = baseColorMapDef;\r\n                    }\r\n                    gltfMaterial.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\r\n                }\r\n                if (material.isGLTFSpecularGlossinessMaterial && material.specularMap) {\r\n                    var specularMapDef = { index: processTexture(material.specularMap) };\r\n                    applyTextureTransform(specularMapDef, material.specularMap);\r\n                    gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.specularGlossinessTexture = specularMapDef;\r\n                }\r\n                if (material.emissive) {\r\n                    var emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity).toArray();\r\n                    if (!equalArray(emissive, [\r\n                            0,\r\n                            0,\r\n                            0\r\n                        ])) {\r\n                        gltfMaterial.emissiveFactor = emissive;\r\n                    }\r\n                    if (material.emissiveMap) {\r\n                        var emissiveMapDef = { index: processTexture(material.emissiveMap) };\r\n                        applyTextureTransform(emissiveMapDef, material.emissiveMap);\r\n                        gltfMaterial.emissiveTexture = emissiveMapDef;\r\n                    }\r\n                }\r\n                if (material.normalMap) {\r\n                    var normalMapDef = { index: processTexture(material.normalMap) };\r\n                    if (material.normalScale && material.normalScale.x !== -1) {\r\n                        if (material.normalScale.x !== material.normalScale.y) {\r\n                            console.warn('THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.');\r\n                        }\r\n                        normalMapDef.scale = material.normalScale.x;\r\n                    }\r\n                    applyTextureTransform(normalMapDef, material.normalMap);\r\n                    gltfMaterial.normalTexture = normalMapDef;\r\n                }\r\n                if (material.aoMap) {\r\n                    var occlusionMapDef = {\r\n                        index: processTexture(material.aoMap),\r\n                        texCoord: 1\r\n                    };\r\n                    if (material.aoMapIntensity !== 1) {\r\n                        occlusionMapDef.strength = material.aoMapIntensity;\r\n                    }\r\n                    applyTextureTransform(occlusionMapDef, material.aoMap);\r\n                    gltfMaterial.occlusionTexture = occlusionMapDef;\r\n                }\r\n                if (material.transparent) {\r\n                    gltfMaterial.alphaMode = 'BLEND';\r\n                } else {\r\n                    if (material.alphaTest > 0) {\r\n                        gltfMaterial.alphaMode = 'MASK';\r\n                        gltfMaterial.alphaCutoff = material.alphaTest;\r\n                    }\r\n                }\r\n                if (material.side === THREE.DoubleSide) {\r\n                    gltfMaterial.doubleSided = true;\r\n                }\r\n                if (material.name !== '') {\r\n                    gltfMaterial.name = material.name;\r\n                }\r\n                serializeUserData(material, gltfMaterial);\r\n                outputJSON.materials.push(gltfMaterial);\r\n                var index = outputJSON.materials.length - 1;\r\n                cachedData.materials.set(material, index);\r\n                return index;\r\n            }\r\n            function processMesh(mesh) {\r\n                var meshCacheKeyParts = [mesh.geometry.uuid];\r\n                if (Array.isArray(mesh.material)) {\r\n                    for (var i = 0, l = mesh.material.length; i < l; i++) {\r\n                        meshCacheKeyParts.push(mesh.material[i].uuid);\r\n                    }\r\n                } else {\r\n                    meshCacheKeyParts.push(mesh.material.uuid);\r\n                }\r\n                var meshCacheKey = meshCacheKeyParts.join(':');\r\n                if (cachedData.meshes.has(meshCacheKey)) {\r\n                    return cachedData.meshes.get(meshCacheKey);\r\n                }\r\n                var geometry = mesh.geometry;\r\n                var mode;\r\n                if (mesh.isLineSegments) {\r\n                    mode = WEBGL_CONSTANTS.LINES;\r\n                } else if (mesh.isLineLoop) {\r\n                    mode = WEBGL_CONSTANTS.LINE_LOOP;\r\n                } else if (mesh.isLine) {\r\n                    mode = WEBGL_CONSTANTS.LINE_STRIP;\r\n                } else if (mesh.isPoints) {\r\n                    mode = WEBGL_CONSTANTS.POINTS;\r\n                } else {\r\n                    mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\r\n                }\r\n                if (!geometry.isBufferGeometry) {\r\n                    console.warn('GLTFExporter: Exporting THREE.Geometry will increase file size. Use BufferGeometry instead.');\r\n                    geometry = new THREE.BufferGeometry().setFromObject(mesh);\r\n                }\r\n                var gltfMesh = {};\r\n                var attributes = {};\r\n                var primitives = [];\r\n                var targets = [];\r\n                var nameConversion = {\r\n                    uv: 'TEXCOORD_0',\r\n                    uv2: 'TEXCOORD_1',\r\n                    color: 'COLOR_0',\r\n                    skinWeight: 'WEIGHTS_0',\r\n                    skinIndex: 'JOINTS_0'\r\n                };\r\n                var originalNormal = geometry.getAttribute('normal');\r\n                if (originalNormal !== undefined && !isNormalizedNormalAttribute(originalNormal)) {\r\n                    console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\r\n                    geometry.setAttribute('normal', createNormalizedNormalAttribute(originalNormal));\r\n                }\r\n                var modifiedAttribute = null;\r\n                for (var attributeName in geometry.attributes) {\r\n                    if (attributeName.substr(0, 5) === 'morph')\r\n                        continue;\r\n                    var attribute = geometry.attributes[attributeName];\r\n                    attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\r\n                    var validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\r\n                    if (!validVertexAttributes.test(attributeName)) {\r\n                        attributeName = '_' + attributeName;\r\n                    }\r\n                    if (cachedData.attributes.has(getUID(attribute))) {\r\n                        attributes[attributeName] = cachedData.attributes.get(getUID(attribute));\r\n                        continue;\r\n                    }\r\n                    modifiedAttribute = null;\r\n                    var array = attribute.array;\r\n                    if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\r\n                        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\r\n                        modifiedAttribute = new THREE.BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\r\n                    }\r\n                    var accessor = processAccessor(modifiedAttribute || attribute, geometry);\r\n                    if (accessor !== null) {\r\n                        attributes[attributeName] = accessor;\r\n                        cachedData.attributes.set(getUID(attribute), accessor);\r\n                    }\r\n                }\r\n                if (originalNormal !== undefined)\r\n                    geometry.setAttribute('normal', originalNormal);\r\n                if (Object.keys(attributes).length === 0) {\r\n                    return null;\r\n                }\r\n                if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\r\n                    var weights = [];\r\n                    var targetNames = [];\r\n                    var reverseDictionary = {};\r\n                    if (mesh.morphTargetDictionary !== undefined) {\r\n                        for (var key in mesh.morphTargetDictionary) {\r\n                            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\r\n                        }\r\n                    }\r\n                    for (var i = 0; i < mesh.morphTargetInfluences.length; ++i) {\r\n                        var target = {};\r\n                        var warned = false;\r\n                        for (var attributeName in geometry.morphAttributes) {\r\n                            if (attributeName !== 'position' && attributeName !== 'normal') {\r\n                                if (!warned) {\r\n                                    console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\r\n                                    warned = true;\r\n                                }\r\n                                continue;\r\n                            }\r\n                            var attribute = geometry.morphAttributes[attributeName][i];\r\n                            var gltfAttributeName = attributeName.toUpperCase();\r\n                            var baseAttribute = geometry.attributes[attributeName];\r\n                            if (cachedData.attributes.has(getUID(attribute))) {\r\n                                target[gltfAttributeName] = cachedData.attributes.get(getUID(attribute));\r\n                                continue;\r\n                            }\r\n                            var relativeAttribute = attribute.clone();\r\n                            if (!geometry.morphTargetsRelative) {\r\n                                for (var j = 0, jl = attribute.count; j < jl; j++) {\r\n                                    relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\r\n                                }\r\n                            }\r\n                            target[gltfAttributeName] = processAccessor(relativeAttribute, geometry);\r\n                            cachedData.attributes.set(getUID(baseAttribute), target[gltfAttributeName]);\r\n                        }\r\n                        targets.push(target);\r\n                        weights.push(mesh.morphTargetInfluences[i]);\r\n                        if (mesh.morphTargetDictionary !== undefined)\r\n                            targetNames.push(reverseDictionary[i]);\r\n                    }\r\n                    gltfMesh.weights = weights;\r\n                    if (targetNames.length > 0) {\r\n                        gltfMesh.extras = {};\r\n                        gltfMesh.extras.targetNames = targetNames;\r\n                    }\r\n                }\r\n                var forceIndices = options.forceIndices;\r\n                var isMultiMaterial = Array.isArray(mesh.material);\r\n                if (isMultiMaterial && geometry.groups.length === 0)\r\n                    return null;\r\n                if (!forceIndices && geometry.index === null && isMultiMaterial) {\r\n                    console.warn('THREE.GLTFExporter: Creating index for non-indexed multi-material mesh.');\r\n                    forceIndices = true;\r\n                }\r\n                var didForceIndices = false;\r\n                if (geometry.index === null && forceIndices) {\r\n                    var indices = [];\r\n                    for (var i = 0, il = geometry.attributes.position.count; i < il; i++) {\r\n                        indices[i] = i;\r\n                    }\r\n                    geometry.setIndex(indices);\r\n                    didForceIndices = true;\r\n                }\r\n                var materials = isMultiMaterial ? mesh.material : [mesh.material];\r\n                var groups = isMultiMaterial ? geometry.groups : [{\r\n                        materialIndex: 0,\r\n                        start: undefined,\r\n                        count: undefined\r\n                    }];\r\n                for (var i = 0, il = groups.length; i < il; i++) {\r\n                    var primitive = {\r\n                        mode: mode,\r\n                        attributes: attributes\r\n                    };\r\n                    serializeUserData(geometry, primitive);\r\n                    if (targets.length > 0)\r\n                        primitive.targets = targets;\r\n                    if (geometry.index !== null) {\r\n                        var cacheKey = getUID(geometry.index);\r\n                        if (groups[i].start !== undefined || groups[i].count !== undefined) {\r\n                            cacheKey += ':' + groups[i].start + ':' + groups[i].count;\r\n                        }\r\n                        if (cachedData.attributes.has(cacheKey)) {\r\n                            primitive.indices = cachedData.attributes.get(cacheKey);\r\n                        } else {\r\n                            primitive.indices = processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\r\n                            cachedData.attributes.set(cacheKey, primitive.indices);\r\n                        }\r\n                        if (primitive.indices === null)\r\n                            delete primitive.indices;\r\n                    }\r\n                    var material = processMaterial(materials[groups[i].materialIndex]);\r\n                    if (material !== null) {\r\n                        primitive.material = material;\r\n                    }\r\n                    primitives.push(primitive);\r\n                }\r\n                if (didForceIndices) {\r\n                    geometry.setIndex(null);\r\n                }\r\n                gltfMesh.primitives = primitives;\r\n                if (!outputJSON.meshes) {\r\n                    outputJSON.meshes = [];\r\n                }\r\n                outputJSON.meshes.push(gltfMesh);\r\n                var index = outputJSON.meshes.length - 1;\r\n                cachedData.meshes.set(meshCacheKey, index);\r\n                return index;\r\n            }\r\n            function processCamera(camera) {\r\n                if (!outputJSON.cameras) {\r\n                    outputJSON.cameras = [];\r\n                }\r\n                var isOrtho = camera.isOrthographicCamera;\r\n                var gltfCamera = { type: isOrtho ? 'orthographic' : 'perspective' };\r\n                if (isOrtho) {\r\n                    gltfCamera.orthographic = {\r\n                        xmag: camera.right * 2,\r\n                        ymag: camera.top * 2,\r\n                        zfar: camera.far <= 0 ? 0.001 : camera.far,\r\n                        znear: camera.near < 0 ? 0 : camera.near\r\n                    };\r\n                } else {\r\n                    gltfCamera.perspective = {\r\n                        aspectRatio: camera.aspect,\r\n                        yfov: THREE.MathUtils.degToRad(camera.fov),\r\n                        zfar: camera.far <= 0 ? 0.001 : camera.far,\r\n                        znear: camera.near < 0 ? 0 : camera.near\r\n                    };\r\n                }\r\n                if (camera.name !== '') {\r\n                    gltfCamera.name = camera.type;\r\n                }\r\n                outputJSON.cameras.push(gltfCamera);\r\n                return outputJSON.cameras.length - 1;\r\n            }\r\n            function processAnimation(clip, root) {\r\n                if (!outputJSON.animations) {\r\n                    outputJSON.animations = [];\r\n                }\r\n                clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\r\n                var tracks = clip.tracks;\r\n                var channels = [];\r\n                var samplers = [];\r\n                for (var i = 0; i < tracks.length; ++i) {\r\n                    var track = tracks[i];\r\n                    var trackBinding = THREE.PropertyBinding.parseTrackName(track.name);\r\n                    var trackNode = THREE.PropertyBinding.findNode(root, trackBinding.nodeName);\r\n                    var trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\r\n                    if (trackBinding.objectName === 'bones') {\r\n                        if (trackNode.isSkinnedMesh === true) {\r\n                            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\r\n                        } else {\r\n                            trackNode = undefined;\r\n                        }\r\n                    }\r\n                    if (!trackNode || !trackProperty) {\r\n                        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\r\n                        return null;\r\n                    }\r\n                    var inputItemSize = 1;\r\n                    var outputItemSize = track.values.length / track.times.length;\r\n                    if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\r\n                        outputItemSize /= trackNode.morphTargetInfluences.length;\r\n                    }\r\n                    var interpolation;\r\n                    if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\r\n                        interpolation = 'CUBICSPLINE';\r\n                        outputItemSize /= 3;\r\n                    } else if (track.getInterpolation() === THREE.InterpolateDiscrete) {\r\n                        interpolation = 'STEP';\r\n                    } else {\r\n                        interpolation = 'LINEAR';\r\n                    }\r\n                    samplers.push({\r\n                        input: processAccessor(new THREE.BufferAttribute(track.times, inputItemSize)),\r\n                        output: processAccessor(new THREE.BufferAttribute(track.values, outputItemSize)),\r\n                        interpolation: interpolation\r\n                    });\r\n                    channels.push({\r\n                        sampler: samplers.length - 1,\r\n                        target: {\r\n                            node: nodeMap.get(trackNode),\r\n                            path: trackProperty\r\n                        }\r\n                    });\r\n                }\r\n                outputJSON.animations.push({\r\n                    name: clip.name || 'clip_' + outputJSON.animations.length,\r\n                    samplers: samplers,\r\n                    channels: channels\r\n                });\r\n                return outputJSON.animations.length - 1;\r\n            }\r\n            function processSkin(object) {\r\n                var node = outputJSON.nodes[nodeMap.get(object)];\r\n                var skeleton = object.skeleton;\r\n                if (skeleton === undefined)\r\n                    return null;\r\n                var rootJoint = object.skeleton.bones[0];\r\n                if (rootJoint === undefined)\r\n                    return null;\r\n                var joints = [];\r\n                var inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\r\n                for (var i = 0; i < skeleton.bones.length; ++i) {\r\n                    joints.push(nodeMap.get(skeleton.bones[i]));\r\n                    skeleton.boneInverses[i].toArray(inverseBindMatrices, i * 16);\r\n                }\r\n                if (outputJSON.skins === undefined) {\r\n                    outputJSON.skins = [];\r\n                }\r\n                outputJSON.skins.push({\r\n                    inverseBindMatrices: processAccessor(new THREE.BufferAttribute(inverseBindMatrices, 16)),\r\n                    joints: joints,\r\n                    skeleton: nodeMap.get(rootJoint)\r\n                });\r\n                var skinIndex = node.skin = outputJSON.skins.length - 1;\r\n                return skinIndex;\r\n            }\r\n            function processLight(light) {\r\n                var lightDef = {};\r\n                if (light.name)\r\n                    lightDef.name = light.name;\r\n                lightDef.color = light.color.toArray();\r\n                lightDef.intensity = light.intensity;\r\n                if (light.isDirectionalLight) {\r\n                    lightDef.type = 'directional';\r\n                } else if (light.isPointLight) {\r\n                    lightDef.type = 'point';\r\n                    if (light.distance > 0)\r\n                        lightDef.range = light.distance;\r\n                } else if (light.isSpotLight) {\r\n                    lightDef.type = 'spot';\r\n                    if (light.distance > 0)\r\n                        lightDef.range = light.distance;\r\n                    lightDef.spot = {};\r\n                    lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;\r\n                    lightDef.spot.outerConeAngle = light.angle;\r\n                }\r\n                if (light.decay !== undefined && light.decay !== 2) {\r\n                    console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\r\n                }\r\n                if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\r\n                    console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\r\n                }\r\n                var lights = outputJSON.extensions['KHR_lights_punctual'].lights;\r\n                lights.push(lightDef);\r\n                return lights.length - 1;\r\n            }\r\n            function processNode(object) {\r\n                if (!outputJSON.nodes) {\r\n                    outputJSON.nodes = [];\r\n                }\r\n                var gltfNode = {};\r\n                if (options.trs) {\r\n                    var rotation = object.quaternion.toArray();\r\n                    var position = object.position.toArray();\r\n                    var scale = object.scale.toArray();\r\n                    if (!equalArray(rotation, [\r\n                            0,\r\n                            0,\r\n                            0,\r\n                            1\r\n                        ])) {\r\n                        gltfNode.rotation = rotation;\r\n                    }\r\n                    if (!equalArray(position, [\r\n                            0,\r\n                            0,\r\n                            0\r\n                        ])) {\r\n                        gltfNode.translation = position;\r\n                    }\r\n                    if (!equalArray(scale, [\r\n                            1,\r\n                            1,\r\n                            1\r\n                        ])) {\r\n                        gltfNode.scale = scale;\r\n                    }\r\n                } else {\r\n                    if (object.matrixAutoUpdate) {\r\n                        object.updateMatrix();\r\n                    }\r\n                    if (!equalArray(object.matrix.elements, [\r\n                            1,\r\n                            0,\r\n                            0,\r\n                            0,\r\n                            0,\r\n                            1,\r\n                            0,\r\n                            0,\r\n                            0,\r\n                            0,\r\n                            1,\r\n                            0,\r\n                            0,\r\n                            0,\r\n                            0,\r\n                            1\r\n                        ])) {\r\n                        gltfNode.matrix = object.matrix.elements;\r\n                    }\r\n                }\r\n                if (object.name !== '') {\r\n                    gltfNode.name = String(object.name);\r\n                }\r\n                serializeUserData(object, gltfNode);\r\n                if (object.isMesh || object.isLine || object.isPoints) {\r\n                    var mesh = processMesh(object);\r\n                    if (mesh !== null) {\r\n                        gltfNode.mesh = mesh;\r\n                    }\r\n                } else if (object.isCamera) {\r\n                    gltfNode.camera = processCamera(object);\r\n                } else if (object.isDirectionalLight || object.isPointLight || object.isSpotLight) {\r\n                    if (!extensionsUsed['KHR_lights_punctual']) {\r\n                        outputJSON.extensions = outputJSON.extensions || {};\r\n                        outputJSON.extensions['KHR_lights_punctual'] = { lights: [] };\r\n                        extensionsUsed['KHR_lights_punctual'] = true;\r\n                    }\r\n                    gltfNode.extensions = gltfNode.extensions || {};\r\n                    gltfNode.extensions['KHR_lights_punctual'] = { light: processLight(object) };\r\n                } else if (object.isLight) {\r\n                    console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', object);\r\n                    return null;\r\n                }\r\n                if (object.isSkinnedMesh) {\r\n                    skins.push(object);\r\n                }\r\n                if (object.children.length > 0) {\r\n                    var children = [];\r\n                    for (var i = 0, l = object.children.length; i < l; i++) {\r\n                        var child = object.children[i];\r\n                        if (child.visible || options.onlyVisible === false) {\r\n                            var node = processNode(child);\r\n                            if (node !== null) {\r\n                                children.push(node);\r\n                            }\r\n                        }\r\n                    }\r\n                    if (children.length > 0) {\r\n                        gltfNode.children = children;\r\n                    }\r\n                }\r\n                outputJSON.nodes.push(gltfNode);\r\n                var nodeIndex = outputJSON.nodes.length - 1;\r\n                nodeMap.set(object, nodeIndex);\r\n                return nodeIndex;\r\n            }\r\n            function processScene(scene) {\r\n                if (!outputJSON.scenes) {\r\n                    outputJSON.scenes = [];\r\n                    outputJSON.scene = 0;\r\n                }\r\n                var gltfScene = {};\r\n                if (scene.name !== '') {\r\n                    gltfScene.name = scene.name;\r\n                }\r\n                outputJSON.scenes.push(gltfScene);\r\n                var nodes = [];\r\n                for (var i = 0, l = scene.children.length; i < l; i++) {\r\n                    var child = scene.children[i];\r\n                    if (child.visible || options.onlyVisible === false) {\r\n                        var node = processNode(child);\r\n                        if (node !== null) {\r\n                            nodes.push(node);\r\n                        }\r\n                    }\r\n                }\r\n                if (nodes.length > 0) {\r\n                    gltfScene.nodes = nodes;\r\n                }\r\n                serializeUserData(scene, gltfScene);\r\n            }\r\n            function processObjects(objects) {\r\n                var scene = new THREE.Scene();\r\n                scene.name = 'AuxScene';\r\n                for (var i = 0; i < objects.length; i++) {\r\n                    scene.children.push(objects[i]);\r\n                }\r\n                processScene(scene);\r\n            }\r\n            function processInput(input) {\r\n                input = input instanceof Array ? input : [input];\r\n                var objectsWithoutScene = [];\r\n                for (var i = 0; i < input.length; i++) {\r\n                    if (input[i] instanceof THREE.Scene) {\r\n                        processScene(input[i]);\r\n                    } else {\r\n                        objectsWithoutScene.push(input[i]);\r\n                    }\r\n                }\r\n                if (objectsWithoutScene.length > 0) {\r\n                    processObjects(objectsWithoutScene);\r\n                }\r\n                for (var i = 0; i < skins.length; ++i) {\r\n                    processSkin(skins[i]);\r\n                }\r\n                for (var i = 0; i < options.animations.length; ++i) {\r\n                    processAnimation(options.animations[i], input[0]);\r\n                }\r\n            }\r\n            processInput(input);\r\n            Promise.all(pending).then(function () {\r\n                var blob = new Blob(buffers, { type: 'application/octet-stream' });\r\n                var extensionsUsedList = Object.keys(extensionsUsed);\r\n                if (extensionsUsedList.length > 0)\r\n                    outputJSON.extensionsUsed = extensionsUsedList;\r\n                if (outputJSON.buffers && outputJSON.buffers.length > 0)\r\n                    outputJSON.buffers[0].byteLength = blob.size;\r\n                if (options.binary === true) {\r\n                    var GLB_HEADER_BYTES = 12;\r\n                    var GLB_HEADER_MAGIC = 1179937895;\r\n                    var GLB_VERSION = 2;\r\n                    var GLB_CHUNK_PREFIX_BYTES = 8;\r\n                    var GLB_CHUNK_TYPE_JSON = 1313821514;\r\n                    var GLB_CHUNK_TYPE_BIN = 5130562;\r\n                    var reader = new window.FileReader();\r\n                    reader.readAsArrayBuffer(blob);\r\n                    reader.onloadend = function () {\r\n                        var binaryChunk = getPaddedArrayBuffer(reader.result);\r\n                        var binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\r\n                        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\r\n                        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\r\n                        var jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(outputJSON)), 32);\r\n                        var jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\r\n                        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\r\n                        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\r\n                        var header = new ArrayBuffer(GLB_HEADER_BYTES);\r\n                        var headerView = new DataView(header);\r\n                        headerView.setUint32(0, GLB_HEADER_MAGIC, true);\r\n                        headerView.setUint32(4, GLB_VERSION, true);\r\n                        var totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\r\n                        headerView.setUint32(8, totalByteLength, true);\r\n                        var glbBlob = new Blob([\r\n                            header,\r\n                            jsonChunkPrefix,\r\n                            jsonChunk,\r\n                            binaryChunkPrefix,\r\n                            binaryChunk\r\n                        ], { type: 'application/octet-stream' });\r\n                        var glbReader = new window.FileReader();\r\n                        glbReader.readAsArrayBuffer(glbBlob);\r\n                        glbReader.onloadend = function () {\r\n                            onDone(glbReader.result);\r\n                        };\r\n                    };\r\n                } else {\r\n                    if (outputJSON.buffers && outputJSON.buffers.length > 0) {\r\n                        var reader = new window.FileReader();\r\n                        reader.readAsDataURL(blob);\r\n                        reader.onloadend = function () {\r\n                            var base64data = reader.result;\r\n                            outputJSON.buffers[0].uri = base64data;\r\n                            onDone(outputJSON);\r\n                        };\r\n                    } else {\r\n                        onDone(outputJSON);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    };\r\n    GLTFExporter.Utils = {\r\n        insertKeyframe: function (track, time) {\r\n            var tolerance = 0.001;\r\n            var valueSize = track.getValueSize();\r\n            var times = new track.TimeBufferType(track.times.length + 1);\r\n            var values = new track.ValueBufferType(track.values.length + valueSize);\r\n            var interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\r\n            var index;\r\n            if (track.times.length === 0) {\r\n                times[0] = time;\r\n                for (var i = 0; i < valueSize; i++) {\r\n                    values[i] = 0;\r\n                }\r\n                index = 0;\r\n            } else if (time < track.times[0]) {\r\n                if (Math.abs(track.times[0] - time) < tolerance)\r\n                    return 0;\r\n                times[0] = time;\r\n                times.set(track.times, 1);\r\n                values.set(interpolant.evaluate(time), 0);\r\n                values.set(track.values, valueSize);\r\n                index = 0;\r\n            } else if (time > track.times[track.times.length - 1]) {\r\n                if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\r\n                    return track.times.length - 1;\r\n                }\r\n                times[times.length - 1] = time;\r\n                times.set(track.times, 0);\r\n                values.set(track.values, 0);\r\n                values.set(interpolant.evaluate(time), track.values.length);\r\n                index = times.length - 1;\r\n            } else {\r\n                for (var i = 0; i < track.times.length; i++) {\r\n                    if (Math.abs(track.times[i] - time) < tolerance)\r\n                        return i;\r\n                    if (track.times[i] < time && track.times[i + 1] > time) {\r\n                        times.set(track.times.slice(0, i + 1), 0);\r\n                        times[i + 1] = time;\r\n                        times.set(track.times.slice(i + 1), i + 2);\r\n                        values.set(track.values.slice(0, (i + 1) * valueSize), 0);\r\n                        values.set(interpolant.evaluate(time), (i + 1) * valueSize);\r\n                        values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\r\n                        index = i + 1;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            track.times = times;\r\n            track.values = values;\r\n            return index;\r\n        },\r\n        mergeMorphTargetTracks: function (clip, root) {\r\n            var tracks = [];\r\n            var mergedTracks = {};\r\n            var sourceTracks = clip.tracks;\r\n            for (var i = 0; i < sourceTracks.length; ++i) {\r\n                var sourceTrack = sourceTracks[i];\r\n                var sourceTrackBinding = THREE.PropertyBinding.parseTrackName(sourceTrack.name);\r\n                var sourceTrackNode = THREE.PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\r\n                if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\r\n                    tracks.push(sourceTrack);\r\n                    continue;\r\n                }\r\n                if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\r\n                    if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\r\n                        throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\r\n                    }\r\n                    console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\r\n                    sourceTrack = sourceTrack.clone();\r\n                    sourceTrack.setInterpolation(THREE.InterpolateLinear);\r\n                }\r\n                var targetCount = sourceTrackNode.morphTargetInfluences.length;\r\n                var targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\r\n                if (targetIndex === undefined) {\r\n                    throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\r\n                }\r\n                var mergedTrack;\r\n                if (mergedTracks[sourceTrackNode.uuid] === undefined) {\r\n                    mergedTrack = sourceTrack.clone();\r\n                    var values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\r\n                    for (var j = 0; j < mergedTrack.times.length; j++) {\r\n                        values[j * targetCount + targetIndex] = mergedTrack.values[j];\r\n                    }\r\n                    mergedTrack.name = '.morphTargetInfluences';\r\n                    mergedTrack.values = values;\r\n                    mergedTracks[sourceTrackNode.uuid] = mergedTrack;\r\n                    tracks.push(mergedTrack);\r\n                    continue;\r\n                }\r\n                var sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\r\n                mergedTrack = mergedTracks[sourceTrackNode.uuid];\r\n                for (var j = 0; j < mergedTrack.times.length; j++) {\r\n                    mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\r\n                }\r\n                for (var j = 0; j < sourceTrack.times.length; j++) {\r\n                    var keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\r\n                    mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\r\n                }\r\n            }\r\n            clip.tracks = tracks;\r\n            return clip;\r\n        }\r\n    };\r\n    return threex.exporters.GLTFExporter = GLTFExporter;\r\n});"]}