{"version":3,"sources":["exporters/GLTFExporter.js"],"names":["define","THREE","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","UNSIGNED_BYTE","UNSIGNED_SHORT","FLOAT","UNSIGNED_INT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","THREE_TO_WEBGL","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","PATH_PROPERTIES","scale","position","quaternion","morphTargetInfluences","GLTFExporter","prototype","constructor","parse","input","onDone","options","DEFAULT_OPTIONS","binary","trs","onlyVisible","truncateDrawRange","embedImages","maxTextureSize","Infinity","animations","forceIndices","forcePowerOfTwoTextures","includeCustomExtensions","Object","assign","length","cachedCanvas","outputJSON","asset","version","generator","byteOffset","buffers","pending","nodeMap","Map","skins","extensionsUsed","cachedData","meshes","attributes","attributesNormalized","materials","textures","images","uids","uid","getUID","object","has","set","get","equalArray","array1","array2","every","element","index","getPaddedBufferSize","bufferSize","Math","ceil","getPaddedArrayBuffer","arrayBuffer","paddingByte","paddedLength","byteLength","array","Uint8Array","i","buffer","serializeUserData","gltfProperty","keys","userData","json","JSON","stringify","gltfExtensions","extensionName","undefined","extensions","extras","error","console","warn","name","message","applyTextureTransform","mapDef","texture","didTransform","transformDef","offset","x","y","toArray","rotation","repeat","processBuffer","push","processAccessor","attribute","geometry","start","count","componentType","Float32Array","Uint32Array","Uint16Array","Error","end","end2","drawRange","max","min","bufferViewTarget","minMax","output","Array","itemSize","fill","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","a","value","getMinMax","bufferView","target","componentSize","bufferViews","dataView","DataView","ArrayBuffer","setFloat32","setUint32","setUint16","setUint8","gltfBufferView","byteStride","id","processBufferView","gltfAccessor","type","1","2","3","4","16","accessors","processImage","image","format","flipY","cachedImages","mimeType","RGBAFormat","key","toString","gltfImage","canvas","document","createElement","width","height","MathUtils","isPowerOfTwo","floorPowerOfTwo","ctx","getContext","translate","drawImage","Promise","resolve","toBlob","blob","reader","window","FileReader","readAsArrayBuffer","onloadend","result","processBufferViewImage","then","bufferViewIndex","uri","toDataURL","src","processTexture","map","gltfTexture","sampler","samplers","gltfSampler","magFilter","minFilter","wrapS","wrapT","processSampler","source","processMaterial","material","isShaderMaterial","gltfMaterial","pbrMetallicRoughness","isMeshBasicMaterial","KHR_materials_unlit","isGLTFSpecularGlossinessMaterial","KHR_materials_pbrSpecularGlossiness","isMeshStandardMaterial","color","concat","opacity","baseColorFactor","metallicFactor","metalness","roughnessFactor","roughness","diffuseFactor","specularFactor","specular","glossinessFactor","glossiness","metalnessMap","roughnessMap","metalRoughMapDef","metallicRoughnessTexture","baseColorMapDef","diffuseTexture","baseColorTexture","specularMap","specularMapDef","specularGlossinessTexture","emissive","clone","multiplyScalar","emissiveIntensity","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","texCoord","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","DoubleSide","doubleSided","processMesh","mesh","meshCacheKeyParts","uuid","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","isBufferGeometry","BufferGeometry","setFromObject","gltfMesh","primitives","targets","nameConversion","uv","uv2","skinWeight","skinIndex","originalNormal","getAttribute","normal","v","Vector3","il","abs","fromArray","isNormalizedNormalAttribute","setAttribute","z","setX","normalize","createNormalizedNormalAttribute","modifiedAttribute","attributeName","substr","toUpperCase","test","BufferAttribute","normalized","accessor","weights","targetNames","reverseDictionary","morphTargetDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","j","jl","setXYZ","getX","getY","getZ","isMultiMaterial","groups","didForceIndices","indices","setIndex","materialIndex","primitive","cacheKey","processAnimation","clip","root","tracks","Utils","mergeMorphTargetTracks","channels","track","trackBinding","PropertyBinding","parseTrackName","trackNode","findNode","nodeName","trackProperty","propertyName","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","interpolation","outputItemSize","values","times","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","getInterpolation","InterpolateDiscrete","node","path","processSkin","nodes","rootJoint","bones","joints","inverseBindMatrices","boneInverses","skin","processNode","gltfNode","translation","matrixAutoUpdate","updateMatrix","matrix","elements","String","isMesh","isCamera","camera","cameras","isOrtho","isOrthographicCamera","gltfCamera","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","processCamera","isDirectionalLight","isPointLight","isSpotLight","lights","light","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","processLight","isLight","children","child","visible","nodeIndex","processScene","scene","scenes","gltfScene","objectsWithoutScene","Scene","objects","processObjects","processInput","all","Blob","extensionsUsedList","size","binaryChunk","binaryChunkPrefix","jsonChunk","text","TextEncoder","encode","charCodeAt","stringToArrayBuffer","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","insertKeyframe","time","valueSize","getValueSize","TimeBufferType","ValueBufferType","interpolant","evaluate","slice","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","setInterpolation","InterpolateLinear","mergedTrack","targetCount","targetIndex","sourceInterpolant","keyframeIndex","this"],"mappings":"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","file":"../../exporters/GLTFExporter.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author fernandojsg / http://fernandojsg.com\n\t * @author Don McCurdy / https://www.donmccurdy.com\n\t * @author Takahiro / https://github.com/takahirox\n\t */\n\n\t//------------------------------------------------------------------------------\n\t// Constants\n\t//------------------------------------------------------------------------------\n\tvar WEBGL_CONSTANTS = {\n\t\tPOINTS: 0x0000,\n\t\tLINES: 0x0001,\n\t\tLINE_LOOP: 0x0002,\n\t\tLINE_STRIP: 0x0003,\n\t\tTRIANGLES: 0x0004,\n\t\tTRIANGLE_STRIP: 0x0005,\n\t\tTRIANGLE_FAN: 0x0006,\n\n\t\tUNSIGNED_BYTE: 0x1401,\n\t\tUNSIGNED_SHORT: 0x1403,\n\t\tFLOAT: 0x1406,\n\t\tUNSIGNED_INT: 0x1405,\n\t\tARRAY_BUFFER: 0x8892,\n\t\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\t\tNEAREST: 0x2600,\n\t\tLINEAR: 0x2601,\n\t\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\t\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\t\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\t\tLINEAR_MIPMAP_LINEAR: 0x2703,\n\n\t\tCLAMP_TO_EDGE: 33071,\n\t\tMIRRORED_REPEAT: 33648,\n\t\tREPEAT: 10497\n\t};\n\n\tvar THREE_TO_WEBGL = {};\n\n\tTHREE_TO_WEBGL[ THREE.NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\n\tTHREE_TO_WEBGL[ THREE.NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\n\tTHREE_TO_WEBGL[ THREE.NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\n\tTHREE_TO_WEBGL[ THREE.LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\n\tTHREE_TO_WEBGL[ THREE.LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\n\tTHREE_TO_WEBGL[ THREE.LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\n\tTHREE_TO_WEBGL[ THREE.ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\n\tTHREE_TO_WEBGL[ THREE.RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\n\tTHREE_TO_WEBGL[ THREE.MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\n\tvar PATH_PROPERTIES = {\n\t\tscale: 'scale',\n\t\tposition: 'translation',\n\t\tquaternion: 'rotation',\n\t\tmorphTargetInfluences: 'weights'\n\t};\n\n\t//------------------------------------------------------------------------------\n\t// GLTF Exporter\n\t//------------------------------------------------------------------------------\n\tTHREE.GLTFExporter = function () {};\n\n\tTHREE.GLTFExporter.prototype = {\n\n\t\tconstructor: THREE.GLTFExporter,\n\n\t\t/**\n\t\t * Parse scenes and generate GLTF output\n\t\t * @param  {THREE.Scene or [THREE.Scenes]} input   THREE.Scene or Array of THREE.Scenes\n\t\t * @param  {Function} onDone  Callback on completed\n\t\t * @param  {Object} options options\n\t\t */\n\t\tparse: function ( input, onDone, options ) {\n\n\t\t\tvar DEFAULT_OPTIONS = {\n\t\t\t\tbinary: false,\n\t\t\t\ttrs: false,\n\t\t\t\tonlyVisible: true,\n\t\t\t\ttruncateDrawRange: true,\n\t\t\t\tembedImages: true,\n\t\t\t\tmaxTextureSize: Infinity,\n\t\t\t\tanimations: [],\n\t\t\t\tforceIndices: false,\n\t\t\t\tforcePowerOfTwoTextures: false,\n\t\t\t\tincludeCustomExtensions: false\n\t\t\t};\n\n\t\t\toptions = Object.assign( {}, DEFAULT_OPTIONS, options );\n\n\t\t\tif ( options.animations.length > 0 ) {\n\n\t\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\t\toptions.trs = true;\n\n\t\t\t}\n\n\t\t\tvar outputJSON = {\n\n\t\t\t\tasset: {\n\n\t\t\t\t\tversion: \"2.0\",\n\t\t\t\t\tgenerator: \"THREE.GLTFExporter\"\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tvar byteOffset = 0;\n\t\t\tvar buffers = [];\n\t\t\tvar pending = [];\n\t\t\tvar nodeMap = new Map();\n\t\t\tvar skins = [];\n\t\t\tvar extensionsUsed = {};\n\t\t\tvar cachedData = {\n\n\t\t\t\tmeshes: new Map(),\n\t\t\t\tattributes: new Map(),\n\t\t\t\tattributesNormalized: new Map(),\n\t\t\t\tmaterials: new Map(),\n\t\t\t\ttextures: new Map(),\n\t\t\t\timages: new Map()\n\n\t\t\t};\n\n\t\t\tvar cachedCanvas;\n\n\t\t\tvar uids = new Map();\n\t\t\tvar uid = 0;\n\n\t\t\t/**\n\t\t\t * Assign and return a temporal unique id for an object\n\t\t\t * especially which doesn't have .uuid\n\t\t\t * @param  {Object} object\n\t\t\t * @return {Integer}\n\t\t\t */\n\t\t\tfunction getUID( object ) {\n\n\t\t\t\tif ( ! uids.has( object ) ) uids.set( object, uid ++ );\n\n\t\t\t\treturn uids.get( object );\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Compare two arrays\n\t\t\t * @param  {Array} array1 Array 1 to compare\n\t\t\t * @param  {Array} array2 Array 2 to compare\n\t\t\t * @return {Boolean}        Returns true if both arrays are equal\n\t\t\t */\n\t\t\tfunction equalArray( array1, array2 ) {\n\n\t\t\t\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\t\t\t\treturn element === array2[ index ];\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Converts a string to an ArrayBuffer.\n\t\t\t * @param  {string} text\n\t\t\t * @return {ArrayBuffer}\n\t\t\t */\n\t\t\tfunction stringToArrayBuffer( text ) {\n\n\t\t\t\tif ( window.TextEncoder !== undefined ) {\n\n\t\t\t\t\treturn new TextEncoder().encode( text ).buffer;\n\n\t\t\t\t}\n\n\t\t\t\tvar array = new Uint8Array( new ArrayBuffer( text.length ) );\n\n\t\t\t\tfor ( var i = 0, il = text.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar value = text.charCodeAt( i );\n\n\t\t\t\t\t// Replacing multi-byte character with space(0x20).\n\t\t\t\t\tarray[ i ] = value > 0xFF ? 0x20 : value;\n\n\t\t\t\t}\n\n\t\t\t\treturn array.buffer;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Get the min and max vectors from the given attribute\n\t\t\t * @param  {THREE.BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n\t\t\t * @param  {Integer} start\n\t\t\t * @param  {Integer} count\n\t\t\t * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n\t\t\t */\n\t\t\tfunction getMinMax( attribute, start, count ) {\n\n\t\t\t\tvar output = {\n\n\t\t\t\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\t\t\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t\t\t\t};\n\n\t\t\t\tfor ( var i = start; i < start + count; i ++ ) {\n\n\t\t\t\t\tfor ( var a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\t\tvar value = attribute.array[ i * attribute.itemSize + a ];\n\t\t\t\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\t\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn output;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Checks if image size is POT.\n\t\t\t *\n\t\t\t * @param {Image} image The image to be checked.\n\t\t\t * @returns {Boolean} Returns true if image size is POT.\n\t\t\t *\n\t\t\t */\n\t\t\tfunction isPowerOfTwo( image ) {\n\n\t\t\t\treturn THREE.MathUtils.isPowerOfTwo( image.width ) && THREE.MathUtils.isPowerOfTwo( image.height );\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Checks if normal attribute values are normalized.\n\t\t\t *\n\t\t\t * @param {THREE.BufferAttribute} normal\n\t\t\t * @returns {Boolean}\n\t\t\t *\n\t\t\t */\n\t\t\tfunction isNormalizedNormalAttribute( normal ) {\n\n\t\t\t\tif ( cachedData.attributesNormalized.has( normal ) ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tvar v = new THREE.Vector3();\n\n\t\t\t\tfor ( var i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t\t\t// 0.0005 is from glTF-validator\n\t\t\t\t\tif ( Math.abs( v.fromArray( normal.array, i * 3 ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Creates normalized normal buffer attribute.\n\t\t\t *\n\t\t\t * @param {THREE.BufferAttribute} normal\n\t\t\t * @returns {THREE.BufferAttribute}\n\t\t\t *\n\t\t\t */\n\t\t\tfunction createNormalizedNormalAttribute( normal ) {\n\n\t\t\t\tif ( cachedData.attributesNormalized.has( normal ) ) {\n\n\t\t\t\t\treturn cachedData.attributesNormalized.get( normal );\n\n\t\t\t\t}\n\n\t\t\t\tvar attribute = normal.clone();\n\n\t\t\t\tvar v = new THREE.Vector3();\n\n\t\t\t\tfor ( var i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tv.fromArray( attribute.array, i * 3 );\n\n\t\t\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\t\t\tv.setX( 1.0 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv.normalize();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tv.toArray( attribute.array, i * 3 );\n\n\t\t\t\t}\n\n\t\t\t\tcachedData.attributesNormalized.set( normal, attribute );\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n\t\t\t * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n\t\t\t *\n\t\t\t * @param {Integer} bufferSize The size the original buffer.\n\t\t\t * @returns {Integer} new buffer size with required padding.\n\t\t\t *\n\t\t\t */\n\t\t\tfunction getPaddedBufferSize( bufferSize ) {\n\n\t\t\t\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Returns a buffer aligned to 4-byte boundary.\n\t\t\t *\n\t\t\t * @param {ArrayBuffer} arrayBuffer Buffer to pad\n\t\t\t * @param {Integer} paddingByte (Optional)\n\t\t\t * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n\t\t\t */\n\t\t\tfunction getPaddedArrayBuffer( arrayBuffer, paddingByte ) {\n\n\t\t\t\tpaddingByte = paddingByte || 0;\n\n\t\t\t\tvar paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\t\t\t\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\t\t\t\tvar array = new Uint8Array( paddedLength );\n\t\t\t\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\t\t\t\tif ( paddingByte !== 0 ) {\n\n\t\t\t\t\t\tfor ( var i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn array.buffer;\n\n\t\t\t\t}\n\n\t\t\t\treturn arrayBuffer;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Serializes a userData.\n\t\t\t *\n\t\t\t * @param {THREE.Object3D|THREE.Material} object\n\t\t\t * @param {Object} gltfProperty\n\t\t\t */\n\t\t\tfunction serializeUserData( object, gltfProperty ) {\n\n\t\t\t\tif ( Object.keys( object.userData ).length === 0 ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar json = JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\n\n\t\t\t\t\t\tif ( gltfProperty.extensions === undefined ) {\n\n\t\t\t\t\t\t\tgltfProperty.extensions = {};\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( var extensionName in json.gltfExtensions ) {\n\n\t\t\t\t\t\t\tgltfProperty.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\n\t\t\t\t\t\t\textensionsUsed[ extensionName ] = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdelete json.gltfExtensions;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Object.keys( json ).length > 0 ) {\n\n\t\t\t\t\t\tgltfProperty.extras = json;\n\n\t\t\t\t\t}\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Applies a texture transform, if present, to the map definition. Requires\n\t\t\t * the KHR_texture_transform extension.\n\t\t\t */\n\t\t\tfunction applyTextureTransform( mapDef, texture ) {\n\n\t\t\t\tvar didTransform = false;\n\t\t\t\tvar transformDef = {};\n\n\t\t\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\n\n\t\t\t\t\ttransformDef.offset = texture.offset.toArray();\n\t\t\t\t\tdidTransform = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.rotation !== 0 ) {\n\n\t\t\t\t\ttransformDef.rotation = texture.rotation;\n\t\t\t\t\tdidTransform = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\n\n\t\t\t\t\ttransformDef.scale = texture.repeat.toArray();\n\t\t\t\t\tdidTransform = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( didTransform ) {\n\n\t\t\t\t\tmapDef.extensions = mapDef.extensions || {};\n\t\t\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\n\t\t\t\t\textensionsUsed[ 'KHR_texture_transform' ] = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process a buffer to append to the default one.\n\t\t\t * @param  {ArrayBuffer} buffer\n\t\t\t * @return {Integer}\n\t\t\t */\n\t\t\tfunction processBuffer( buffer ) {\n\n\t\t\t\tif ( ! outputJSON.buffers ) {\n\n\t\t\t\t\toutputJSON.buffers = [ { byteLength: 0 } ];\n\n\t\t\t\t}\n\n\t\t\t\t// All buffers are merged before export.\n\t\t\t\tbuffers.push( buffer );\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process and generate a BufferView\n\t\t\t * @param  {THREE.BufferAttribute} attribute\n\t\t\t * @param  {number} componentType\n\t\t\t * @param  {number} start\n\t\t\t * @param  {number} count\n\t\t\t * @param  {number} target (Optional) Target usage of the BufferView\n\t\t\t * @return {Object}\n\t\t\t */\n\t\t\tfunction processBufferView( attribute, componentType, start, count, target ) {\n\n\t\t\t\tif ( ! outputJSON.bufferViews ) {\n\n\t\t\t\t\toutputJSON.bufferViews = [];\n\n\t\t\t\t}\n\n\t\t\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\t\t\tvar componentSize;\n\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\tcomponentSize = 1;\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\tcomponentSize = 2;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcomponentSize = 4;\n\n\t\t\t\t}\n\n\t\t\t\tvar byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );\n\t\t\t\tvar dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\t\t\tvar offset = 0;\n\n\t\t\t\tfor ( var i = start; i < start + count; i ++ ) {\n\n\t\t\t\t\tfor ( var a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\t\t// @TODO Fails on InterleavedBufferAttribute, and could probably be\n\t\t\t\t\t\t// optimized for normal BufferAttribute.\n\t\t\t\t\t\tvar value = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\toffset += componentSize;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfBufferView = {\n\n\t\t\t\t\tbuffer: processBuffer( dataView.buffer ),\n\t\t\t\t\tbyteOffset: byteOffset,\n\t\t\t\t\tbyteLength: byteLength\n\n\t\t\t\t};\n\n\t\t\t\tif ( target !== undefined ) gltfBufferView.target = target;\n\n\t\t\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t\t\t// Only define byteStride for vertex attributes.\n\t\t\t\t\tgltfBufferView.byteStride = attribute.itemSize * componentSize;\n\n\t\t\t\t}\n\n\t\t\t\tbyteOffset += byteLength;\n\n\t\t\t\toutputJSON.bufferViews.push( gltfBufferView );\n\n\t\t\t\t// @TODO Merge bufferViews where possible.\n\t\t\t\tvar output = {\n\n\t\t\t\t\tid: outputJSON.bufferViews.length - 1,\n\t\t\t\t\tbyteLength: 0\n\n\t\t\t\t};\n\n\t\t\t\treturn output;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process and generate a BufferView from an image Blob.\n\t\t\t * @param {Blob} blob\n\t\t\t * @return {Promise<Integer>}\n\t\t\t */\n\t\t\tfunction processBufferViewImage( blob ) {\n\n\t\t\t\tif ( ! outputJSON.bufferViews ) {\n\n\t\t\t\t\toutputJSON.bufferViews = [];\n\n\t\t\t\t}\n\n\t\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\t\tvar reader = new window.FileReader();\n\t\t\t\t\treader.readAsArrayBuffer( blob );\n\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\tvar buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\t\t\tvar bufferView = {\n\t\t\t\t\t\t\tbuffer: processBuffer( buffer ),\n\t\t\t\t\t\t\tbyteOffset: byteOffset,\n\t\t\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t\t\t\t\toutputJSON.bufferViews.push( bufferView );\n\n\t\t\t\t\t\tresolve( outputJSON.bufferViews.length - 1 );\n\n\t\t\t\t\t};\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process attribute to generate an accessor\n\t\t\t * @param  {THREE.BufferAttribute} attribute Attribute to process\n\t\t\t * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n\t\t\t * @param  {Integer} start (Optional)\n\t\t\t * @param  {Integer} count (Optional)\n\t\t\t * @return {Integer}           Index of the processed accessor on the \"accessors\" array\n\t\t\t */\n\t\t\tfunction processAccessor( attribute, geometry, start, count ) {\n\n\t\t\t\tvar types = {\n\n\t\t\t\t\t1: 'SCALAR',\n\t\t\t\t\t2: 'VEC2',\n\t\t\t\t\t3: 'VEC3',\n\t\t\t\t\t4: 'VEC4',\n\t\t\t\t\t16: 'MAT4'\n\n\t\t\t\t};\n\n\t\t\t\tvar componentType;\n\n\t\t\t\t// Detect the component type of the attribute array (float, uint or ushort)\n\t\t\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( start === undefined ) start = 0;\n\t\t\t\tif ( count === undefined ) count = attribute.count;\n\n\t\t\t\t// @TODO Indexed buffer geometry with drawRange not supported yet\n\t\t\t\tif ( options.truncateDrawRange && geometry !== undefined && geometry.index === null ) {\n\n\t\t\t\t\tvar end = start + count;\n\t\t\t\t\tvar end2 = geometry.drawRange.count === Infinity\n\t\t\t\t\t\t? attribute.count\n\t\t\t\t\t\t: geometry.drawRange.start + geometry.drawRange.count;\n\n\t\t\t\t\tstart = Math.max( start, geometry.drawRange.start );\n\t\t\t\t\tcount = Math.min( end, end2 ) - start;\n\n\t\t\t\t\tif ( count < 0 ) count = 0;\n\n\t\t\t\t}\n\n\t\t\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\t\t\tif ( count === 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tvar minMax = getMinMax( attribute, start, count );\n\n\t\t\t\tvar bufferViewTarget;\n\n\t\t\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t\t\t// animation samplers, target must not be set.\n\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t\t\t}\n\n\t\t\t\tvar bufferView = processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\t\t\tvar gltfAccessor = {\n\n\t\t\t\t\tbufferView: bufferView.id,\n\t\t\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\t\t\tcomponentType: componentType,\n\t\t\t\t\tcount: count,\n\t\t\t\t\tmax: minMax.max,\n\t\t\t\t\tmin: minMax.min,\n\t\t\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t\t\t};\n\n\t\t\t\tif ( ! outputJSON.accessors ) {\n\n\t\t\t\t\toutputJSON.accessors = [];\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.accessors.push( gltfAccessor );\n\n\t\t\t\treturn outputJSON.accessors.length - 1;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process image\n\t\t\t * @param  {Image} image to process\n\t\t\t * @param  {Integer} format of the image (e.g. THREE.RGBFormat, THREE.RGBAFormat etc)\n\t\t\t * @param  {Boolean} flipY before writing out the image\n\t\t\t * @return {Integer}     Index of the processed texture in the \"images\" array\n\t\t\t */\n\t\t\tfunction processImage( image, format, flipY ) {\n\n\t\t\t\tif ( ! cachedData.images.has( image ) ) {\n\n\t\t\t\t\tcachedData.images.set( image, {} );\n\n\t\t\t\t}\n\n\t\t\t\tvar cachedImages = cachedData.images.get( image );\n\t\t\t\tvar mimeType = format === THREE.RGBAFormat ? 'image/png' : 'image/jpeg';\n\t\t\t\tvar key = mimeType + \":flipY/\" + flipY.toString();\n\n\t\t\t\tif ( cachedImages[ key ] !== undefined ) {\n\n\t\t\t\t\treturn cachedImages[ key ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! outputJSON.images ) {\n\n\t\t\t\t\toutputJSON.images = [];\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfImage = { mimeType: mimeType };\n\n\t\t\t\tif ( options.embedImages ) {\n\n\t\t\t\t\tvar canvas = cachedCanvas = cachedCanvas || document.createElement( 'canvas' );\n\n\t\t\t\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\n\t\t\t\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\n\n\t\t\t\t\tif ( options.forcePowerOfTwoTextures && ! isPowerOfTwo( canvas ) ) {\n\n\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Resized non-power-of-two image.', image );\n\n\t\t\t\t\t\tcanvas.width = THREE.MathUtils.floorPowerOfTwo( canvas.width );\n\t\t\t\t\t\tcanvas.height = THREE.MathUtils.floorPowerOfTwo( canvas.height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar ctx = canvas.getContext( '2d' );\n\n\t\t\t\t\tif ( flipY === true ) {\n\n\t\t\t\t\t\tctx.translate( 0, canvas.height );\n\t\t\t\t\t\tctx.scale( 1, - 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\t\tif ( options.binary === true ) {\n\n\t\t\t\t\t\tpending.push( new Promise( function ( resolve ) {\n\n\t\t\t\t\t\t\tcanvas.toBlob( function ( blob ) {\n\n\t\t\t\t\t\t\t\tprocessBufferViewImage( blob ).then( function ( bufferViewIndex ) {\n\n\t\t\t\t\t\t\t\t\tgltfImage.bufferView = bufferViewIndex;\n\n\t\t\t\t\t\t\t\t\tresolve();\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}, mimeType );\n\n\t\t\t\t\t\t} ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgltfImage.uri = canvas.toDataURL( mimeType );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgltfImage.uri = image.src;\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.images.push( gltfImage );\n\n\t\t\t\tvar index = outputJSON.images.length - 1;\n\t\t\t\tcachedImages[ key ] = index;\n\n\t\t\t\treturn index;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process sampler\n\t\t\t * @param  {Texture} map Texture to process\n\t\t\t * @return {Integer}     Index of the processed texture in the \"samplers\" array\n\t\t\t */\n\t\t\tfunction processSampler( map ) {\n\n\t\t\t\tif ( ! outputJSON.samplers ) {\n\n\t\t\t\t\toutputJSON.samplers = [];\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfSampler = {\n\n\t\t\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\n\t\t\t\t};\n\n\t\t\t\toutputJSON.samplers.push( gltfSampler );\n\n\t\t\t\treturn outputJSON.samplers.length - 1;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process texture\n\t\t\t * @param  {Texture} map Map to process\n\t\t\t * @return {Integer}     Index of the processed texture in the \"textures\" array\n\t\t\t */\n\t\t\tfunction processTexture( map ) {\n\n\t\t\t\tif ( cachedData.textures.has( map ) ) {\n\n\t\t\t\t\treturn cachedData.textures.get( map );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! outputJSON.textures ) {\n\n\t\t\t\t\toutputJSON.textures = [];\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfTexture = {\n\n\t\t\t\t\tsampler: processSampler( map ),\n\t\t\t\t\tsource: processImage( map.image, map.format, map.flipY )\n\n\t\t\t\t};\n\n\t\t\t\tif ( map.name ) {\n\n\t\t\t\t\tgltfTexture.name = map.name;\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.textures.push( gltfTexture );\n\n\t\t\t\tvar index = outputJSON.textures.length - 1;\n\t\t\t\tcachedData.textures.set( map, index );\n\n\t\t\t\treturn index;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process material\n\t\t\t * @param  {THREE.Material} material Material to process\n\t\t\t * @return {Integer}      Index of the processed material in the \"materials\" array\n\t\t\t */\n\t\t\tfunction processMaterial( material ) {\n\n\t\t\t\tif ( cachedData.materials.has( material ) ) {\n\n\t\t\t\t\treturn cachedData.materials.get( material );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isShaderMaterial ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! outputJSON.materials ) {\n\n\t\t\t\t\toutputJSON.materials = [];\n\n\t\t\t\t}\n\n\t\t\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\t\t\tvar gltfMaterial = {\n\n\t\t\t\t\tpbrMetallicRoughness: {}\n\n\t\t\t\t};\n\n\t\t\t\tif ( material.isMeshBasicMaterial ) {\n\n\t\t\t\t\tgltfMaterial.extensions = { KHR_materials_unlit: {} };\n\n\t\t\t\t\textensionsUsed[ 'KHR_materials_unlit' ] = true;\n\n\t\t\t\t} else if ( material.isGLTFSpecularGlossinessMaterial ) {\n\n\t\t\t\t\tgltfMaterial.extensions = { KHR_materials_pbrSpecularGlossiness: {} };\n\n\t\t\t\t\textensionsUsed[ 'KHR_materials_pbrSpecularGlossiness' ] = true;\n\n\t\t\t\t} else if ( ! material.isMeshStandardMaterial ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t\t\t}\n\n\t\t\t\t// pbrMetallicRoughness.baseColorFactor\n\t\t\t\tvar color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\t\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t\t\t} else if ( material.isMeshBasicMaterial ) {\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = 0.5;\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.5;\n\n\t\t\t\t}\n\n\t\t\t\t// pbrSpecularGlossiness diffuse, specular and glossiness factor\n\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) {\n\n\t\t\t\t\tif ( gltfMaterial.pbrMetallicRoughness.baseColorFactor ) {\n\n\t\t\t\t\t\tgltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor = gltfMaterial.pbrMetallicRoughness.baseColorFactor;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar specularFactor = [ 1, 1, 1 ];\n\t\t\t\t\tmaterial.specular.toArray( specularFactor, 0 );\n\t\t\t\t\tgltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor = specularFactor;\n\n\t\t\t\t\tgltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor = material.glossiness;\n\n\t\t\t\t}\n\n\t\t\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\t\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\t\t\tif ( material.metalnessMap === material.roughnessMap ) {\n\n\t\t\t\t\t\tvar metalRoughMapDef = { index: processTexture( material.metalnessMap ) };\n\t\t\t\t\t\tapplyTextureTransform( metalRoughMapDef, material.metalnessMap );\n\t\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\tvar baseColorMapDef = { index: processTexture( material.map ) };\n\t\t\t\t\tapplyTextureTransform( baseColorMapDef, material.map );\n\n\t\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) {\n\n\t\t\t\t\t\tgltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.diffuseTexture = baseColorMapDef;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n\n\t\t\t\t}\n\n\t\t\t\t// pbrSpecularGlossiness specular map\n\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial && material.specularMap ) {\n\n\t\t\t\t\tvar specularMapDef = { index: processTexture( material.specularMap ) };\n\t\t\t\t\tapplyTextureTransform( specularMapDef, material.specularMap );\n\t\t\t\t\tgltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness.specularGlossinessTexture = specularMapDef;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.emissive ) {\n\n\t\t\t\t\t// emissiveFactor\n\t\t\t\t\tvar emissive = material.emissive.clone().multiplyScalar( material.emissiveIntensity ).toArray();\n\n\t\t\t\t\tif ( ! equalArray( emissive, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\t\t\tgltfMaterial.emissiveFactor = emissive;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// emissiveTexture\n\t\t\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\t\t\tvar emissiveMapDef = { index: processTexture( material.emissiveMap ) };\n\t\t\t\t\t\tapplyTextureTransform( emissiveMapDef, material.emissiveMap );\n\t\t\t\t\t\tgltfMaterial.emissiveTexture = emissiveMapDef;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// normalTexture\n\t\t\t\tif ( material.normalMap ) {\n\n\t\t\t\t\tvar normalMapDef = { index: processTexture( material.normalMap ) };\n\n\t\t\t\t\tif ( material.normalScale && material.normalScale.x !== - 1 ) {\n\n\t\t\t\t\t\tif ( material.normalScale.x !== material.normalScale.y ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormalMapDef.scale = material.normalScale.x;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tapplyTextureTransform( normalMapDef, material.normalMap );\n\n\t\t\t\t\tgltfMaterial.normalTexture = normalMapDef;\n\n\t\t\t\t}\n\n\t\t\t\t// occlusionTexture\n\t\t\t\tif ( material.aoMap ) {\n\n\t\t\t\t\tvar occlusionMapDef = {\n\t\t\t\t\t\tindex: processTexture( material.aoMap ),\n\t\t\t\t\t\ttexCoord: 1\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tapplyTextureTransform( occlusionMapDef, material.aoMap );\n\n\t\t\t\t\tgltfMaterial.occlusionTexture = occlusionMapDef;\n\n\t\t\t\t}\n\n\t\t\t\t// alphaMode\n\t\t\t\tif ( material.transparent ) {\n\n\t\t\t\t\tgltfMaterial.alphaMode = 'BLEND';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( material.alphaTest > 0.0 ) {\n\n\t\t\t\t\t\tgltfMaterial.alphaMode = 'MASK';\n\t\t\t\t\t\tgltfMaterial.alphaCutoff = material.alphaTest;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// doubleSided\n\t\t\t\tif ( material.side === THREE.DoubleSide ) {\n\n\t\t\t\t\tgltfMaterial.doubleSided = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.name !== '' ) {\n\n\t\t\t\t\tgltfMaterial.name = material.name;\n\n\t\t\t\t}\n\n\t\t\t\tserializeUserData( material, gltfMaterial );\n\n\t\t\t\toutputJSON.materials.push( gltfMaterial );\n\n\t\t\t\tvar index = outputJSON.materials.length - 1;\n\t\t\t\tcachedData.materials.set( material, index );\n\n\t\t\t\treturn index;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process mesh\n\t\t\t * @param  {THREE.Mesh} mesh Mesh to process\n\t\t\t * @return {Integer}      Index of the processed mesh in the \"meshes\" array\n\t\t\t */\n\t\t\tfunction processMesh( mesh ) {\n\n\t\t\t\tvar meshCacheKeyParts = [ mesh.geometry.uuid ];\n\t\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\t\tfor ( var i = 0, l = mesh.material.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tvar meshCacheKey = meshCacheKeyParts.join( ':' );\n\t\t\t\tif ( cachedData.meshes.has( meshCacheKey ) ) {\n\n\t\t\t\t\treturn cachedData.meshes.get( meshCacheKey );\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = mesh.geometry;\n\n\t\t\t\tvar mode;\n\n\t\t\t\t// Use the correct mode\n\t\t\t\tif ( mesh.isLineSegments ) {\n\n\t\t\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t\t\t} else if ( mesh.isLine ) {\n\n\t\t\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t\t\t} else if ( mesh.isPoints ) {\n\n\t\t\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Exporting THREE.Geometry will increase file size. Use THREE.BufferGeometry instead.' );\n\t\t\t\t\tgeometry = new THREE.BufferGeometry().setFromObject( mesh );\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfMesh = {};\n\n\t\t\t\tvar attributes = {};\n\t\t\t\tvar primitives = [];\n\t\t\t\tvar targets = [];\n\n\t\t\t\t// Conversion between attributes names in threejs and gltf spec\n\t\t\t\tvar nameConversion = {\n\n\t\t\t\t\tuv: 'TEXCOORD_0',\n\t\t\t\t\tuv2: 'TEXCOORD_1',\n\t\t\t\t\tcolor: 'COLOR_0',\n\t\t\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\t\t\tskinIndex: 'JOINTS_0'\n\n\t\t\t\t};\n\n\t\t\t\tvar originalNormal = geometry.getAttribute( 'normal' );\n\n\t\t\t\tif ( originalNormal !== undefined && ! isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t\t\t}\n\n\t\t\t\t// @QUESTION Detect if .vertexColors = true?\n\t\t\t\t// For every attribute create an accessor\n\t\t\t\tvar modifiedAttribute = null;\n\t\t\t\tfor ( var attributeName in geometry.attributes ) {\n\n\t\t\t\t\t// Ignore morph target attributes, which are exported later.\n\t\t\t\t\tif ( attributeName.substr( 0, 5 ) === 'morph' ) continue;\n\n\t\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t\t\t// Prefix all geometry attributes except the ones specifically\n\t\t\t\t\t// listed in the spec; non-spec attributes are considered custom.\n\t\t\t\t\tvar validVertexAttributes =\n\t\t\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\t\t\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) {\n\n\t\t\t\t\t\tattributeName = '_' + attributeName;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cachedData.attributes.has( getUID( attribute ) ) ) {\n\n\t\t\t\t\t\tattributes[ attributeName ] = cachedData.attributes.get( getUID( attribute ) );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\t\t\t\t\tmodifiedAttribute = null;\n\t\t\t\t\tvar array = attribute.array;\n\t\t\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\t\t\tmodifiedAttribute = new THREE.BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar accessor = processAccessor( modifiedAttribute || attribute, geometry );\n\t\t\t\t\tif ( accessor !== null ) {\n\n\t\t\t\t\t\tattributes[ attributeName ] = accessor;\n\t\t\t\t\t\tcachedData.attributes.set( getUID( attribute ), accessor );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\n\n\t\t\t\t// Skip if no exportable attributes found\n\t\t\t\tif ( Object.keys( attributes ).length === 0 ) {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\t// Morph targets\n\t\t\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\t\t\tvar weights = [];\n\t\t\t\t\tvar targetNames = [];\n\t\t\t\t\tvar reverseDictionary = {};\n\n\t\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\t\t\tfor ( var key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\t\t\tvar target = {};\n\n\t\t\t\t\t\tvar warned = false;\n\n\t\t\t\t\t\tfor ( var attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar attribute = geometry.morphAttributes[ attributeName ][ i ];\n\t\t\t\t\t\t\tvar gltfAttributeName = attributeName.toUpperCase();\n\n\t\t\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\t\t\tvar baseAttribute = geometry.attributes[ attributeName ];\n\n\t\t\t\t\t\t\tif ( cachedData.attributes.has( getUID( attribute ) ) ) {\n\n\t\t\t\t\t\t\t\ttarget[ gltfAttributeName ] = cachedData.attributes.get( getUID( attribute ) );\n\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\t\t\tvar relativeAttribute = attribute.clone();\n\n\t\t\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t\tfor ( var j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\t\trelativeAttribute.setXYZ(\n\t\t\t\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\t\t\t\tattribute.getX( j ) - baseAttribute.getX( j ),\n\t\t\t\t\t\t\t\t\t\tattribute.getY( j ) - baseAttribute.getY( j ),\n\t\t\t\t\t\t\t\t\t\tattribute.getZ( j ) - baseAttribute.getZ( j )\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttarget[ gltfAttributeName ] = processAccessor( relativeAttribute, geometry );\n\t\t\t\t\t\t\tcachedData.attributes.set( getUID( baseAttribute ), target[ gltfAttributeName ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargets.push( target );\n\n\t\t\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\t\t\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgltfMesh.weights = weights;\n\n\t\t\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\t\t\tgltfMesh.extras = {};\n\t\t\t\t\t\tgltfMesh.extras.targetNames = targetNames;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar forceIndices = options.forceIndices;\n\t\t\t\tvar isMultiMaterial = Array.isArray( mesh.material );\n\n\t\t\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\t\t\tif ( ! forceIndices && geometry.index === null && isMultiMaterial ) {\n\n\t\t\t\t\t// temporal workaround.\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating index for non-indexed multi-material mesh.' );\n\t\t\t\t\tforceIndices = true;\n\n\t\t\t\t}\n\n\t\t\t\tvar didForceIndices = false;\n\n\t\t\t\tif ( geometry.index === null && forceIndices ) {\n\n\t\t\t\t\tvar indices = [];\n\n\t\t\t\t\tfor ( var i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {\n\n\t\t\t\t\t\tindices[ i ] = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setIndex( indices );\n\n\t\t\t\t\tdidForceIndices = true;\n\n\t\t\t\t}\n\n\t\t\t\tvar materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\t\t\tvar groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\t\t\tfor ( var i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar primitive = {\n\t\t\t\t\t\tmode: mode,\n\t\t\t\t\t\tattributes: attributes,\n\t\t\t\t\t};\n\n\t\t\t\t\tserializeUserData( geometry, primitive );\n\n\t\t\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t\t\tvar cacheKey = getUID( geometry.index );\n\n\t\t\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\n\n\t\t\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( cachedData.attributes.has( cacheKey ) ) {\n\n\t\t\t\t\t\t\tprimitive.indices = cachedData.attributes.get( cacheKey );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tprimitive.indices = processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\t\t\t\t\t\t\tcachedData.attributes.set( cacheKey, primitive.indices );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar material = processMaterial( materials[ groups[ i ].materialIndex ] );\n\n\t\t\t\t\tif ( material !== null ) {\n\n\t\t\t\t\t\tprimitive.material = material;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tprimitives.push( primitive );\n\n\t\t\t\t}\n\n\t\t\t\tif ( didForceIndices ) {\n\n\t\t\t\t\tgeometry.setIndex( null );\n\n\t\t\t\t}\n\n\t\t\t\tgltfMesh.primitives = primitives;\n\n\t\t\t\tif ( ! outputJSON.meshes ) {\n\n\t\t\t\t\toutputJSON.meshes = [];\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.meshes.push( gltfMesh );\n\n\t\t\t\tvar index = outputJSON.meshes.length - 1;\n\t\t\t\tcachedData.meshes.set( meshCacheKey, index );\n\n\t\t\t\treturn index;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process camera\n\t\t\t * @param  {THREE.Camera} camera Camera to process\n\t\t\t * @return {Integer}      Index of the processed mesh in the \"camera\" array\n\t\t\t */\n\t\t\tfunction processCamera( camera ) {\n\n\t\t\t\tif ( ! outputJSON.cameras ) {\n\n\t\t\t\t\toutputJSON.cameras = [];\n\n\t\t\t\t}\n\n\t\t\t\tvar isOrtho = camera.isOrthographicCamera;\n\n\t\t\t\tvar gltfCamera = {\n\n\t\t\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\n\t\t\t\t};\n\n\t\t\t\tif ( isOrtho ) {\n\n\t\t\t\t\tgltfCamera.orthographic = {\n\n\t\t\t\t\t\txmag: camera.right * 2,\n\t\t\t\t\t\tymag: camera.top * 2,\n\t\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgltfCamera.perspective = {\n\n\t\t\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\t\t\tyfov: THREE.MathUtils.degToRad( camera.fov ),\n\t\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tif ( camera.name !== '' ) {\n\n\t\t\t\t\tgltfCamera.name = camera.type;\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.cameras.push( gltfCamera );\n\n\t\t\t\treturn outputJSON.cameras.length - 1;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Creates glTF animation entry from AnimationClip object.\n\t\t\t *\n\t\t\t * Status:\n\t\t\t * - Only properties listed in PATH_PROPERTIES may be animated.\n\t\t\t *\n\t\t\t * @param {THREE.AnimationClip} clip\n\t\t\t * @param {THREE.Object3D} root\n\t\t\t * @return {number}\n\t\t\t */\n\t\t\tfunction processAnimation( clip, root ) {\n\n\t\t\t\tif ( ! outputJSON.animations ) {\n\n\t\t\t\t\toutputJSON.animations = [];\n\n\t\t\t\t}\n\n\t\t\t\tclip = THREE.GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\n\n\t\t\t\tvar tracks = clip.tracks;\n\t\t\t\tvar channels = [];\n\t\t\t\tvar samplers = [];\n\n\t\t\t\tfor ( var i = 0; i < tracks.length; ++ i ) {\n\n\t\t\t\t\tvar track = tracks[ i ];\n\t\t\t\t\tvar trackBinding = THREE.PropertyBinding.parseTrackName( track.name );\n\t\t\t\t\tvar trackNode = THREE.PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\t\t\tvar trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar inputItemSize = 1;\n\t\t\t\t\tvar outputItemSize = track.values.length / track.times.length;\n\n\t\t\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar interpolation;\n\n\t\t\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t\t\t// valid value from .getInterpolation().\n\t\t\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\t\t\toutputItemSize /= 3;\n\n\t\t\t\t\t} else if ( track.getInterpolation() === THREE.InterpolateDiscrete ) {\n\n\t\t\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsamplers.push( {\n\n\t\t\t\t\t\tinput: processAccessor( new THREE.BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\t\t\toutput: processAccessor( new THREE.BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\t\t\tinterpolation: interpolation\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tchannels.push( {\n\n\t\t\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\t\t\ttarget: {\n\t\t\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\t\t\tpath: trackProperty\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.animations.push( {\n\n\t\t\t\t\tname: clip.name || 'clip_' + outputJSON.animations.length,\n\t\t\t\t\tsamplers: samplers,\n\t\t\t\t\tchannels: channels\n\n\t\t\t\t} );\n\n\t\t\t\treturn outputJSON.animations.length - 1;\n\n\t\t\t}\n\n\t\t\tfunction processSkin( object ) {\n\n\t\t\t\tvar node = outputJSON.nodes[ nodeMap.get( object ) ];\n\n\t\t\t\tvar skeleton = object.skeleton;\n\n\t\t\t\tif ( skeleton === undefined ) return null;\n\n\t\t\t\tvar rootJoint = object.skeleton.bones[ 0 ];\n\n\t\t\t\tif ( rootJoint === undefined ) return null;\n\n\t\t\t\tvar joints = [];\n\t\t\t\tvar inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\n\t\t\t\tfor ( var i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\n\t\t\t\t\tskeleton.boneInverses[ i ].toArray( inverseBindMatrices, i * 16 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( outputJSON.skins === undefined ) {\n\n\t\t\t\t\toutputJSON.skins = [];\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.skins.push( {\n\n\t\t\t\t\tinverseBindMatrices: processAccessor( new THREE.BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\t\t\tjoints: joints,\n\t\t\t\t\tskeleton: nodeMap.get( rootJoint )\n\n\t\t\t\t} );\n\n\t\t\t\tvar skinIndex = node.skin = outputJSON.skins.length - 1;\n\n\t\t\t\treturn skinIndex;\n\n\t\t\t}\n\n\t\t\tfunction processLight( light ) {\n\n\t\t\t\tvar lightDef = {};\n\n\t\t\t\tif ( light.name ) lightDef.name = light.name;\n\n\t\t\t\tlightDef.color = light.color.toArray();\n\n\t\t\t\tlightDef.intensity = light.intensity;\n\n\t\t\t\tif ( light.isDirectionalLight ) {\n\n\t\t\t\t\tlightDef.type = 'directional';\n\n\t\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\t\tlightDef.type = 'point';\n\t\t\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\t\tlightDef.type = 'spot';\n\t\t\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\t\t\t\t\tlightDef.spot = {};\n\t\t\t\t\tlightDef.spot.innerConeAngle = ( light.penumbra - 1.0 ) * light.angle * - 1.0;\n\t\t\t\t\tlightDef.spot.outerConeAngle = light.angle;\n\n\t\t\t\t}\n\n\t\t\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\n\t\t\t\t\t\t+ 'and expects light.decay=2.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( light.target\n\t\t\t\t\t\t&& ( light.target.parent !== light\n\t\t\t\t\t\t || light.target.position.x !== 0\n\t\t\t\t\t\t || light.target.position.y !== 0\n\t\t\t\t\t\t || light.target.position.z !== - 1 ) ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\n\t\t\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\n\n\t\t\t\t}\n\n\t\t\t\tvar lights = outputJSON.extensions[ 'KHR_lights_punctual' ].lights;\n\t\t\t\tlights.push( lightDef );\n\t\t\t\treturn lights.length - 1;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process Object3D node\n\t\t\t * @param  {THREE.Object3D} node Object3D to processNode\n\t\t\t * @return {Integer}      Index of the node in the nodes list\n\t\t\t */\n\t\t\tfunction processNode( object ) {\n\n\t\t\t\tif ( ! outputJSON.nodes ) {\n\n\t\t\t\t\toutputJSON.nodes = [];\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfNode = {};\n\n\t\t\t\tif ( options.trs ) {\n\n\t\t\t\t\tvar rotation = object.quaternion.toArray();\n\t\t\t\t\tvar position = object.position.toArray();\n\t\t\t\t\tvar scale = object.scale.toArray();\n\n\t\t\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\t\t\tgltfNode.rotation = rotation;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\t\t\tgltfNode.translation = position;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\t\t\tgltfNode.scale = scale;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\t\t\tobject.updateMatrix();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! equalArray( object.matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\t\t\tgltfNode.matrix = object.matrix.elements;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\t\t\tif ( object.name !== '' ) {\n\n\t\t\t\t\tgltfNode.name = String( object.name );\n\n\t\t\t\t}\n\n\t\t\t\tserializeUserData( object, gltfNode );\n\n\t\t\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\t\tvar mesh = processMesh( object );\n\n\t\t\t\t\tif ( mesh !== null ) {\n\n\t\t\t\t\t\tgltfNode.mesh = mesh;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isCamera ) {\n\n\t\t\t\t\tgltfNode.camera = processCamera( object );\n\n\t\t\t\t} else if ( object.isDirectionalLight || object.isPointLight || object.isSpotLight ) {\n\n\t\t\t\t\tif ( ! extensionsUsed[ 'KHR_lights_punctual' ] ) {\n\n\t\t\t\t\t\toutputJSON.extensions = outputJSON.extensions || {};\n\t\t\t\t\t\toutputJSON.extensions[ 'KHR_lights_punctual' ] = { lights: [] };\n\t\t\t\t\t\textensionsUsed[ 'KHR_lights_punctual' ] = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgltfNode.extensions = gltfNode.extensions || {};\n\t\t\t\t\tgltfNode.extensions[ 'KHR_lights_punctual' ] = { light: processLight( object ) };\n\n\t\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', object );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\tskins.push( object );\n\n\t\t\t\t}\n\n\t\t\t\tif ( object.children.length > 0 ) {\n\n\t\t\t\t\tvar children = [];\n\n\t\t\t\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar child = object.children[ i ];\n\n\t\t\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\t\t\tvar node = processNode( child );\n\n\t\t\t\t\t\t\tif ( node !== null ) {\n\n\t\t\t\t\t\t\t\tchildren.push( node );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( children.length > 0 ) {\n\n\t\t\t\t\t\tgltfNode.children = children;\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.nodes.push( gltfNode );\n\n\t\t\t\tvar nodeIndex = outputJSON.nodes.length - 1;\n\t\t\t\tnodeMap.set( object, nodeIndex );\n\n\t\t\t\treturn nodeIndex;\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Process Scene\n\t\t\t * @param  {THREE.Scene} node Scene to process\n\t\t\t */\n\t\t\tfunction processScene( scene ) {\n\n\t\t\t\tif ( ! outputJSON.scenes ) {\n\n\t\t\t\t\toutputJSON.scenes = [];\n\t\t\t\t\toutputJSON.scene = 0;\n\n\t\t\t\t}\n\n\t\t\t\tvar gltfScene = {};\n\n\t\t\t\tif ( scene.name !== '' ) {\n\n\t\t\t\t\tgltfScene.name = scene.name;\n\n\t\t\t\t}\n\n\t\t\t\toutputJSON.scenes.push( gltfScene );\n\n\t\t\t\tvar nodes = [];\n\n\t\t\t\tfor ( var i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = scene.children[ i ];\n\n\t\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\t\tvar node = processNode( child );\n\n\t\t\t\t\t\tif ( node !== null ) {\n\n\t\t\t\t\t\t\tnodes.push( node );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodes.length > 0 ) {\n\n\t\t\t\t\tgltfScene.nodes = nodes;\n\n\t\t\t\t}\n\n\t\t\t\tserializeUserData( scene, gltfScene );\n\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Creates a THREE.Scene to hold a list of objects and parse it\n\t\t\t * @param  {Array} objects List of objects to process\n\t\t\t */\n\t\t\tfunction processObjects( objects ) {\n\n\t\t\t\tvar scene = new THREE.Scene();\n\t\t\t\tscene.name = 'AuxScene';\n\n\t\t\t\tfor ( var i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\t\t\tscene.children.push( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tprocessScene( scene );\n\n\t\t\t}\n\n\t\t\tfunction processInput( input ) {\n\n\t\t\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\t\t\tvar objectsWithoutScene = [];\n\n\t\t\t\tfor ( var i = 0; i < input.length; i ++ ) {\n\n\t\t\t\t\tif ( input[ i ] instanceof THREE.Scene ) {\n\n\t\t\t\t\t\tprocessScene( input[ i ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( objectsWithoutScene.length > 0 ) {\n\n\t\t\t\t\tprocessObjects( objectsWithoutScene );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < skins.length; ++ i ) {\n\n\t\t\t\t\tprocessSkin( skins[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\t\t\tprocessAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprocessInput( input );\n\n\t\t\tPromise.all( pending ).then( function () {\n\n\t\t\t\t// Merge buffers.\n\t\t\t\tvar blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t\t\t// Declare extensions.\n\t\t\t\tvar extensionsUsedList = Object.keys( extensionsUsed );\n\t\t\t\tif ( extensionsUsedList.length > 0 ) outputJSON.extensionsUsed = extensionsUsedList;\n\n\t\t\t\t// Update bytelength of the single buffer.\n\t\t\t\tif ( outputJSON.buffers && outputJSON.buffers.length > 0 ) outputJSON.buffers[ 0 ].byteLength = blob.size;\n\n\t\t\t\tif ( options.binary === true ) {\n\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\t\t\tvar GLB_HEADER_BYTES = 12;\n\t\t\t\t\tvar GLB_HEADER_MAGIC = 0x46546C67;\n\t\t\t\t\tvar GLB_VERSION = 2;\n\n\t\t\t\t\tvar GLB_CHUNK_PREFIX_BYTES = 8;\n\t\t\t\t\tvar GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\n\t\t\t\t\tvar GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n\t\t\t\t\tvar reader = new window.FileReader();\n\t\t\t\t\treader.readAsArrayBuffer( blob );\n\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\t// Binary chunk.\n\t\t\t\t\t\tvar binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\t\t\tvar binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t\t\t// JSON chunk.\n\t\t\t\t\t\tvar jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( outputJSON ) ), 0x20 );\n\t\t\t\t\t\tvar jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t\t\t// GLB header.\n\t\t\t\t\t\tvar header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\t\t\tvar headerView = new DataView( header );\n\t\t\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\t\t\tvar totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\t\t\tvar glbBlob = new Blob( [\n\t\t\t\t\t\t\theader,\n\t\t\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\t\t\tjsonChunk,\n\t\t\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\t\t\tbinaryChunk\n\t\t\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\t\t\tvar glbReader = new window.FileReader();\n\t\t\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( outputJSON.buffers && outputJSON.buffers.length > 0 ) {\n\n\t\t\t\t\t\tvar reader = new window.FileReader();\n\t\t\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\t\tvar base64data = reader.result;\n\t\t\t\t\t\t\toutputJSON.buffers[ 0 ].uri = base64data;\n\t\t\t\t\t\t\tonDone( outputJSON );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tonDone( outputJSON );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t};\n\n\tTHREE.GLTFExporter.Utils = {\n\n\t\tinsertKeyframe: function ( track, time ) {\n\n\t\t\tvar tolerance = 0.001; // 1ms\n\t\t\tvar valueSize = track.getValueSize();\n\n\t\t\tvar times = new track.TimeBufferType( track.times.length + 1 );\n\t\t\tvar values = new track.ValueBufferType( track.values.length + valueSize );\n\t\t\tvar interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\n\n\t\t\tvar index;\n\n\t\t\tif ( track.times.length === 0 ) {\n\n\t\t\t\ttimes[ 0 ] = time;\n\n\t\t\t\tfor ( var i = 0; i < valueSize; i ++ ) {\n\n\t\t\t\t\tvalues[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tindex = 0;\n\n\t\t\t} else if ( time < track.times[ 0 ] ) {\n\n\t\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\n\n\t\t\t\ttimes[ 0 ] = time;\n\t\t\t\ttimes.set( track.times, 1 );\n\n\t\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\n\t\t\t\tvalues.set( track.values, valueSize );\n\n\t\t\t\tindex = 0;\n\n\t\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\n\n\t\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\n\n\t\t\t\t\treturn track.times.length - 1;\n\n\t\t\t\t}\n\n\t\t\t\ttimes[ times.length - 1 ] = time;\n\t\t\t\ttimes.set( track.times, 0 );\n\n\t\t\t\tvalues.set( track.values, 0 );\n\t\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\n\n\t\t\t\tindex = times.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < track.times.length; i ++ ) {\n\n\t\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\n\n\t\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\n\n\t\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\n\t\t\t\t\t\ttimes[ i + 1 ] = time;\n\t\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\n\n\t\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\n\t\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\n\t\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\n\n\t\t\t\t\t\tindex = i + 1;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttrack.times = times;\n\t\t\ttrack.values = values;\n\n\t\t\treturn index;\n\n\t\t},\n\n\t\tmergeMorphTargetTracks: function ( clip, root ) {\n\n\t\t\tvar tracks = [];\n\t\t\tvar mergedTracks = {};\n\t\t\tvar sourceTracks = clip.tracks;\n\n\t\t\tfor ( var i = 0; i < sourceTracks.length; ++ i ) {\n\n\t\t\t\tvar sourceTrack = sourceTracks[ i ];\n\t\t\t\tvar sourceTrackBinding = THREE.PropertyBinding.parseTrackName( sourceTrack.name );\n\t\t\t\tvar sourceTrackNode = THREE.PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\n\n\t\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\n\n\t\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n\t\t\t\t\ttracks.push( sourceTrack );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\n\t\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\n\n\t\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\t\t\t// This should never happen, because glTF morph target animations\n\t\t\t\t\t\t// affect all targets already.\n\t\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\n\n\t\t\t\t\tsourceTrack = sourceTrack.clone();\n\t\t\t\t\tsourceTrack.setInterpolation( THREE.InterpolateLinear );\n\n\t\t\t\t}\n\n\t\t\t\tvar targetCount = sourceTrackNode.morphTargetInfluences.length;\n\t\t\t\tvar targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\n\n\t\t\t\tif ( targetIndex === undefined ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\n\n\t\t\t\t}\n\n\t\t\t\tvar mergedTrack;\n\n\t\t\t\t// If this is the first time we've seen this object, create a new\n\t\t\t\t// track to store merged keyframe data for each morph target.\n\t\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\n\n\t\t\t\t\tmergedTrack = sourceTrack.clone();\n\n\t\t\t\t\tvar values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\n\n\t\t\t\t\tfor ( var j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmergedTrack.name = '.morphTargetInfluences';\n\t\t\t\t\tmergedTrack.values = values;\n\n\t\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\n\t\t\t\t\ttracks.push( mergedTrack );\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\n\n\t\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\n\n\t\t\t\t// For every existing keyframe of the merged track, write a (possibly\n\t\t\t\t// interpolated) value from the source track.\n\t\t\t\tfor ( var j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\n\n\t\t\t\t}\n\n\t\t\t\t// For every existing keyframe of the source track, write a (possibly\n\t\t\t\t// new) keyframe to the merged track. Values from the previous loop may\n\t\t\t\t// be written again, but keyframes are de-duplicated.\n\t\t\t\tfor ( var j = 0; j < sourceTrack.times.length; j ++ ) {\n\n\t\t\t\t\tvar keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\n\t\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tclip.tracks = tracks;\n\n\t\t\treturn clip;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.GLTFExporter;\n});\n"]}