{"version":3,"sources":["exporters/PLYExporter.js"],"names":["define","THREE","threex","PLYExporter","prototype","constructor","parse","object","onDone","options","traverseMeshes","cb","traverse","child","isMesh","mesh","geometry","isGeometry","geomToBufferGeom","get","isBufferGeometry","undefined","getAttribute","console","warn","excludeAttributes","Object","assign","binary","littleEndian","WeakMap","includeNormals","includeColors","includeUVs","vertexCount","faceCount","bufferGeometry","BufferGeometry","setFromObject","set","vertices","normals","uvs","colors","indices","getIndex","count","includeIndices","indexOf","Math","floor","error","header","vertex","Vector3","normalMatrixWorld","Matrix3","result","headerBin","TextEncoder","encode","vertexListLength","faceListLength","output","DataView","ArrayBuffer","length","Uint8Array","buffer","vOffset","fOffset","writtenVertices","getNormalMatrix","matrixWorld","i","l","x","getX","y","getY","z","getZ","applyMatrix4","setFloat32","applyMatrix3","normalize","setUint8","setUint32","vertexList","faceList","line","requestAnimationFrame","exporters"],"mappings":"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","file":"../../exporters/PLYExporter.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    var PLYExporter = function () {\n    };\n    PLYExporter.prototype = {\n        constructor: PLYExporter,\n        parse: function (object, onDone, options) {\n            if (onDone && typeof onDone === 'object') {\n                console.warn('THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.');\n                options = onDone;\n                onDone = undefined;\n            }\n            function traverseMeshes(cb) {\n                object.traverse(function (child) {\n                    if (child.isMesh === true) {\n                        var mesh = child;\n                        var geometry = mesh.geometry;\n                        if (geometry.isGeometry === true) {\n                            geometry = geomToBufferGeom.get(geometry);\n                        }\n                        if (geometry.isBufferGeometry === true) {\n                            if (geometry.getAttribute('position') !== undefined) {\n                                cb(mesh, geometry);\n                            }\n                        }\n                    }\n                });\n            }\n            var defaultOptions = {\n                binary: false,\n                excludeAttributes: [],\n                littleEndian: false\n            };\n            options = Object.assign(defaultOptions, options);\n            var excludeAttributes = options.excludeAttributes;\n            var geomToBufferGeom = new WeakMap();\n            var includeNormals = false;\n            var includeColors = false;\n            var includeUVs = false;\n            var vertexCount = 0;\n            var faceCount = 0;\n            object.traverse(function (child) {\n                if (child.isMesh === true) {\n                    var mesh = child;\n                    var geometry = mesh.geometry;\n                    if (geometry.isGeometry === true) {\n                        var bufferGeometry = geomToBufferGeom.get(geometry) || new THREE.BufferGeometry().setFromObject(mesh);\n                        geomToBufferGeom.set(geometry, bufferGeometry);\n                        geometry = bufferGeometry;\n                    }\n                    if (geometry.isBufferGeometry === true) {\n                        var vertices = geometry.getAttribute('position');\n                        var normals = geometry.getAttribute('normal');\n                        var uvs = geometry.getAttribute('uv');\n                        var colors = geometry.getAttribute('color');\n                        var indices = geometry.getIndex();\n                        if (vertices === undefined) {\n                            return;\n                        }\n                        vertexCount += vertices.count;\n                        faceCount += indices ? indices.count / 3 : vertices.count / 3;\n                        if (normals !== undefined)\n                            includeNormals = true;\n                        if (uvs !== undefined)\n                            includeUVs = true;\n                        if (colors !== undefined)\n                            includeColors = true;\n                    }\n                }\n            });\n            var includeIndices = excludeAttributes.indexOf('index') === -1;\n            includeNormals = includeNormals && excludeAttributes.indexOf('normal') === -1;\n            includeColors = includeColors && excludeAttributes.indexOf('color') === -1;\n            includeUVs = includeUVs && excludeAttributes.indexOf('uv') === -1;\n            if (includeIndices && faceCount !== Math.floor(faceCount)) {\n                console.error('PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' + 'number of indices is not divisible by 3.');\n                return null;\n            }\n            var indexByteCount = 4;\n            var header = 'ply\\n' + `format ${ options.binary ? options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' : 'ascii' } 1.0\\n` + `element vertex ${ vertexCount }\\n` + 'property float x\\n' + 'property float y\\n' + 'property float z\\n';\n            if (includeNormals === true) {\n                header += 'property float nx\\n' + 'property float ny\\n' + 'property float nz\\n';\n            }\n            if (includeUVs === true) {\n                header += 'property float s\\n' + 'property float t\\n';\n            }\n            if (includeColors === true) {\n                header += 'property uchar red\\n' + 'property uchar green\\n' + 'property uchar blue\\n';\n            }\n            if (includeIndices === true) {\n                header += `element face ${ faceCount }\\n` + `property list uchar int vertex_index\\n`;\n            }\n            header += 'end_header\\n';\n            var vertex = new THREE.Vector3();\n            var normalMatrixWorld = new THREE.Matrix3();\n            var result = null;\n            if (options.binary === true) {\n                var headerBin = new TextEncoder().encode(header);\n                var vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0));\n                var faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n                var output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n                new Uint8Array(output.buffer).set(headerBin, 0);\n                var vOffset = headerBin.length;\n                var fOffset = headerBin.length + vertexListLength;\n                var writtenVertices = 0;\n                traverseMeshes(function (mesh, geometry) {\n                    var vertices = geometry.getAttribute('position');\n                    var normals = geometry.getAttribute('normal');\n                    var uvs = geometry.getAttribute('uv');\n                    var colors = geometry.getAttribute('color');\n                    var indices = geometry.getIndex();\n                    normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n                    for (var i = 0, l = vertices.count; i < l; i++) {\n                        vertex.x = vertices.getX(i);\n                        vertex.y = vertices.getY(i);\n                        vertex.z = vertices.getZ(i);\n                        vertex.applyMatrix4(mesh.matrixWorld);\n                        output.setFloat32(vOffset, vertex.x, options.littleEndian);\n                        vOffset += 4;\n                        output.setFloat32(vOffset, vertex.y, options.littleEndian);\n                        vOffset += 4;\n                        output.setFloat32(vOffset, vertex.z, options.littleEndian);\n                        vOffset += 4;\n                        if (includeNormals === true) {\n                            if (normals != null) {\n                                vertex.x = normals.getX(i);\n                                vertex.y = normals.getY(i);\n                                vertex.z = normals.getZ(i);\n                                vertex.applyMatrix3(normalMatrixWorld).normalize();\n                                output.setFloat32(vOffset, vertex.x, options.littleEndian);\n                                vOffset += 4;\n                                output.setFloat32(vOffset, vertex.y, options.littleEndian);\n                                vOffset += 4;\n                                output.setFloat32(vOffset, vertex.z, options.littleEndian);\n                                vOffset += 4;\n                            } else {\n                                output.setFloat32(vOffset, 0, options.littleEndian);\n                                vOffset += 4;\n                                output.setFloat32(vOffset, 0, options.littleEndian);\n                                vOffset += 4;\n                                output.setFloat32(vOffset, 0, options.littleEndian);\n                                vOffset += 4;\n                            }\n                        }\n                        if (includeUVs === true) {\n                            if (uvs != null) {\n                                output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n                                vOffset += 4;\n                                output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n                                vOffset += 4;\n                            } else if (includeUVs !== false) {\n                                output.setFloat32(vOffset, 0, options.littleEndian);\n                                vOffset += 4;\n                                output.setFloat32(vOffset, 0, options.littleEndian);\n                                vOffset += 4;\n                            }\n                        }\n                        if (includeColors === true) {\n                            if (colors != null) {\n                                output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\n                                vOffset += 1;\n                                output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\n                                vOffset += 1;\n                                output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\n                                vOffset += 1;\n                            } else {\n                                output.setUint8(vOffset, 255);\n                                vOffset += 1;\n                                output.setUint8(vOffset, 255);\n                                vOffset += 1;\n                                output.setUint8(vOffset, 255);\n                                vOffset += 1;\n                            }\n                        }\n                    }\n                    if (includeIndices === true) {\n                        if (indices !== null) {\n                            for (var i = 0, l = indices.count; i < l; i += 3) {\n                                output.setUint8(fOffset, 3);\n                                fOffset += 1;\n                                output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian);\n                                fOffset += indexByteCount;\n                                output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian);\n                                fOffset += indexByteCount;\n                                output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian);\n                                fOffset += indexByteCount;\n                            }\n                        } else {\n                            for (var i = 0, l = vertices.count; i < l; i += 3) {\n                                output.setUint8(fOffset, 3);\n                                fOffset += 1;\n                                output.setUint32(fOffset, writtenVertices + i, options.littleEndian);\n                                fOffset += indexByteCount;\n                                output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian);\n                                fOffset += indexByteCount;\n                                output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian);\n                                fOffset += indexByteCount;\n                            }\n                        }\n                    }\n                    writtenVertices += vertices.count;\n                });\n                result = output.buffer;\n            } else {\n                var writtenVertices = 0;\n                var vertexList = '';\n                var faceList = '';\n                traverseMeshes(function (mesh, geometry) {\n                    var vertices = geometry.getAttribute('position');\n                    var normals = geometry.getAttribute('normal');\n                    var uvs = geometry.getAttribute('uv');\n                    var colors = geometry.getAttribute('color');\n                    var indices = geometry.getIndex();\n                    normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n                    for (var i = 0, l = vertices.count; i < l; i++) {\n                        vertex.x = vertices.getX(i);\n                        vertex.y = vertices.getY(i);\n                        vertex.z = vertices.getZ(i);\n                        vertex.applyMatrix4(mesh.matrixWorld);\n                        var line = vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n                        if (includeNormals === true) {\n                            if (normals != null) {\n                                vertex.x = normals.getX(i);\n                                vertex.y = normals.getY(i);\n                                vertex.z = normals.getZ(i);\n                                vertex.applyMatrix3(normalMatrixWorld).normalize();\n                                line += ' ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n                            } else {\n                                line += ' 0 0 0';\n                            }\n                        }\n                        if (includeUVs === true) {\n                            if (uvs != null) {\n                                line += ' ' + uvs.getX(i) + ' ' + uvs.getY(i);\n                            } else if (includeUVs !== false) {\n                                line += ' 0 0';\n                            }\n                        }\n                        if (includeColors === true) {\n                            if (colors != null) {\n                                line += ' ' + Math.floor(colors.getX(i) * 255) + ' ' + Math.floor(colors.getY(i) * 255) + ' ' + Math.floor(colors.getZ(i) * 255);\n                            } else {\n                                line += ' 255 255 255';\n                            }\n                        }\n                        vertexList += line + '\\n';\n                    }\n                    if (includeIndices === true) {\n                        if (indices !== null) {\n                            for (var i = 0, l = indices.count; i < l; i += 3) {\n                                faceList += `3 ${ indices.getX(i + 0) + writtenVertices }`;\n                                faceList += ` ${ indices.getX(i + 1) + writtenVertices }`;\n                                faceList += ` ${ indices.getX(i + 2) + writtenVertices }\\n`;\n                            }\n                        } else {\n                            for (var i = 0, l = vertices.count; i < l; i += 3) {\n                                faceList += `3 ${ writtenVertices + i } ${ writtenVertices + i + 1 } ${ writtenVertices + i + 2 }\\n`;\n                            }\n                        }\n                        faceCount += indices ? indices.count / 3 : vertices.count / 3;\n                    }\n                    writtenVertices += vertices.count;\n                });\n                result = `${ header }${ vertexList }${ includeIndices ? `${ faceList }\\n` : '\\n' }`;\n            }\n            if (typeof onDone === 'function')\n                requestAnimationFrame(() => onDone(result));\n            return result;\n        }\n    };\n    \n    return threex.exporters.PLYExporter = PLYExporter;\n});"]}