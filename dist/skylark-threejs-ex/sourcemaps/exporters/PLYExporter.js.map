{"version":3,"sources":["exporters/PLYExporter.js"],"names":["define","THREE","PLYExporter","prototype","constructor","parse","object","onDone","options","traverseMeshes","cb","traverse","child","isMesh","mesh","geometry","isGeometry","geomToBufferGeom","get","isBufferGeometry","undefined","getAttribute","console","warn","excludeAttributes","Object","assign","binary","littleEndian","WeakMap","includeNormals","includeColors","includeUVs","vertexCount","faceCount","bufferGeometry","BufferGeometry","setFromObject","set","vertices","normals","uvs","colors","indices","getIndex","count","includeIndices","indexOf","Math","floor","error","header","vertex","Vector3","normalMatrixWorld","Matrix3","result","headerBin","TextEncoder","encode","vertexListLength","faceListLength","output","DataView","ArrayBuffer","length","Uint8Array","buffer","vOffset","fOffset","writtenVertices","getNormalMatrix","matrixWorld","i","l","x","getX","y","getY","z","getZ","applyMatrix4","setFloat32","applyMatrix3","normalize","setUint8","setUint32","vertexList","faceList","line","requestAnimationFrame"],"mappings":"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","file":"../../exporters/PLYExporter.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Garrett Johnson / http://gkjohnson.github.io/\n\t * https://github.com/gkjohnson/ply-exporter-js\n\t *\n\t * Usage:\n\t *  var exporter = new THREE.PLYExporter();\n\t *\n\t *  // second argument is a list of options\n\t *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\n\t *\n\t * Format Definition:\n\t * http://paulbourke.net/dataformats/ply/\n\t */\n\n\tTHREE.PLYExporter = function () {};\n\n\tTHREE.PLYExporter.prototype = {\n\n\t\tconstructor: THREE.PLYExporter,\n\n\t\tparse: function ( object, onDone, options ) {\n\n\t\t\tif ( onDone && typeof onDone === 'object' ) {\n\n\t\t\t\tconsole.warn( 'THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.' );\n\t\t\t\toptions = onDone;\n\t\t\t\tonDone = undefined;\n\n\t\t\t}\n\n\t\t\t// Iterate over the valid meshes in the object\n\t\t\tfunction traverseMeshes( cb ) {\n\n\t\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\t\t\tvar mesh = child;\n\t\t\t\t\t\tvar geometry = mesh.geometry;\n\n\t\t\t\t\t\tif ( geometry.isGeometry === true ) {\n\n\t\t\t\t\t\t\tgeometry = geomToBufferGeom.get( geometry );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( geometry.isBufferGeometry === true ) {\n\n\t\t\t\t\t\t\tif ( geometry.getAttribute( 'position' ) !== undefined ) {\n\n\t\t\t\t\t\t\t\tcb( mesh, geometry );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// Default options\n\t\t\tvar defaultOptions = {\n\t\t\t\tbinary: false,\n\t\t\t\texcludeAttributes: [], // normal, uv, color, index\n\t\t\t\tlittleEndian: false\n\t\t\t};\n\n\t\t\toptions = Object.assign( defaultOptions, options );\n\n\t\t\tvar excludeAttributes = options.excludeAttributes;\n\t\t\tvar geomToBufferGeom = new WeakMap();\n\t\t\tvar includeNormals = false;\n\t\t\tvar includeColors = false;\n\t\t\tvar includeUVs = false;\n\n\t\t\t// count the vertices, check which properties are used,\n\t\t\t// and cache the BufferGeometry\n\t\t\tvar vertexCount = 0;\n\t\t\tvar faceCount = 0;\n\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\t\tvar mesh = child;\n\t\t\t\t\tvar geometry = mesh.geometry;\n\n\t\t\t\t\tif ( geometry.isGeometry === true ) {\n\n\t\t\t\t\t\tvar bufferGeometry = geomToBufferGeom.get( geometry ) || new THREE.BufferGeometry().setFromObject( mesh );\n\t\t\t\t\t\tgeomToBufferGeom.set( geometry, bufferGeometry );\n\t\t\t\t\t\tgeometry = bufferGeometry;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.isBufferGeometry === true ) {\n\n\t\t\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\t\t\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\n\t\t\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\n\t\t\t\t\t\tvar colors = geometry.getAttribute( 'color' );\n\t\t\t\t\t\tvar indices = geometry.getIndex();\n\n\t\t\t\t\t\tif ( vertices === undefined ) {\n\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvertexCount += vertices.count;\n\t\t\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\n\t\t\t\t\t\tif ( normals !== undefined ) includeNormals = true;\n\n\t\t\t\t\t\tif ( uvs !== undefined ) includeUVs = true;\n\n\t\t\t\t\t\tif ( colors !== undefined ) includeColors = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tvar includeIndices = excludeAttributes.indexOf( 'index' ) === - 1;\n\t\t\tincludeNormals = includeNormals && excludeAttributes.indexOf( 'normal' ) === - 1;\n\t\t\tincludeColors = includeColors && excludeAttributes.indexOf( 'color' ) === - 1;\n\t\t\tincludeUVs = includeUVs && excludeAttributes.indexOf( 'uv' ) === - 1;\n\n\n\t\t\tif ( includeIndices && faceCount !== Math.floor( faceCount ) ) {\n\n\t\t\t\t// point cloud meshes will not have an index array and may not have a\n\t\t\t\t// number of vertices that is divisble by 3 (and therefore representable\n\t\t\t\t// as triangles)\n\t\t\t\tconsole.error(\n\n\t\t\t\t\t'PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' +\n\t\t\t\t\t'number of indices is not divisible by 3.'\n\n\t\t\t\t);\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar indexByteCount = 4;\n\n\t\t\tvar header =\n\t\t\t\t'ply\\n' +\n\t\t\t\t`format ${ options.binary ? ( options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' ) : 'ascii' } 1.0\\n` +\n\t\t\t\t`element vertex ${vertexCount}\\n` +\n\n\t\t\t\t// position\n\t\t\t\t'property float x\\n' +\n\t\t\t\t'property float y\\n' +\n\t\t\t\t'property float z\\n';\n\n\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t// normal\n\t\t\t\theader +=\n\t\t\t\t\t'property float nx\\n' +\n\t\t\t\t\t'property float ny\\n' +\n\t\t\t\t\t'property float nz\\n';\n\n\t\t\t}\n\n\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t// uvs\n\t\t\t\theader +=\n\t\t\t\t\t'property float s\\n' +\n\t\t\t\t\t'property float t\\n';\n\n\t\t\t}\n\n\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t// colors\n\t\t\t\theader +=\n\t\t\t\t\t'property uchar red\\n' +\n\t\t\t\t\t'property uchar green\\n' +\n\t\t\t\t\t'property uchar blue\\n';\n\n\t\t\t}\n\n\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t// faces\n\t\t\t\theader +=\n\t\t\t\t\t`element face ${faceCount}\\n` +\n\t\t\t\t\t`property list uchar int vertex_index\\n`;\n\n\t\t\t}\n\n\t\t\theader += 'end_header\\n';\n\n\n\t\t\t// Generate attribute data\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\t\t\tvar result = null;\n\n\t\t\tif ( options.binary === true ) {\n\n\t\t\t\t// Binary File Generation\n\t\t\t\tvar headerBin = new TextEncoder().encode( header );\n\n\t\t\t\t// 3 position values at 4 bytes\n\t\t\t\t// 3 normal values at 4 bytes\n\t\t\t\t// 3 color channels with 1 byte\n\t\t\t\t// 2 uv values at 4 bytes\n\t\t\t\tvar vertexListLength = vertexCount * ( 4 * 3 + ( includeNormals ? 4 * 3 : 0 ) + ( includeColors ? 3 : 0 ) + ( includeUVs ? 4 * 2 : 0 ) );\n\n\t\t\t\t// 1 byte shape desciptor\n\t\t\t\t// 3 vertex indices at ${indexByteCount} bytes\n\t\t\t\tvar faceListLength = includeIndices ? faceCount * ( indexByteCount * 3 + 1 ) : 0;\n\t\t\t\tvar output = new DataView( new ArrayBuffer( headerBin.length + vertexListLength + faceListLength ) );\n\t\t\t\tnew Uint8Array( output.buffer ).set( headerBin, 0 );\n\n\n\t\t\t\tvar vOffset = headerBin.length;\n\t\t\t\tvar fOffset = headerBin.length + vertexListLength;\n\t\t\t\tvar writtenVertices = 0;\n\t\t\t\ttraverseMeshes( function ( mesh, geometry ) {\n\n\t\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\t\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\n\t\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\n\t\t\t\t\tvar colors = geometry.getAttribute( 'color' );\n\t\t\t\t\tvar indices = geometry.getIndex();\n\n\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\n\t\t\t\t\t\t// Position information\n\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.x, options.littleEndian );\n\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.y, options.littleEndian );\n\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.z, options.littleEndian );\n\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t// Normal information\n\t\t\t\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t\t\t\tif ( normals != null ) {\n\n\t\t\t\t\t\t\t\tvertex.x = normals.getX( i );\n\t\t\t\t\t\t\t\tvertex.y = normals.getY( i );\n\t\t\t\t\t\t\t\tvertex.z = normals.getZ( i );\n\n\t\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.x, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.y, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.z, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// UV information\n\t\t\t\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t\t\t\tif ( uvs != null ) {\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getX( i ), options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getY( i ), options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t} else if ( includeUVs !== false ) {\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Color information\n\t\t\t\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t\t\t\tif ( colors != null ) {\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getX( i ) * 255 ) );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getY( i ) * 255 ) );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getZ( i ) * 255 ) );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t\t\t// Create the face list\n\n\t\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\n\t\t\t\t\t\t\t\tfOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 0 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 1 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 2 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\n\t\t\t\t\t\t\t\tfOffset += 1;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i + 1, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i + 2, options.littleEndian );\n\t\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// Save the amount of verts we've already written so we can offset\n\t\t\t\t\t// the face index on the next mesh\n\t\t\t\t\twrittenVertices += vertices.count;\n\n\t\t\t\t} );\n\n\t\t\t\tresult = output.buffer;\n\n\t\t\t} else {\n\n\t\t\t\t// Ascii File Generation\n\t\t\t\t// count the number of vertices\n\t\t\t\tvar writtenVertices = 0;\n\t\t\t\tvar vertexList = '';\n\t\t\t\tvar faceList = '';\n\n\t\t\t\ttraverseMeshes( function ( mesh, geometry ) {\n\n\t\t\t\t\tvar vertices = geometry.getAttribute( 'position' );\n\t\t\t\t\tvar normals = geometry.getAttribute( 'normal' );\n\t\t\t\t\tvar uvs = geometry.getAttribute( 'uv' );\n\t\t\t\t\tvar colors = geometry.getAttribute( 'color' );\n\t\t\t\t\tvar indices = geometry.getIndex();\n\n\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\t\t// form each line\n\t\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\n\t\t\t\t\t\t// Position information\n\t\t\t\t\t\tvar line =\n\t\t\t\t\t\t\tvertex.x + ' ' +\n\t\t\t\t\t\t\tvertex.y + ' ' +\n\t\t\t\t\t\t\tvertex.z;\n\n\t\t\t\t\t\t// Normal information\n\t\t\t\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t\t\t\tif ( normals != null ) {\n\n\t\t\t\t\t\t\t\tvertex.x = normals.getX( i );\n\t\t\t\t\t\t\t\tvertex.y = normals.getY( i );\n\t\t\t\t\t\t\t\tvertex.z = normals.getZ( i );\n\n\t\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\t\tvertex.x + ' ' +\n\t\t\t\t\t\t\t\t\tvertex.y + ' ' +\n\t\t\t\t\t\t\t\t\tvertex.z;\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tline += ' 0 0 0';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// UV information\n\t\t\t\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t\t\t\tif ( uvs != null ) {\n\n\t\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\t\tuvs.getX( i ) + ' ' +\n\t\t\t\t\t\t\t\t\tuvs.getY( i );\n\n\t\t\t\t\t\t\t} else if ( includeUVs !== false ) {\n\n\t\t\t\t\t\t\t\tline += ' 0 0';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Color information\n\t\t\t\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t\t\t\tif ( colors != null ) {\n\n\t\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\t\tMath.floor( colors.getX( i ) * 255 ) + ' ' +\n\t\t\t\t\t\t\t\t\tMath.floor( colors.getY( i ) * 255 ) + ' ' +\n\t\t\t\t\t\t\t\t\tMath.floor( colors.getZ( i ) * 255 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tline += ' 255 255 255';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvertexList += line + '\\n';\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create the face list\n\t\t\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\tfaceList += `3 ${ indices.getX( i + 0 ) + writtenVertices }`;\n\t\t\t\t\t\t\t\tfaceList += ` ${ indices.getX( i + 1 ) + writtenVertices }`;\n\t\t\t\t\t\t\t\tfaceList += ` ${ indices.getX( i + 2 ) + writtenVertices }\\n`;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( var i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\tfaceList += `3 ${ writtenVertices + i } ${ writtenVertices + i + 1 } ${ writtenVertices + i + 2 }\\n`;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\twrittenVertices += vertices.count;\n\n\t\t\t\t} );\n\n\t\t\t\tresult = `${ header }${vertexList}${ includeIndices ? `${faceList}\\n` : '\\n' }`;\n\n\t\t\t}\n\n\t\t\tif ( typeof onDone === 'function' ) requestAnimationFrame( () => onDone( result ) );\n\t\t\treturn result;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.PLYExporter;\n});\n"]}