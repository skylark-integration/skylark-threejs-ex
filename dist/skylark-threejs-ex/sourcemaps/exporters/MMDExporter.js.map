{"version":3,"sources":["exporters/MMDExporter.js"],"names":["define","THREE","MMDParser","MMDExporter","u2sTable","this","parseVpd","skin","outputShiftJis","useOriginalBones","isSkinnedMesh","console","warn","toStringsFromNumber","num","Math","abs","a","toString","indexOf","index","slice","toStringsFromArray","array","i","il","length","push","join","updateMatrixWorld","bones","skeleton","bones2","poseSkin","clone","pose","getBindBones","position","Vector3","quaternion","Quaternion","quaternion2","matrix","Matrix4","name","replace","bone","bone2","undefined","userData","ik","originalMatrix","fromArray","copy","setFromMatrixPosition","setFromRotationMatrix","pArray","sub","toArray","qArray","conjugate","multiply","lines","str","table","CharsetEncoder","s2uTable","keys","Object","key","value","parseInt","code","charCodeAt","Uint8Array","unicodeToShiftjis"],"mappings":"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","file":"../../exporters/MMDExporter.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"../utils/mmdparser\"\n],function(THREE,MMDParser){\n\t/**\n\t * @author takahiro / http://github.com/takahirox\n\t *\n\t * Dependencies\n\t *  - mmd-parser https://github.com/takahirox/mmd-parser\n\t */\n\n\tTHREE.MMDExporter = function () {\n\n\t\t// Unicode to Shift_JIS table\n\t\tvar u2sTable;\n\n\t\tfunction unicodeToShiftjis( str ) {\n\n\t\t\tif ( u2sTable === undefined ) {\n\n\t\t\t\tvar encoder = new MMDParser.CharsetEncoder();\n\t\t\t\tvar table = encoder.s2uTable;\n\t\t\t\tu2sTable = {};\n\n\t\t\t\tvar keys = Object.keys( table );\n\n\t\t\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar key = keys[ i ];\n\n\t\t\t\t\tvar value = table[ key ];\n\t\t\t\t\tkey = parseInt( key );\n\n\t\t\t\t\tu2sTable[ value ] = key;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar array = [];\n\n\t\t\tfor ( var i = 0, il = str.length; i < il; i ++ ) {\n\n\t\t\t\tvar code = str.charCodeAt( i );\n\n\t\t\t\tvar value = u2sTable[ code ];\n\n\t\t\t\tif ( value === undefined ) {\n\n\t\t\t\t\tthrow 'cannot convert charcode 0x' + code.toString( 16 );\n\n\t\t\t\t} else if ( value > 0xff ) {\n\n\t\t\t\t\tarray.push( ( value >> 8 ) & 0xff );\n\t\t\t\t\tarray.push( value & 0xff );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray.push( value & 0xff );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Uint8Array( array );\n\n\t\t}\n\n\t\tfunction getBindBones( skin ) {\n\n\t\t\t// any more efficient ways?\n\t\t\tvar poseSkin = skin.clone();\n\t\t\tposeSkin.pose();\n\t\t\treturn poseSkin.skeleton.bones;\n\n\t\t}\n\n\t\t/* TODO: implement\n\t\t// mesh -> pmd\n\t\tthis.parsePmd = function ( object ) {\n\n\t\t};\n\t\t*/\n\n\t\t/* TODO: implement\n\t\t// mesh -> pmx\n\t\tthis.parsePmx = function ( object ) {\n\n\t\t};\n\t\t*/\n\n\t\t/*\n\t\t * skeleton -> vpd\n\t\t * Returns Shift_JIS encoded Uint8Array. Otherwise return strings.\n\t\t */\n\t\tthis.parseVpd = function ( skin, outputShiftJis, useOriginalBones ) {\n\n\t\t\tif ( skin.isSkinnedMesh !== true ) {\n\n\t\t\t\tconsole.warn( 'THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tfunction toStringsFromNumber( num ) {\n\n\t\t\t\tif ( Math.abs( num ) < 1e-6 ) num = 0;\n\n\t\t\t\tvar a = num.toString();\n\n\t\t\t\tif ( a.indexOf( '.' ) === - 1 ) {\n\n\t\t\t\t\ta += '.';\n\n\t\t\t\t}\n\n\t\t\t\ta += '000000';\n\n\t\t\t\tvar index = a.indexOf( '.' );\n\n\t\t\t\tvar d = a.slice( 0, index );\n\t\t\t\tvar p = a.slice( index + 1, index + 7 );\n\n\t\t\t\treturn d + '.' + p;\n\n\t\t\t}\n\n\t\t\tfunction toStringsFromArray( array ) {\n\n\t\t\t\tvar a = [];\n\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t\t\ta.push( toStringsFromNumber( array[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn a.join( ',' );\n\n\t\t\t}\n\n\t\t\tskin.updateMatrixWorld( true );\n\n\t\t\tvar bones = skin.skeleton.bones;\n\t\t\tvar bones2 = getBindBones( skin );\n\n\t\t\tvar position = new THREE.Vector3();\n\t\t\tvar quaternion = new THREE.Quaternion();\n\t\t\tvar quaternion2 = new THREE.Quaternion();\n\t\t\tvar matrix = new THREE.Matrix4();\n\n\t\t\tvar array = [];\n\t\t\tarray.push( 'Vocaloid Pose Data file' );\n\t\t\tarray.push( '' );\n\t\t\tarray.push( ( skin.name !== '' ? skin.name.replace( /\\s/g, '_' ) : 'skin' ) + '.osm;' );\n\t\t\tarray.push( bones.length + ';' );\n\t\t\tarray.push( '' );\n\n\t\t\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t\tvar bone = bones[ i ];\n\t\t\t\tvar bone2 = bones2[ i ];\n\n\t\t\t\t/*\n\t\t\t\t * use the bone matrix saved before solving IK.\n\t\t\t\t * see CCDIKSolver for the detail.\n\t\t\t\t */\n\t\t\t\tif ( useOriginalBones === true &&\n\t\t\t\t\tbone.userData.ik !== undefined &&\n\t\t\t\t\tbone.userData.ik.originalMatrix !== undefined ) {\n\n\t\t\t\t\tmatrix.fromArray( bone.userData.ik.originalMatrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmatrix.copy( bone.matrix );\n\n\t\t\t\t}\n\n\t\t\t\tposition.setFromMatrixPosition( matrix );\n\t\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\t\tvar pArray = position.sub( bone2.position ).toArray();\n\t\t\t\tvar qArray = quaternion2.copy( bone2.quaternion ).conjugate().multiply( quaternion ).toArray();\n\n\t\t\t\t// right to left\n\t\t\t\tpArray[ 2 ] = - pArray[ 2 ];\n\t\t\t\tqArray[ 0 ] = - qArray[ 0 ];\n\t\t\t\tqArray[ 1 ] = - qArray[ 1 ];\n\n\t\t\t\tarray.push( 'Bone' + i + '{' + bone.name );\n\t\t\t\tarray.push( '  ' + toStringsFromArray( pArray ) + ';' );\n\t\t\t\tarray.push( '  ' + toStringsFromArray( qArray ) + ';' );\n\t\t\t\tarray.push( '}' );\n\t\t\t\tarray.push( '' );\n\n\t\t\t}\n\n\t\t\tarray.push( '' );\n\n\t\t\tvar lines = array.join( '\\n' );\n\n\t\t\treturn ( outputShiftJis === true ) ? unicodeToShiftjis( lines ) : lines;\n\n\t\t};\n\n\t\t/* TODO: implement\n\t\t// animation + skeleton -> vmd\n\t\tthis.parseVmd = function ( object ) {\n\n\t\t};\n\t\t*/\n\n\t};\n\t\n\treturn THREE.MMDExporter;\n});\n"]}