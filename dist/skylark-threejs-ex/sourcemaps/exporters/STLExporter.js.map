{"version":3,"sources":["exporters/STLExporter.js"],"names":["define","THREE","vector","normalMatrixWorld","STLExporter","prototype","constructor","parse","Vector3","Matrix3","scene","options","undefined","binary","objects","triangles","traverse","object","isMesh","geometry","isBufferGeometry","Geometry","fromBufferGeometry","isGeometry","faces","length","push","matrixWorld","offset","arrayBuffer","ArrayBuffer","output","DataView","setUint32","i","il","vertices","getNormalMatrix","j","jl","face","copy","normal","applyMatrix3","normalize","setFloat32","x","y","z","indices","a","b","c","k","applyMatrix4","setUint16"],"mappings":"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","file":"../../exporters/STLExporter.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author kovacsv / http://kovacsv.hu/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mudcube / http://mudcu.be/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Usage:\n\t *  var exporter = new THREE.STLExporter();\n\t *\n\t *  // second argument is a list of options\n\t *  var data = exporter.parse( mesh, { binary: true } );\n\t *\n\t */\n\n\tTHREE.STLExporter = function () {};\n\n\tTHREE.STLExporter.prototype = {\n\n\t\tconstructor: THREE.STLExporter,\n\n\t\tparse: ( function () {\n\n\t\t\tvar vector = new THREE.Vector3();\n\t\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\n\t\t\treturn function parse( scene, options ) {\n\n\t\t\t\tif ( options === undefined ) options = {};\n\n\t\t\t\tvar binary = options.binary !== undefined ? options.binary : false;\n\n\t\t\t\t//\n\n\t\t\t\tvar objects = [];\n\t\t\t\tvar triangles = 0;\t\n\n\t\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.isMesh ) {\n\n\t\t\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry( geometry );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\t\t\t\ttriangles += geometry.faces.length;\n\n\t\t\t\t\t\t\tobjects.push( {\n\n\t\t\t\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\t\t\t\tmatrixWorld: object.matrixWorld\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tif ( binary ) {\n\n\t\t\t\t\tvar offset = 80; // skip header\n\t\t\t\t\tvar bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n\t\t\t\t\tvar arrayBuffer = new ArrayBuffer( bufferLength );\n\t\t\t\t\tvar output = new DataView( arrayBuffer );\n\t\t\t\t\toutput.setUint32( offset, triangles, true ); offset += 4;\n\n\t\t\t\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar object = objects[ i ];\n\n\t\t\t\t\t\tvar vertices = object.geometry.vertices;\n\t\t\t\t\t\tvar faces = object.geometry.faces;\n\t\t\t\t\t\tvar matrixWorld = object.matrixWorld;\n\n\t\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( matrixWorld );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = faces.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar face = faces[ j ];\n\n\t\t\t\t\t\t\tvector.copy( face.normal ).applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\toutput.setFloat32( offset, vector.x, true ); offset += 4; // normal\n\t\t\t\t\t\t\toutput.setFloat32( offset, vector.y, true ); offset += 4;\n\t\t\t\t\t\t\toutput.setFloat32( offset, vector.z, true ); offset += 4;\n\n\t\t\t\t\t\t\tvar indices = [ face.a, face.b, face.c ];\n\n\t\t\t\t\t\t\tfor ( var k = 0; k < 3; k ++ ) {\n\n\t\t\t\t\t\t\t\tvector.copy( vertices[ indices[ k ] ] ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\t\t\toutput.setFloat32( offset, vector.x, true ); offset += 4; // vertices\n\t\t\t\t\t\t\t\toutput.setFloat32( offset, vector.y, true ); offset += 4;\n\t\t\t\t\t\t\t\toutput.setFloat32( offset, vector.z, true ); offset += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutput.setUint16( offset, 0, true ); offset += 2; // attribute byte count\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn output;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar output = '';\n\n\t\t\t\t\toutput += 'solid exported\\n';\n\n\t\t\t\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar object = objects[ i ];\n\n\t\t\t\t\t\tvar vertices = object.geometry.vertices;\n\t\t\t\t\t\tvar faces = object.geometry.faces;\n\t\t\t\t\t\tvar matrixWorld = object.matrixWorld;\n\n\t\t\t\t\t\tnormalMatrixWorld.getNormalMatrix( matrixWorld );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = faces.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar face = faces[ j ];\n\n\t\t\t\t\t\t\tvector.copy( face.normal ).applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\toutput += '\\tfacet normal ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\\n';\n\t\t\t\t\t\t\toutput += '\\t\\touter loop\\n';\n\n\t\t\t\t\t\t\tvar indices = [ face.a, face.b, face.c ];\n\n\t\t\t\t\t\t\tfor ( var k = 0; k < 3; k ++ ) {\n\n\t\t\t\t\t\t\t\tvector.copy( vertices[ indices[ k ] ] ).applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\t\t\toutput += '\\t\\t\\tvertex ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\\n';\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutput += '\\t\\tendloop\\n';\n\t\t\t\t\t\t\toutput += '\\tendfacet\\n';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\toutput += 'endsolid exported\\n';\n\n\t\t\t\t\treturn output;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() )\n\n\t};\n\t\n\treturn THREE.STLExporter;\n});\n"]}