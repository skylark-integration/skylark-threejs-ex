{"version":3,"sources":["exporters/ColladaExporter.js"],"names":["define","THREE","ColladaExporter","prototype","constructor","parse","object","onDone","options","Object","assign","version","author","textureDirectory","replace","canvas","ctx","console","warn","imageToData","image","ext","document","createElement","getContext","width","naturalWidth","height","naturalHeight","drawImage","str","b","atob","buf","Uint8Array","length","i","l","charCodeAt","base64ToBuffer","toDataURL","transMat","getFuncs","attrBufferToArray","attr","isInterleavedBufferAttribute","arr","array","count","itemSize","size","j","getAttribute","name","params","type","join","Math","floor","map","n","processTexture","tex","texid","imageMap","get","libraryImages","imageNode","push","set","textures","directory","data","original","geometryInfo","WeakMap","materialMap","libraryGeometries","libraryEffects","libraryMaterials","libraryVisualScenes","processObject","o","node","updateMatrix","Matrix4","copy","matrix","transpose","toArray","getTransform","Mesh","geometry","geomInfo","g","st","ct","info","bufferGeometry","Geometry","BufferGeometry","fromGeometry","meshid","indexCount","index","attributes","position","groups","start","materialIndex","gnode","posName","vertName","triangleInputs","normName","normal","uvName","uv","colName","color","indexArray","Array","group","subarr","isArray","slice","buffer","BYTES_PER_ELEMENT","polycount","processGeometry","matids","mat","material","MeshBasicMaterial","materials","fill","v","m","matid","MeshLambertMaterial","emissive","Color","diffuse","specular","shininess","reflectivity","transparencyNode","transparent","opacity","techniqueNode","emissiveMap","r","normalMap","specularMap","effectnode","side","DoubleSide","materialNode","processMaterial","id","children","forEach","c","dae","Date","toISOString","urdf","IS_END_TAG","IS_SELF_CLOSING","HAS_TEXT","pad","tagnum","res","ch","num","match","tag","test","requestAnimationFrame"],"mappings":"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","file":"../../exporters/ColladaExporter.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author Garrett Johnson / http://gkjohnson.github.io/\n\t * https://github.com/gkjohnson/collada-exporter-js\n\t *\n\t * Usage:\n\t *  var exporter = new THREE.ColladaExporter();\n\t *\n\t *  var data = exporter.parse(mesh);\n\t *\n\t * Format Definition:\n\t *  https://www.khronos.org/collada/\n\t */\n\n\tTHREE.ColladaExporter = function () {};\n\n\tTHREE.ColladaExporter.prototype = {\n\n\t\tconstructor: THREE.ColladaExporter,\n\n\t\tparse: function ( object, onDone, options ) {\n\n\t\t\toptions = options || {};\n\n\t\t\toptions = Object.assign( {\n\t\t\t\tversion: '1.4.1',\n\t\t\t\tauthor: null,\n\t\t\t\ttextureDirectory: '',\n\t\t\t}, options );\n\n\t\t\tif ( options.textureDirectory !== '' ) {\n\n\t\t\t\toptions.textureDirectory = `${ options.textureDirectory }/`\n\t\t\t\t\t.replace( /\\\\/g, '/' )\n\t\t\t\t\t.replace( /\\/+/g, '/' );\n\n\t\t\t}\n\n\t\t\tvar version = options.version;\n\t\t\tif ( version !== '1.4.1' && version !== '1.5.0' ) {\n\n\t\t\t\tconsole.warn( `ColladaExporter : Version ${ version } not supported for export. Only 1.4.1 and 1.5.0.` );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Convert the urdf xml into a well-formatted, indented format\n\t\t\tfunction format( urdf ) {\n\n\t\t\t\tvar IS_END_TAG = /^<\\//;\n\t\t\t\tvar IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n\t\t\t\tvar HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n\n\t\t\t\tvar pad = ( ch, num ) => ( num > 0 ? ch + pad( ch, num - 1 ) : '' );\n\n\t\t\t\tvar tagnum = 0;\n\t\t\t\treturn urdf\n\t\t\t\t\t.match( /(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g )\n\t\t\t\t\t.map( tag => {\n\n\t\t\t\t\t\tif ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && IS_END_TAG.test( tag ) ) {\n\n\t\t\t\t\t\t\ttagnum --;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar res = `${ pad( '  ', tagnum ) }${ tag }`;\n\n\t\t\t\t\t\tif ( ! HAS_TEXT.test( tag ) && ! IS_SELF_CLOSING.test( tag ) && ! IS_END_TAG.test( tag ) ) {\n\n\t\t\t\t\t\t\ttagnum ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn res;\n\n\t\t\t\t\t} )\n\t\t\t\t\t.join( '\\n' );\n\n\t\t\t}\n\n\t\t\t// Convert an image into a png format for saving\n\t\t\tfunction base64ToBuffer( str ) {\n\n\t\t\t\tvar b = atob( str );\n\t\t\t\tvar buf = new Uint8Array( b.length );\n\n\t\t\t\tfor ( var i = 0, l = buf.length; i < l; i ++ ) {\n\n\t\t\t\t\tbuf[ i ] = b.charCodeAt( i );\n\n\t\t\t\t}\n\n\t\t\t\treturn buf;\n\n\t\t\t}\n\n\t\t\tvar canvas, ctx;\n\t\t\tfunction imageToData( image, ext ) {\n\n\t\t\t\tcanvas = canvas || document.createElement( 'canvas' );\n\t\t\t\tctx = ctx || canvas.getContext( '2d' );\n\n\t\t\t\tcanvas.width = image.naturalWidth;\n\t\t\t\tcanvas.height = image.naturalHeight;\n\n\t\t\t\tctx.drawImage( image, 0, 0 );\n\n\t\t\t\t// Get the base64 encoded data\n\t\t\t\tvar base64data = canvas\n\t\t\t\t\t.toDataURL( `image/${ ext }`, 1 )\n\t\t\t\t\t.replace( /^data:image\\/(png|jpg);base64,/, '' );\n\n\t\t\t\t// Convert to a uint8 array\n\t\t\t\treturn base64ToBuffer( base64data );\n\n\t\t\t}\n\n\t\t\t// gets the attribute array. Generate a new array if the attribute is interleaved\n\t\t\tvar getFuncs = [ 'getX', 'getY', 'getZ', 'getW' ];\n\t\t\tfunction attrBufferToArray( attr ) {\n\n\t\t\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t// use the typed array constructor to save on memory\n\t\t\t\t\tvar arr = new attr.array.constructor( attr.count * attr.itemSize );\n\t\t\t\t\tvar size = attr.itemSize;\n\t\t\t\t\tfor ( var i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tfor ( var j = 0; j < size; j ++ ) {\n\n\t\t\t\t\t\t\tarr[ i * size + j ] = attr[ getFuncs[ j ] ]( i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn arr;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn attr.array;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Returns an array of the same type starting at the `st` index,\n\t\t\t// and `ct` length\n\t\t\tfunction subArray( arr, st, ct ) {\n\n\t\t\t\tif ( Array.isArray( arr ) ) return arr.slice( st, st + ct );\n\t\t\t\telse return new arr.constructor( arr.buffer, st * arr.BYTES_PER_ELEMENT, ct );\n\n\t\t\t}\n\n\t\t\t// Returns the string for a geometry's attribute\n\t\t\tfunction getAttribute( attr, name, params, type ) {\n\n\t\t\t\tvar array = attrBufferToArray( attr );\n\t\t\t\tvar res =\n\t\t\t\t\t\t`<source id=\"${ name }\">` +\n\n\t\t\t\t\t\t`<float_array id=\"${ name }-array\" count=\"${ array.length }\">` +\n\t\t\t\t\t\tarray.join( ' ' ) +\n\t\t\t\t\t\t'</float_array>' +\n\n\t\t\t\t\t\t'<technique_common>' +\n\t\t\t\t\t\t`<accessor source=\"#${ name }-array\" count=\"${ Math.floor( array.length / attr.itemSize ) }\" stride=\"${ attr.itemSize }\">` +\n\n\t\t\t\t\t\tparams.map( n => `<param name=\"${ n }\" type=\"${ type }\" />` ).join( '' ) +\n\n\t\t\t\t\t\t'</accessor>' +\n\t\t\t\t\t\t'</technique_common>' +\n\t\t\t\t\t\t'</source>';\n\n\t\t\t\treturn res;\n\n\t\t\t}\n\n\t\t\t// Returns the string for a node's transform information\n\t\t\tvar transMat;\n\t\t\tfunction getTransform( o ) {\n\n\t\t\t\t// ensure the object's matrix is up to date\n\t\t\t\t// before saving the transform\n\t\t\t\to.updateMatrix();\n\n\t\t\t\ttransMat = transMat || new THREE.Matrix4();\n\t\t\t\ttransMat.copy( o.matrix );\n\t\t\t\ttransMat.transpose();\n\t\t\t\treturn `<matrix>${ transMat.toArray().join( ' ' ) }</matrix>`;\n\n\t\t\t}\n\n\t\t\t// Process the given piece of geometry into the geometry library\n\t\t\t// Returns the mesh id\n\t\t\tfunction processGeometry( g ) {\n\n\t\t\t\tvar info = geometryInfo.get( g );\n\n\t\t\t\tif ( ! info ) {\n\n\t\t\t\t\t// convert the geometry to bufferGeometry if it isn't already\n\t\t\t\t\tvar bufferGeometry = g;\n\t\t\t\t\tif ( bufferGeometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\t\tbufferGeometry = ( new THREE.BufferGeometry() ).fromGeometry( bufferGeometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meshid = `Mesh${ libraryGeometries.length + 1 }`;\n\n\t\t\t\t\tvar indexCount =\n\t\t\t\t\t\tbufferGeometry.index ?\n\t\t\t\t\t\t\tbufferGeometry.index.count * bufferGeometry.index.itemSize :\n\t\t\t\t\t\t\tbufferGeometry.attributes.position.count;\n\n\t\t\t\t\tvar groups =\n\t\t\t\t\t\tbufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ?\n\t\t\t\t\t\t\tbufferGeometry.groups :\n\t\t\t\t\t\t\t[ { start: 0, count: indexCount, materialIndex: 0 } ];\n\n\n\t\t\t\t\tvar gname = g.name ? ` name=\"${ g.name }\"` : '';\n\t\t\t\t\tvar gnode = `<geometry id=\"${ meshid }\"${ gname }><mesh>`;\n\n\t\t\t\t\t// define the geometry node and the vertices for the geometry\n\t\t\t\t\tvar posName = `${ meshid }-position`;\n\t\t\t\t\tvar vertName = `${ meshid }-vertices`;\n\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.position, posName, [ 'X', 'Y', 'Z' ], 'float' );\n\t\t\t\t\tgnode += `<vertices id=\"${ vertName }\"><input semantic=\"POSITION\" source=\"#${ posName }\" /></vertices>`;\n\n\t\t\t\t\t// NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n\t\t\t\t\t// can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n\t\t\t\t\t// models with attributes that share an offset.\n\t\t\t\t\t// MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n\n\t\t\t\t\t// serialize normals\n\t\t\t\t\tvar triangleInputs = `<input semantic=\"VERTEX\" source=\"#${ vertName }\" offset=\"0\" />`;\n\t\t\t\t\tif ( 'normal' in bufferGeometry.attributes ) {\n\n\t\t\t\t\t\tvar normName = `${ meshid }-normal`;\n\t\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.normal, normName, [ 'X', 'Y', 'Z' ], 'float' );\n\t\t\t\t\t\ttriangleInputs += `<input semantic=\"NORMAL\" source=\"#${ normName }\" offset=\"0\" />`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// serialize uvs\n\t\t\t\t\tif ( 'uv' in bufferGeometry.attributes ) {\n\n\t\t\t\t\t\tvar uvName = `${ meshid }-texcoord`;\n\t\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.uv, uvName, [ 'S', 'T' ], 'float' );\n\t\t\t\t\t\ttriangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${ uvName }\" offset=\"0\" set=\"0\" />`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// serialize colors\n\t\t\t\t\tif ( 'color' in bufferGeometry.attributes ) {\n\n\t\t\t\t\t\tvar colName = `${ meshid }-color`;\n\t\t\t\t\t\tgnode += getAttribute( bufferGeometry.attributes.color, colName, [ 'X', 'Y', 'Z' ], 'uint8' );\n\t\t\t\t\t\ttriangleInputs += `<input semantic=\"COLOR\" source=\"#${ colName }\" offset=\"0\" />`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar indexArray = null;\n\t\t\t\t\tif ( bufferGeometry.index ) {\n\n\t\t\t\t\t\tindexArray = attrBufferToArray( bufferGeometry.index );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tindexArray = new Array( indexCount );\n\t\t\t\t\t\tfor ( var i = 0, l = indexArray.length; i < l; i ++ ) indexArray[ i ] = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvar group = groups[ i ];\n\t\t\t\t\t\tvar subarr = subArray( indexArray, group.start, group.count );\n\t\t\t\t\t\tvar polycount = subarr.length / 3;\n\t\t\t\t\t\tgnode += `<triangles material=\"MESH_MATERIAL_${ group.materialIndex }\" count=\"${ polycount }\">`;\n\t\t\t\t\t\tgnode += triangleInputs;\n\n\t\t\t\t\t\tgnode += `<p>${ subarr.join( ' ' ) }</p>`;\n\t\t\t\t\t\tgnode += '</triangles>';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgnode += `</mesh></geometry>`;\n\n\t\t\t\t\tlibraryGeometries.push( gnode );\n\n\t\t\t\t\tinfo = { meshid: meshid, bufferGeometry: bufferGeometry };\n\t\t\t\t\tgeometryInfo.set( g, info );\n\n\t\t\t\t}\n\n\t\t\t\treturn info;\n\n\t\t\t}\n\n\t\t\t// Process the given texture into the image library\n\t\t\t// Returns the image library\n\t\t\tfunction processTexture( tex ) {\n\n\t\t\t\tvar texid = imageMap.get( tex );\n\t\t\t\tif ( texid == null ) {\n\n\t\t\t\t\ttexid = `image-${ libraryImages.length + 1 }`;\n\n\t\t\t\t\tvar ext = 'png';\n\t\t\t\t\tvar name = tex.name || texid;\n\t\t\t\t\tvar imageNode = `<image id=\"${ texid }\" name=\"${ name }\">`;\n\n\t\t\t\t\tif ( version === '1.5.0' ) {\n\n\t\t\t\t\t\timageNode += `<init_from><ref>${ options.textureDirectory }${ name }.${ ext }</ref></init_from>`;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// version image node 1.4.1\n\t\t\t\t\t\timageNode += `<init_from>${ options.textureDirectory }${ name }.${ ext }</init_from>`;\n\n\t\t\t\t\t}\n\n\t\t\t\t\timageNode += '</image>';\n\n\t\t\t\t\tlibraryImages.push( imageNode );\n\t\t\t\t\timageMap.set( tex, texid );\n\t\t\t\t\ttextures.push( {\n\t\t\t\t\t\tdirectory: options.textureDirectory,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\text,\n\t\t\t\t\t\tdata: imageToData( tex.image, ext ),\n\t\t\t\t\t\toriginal: tex\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\treturn texid;\n\n\t\t\t}\n\n\t\t\t// Process the given material into the material and effect libraries\n\t\t\t// Returns the material id\n\t\t\tfunction processMaterial( m ) {\n\n\t\t\t\tvar matid = materialMap.get( m );\n\n\t\t\t\tif ( matid == null ) {\n\n\t\t\t\t\tmatid = `Mat${ libraryEffects.length + 1 }`;\n\n\t\t\t\t\tvar type = 'phong';\n\n\t\t\t\t\tif ( m instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\t\t\t\ttype = 'lambert';\n\n\t\t\t\t\t} else if ( m instanceof THREE.MeshBasicMaterial ) {\n\n\t\t\t\t\t\ttype = 'constant';\n\n\t\t\t\t\t\tif ( m.map !== null ) {\n\n\t\t\t\t\t\t\t// The Collada spec does not support diffuse texture maps with the\n\t\t\t\t\t\t\t// constant shader type.\n\t\t\t\t\t\t\t// mrdoob/three.js#15469\n\t\t\t\t\t\t\tconsole.warn( 'ColladaExporter: Texture maps not supported with MeshBasicMaterial.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar emissive = m.emissive ? m.emissive : new THREE.Color( 0, 0, 0 );\n\t\t\t\t\tvar diffuse = m.color ? m.color : new THREE.Color( 0, 0, 0 );\n\t\t\t\t\tvar specular = m.specular ? m.specular : new THREE.Color( 1, 1, 1 );\n\t\t\t\t\tvar shininess = m.shininess || 0;\n\t\t\t\t\tvar reflectivity = m.reflectivity || 0;\n\n\t\t\t\t\t// Do not export and alpha map for the reasons mentioned in issue (#13792)\n\t\t\t\t\t// in three.js alpha maps are black and white, but collada expects the alpha\n\t\t\t\t\t// channel to specify the transparency\n\t\t\t\t\tvar transparencyNode = '';\n\t\t\t\t\tif ( m.transparent === true ) {\n\n\t\t\t\t\t\ttransparencyNode +=\n\t\t\t\t\t\t\t`<transparent>` +\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t\t\t`<texture texture=\"diffuse-sampler\"></texture>` :\n\t\t\t\t\t\t\t\t\t'<float>1</float>'\n\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t'</transparent>';\n\n\t\t\t\t\t\tif ( m.opacity < 1 ) {\n\n\t\t\t\t\t\t\ttransparencyNode += `<transparency><float>${ m.opacity }</float></transparency>`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar techniqueNode = `<technique sid=\"common\"><${ type }>` +\n\n\t\t\t\t\t\t'<emission>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.emissiveMap ?\n\t\t\t\t\t\t\t\t'<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t\t`<color sid=\"emission\">${ emissive.r } ${ emissive.g } ${ emissive.b } 1</color>`\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t'</emission>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\ttype !== 'constant' ?\n\t\t\t\t\t\t\t\t'<diffuse>' +\n\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t\t\t'<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t\t\t`<color sid=\"diffuse\">${ diffuse.r } ${ diffuse.g } ${ diffuse.b } 1</color>`\n\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t'</diffuse>'\n\t\t\t\t\t\t\t\t: ''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\ttype !== 'constant' ?\n\t\t\t\t\t\t\t\t'<bump>' +\n\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tm.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''\n\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t'</bump>'\n\t\t\t\t\t\t\t\t: ''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\ttype === 'phong' ?\n\t\t\t\t\t\t\t\t`<specular><color sid=\"specular\">${ specular.r } ${ specular.g } ${ specular.b } 1</color></specular>` +\n\n\t\t\t\t\t\t\t'<shininess>' +\n\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tm.specularMap ?\n\t\t\t\t\t\t\t\t\t'<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' :\n\t\t\t\t\t\t\t\t\t`<float sid=\"shininess\">${ shininess }</float>`\n\t\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t\t'</shininess>'\n\t\t\t\t\t\t\t\t: ''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t`<reflective><color>${ diffuse.r } ${ diffuse.g } ${ diffuse.b } 1</color></reflective>` +\n\n\t\t\t\t\t\t`<reflectivity><float>${ reflectivity }</float></reflectivity>` +\n\n\t\t\t\t\t\ttransparencyNode +\n\n\t\t\t\t\t\t`</${ type }></technique>`;\n\n\t\t\t\t\tvar effectnode =\n\t\t\t\t\t\t`<effect id=\"${ matid }-effect\">` +\n\t\t\t\t\t\t'<profile_COMMON>' +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.map ?\n\t\t\t\t\t\t\t\t'<newparam sid=\"diffuse-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t\t`<init_from>${ processTexture( m.map ) }</init_from>` +\n\t\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t\t'<newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.specularMap ?\n\t\t\t\t\t\t\t\t'<newparam sid=\"specular-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t\t`<init_from>${ processTexture( m.specularMap ) }</init_from>` +\n\t\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t\t'<newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.emissiveMap ?\n\t\t\t\t\t\t\t\t'<newparam sid=\"emissive-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t\t`<init_from>${ processTexture( m.emissiveMap ) }</init_from>` +\n\t\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t\t'<newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.normalMap ?\n\t\t\t\t\t\t\t\t'<newparam sid=\"bump-surface\"><surface type=\"2D\">' +\n\t\t\t\t\t\t\t\t`<init_from>${ processTexture( m.normalMap ) }</init_from>` +\n\t\t\t\t\t\t\t\t'</surface></newparam>' +\n\t\t\t\t\t\t\t\t'<newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\ttechniqueNode +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tm.side === THREE.DoubleSide ?\n\t\t\t\t\t\t\t\t`<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>` :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t'</profile_COMMON>' +\n\n\t\t\t\t\t\t'</effect>';\n\n\t\t\t\t\tvar materialName = m.name ? ` name=\"${ m.name }\"` : '';\n\t\t\t\t\tvar materialNode = `<material id=\"${ matid }\"${ materialName }><instance_effect url=\"#${ matid }-effect\" /></material>`;\n\n\t\t\t\t\tlibraryMaterials.push( materialNode );\n\t\t\t\t\tlibraryEffects.push( effectnode );\n\t\t\t\t\tmaterialMap.set( m, matid );\n\n\t\t\t\t}\n\n\t\t\t\treturn matid;\n\n\t\t\t}\n\n\t\t\t// Recursively process the object into a scene\n\t\t\tfunction processObject( o ) {\n\n\t\t\t\tvar node = `<node name=\"${ o.name }\">`;\n\n\t\t\t\tnode += getTransform( o );\n\n\t\t\t\tif ( o instanceof THREE.Mesh && o.geometry != null ) {\n\n\t\t\t\t\t// function returns the id associated with the mesh and a \"BufferGeometry\" version\n\t\t\t\t\t// of the geometry in case it's not a geometry.\n\t\t\t\t\tvar geomInfo = processGeometry( o.geometry );\n\t\t\t\t\tvar meshid = geomInfo.meshid;\n\t\t\t\t\tvar geometry = geomInfo.bufferGeometry;\n\n\t\t\t\t\t// ids of the materials to bind to the geometry\n\t\t\t\t\tvar matids = null;\n\t\t\t\t\tvar matidsArray = [];\n\n\t\t\t\t\t// get a list of materials to bind to the sub groups of the geometry.\n\t\t\t\t\t// If the amount of subgroups is greater than the materials, than reuse\n\t\t\t\t\t// the materials.\n\t\t\t\t\tvar mat = o.material || new THREE.MeshBasicMaterial();\n\t\t\t\t\tvar materials = Array.isArray( mat ) ? mat : [ mat ];\n\n\t\t\t\t\tif ( geometry.groups.length > materials.length ) {\n\n\t\t\t\t\t\tmatidsArray = new Array( geometry.groups.length );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmatidsArray = new Array( materials.length );\n\n\t\t\t\t\t}\n\t\t\t\t\tmatids = matidsArray.fill()\n\t\t\t\t\t\t.map( ( v, i ) => processMaterial( materials[ i % materials.length ] ) );\n\n\t\t\t\t\tnode +=\n\t\t\t\t\t\t`<instance_geometry url=\"#${ meshid }\">` +\n\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tmatids != null ?\n\t\t\t\t\t\t\t\t'<bind_material><technique_common>' +\n\t\t\t\t\t\t\t\tmatids.map( ( id, i ) =>\n\n\t\t\t\t\t\t\t\t\t`<instance_material symbol=\"MESH_MATERIAL_${ i }\" target=\"#${ id }\" >` +\n\n\t\t\t\t\t\t\t\t\t'<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" />' +\n\n\t\t\t\t\t\t\t\t\t'</instance_material>'\n\t\t\t\t\t\t\t\t).join( '' ) +\n\t\t\t\t\t\t\t\t'</technique_common></bind_material>' :\n\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t) +\n\n\t\t\t\t\t\t'</instance_geometry>';\n\n\t\t\t\t}\n\n\t\t\t\to.children.forEach( c => node += processObject( c ) );\n\n\t\t\t\tnode += '</node>';\n\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t\tvar geometryInfo = new WeakMap();\n\t\t\tvar materialMap = new WeakMap();\n\t\t\tvar imageMap = new WeakMap();\n\t\t\tvar textures = [];\n\n\t\t\tvar libraryImages = [];\n\t\t\tvar libraryGeometries = [];\n\t\t\tvar libraryEffects = [];\n\t\t\tvar libraryMaterials = [];\n\t\t\tvar libraryVisualScenes = processObject( object );\n\n\t\t\tvar specLink = version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n\t\t\tvar dae =\n\t\t\t\t'<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>' +\n\t\t\t\t`<COLLADA xmlns=\"${ specLink }\" version=\"${ version }\">` +\n\t\t\t\t'<asset>' +\n\t\t\t\t(\n\t\t\t\t\t'<contributor>' +\n\t\t\t\t\t'<authoring_tool>three.js Collada Exporter</authoring_tool>' +\n\t\t\t\t\t( options.author !== null ? `<author>${ options.author }</author>` : '' ) +\n\t\t\t\t\t'</contributor>' +\n\t\t\t\t\t`<created>${ ( new Date() ).toISOString() }</created>` +\n\t\t\t\t\t`<modified>${ ( new Date() ).toISOString() }</modified>` +\n\t\t\t\t\t'<up_axis>Y_UP</up_axis>'\n\t\t\t\t) +\n\t\t\t\t'</asset>';\n\n\t\t\tdae += `<library_images>${ libraryImages.join( '' ) }</library_images>`;\n\n\t\t\tdae += `<library_effects>${ libraryEffects.join( '' ) }</library_effects>`;\n\n\t\t\tdae += `<library_materials>${ libraryMaterials.join( '' ) }</library_materials>`;\n\n\t\t\tdae += `<library_geometries>${ libraryGeometries.join( '' ) }</library_geometries>`;\n\n\t\t\tdae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${ libraryVisualScenes }</visual_scene></library_visual_scenes>`;\n\n\t\t\tdae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n\n\t\t\tdae += '</COLLADA>';\n\n\t\t\tvar res = {\n\t\t\t\tdata: format( dae ),\n\t\t\t\ttextures\n\t\t\t};\n\n\t\t\tif ( typeof onDone === 'function' ) {\n\n\t\t\t\trequestAnimationFrame( () => onDone( res ) );\n\n\t\t\t}\n\n\t\t\treturn res;\n\n\t\t}\n\n\t};\n\n\treturn THREE.ColladaExporter;\n});\n"]}