{"version":3,"sources":["exporters/ColladaExporter.js"],"names":["define","THREE","threex","ColladaExporter","prototype","constructor","parse","object","onDone","options","Object","assign","version","author","textureDirectory","replace","canvas","ctx","console","warn","imageToData","image","ext","document","createElement","getContext","width","naturalWidth","height","naturalHeight","drawImage","str","b","atob","buf","Uint8Array","length","i","l","charCodeAt","base64ToBuffer","toDataURL","transMat","getFuncs","attrBufferToArray","attr","isInterleavedBufferAttribute","arr","array","count","itemSize","size","j","getAttribute","name","params","type","join","Math","floor","map","n","processTexture","tex","texid","imageMap","get","libraryImages","imageNode","push","set","textures","directory","data","original","geometryInfo","WeakMap","materialMap","libraryGeometries","libraryEffects","libraryMaterials","libraryVisualScenes","processObject","o","node","updateMatrix","Matrix4","copy","matrix","transpose","toArray","getTransform","Mesh","geometry","geomInfo","g","st","ct","info","bufferGeometry","Geometry","BufferGeometry","fromGeometry","meshid","indexCount","index","attributes","position","groups","start","materialIndex","gnode","posName","vertName","triangleInputs","normName","normal","uvName","uv","colName","color","indexArray","Array","group","subarr","isArray","slice","buffer","BYTES_PER_ELEMENT","polycount","processGeometry","matids","mat","material","MeshBasicMaterial","materials","fill","v","m","matid","MeshLambertMaterial","emissive","Color","diffuse","specular","shininess","reflectivity","transparencyNode","transparent","opacity","techniqueNode","emissiveMap","r","normalMap","specularMap","effectnode","side","DoubleSide","materialNode","processMaterial","id","children","forEach","c","dae","Date","toISOString","urdf","IS_END_TAG","IS_SELF_CLOSING","HAS_TEXT","pad","tagnum","res","ch","num","match","tag","test","requestAnimationFrame","exporters"],"mappings":"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","file":"../../exporters/ColladaExporter.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    var ColladaExporter = function () {\n    };\n    ColladaExporter.prototype = {\n        constructor: ColladaExporter,\n        parse: function (object, onDone, options) {\n            options = options || {};\n            options = Object.assign({\n                version: '1.4.1',\n                author: null,\n                textureDirectory: ''\n            }, options);\n            if (options.textureDirectory !== '') {\n                options.textureDirectory = `${ options.textureDirectory }/`.replace(/\\\\/g, '/').replace(/\\/+/g, '/');\n            }\n            var version = options.version;\n            if (version !== '1.4.1' && version !== '1.5.0') {\n                console.warn(`ColladaExporter : Version ${ version } not supported for export. Only 1.4.1 and 1.5.0.`);\n                return null;\n            }\n            function format(urdf) {\n                var IS_END_TAG = /^<\\//;\n                var IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n                var HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n                var pad = (ch, num) => num > 0 ? ch + pad(ch, num - 1) : '';\n                var tagnum = 0;\n                return urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g).map(tag => {\n                    if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n                        tagnum--;\n                    }\n                    var res = `${ pad('  ', tagnum) }${ tag }`;\n                    if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n                        tagnum++;\n                    }\n                    return res;\n                }).join('\\n');\n            }\n            function base64ToBuffer(str) {\n                var b = atob(str);\n                var buf = new Uint8Array(b.length);\n                for (var i = 0, l = buf.length; i < l; i++) {\n                    buf[i] = b.charCodeAt(i);\n                }\n                return buf;\n            }\n            var canvas, ctx;\n            function imageToData(image, ext) {\n                canvas = canvas || document.createElement('canvas');\n                ctx = ctx || canvas.getContext('2d');\n                canvas.width = image.naturalWidth;\n                canvas.height = image.naturalHeight;\n                ctx.drawImage(image, 0, 0);\n                var base64data = canvas.toDataURL(`image/${ ext }`, 1).replace(/^data:image\\/(png|jpg);base64,/, '');\n                return base64ToBuffer(base64data);\n            }\n            var getFuncs = [\n                'getX',\n                'getY',\n                'getZ',\n                'getW'\n            ];\n            function attrBufferToArray(attr) {\n                if (attr.isInterleavedBufferAttribute) {\n                    var arr = new attr.array.constructor(attr.count * attr.itemSize);\n                    var size = attr.itemSize;\n                    for (var i = 0, l = attr.count; i < l; i++) {\n                        for (var j = 0; j < size; j++) {\n                            arr[i * size + j] = attr[getFuncs[j]](i);\n                        }\n                    }\n                    return arr;\n                } else {\n                    return attr.array;\n                }\n            }\n            function subArray(arr, st, ct) {\n                if (Array.isArray(arr))\n                    return arr.slice(st, st + ct);\n                else\n                    return new arr.constructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n            }\n            function getAttribute(attr, name, params, type) {\n                var array = attrBufferToArray(attr);\n                var res = `<source id=\"${ name }\">` + `<float_array id=\"${ name }-array\" count=\"${ array.length }\">` + array.join(' ') + '</float_array>' + '<technique_common>' + `<accessor source=\"#${ name }-array\" count=\"${ Math.floor(array.length / attr.itemSize) }\" stride=\"${ attr.itemSize }\">` + params.map(n => `<param name=\"${ n }\" type=\"${ type }\" />`).join('') + '</accessor>' + '</technique_common>' + '</source>';\n                return res;\n            }\n            var transMat;\n            function getTransform(o) {\n                o.updateMatrix();\n                transMat = transMat || new THREE.Matrix4();\n                transMat.copy(o.matrix);\n                transMat.transpose();\n                return `<matrix>${ transMat.toArray().join(' ') }</matrix>`;\n            }\n            function processGeometry(g) {\n                var info = geometryInfo.get(g);\n                if (!info) {\n                    var bufferGeometry = g;\n                    if (bufferGeometry instanceof THREE.Geometry) {\n                        bufferGeometry = new THREE.BufferGeometry().fromGeometry(bufferGeometry);\n                    }\n                    var meshid = `Mesh${ libraryGeometries.length + 1 }`;\n                    var indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n                    var groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{\n                            start: 0,\n                            count: indexCount,\n                            materialIndex: 0\n                        }];\n                    var gname = g.name ? ` name=\"${ g.name }\"` : '';\n                    var gnode = `<geometry id=\"${ meshid }\"${ gname }><mesh>`;\n                    var posName = `${ meshid }-position`;\n                    var vertName = `${ meshid }-vertices`;\n                    gnode += getAttribute(bufferGeometry.attributes.position, posName, [\n                        'X',\n                        'Y',\n                        'Z'\n                    ], 'float');\n                    gnode += `<vertices id=\"${ vertName }\"><input semantic=\"POSITION\" source=\"#${ posName }\" /></vertices>`;\n                    var triangleInputs = `<input semantic=\"VERTEX\" source=\"#${ vertName }\" offset=\"0\" />`;\n                    if ('normal' in bufferGeometry.attributes) {\n                        var normName = `${ meshid }-normal`;\n                        gnode += getAttribute(bufferGeometry.attributes.normal, normName, [\n                            'X',\n                            'Y',\n                            'Z'\n                        ], 'float');\n                        triangleInputs += `<input semantic=\"NORMAL\" source=\"#${ normName }\" offset=\"0\" />`;\n                    }\n                    if ('uv' in bufferGeometry.attributes) {\n                        var uvName = `${ meshid }-texcoord`;\n                        gnode += getAttribute(bufferGeometry.attributes.uv, uvName, [\n                            'S',\n                            'T'\n                        ], 'float');\n                        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${ uvName }\" offset=\"0\" set=\"0\" />`;\n                    }\n                    if ('color' in bufferGeometry.attributes) {\n                        var colName = `${ meshid }-color`;\n                        gnode += getAttribute(bufferGeometry.attributes.color, colName, [\n                            'X',\n                            'Y',\n                            'Z'\n                        ], 'uint8');\n                        triangleInputs += `<input semantic=\"COLOR\" source=\"#${ colName }\" offset=\"0\" />`;\n                    }\n                    var indexArray = null;\n                    if (bufferGeometry.index) {\n                        indexArray = attrBufferToArray(bufferGeometry.index);\n                    } else {\n                        indexArray = new Array(indexCount);\n                        for (var i = 0, l = indexArray.length; i < l; i++)\n                            indexArray[i] = i;\n                    }\n                    for (var i = 0, l = groups.length; i < l; i++) {\n                        var group = groups[i];\n                        var subarr = subArray(indexArray, group.start, group.count);\n                        var polycount = subarr.length / 3;\n                        gnode += `<triangles material=\"MESH_MATERIAL_${ group.materialIndex }\" count=\"${ polycount }\">`;\n                        gnode += triangleInputs;\n                        gnode += `<p>${ subarr.join(' ') }</p>`;\n                        gnode += '</triangles>';\n                    }\n                    gnode += `</mesh></geometry>`;\n                    libraryGeometries.push(gnode);\n                    info = {\n                        meshid: meshid,\n                        bufferGeometry: bufferGeometry\n                    };\n                    geometryInfo.set(g, info);\n                }\n                return info;\n            }\n            function processTexture(tex) {\n                var texid = imageMap.get(tex);\n                if (texid == null) {\n                    texid = `image-${ libraryImages.length + 1 }`;\n                    var ext = 'png';\n                    var name = tex.name || texid;\n                    var imageNode = `<image id=\"${ texid }\" name=\"${ name }\">`;\n                    if (version === '1.5.0') {\n                        imageNode += `<init_from><ref>${ options.textureDirectory }${ name }.${ ext }</ref></init_from>`;\n                    } else {\n                        imageNode += `<init_from>${ options.textureDirectory }${ name }.${ ext }</init_from>`;\n                    }\n                    imageNode += '</image>';\n                    libraryImages.push(imageNode);\n                    imageMap.set(tex, texid);\n                    textures.push({\n                        directory: options.textureDirectory,\n                        name,\n                        ext,\n                        data: imageToData(tex.image, ext),\n                        original: tex\n                    });\n                }\n                return texid;\n            }\n            function processMaterial(m) {\n                var matid = materialMap.get(m);\n                if (matid == null) {\n                    matid = `Mat${ libraryEffects.length + 1 }`;\n                    var type = 'phong';\n                    if (m instanceof THREE.MeshLambertMaterial) {\n                        type = 'lambert';\n                    } else if (m instanceof THREE.MeshBasicMaterial) {\n                        type = 'constant';\n                        if (m.map !== null) {\n                            console.warn('ColladaExporter: Texture maps not supported with MeshBasicMaterial.');\n                        }\n                    }\n                    var emissive = m.emissive ? m.emissive : new THREE.Color(0, 0, 0);\n                    var diffuse = m.color ? m.color : new THREE.Color(0, 0, 0);\n                    var specular = m.specular ? m.specular : new THREE.Color(1, 1, 1);\n                    var shininess = m.shininess || 0;\n                    var reflectivity = m.reflectivity || 0;\n                    var transparencyNode = '';\n                    if (m.transparent === true) {\n                        transparencyNode += `<transparent>` + (m.map ? `<texture texture=\"diffuse-sampler\"></texture>` : '<float>1</float>') + '</transparent>';\n                        if (m.opacity < 1) {\n                            transparencyNode += `<transparency><float>${ m.opacity }</float></transparency>`;\n                        }\n                    }\n                    var techniqueNode = `<technique sid=\"common\"><${ type }>` + '<emission>' + (m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"emission\">${ emissive.r } ${ emissive.g } ${ emissive.b } 1</color>`) + '</emission>' + (type !== 'constant' ? '<diffuse>' + (m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : `<color sid=\"diffuse\">${ diffuse.r } ${ diffuse.g } ${ diffuse.b } 1</color>`) + '</diffuse>' : '') + (type !== 'constant' ? '<bump>' + (m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : '') + '</bump>' : '') + (type === 'phong' ? `<specular><color sid=\"specular\">${ specular.r } ${ specular.g } ${ specular.b } 1</color></specular>` + '<shininess>' + (m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : `<float sid=\"shininess\">${ shininess }</float>`) + '</shininess>' : '') + `<reflective><color>${ diffuse.r } ${ diffuse.g } ${ diffuse.b } 1</color></reflective>` + `<reflectivity><float>${ reflectivity }</float></reflectivity>` + transparencyNode + `</${ type }></technique>`;\n                    var effectnode = `<effect id=\"${ matid }-effect\">` + '<profile_COMMON>' + (m.map ? '<newparam sid=\"diffuse-surface\"><surface type=\"2D\">' + `<init_from>${ processTexture(m.map) }</init_from>` + '</surface></newparam>' + '<newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>' : '') + (m.specularMap ? '<newparam sid=\"specular-surface\"><surface type=\"2D\">' + `<init_from>${ processTexture(m.specularMap) }</init_from>` + '</surface></newparam>' + '<newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>' : '') + (m.emissiveMap ? '<newparam sid=\"emissive-surface\"><surface type=\"2D\">' + `<init_from>${ processTexture(m.emissiveMap) }</init_from>` + '</surface></newparam>' + '<newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>' : '') + (m.normalMap ? '<newparam sid=\"bump-surface\"><surface type=\"2D\">' + `<init_from>${ processTexture(m.normalMap) }</init_from>` + '</surface></newparam>' + '<newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>' : '') + techniqueNode + (m.side === THREE.DoubleSide ? `<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>` : '') + '</profile_COMMON>' + '</effect>';\n                    var materialName = m.name ? ` name=\"${ m.name }\"` : '';\n                    var materialNode = `<material id=\"${ matid }\"${ materialName }><instance_effect url=\"#${ matid }-effect\" /></material>`;\n                    libraryMaterials.push(materialNode);\n                    libraryEffects.push(effectnode);\n                    materialMap.set(m, matid);\n                }\n                return matid;\n            }\n            function processObject(o) {\n                var node = `<node name=\"${ o.name }\">`;\n                node += getTransform(o);\n                if (o instanceof THREE.Mesh && o.geometry != null) {\n                    var geomInfo = processGeometry(o.geometry);\n                    var meshid = geomInfo.meshid;\n                    var geometry = geomInfo.bufferGeometry;\n                    var matids = null;\n                    var matidsArray = [];\n                    var mat = o.material || new THREE.MeshBasicMaterial();\n                    var materials = Array.isArray(mat) ? mat : [mat];\n                    if (geometry.groups.length > materials.length) {\n                        matidsArray = new Array(geometry.groups.length);\n                    } else {\n                        matidsArray = new Array(materials.length);\n                    }\n                    matids = matidsArray.fill().map((v, i) => processMaterial(materials[i % materials.length]));\n                    node += `<instance_geometry url=\"#${ meshid }\">` + (matids != null ? '<bind_material><technique_common>' + matids.map((id, i) => `<instance_material symbol=\"MESH_MATERIAL_${ i }\" target=\"#${ id }\" >` + '<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" />' + '</instance_material>').join('') + '</technique_common></bind_material>' : '') + '</instance_geometry>';\n                }\n                o.children.forEach(c => node += processObject(c));\n                node += '</node>';\n                return node;\n            }\n            var geometryInfo = new WeakMap();\n            var materialMap = new WeakMap();\n            var imageMap = new WeakMap();\n            var textures = [];\n            var libraryImages = [];\n            var libraryGeometries = [];\n            var libraryEffects = [];\n            var libraryMaterials = [];\n            var libraryVisualScenes = processObject(object);\n            var specLink = version === '1.4.1' ? 'http://www.collada.org/2005/11/COLLADASchema' : 'https://www.khronos.org/collada/';\n            var dae = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>' + `<COLLADA xmlns=\"${ specLink }\" version=\"${ version }\">` + '<asset>' + ('<contributor>' + '<authoring_tool>three.js Collada Exporter</authoring_tool>' + (options.author !== null ? `<author>${ options.author }</author>` : '') + '</contributor>' + `<created>${ new Date().toISOString() }</created>` + `<modified>${ new Date().toISOString() }</modified>` + '<up_axis>Y_UP</up_axis>') + '</asset>';\n            dae += `<library_images>${ libraryImages.join('') }</library_images>`;\n            dae += `<library_effects>${ libraryEffects.join('') }</library_effects>`;\n            dae += `<library_materials>${ libraryMaterials.join('') }</library_materials>`;\n            dae += `<library_geometries>${ libraryGeometries.join('') }</library_geometries>`;\n            dae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${ libraryVisualScenes }</visual_scene></library_visual_scenes>`;\n            dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n            dae += '</COLLADA>';\n            var res = {\n                data: format(dae),\n                textures\n            };\n            if (typeof onDone === 'function') {\n                requestAnimationFrame(() => onDone(res));\n            }\n            return res;\n        }\n    };\n\n    return threex.exporters.ColladaExporter = ColladaExporter;\n});"]}