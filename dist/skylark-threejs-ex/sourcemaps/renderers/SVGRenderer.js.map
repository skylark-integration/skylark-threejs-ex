{"version":3,"sources":["renderers/SVGRenderer.js"],"names":["define","THREE","Projector","SVGObject","node","Object3D","call","this","prototype","Object","create","constructor","SVGRenderer","_renderData","_elements","_lights","_svgWidth","_svgHeight","_svgWidthHalf","_svgHeightHalf","_v1","_v2","_v3","_svgNode","_currentPath","_currentStyle","_this","_projector","_svg","document","createElementNS","_clipBox","Box2","_elemBox","_color","Color","_diffuseColor","_ambientLight","_directionalLights","_pointLights","_clearColor","_vector3","Vector3","_centroid","_normal","_normalViewMatrix","Matrix3","_viewMatrix","Matrix4","_viewProjectionMatrix","_svgPathPool","_pathCount","_quality","_precision","removeChildNodes","childNodes","length","removeChild","convert","c","toFixed","renderSprite","v1","element","material","scaleX","scale","x","scaleY","y","isPointsMaterial","size","path","style","isSpriteMaterial","color","getStyle","opacity","addPath","renderLine","v2","positionScreen","isLineBasicMaterial","linewidth","linecap","isLineDashedMaterial","dashSize","gapSize","renderFace3","v3","info","render","vertices","faces","isMeshBasicMaterial","copy","vertexColors","multiply","isMeshLambertMaterial","isMeshPhongMaterial","isMeshStandardMaterial","positionWorld","add","divideScalar","lights","position","normal","l","ll","light","lightColor","isDirectionalLight","lightPosition","setFromMatrixPosition","matrixWorld","normalize","amount","dot","intensity","r","g","b","isPointLight","subVectors","distance","Math","min","distanceTo","calculateLight","normalModel","emissive","isMeshNormalMaterial","applyMatrix3","setRGB","z","multiplyScalar","addScalar","wireframe","wireframeLinewidth","wireframeLinecap","wireframeLinejoin","expand","pixels","idet","det","sqrt","flushPath","id","setAttribute","getPathNode","appendChild","domElement","autoClear","sortObjects","sortElements","overdraw","setQuality","quality","setClearColor","set","setPixelRatio","setSize","width","height","max","setPrecision","precision","clear","backgroundColor","scene","camera","Camera","background","isColor","matrixWorldInverse","multiplyMatrices","projectionMatrix","projectScene","elements","getNormalMatrix","isAmbientLight","calculateLights","e","el","undefined","makeEmpty","RenderableSprite","RenderableLine","setFromPoints","intersectsBox","RenderableFace","traverseVisible","object","applyMatrix4","console","error"],"mappings":"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","file":"../../renderers/SVGRenderer.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    '../renderers/Projector'\n], function (\n    THREE, \n    Projector\n) {\n    'use strict';\n    var SVGObject = function (node) {\n        THREE.Object3D.call(this);\n        this.node = node;\n    };\n    SVGObject.prototype = Object.create(THREE.Object3D.prototype);\n    SVGObject.prototype.constructor = SVGObject;\n    var SVGRenderer = function () {\n        var _this = this, _renderData, _elements, _lights, _projector = new Projector(), _svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'), _svgWidth, _svgHeight, _svgWidthHalf, _svgHeightHalf, _v1, _v2, _v3, _clipBox = new THREE.Box2(), _elemBox = new THREE.Box2(), _color = new THREE.Color(), _diffuseColor = new THREE.Color(), _ambientLight = new THREE.Color(), _directionalLights = new THREE.Color(), _pointLights = new THREE.Color(), _clearColor = new THREE.Color(), _vector3 = new THREE.Vector3(), _centroid = new THREE.Vector3(), _normal = new THREE.Vector3(), _normalViewMatrix = new THREE.Matrix3(), _viewMatrix = new THREE.Matrix4(), _viewProjectionMatrix = new THREE.Matrix4(), _svgPathPool = [], _svgNode, _pathCount = 0, _currentPath, _currentStyle, _quality = 1, _precision = null;\n        this.domElement = _svg;\n        this.autoClear = true;\n        this.sortObjects = true;\n        this.sortElements = true;\n        this.overdraw = 0.5;\n        this.info = {\n            render: {\n                vertices: 0,\n                faces: 0\n            }\n        };\n        this.setQuality = function (quality) {\n            switch (quality) {\n            case 'high':\n                _quality = 1;\n                break;\n            case 'low':\n                _quality = 0;\n                break;\n            }\n        };\n        this.setClearColor = function (color) {\n            _clearColor.set(color);\n        };\n        this.setPixelRatio = function () {\n        };\n        this.setSize = function (width, height) {\n            _svgWidth = width;\n            _svgHeight = height;\n            _svgWidthHalf = _svgWidth / 2;\n            _svgHeightHalf = _svgHeight / 2;\n            _svg.setAttribute('viewBox', -_svgWidthHalf + ' ' + -_svgHeightHalf + ' ' + _svgWidth + ' ' + _svgHeight);\n            _svg.setAttribute('width', _svgWidth);\n            _svg.setAttribute('height', _svgHeight);\n            _clipBox.min.set(-_svgWidthHalf, -_svgHeightHalf);\n            _clipBox.max.set(_svgWidthHalf, _svgHeightHalf);\n        };\n        this.setPrecision = function (precision) {\n            _precision = precision;\n        };\n        function removeChildNodes() {\n            _pathCount = 0;\n            while (_svg.childNodes.length > 0) {\n                _svg.removeChild(_svg.childNodes[0]);\n            }\n        }\n        function convert(c) {\n            return _precision !== null ? c.toFixed(_precision) : c;\n        }\n        this.clear = function () {\n            removeChildNodes();\n            _svg.style.backgroundColor = _clearColor.getStyle();\n        };\n        this.render = function (scene, camera) {\n            if (camera instanceof THREE.Camera === false) {\n                console.error('THREE.SVGRenderer.render: camera is not an instance of Camera.');\n                return;\n            }\n            var background = scene.background;\n            if (background && background.isColor) {\n                removeChildNodes();\n                _svg.style.backgroundColor = background.getStyle();\n            } else if (this.autoClear === true) {\n                this.clear();\n            }\n            _this.info.render.vertices = 0;\n            _this.info.render.faces = 0;\n            _viewMatrix.copy(camera.matrixWorldInverse);\n            _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);\n            _renderData = _projector.projectScene(scene, camera, this.sortObjects, this.sortElements);\n            _elements = _renderData.elements;\n            _lights = _renderData.lights;\n            _normalViewMatrix.getNormalMatrix(camera.matrixWorldInverse);\n            calculateLights(_lights);\n            _currentPath = '';\n            _currentStyle = '';\n            for (var e = 0, el = _elements.length; e < el; e++) {\n                var element = _elements[e];\n                var material = element.material;\n                if (material === undefined || material.opacity === 0)\n                    continue;\n                _elemBox.makeEmpty();\n                if (element instanceof Projector.RenderableSprite) {\n                    _v1 = element;\n                    _v1.x *= _svgWidthHalf;\n                    _v1.y *= -_svgHeightHalf;\n                    renderSprite(_v1, element, material);\n                } else if (element instanceof Projector.RenderableLine) {\n                    _v1 = element.v1;\n                    _v2 = element.v2;\n                    _v1.positionScreen.x *= _svgWidthHalf;\n                    _v1.positionScreen.y *= -_svgHeightHalf;\n                    _v2.positionScreen.x *= _svgWidthHalf;\n                    _v2.positionScreen.y *= -_svgHeightHalf;\n                    _elemBox.setFromPoints([\n                        _v1.positionScreen,\n                        _v2.positionScreen\n                    ]);\n                    if (_clipBox.intersectsBox(_elemBox) === true) {\n                        renderLine(_v1, _v2, element, material);\n                    }\n                } else if (element instanceof Projector.RenderableFace) {\n                    _v1 = element.v1;\n                    _v2 = element.v2;\n                    _v3 = element.v3;\n                    if (_v1.positionScreen.z < -1 || _v1.positionScreen.z > 1)\n                        continue;\n                    if (_v2.positionScreen.z < -1 || _v2.positionScreen.z > 1)\n                        continue;\n                    if (_v3.positionScreen.z < -1 || _v3.positionScreen.z > 1)\n                        continue;\n                    _v1.positionScreen.x *= _svgWidthHalf;\n                    _v1.positionScreen.y *= -_svgHeightHalf;\n                    _v2.positionScreen.x *= _svgWidthHalf;\n                    _v2.positionScreen.y *= -_svgHeightHalf;\n                    _v3.positionScreen.x *= _svgWidthHalf;\n                    _v3.positionScreen.y *= -_svgHeightHalf;\n                    if (this.overdraw > 0) {\n                        expand(_v1.positionScreen, _v2.positionScreen, this.overdraw);\n                        expand(_v2.positionScreen, _v3.positionScreen, this.overdraw);\n                        expand(_v3.positionScreen, _v1.positionScreen, this.overdraw);\n                    }\n                    _elemBox.setFromPoints([\n                        _v1.positionScreen,\n                        _v2.positionScreen,\n                        _v3.positionScreen\n                    ]);\n                    if (_clipBox.intersectsBox(_elemBox) === true) {\n                        renderFace3(_v1, _v2, _v3, element, material);\n                    }\n                }\n            }\n            flushPath();\n            scene.traverseVisible(function (object) {\n                if (object instanceof SVGObject) {\n                    _vector3.setFromMatrixPosition(object.matrixWorld);\n                    _vector3.applyMatrix4(_viewProjectionMatrix);\n                    if (_vector3.z < -1 || _vector3.z > 1)\n                        return;\n                    var x = _vector3.x * _svgWidthHalf;\n                    var y = -_vector3.y * _svgHeightHalf;\n                    var node = object.node;\n                    node.setAttribute('transform', 'translate(' + x + ',' + y + ')');\n                    _svg.appendChild(node);\n                }\n            });\n        };\n        function calculateLights(lights) {\n            _ambientLight.setRGB(0, 0, 0);\n            _directionalLights.setRGB(0, 0, 0);\n            _pointLights.setRGB(0, 0, 0);\n            for (var l = 0, ll = lights.length; l < ll; l++) {\n                var light = lights[l];\n                var lightColor = light.color;\n                if (light.isAmbientLight) {\n                    _ambientLight.r += lightColor.r;\n                    _ambientLight.g += lightColor.g;\n                    _ambientLight.b += lightColor.b;\n                } else if (light.isDirectionalLight) {\n                    _directionalLights.r += lightColor.r;\n                    _directionalLights.g += lightColor.g;\n                    _directionalLights.b += lightColor.b;\n                } else if (light.isPointLight) {\n                    _pointLights.r += lightColor.r;\n                    _pointLights.g += lightColor.g;\n                    _pointLights.b += lightColor.b;\n                }\n            }\n        }\n        function calculateLight(lights, position, normal, color) {\n            for (var l = 0, ll = lights.length; l < ll; l++) {\n                var light = lights[l];\n                var lightColor = light.color;\n                if (light.isDirectionalLight) {\n                    var lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld).normalize();\n                    var amount = normal.dot(lightPosition);\n                    if (amount <= 0)\n                        continue;\n                    amount *= light.intensity;\n                    color.r += lightColor.r * amount;\n                    color.g += lightColor.g * amount;\n                    color.b += lightColor.b * amount;\n                } else if (light.isPointLight) {\n                    var lightPosition = _vector3.setFromMatrixPosition(light.matrixWorld);\n                    var amount = normal.dot(_vector3.subVectors(lightPosition, position).normalize());\n                    if (amount <= 0)\n                        continue;\n                    amount *= light.distance == 0 ? 1 : 1 - Math.min(position.distanceTo(lightPosition) / light.distance, 1);\n                    if (amount == 0)\n                        continue;\n                    amount *= light.intensity;\n                    color.r += lightColor.r * amount;\n                    color.g += lightColor.g * amount;\n                    color.b += lightColor.b * amount;\n                }\n            }\n        }\n        function renderSprite(v1, element, material) {\n            var scaleX = element.scale.x * _svgWidthHalf;\n            var scaleY = element.scale.y * _svgHeightHalf;\n            if (material.isPointsMaterial) {\n                scaleX *= material.size;\n                scaleY *= material.size;\n            }\n            var path = 'M' + convert(v1.x - scaleX * 0.5) + ',' + convert(v1.y - scaleY * 0.5) + 'h' + convert(scaleX) + 'v' + convert(scaleY) + 'h' + convert(-scaleX) + 'z';\n            var style = '';\n            if (material.isSpriteMaterial || material.isPointsMaterial) {\n                style = 'fill:' + material.color.getStyle() + ';fill-opacity:' + material.opacity;\n            }\n            addPath(style, path);\n        }\n        function renderLine(v1, v2, element, material) {\n            var path = 'M' + convert(v1.positionScreen.x) + ',' + convert(v1.positionScreen.y) + 'L' + convert(v2.positionScreen.x) + ',' + convert(v2.positionScreen.y);\n            if (material.isLineBasicMaterial) {\n                var style = 'fill:none;stroke:' + material.color.getStyle() + ';stroke-opacity:' + material.opacity + ';stroke-width:' + material.linewidth + ';stroke-linecap:' + material.linecap;\n                if (material.isLineDashedMaterial) {\n                    style = style + ';stroke-dasharray:' + material.dashSize + ',' + material.gapSize;\n                }\n                addPath(style, path);\n            }\n        }\n        function renderFace3(v1, v2, v3, element, material) {\n            _this.info.render.vertices += 3;\n            _this.info.render.faces++;\n            var path = 'M' + convert(v1.positionScreen.x) + ',' + convert(v1.positionScreen.y) + 'L' + convert(v2.positionScreen.x) + ',' + convert(v2.positionScreen.y) + 'L' + convert(v3.positionScreen.x) + ',' + convert(v3.positionScreen.y) + 'z';\n            var style = '';\n            if (material.isMeshBasicMaterial) {\n                _color.copy(material.color);\n                if (material.vertexColors) {\n                    _color.multiply(element.color);\n                }\n            } else if (material.isMeshLambertMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial) {\n                _diffuseColor.copy(material.color);\n                if (material.vertexColors) {\n                    _diffuseColor.multiply(element.color);\n                }\n                _color.copy(_ambientLight);\n                _centroid.copy(v1.positionWorld).add(v2.positionWorld).add(v3.positionWorld).divideScalar(3);\n                calculateLight(_lights, _centroid, element.normalModel, _color);\n                _color.multiply(_diffuseColor).add(material.emissive);\n            } else if (material.isMeshNormalMaterial) {\n                _normal.copy(element.normalModel).applyMatrix3(_normalViewMatrix).normalize();\n                _color.setRGB(_normal.x, _normal.y, _normal.z).multiplyScalar(0.5).addScalar(0.5);\n            }\n            if (material.wireframe) {\n                style = 'fill:none;stroke:' + _color.getStyle() + ';stroke-opacity:' + material.opacity + ';stroke-width:' + material.wireframeLinewidth + ';stroke-linecap:' + material.wireframeLinecap + ';stroke-linejoin:' + material.wireframeLinejoin;\n            } else {\n                style = 'fill:' + _color.getStyle() + ';fill-opacity:' + material.opacity;\n            }\n            addPath(style, path);\n        }\n        function expand(v1, v2, pixels) {\n            var x = v2.x - v1.x, y = v2.y - v1.y, det = x * x + y * y, idet;\n            if (det === 0)\n                return;\n            idet = pixels / Math.sqrt(det);\n            x *= idet;\n            y *= idet;\n            v2.x += x;\n            v2.y += y;\n            v1.x -= x;\n            v1.y -= y;\n        }\n        function addPath(style, path) {\n            if (_currentStyle === style) {\n                _currentPath += path;\n            } else {\n                flushPath();\n                _currentStyle = style;\n                _currentPath = path;\n            }\n        }\n        function flushPath() {\n            if (_currentPath) {\n                _svgNode = getPathNode(_pathCount++);\n                _svgNode.setAttribute('d', _currentPath);\n                _svgNode.setAttribute('style', _currentStyle);\n                _svg.appendChild(_svgNode);\n            }\n            _currentPath = '';\n            _currentStyle = '';\n        }\n        function getPathNode(id) {\n            if (_svgPathPool[id] == null) {\n                _svgPathPool[id] = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n                if (_quality == 0) {\n                    _svgPathPool[id].setAttribute('shape-rendering', 'crispEdges');\n                }\n                return _svgPathPool[id];\n            }\n            return _svgPathPool[id];\n        }\n    };\n\n    SVGRenderer.SVGObject = SVGObject;\n    \n    return  SVGRenderer;\n});"]}