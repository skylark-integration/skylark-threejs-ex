{"version":3,"sources":["lines/LineSegments2.js"],"names":["define","THREE","LineSegmentsGeometry","LineMaterial","start","end","LineSegments2","geometry","material","Mesh","call","this","type","undefined","color","Math","random","prototype","Object","assign","create","constructor","isLineSegments2","computeLineDistances","Vector3","instanceStart","attributes","instanceEnd","lineDistances","Float32Array","data","count","i","j","l","fromBufferAttribute","distanceTo","instanceDistanceBuffer","InstancedInterleavedBuffer","setAttribute","InterleavedBufferAttribute","raycast","Vector4","ssOrigin","ssOrigin3","mvMatrix","Matrix4","line","Line3","closestPoint","raycaster","intersects","camera","console","error","ray","projectionMatrix","resolution","lineWidth","linewidth","at","w","applyMatrix4","matrixWorldInverse","multiplyScalar","x","y","z","copy","matrixWorld","multiplyMatrices","isBehindCameraNear","isPastCameraFar","param","closestPointToPointParameter","zPos","MathUtils","lerp","isInClipSpace","isInside","pointOnLine","point","distanceSqToSegment","push","distance","origin","object","face","faceIndex","uv","uv2"],"mappings":"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","file":"../../lines/LineSegments2.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"./LineSegmentsGeometry\",\n\t\"./LineMaterial\"\n],function(THREE,LineSegmentsGeometry,LineMaterial){\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t */\n\n\tTHREE.LineSegments2 = function ( geometry, material ) {\n\n\t\tTHREE.Mesh.call( this );\n\n\t\tthis.type = 'LineSegments2';\n\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.LineSegmentsGeometry();\n\t\tthis.material = material !== undefined ? material : new THREE.LineMaterial( { color: Math.random() * 0xffffff } );\n\n\t};\n\n\tTHREE.LineSegments2.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {\n\n\t\tconstructor: THREE.LineSegments2,\n\n\t\tisLineSegments2: true,\n\n\t\tcomputeLineDistances: ( function () { // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n\t\t\tvar start = new THREE.Vector3();\n\t\t\tvar end = new THREE.Vector3();\n\n\t\t\treturn function computeLineDistances() {\n\n\t\t\t\tvar geometry = this.geometry;\n\n\t\t\t\tvar instanceStart = geometry.attributes.instanceStart;\n\t\t\t\tvar instanceEnd = geometry.attributes.instanceEnd;\n\t\t\t\tvar lineDistances = new Float32Array( 2 * instanceStart.data.count );\n\n\t\t\t\tfor ( var i = 0, j = 0, l = instanceStart.data.count; i < l; i ++, j += 2 ) {\n\n\t\t\t\t\tstart.fromBufferAttribute( instanceStart, i );\n\t\t\t\t\tend.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + start.distanceTo( end );\n\n\t\t\t\t}\n\n\t\t\t\tvar instanceDistanceBuffer = new THREE.InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\t\t\tgeometry.setAttribute( 'instanceDistanceStart', new THREE.InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\t\t\tgeometry.setAttribute( 'instanceDistanceEnd', new THREE.InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}() ),\n\n\t\traycast: ( function () {\n\n\t\t\tvar start = new THREE.Vector4();\n\t\t\tvar end = new THREE.Vector4();\n\n\t\t\tvar ssOrigin = new THREE.Vector4();\n\t\t\tvar ssOrigin3 = new THREE.Vector3();\n\t\t\tvar mvMatrix = new THREE.Matrix4();\n\t\t\tvar line = new THREE.Line3();\n\t\t\tvar closestPoint = new THREE.Vector3();\n\n\t\t\treturn function raycast( raycaster, intersects ) {\n\n\t\t\t\tif ( raycaster.camera === null ) {\n\n\t\t\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.' );\n\n\t\t\t\t}\n\n\t\t\t\tvar ray = raycaster.ray;\n\t\t\t\tvar camera = raycaster.camera;\n\t\t\t\tvar projectionMatrix = camera.projectionMatrix;\n\n\t\t\t\tvar geometry = this.geometry;\n\t\t\t\tvar material = this.material;\n\t\t\t\tvar resolution = material.resolution;\n\t\t\t\tvar lineWidth = material.linewidth;\n\n\t\t\t\tvar instanceStart = geometry.attributes.instanceStart;\n\t\t\t\tvar instanceEnd = geometry.attributes.instanceEnd;\n\n\t\t\t\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t\t\t\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t\t\t\t// applying the projection matrix.\n\t\t\t\tray.at( 1, ssOrigin );\n\n\t\t\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t\t\tssOrigin.w = 1;\n\t\t\t\tssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t\t\t\tssOrigin.applyMatrix4( projectionMatrix );\n\t\t\t\tssOrigin.multiplyScalar( 1 / ssOrigin.w );\n\n\t\t\t\t// screen space\n\t\t\t\tssOrigin.x *= resolution.x / 2;\n\t\t\t\tssOrigin.y *= resolution.y / 2;\n\t\t\t\tssOrigin.z = 0;\n\n\t\t\t\tssOrigin3.copy( ssOrigin );\n\n\t\t\t\tvar matrixWorld = this.matrixWorld;\n\t\t\t\tmvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\t\t\t\tfor ( var i = 0, l = instanceStart.count; i < l; i ++ ) {\n\n\t\t\t\t\tstart.fromBufferAttribute( instanceStart, i );\n\t\t\t\t\tend.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t\t\tstart.w = 1;\n\t\t\t\t\tend.w = 1;\n\n\t\t\t\t\t// camera space\n\t\t\t\t\tstart.applyMatrix4( mvMatrix );\n\t\t\t\t\tend.applyMatrix4( mvMatrix );\n\n\t\t\t\t\t// clip space\n\t\t\t\t\tstart.applyMatrix4( projectionMatrix );\n\t\t\t\t\tend.applyMatrix4( projectionMatrix );\n\n\t\t\t\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t\t\t\tstart.multiplyScalar( 1 / start.w );\n\t\t\t\t\tend.multiplyScalar( 1 / end.w );\n\n\t\t\t\t\t// skip the segment if it's outside the camera near and far planes\n\t\t\t\t\tvar isBehindCameraNear = start.z < - 1 && end.z < - 1;\n\t\t\t\t\tvar isPastCameraFar = start.z > 1 && end.z > 1;\n\t\t\t\t\tif ( isBehindCameraNear || isPastCameraFar ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// screen space\n\t\t\t\t\tstart.x *= resolution.x / 2;\n\t\t\t\t\tstart.y *= resolution.y / 2;\n\n\t\t\t\t\tend.x *= resolution.x / 2;\n\t\t\t\t\tend.y *= resolution.y / 2;\n\n\t\t\t\t\t// create 2d segment\n\t\t\t\t\tline.start.copy( start );\n\t\t\t\t\tline.start.z = 0;\n\n\t\t\t\t\tline.end.copy( end );\n\t\t\t\t\tline.end.z = 0;\n\n\t\t\t\t\t// get closest point on ray to segment\n\t\t\t\t\tvar param = line.closestPointToPointParameter( ssOrigin3, true );\n\t\t\t\t\tline.at( param, closestPoint );\n\n\t\t\t\t\t// check if the intersection point is within clip space\n\t\t\t\t\tvar zPos = THREE.MathUtils.lerp( start.z, end.z, param );\n\t\t\t\t\tvar isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\t\t\t\tvar isInside = ssOrigin3.distanceTo( closestPoint ) < lineWidth * 0.5;\n\n\t\t\t\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t\t\t\tline.start.fromBufferAttribute( instanceStart, i );\n\t\t\t\t\t\tline.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t\t\t\tline.start.applyMatrix4( matrixWorld );\n\t\t\t\t\t\tline.end.applyMatrix4( matrixWorld );\n\n\t\t\t\t\t\tvar pointOnLine = new THREE.Vector3();\n\t\t\t\t\t\tvar point = new THREE.Vector3();\n\n\t\t\t\t\t\tray.distanceSqToSegment( line.start, line.end, point, pointOnLine );\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tpoint: point,\n\t\t\t\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\t\t\t\tdistance: ray.origin.distanceTo( point ),\n\n\t\t\t\t\t\t\tobject: this,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: i,\n\t\t\t\t\t\t\tuv: null,\n\t\t\t\t\t\t\tuv2: null,\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}() )\n\n\t} );\n\t\n\treturn THREE.LineSegments2;\n});\n"]}