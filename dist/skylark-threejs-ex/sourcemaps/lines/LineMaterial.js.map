{"version":3,"sources":["lines/LineMaterial.js"],"names":["define","THREE","threex","UniformsLib","line","linewidth","value","resolution","Vector2","dashScale","dashSize","gapSize","ShaderLib","uniforms","UniformsUtils","merge","common","fog","vertexShader","fragmentShader","LineMaterial","parameters","ShaderMaterial","call","this","type","clone","clipping","dashed","Object","defineProperties","color","enumerable","get","diffuse","set","copy","setValues","prototype","create","constructor","isLineMaterial","lines"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACAD,EAAME,YAAYC,MACdC,WAAaC,MAAO,GACpBC,YAAcD,MAAO,IAAIL,EAAMO,QAAQ,EAAG,IAC1CC,WAAaH,MAAO,GACpBI,UAAYJ,MAAO,GACnBK,SAAWL,MAAO,IAEtBL,EAAMW,UAAgB,MAClBC,SAAUZ,EAAMa,cAAcC,OAC1Bd,EAAME,YAAYa,OAClBf,EAAME,YAAYc,IAClBhB,EAAME,YAAYC,OAEtBc,aAAc,qvHAiJdC,eAAgB,2uCA0DpB,IAAIC,EAAe,SAAUC,GACzBpB,EAAMqB,eAAeC,KAAKC,MACtBC,KAAM,eACNZ,SAAUZ,EAAMa,cAAcY,MAAMzB,EAAMW,UAAgB,KAAEC,UAC5DK,aAAcjB,EAAMW,UAAgB,KAAEM,aACtCC,eAAgBlB,EAAMW,UAAgB,KAAEO,eACxCQ,UAAU,IAEdH,KAAKI,QAAS,EACdC,OAAOC,iBAAiBN,MACpBO,OACIC,YAAY,EACZC,IAAK,WACD,OAAOT,KAAKX,SAASqB,QAAQ5B,OAEjC6B,IAAK,SAAU7B,GACXkB,KAAKX,SAASqB,QAAQ5B,MAAQA,IAGtCD,WACI2B,YAAY,EACZC,IAAK,WACD,OAAOT,KAAKX,SAASR,UAAUC,OAEnC6B,IAAK,SAAU7B,GACXkB,KAAKX,SAASR,UAAUC,MAAQA,IAGxCG,WACIuB,YAAY,EACZC,IAAK,WACD,OAAOT,KAAKX,SAASJ,UAAUH,OAEnC6B,IAAK,SAAU7B,GACXkB,KAAKX,SAASJ,UAAUH,MAAQA,IAGxCI,UACIsB,YAAY,EACZC,IAAK,WACD,OAAOT,KAAKX,SAASH,SAASJ,OAElC6B,IAAK,SAAU7B,GACXkB,KAAKX,SAASH,SAASJ,MAAQA,IAGvCK,SACIqB,YAAY,EACZC,IAAK,WACD,OAAOT,KAAKX,SAASF,QAAQL,OAEjC6B,IAAK,SAAU7B,GACXkB,KAAKX,SAASF,QAAQL,MAAQA,IAGtCC,YACIyB,YAAY,EACZC,IAAK,WACD,OAAOT,KAAKX,SAASN,WAAWD,OAEpC6B,IAAK,SAAU7B,GACXkB,KAAKX,SAASN,WAAWD,MAAM8B,KAAK9B,OAIhDkB,KAAKa,UAAUhB,IAMnB,OAJAD,EAAakB,UAAYT,OAAOU,OAAOtC,EAAMqB,eAAegB,YACrCE,YAAcpB,EACrCA,EAAakB,UAAUG,gBAAiB,EAEjCvC,EAAOwC,MAAMtB,aAAeA","file":"../../lines/LineMaterial.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    THREE.UniformsLib.line = {\r\n        linewidth: { value: 1 },\r\n        resolution: { value: new THREE.Vector2(1, 1) },\r\n        dashScale: { value: 1 },\r\n        dashSize: { value: 1 },\r\n        gapSize: { value: 1 }\r\n    };\r\n    THREE.ShaderLib['line'] = {\r\n        uniforms: THREE.UniformsUtils.merge([\r\n            THREE.UniformsLib.common,\r\n            THREE.UniformsLib.fog,\r\n            THREE.UniformsLib.line\r\n        ]),\r\n        vertexShader: `\r\n\t\t#include <common>\r\n\t\t#include <color_pars_vertex>\r\n\t\t#include <fog_pars_vertex>\r\n\t\t#include <logdepthbuf_pars_vertex>\r\n\t\t#include <clipping_planes_pars_vertex>\r\n\r\n\t\tuniform float linewidth;\r\n\t\tuniform vec2 resolution;\r\n\r\n\t\tattribute vec3 instanceStart;\r\n\t\tattribute vec3 instanceEnd;\r\n\r\n\t\tattribute vec3 instanceColorStart;\r\n\t\tattribute vec3 instanceColorEnd;\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\t#ifdef USE_DASH\r\n\r\n\t\t\tuniform float dashScale;\r\n\t\t\tattribute float instanceDistanceStart;\r\n\t\t\tattribute float instanceDistanceEnd;\r\n\t\t\tvarying float vLineDistance;\r\n\r\n\t\t#endif\r\n\r\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\r\n\r\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\r\n\r\n\t\t\t// conservative estimate of the near plane\r\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\r\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\r\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\r\n\r\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\r\n\r\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#ifdef USE_COLOR\r\n\r\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t#ifdef USE_DASH\r\n\r\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tfloat aspect = resolution.x / resolution.y;\r\n\r\n\t\t\tvUv = uv;\r\n\r\n\t\t\t// camera space\r\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\r\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\r\n\r\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\r\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\r\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\r\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\r\n\r\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\r\n\r\n\t\t\tif ( perspective ) {\r\n\r\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\r\n\r\n\t\t\t\t\ttrimSegment( start, end );\r\n\r\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\r\n\r\n\t\t\t\t\ttrimSegment( end, start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// clip space\r\n\t\t\tvec4 clipStart = projectionMatrix * start;\r\n\t\t\tvec4 clipEnd = projectionMatrix * end;\r\n\r\n\t\t\t// ndc space\r\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\r\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\r\n\r\n\t\t\t// direction\r\n\t\t\tvec2 dir = ndcEnd - ndcStart;\r\n\r\n\t\t\t// account for clip-space aspect ratio\r\n\t\t\tdir.x *= aspect;\r\n\t\t\tdir = normalize( dir );\r\n\r\n\t\t\t// perpendicular to dir\r\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\r\n\r\n\t\t\t// undo aspect ratio adjustment\r\n\t\t\tdir.x /= aspect;\r\n\t\t\toffset.x /= aspect;\r\n\r\n\t\t\t// sign flip\r\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\r\n\r\n\t\t\t// endcaps\r\n\t\t\tif ( position.y < 0.0 ) {\r\n\r\n\t\t\t\toffset += - dir;\r\n\r\n\t\t\t} else if ( position.y > 1.0 ) {\r\n\r\n\t\t\t\toffset += dir;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// adjust for linewidth\r\n\t\t\toffset *= linewidth;\r\n\r\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\r\n\t\t\toffset /= resolution.y;\r\n\r\n\t\t\t// select end\r\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\r\n\r\n\t\t\t// back to clip space\r\n\t\t\toffset *= clip.w;\r\n\r\n\t\t\tclip.xy += offset;\r\n\r\n\t\t\tgl_Position = clip;\r\n\r\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\r\n\r\n\t\t\t#include <logdepthbuf_vertex>\r\n\t\t\t#include <clipping_planes_vertex>\r\n\t\t\t#include <fog_vertex>\r\n\r\n\t\t}\r\n\t\t`,\r\n        fragmentShader: `\r\n\t\tuniform vec3 diffuse;\r\n\t\tuniform float opacity;\r\n\r\n\t\t#ifdef USE_DASH\r\n\r\n\t\t\tuniform float dashSize;\r\n\t\t\tuniform float gapSize;\r\n\r\n\t\t#endif\r\n\r\n\t\tvarying float vLineDistance;\r\n\r\n\t\t#include <common>\r\n\t\t#include <color_pars_fragment>\r\n\t\t#include <fog_pars_fragment>\r\n\t\t#include <logdepthbuf_pars_fragment>\r\n\t\t#include <clipping_planes_pars_fragment>\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <clipping_planes_fragment>\r\n\r\n\t\t\t#ifdef USE_DASH\r\n\r\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\r\n\r\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\r\n\r\n\t\t\t\tfloat a = vUv.x;\r\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\r\n\t\t\t\tfloat len2 = a * a + b * b;\r\n\r\n\t\t\t\tif ( len2 > 1.0 ) discard;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t\t\t#include <logdepthbuf_fragment>\r\n\t\t\t#include <color_fragment>\r\n\r\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\r\n\r\n\t\t\t#include <tonemapping_fragment>\r\n\t\t\t#include <encodings_fragment>\r\n\t\t\t#include <fog_fragment>\r\n\t\t\t#include <premultiplied_alpha_fragment>\r\n\r\n\t\t}\r\n\t\t`\r\n    };\r\n    var LineMaterial = function (parameters) {\r\n        THREE.ShaderMaterial.call(this, {\r\n            type: 'LineMaterial',\r\n            uniforms: THREE.UniformsUtils.clone(THREE.ShaderLib['line'].uniforms),\r\n            vertexShader: THREE.ShaderLib['line'].vertexShader,\r\n            fragmentShader: THREE.ShaderLib['line'].fragmentShader,\r\n            clipping: true\r\n        });\r\n        this.dashed = false;\r\n        Object.defineProperties(this, {\r\n            color: {\r\n                enumerable: true,\r\n                get: function () {\r\n                    return this.uniforms.diffuse.value;\r\n                },\r\n                set: function (value) {\r\n                    this.uniforms.diffuse.value = value;\r\n                }\r\n            },\r\n            linewidth: {\r\n                enumerable: true,\r\n                get: function () {\r\n                    return this.uniforms.linewidth.value;\r\n                },\r\n                set: function (value) {\r\n                    this.uniforms.linewidth.value = value;\r\n                }\r\n            },\r\n            dashScale: {\r\n                enumerable: true,\r\n                get: function () {\r\n                    return this.uniforms.dashScale.value;\r\n                },\r\n                set: function (value) {\r\n                    this.uniforms.dashScale.value = value;\r\n                }\r\n            },\r\n            dashSize: {\r\n                enumerable: true,\r\n                get: function () {\r\n                    return this.uniforms.dashSize.value;\r\n                },\r\n                set: function (value) {\r\n                    this.uniforms.dashSize.value = value;\r\n                }\r\n            },\r\n            gapSize: {\r\n                enumerable: true,\r\n                get: function () {\r\n                    return this.uniforms.gapSize.value;\r\n                },\r\n                set: function (value) {\r\n                    this.uniforms.gapSize.value = value;\r\n                }\r\n            },\r\n            resolution: {\r\n                enumerable: true,\r\n                get: function () {\r\n                    return this.uniforms.resolution.value;\r\n                },\r\n                set: function (value) {\r\n                    this.uniforms.resolution.value.copy(value);\r\n                }\r\n            }\r\n        });\r\n        this.setValues(parameters);\r\n    };\r\n    LineMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);\r\n    LineMaterial.prototype.constructor = LineMaterial;\r\n    LineMaterial.prototype.isLineMaterial = true;\r\n\r\n    return threex.lines.LineMaterial = LineMaterial;\r\n});"]}