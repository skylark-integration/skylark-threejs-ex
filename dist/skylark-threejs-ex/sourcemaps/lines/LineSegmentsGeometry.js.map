{"version":3,"sources":["lines/LineSegmentsGeometry.js"],"names":["define","THREE","threex","vector","box","LineSegmentsGeometry","InstancedBufferGeometry","call","this","type","setIndex","setAttribute","Float32BufferAttribute","prototype","Object","assign","create","constructor","isLineSegmentsGeometry","applyMatrix4","matrix","start","attributes","instanceStart","end","instanceEnd","undefined","data","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","setPositions","array","lineSegments","Float32Array","Array","isArray","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","setColors","colors","instanceColorBuffer","fromWireframeGeometry","geometry","position","fromEdgesGeometry","fromMesh","mesh","WireframeGeometry","fromLineSegements","isGeometry","vertices","isBufferGeometry","Box3","setFromBufferAttribute","union","Vector3","Sphere","center","getCenter","maxRadiusSq","i","il","count","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","console","error","toJSON","applyMatrix","warn","lines"],"mappings":"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","file":"../../lines/LineSegmentsGeometry.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var LineSegmentsGeometry = function () {\r\n        THREE.InstancedBufferGeometry.call(this);\r\n        this.type = 'LineSegmentsGeometry';\r\n        var positions = [\r\n            -1,\r\n            2,\r\n            0,\r\n            1,\r\n            2,\r\n            0,\r\n            -1,\r\n            1,\r\n            0,\r\n            1,\r\n            1,\r\n            0,\r\n            -1,\r\n            0,\r\n            0,\r\n            1,\r\n            0,\r\n            0,\r\n            -1,\r\n            -1,\r\n            0,\r\n            1,\r\n            -1,\r\n            0\r\n        ];\r\n        var uvs = [\r\n            -1,\r\n            2,\r\n            1,\r\n            2,\r\n            -1,\r\n            1,\r\n            1,\r\n            1,\r\n            -1,\r\n            -1,\r\n            1,\r\n            -1,\r\n            -1,\r\n            -2,\r\n            1,\r\n            -2\r\n        ];\r\n        var index = [\r\n            0,\r\n            2,\r\n            1,\r\n            2,\r\n            3,\r\n            1,\r\n            2,\r\n            4,\r\n            3,\r\n            4,\r\n            5,\r\n            3,\r\n            4,\r\n            6,\r\n            5,\r\n            6,\r\n            7,\r\n            5\r\n        ];\r\n        this.setIndex(index);\r\n        this.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n        this.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\r\n    };\r\n    LineSegmentsGeometry.prototype = Object.assign(Object.create(THREE.InstancedBufferGeometry.prototype), {\r\n        constructor: LineSegmentsGeometry,\r\n        isLineSegmentsGeometry: true,\r\n        applyMatrix4: function (matrix) {\r\n            var start = this.attributes.instanceStart;\r\n            var end = this.attributes.instanceEnd;\r\n            if (start !== undefined) {\r\n                start.applyMatrix4(matrix);\r\n                end.applyMatrix4(matrix);\r\n                start.data.needsUpdate = true;\r\n            }\r\n            if (this.boundingBox !== null) {\r\n                this.computeBoundingBox();\r\n            }\r\n            if (this.boundingSphere !== null) {\r\n                this.computeBoundingSphere();\r\n            }\r\n            return this;\r\n        },\r\n        setPositions: function (array) {\r\n            var lineSegments;\r\n            if (array instanceof Float32Array) {\r\n                lineSegments = array;\r\n            } else if (Array.isArray(array)) {\r\n                lineSegments = new Float32Array(array);\r\n            }\r\n            var instanceBuffer = new THREE.InstancedInterleavedBuffer(lineSegments, 6, 1);\r\n            this.setAttribute('instanceStart', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 0));\r\n            this.setAttribute('instanceEnd', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 3));\r\n            this.computeBoundingBox();\r\n            this.computeBoundingSphere();\r\n            return this;\r\n        },\r\n        setColors: function (array) {\r\n            var colors;\r\n            if (array instanceof Float32Array) {\r\n                colors = array;\r\n            } else if (Array.isArray(array)) {\r\n                colors = new Float32Array(array);\r\n            }\r\n            var instanceColorBuffer = new THREE.InstancedInterleavedBuffer(colors, 6, 1);\r\n            this.setAttribute('instanceColorStart', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 0));\r\n            this.setAttribute('instanceColorEnd', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 3));\r\n            return this;\r\n        },\r\n        fromWireframeGeometry: function (geometry) {\r\n            this.setPositions(geometry.attributes.position.array);\r\n            return this;\r\n        },\r\n        fromEdgesGeometry: function (geometry) {\r\n            this.setPositions(geometry.attributes.position.array);\r\n            return this;\r\n        },\r\n        fromMesh: function (mesh) {\r\n            this.fromWireframeGeometry(new THREE.WireframeGeometry(mesh.geometry));\r\n            return this;\r\n        },\r\n        fromLineSegements: function (lineSegments) {\r\n            var geometry = lineSegments.geometry;\r\n            if (geometry.isGeometry) {\r\n                this.setPositions(geometry.vertices);\r\n            } else if (geometry.isBufferGeometry) {\r\n                this.setPositions(geometry.position.array);\r\n            }\r\n            return this;\r\n        },\r\n        computeBoundingBox: function () {\r\n            var box = new THREE.Box3();\r\n            return function computeBoundingBox() {\r\n                if (this.boundingBox === null) {\r\n                    this.boundingBox = new THREE.Box3();\r\n                }\r\n                var start = this.attributes.instanceStart;\r\n                var end = this.attributes.instanceEnd;\r\n                if (start !== undefined && end !== undefined) {\r\n                    this.boundingBox.setFromBufferAttribute(start);\r\n                    box.setFromBufferAttribute(end);\r\n                    this.boundingBox.union(box);\r\n                }\r\n            };\r\n        }(),\r\n        computeBoundingSphere: function () {\r\n            var vector = new THREE.Vector3();\r\n            return function computeBoundingSphere() {\r\n                if (this.boundingSphere === null) {\r\n                    this.boundingSphere = new THREE.Sphere();\r\n                }\r\n                if (this.boundingBox === null) {\r\n                    this.computeBoundingBox();\r\n                }\r\n                var start = this.attributes.instanceStart;\r\n                var end = this.attributes.instanceEnd;\r\n                if (start !== undefined && end !== undefined) {\r\n                    var center = this.boundingSphere.center;\r\n                    this.boundingBox.getCenter(center);\r\n                    var maxRadiusSq = 0;\r\n                    for (var i = 0, il = start.count; i < il; i++) {\r\n                        vector.fromBufferAttribute(start, i);\r\n                        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\r\n                        vector.fromBufferAttribute(end, i);\r\n                        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\r\n                    }\r\n                    this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\r\n                    if (isNaN(this.boundingSphere.radius)) {\r\n                        console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\r\n                    }\r\n                }\r\n            };\r\n        }(),\r\n        toJSON: function () {\r\n        },\r\n        applyMatrix: function (matrix) {\r\n            console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\r\n            return this.applyMatrix4(matrix);\r\n        }\r\n    });\r\n\r\n    return threex.lines.LineSegmentsGeometry = LineSegmentsGeometry;\r\n});"]}