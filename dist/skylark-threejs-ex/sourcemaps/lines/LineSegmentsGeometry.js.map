{"version":3,"sources":["lines/LineSegmentsGeometry.js"],"names":["define","THREE","vector","box","LineSegmentsGeometry","InstancedBufferGeometry","call","this","type","setIndex","setAttribute","Float32BufferAttribute","prototype","Object","assign","create","constructor","isLineSegmentsGeometry","applyMatrix4","matrix","start","attributes","instanceStart","end","instanceEnd","undefined","data","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","setPositions","array","lineSegments","Float32Array","Array","isArray","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","setColors","colors","instanceColorBuffer","fromWireframeGeometry","geometry","position","fromEdgesGeometry","fromMesh","mesh","WireframeGeometry","fromLineSegements","isGeometry","vertices","isBufferGeometry","Box3","setFromBufferAttribute","union","Vector3","Sphere","center","getCenter","maxRadiusSq","i","il","count","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","console","error","toJSON","applyMatrix","warn"],"mappings":"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","file":"../../lines/LineSegmentsGeometry.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t */\n\n\tTHREE.LineSegmentsGeometry = function () {\n\n\t\tTHREE.InstancedBufferGeometry.call( this );\n\n\t\tthis.type = 'LineSegmentsGeometry';\n\n\t\tvar positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\t\tvar uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];\n\t\tvar index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];\n\n\t\tthis.setIndex( index );\n\t\tthis.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );\n\t\tthis.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );\n\n\t};\n\n\tTHREE.LineSegmentsGeometry.prototype = Object.assign( Object.create( THREE.InstancedBufferGeometry.prototype ), {\n\n\t\tconstructor: THREE.LineSegmentsGeometry,\n\n\t\tisLineSegmentsGeometry: true,\n\n\t\tapplyMatrix4: function ( matrix ) {\n\n\t\t\tvar start = this.attributes.instanceStart;\n\t\t\tvar end = this.attributes.instanceEnd;\n\n\t\t\tif ( start !== undefined ) {\n\n\t\t\t\tstart.applyMatrix4( matrix );\n\n\t\t\t\tend.applyMatrix4( matrix );\n\n\t\t\t\tstart.data.needsUpdate = true;\n\n\t\t\t}\n\n\t\t\tif ( this.boundingBox !== null ) {\n\n\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\t\tthis.computeBoundingSphere();\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPositions: function ( array ) {\n\n\t\t\tvar lineSegments;\n\n\t\t\tif ( array instanceof Float32Array ) {\n\n\t\t\t\tlineSegments = array;\n\n\t\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\t\tlineSegments = new Float32Array( array );\n\n\t\t\t}\n\n\t\t\tvar instanceBuffer = new THREE.InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz\n\n\t\t\tthis.setAttribute( 'instanceStart', new THREE.InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz\n\t\t\tthis.setAttribute( 'instanceEnd', new THREE.InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz\n\n\t\t\t//\n\n\t\t\tthis.computeBoundingBox();\n\t\t\tthis.computeBoundingSphere();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetColors: function ( array ) {\n\n\t\t\tvar colors;\n\n\t\t\tif ( array instanceof Float32Array ) {\n\n\t\t\t\tcolors = array;\n\n\t\t\t} else if ( Array.isArray( array ) ) {\n\n\t\t\t\tcolors = new Float32Array( array );\n\n\t\t\t}\n\n\t\t\tvar instanceColorBuffer = new THREE.InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb\n\n\t\t\tthis.setAttribute( 'instanceColorStart', new THREE.InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb\n\t\t\tthis.setAttribute( 'instanceColorEnd', new THREE.InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tfromWireframeGeometry: function ( geometry ) {\n\n\t\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tfromEdgesGeometry: function ( geometry ) {\n\n\t\t\tthis.setPositions( geometry.attributes.position.array );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tfromMesh: function ( mesh ) {\n\n\t\t\tthis.fromWireframeGeometry( new THREE.WireframeGeometry( mesh.geometry ) );\n\n\t\t\t// set colors, maybe\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tfromLineSegements: function ( lineSegments ) {\n\n\t\t\tvar geometry = lineSegments.geometry;\n\n\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\tthis.setPositions( geometry.vertices );\n\n\t\t\t} else if ( geometry.isBufferGeometry ) {\n\n\t\t\t\tthis.setPositions( geometry.position.array ); // assumes non-indexed\n\n\t\t\t}\n\n\t\t\t// set colors, maybe\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcomputeBoundingBox: function () {\n\n\t\t\tvar box = new THREE.Box3();\n\n\t\t\treturn function computeBoundingBox() {\n\n\t\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t\t\t}\n\n\t\t\t\tvar start = this.attributes.instanceStart;\n\t\t\t\tvar end = this.attributes.instanceEnd;\n\n\t\t\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\t\t\tthis.boundingBox.setFromBufferAttribute( start );\n\n\t\t\t\t\tbox.setFromBufferAttribute( end );\n\n\t\t\t\t\tthis.boundingBox.union( box );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tcomputeBoundingSphere: function () {\n\n\t\t\tvar vector = new THREE.Vector3();\n\n\t\t\treturn function computeBoundingSphere() {\n\n\t\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.boundingBox === null ) {\n\n\t\t\t\t\tthis.computeBoundingBox();\n\n\t\t\t\t}\n\n\t\t\t\tvar start = this.attributes.instanceStart;\n\t\t\t\tvar end = this.attributes.instanceEnd;\n\n\t\t\t\tif ( start !== undefined && end !== undefined ) {\n\n\t\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\t\tthis.boundingBox.getCenter( center );\n\n\t\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\t\tfor ( var i = 0, il = start.count; i < il; i ++ ) {\n\n\t\t\t\t\t\tvector.fromBufferAttribute( start, i );\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t\t\tvector.fromBufferAttribute( end, i );\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\ttoJSON: function () {\n\n\t\t\t// todo\n\n\t\t},\n\n\t\tapplyMatrix: function ( matrix ) {\n\n\t\t\tconsole.warn( 'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().' );\n\n\t\t\treturn this.applyMatrix4( matrix );\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.LineSegmentsGeometry;\n});\n"]}