{"version":3,"sources":["lines/LineSegmentsGeometry.js"],"names":["define","THREE","threex","vector","box","LineSegmentsGeometry","InstancedBufferGeometry","call","this","type","setIndex","setAttribute","Float32BufferAttribute","prototype","Object","assign","create","constructor","isLineSegmentsGeometry","applyMatrix4","matrix","start","attributes","instanceStart","end","instanceEnd","undefined","data","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","setPositions","array","lineSegments","Float32Array","Array","isArray","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","setColors","colors","instanceColorBuffer","fromWireframeGeometry","geometry","position","fromEdgesGeometry","fromMesh","mesh","WireframeGeometry","fromLineSegements","isGeometry","vertices","isBufferGeometry","Box3","setFromBufferAttribute","union","Vector3","Sphere","center","getCenter","maxRadiusSq","i","il","count","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","console","error","toJSON","applyMatrix","warn","lins"],"mappings":"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","file":"../../lines/LineSegmentsGeometry.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    var LineSegmentsGeometry = function () {\n        THREE.InstancedBufferGeometry.call(this);\n        this.type = 'LineSegmentsGeometry';\n        var positions = [\n            -1,\n            2,\n            0,\n            1,\n            2,\n            0,\n            -1,\n            1,\n            0,\n            1,\n            1,\n            0,\n            -1,\n            0,\n            0,\n            1,\n            0,\n            0,\n            -1,\n            -1,\n            0,\n            1,\n            -1,\n            0\n        ];\n        var uvs = [\n            -1,\n            2,\n            1,\n            2,\n            -1,\n            1,\n            1,\n            1,\n            -1,\n            -1,\n            1,\n            -1,\n            -1,\n            -2,\n            1,\n            -2\n        ];\n        var index = [\n            0,\n            2,\n            1,\n            2,\n            3,\n            1,\n            2,\n            4,\n            3,\n            4,\n            5,\n            3,\n            4,\n            6,\n            5,\n            6,\n            7,\n            5\n        ];\n        this.setIndex(index);\n        this.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n        this.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\n    };\n    LineSegmentsGeometry.prototype = Object.assign(Object.create(THREE.InstancedBufferGeometry.prototype), {\n        constructor: LineSegmentsGeometry,\n        isLineSegmentsGeometry: true,\n        applyMatrix4: function (matrix) {\n            var start = this.attributes.instanceStart;\n            var end = this.attributes.instanceEnd;\n            if (start !== undefined) {\n                start.applyMatrix4(matrix);\n                end.applyMatrix4(matrix);\n                start.data.needsUpdate = true;\n            }\n            if (this.boundingBox !== null) {\n                this.computeBoundingBox();\n            }\n            if (this.boundingSphere !== null) {\n                this.computeBoundingSphere();\n            }\n            return this;\n        },\n        setPositions: function (array) {\n            var lineSegments;\n            if (array instanceof Float32Array) {\n                lineSegments = array;\n            } else if (Array.isArray(array)) {\n                lineSegments = new Float32Array(array);\n            }\n            var instanceBuffer = new THREE.InstancedInterleavedBuffer(lineSegments, 6, 1);\n            this.setAttribute('instanceStart', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 0));\n            this.setAttribute('instanceEnd', new THREE.InterleavedBufferAttribute(instanceBuffer, 3, 3));\n            this.computeBoundingBox();\n            this.computeBoundingSphere();\n            return this;\n        },\n        setColors: function (array) {\n            var colors;\n            if (array instanceof Float32Array) {\n                colors = array;\n            } else if (Array.isArray(array)) {\n                colors = new Float32Array(array);\n            }\n            var instanceColorBuffer = new THREE.InstancedInterleavedBuffer(colors, 6, 1);\n            this.setAttribute('instanceColorStart', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 0));\n            this.setAttribute('instanceColorEnd', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 3, 3));\n            return this;\n        },\n        fromWireframeGeometry: function (geometry) {\n            this.setPositions(geometry.attributes.position.array);\n            return this;\n        },\n        fromEdgesGeometry: function (geometry) {\n            this.setPositions(geometry.attributes.position.array);\n            return this;\n        },\n        fromMesh: function (mesh) {\n            this.fromWireframeGeometry(new THREE.WireframeGeometry(mesh.geometry));\n            return this;\n        },\n        fromLineSegements: function (lineSegments) {\n            var geometry = lineSegments.geometry;\n            if (geometry.isGeometry) {\n                this.setPositions(geometry.vertices);\n            } else if (geometry.isBufferGeometry) {\n                this.setPositions(geometry.position.array);\n            }\n            return this;\n        },\n        computeBoundingBox: function () {\n            var box = new THREE.Box3();\n            return function computeBoundingBox() {\n                if (this.boundingBox === null) {\n                    this.boundingBox = new THREE.Box3();\n                }\n                var start = this.attributes.instanceStart;\n                var end = this.attributes.instanceEnd;\n                if (start !== undefined && end !== undefined) {\n                    this.boundingBox.setFromBufferAttribute(start);\n                    box.setFromBufferAttribute(end);\n                    this.boundingBox.union(box);\n                }\n            };\n        }(),\n        computeBoundingSphere: function () {\n            var vector = new THREE.Vector3();\n            return function computeBoundingSphere() {\n                if (this.boundingSphere === null) {\n                    this.boundingSphere = new THREE.Sphere();\n                }\n                if (this.boundingBox === null) {\n                    this.computeBoundingBox();\n                }\n                var start = this.attributes.instanceStart;\n                var end = this.attributes.instanceEnd;\n                if (start !== undefined && end !== undefined) {\n                    var center = this.boundingSphere.center;\n                    this.boundingBox.getCenter(center);\n                    var maxRadiusSq = 0;\n                    for (var i = 0, il = start.count; i < il; i++) {\n                        vector.fromBufferAttribute(start, i);\n                        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\n                        vector.fromBufferAttribute(end, i);\n                        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\n                    }\n                    this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n                    if (isNaN(this.boundingSphere.radius)) {\n                        console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);\n                    }\n                }\n            };\n        }(),\n        toJSON: function () {\n        },\n        applyMatrix: function (matrix) {\n            console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().');\n            return this.applyMatrix4(matrix);\n        }\n    });\n\n    return threex.lins.LineSegmentsGeometry = LineSegmentsGeometry;\n});"]}