{"version":3,"sources":["postprocessing/CubeTexturePass.js"],"names":["define","THREE","threex","Pass","CubeTexturePass","camera","envMap","opacity","call","this","needsSwap","cubeShader","ShaderLib","cubeMesh","Mesh","BoxBufferGeometry","ShaderMaterial","uniforms","vertexShader","fragmentShader","depthTest","depthWrite","side","BackSide","Object","defineProperty","material","get","value","undefined","cubeScene","Scene","cubeCamera","PerspectiveCamera","add","prototype","assign","create","constructor","render","renderer","writeBuffer","readBuffer","oldAutoClear","autoClear","projectionMatrix","copy","quaternion","setFromRotationMatrix","matrixWorld","transparent","setRenderTarget","renderToScreen","clear","postprocessing"],"mappings":";;;;;;;AAAAA,QACI,kBACA,YACA,0BACD,SACCC,EACAC,EACAC,GAEA,aACA,IAAIC,EAAkB,SAAUC,EAAQC,EAAQC,GAC5CJ,EAAKK,KAAKC,MACVA,KAAKJ,OAASA,EACdI,KAAKC,WAAY,EACjBD,KAAKE,WAAaV,EAAMW,UAAgB,KACxCH,KAAKI,SAAW,IAAIZ,EAAMa,KAAK,IAAIb,EAAMc,kBAAkB,GAAI,GAAI,IAAK,IAAId,EAAMe,gBAC9EC,SAAUR,KAAKE,WAAWM,SAC1BC,aAAcT,KAAKE,WAAWO,aAC9BC,eAAgBV,KAAKE,WAAWQ,eAChCC,WAAW,EACXC,YAAY,EACZC,KAAMrB,EAAMsB,YAEhBC,OAAOC,eAAehB,KAAKI,SAASa,SAAU,UAC1CC,IAAK,WACD,OAAOlB,KAAKQ,SAASX,OAAOsB,SAGpCnB,KAAKH,OAASA,EACdG,KAAKF,aAAsBsB,IAAZtB,EAAwBA,EAAU,EACjDE,KAAKqB,UAAY,IAAI7B,EAAM8B,MAC3BtB,KAAKuB,WAAa,IAAI/B,EAAMgC,kBAC5BxB,KAAKqB,UAAUI,IAAIzB,KAAKI,WAoB5B,OAlBAT,EAAgB+B,UAAYX,OAAOY,OAAOZ,OAAOa,OAAOlC,EAAKgC,YACzDG,YAAalC,EACbmC,OAAQ,SAAUC,EAAUC,EAAaC,GACrC,IAAIC,EAAeH,EAASI,UAC5BJ,EAASI,WAAY,EACrBnC,KAAKuB,WAAWa,iBAAiBC,KAAKrC,KAAKJ,OAAOwC,kBAClDpC,KAAKuB,WAAWe,WAAWC,sBAAsBvC,KAAKJ,OAAO4C,aAC7DxC,KAAKI,SAASa,SAAST,SAASX,OAAOsB,MAAQnB,KAAKH,OACpDG,KAAKI,SAASa,SAAST,SAASV,QAAQqB,MAAQnB,KAAKF,QACrDE,KAAKI,SAASa,SAASwB,YAAczC,KAAKF,QAAU,EACpDiC,EAASW,gBAAgB1C,KAAK2C,eAAiB,KAAOV,GAClDjC,KAAK4C,OACLb,EAASa,QACbb,EAASD,OAAO9B,KAAKqB,UAAWrB,KAAKuB,YACrCQ,EAASI,UAAYD,KAItBzC,EAAOoD,eAAelD,gBAAkBA","file":"../../postprocessing/CubeTexturePass.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\",\r\n    '../postprocessing/Pass'\r\n], function (\r\n    THREE, \r\n    threex,\r\n    Pass\r\n) {\r\n    'use strict';\r\n    var CubeTexturePass = function (camera, envMap, opacity) {\r\n        Pass.call(this);\r\n        this.camera = camera;\r\n        this.needsSwap = false;\r\n        this.cubeShader = THREE.ShaderLib['cube'];\r\n        this.cubeMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(10, 10, 10), new THREE.ShaderMaterial({\r\n            uniforms: this.cubeShader.uniforms,\r\n            vertexShader: this.cubeShader.vertexShader,\r\n            fragmentShader: this.cubeShader.fragmentShader,\r\n            depthTest: false,\r\n            depthWrite: false,\r\n            side: THREE.BackSide\r\n        }));\r\n        Object.defineProperty(this.cubeMesh.material, 'envMap', {\r\n            get: function () {\r\n                return this.uniforms.envMap.value;\r\n            }\r\n        });\r\n        this.envMap = envMap;\r\n        this.opacity = opacity !== undefined ? opacity : 1;\r\n        this.cubeScene = new THREE.Scene();\r\n        this.cubeCamera = new THREE.PerspectiveCamera();\r\n        this.cubeScene.add(this.cubeMesh);\r\n    };\r\n    CubeTexturePass.prototype = Object.assign(Object.create(Pass.prototype), {\r\n        constructor: CubeTexturePass,\r\n        render: function (renderer, writeBuffer, readBuffer) {\r\n            var oldAutoClear = renderer.autoClear;\r\n            renderer.autoClear = false;\r\n            this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);\r\n            this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);\r\n            this.cubeMesh.material.uniforms.envMap.value = this.envMap;\r\n            this.cubeMesh.material.uniforms.opacity.value = this.opacity;\r\n            this.cubeMesh.material.transparent = this.opacity < 1;\r\n            renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\r\n            if (this.clear)\r\n                renderer.clear();\r\n            renderer.render(this.cubeScene, this.cubeCamera);\r\n            renderer.autoClear = oldAutoClear;\r\n        }\r\n    });\r\n\r\n    return threex.postprocessing.CubeTexturePass = CubeTexturePass;\r\n});"]}