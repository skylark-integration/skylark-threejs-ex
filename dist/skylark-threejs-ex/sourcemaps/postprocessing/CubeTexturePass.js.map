{"version":3,"sources":["postprocessing/CubeTexturePass.js"],"names":["define","THREE","Pass","CubeTexturePass","camera","envMap","opacity","call","this","needsSwap","cubeShader","ShaderLib","cubeMesh","Mesh","BoxBufferGeometry","ShaderMaterial","uniforms","vertexShader","fragmentShader","depthTest","depthWrite","side","BackSide","Object","defineProperty","material","get","value","undefined","cubeScene","Scene","cubeCamera","PerspectiveCamera","add","prototype","assign","create","constructor","render","renderer","writeBuffer","readBuffer","oldAutoClear","autoClear","projectionMatrix","copy","quaternion","setFromRotationMatrix","matrixWorld","transparent","setRenderTarget","renderToScreen","clear"],"mappings":";;;;;;;AAAAA,QACC,kBACA,UACC,SAASC,EAAMC,GAuEhB,OAlEAD,EAAME,gBAAkB,SAAWC,EAAQC,EAAQC,GAElDL,EAAMC,KAAKK,KAAMC,MAEjBA,KAAKJ,OAASA,EAEdI,KAAKC,WAAY,EAEjBD,KAAKE,WAAaT,EAAMU,UAAkB,KAC1CH,KAAKI,SAAW,IAAIX,EAAMY,KACzB,IAAIZ,EAAMa,kBAAmB,GAAI,GAAI,IACrC,IAAIb,EAAMc,gBACTC,SAAUR,KAAKE,WAAWM,SAC1BC,aAAcT,KAAKE,WAAWO,aAC9BC,eAAgBV,KAAKE,WAAWQ,eAChCC,WAAW,EACXC,YAAY,EACZC,KAAMpB,EAAMqB,YAIdC,OAAOC,eAAgBhB,KAAKI,SAASa,SAAU,UAE9CC,IAAK,WAEJ,OAAOlB,KAAKQ,SAASX,OAAOsB,SAM9BnB,KAAKH,OAASA,EACdG,KAAKF,aAAwBsB,IAAZtB,EAA0BA,EAAU,EAErDE,KAAKqB,UAAY,IAAI5B,EAAM6B,MAC3BtB,KAAKuB,WAAa,IAAI9B,EAAM+B,kBAC5BxB,KAAKqB,UAAUI,IAAKzB,KAAKI,WAI1BX,EAAME,gBAAgB+B,UAAYX,OAAOY,OAAQZ,OAAOa,OAAQnC,EAAMC,KAAKgC,YAE1EG,YAAapC,EAAME,gBAEnBmC,OAAQ,SAAWC,EAAUC,EAAaC,GAEzC,IAAIC,EAAeH,EAASI,UAC5BJ,EAASI,WAAY,EAErBnC,KAAKuB,WAAWa,iBAAiBC,KAAMrC,KAAKJ,OAAOwC,kBACnDpC,KAAKuB,WAAWe,WAAWC,sBAAuBvC,KAAKJ,OAAO4C,aAE9DxC,KAAKI,SAASa,SAAST,SAASX,OAAOsB,MAAQnB,KAAKH,OACpDG,KAAKI,SAASa,SAAST,SAASV,QAAQqB,MAAQnB,KAAKF,QACrDE,KAAKI,SAASa,SAASwB,YAAgBzC,KAAKF,QAAU,EAEtDiC,EAASW,gBAAiB1C,KAAK2C,eAAiB,KAAOV,GAClDjC,KAAK4C,OAAQb,EAASa,QAC3Bb,EAASD,OAAQ9B,KAAKqB,UAAWrB,KAAKuB,YAEtCQ,EAASI,UAAYD,KAMhBzC,EAAME","file":"../../postprocessing/CubeTexturePass.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"./Pass\"\n],function(THREE,Pass){\n\t/**\n\t * @author bhouston / http://clara.io/\n\t */\n\n\tTHREE.CubeTexturePass = function ( camera, envMap, opacity ) {\n\n\t\tTHREE.Pass.call( this );\n\n\t\tthis.camera = camera;\n\n\t\tthis.needsSwap = false;\n\n\t\tthis.cubeShader = THREE.ShaderLib[ 'cube' ];\n\t\tthis.cubeMesh = new THREE.Mesh(\n\t\t\tnew THREE.BoxBufferGeometry( 10, 10, 10 ),\n\t\t\tnew THREE.ShaderMaterial( {\n\t\t\t\tuniforms: this.cubeShader.uniforms,\n\t\t\t\tvertexShader: this.cubeShader.vertexShader,\n\t\t\t\tfragmentShader: this.cubeShader.fragmentShader,\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\tside: THREE.BackSide\n\t\t\t} )\n\t\t);\n\n\t\tObject.defineProperty( this.cubeMesh.material, 'envMap', {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms.envMap.value;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.envMap = envMap;\n\t\tthis.opacity = ( opacity !== undefined ) ? opacity : 1.0;\n\n\t\tthis.cubeScene = new THREE.Scene();\n\t\tthis.cubeCamera = new THREE.PerspectiveCamera();\n\t\tthis.cubeScene.add( this.cubeMesh );\n\n\t};\n\n\tTHREE.CubeTexturePass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\n\t\tconstructor: THREE.CubeTexturePass,\n\n\t\trender: function ( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {\n\n\t\t\tvar oldAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\n\t\t\tthis.cubeCamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\t\t\tthis.cubeCamera.quaternion.setFromRotationMatrix( this.camera.matrixWorld );\n\n\t\t\tthis.cubeMesh.material.uniforms.envMap.value = this.envMap;\n\t\t\tthis.cubeMesh.material.uniforms.opacity.value = this.opacity;\n\t\t\tthis.cubeMesh.material.transparent = ( this.opacity < 1.0 );\n\n\t\t\trenderer.setRenderTarget( this.renderToScreen ? null : readBuffer );\n\t\t\tif ( this.clear ) renderer.clear();\n\t\t\trenderer.render( this.cubeScene, this.cubeCamera );\n\n\t\t\trenderer.autoClear = oldAutoClear;\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.CubeTexturePass;\n});\n"]}