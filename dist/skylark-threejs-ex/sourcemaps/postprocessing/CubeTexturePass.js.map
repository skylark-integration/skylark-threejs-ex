{"version":3,"sources":["postprocessing/CubeTexturePass.js"],"names":["define","THREE","threex","Pass","CubeTexturePass","camera","envMap","opacity","call","this","needsSwap","cubeShader","ShaderLib","cubeMesh","Mesh","BoxBufferGeometry","ShaderMaterial","uniforms","vertexShader","fragmentShader","depthTest","depthWrite","side","BackSide","Object","defineProperty","material","get","value","undefined","cubeScene","Scene","cubeCamera","PerspectiveCamera","add","prototype","assign","create","constructor","render","renderer","writeBuffer","readBuffer","oldAutoClear","autoClear","projectionMatrix","copy","quaternion","setFromRotationMatrix","matrixWorld","transparent","setRenderTarget","renderToScreen","clear","postprocessing"],"mappings":";;;;;;;AAAAA,QACI,kBACA,YACA,0BACD,SACCC,EACAC,EACAC,GAEA,aACA,IAAIC,EAAkB,SAAUC,EAAQC,EAAQC,GAC5CJ,EAAKK,KAAKC,MACVA,KAAKJ,OAASA,EACdI,KAAKC,WAAY,EACjBD,KAAKE,WAAaV,EAAMW,UAAgB,KACxCH,KAAKI,SAAW,IAAIZ,EAAMa,KAAK,IAAIb,EAAMc,kBAAkB,GAAI,GAAI,IAAK,IAAId,EAAMe,gBAC9EC,SAAUR,KAAKE,WAAWM,SAC1BC,aAAcT,KAAKE,WAAWO,aAC9BC,eAAgBV,KAAKE,WAAWQ,eAChCC,WAAW,EACXC,YAAY,EACZC,KAAMrB,EAAMsB,YAEhBC,OAAOC,eAAehB,KAAKI,SAASa,SAAU,UAC1CC,IAAK,WACD,OAAOlB,KAAKQ,SAASX,OAAOsB,SAGpCnB,KAAKH,OAASA,EACdG,KAAKF,aAAsBsB,IAAZtB,EAAwBA,EAAU,EACjDE,KAAKqB,UAAY,IAAI7B,EAAM8B,MAC3BtB,KAAKuB,WAAa,IAAI/B,EAAMgC,kBAC5BxB,KAAKqB,UAAUI,IAAIzB,KAAKI,WAoB5B,OAlBAT,EAAgB+B,UAAYX,OAAOY,OAAOZ,OAAOa,OAAOlC,EAAKgC,YACzDG,YAAalC,EACbmC,OAAQ,SAAUC,EAAUC,EAAaC,GACrC,IAAIC,EAAeH,EAASI,UAC5BJ,EAASI,WAAY,EACrBnC,KAAKuB,WAAWa,iBAAiBC,KAAKrC,KAAKJ,OAAOwC,kBAClDpC,KAAKuB,WAAWe,WAAWC,sBAAsBvC,KAAKJ,OAAO4C,aAC7DxC,KAAKI,SAASa,SAAST,SAASX,OAAOsB,MAAQnB,KAAKH,OACpDG,KAAKI,SAASa,SAAST,SAASV,QAAQqB,MAAQnB,KAAKF,QACrDE,KAAKI,SAASa,SAASwB,YAAczC,KAAKF,QAAU,EACpDiC,EAASW,gBAAgB1C,KAAK2C,eAAiB,KAAOV,GAClDjC,KAAK4C,OACLb,EAASa,QACbb,EAASD,OAAO9B,KAAKqB,UAAWrB,KAAKuB,YACrCQ,EAASI,UAAYD,KAItBzC,EAAOoD,eAAelD,gBAAkBA","file":"../../postprocessing/CubeTexturePass.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\",\n    '../postprocessing/Pass'\n], function (\n    THREE, \n    threex,\n    Pass\n) {\n    'use strict';\n    var CubeTexturePass = function (camera, envMap, opacity) {\n        Pass.call(this);\n        this.camera = camera;\n        this.needsSwap = false;\n        this.cubeShader = THREE.ShaderLib['cube'];\n        this.cubeMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(10, 10, 10), new THREE.ShaderMaterial({\n            uniforms: this.cubeShader.uniforms,\n            vertexShader: this.cubeShader.vertexShader,\n            fragmentShader: this.cubeShader.fragmentShader,\n            depthTest: false,\n            depthWrite: false,\n            side: THREE.BackSide\n        }));\n        Object.defineProperty(this.cubeMesh.material, 'envMap', {\n            get: function () {\n                return this.uniforms.envMap.value;\n            }\n        });\n        this.envMap = envMap;\n        this.opacity = opacity !== undefined ? opacity : 1;\n        this.cubeScene = new THREE.Scene();\n        this.cubeCamera = new THREE.PerspectiveCamera();\n        this.cubeScene.add(this.cubeMesh);\n    };\n    CubeTexturePass.prototype = Object.assign(Object.create(Pass.prototype), {\n        constructor: CubeTexturePass,\n        render: function (renderer, writeBuffer, readBuffer) {\n            var oldAutoClear = renderer.autoClear;\n            renderer.autoClear = false;\n            this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);\n            this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);\n            this.cubeMesh.material.uniforms.envMap.value = this.envMap;\n            this.cubeMesh.material.uniforms.opacity.value = this.opacity;\n            this.cubeMesh.material.transparent = this.opacity < 1;\n            renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n            if (this.clear)\n                renderer.clear();\n            renderer.render(this.cubeScene, this.cubeCamera);\n            renderer.autoClear = oldAutoClear;\n        }\n    });\n\n    return threex.postprocessing.CubeTexturePass = CubeTexturePass;\n});"]}