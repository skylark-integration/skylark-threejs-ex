{"version":3,"sources":["postprocessing/OutlinePass.js"],"names":["define","THREE","threex","Pass","CopyShader","OutlinePass","resolution","scene","camera","selectedObjects","this","renderScene","renderCamera","undefined","visibleEdgeColor","Color","hiddenEdgeColor","edgeGlow","usePatternTexture","edgeThickness","edgeStrength","downSampleRatio","pulsePeriod","call","Vector2","x","y","pars","minFilter","LinearFilter","magFilter","format","RGBAFormat","resx","Math","round","resy","maskBufferMaterial","MeshBasicMaterial","color","side","DoubleSide","renderTargetMaskBuffer","WebGLRenderTarget","texture","name","generateMipmaps","depthMaterial","MeshDepthMaterial","depthPacking","RGBADepthPacking","blending","NoBlending","prepareMaskMaterial","getPrepareMaskMaterial","fragmentShader","string","type","isPerspectiveCamera","replace","replaceDepthToViewZ","renderTargetDepthBuffer","renderTargetMaskDownSampleBuffer","renderTargetBlurBuffer1","renderTargetBlurBuffer2","edgeDetectionMaterial","getEdgeDetectionMaterial","renderTargetEdgeBuffer1","renderTargetEdgeBuffer2","separableBlurMaterial1","getSeperableBlurMaterial","uniforms","value","set","separableBlurMaterial2","overlayMaterial","getOverlayMaterial","console","error","copyShader","copyUniforms","UniformsUtils","clone","materialCopy","ShaderMaterial","vertexShader","depthTest","depthWrite","transparent","enabled","needsSwap","oldClearColor","oldClearAlpha","fsQuad","FullScreenQuad","tempPulseColor1","tempPulseColor2","textureMatrix","Matrix4","prototype","Object","assign","create","constructor","dispose","setSize","width","height","changeVisibilityOfSelectedObjects","bVisible","gatherSelectedMeshesCallBack","object","isMesh","visible","userData","oldVisible","i","length","traverse","changeVisibilityOfNonSelectedObjects","selectedMeshes","push","isLine","isSprite","bFound","id","visibility","updateTextureMatrix","multiply","projectionMatrix","matrixWorldInverse","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","copy","getClearColor","getClearAlpha","oldAutoClear","autoClear","state","buffers","stencil","setTest","setClearColor","currentBackground","background","overrideMaterial","setRenderTarget","clear","near","far","material","scalar","cos","performance","now","multiplyScalar","BlurDirectionX","BlurDirectionY","patternTexture","renderToScreen","depthTexture","cameraNearFar","join","maskTexture","texSize","Vector3","maxRadius","defines","MAX_RADIUS","colorTexture","direction","kernelRadius","edgeTexture1","edgeTexture2","AdditiveBlending","postprocessing"],"mappings":"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","file":"../../postprocessing/OutlinePass.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\",\r\n    './Pass',\r\n    '../shaders/CopyShader'\r\n], function (\r\n    THREE,\r\n    threex, \r\n    Pass, \r\n    CopyShader\r\n) {\r\n    'use strict';\r\n    var OutlinePass = function (resolution, scene, camera, selectedObjects) {\r\n        this.renderScene = scene;\r\n        this.renderCamera = camera;\r\n        this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\r\n        this.visibleEdgeColor = new THREE.Color(1, 1, 1);\r\n        this.hiddenEdgeColor = new THREE.Color(0.1, 0.04, 0.02);\r\n        this.edgeGlow = 0;\r\n        this.usePatternTexture = false;\r\n        this.edgeThickness = 1;\r\n        this.edgeStrength = 3;\r\n        this.downSampleRatio = 2;\r\n        this.pulsePeriod = 0;\r\n        Pass.call(this);\r\n        this.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);\r\n        var pars = {\r\n            minFilter: THREE.LinearFilter,\r\n            magFilter: THREE.LinearFilter,\r\n            format: THREE.RGBAFormat\r\n        };\r\n        var resx = Math.round(this.resolution.x / this.downSampleRatio);\r\n        var resy = Math.round(this.resolution.y / this.downSampleRatio);\r\n        this.maskBufferMaterial = new THREE.MeshBasicMaterial({ color: 16777215 });\r\n        this.maskBufferMaterial.side = THREE.DoubleSide;\r\n        this.renderTargetMaskBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\r\n        this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\r\n        this.renderTargetMaskBuffer.texture.generateMipmaps = false;\r\n        this.depthMaterial = new THREE.MeshDepthMaterial();\r\n        this.depthMaterial.side = THREE.DoubleSide;\r\n        this.depthMaterial.depthPacking = THREE.RGBADepthPacking;\r\n        this.depthMaterial.blending = THREE.NoBlending;\r\n        this.prepareMaskMaterial = this.getPrepareMaskMaterial();\r\n        this.prepareMaskMaterial.side = THREE.DoubleSide;\r\n        this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\r\n        this.renderTargetDepthBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\r\n        this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\r\n        this.renderTargetDepthBuffer.texture.generateMipmaps = false;\r\n        this.renderTargetMaskDownSampleBuffer = new THREE.WebGLRenderTarget(resx, resy, pars);\r\n        this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\r\n        this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\r\n        this.renderTargetBlurBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars);\r\n        this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\r\n        this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\r\n        this.renderTargetBlurBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\r\n        this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\r\n        this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\r\n        this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\r\n        this.renderTargetEdgeBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars);\r\n        this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\r\n        this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\r\n        this.renderTargetEdgeBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\r\n        this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\r\n        this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\r\n        var MAX_EDGE_THICKNESS = 4;\r\n        var MAX_EDGE_GLOW = 4;\r\n        this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\r\n        this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\r\n        this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;\r\n        this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\r\n        this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));\r\n        this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW;\r\n        this.overlayMaterial = this.getOverlayMaterial();\r\n        if (CopyShader === undefined)\r\n            console.error('OutlinePass relies on CopyShader');\r\n        var copyShader = CopyShader;\r\n        this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\r\n        this.copyUniforms['opacity'].value = 1;\r\n        this.materialCopy = new THREE.ShaderMaterial({\r\n            uniforms: this.copyUniforms,\r\n            vertexShader: copyShader.vertexShader,\r\n            fragmentShader: copyShader.fragmentShader,\r\n            blending: THREE.NoBlending,\r\n            depthTest: false,\r\n            depthWrite: false,\r\n            transparent: true\r\n        });\r\n        this.enabled = true;\r\n        this.needsSwap = false;\r\n        this.oldClearColor = new THREE.Color();\r\n        this.oldClearAlpha = 1;\r\n        this.fsQuad = new Pass.FullScreenQuad(null);\r\n        this.tempPulseColor1 = new THREE.Color();\r\n        this.tempPulseColor2 = new THREE.Color();\r\n        this.textureMatrix = new THREE.Matrix4();\r\n        function replaceDepthToViewZ(string, camera) {\r\n            var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\r\n            return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\r\n        }\r\n    };\r\n    OutlinePass.prototype = Object.assign(Object.create(Pass.prototype), {\r\n        constructor: OutlinePass,\r\n        dispose: function () {\r\n            this.renderTargetMaskBuffer.dispose();\r\n            this.renderTargetDepthBuffer.dispose();\r\n            this.renderTargetMaskDownSampleBuffer.dispose();\r\n            this.renderTargetBlurBuffer1.dispose();\r\n            this.renderTargetBlurBuffer2.dispose();\r\n            this.renderTargetEdgeBuffer1.dispose();\r\n            this.renderTargetEdgeBuffer2.dispose();\r\n        },\r\n        setSize: function (width, height) {\r\n            this.renderTargetMaskBuffer.setSize(width, height);\r\n            var resx = Math.round(width / this.downSampleRatio);\r\n            var resy = Math.round(height / this.downSampleRatio);\r\n            this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\r\n            this.renderTargetBlurBuffer1.setSize(resx, resy);\r\n            this.renderTargetEdgeBuffer1.setSize(resx, resy);\r\n            this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\r\n            resx = Math.round(resx / 2);\r\n            resy = Math.round(resy / 2);\r\n            this.renderTargetBlurBuffer2.setSize(resx, resy);\r\n            this.renderTargetEdgeBuffer2.setSize(resx, resy);\r\n            this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);\r\n        },\r\n        changeVisibilityOfSelectedObjects: function (bVisible) {\r\n            function gatherSelectedMeshesCallBack(object) {\r\n                if (object.isMesh) {\r\n                    if (bVisible) {\r\n                        object.visible = object.userData.oldVisible;\r\n                        delete object.userData.oldVisible;\r\n                    } else {\r\n                        object.userData.oldVisible = object.visible;\r\n                        object.visible = bVisible;\r\n                    }\r\n                }\r\n            }\r\n            for (var i = 0; i < this.selectedObjects.length; i++) {\r\n                var selectedObject = this.selectedObjects[i];\r\n                selectedObject.traverse(gatherSelectedMeshesCallBack);\r\n            }\r\n        },\r\n        changeVisibilityOfNonSelectedObjects: function (bVisible) {\r\n            var selectedMeshes = [];\r\n            function gatherSelectedMeshesCallBack(object) {\r\n                if (object.isMesh)\r\n                    selectedMeshes.push(object);\r\n            }\r\n            for (var i = 0; i < this.selectedObjects.length; i++) {\r\n                var selectedObject = this.selectedObjects[i];\r\n                selectedObject.traverse(gatherSelectedMeshesCallBack);\r\n            }\r\n            function VisibilityChangeCallBack(object) {\r\n                if (object.isMesh || object.isLine || object.isSprite) {\r\n                    var bFound = false;\r\n                    for (var i = 0; i < selectedMeshes.length; i++) {\r\n                        var selectedObjectId = selectedMeshes[i].id;\r\n                        if (selectedObjectId === object.id) {\r\n                            bFound = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!bFound) {\r\n                        var visibility = object.visible;\r\n                        if (!bVisible || object.bVisible)\r\n                            object.visible = bVisible;\r\n                        object.bVisible = visibility;\r\n                    }\r\n                }\r\n            }\r\n            this.renderScene.traverse(VisibilityChangeCallBack);\r\n        },\r\n        updateTextureMatrix: function () {\r\n            this.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\r\n            this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\r\n            this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\r\n        },\r\n        render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\r\n            if (this.selectedObjects.length > 0) {\r\n                this.oldClearColor.copy(renderer.getClearColor());\r\n                this.oldClearAlpha = renderer.getClearAlpha();\r\n                var oldAutoClear = renderer.autoClear;\r\n                renderer.autoClear = false;\r\n                if (maskActive)\r\n                    renderer.state.buffers.stencil.setTest(false);\r\n                renderer.setClearColor(16777215, 1);\r\n                this.changeVisibilityOfSelectedObjects(false);\r\n                var currentBackground = this.renderScene.background;\r\n                this.renderScene.background = null;\r\n                this.renderScene.overrideMaterial = this.depthMaterial;\r\n                renderer.setRenderTarget(this.renderTargetDepthBuffer);\r\n                renderer.clear();\r\n                renderer.render(this.renderScene, this.renderCamera);\r\n                this.changeVisibilityOfSelectedObjects(true);\r\n                this.updateTextureMatrix();\r\n                this.changeVisibilityOfNonSelectedObjects(false);\r\n                this.renderScene.overrideMaterial = this.prepareMaskMaterial;\r\n                this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);\r\n                this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;\r\n                this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;\r\n                renderer.setRenderTarget(this.renderTargetMaskBuffer);\r\n                renderer.clear();\r\n                renderer.render(this.renderScene, this.renderCamera);\r\n                this.renderScene.overrideMaterial = null;\r\n                this.changeVisibilityOfNonSelectedObjects(true);\r\n                this.renderScene.background = currentBackground;\r\n                this.fsQuad.material = this.materialCopy;\r\n                this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;\r\n                renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\r\n                renderer.clear();\r\n                this.fsQuad.render(renderer);\r\n                this.tempPulseColor1.copy(this.visibleEdgeColor);\r\n                this.tempPulseColor2.copy(this.hiddenEdgeColor);\r\n                if (this.pulsePeriod > 0) {\r\n                    var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1 - 0.25) / 2;\r\n                    this.tempPulseColor1.multiplyScalar(scalar);\r\n                    this.tempPulseColor2.multiplyScalar(scalar);\r\n                }\r\n                this.fsQuad.material = this.edgeDetectionMaterial;\r\n                this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;\r\n                this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\r\n                this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1;\r\n                this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2;\r\n                renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\r\n                renderer.clear();\r\n                this.fsQuad.render(renderer);\r\n                this.fsQuad.material = this.separableBlurMaterial1;\r\n                this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\r\n                this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionX;\r\n                this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;\r\n                renderer.setRenderTarget(this.renderTargetBlurBuffer1);\r\n                renderer.clear();\r\n                this.fsQuad.render(renderer);\r\n                this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;\r\n                this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionY;\r\n                renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\r\n                renderer.clear();\r\n                this.fsQuad.render(renderer);\r\n                this.fsQuad.material = this.separableBlurMaterial2;\r\n                this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\r\n                this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionX;\r\n                renderer.setRenderTarget(this.renderTargetBlurBuffer2);\r\n                renderer.clear();\r\n                this.fsQuad.render(renderer);\r\n                this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;\r\n                this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionY;\r\n                renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\r\n                renderer.clear();\r\n                this.fsQuad.render(renderer);\r\n                this.fsQuad.material = this.overlayMaterial;\r\n                this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;\r\n                this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;\r\n                this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;\r\n                this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;\r\n                this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;\r\n                this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;\r\n                this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;\r\n                if (maskActive)\r\n                    renderer.state.buffers.stencil.setTest(true);\r\n                renderer.setRenderTarget(readBuffer);\r\n                this.fsQuad.render(renderer);\r\n                renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);\r\n                renderer.autoClear = oldAutoClear;\r\n            }\r\n            if (this.renderToScreen) {\r\n                this.fsQuad.material = this.materialCopy;\r\n                this.copyUniforms['tDiffuse'].value = readBuffer.texture;\r\n                renderer.setRenderTarget(null);\r\n                this.fsQuad.render(renderer);\r\n            }\r\n        },\r\n        getPrepareMaskMaterial: function () {\r\n            return new THREE.ShaderMaterial({\r\n                uniforms: {\r\n                    'depthTexture': { value: null },\r\n                    'cameraNearFar': { value: new THREE.Vector2(0.5, 0.5) },\r\n                    'textureMatrix': { value: null }\r\n                },\r\n                vertexShader: [\r\n                    '#include <morphtarget_pars_vertex>',\r\n                    '#include <skinning_pars_vertex>',\r\n                    'varying vec4 projTexCoord;',\r\n                    'varying vec4 vPosition;',\r\n                    'uniform mat4 textureMatrix;',\r\n                    'void main() {',\r\n                    '\\t#include <skinbase_vertex>',\r\n                    '\\t#include <begin_vertex>',\r\n                    '\\t#include <morphtarget_vertex>',\r\n                    '\\t#include <skinning_vertex>',\r\n                    '\\t#include <project_vertex>',\r\n                    '\\tvPosition = mvPosition;',\r\n                    '\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\r\n                    '\\tprojTexCoord = textureMatrix * worldPosition;',\r\n                    '}'\r\n                ].join('\\n'),\r\n                fragmentShader: [\r\n                    '#include <packing>',\r\n                    'varying vec4 vPosition;',\r\n                    'varying vec4 projTexCoord;',\r\n                    'uniform sampler2D depthTexture;',\r\n                    'uniform vec2 cameraNearFar;',\r\n                    'void main() {',\r\n                    '\\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));',\r\n                    '\\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );',\r\n                    '\\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;',\r\n                    '\\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);',\r\n                    '}'\r\n                ].join('\\n')\r\n            });\r\n        },\r\n        getEdgeDetectionMaterial: function () {\r\n            return new THREE.ShaderMaterial({\r\n                uniforms: {\r\n                    'maskTexture': { value: null },\r\n                    'texSize': { value: new THREE.Vector2(0.5, 0.5) },\r\n                    'visibleEdgeColor': { value: new THREE.Vector3(1, 1, 1) },\r\n                    'hiddenEdgeColor': { value: new THREE.Vector3(1, 1, 1) }\r\n                },\r\n                vertexShader: 'varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}',\r\n                fragmentShader: 'varying vec2 vUv;\\t\\t\\t\\tuniform sampler2D maskTexture;\\t\\t\\t\\tuniform vec2 texSize;\\t\\t\\t\\tuniform vec3 visibleEdgeColor;\\t\\t\\t\\tuniform vec3 hiddenEdgeColor;\\t\\t\\t\\t\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\t\\t\\t\\t\\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\t\\t\\t\\t\\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\t\\t\\t\\t\\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\t\\t\\t\\t\\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\t\\t\\t\\t\\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\t\\t\\t\\t\\tfloat diff1 = (c1.r - c2.r)*0.5;\\t\\t\\t\\t\\tfloat diff2 = (c3.r - c4.r)*0.5;\\t\\t\\t\\t\\tfloat d = length( vec2(diff1, diff2) );\\t\\t\\t\\t\\tfloat a1 = min(c1.g, c2.g);\\t\\t\\t\\t\\tfloat a2 = min(c3.g, c4.g);\\t\\t\\t\\t\\tfloat visibilityFactor = min(a1, a2);\\t\\t\\t\\t\\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\t\\t\\t\\t\\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\t\\t\\t\\t}'\r\n            });\r\n        },\r\n        getSeperableBlurMaterial: function (maxRadius) {\r\n            return new THREE.ShaderMaterial({\r\n                defines: { 'MAX_RADIUS': maxRadius },\r\n                uniforms: {\r\n                    'colorTexture': { value: null },\r\n                    'texSize': { value: new THREE.Vector2(0.5, 0.5) },\r\n                    'direction': { value: new THREE.Vector2(0.5, 0.5) },\r\n                    'kernelRadius': { value: 1 }\r\n                },\r\n                vertexShader: 'varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}',\r\n                fragmentShader: '#include <common>\\t\\t\\t\\tvarying vec2 vUv;\\t\\t\\t\\tuniform sampler2D colorTexture;\\t\\t\\t\\tuniform vec2 texSize;\\t\\t\\t\\tuniform vec2 direction;\\t\\t\\t\\tuniform float kernelRadius;\\t\\t\\t\\t\\t\\t\\t\\tfloat gaussianPdf(in float x, in float sigma) {\\t\\t\\t\\t\\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\t\\t\\t\\t}\\t\\t\\t\\tvoid main() {\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\t\\t\\t\\t\\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\t\\t\\t\\t\\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\\t\\t\\t\\t\\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\t\\t\\t\\t\\tvec2 uvOffset = delta;\\t\\t\\t\\t\\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\t\\t\\t\\t\\t\\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\t\\t\\t\\t\\t\\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\\t\\t\\t\\t\\t\\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\\t\\t\\t\\t\\t\\tdiffuseSum += ((sample1 + sample2) * w);\\t\\t\\t\\t\\t\\tweightSum += (2.0 * w);\\t\\t\\t\\t\\t\\tuvOffset += delta;\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\tgl_FragColor = diffuseSum/weightSum;\\t\\t\\t\\t}'\r\n            });\r\n        },\r\n        getOverlayMaterial: function () {\r\n            return new THREE.ShaderMaterial({\r\n                uniforms: {\r\n                    'maskTexture': { value: null },\r\n                    'edgeTexture1': { value: null },\r\n                    'edgeTexture2': { value: null },\r\n                    'patternTexture': { value: null },\r\n                    'edgeStrength': { value: 1 },\r\n                    'edgeGlow': { value: 1 },\r\n                    'usePatternTexture': { value: 0 }\r\n                },\r\n                vertexShader: 'varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}',\r\n                fragmentShader: 'varying vec2 vUv;\\t\\t\\t\\tuniform sampler2D maskTexture;\\t\\t\\t\\tuniform sampler2D edgeTexture1;\\t\\t\\t\\tuniform sampler2D edgeTexture2;\\t\\t\\t\\tuniform sampler2D patternTexture;\\t\\t\\t\\tuniform float edgeStrength;\\t\\t\\t\\tuniform float edgeGlow;\\t\\t\\t\\tuniform bool usePatternTexture;\\t\\t\\t\\t\\t\\t\\t\\tvoid main() {\\t\\t\\t\\t\\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\t\\t\\t\\t\\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\t\\t\\t\\t\\tvec4 maskColor = texture2D(maskTexture, vUv);\\t\\t\\t\\t\\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\t\\t\\t\\t\\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\t\\t\\t\\t\\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\t\\t\\t\\t\\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\t\\t\\t\\t\\tif(usePatternTexture)\\t\\t\\t\\t\\t\\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\t\\t\\t\\t\\tgl_FragColor = finalColor;\\t\\t\\t\\t}',\r\n                blending: THREE.AdditiveBlending,\r\n                depthTest: false,\r\n                depthWrite: false,\r\n                transparent: true\r\n            });\r\n        }\r\n    });\r\n    OutlinePass.BlurDirectionX = new THREE.Vector2(1, 0);\r\n    OutlinePass.BlurDirectionY = new THREE.Vector2(0, 1);\r\n\r\n    return threex.postprocessing.OutlinePass = OutlinePass;\r\n});"]}