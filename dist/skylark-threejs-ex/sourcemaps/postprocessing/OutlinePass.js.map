{"version":3,"sources":["postprocessing/OutlinePass.js"],"names":["define","THREE","CopyShader","Pass","OutlinePass","resolution","scene","camera","selectedObjects","this","renderScene","renderCamera","undefined","visibleEdgeColor","Color","hiddenEdgeColor","edgeGlow","usePatternTexture","edgeThickness","edgeStrength","downSampleRatio","pulsePeriod","call","Vector2","x","y","pars","minFilter","LinearFilter","magFilter","format","RGBAFormat","resx","Math","round","resy","maskBufferMaterial","MeshBasicMaterial","color","side","DoubleSide","renderTargetMaskBuffer","WebGLRenderTarget","texture","name","generateMipmaps","depthMaterial","MeshDepthMaterial","depthPacking","RGBADepthPacking","blending","NoBlending","prepareMaskMaterial","getPrepareMaskMaterial","fragmentShader","string","type","isPerspectiveCamera","replace","replaceDepthToViewZ","renderTargetDepthBuffer","renderTargetMaskDownSampleBuffer","renderTargetBlurBuffer1","renderTargetBlurBuffer2","edgeDetectionMaterial","getEdgeDetectionMaterial","renderTargetEdgeBuffer1","renderTargetEdgeBuffer2","separableBlurMaterial1","getSeperableBlurMaterial","uniforms","value","set","separableBlurMaterial2","overlayMaterial","getOverlayMaterial","console","error","copyShader","copyUniforms","UniformsUtils","clone","materialCopy","ShaderMaterial","vertexShader","depthTest","depthWrite","transparent","enabled","needsSwap","oldClearColor","oldClearAlpha","fsQuad","FullScreenQuad","tempPulseColor1","tempPulseColor2","textureMatrix","Matrix4","prototype","Object","assign","create","constructor","dispose","setSize","width","height","changeVisibilityOfSelectedObjects","bVisible","gatherSelectedMeshesCallBack","object","isMesh","visible","userData","oldVisible","i","length","traverse","changeVisibilityOfNonSelectedObjects","selectedMeshes","push","isLine","isSprite","bFound","id","visibility","updateTextureMatrix","multiply","projectionMatrix","matrixWorldInverse","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","copy","getClearColor","getClearAlpha","oldAutoClear","autoClear","state","buffers","stencil","setTest","setClearColor","currentBackground","background","overrideMaterial","setRenderTarget","clear","near","far","material","scalar","cos","performance","now","multiplyScalar","BlurDirectionX","BlurDirectionY","patternTexture","renderToScreen","depthTexture","cameraNearFar","join","maskTexture","texSize","Vector3","maxRadius","defines","MAX_RADIUS","colorTexture","direction","kernelRadius","edgeTexture1","edgeTexture2","AdditiveBlending"],"mappings":"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","file":"../../postprocessing/OutlinePass.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"../shaders/CopyShader\",\n\t\"./Pass\"\n],function(THREE,CopyShader,Pass){\n\t/**\n\t * @author spidersharma / http://eduperiment.com/\n\t */\n\n\tTHREE.OutlinePass = function ( resolution, scene, camera, selectedObjects ) {\n\n\t\tthis.renderScene = scene;\n\t\tthis.renderCamera = camera;\n\t\tthis.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n\t\tthis.visibleEdgeColor = new THREE.Color( 1, 1, 1 );\n\t\tthis.hiddenEdgeColor = new THREE.Color( 0.1, 0.04, 0.02 );\n\t\tthis.edgeGlow = 0.0;\n\t\tthis.usePatternTexture = false;\n\t\tthis.edgeThickness = 1.0;\n\t\tthis.edgeStrength = 3.0;\n\t\tthis.downSampleRatio = 2;\n\t\tthis.pulsePeriod = 0;\n\n\t\tTHREE.Pass.call( this );\n\n\t\tthis.resolution = ( resolution !== undefined ) ? new THREE.Vector2( resolution.x, resolution.y ) : new THREE.Vector2( 256, 256 );\n\n\t\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\n\n\t\tvar resx = Math.round( this.resolution.x / this.downSampleRatio );\n\t\tvar resy = Math.round( this.resolution.y / this.downSampleRatio );\n\n\t\tthis.maskBufferMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff } );\n\t\tthis.maskBufferMaterial.side = THREE.DoubleSide;\n\t\tthis.renderTargetMaskBuffer = new THREE.WebGLRenderTarget( this.resolution.x, this.resolution.y, pars );\n\t\tthis.renderTargetMaskBuffer.texture.name = \"OutlinePass.mask\";\n\t\tthis.renderTargetMaskBuffer.texture.generateMipmaps = false;\n\n\t\tthis.depthMaterial = new THREE.MeshDepthMaterial();\n\t\tthis.depthMaterial.side = THREE.DoubleSide;\n\t\tthis.depthMaterial.depthPacking = THREE.RGBADepthPacking;\n\t\tthis.depthMaterial.blending = THREE.NoBlending;\n\n\t\tthis.prepareMaskMaterial = this.getPrepareMaskMaterial();\n\t\tthis.prepareMaskMaterial.side = THREE.DoubleSide;\n\t\tthis.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ( this.prepareMaskMaterial.fragmentShader, this.renderCamera );\n\n\t\tthis.renderTargetDepthBuffer = new THREE.WebGLRenderTarget( this.resolution.x, this.resolution.y, pars );\n\t\tthis.renderTargetDepthBuffer.texture.name = \"OutlinePass.depth\";\n\t\tthis.renderTargetDepthBuffer.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetMaskDownSampleBuffer = new THREE.WebGLRenderTarget( resx, resy, pars );\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.name = \"OutlinePass.depthDownSample\";\n\t\tthis.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetBlurBuffer1 = new THREE.WebGLRenderTarget( resx, resy, pars );\n\t\tthis.renderTargetBlurBuffer1.texture.name = \"OutlinePass.blur1\";\n\t\tthis.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n\t\tthis.renderTargetBlurBuffer2 = new THREE.WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), pars );\n\t\tthis.renderTargetBlurBuffer2.texture.name = \"OutlinePass.blur2\";\n\t\tthis.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n\n\t\tthis.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n\t\tthis.renderTargetEdgeBuffer1 = new THREE.WebGLRenderTarget( resx, resy, pars );\n\t\tthis.renderTargetEdgeBuffer1.texture.name = \"OutlinePass.edge1\";\n\t\tthis.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n\t\tthis.renderTargetEdgeBuffer2 = new THREE.WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), pars );\n\t\tthis.renderTargetEdgeBuffer2.texture.name = \"OutlinePass.edge2\";\n\t\tthis.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n\n\t\tvar MAX_EDGE_THICKNESS = 4;\n\t\tvar MAX_EDGE_GLOW = 4;\n\n\t\tthis.separableBlurMaterial1 = this.getSeperableBlurMaterial( MAX_EDGE_THICKNESS );\n\t\tthis.separableBlurMaterial1.uniforms[ \"texSize\" ].value.set( resx, resy );\n\t\tthis.separableBlurMaterial1.uniforms[ \"kernelRadius\" ].value = 1;\n\t\tthis.separableBlurMaterial2 = this.getSeperableBlurMaterial( MAX_EDGE_GLOW );\n\t\tthis.separableBlurMaterial2.uniforms[ \"texSize\" ].value.set( Math.round( resx / 2 ), Math.round( resy / 2 ) );\n\t\tthis.separableBlurMaterial2.uniforms[ \"kernelRadius\" ].value = MAX_EDGE_GLOW;\n\n\t\t// Overlay material\n\t\tthis.overlayMaterial = this.getOverlayMaterial();\n\n\t\t// copy material\n\t\tif ( THREE.CopyShader === undefined )\n\t\t\tconsole.error( \"THREE.OutlinePass relies on THREE.CopyShader\" );\n\n\t\tvar copyShader = THREE.CopyShader;\n\n\t\tthis.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );\n\t\tthis.copyUniforms[ \"opacity\" ].value = 1.0;\n\n\t\tthis.materialCopy = new THREE.ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: THREE.NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis.oldClearColor = new THREE.Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis.fsQuad = new THREE.Pass.FullScreenQuad( null );\n\n\t\tthis.tempPulseColor1 = new THREE.Color();\n\t\tthis.tempPulseColor2 = new THREE.Color();\n\t\tthis.textureMatrix = new THREE.Matrix4();\n\n\t\tfunction replaceDepthToViewZ( string, camera ) {\n\n\t\t\tvar type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n\n\t\t\treturn string.replace( /DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ' );\n\n\t\t}\n\n\t};\n\n\tTHREE.OutlinePass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\n\t\tconstructor: THREE.OutlinePass,\n\n\t\tdispose: function () {\n\n\t\t\tthis.renderTargetMaskBuffer.dispose();\n\t\t\tthis.renderTargetDepthBuffer.dispose();\n\t\t\tthis.renderTargetMaskDownSampleBuffer.dispose();\n\t\t\tthis.renderTargetBlurBuffer1.dispose();\n\t\t\tthis.renderTargetBlurBuffer2.dispose();\n\t\t\tthis.renderTargetEdgeBuffer1.dispose();\n\t\t\tthis.renderTargetEdgeBuffer2.dispose();\n\n\t\t},\n\n\t\tsetSize: function ( width, height ) {\n\n\t\t\tthis.renderTargetMaskBuffer.setSize( width, height );\n\n\t\t\tvar resx = Math.round( width / this.downSampleRatio );\n\t\t\tvar resy = Math.round( height / this.downSampleRatio );\n\t\t\tthis.renderTargetMaskDownSampleBuffer.setSize( resx, resy );\n\t\t\tthis.renderTargetBlurBuffer1.setSize( resx, resy );\n\t\t\tthis.renderTargetEdgeBuffer1.setSize( resx, resy );\n\t\t\tthis.separableBlurMaterial1.uniforms[ \"texSize\" ].value.set( resx, resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t\tthis.renderTargetBlurBuffer2.setSize( resx, resy );\n\t\t\tthis.renderTargetEdgeBuffer2.setSize( resx, resy );\n\n\t\t\tthis.separableBlurMaterial2.uniforms[ \"texSize\" ].value.set( resx, resy );\n\n\t\t},\n\n\t\tchangeVisibilityOfSelectedObjects: function ( bVisible ) {\n\n\t\t\tfunction gatherSelectedMeshesCallBack( object ) {\n\n\t\t\t\tif ( object.isMesh ) {\n\n\t\t\t\t\tif ( bVisible ) {\n\n\t\t\t\t\t\tobject.visible = object.userData.oldVisible;\n\t\t\t\t\t\tdelete object.userData.oldVisible;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject.userData.oldVisible = object.visible;\n\t\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\t\tvar selectedObject = this.selectedObjects[ i ];\n\t\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\n\n\t\t\t}\n\n\t\t},\n\n\t\tchangeVisibilityOfNonSelectedObjects: function ( bVisible ) {\n\n\t\t\tvar selectedMeshes = [];\n\n\t\t\tfunction gatherSelectedMeshesCallBack( object ) {\n\n\t\t\t\tif ( object.isMesh ) selectedMeshes.push( object );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\t\tvar selectedObject = this.selectedObjects[ i ];\n\t\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\n\n\t\t\t}\n\n\t\t\tfunction VisibilityChangeCallBack( object ) {\n\n\t\t\t\tif ( object.isMesh || object.isLine || object.isSprite ) {\n\n\t\t\t\t\tvar bFound = false;\n\n\t\t\t\t\tfor ( var i = 0; i < selectedMeshes.length; i ++ ) {\n\n\t\t\t\t\t\tvar selectedObjectId = selectedMeshes[ i ].id;\n\n\t\t\t\t\t\tif ( selectedObjectId === object.id ) {\n\n\t\t\t\t\t\t\tbFound = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! bFound ) {\n\n\t\t\t\t\t\tvar visibility = object.visible;\n\n\t\t\t\t\t\tif ( ! bVisible || object.bVisible ) object.visible = bVisible;\n\n\t\t\t\t\t\tobject.bVisible = visibility;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.renderScene.traverse( VisibilityChangeCallBack );\n\n\t\t},\n\n\t\tupdateTextureMatrix: function () {\n\n\t\t\tthis.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0 );\n\t\t\tthis.textureMatrix.multiply( this.renderCamera.projectionMatrix );\n\t\t\tthis.textureMatrix.multiply( this.renderCamera.matrixWorldInverse );\n\n\t\t},\n\n\t\trender: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\t\tif ( this.selectedObjects.length > 0 ) {\n\n\t\t\t\tthis.oldClearColor.copy( renderer.getClearColor() );\n\t\t\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\t\t\tvar oldAutoClear = renderer.autoClear;\n\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t\t\trenderer.setClearColor( 0xffffff, 1 );\n\n\t\t\t\t// Make selected objects invisible\n\t\t\t\tthis.changeVisibilityOfSelectedObjects( false );\n\n\t\t\t\tvar currentBackground = this.renderScene.background;\n\t\t\t\tthis.renderScene.background = null;\n\n\t\t\t\t// 1. Draw Non Selected objects in the depth buffer\n\t\t\t\tthis.renderScene.overrideMaterial = this.depthMaterial;\n\t\t\t\trenderer.setRenderTarget( this.renderTargetDepthBuffer );\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\n\t\t\t\t// Make selected objects visible\n\t\t\t\tthis.changeVisibilityOfSelectedObjects( true );\n\n\t\t\t\t// Update Texture Matrix for Depth compare\n\t\t\t\tthis.updateTextureMatrix();\n\n\t\t\t\t// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\t\t\t\tthis.changeVisibilityOfNonSelectedObjects( false );\n\t\t\t\tthis.renderScene.overrideMaterial = this.prepareMaskMaterial;\n\t\t\t\tthis.prepareMaskMaterial.uniforms[ \"cameraNearFar\" ].value.set( this.renderCamera.near, this.renderCamera.far );\n\t\t\t\tthis.prepareMaskMaterial.uniforms[ \"depthTexture\" ].value = this.renderTargetDepthBuffer.texture;\n\t\t\t\tthis.prepareMaskMaterial.uniforms[ \"textureMatrix\" ].value = this.textureMatrix;\n\t\t\t\trenderer.setRenderTarget( this.renderTargetMaskBuffer );\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\t\t\t\tthis.renderScene.overrideMaterial = null;\n\t\t\t\tthis.changeVisibilityOfNonSelectedObjects( true );\n\n\t\t\t\tthis.renderScene.background = currentBackground;\n\n\t\t\t\t// 2. Downsample to Half resolution\n\t\t\t\tthis.fsQuad.material = this.materialCopy;\n\t\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetMaskBuffer.texture;\n\t\t\t\trenderer.setRenderTarget( this.renderTargetMaskDownSampleBuffer );\n\t\t\t\trenderer.clear();\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t\tthis.tempPulseColor1.copy( this.visibleEdgeColor );\n\t\t\t\tthis.tempPulseColor2.copy( this.hiddenEdgeColor );\n\n\t\t\t\tif ( this.pulsePeriod > 0 ) {\n\n\t\t\t\t\tvar scalar = ( 1 + 0.25 ) / 2 + Math.cos( performance.now() * 0.01 / this.pulsePeriod ) * ( 1.0 - 0.25 ) / 2;\n\t\t\t\t\tthis.tempPulseColor1.multiplyScalar( scalar );\n\t\t\t\t\tthis.tempPulseColor2.multiplyScalar( scalar );\n\n\t\t\t\t}\n\n\t\t\t\t// 3. Apply Edge Detection Pass\n\t\t\t\tthis.fsQuad.material = this.edgeDetectionMaterial;\n\t\t\t\tthis.edgeDetectionMaterial.uniforms[ \"maskTexture\" ].value = this.renderTargetMaskDownSampleBuffer.texture;\n\t\t\t\tthis.edgeDetectionMaterial.uniforms[ \"texSize\" ].value.set( this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height );\n\t\t\t\tthis.edgeDetectionMaterial.uniforms[ \"visibleEdgeColor\" ].value = this.tempPulseColor1;\n\t\t\t\tthis.edgeDetectionMaterial.uniforms[ \"hiddenEdgeColor\" ].value = this.tempPulseColor2;\n\t\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\t\trenderer.clear();\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t\t// 4. Apply Blur on Half res\n\t\t\t\tthis.fsQuad.material = this.separableBlurMaterial1;\n\t\t\t\tthis.separableBlurMaterial1.uniforms[ \"colorTexture\" ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\t\tthis.separableBlurMaterial1.uniforms[ \"direction\" ].value = THREE.OutlinePass.BlurDirectionX;\n\t\t\t\tthis.separableBlurMaterial1.uniforms[ \"kernelRadius\" ].value = this.edgeThickness;\n\t\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer1 );\n\t\t\t\trenderer.clear();\n\t\t\t\tthis.fsQuad.render( renderer );\n\t\t\t\tthis.separableBlurMaterial1.uniforms[ \"colorTexture\" ].value = this.renderTargetBlurBuffer1.texture;\n\t\t\t\tthis.separableBlurMaterial1.uniforms[ \"direction\" ].value = THREE.OutlinePass.BlurDirectionY;\n\t\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\t\trenderer.clear();\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t\t// Apply Blur on quarter res\n\t\t\t\tthis.fsQuad.material = this.separableBlurMaterial2;\n\t\t\t\tthis.separableBlurMaterial2.uniforms[ \"colorTexture\" ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\t\tthis.separableBlurMaterial2.uniforms[ \"direction\" ].value = THREE.OutlinePass.BlurDirectionX;\n\t\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer2 );\n\t\t\t\trenderer.clear();\n\t\t\t\tthis.fsQuad.render( renderer );\n\t\t\t\tthis.separableBlurMaterial2.uniforms[ \"colorTexture\" ].value = this.renderTargetBlurBuffer2.texture;\n\t\t\t\tthis.separableBlurMaterial2.uniforms[ \"direction\" ].value = THREE.OutlinePass.BlurDirectionY;\n\t\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer2 );\n\t\t\t\trenderer.clear();\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t\t// Blend it additively over the input texture\n\t\t\t\tthis.fsQuad.material = this.overlayMaterial;\n\t\t\t\tthis.overlayMaterial.uniforms[ \"maskTexture\" ].value = this.renderTargetMaskBuffer.texture;\n\t\t\t\tthis.overlayMaterial.uniforms[ \"edgeTexture1\" ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\t\tthis.overlayMaterial.uniforms[ \"edgeTexture2\" ].value = this.renderTargetEdgeBuffer2.texture;\n\t\t\t\tthis.overlayMaterial.uniforms[ \"patternTexture\" ].value = this.patternTexture;\n\t\t\t\tthis.overlayMaterial.uniforms[ \"edgeStrength\" ].value = this.edgeStrength;\n\t\t\t\tthis.overlayMaterial.uniforms[ \"edgeGlow\" ].value = this.edgeGlow;\n\t\t\t\tthis.overlayMaterial.uniforms[ \"usePatternTexture\" ].value = this.usePatternTexture;\n\n\n\t\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t\trenderer.setClearColor( this.oldClearColor, this.oldClearAlpha );\n\t\t\t\trenderer.autoClear = oldAutoClear;\n\n\t\t\t}\n\n\t\t\tif ( this.renderToScreen ) {\n\n\t\t\t\tthis.fsQuad.material = this.materialCopy;\n\t\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = readBuffer.texture;\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetPrepareMaskMaterial: function () {\n\n\t\t\treturn new THREE.ShaderMaterial( {\n\n\t\t\t\tuniforms: {\n\t\t\t\t\t\"depthTexture\": { value: null },\n\t\t\t\t\t\"cameraNearFar\": { value: new THREE.Vector2( 0.5, 0.5 ) },\n\t\t\t\t\t\"textureMatrix\": { value: null }\n\t\t\t\t},\n\n\t\t\t\tvertexShader: [\n\t\t\t\t\t'#include <morphtarget_pars_vertex>',\n\t\t\t\t\t'#include <skinning_pars_vertex>',\n\n\t\t\t\t\t'varying vec4 projTexCoord;',\n\t\t\t\t\t'varying vec4 vPosition;',\n\t\t\t\t\t'uniform mat4 textureMatrix;',\n\n\t\t\t\t\t'void main() {',\n\n\t\t\t\t\t'\t#include <skinbase_vertex>',\n\t\t\t\t\t'\t#include <begin_vertex>',\n\t\t\t\t\t'\t#include <morphtarget_vertex>',\n\t\t\t\t\t'\t#include <skinning_vertex>',\n\t\t\t\t\t'\t#include <project_vertex>',\n\n\t\t\t\t\t'\tvPosition = mvPosition;',\n\t\t\t\t\t'\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\n\t\t\t\t\t'\tprojTexCoord = textureMatrix * worldPosition;',\n\n\t\t\t\t\t'}'\n\t\t\t\t].join( '\\n' ),\n\n\t\t\t\tfragmentShader: [\n\t\t\t\t\t'#include <packing>',\n\t\t\t\t\t'varying vec4 vPosition;',\n\t\t\t\t\t'varying vec4 projTexCoord;',\n\t\t\t\t\t'uniform sampler2D depthTexture;',\n\t\t\t\t\t'uniform vec2 cameraNearFar;',\n\n\t\t\t\t\t'void main() {',\n\n\t\t\t\t\t'\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));',\n\t\t\t\t\t'\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );',\n\t\t\t\t\t'\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;',\n\t\t\t\t\t'\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);',\n\n\t\t\t\t\t'}'\n\t\t\t\t].join( '\\n' )\n\n\t\t\t} );\n\n\t\t},\n\n\t\tgetEdgeDetectionMaterial: function () {\n\n\t\t\treturn new THREE.ShaderMaterial( {\n\n\t\t\t\tuniforms: {\n\t\t\t\t\t\"maskTexture\": { value: null },\n\t\t\t\t\t\"texSize\": { value: new THREE.Vector2( 0.5, 0.5 ) },\n\t\t\t\t\t\"visibleEdgeColor\": { value: new THREE.Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t\t\t\"hiddenEdgeColor\": { value: new THREE.Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t\t},\n\n\t\t\t\tvertexShader:\n\t\t\t\t\t\"varying vec2 vUv;\\n\\\n\t\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t\t}\",\n\n\t\t\t\tfragmentShader:\n\t\t\t\t\t\"varying vec2 vUv;\\\n\t\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\t\tuniform vec3 visibleEdgeColor;\\\n\t\t\t\t\tuniform vec3 hiddenEdgeColor;\\\n\t\t\t\t\t\\\n\t\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\\n\t\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\\n\t\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\\n\t\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\\n\t\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\\n\t\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\\\n\t\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\\\n\t\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\\\n\t\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\\\n\t\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\\\n\t\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\\\n\t\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\\n\t\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\\n\t\t\t\t\t}\"\n\t\t\t} );\n\n\t\t},\n\n\t\tgetSeperableBlurMaterial: function ( maxRadius ) {\n\n\t\t\treturn new THREE.ShaderMaterial( {\n\n\t\t\t\tdefines: {\n\t\t\t\t\t\"MAX_RADIUS\": maxRadius,\n\t\t\t\t},\n\n\t\t\t\tuniforms: {\n\t\t\t\t\t\"colorTexture\": { value: null },\n\t\t\t\t\t\"texSize\": { value: new THREE.Vector2( 0.5, 0.5 ) },\n\t\t\t\t\t\"direction\": { value: new THREE.Vector2( 0.5, 0.5 ) },\n\t\t\t\t\t\"kernelRadius\": { value: 1.0 }\n\t\t\t\t},\n\n\t\t\t\tvertexShader:\n\t\t\t\t\t\"varying vec2 vUv;\\n\\\n\t\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t\t}\",\n\n\t\t\t\tfragmentShader:\n\t\t\t\t\t\"#include <common>\\\n\t\t\t\t\tvarying vec2 vUv;\\\n\t\t\t\t\tuniform sampler2D colorTexture;\\\n\t\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\t\tuniform vec2 direction;\\\n\t\t\t\t\tuniform float kernelRadius;\\\n\t\t\t\t\t\\\n\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tvoid main() {\\\n\t\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\\n\t\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\\\n\t\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\\n\t\t\t\t\t\tvec2 uvOffset = delta;\\\n\t\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\\n\t\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\\n\t\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\\\n\t\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\\\n\t\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\\\n\t\t\t\t\t\t\tweightSum += (2.0 * w);\\\n\t\t\t\t\t\t\tuvOffset += delta;\\\n\t\t\t\t\t\t}\\\n\t\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\\\n\t\t\t\t\t}\"\n\t\t\t} );\n\n\t\t},\n\n\t\tgetOverlayMaterial: function () {\n\n\t\t\treturn new THREE.ShaderMaterial( {\n\n\t\t\t\tuniforms: {\n\t\t\t\t\t\"maskTexture\": { value: null },\n\t\t\t\t\t\"edgeTexture1\": { value: null },\n\t\t\t\t\t\"edgeTexture2\": { value: null },\n\t\t\t\t\t\"patternTexture\": { value: null },\n\t\t\t\t\t\"edgeStrength\": { value: 1.0 },\n\t\t\t\t\t\"edgeGlow\": { value: 1.0 },\n\t\t\t\t\t\"usePatternTexture\": { value: 0.0 }\n\t\t\t\t},\n\n\t\t\t\tvertexShader:\n\t\t\t\t\t\"varying vec2 vUv;\\n\\\n\t\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t\t}\",\n\n\t\t\t\tfragmentShader:\n\t\t\t\t\t\"varying vec2 vUv;\\\n\t\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\t\tuniform sampler2D edgeTexture1;\\\n\t\t\t\t\tuniform sampler2D edgeTexture2;\\\n\t\t\t\t\tuniform sampler2D patternTexture;\\\n\t\t\t\t\tuniform float edgeStrength;\\\n\t\t\t\t\tuniform float edgeGlow;\\\n\t\t\t\t\tuniform bool usePatternTexture;\\\n\t\t\t\t\t\\\n\t\t\t\t\tvoid main() {\\\n\t\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\\n\t\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\\n\t\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\\\n\t\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\\n\t\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\\n\t\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\\n\t\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\\n\t\t\t\t\t\tif(usePatternTexture)\\\n\t\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\\n\t\t\t\t\t\tgl_FragColor = finalColor;\\\n\t\t\t\t\t}\",\n\t\t\t\tblending: THREE.AdditiveBlending,\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\ttransparent: true\n\t\t\t} );\n\n\t\t}\n\n\t} );\n\n\tTHREE.OutlinePass.BlurDirectionX = new THREE.Vector2( 1.0, 0.0 );\n\tTHREE.OutlinePass.BlurDirectionY = new THREE.Vector2( 0.0, 1.0 );\n\t\n\treturn THREE.OutlinePass;\n});\n"]}