{"version":3,"sources":["postprocessing/OutlinePass.js"],"names":["define","THREE","threex","Pass","CopyShader","OutlinePass","resolution","scene","camera","selectedObjects","this","renderScene","renderCamera","undefined","visibleEdgeColor","Color","hiddenEdgeColor","edgeGlow","usePatternTexture","edgeThickness","edgeStrength","downSampleRatio","pulsePeriod","call","Vector2","x","y","pars","minFilter","LinearFilter","magFilter","format","RGBAFormat","resx","Math","round","resy","maskBufferMaterial","MeshBasicMaterial","color","side","DoubleSide","renderTargetMaskBuffer","WebGLRenderTarget","texture","name","generateMipmaps","depthMaterial","MeshDepthMaterial","depthPacking","RGBADepthPacking","blending","NoBlending","prepareMaskMaterial","getPrepareMaskMaterial","fragmentShader","string","type","isPerspectiveCamera","replace","replaceDepthToViewZ","renderTargetDepthBuffer","renderTargetMaskDownSampleBuffer","renderTargetBlurBuffer1","renderTargetBlurBuffer2","edgeDetectionMaterial","getEdgeDetectionMaterial","renderTargetEdgeBuffer1","renderTargetEdgeBuffer2","separableBlurMaterial1","getSeperableBlurMaterial","uniforms","value","set","separableBlurMaterial2","overlayMaterial","getOverlayMaterial","console","error","copyShader","copyUniforms","UniformsUtils","clone","materialCopy","ShaderMaterial","vertexShader","depthTest","depthWrite","transparent","enabled","needsSwap","oldClearColor","oldClearAlpha","fsQuad","FullScreenQuad","tempPulseColor1","tempPulseColor2","textureMatrix","Matrix4","prototype","Object","assign","create","constructor","dispose","setSize","width","height","changeVisibilityOfSelectedObjects","bVisible","gatherSelectedMeshesCallBack","object","isMesh","visible","userData","oldVisible","i","length","traverse","changeVisibilityOfNonSelectedObjects","selectedMeshes","push","isLine","isSprite","bFound","id","visibility","updateTextureMatrix","multiply","projectionMatrix","matrixWorldInverse","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","copy","getClearColor","getClearAlpha","oldAutoClear","autoClear","state","buffers","stencil","setTest","setClearColor","currentBackground","background","overrideMaterial","setRenderTarget","clear","near","far","material","scalar","cos","performance","now","multiplyScalar","BlurDirectionX","BlurDirectionY","patternTexture","renderToScreen","depthTexture","cameraNearFar","join","maskTexture","texSize","Vector3","maxRadius","defines","MAX_RADIUS","colorTexture","direction","kernelRadius","edgeTexture1","edgeTexture2","AdditiveBlending","postprocessing"],"mappings":";;;;;;;AAAAA,QACI,kBACA,YACA,SACA,yBACD,SACCC,EACAC,EACAC,EACAC,GAEA,aACA,IAAIC,EAAc,SAAUC,EAAYC,EAAOC,EAAQC,GACnDC,KAAKC,YAAcJ,EACnBG,KAAKE,aAAeJ,EACpBE,KAAKD,qBAAsCI,IAApBJ,EAAgCA,KACvDC,KAAKI,iBAAmB,IAAIb,EAAMc,MAAM,EAAG,EAAG,GAC9CL,KAAKM,gBAAkB,IAAIf,EAAMc,MAAM,GAAK,IAAM,KAClDL,KAAKO,SAAW,EAChBP,KAAKQ,mBAAoB,EACzBR,KAAKS,cAAgB,EACrBT,KAAKU,aAAe,EACpBV,KAAKW,gBAAkB,EACvBX,KAAKY,YAAc,EACnBnB,EAAKoB,KAAKb,MACVA,KAAKJ,gBAA4BO,IAAfP,EAA2B,IAAIL,EAAMuB,QAAQlB,EAAWmB,EAAGnB,EAAWoB,GAAK,IAAIzB,EAAMuB,QAAQ,IAAK,KACpH,IAAIG,GACAC,UAAW3B,EAAM4B,aACjBC,UAAW7B,EAAM4B,aACjBE,OAAQ9B,EAAM+B,YAEdC,EAAOC,KAAKC,MAAMzB,KAAKJ,WAAWmB,EAAIf,KAAKW,iBAC3Ce,EAAOF,KAAKC,MAAMzB,KAAKJ,WAAWoB,EAAIhB,KAAKW,iBAC/CX,KAAK2B,mBAAqB,IAAIpC,EAAMqC,mBAAoBC,MAAO,WAC/D7B,KAAK2B,mBAAmBG,KAAOvC,EAAMwC,WACrC/B,KAAKgC,uBAAyB,IAAIzC,EAAM0C,kBAAkBjC,KAAKJ,WAAWmB,EAAGf,KAAKJ,WAAWoB,EAAGC,GAChGjB,KAAKgC,uBAAuBE,QAAQC,KAAO,mBAC3CnC,KAAKgC,uBAAuBE,QAAQE,iBAAkB,EACtDpC,KAAKqC,cAAgB,IAAI9C,EAAM+C,kBAC/BtC,KAAKqC,cAAcP,KAAOvC,EAAMwC,WAChC/B,KAAKqC,cAAcE,aAAehD,EAAMiD,iBACxCxC,KAAKqC,cAAcI,SAAWlD,EAAMmD,WACpC1C,KAAK2C,oBAAsB3C,KAAK4C,yBAChC5C,KAAK2C,oBAAoBb,KAAOvC,EAAMwC,WACtC/B,KAAK2C,oBAAoBE,eAmDzB,SAA6BC,EAAQhD,GACjC,IAAIiD,EAAOjD,EAAOkD,oBAAsB,cAAgB,eACxD,OAAOF,EAAOG,QAAQ,mBAAoBF,EAAO,gBArDXG,CAAoBlD,KAAK2C,oBAAoBE,eAAgB7C,KAAKE,cAC5GF,KAAKmD,wBAA0B,IAAI5D,EAAM0C,kBAAkBjC,KAAKJ,WAAWmB,EAAGf,KAAKJ,WAAWoB,EAAGC,GACjGjB,KAAKmD,wBAAwBjB,QAAQC,KAAO,oBAC5CnC,KAAKmD,wBAAwBjB,QAAQE,iBAAkB,EACvDpC,KAAKoD,iCAAmC,IAAI7D,EAAM0C,kBAAkBV,EAAMG,EAAMT,GAChFjB,KAAKoD,iCAAiClB,QAAQC,KAAO,8BACrDnC,KAAKoD,iCAAiClB,QAAQE,iBAAkB,EAChEpC,KAAKqD,wBAA0B,IAAI9D,EAAM0C,kBAAkBV,EAAMG,EAAMT,GACvEjB,KAAKqD,wBAAwBnB,QAAQC,KAAO,oBAC5CnC,KAAKqD,wBAAwBnB,QAAQE,iBAAkB,EACvDpC,KAAKsD,wBAA0B,IAAI/D,EAAM0C,kBAAkBT,KAAKC,MAAMF,EAAO,GAAIC,KAAKC,MAAMC,EAAO,GAAIT,GACvGjB,KAAKsD,wBAAwBpB,QAAQC,KAAO,oBAC5CnC,KAAKsD,wBAAwBpB,QAAQE,iBAAkB,EACvDpC,KAAKuD,sBAAwBvD,KAAKwD,2BAClCxD,KAAKyD,wBAA0B,IAAIlE,EAAM0C,kBAAkBV,EAAMG,EAAMT,GACvEjB,KAAKyD,wBAAwBvB,QAAQC,KAAO,oBAC5CnC,KAAKyD,wBAAwBvB,QAAQE,iBAAkB,EACvDpC,KAAK0D,wBAA0B,IAAInE,EAAM0C,kBAAkBT,KAAKC,MAAMF,EAAO,GAAIC,KAAKC,MAAMC,EAAO,GAAIT,GACvGjB,KAAK0D,wBAAwBxB,QAAQC,KAAO,oBAC5CnC,KAAK0D,wBAAwBxB,QAAQE,iBAAkB,EAGvDpC,KAAK2D,uBAAyB3D,KAAK4D,yBAFV,GAGzB5D,KAAK2D,uBAAuBE,SAAkB,QAAEC,MAAMC,IAAIxC,EAAMG,GAChE1B,KAAK2D,uBAAuBE,SAAuB,aAAEC,MAAQ,EAC7D9D,KAAKgE,uBAAyBhE,KAAK4D,yBAJf,GAKpB5D,KAAKgE,uBAAuBH,SAAkB,QAAEC,MAAMC,IAAIvC,KAAKC,MAAMF,EAAO,GAAIC,KAAKC,MAAMC,EAAO,IAClG1B,KAAKgE,uBAAuBH,SAAuB,aAAEC,MANjC,EAOpB9D,KAAKiE,gBAAkBjE,KAAKkE,0BACT/D,IAAfT,GACAyE,QAAQC,MAAM,oCAClB,IAAIC,EAAa3E,EACjBM,KAAKsE,aAAe/E,EAAMgF,cAAcC,MAAMH,EAAWR,UACzD7D,KAAKsE,aAAsB,QAAER,MAAQ,EACrC9D,KAAKyE,aAAe,IAAIlF,EAAMmF,gBAC1Bb,SAAU7D,KAAKsE,aACfK,aAAcN,EAAWM,aACzB9B,eAAgBwB,EAAWxB,eAC3BJ,SAAUlD,EAAMmD,WAChBkC,WAAW,EACXC,YAAY,EACZC,aAAa,IAEjB9E,KAAK+E,SAAU,EACf/E,KAAKgF,WAAY,EACjBhF,KAAKiF,cAAgB,IAAI1F,EAAMc,MAC/BL,KAAKkF,cAAgB,EACrBlF,KAAKmF,OAAS,IAAI1F,EAAK2F,eAAe,MACtCpF,KAAKqF,gBAAkB,IAAI9F,EAAMc,MACjCL,KAAKsF,gBAAkB,IAAI/F,EAAMc,MACjCL,KAAKuF,cAAgB,IAAIhG,EAAMiG,SAwQnC,OAlQA7F,EAAY8F,UAAYC,OAAOC,OAAOD,OAAOE,OAAOnG,EAAKgG,YACrDI,YAAalG,EACbmG,QAAS,WACL9F,KAAKgC,uBAAuB8D,UAC5B9F,KAAKmD,wBAAwB2C,UAC7B9F,KAAKoD,iCAAiC0C,UACtC9F,KAAKqD,wBAAwByC,UAC7B9F,KAAKsD,wBAAwBwC,UAC7B9F,KAAKyD,wBAAwBqC,UAC7B9F,KAAK0D,wBAAwBoC,WAEjCC,QAAS,SAAUC,EAAOC,GACtBjG,KAAKgC,uBAAuB+D,QAAQC,EAAOC,GAC3C,IAAI1E,EAAOC,KAAKC,MAAMuE,EAAQhG,KAAKW,iBAC/Be,EAAOF,KAAKC,MAAMwE,EAASjG,KAAKW,iBACpCX,KAAKoD,iCAAiC2C,QAAQxE,EAAMG,GACpD1B,KAAKqD,wBAAwB0C,QAAQxE,EAAMG,GAC3C1B,KAAKyD,wBAAwBsC,QAAQxE,EAAMG,GAC3C1B,KAAK2D,uBAAuBE,SAAkB,QAAEC,MAAMC,IAAIxC,EAAMG,GAChEH,EAAOC,KAAKC,MAAMF,EAAO,GACzBG,EAAOF,KAAKC,MAAMC,EAAO,GACzB1B,KAAKsD,wBAAwByC,QAAQxE,EAAMG,GAC3C1B,KAAK0D,wBAAwBqC,QAAQxE,EAAMG,GAC3C1B,KAAKgE,uBAAuBH,SAAkB,QAAEC,MAAMC,IAAIxC,EAAMG,IAEpEwE,kCAAmC,SAAUC,GACzC,SAASC,EAA6BC,GAC9BA,EAAOC,SACHH,GACAE,EAAOE,QAAUF,EAAOG,SAASC,kBAC1BJ,EAAOG,SAASC,aAEvBJ,EAAOG,SAASC,WAAaJ,EAAOE,QACpCF,EAAOE,QAAUJ,IAI7B,IAAK,IAAIO,EAAI,EAAGA,EAAI1G,KAAKD,gBAAgB4G,OAAQD,IAAK,CAC7B1G,KAAKD,gBAAgB2G,GAC3BE,SAASR,KAGhCS,qCAAsC,SAAUV,GAC5C,IAAIW,KACJ,SAASV,EAA6BC,GAC9BA,EAAOC,QACPQ,EAAeC,KAAKV,GAE5B,IAAK,IAAIK,EAAI,EAAGA,EAAI1G,KAAKD,gBAAgB4G,OAAQD,IAAK,CAC7B1G,KAAKD,gBAAgB2G,GAC3BE,SAASR,GAoB5BpG,KAAKC,YAAY2G,SAlBjB,SAAkCP,GAC9B,GAAIA,EAAOC,QAAUD,EAAOW,QAAUX,EAAOY,SAAU,CAEnD,IADA,IAAIC,GAAS,EACJR,EAAI,EAAGA,EAAII,EAAeH,OAAQD,IAEvC,GADuBI,EAAeJ,GAAGS,KAChBd,EAAOc,GAAI,CAChCD,GAAS,EACT,MAGR,IAAKA,EAAQ,CACT,IAAIE,EAAaf,EAAOE,QACnBJ,IAAYE,EAAOF,WACpBE,EAAOE,QAAUJ,GACrBE,EAAOF,SAAWiB,OAMlCC,oBAAqB,WACjBrH,KAAKuF,cAAcxB,IAAI,GAAK,EAAG,EAAG,GAAK,EAAG,GAAK,EAAG,GAAK,EAAG,EAAG,GAAK,GAAK,EAAG,EAAG,EAAG,GAChF/D,KAAKuF,cAAc+B,SAAStH,KAAKE,aAAaqH,kBAC9CvH,KAAKuF,cAAc+B,SAAStH,KAAKE,aAAasH,qBAElDC,OAAQ,SAAUC,EAAUC,EAAaC,EAAYC,EAAWC,GAC5D,GAAI9H,KAAKD,gBAAgB4G,OAAS,EAAG,CACjC3G,KAAKiF,cAAc8C,KAAKL,EAASM,iBACjChI,KAAKkF,cAAgBwC,EAASO,gBAC9B,IAAIC,EAAeR,EAASS,UAC5BT,EAASS,WAAY,EACjBL,GACAJ,EAASU,MAAMC,QAAQC,QAAQC,SAAQ,GAC3Cb,EAASc,cAAc,SAAU,GACjCxI,KAAKkG,mCAAkC,GACvC,IAAIuC,EAAoBzI,KAAKC,YAAYyI,WA0BzC,GAzBA1I,KAAKC,YAAYyI,WAAa,KAC9B1I,KAAKC,YAAY0I,iBAAmB3I,KAAKqC,cACzCqF,EAASkB,gBAAgB5I,KAAKmD,yBAC9BuE,EAASmB,QACTnB,EAASD,OAAOzH,KAAKC,YAAaD,KAAKE,cACvCF,KAAKkG,mCAAkC,GACvClG,KAAKqH,sBACLrH,KAAK6G,sCAAqC,GAC1C7G,KAAKC,YAAY0I,iBAAmB3I,KAAK2C,oBACzC3C,KAAK2C,oBAAoBkB,SAAwB,cAAEC,MAAMC,IAAI/D,KAAKE,aAAa4I,KAAM9I,KAAKE,aAAa6I,KACvG/I,KAAK2C,oBAAoBkB,SAAuB,aAAEC,MAAQ9D,KAAKmD,wBAAwBjB,QACvFlC,KAAK2C,oBAAoBkB,SAAwB,cAAEC,MAAQ9D,KAAKuF,cAChEmC,EAASkB,gBAAgB5I,KAAKgC,wBAC9B0F,EAASmB,QACTnB,EAASD,OAAOzH,KAAKC,YAAaD,KAAKE,cACvCF,KAAKC,YAAY0I,iBAAmB,KACpC3I,KAAK6G,sCAAqC,GAC1C7G,KAAKC,YAAYyI,WAAaD,EAC9BzI,KAAKmF,OAAO6D,SAAWhJ,KAAKyE,aAC5BzE,KAAKsE,aAAuB,SAAER,MAAQ9D,KAAKgC,uBAAuBE,QAClEwF,EAASkB,gBAAgB5I,KAAKoD,kCAC9BsE,EAASmB,QACT7I,KAAKmF,OAAOsC,OAAOC,GACnB1H,KAAKqF,gBAAgB0C,KAAK/H,KAAKI,kBAC/BJ,KAAKsF,gBAAgByC,KAAK/H,KAAKM,iBAC3BN,KAAKY,YAAc,EAAG,CACtB,IAAIqI,EAAS,KAAyE,IAAxDzH,KAAK0H,IAAwB,IAApBC,YAAYC,MAAepJ,KAAKY,aAA4B,EACnGZ,KAAKqF,gBAAgBgE,eAAeJ,GACpCjJ,KAAKsF,gBAAgB+D,eAAeJ,GAExCjJ,KAAKmF,OAAO6D,SAAWhJ,KAAKuD,sBAC5BvD,KAAKuD,sBAAsBM,SAAsB,YAAEC,MAAQ9D,KAAKoD,iCAAiClB,QACjGlC,KAAKuD,sBAAsBM,SAAkB,QAAEC,MAAMC,IAAI/D,KAAKoD,iCAAiC4C,MAAOhG,KAAKoD,iCAAiC6C,QAC5IjG,KAAKuD,sBAAsBM,SAA2B,iBAAEC,MAAQ9D,KAAKqF,gBACrErF,KAAKuD,sBAAsBM,SAA0B,gBAAEC,MAAQ9D,KAAKsF,gBACpEoC,EAASkB,gBAAgB5I,KAAKyD,yBAC9BiE,EAASmB,QACT7I,KAAKmF,OAAOsC,OAAOC,GACnB1H,KAAKmF,OAAO6D,SAAWhJ,KAAK2D,uBAC5B3D,KAAK2D,uBAAuBE,SAAuB,aAAEC,MAAQ9D,KAAKyD,wBAAwBvB,QAC1FlC,KAAK2D,uBAAuBE,SAAoB,UAAEC,MAAQnE,EAAY2J,eACtEtJ,KAAK2D,uBAAuBE,SAAuB,aAAEC,MAAQ9D,KAAKS,cAClEiH,EAASkB,gBAAgB5I,KAAKqD,yBAC9BqE,EAASmB,QACT7I,KAAKmF,OAAOsC,OAAOC,GACnB1H,KAAK2D,uBAAuBE,SAAuB,aAAEC,MAAQ9D,KAAKqD,wBAAwBnB,QAC1FlC,KAAK2D,uBAAuBE,SAAoB,UAAEC,MAAQnE,EAAY4J,eACtE7B,EAASkB,gBAAgB5I,KAAKyD,yBAC9BiE,EAASmB,QACT7I,KAAKmF,OAAOsC,OAAOC,GACnB1H,KAAKmF,OAAO6D,SAAWhJ,KAAKgE,uBAC5BhE,KAAKgE,uBAAuBH,SAAuB,aAAEC,MAAQ9D,KAAKyD,wBAAwBvB,QAC1FlC,KAAKgE,uBAAuBH,SAAoB,UAAEC,MAAQnE,EAAY2J,eACtE5B,EAASkB,gBAAgB5I,KAAKsD,yBAC9BoE,EAASmB,QACT7I,KAAKmF,OAAOsC,OAAOC,GACnB1H,KAAKgE,uBAAuBH,SAAuB,aAAEC,MAAQ9D,KAAKsD,wBAAwBpB,QAC1FlC,KAAKgE,uBAAuBH,SAAoB,UAAEC,MAAQnE,EAAY4J,eACtE7B,EAASkB,gBAAgB5I,KAAK0D,yBAC9BgE,EAASmB,QACT7I,KAAKmF,OAAOsC,OAAOC,GACnB1H,KAAKmF,OAAO6D,SAAWhJ,KAAKiE,gBAC5BjE,KAAKiE,gBAAgBJ,SAAsB,YAAEC,MAAQ9D,KAAKgC,uBAAuBE,QACjFlC,KAAKiE,gBAAgBJ,SAAuB,aAAEC,MAAQ9D,KAAKyD,wBAAwBvB,QACnFlC,KAAKiE,gBAAgBJ,SAAuB,aAAEC,MAAQ9D,KAAK0D,wBAAwBxB,QACnFlC,KAAKiE,gBAAgBJ,SAAyB,eAAEC,MAAQ9D,KAAKwJ,eAC7DxJ,KAAKiE,gBAAgBJ,SAAuB,aAAEC,MAAQ9D,KAAKU,aAC3DV,KAAKiE,gBAAgBJ,SAAmB,SAAEC,MAAQ9D,KAAKO,SACvDP,KAAKiE,gBAAgBJ,SAA4B,kBAAEC,MAAQ9D,KAAKQ,kBAC5DsH,GACAJ,EAASU,MAAMC,QAAQC,QAAQC,SAAQ,GAC3Cb,EAASkB,gBAAgBhB,GACzB5H,KAAKmF,OAAOsC,OAAOC,GACnBA,EAASc,cAAcxI,KAAKiF,cAAejF,KAAKkF,eAChDwC,EAASS,UAAYD,EAErBlI,KAAKyJ,iBACLzJ,KAAKmF,OAAO6D,SAAWhJ,KAAKyE,aAC5BzE,KAAKsE,aAAuB,SAAER,MAAQ8D,EAAW1F,QACjDwF,EAASkB,gBAAgB,MACzB5I,KAAKmF,OAAOsC,OAAOC,KAG3B9E,uBAAwB,WACpB,OAAO,IAAIrD,EAAMmF,gBACbb,UACI6F,cAAkB5F,MAAO,MACzB6F,eAAmB7F,MAAO,IAAIvE,EAAMuB,QAAQ,GAAK,KACjDyE,eAAmBzB,MAAO,OAE9Ba,cACI,qCACA,kCACA,6BACA,0BACA,8BACA,gBACA,+BACA,4BACA,kCACA,+BACA,8BACA,4BACA,8DACA,kDACA,KACFiF,KAAK,MACP/G,gBACI,qBACA,0BACA,6BACA,kCACA,8BACA,gBACA,kFACA,gFACA,0DACA,mDACA,KACF+G,KAAK,SAGfpG,yBAA0B,WACtB,OAAO,IAAIjE,EAAMmF,gBACbb,UACIgG,aAAiB/F,MAAO,MACxBgG,SAAahG,MAAO,IAAIvE,EAAMuB,QAAQ,GAAK,KAC3CV,kBAAsB0D,MAAO,IAAIvE,EAAMwK,QAAQ,EAAG,EAAG,IACrDzJ,iBAAqBwD,MAAO,IAAIvE,EAAMwK,QAAQ,EAAG,EAAG,KAExDpF,aAAc,gKACd9B,eAAgB,i9BAGxBe,yBAA0B,SAAUoG,GAChC,OAAO,IAAIzK,EAAMmF,gBACbuF,SAAWC,WAAcF,GACzBnG,UACIsG,cAAkBrG,MAAO,MACzBgG,SAAahG,MAAO,IAAIvE,EAAMuB,QAAQ,GAAK,KAC3CsJ,WAAetG,MAAO,IAAIvE,EAAMuB,QAAQ,GAAK,KAC7CuJ,cAAkBvG,MAAO,IAE7Ba,aAAc,gKACd9B,eAAgB,0hCAGxBqB,mBAAoB,WAChB,OAAO,IAAI3E,EAAMmF,gBACbb,UACIgG,aAAiB/F,MAAO,MACxBwG,cAAkBxG,MAAO,MACzByG,cAAkBzG,MAAO,MACzB0F,gBAAoB1F,MAAO,MAC3BpD,cAAkBoD,MAAO,GACzBvD,UAAcuD,MAAO,GACrBtD,mBAAuBsD,MAAO,IAElCa,aAAc,gKACd9B,eAAgB,m5BAChBJ,SAAUlD,EAAMiL,iBAChB5F,WAAW,EACXC,YAAY,EACZC,aAAa,OAIzBnF,EAAY2J,eAAiB,IAAI/J,EAAMuB,QAAQ,EAAG,GAClDnB,EAAY4J,eAAiB,IAAIhK,EAAMuB,QAAQ,EAAG,GAE3CtB,EAAOiL,eAAe9K,YAAcA","file":"../../postprocessing/OutlinePass.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\",\n    './Pass',\n    '../shaders/CopyShader'\n], function (\n    THREE,\n    threex, \n    Pass, \n    CopyShader\n) {\n    'use strict';\n    var OutlinePass = function (resolution, scene, camera, selectedObjects) {\n        this.renderScene = scene;\n        this.renderCamera = camera;\n        this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n        this.visibleEdgeColor = new THREE.Color(1, 1, 1);\n        this.hiddenEdgeColor = new THREE.Color(0.1, 0.04, 0.02);\n        this.edgeGlow = 0;\n        this.usePatternTexture = false;\n        this.edgeThickness = 1;\n        this.edgeStrength = 3;\n        this.downSampleRatio = 2;\n        this.pulsePeriod = 0;\n        Pass.call(this);\n        this.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);\n        var pars = {\n            minFilter: THREE.LinearFilter,\n            magFilter: THREE.LinearFilter,\n            format: THREE.RGBAFormat\n        };\n        var resx = Math.round(this.resolution.x / this.downSampleRatio);\n        var resy = Math.round(this.resolution.y / this.downSampleRatio);\n        this.maskBufferMaterial = new THREE.MeshBasicMaterial({ color: 16777215 });\n        this.maskBufferMaterial.side = THREE.DoubleSide;\n        this.renderTargetMaskBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n        this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n        this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n        this.depthMaterial = new THREE.MeshDepthMaterial();\n        this.depthMaterial.side = THREE.DoubleSide;\n        this.depthMaterial.depthPacking = THREE.RGBADepthPacking;\n        this.depthMaterial.blending = THREE.NoBlending;\n        this.prepareMaskMaterial = this.getPrepareMaskMaterial();\n        this.prepareMaskMaterial.side = THREE.DoubleSide;\n        this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\n        this.renderTargetDepthBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n        this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n        this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n        this.renderTargetMaskDownSampleBuffer = new THREE.WebGLRenderTarget(resx, resy, pars);\n        this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n        this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n        this.renderTargetBlurBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars);\n        this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n        this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n        this.renderTargetBlurBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n        this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n        this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n        this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n        this.renderTargetEdgeBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars);\n        this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n        this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n        this.renderTargetEdgeBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n        this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n        this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n        var MAX_EDGE_THICKNESS = 4;\n        var MAX_EDGE_GLOW = 4;\n        this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n        this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n        this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;\n        this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n        this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));\n        this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW;\n        this.overlayMaterial = this.getOverlayMaterial();\n        if (CopyShader === undefined)\n            console.error('OutlinePass relies on CopyShader');\n        var copyShader = CopyShader;\n        this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n        this.copyUniforms['opacity'].value = 1;\n        this.materialCopy = new THREE.ShaderMaterial({\n            uniforms: this.copyUniforms,\n            vertexShader: copyShader.vertexShader,\n            fragmentShader: copyShader.fragmentShader,\n            blending: THREE.NoBlending,\n            depthTest: false,\n            depthWrite: false,\n            transparent: true\n        });\n        this.enabled = true;\n        this.needsSwap = false;\n        this.oldClearColor = new THREE.Color();\n        this.oldClearAlpha = 1;\n        this.fsQuad = new Pass.FullScreenQuad(null);\n        this.tempPulseColor1 = new THREE.Color();\n        this.tempPulseColor2 = new THREE.Color();\n        this.textureMatrix = new THREE.Matrix4();\n        function replaceDepthToViewZ(string, camera) {\n            var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n            return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\n        }\n    };\n    OutlinePass.prototype = Object.assign(Object.create(Pass.prototype), {\n        constructor: OutlinePass,\n        dispose: function () {\n            this.renderTargetMaskBuffer.dispose();\n            this.renderTargetDepthBuffer.dispose();\n            this.renderTargetMaskDownSampleBuffer.dispose();\n            this.renderTargetBlurBuffer1.dispose();\n            this.renderTargetBlurBuffer2.dispose();\n            this.renderTargetEdgeBuffer1.dispose();\n            this.renderTargetEdgeBuffer2.dispose();\n        },\n        setSize: function (width, height) {\n            this.renderTargetMaskBuffer.setSize(width, height);\n            var resx = Math.round(width / this.downSampleRatio);\n            var resy = Math.round(height / this.downSampleRatio);\n            this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n            this.renderTargetBlurBuffer1.setSize(resx, resy);\n            this.renderTargetEdgeBuffer1.setSize(resx, resy);\n            this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n            this.renderTargetBlurBuffer2.setSize(resx, resy);\n            this.renderTargetEdgeBuffer2.setSize(resx, resy);\n            this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);\n        },\n        changeVisibilityOfSelectedObjects: function (bVisible) {\n            function gatherSelectedMeshesCallBack(object) {\n                if (object.isMesh) {\n                    if (bVisible) {\n                        object.visible = object.userData.oldVisible;\n                        delete object.userData.oldVisible;\n                    } else {\n                        object.userData.oldVisible = object.visible;\n                        object.visible = bVisible;\n                    }\n                }\n            }\n            for (var i = 0; i < this.selectedObjects.length; i++) {\n                var selectedObject = this.selectedObjects[i];\n                selectedObject.traverse(gatherSelectedMeshesCallBack);\n            }\n        },\n        changeVisibilityOfNonSelectedObjects: function (bVisible) {\n            var selectedMeshes = [];\n            function gatherSelectedMeshesCallBack(object) {\n                if (object.isMesh)\n                    selectedMeshes.push(object);\n            }\n            for (var i = 0; i < this.selectedObjects.length; i++) {\n                var selectedObject = this.selectedObjects[i];\n                selectedObject.traverse(gatherSelectedMeshesCallBack);\n            }\n            function VisibilityChangeCallBack(object) {\n                if (object.isMesh || object.isLine || object.isSprite) {\n                    var bFound = false;\n                    for (var i = 0; i < selectedMeshes.length; i++) {\n                        var selectedObjectId = selectedMeshes[i].id;\n                        if (selectedObjectId === object.id) {\n                            bFound = true;\n                            break;\n                        }\n                    }\n                    if (!bFound) {\n                        var visibility = object.visible;\n                        if (!bVisible || object.bVisible)\n                            object.visible = bVisible;\n                        object.bVisible = visibility;\n                    }\n                }\n            }\n            this.renderScene.traverse(VisibilityChangeCallBack);\n        },\n        updateTextureMatrix: function () {\n            this.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n            this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n            this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n        },\n        render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n            if (this.selectedObjects.length > 0) {\n                this.oldClearColor.copy(renderer.getClearColor());\n                this.oldClearAlpha = renderer.getClearAlpha();\n                var oldAutoClear = renderer.autoClear;\n                renderer.autoClear = false;\n                if (maskActive)\n                    renderer.state.buffers.stencil.setTest(false);\n                renderer.setClearColor(16777215, 1);\n                this.changeVisibilityOfSelectedObjects(false);\n                var currentBackground = this.renderScene.background;\n                this.renderScene.background = null;\n                this.renderScene.overrideMaterial = this.depthMaterial;\n                renderer.setRenderTarget(this.renderTargetDepthBuffer);\n                renderer.clear();\n                renderer.render(this.renderScene, this.renderCamera);\n                this.changeVisibilityOfSelectedObjects(true);\n                this.updateTextureMatrix();\n                this.changeVisibilityOfNonSelectedObjects(false);\n                this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n                this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);\n                this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;\n                this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;\n                renderer.setRenderTarget(this.renderTargetMaskBuffer);\n                renderer.clear();\n                renderer.render(this.renderScene, this.renderCamera);\n                this.renderScene.overrideMaterial = null;\n                this.changeVisibilityOfNonSelectedObjects(true);\n                this.renderScene.background = currentBackground;\n                this.fsQuad.material = this.materialCopy;\n                this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;\n                renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n                renderer.clear();\n                this.fsQuad.render(renderer);\n                this.tempPulseColor1.copy(this.visibleEdgeColor);\n                this.tempPulseColor2.copy(this.hiddenEdgeColor);\n                if (this.pulsePeriod > 0) {\n                    var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1 - 0.25) / 2;\n                    this.tempPulseColor1.multiplyScalar(scalar);\n                    this.tempPulseColor2.multiplyScalar(scalar);\n                }\n                this.fsQuad.material = this.edgeDetectionMaterial;\n                this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;\n                this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n                this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1;\n                this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2;\n                renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n                renderer.clear();\n                this.fsQuad.render(renderer);\n                this.fsQuad.material = this.separableBlurMaterial1;\n                this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n                this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n                this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;\n                renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n                renderer.clear();\n                this.fsQuad.render(renderer);\n                this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;\n                this.separableBlurMaterial1.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n                renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n                renderer.clear();\n                this.fsQuad.render(renderer);\n                this.fsQuad.material = this.separableBlurMaterial2;\n                this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n                this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionX;\n                renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n                renderer.clear();\n                this.fsQuad.render(renderer);\n                this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;\n                this.separableBlurMaterial2.uniforms['direction'].value = OutlinePass.BlurDirectionY;\n                renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n                renderer.clear();\n                this.fsQuad.render(renderer);\n                this.fsQuad.material = this.overlayMaterial;\n                this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;\n                this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;\n                this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;\n                this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;\n                this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;\n                this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;\n                this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;\n                if (maskActive)\n                    renderer.state.buffers.stencil.setTest(true);\n                renderer.setRenderTarget(readBuffer);\n                this.fsQuad.render(renderer);\n                renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);\n                renderer.autoClear = oldAutoClear;\n            }\n            if (this.renderToScreen) {\n                this.fsQuad.material = this.materialCopy;\n                this.copyUniforms['tDiffuse'].value = readBuffer.texture;\n                renderer.setRenderTarget(null);\n                this.fsQuad.render(renderer);\n            }\n        },\n        getPrepareMaskMaterial: function () {\n            return new THREE.ShaderMaterial({\n                uniforms: {\n                    'depthTexture': { value: null },\n                    'cameraNearFar': { value: new THREE.Vector2(0.5, 0.5) },\n                    'textureMatrix': { value: null }\n                },\n                vertexShader: [\n                    '#include <morphtarget_pars_vertex>',\n                    '#include <skinning_pars_vertex>',\n                    'varying vec4 projTexCoord;',\n                    'varying vec4 vPosition;',\n                    'uniform mat4 textureMatrix;',\n                    'void main() {',\n                    '\\t#include <skinbase_vertex>',\n                    '\\t#include <begin_vertex>',\n                    '\\t#include <morphtarget_vertex>',\n                    '\\t#include <skinning_vertex>',\n                    '\\t#include <project_vertex>',\n                    '\\tvPosition = mvPosition;',\n                    '\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\n                    '\\tprojTexCoord = textureMatrix * worldPosition;',\n                    '}'\n                ].join('\\n'),\n                fragmentShader: [\n                    '#include <packing>',\n                    'varying vec4 vPosition;',\n                    'varying vec4 projTexCoord;',\n                    'uniform sampler2D depthTexture;',\n                    'uniform vec2 cameraNearFar;',\n                    'void main() {',\n                    '\\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));',\n                    '\\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );',\n                    '\\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;',\n                    '\\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);',\n                    '}'\n                ].join('\\n')\n            });\n        },\n        getEdgeDetectionMaterial: function () {\n            return new THREE.ShaderMaterial({\n                uniforms: {\n                    'maskTexture': { value: null },\n                    'texSize': { value: new THREE.Vector2(0.5, 0.5) },\n                    'visibleEdgeColor': { value: new THREE.Vector3(1, 1, 1) },\n                    'hiddenEdgeColor': { value: new THREE.Vector3(1, 1, 1) }\n                },\n                vertexShader: 'varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}',\n                fragmentShader: 'varying vec2 vUv;\\t\\t\\t\\tuniform sampler2D maskTexture;\\t\\t\\t\\tuniform vec2 texSize;\\t\\t\\t\\tuniform vec3 visibleEdgeColor;\\t\\t\\t\\tuniform vec3 hiddenEdgeColor;\\t\\t\\t\\t\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\t\\t\\t\\t\\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\t\\t\\t\\t\\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\t\\t\\t\\t\\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\t\\t\\t\\t\\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\t\\t\\t\\t\\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\t\\t\\t\\t\\tfloat diff1 = (c1.r - c2.r)*0.5;\\t\\t\\t\\t\\tfloat diff2 = (c3.r - c4.r)*0.5;\\t\\t\\t\\t\\tfloat d = length( vec2(diff1, diff2) );\\t\\t\\t\\t\\tfloat a1 = min(c1.g, c2.g);\\t\\t\\t\\t\\tfloat a2 = min(c3.g, c4.g);\\t\\t\\t\\t\\tfloat visibilityFactor = min(a1, a2);\\t\\t\\t\\t\\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\t\\t\\t\\t\\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\t\\t\\t\\t}'\n            });\n        },\n        getSeperableBlurMaterial: function (maxRadius) {\n            return new THREE.ShaderMaterial({\n                defines: { 'MAX_RADIUS': maxRadius },\n                uniforms: {\n                    'colorTexture': { value: null },\n                    'texSize': { value: new THREE.Vector2(0.5, 0.5) },\n                    'direction': { value: new THREE.Vector2(0.5, 0.5) },\n                    'kernelRadius': { value: 1 }\n                },\n                vertexShader: 'varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}',\n                fragmentShader: '#include <common>\\t\\t\\t\\tvarying vec2 vUv;\\t\\t\\t\\tuniform sampler2D colorTexture;\\t\\t\\t\\tuniform vec2 texSize;\\t\\t\\t\\tuniform vec2 direction;\\t\\t\\t\\tuniform float kernelRadius;\\t\\t\\t\\t\\t\\t\\t\\tfloat gaussianPdf(in float x, in float sigma) {\\t\\t\\t\\t\\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\t\\t\\t\\t}\\t\\t\\t\\tvoid main() {\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\t\\t\\t\\t\\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\t\\t\\t\\t\\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\\t\\t\\t\\t\\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\t\\t\\t\\t\\tvec2 uvOffset = delta;\\t\\t\\t\\t\\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\t\\t\\t\\t\\t\\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\t\\t\\t\\t\\t\\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\\t\\t\\t\\t\\t\\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\\t\\t\\t\\t\\t\\tdiffuseSum += ((sample1 + sample2) * w);\\t\\t\\t\\t\\t\\tweightSum += (2.0 * w);\\t\\t\\t\\t\\t\\tuvOffset += delta;\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\tgl_FragColor = diffuseSum/weightSum;\\t\\t\\t\\t}'\n            });\n        },\n        getOverlayMaterial: function () {\n            return new THREE.ShaderMaterial({\n                uniforms: {\n                    'maskTexture': { value: null },\n                    'edgeTexture1': { value: null },\n                    'edgeTexture2': { value: null },\n                    'patternTexture': { value: null },\n                    'edgeStrength': { value: 1 },\n                    'edgeGlow': { value: 1 },\n                    'usePatternTexture': { value: 0 }\n                },\n                vertexShader: 'varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}',\n                fragmentShader: 'varying vec2 vUv;\\t\\t\\t\\tuniform sampler2D maskTexture;\\t\\t\\t\\tuniform sampler2D edgeTexture1;\\t\\t\\t\\tuniform sampler2D edgeTexture2;\\t\\t\\t\\tuniform sampler2D patternTexture;\\t\\t\\t\\tuniform float edgeStrength;\\t\\t\\t\\tuniform float edgeGlow;\\t\\t\\t\\tuniform bool usePatternTexture;\\t\\t\\t\\t\\t\\t\\t\\tvoid main() {\\t\\t\\t\\t\\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\t\\t\\t\\t\\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\t\\t\\t\\t\\tvec4 maskColor = texture2D(maskTexture, vUv);\\t\\t\\t\\t\\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\t\\t\\t\\t\\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\t\\t\\t\\t\\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\t\\t\\t\\t\\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\t\\t\\t\\t\\tif(usePatternTexture)\\t\\t\\t\\t\\t\\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\t\\t\\t\\t\\tgl_FragColor = finalColor;\\t\\t\\t\\t}',\n                blending: THREE.AdditiveBlending,\n                depthTest: false,\n                depthWrite: false,\n                transparent: true\n            });\n        }\n    });\n    OutlinePass.BlurDirectionX = new THREE.Vector2(1, 0);\n    OutlinePass.BlurDirectionY = new THREE.Vector2(0, 1);\n\n    return threex.postprocessing.OutlinePass = OutlinePass;\n});"]}