{"version":3,"sources":["postprocessing/UnrealBloomPass.js"],"names":["define","THREE","threex","Pass","CopyShader","LuminosityHighPassShader","UnrealBloomPass","resolution","strength","radius","threshold","call","this","undefined","Vector2","x","y","clearColor","Color","pars","minFilter","LinearFilter","magFilter","format","RGBAFormat","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","WebGLRenderTarget","texture","name","generateMipmaps","i","renderTargetHorizonal","push","renderTargetVertical","console","error","highPassShader","highPassUniforms","UniformsUtils","clone","uniforms","value","materialHighPassFilter","ShaderMaterial","vertexShader","fragmentShader","defines","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","needsUpdate","bloomTintColors","Vector3","copyShader","copyUniforms","materialCopy","blending","AdditiveBlending","depthTest","depthWrite","transparent","enabled","needsSwap","oldClearColor","oldClearAlpha","basic","MeshBasicMaterial","fsQuad","FullScreenQuad","prototype","Object","assign","create","constructor","dispose","length","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","copy","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","renderToScreen","material","map","setRenderTarget","clear","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius","KERNEL_RADIUS","SIGMA","colorTexture","texSize","direction","NUM_MIPS","blurTexture1","blurTexture2","blurTexture3","blurTexture4","blurTexture5","dirtTexture","bloomStrength","bloomFactors","bloomRadius","postprocessing"],"mappings":"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","file":"../../postprocessing/UnrealBloomPass.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\",\r\n    './Pass',\r\n    '../shaders/CopyShader',\r\n    '../shaders/LuminosityHighPassShader'\r\n], function (\r\n    THREE, \r\n    threex,\r\n    Pass, \r\n    CopyShader, \r\n    LuminosityHighPassShader\r\n) {\r\n    'use strict';\r\n    var UnrealBloomPass = function (resolution, strength, radius, threshold) {\r\n        Pass.call(this);\r\n        this.strength = strength !== undefined ? strength : 1;\r\n        this.radius = radius;\r\n        this.threshold = threshold;\r\n        this.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);\r\n        this.clearColor = new THREE.Color(0, 0, 0);\r\n        var pars = {\r\n            minFilter: THREE.LinearFilter,\r\n            magFilter: THREE.LinearFilter,\r\n            format: THREE.RGBAFormat\r\n        };\r\n        this.renderTargetsHorizontal = [];\r\n        this.renderTargetsVertical = [];\r\n        this.nMips = 5;\r\n        var resx = Math.round(this.resolution.x / 2);\r\n        var resy = Math.round(this.resolution.y / 2);\r\n        this.renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);\r\n        this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\r\n        this.renderTargetBright.texture.generateMipmaps = false;\r\n        for (var i = 0; i < this.nMips; i++) {\r\n            var renderTargetHorizonal = new THREE.WebGLRenderTarget(resx, resy, pars);\r\n            renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\r\n            renderTargetHorizonal.texture.generateMipmaps = false;\r\n            this.renderTargetsHorizontal.push(renderTargetHorizonal);\r\n            var renderTargetVertical = new THREE.WebGLRenderTarget(resx, resy, pars);\r\n            renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\r\n            renderTargetVertical.texture.generateMipmaps = false;\r\n            this.renderTargetsVertical.push(renderTargetVertical);\r\n            resx = Math.round(resx / 2);\r\n            resy = Math.round(resy / 2);\r\n        }\r\n        if (LuminosityHighPassShader === undefined)\r\n            console.error('UnrealBloomPass relies on LuminosityHighPassShader');\r\n        var highPassShader = LuminosityHighPassShader;\r\n        this.highPassUniforms = THREE.UniformsUtils.clone(highPassShader.uniforms);\r\n        this.highPassUniforms['luminosityThreshold'].value = threshold;\r\n        this.highPassUniforms['smoothWidth'].value = 0.01;\r\n        this.materialHighPassFilter = new THREE.ShaderMaterial({\r\n            uniforms: this.highPassUniforms,\r\n            vertexShader: highPassShader.vertexShader,\r\n            fragmentShader: highPassShader.fragmentShader,\r\n            defines: {}\r\n        });\r\n        this.separableBlurMaterials = [];\r\n        var kernelSizeArray = [\r\n            3,\r\n            5,\r\n            7,\r\n            9,\r\n            11\r\n        ];\r\n        var resx = Math.round(this.resolution.x / 2);\r\n        var resy = Math.round(this.resolution.y / 2);\r\n        for (var i = 0; i < this.nMips; i++) {\r\n            this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\r\n            this.separableBlurMaterials[i].uniforms['texSize'].value = new THREE.Vector2(resx, resy);\r\n            resx = Math.round(resx / 2);\r\n            resy = Math.round(resy / 2);\r\n        }\r\n        this.compositeMaterial = this.getCompositeMaterial(this.nMips);\r\n        this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;\r\n        this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;\r\n        this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;\r\n        this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;\r\n        this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;\r\n        this.compositeMaterial.uniforms['bloomStrength'].value = strength;\r\n        this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\r\n        this.compositeMaterial.needsUpdate = true;\r\n        var bloomFactors = [\r\n            1,\r\n            0.8,\r\n            0.6,\r\n            0.4,\r\n            0.2\r\n        ];\r\n        this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\r\n        this.bloomTintColors = [\r\n            new THREE.Vector3(1, 1, 1),\r\n            new THREE.Vector3(1, 1, 1),\r\n            new THREE.Vector3(1, 1, 1),\r\n            new THREE.Vector3(1, 1, 1),\r\n            new THREE.Vector3(1, 1, 1)\r\n        ];\r\n        this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\r\n        if (CopyShader === undefined) {\r\n            console.error('UnrealBloomPass relies on CopyShader');\r\n        }\r\n        var copyShader = CopyShader;\r\n        this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\r\n        this.copyUniforms['opacity'].value = 1;\r\n        this.materialCopy = new THREE.ShaderMaterial({\r\n            uniforms: this.copyUniforms,\r\n            vertexShader: copyShader.vertexShader,\r\n            fragmentShader: copyShader.fragmentShader,\r\n            blending: THREE.AdditiveBlending,\r\n            depthTest: false,\r\n            depthWrite: false,\r\n            transparent: true\r\n        });\r\n        this.enabled = true;\r\n        this.needsSwap = false;\r\n        this.oldClearColor = new THREE.Color();\r\n        this.oldClearAlpha = 1;\r\n        this.basic = new THREE.MeshBasicMaterial();\r\n        this.fsQuad = new Pass.FullScreenQuad(null);\r\n    };\r\n    UnrealBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {\r\n        constructor: UnrealBloomPass,\r\n        dispose: function () {\r\n            for (var i = 0; i < this.renderTargetsHorizontal.length; i++) {\r\n                this.renderTargetsHorizontal[i].dispose();\r\n            }\r\n            for (var i = 0; i < this.renderTargetsVertical.length; i++) {\r\n                this.renderTargetsVertical[i].dispose();\r\n            }\r\n            this.renderTargetBright.dispose();\r\n        },\r\n        setSize: function (width, height) {\r\n            var resx = Math.round(width / 2);\r\n            var resy = Math.round(height / 2);\r\n            this.renderTargetBright.setSize(resx, resy);\r\n            for (var i = 0; i < this.nMips; i++) {\r\n                this.renderTargetsHorizontal[i].setSize(resx, resy);\r\n                this.renderTargetsVertical[i].setSize(resx, resy);\r\n                this.separableBlurMaterials[i].uniforms['texSize'].value = new THREE.Vector2(resx, resy);\r\n                resx = Math.round(resx / 2);\r\n                resy = Math.round(resy / 2);\r\n            }\r\n        },\r\n        render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\r\n            this.oldClearColor.copy(renderer.getClearColor());\r\n            this.oldClearAlpha = renderer.getClearAlpha();\r\n            var oldAutoClear = renderer.autoClear;\r\n            renderer.autoClear = false;\r\n            renderer.setClearColor(this.clearColor, 0);\r\n            if (maskActive)\r\n                renderer.state.buffers.stencil.setTest(false);\r\n            if (this.renderToScreen) {\r\n                this.fsQuad.material = this.basic;\r\n                this.basic.map = readBuffer.texture;\r\n                renderer.setRenderTarget(null);\r\n                renderer.clear();\r\n                this.fsQuad.render(renderer);\r\n            }\r\n            this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\r\n            this.highPassUniforms['luminosityThreshold'].value = this.threshold;\r\n            this.fsQuad.material = this.materialHighPassFilter;\r\n            renderer.setRenderTarget(this.renderTargetBright);\r\n            renderer.clear();\r\n            this.fsQuad.render(renderer);\r\n            var inputRenderTarget = this.renderTargetBright;\r\n            for (var i = 0; i < this.nMips; i++) {\r\n                this.fsQuad.material = this.separableBlurMaterials[i];\r\n                this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\r\n                this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\r\n                renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\r\n                renderer.clear();\r\n                this.fsQuad.render(renderer);\r\n                this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\r\n                this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\r\n                renderer.setRenderTarget(this.renderTargetsVertical[i]);\r\n                renderer.clear();\r\n                this.fsQuad.render(renderer);\r\n                inputRenderTarget = this.renderTargetsVertical[i];\r\n            }\r\n            this.fsQuad.material = this.compositeMaterial;\r\n            this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\r\n            this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\r\n            this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\r\n            renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\r\n            renderer.clear();\r\n            this.fsQuad.render(renderer);\r\n            this.fsQuad.material = this.materialCopy;\r\n            this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\r\n            if (maskActive)\r\n                renderer.state.buffers.stencil.setTest(true);\r\n            if (this.renderToScreen) {\r\n                renderer.setRenderTarget(null);\r\n                this.fsQuad.render(renderer);\r\n            } else {\r\n                renderer.setRenderTarget(readBuffer);\r\n                this.fsQuad.render(renderer);\r\n            }\r\n            renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);\r\n            renderer.autoClear = oldAutoClear;\r\n        },\r\n        getSeperableBlurMaterial: function (kernelRadius) {\r\n            return new THREE.ShaderMaterial({\r\n                defines: {\r\n                    'KERNEL_RADIUS': kernelRadius,\r\n                    'SIGMA': kernelRadius\r\n                },\r\n                uniforms: {\r\n                    'colorTexture': { value: null },\r\n                    'texSize': { value: new THREE.Vector2(0.5, 0.5) },\r\n                    'direction': { value: new THREE.Vector2(0.5, 0.5) }\r\n                },\r\n                vertexShader: 'varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}',\r\n                fragmentShader: '#include <common>\\t\\t\\t\\tvarying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D colorTexture;\\n\\t\\t\\t\\tuniform vec2 texSize;\\t\\t\\t\\tuniform vec2 direction;\\t\\t\\t\\t\\t\\t\\t\\tfloat gaussianPdf(in float x, in float sigma) {\\t\\t\\t\\t\\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\t\\t\\t\\t}\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\t\\t\\t\\t\\tfloat fSigma = float(SIGMA);\\t\\t\\t\\t\\tfloat weightSum = gaussianPdf(0.0, fSigma);\\t\\t\\t\\t\\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\t\\t\\t\\t\\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\t\\t\\t\\t\\t\\tfloat x = float(i);\\t\\t\\t\\t\\t\\tfloat w = gaussianPdf(x, fSigma);\\t\\t\\t\\t\\t\\tvec2 uvOffset = direction * invSize * x;\\t\\t\\t\\t\\t\\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\t\\t\\t\\t\\t\\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\t\\t\\t\\t\\t\\tdiffuseSum += (sample1 + sample2) * w;\\t\\t\\t\\t\\t\\tweightSum += 2.0 * w;\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\t\\t\\t\\t}'\r\n            });\r\n        },\r\n        getCompositeMaterial: function (nMips) {\r\n            return new THREE.ShaderMaterial({\r\n                defines: { 'NUM_MIPS': nMips },\r\n                uniforms: {\r\n                    'blurTexture1': { value: null },\r\n                    'blurTexture2': { value: null },\r\n                    'blurTexture3': { value: null },\r\n                    'blurTexture4': { value: null },\r\n                    'blurTexture5': { value: null },\r\n                    'dirtTexture': { value: null },\r\n                    'bloomStrength': { value: 1 },\r\n                    'bloomFactors': { value: null },\r\n                    'bloomTintColors': { value: null },\r\n                    'bloomRadius': { value: 0 }\r\n                },\r\n                vertexShader: 'varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}',\r\n                fragmentShader: 'varying vec2 vUv;\\t\\t\\t\\tuniform sampler2D blurTexture1;\\t\\t\\t\\tuniform sampler2D blurTexture2;\\t\\t\\t\\tuniform sampler2D blurTexture3;\\t\\t\\t\\tuniform sampler2D blurTexture4;\\t\\t\\t\\tuniform sampler2D blurTexture5;\\t\\t\\t\\tuniform sampler2D dirtTexture;\\t\\t\\t\\tuniform float bloomStrength;\\t\\t\\t\\tuniform float bloomRadius;\\t\\t\\t\\tuniform float bloomFactors[NUM_MIPS];\\t\\t\\t\\tuniform vec3 bloomTintColors[NUM_MIPS];\\t\\t\\t\\t\\t\\t\\t\\tfloat lerpBloomFactor(const in float factor) { \\t\\t\\t\\t\\tfloat mirrorFactor = 1.2 - factor;\\t\\t\\t\\t\\treturn mix(factor, mirrorFactor, bloomRadius);\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\t\\tvoid main() {\\t\\t\\t\\t\\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\t\\t\\t\\t}'\r\n            });\r\n        }\r\n    });\r\n    UnrealBloomPass.BlurDirectionX = new THREE.Vector2(1, 0);\r\n    UnrealBloomPass.BlurDirectionY = new THREE.Vector2(0, 1);\r\n\r\n    return threex.postprocessing.UnrealBloomPass = UnrealBloomPass;\r\n});"]}