{"version":3,"sources":["postprocessing/UnrealBloomPass.js"],"names":["define","THREE","UnrealBloomPass","resolution","strength","radius","threshold","Pass","call","this","undefined","Vector2","x","y","clearColor","Color","pars","minFilter","LinearFilter","magFilter","format","RGBAFormat","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","WebGLRenderTarget","texture","name","generateMipmaps","i","renderTargetHorizonal","push","renderTargetVertical","LuminosityHighPassShader","console","error","highPassShader","highPassUniforms","UniformsUtils","clone","uniforms","value","materialHighPassFilter","ShaderMaterial","vertexShader","fragmentShader","defines","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","needsUpdate","bloomTintColors","Vector3","CopyShader","copyShader","copyUniforms","materialCopy","blending","AdditiveBlending","depthTest","depthWrite","transparent","enabled","needsSwap","oldClearColor","oldClearAlpha","basic","MeshBasicMaterial","fsQuad","FullScreenQuad","prototype","Object","assign","create","constructor","dispose","length","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","copy","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","renderToScreen","material","map","setRenderTarget","clear","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius","KERNEL_RADIUS","SIGMA","colorTexture","texSize","direction","NUM_MIPS","blurTexture1","blurTexture2","blurTexture3","blurTexture4","blurTexture5","dirtTexture","bloomStrength","bloomFactors","bloomRadius"],"mappings":"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","file":"../../postprocessing/UnrealBloomPass.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"../shaders/CopyShader\",\n\t\"../shaders/LuminosityHighPassShader\",\n\t\"./Pass\"\n],function(THREE){\n\t/**\n\t * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n\t * mip map chain of bloom textures and blurs them with different radii. Because\n\t * of the weighted combination of mips, and because larger blurs are done on\n\t * higher mips, this effect provides good quality and performance.\n\t *\n\t * Reference:\n\t * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n\t */\n\tTHREE.UnrealBloomPass = function ( resolution, strength, radius, threshold ) {\n\n\t\tTHREE.Pass.call( this );\n\n\t\tthis.strength = ( strength !== undefined ) ? strength : 1;\n\t\tthis.radius = radius;\n\t\tthis.threshold = threshold;\n\t\tthis.resolution = ( resolution !== undefined ) ? new THREE.Vector2( resolution.x, resolution.y ) : new THREE.Vector2( 256, 256 );\n\n\t\t// create color only once here, reuse it later inside the render function\n\t\tthis.clearColor = new THREE.Color( 0, 0, 0 );\n\n\t\t// render targets\n\t\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\n\t\tthis.renderTargetsHorizontal = [];\n\t\tthis.renderTargetsVertical = [];\n\t\tthis.nMips = 5;\n\t\tvar resx = Math.round( this.resolution.x / 2 );\n\t\tvar resy = Math.round( this.resolution.y / 2 );\n\n\t\tthis.renderTargetBright = new THREE.WebGLRenderTarget( resx, resy, pars );\n\t\tthis.renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n\t\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\t\tfor ( var i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tvar renderTargetHorizonal = new THREE.WebGLRenderTarget( resx, resy, pars );\n\n\t\t\trenderTargetHorizonal.texture.name = \"UnrealBloomPass.h\" + i;\n\t\t\trenderTargetHorizonal.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsHorizontal.push( renderTargetHorizonal );\n\n\t\t\tvar renderTargetVertical = new THREE.WebGLRenderTarget( resx, resy, pars );\n\n\t\t\trenderTargetVertical.texture.name = \"UnrealBloomPass.v\" + i;\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsVertical.push( renderTargetVertical );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// luminosity high pass material\n\n\t\tif ( THREE.LuminosityHighPassShader === undefined )\n\t\t\tconsole.error( \"THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader\" );\n\n\t\tvar highPassShader = THREE.LuminosityHighPassShader;\n\t\tthis.highPassUniforms = THREE.UniformsUtils.clone( highPassShader.uniforms );\n\n\t\tthis.highPassUniforms[ \"luminosityThreshold\" ].value = threshold;\n\t\tthis.highPassUniforms[ \"smoothWidth\" ].value = 0.01;\n\n\t\tthis.materialHighPassFilter = new THREE.ShaderMaterial( {\n\t\t\tuniforms: this.highPassUniforms,\n\t\t\tvertexShader: highPassShader.vertexShader,\n\t\t\tfragmentShader: highPassShader.fragmentShader,\n\t\t\tdefines: {}\n\t\t} );\n\n\t\t// Gaussian Blur Materials\n\t\tthis.separableBlurMaterials = [];\n\t\tvar kernelSizeArray = [ 3, 5, 7, 9, 11 ];\n\t\tvar resx = Math.round( this.resolution.x / 2 );\n\t\tvar resy = Math.round( this.resolution.y / 2 );\n\n\t\tfor ( var i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"texSize\" ].value = new THREE.Vector2( resx, resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// Composite material\n\t\tthis.compositeMaterial = this.getCompositeMaterial( this.nMips );\n\t\tthis.compositeMaterial.uniforms[ \"blurTexture1\" ].value = this.renderTargetsVertical[ 0 ].texture;\n\t\tthis.compositeMaterial.uniforms[ \"blurTexture2\" ].value = this.renderTargetsVertical[ 1 ].texture;\n\t\tthis.compositeMaterial.uniforms[ \"blurTexture3\" ].value = this.renderTargetsVertical[ 2 ].texture;\n\t\tthis.compositeMaterial.uniforms[ \"blurTexture4\" ].value = this.renderTargetsVertical[ 3 ].texture;\n\t\tthis.compositeMaterial.uniforms[ \"blurTexture5\" ].value = this.renderTargetsVertical[ 4 ].texture;\n\t\tthis.compositeMaterial.uniforms[ \"bloomStrength\" ].value = strength;\n\t\tthis.compositeMaterial.uniforms[ \"bloomRadius\" ].value = 0.1;\n\t\tthis.compositeMaterial.needsUpdate = true;\n\n\t\tvar bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\n\t\tthis.compositeMaterial.uniforms[ \"bloomFactors\" ].value = bloomFactors;\n\t\tthis.bloomTintColors = [ new THREE.Vector3( 1, 1, 1 ), new THREE.Vector3( 1, 1, 1 ), new THREE.Vector3( 1, 1, 1 ),\n\t\t\t\t\t\t\t\t new THREE.Vector3( 1, 1, 1 ), new THREE.Vector3( 1, 1, 1 ) ];\n\t\tthis.compositeMaterial.uniforms[ \"bloomTintColors\" ].value = this.bloomTintColors;\n\n\t\t// copy material\n\t\tif ( THREE.CopyShader === undefined ) {\n\n\t\t\tconsole.error( \"THREE.UnrealBloomPass relies on THREE.CopyShader\" );\n\n\t\t}\n\n\t\tvar copyShader = THREE.CopyShader;\n\n\t\tthis.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );\n\t\tthis.copyUniforms[ \"opacity\" ].value = 1.0;\n\n\t\tthis.materialCopy = new THREE.ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: THREE.AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis.oldClearColor = new THREE.Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis.basic = new THREE.MeshBasicMaterial();\n\n\t\tthis.fsQuad = new THREE.Pass.FullScreenQuad( null );\n\n\t};\n\n\tTHREE.UnrealBloomPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\n\t\tconstructor: THREE.UnrealBloomPass,\n\n\t\tdispose: function () {\n\n\t\t\tfor ( var i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < this.renderTargetsVertical.length; i ++ ) {\n\n\t\t\t\tthis.renderTargetsVertical[ i ].dispose();\n\n\t\t\t}\n\n\t\t\tthis.renderTargetBright.dispose();\n\n\t\t},\n\n\t\tsetSize: function ( width, height ) {\n\n\t\t\tvar resx = Math.round( width / 2 );\n\t\t\tvar resy = Math.round( height / 2 );\n\n\t\t\tthis.renderTargetBright.setSize( resx, resy );\n\n\t\t\tfor ( var i = 0; i < this.nMips; i ++ ) {\n\n\t\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"texSize\" ].value = new THREE.Vector2( resx, resy );\n\n\t\t\t\tresx = Math.round( resx / 2 );\n\t\t\t\tresy = Math.round( resy / 2 );\n\n\t\t\t}\n\n\t\t},\n\n\t\trender: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\t\tthis.oldClearColor.copy( renderer.getClearColor() );\n\t\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\t\tvar oldAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\n\t\t\trenderer.setClearColor( this.clearColor, 0 );\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t\t// Render input to screen\n\n\t\t\tif ( this.renderToScreen ) {\n\n\t\t\t\tthis.fsQuad.material = this.basic;\n\t\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\trenderer.clear();\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t}\n\n\t\t\t// 1. Extract Bright Areas\n\n\t\t\tthis.highPassUniforms[ \"tDiffuse\" ].value = readBuffer.texture;\n\t\t\tthis.highPassUniforms[ \"luminosityThreshold\" ].value = this.threshold;\n\t\t\tthis.fsQuad.material = this.materialHighPassFilter;\n\n\t\t\trenderer.setRenderTarget( this.renderTargetBright );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// 2. Blur All the mips progressively\n\n\t\t\tvar inputRenderTarget = this.renderTargetBright;\n\n\t\t\tfor ( var i = 0; i < this.nMips; i ++ ) {\n\n\t\t\t\tthis.fsQuad.material = this.separableBlurMaterials[ i ];\n\n\t\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"colorTexture\" ].value = inputRenderTarget.texture;\n\t\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"direction\" ].value = THREE.UnrealBloomPass.BlurDirectionX;\n\t\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\n\t\t\t\trenderer.clear();\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"colorTexture\" ].value = this.renderTargetsHorizontal[ i ].texture;\n\t\t\t\tthis.separableBlurMaterials[ i ].uniforms[ \"direction\" ].value = THREE.UnrealBloomPass.BlurDirectionY;\n\t\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\n\t\t\t\trenderer.clear();\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\n\n\t\t\t}\n\n\t\t\t// Composite All the mips\n\n\t\t\tthis.fsQuad.material = this.compositeMaterial;\n\t\t\tthis.compositeMaterial.uniforms[ \"bloomStrength\" ].value = this.strength;\n\t\t\tthis.compositeMaterial.uniforms[ \"bloomRadius\" ].value = this.radius;\n\t\t\tthis.compositeMaterial.uniforms[ \"bloomTintColors\" ].value = this.bloomTintColors;\n\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// Blend it additively over the input texture\n\n\t\t\tthis.fsQuad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetsHorizontal[ 0 ].texture;\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\t\tif ( this.renderToScreen ) {\n\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t}\n\n\t\t\t// Restore renderer settings\n\n\t\t\trenderer.setClearColor( this.oldClearColor, this.oldClearAlpha );\n\t\t\trenderer.autoClear = oldAutoClear;\n\n\t\t},\n\n\t\tgetSeperableBlurMaterial: function ( kernelRadius ) {\n\n\t\t\treturn new THREE.ShaderMaterial( {\n\n\t\t\t\tdefines: {\n\t\t\t\t\t\"KERNEL_RADIUS\": kernelRadius,\n\t\t\t\t\t\"SIGMA\": kernelRadius\n\t\t\t\t},\n\n\t\t\t\tuniforms: {\n\t\t\t\t\t\"colorTexture\": { value: null },\n\t\t\t\t\t\"texSize\": { value: new THREE.Vector2( 0.5, 0.5 ) },\n\t\t\t\t\t\"direction\": { value: new THREE.Vector2( 0.5, 0.5 ) }\n\t\t\t\t},\n\n\t\t\t\tvertexShader:\n\t\t\t\t\t\"varying vec2 vUv;\\n\\\n\t\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t\t}\",\n\n\t\t\t\tfragmentShader:\n\t\t\t\t\t\"#include <common>\\\n\t\t\t\t\tvarying vec2 vUv;\\n\\\n\t\t\t\t\tuniform sampler2D colorTexture;\\n\\\n\t\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\t\tuniform vec2 direction;\\\n\t\t\t\t\t\\\n\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\t\tfloat fSigma = float(SIGMA);\\\n\t\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\n\t\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\n\t\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\n\t\t\t\t\t\t\tfloat x = float(i);\\\n\t\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\n\t\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\n\t\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\n\t\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\n\t\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\n\t\t\t\t\t\t\tweightSum += 2.0 * w;\\\n\t\t\t\t\t\t}\\\n\t\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\n\t\t\t\t\t}\"\n\t\t\t} );\n\n\t\t},\n\n\t\tgetCompositeMaterial: function ( nMips ) {\n\n\t\t\treturn new THREE.ShaderMaterial( {\n\n\t\t\t\tdefines: {\n\t\t\t\t\t\"NUM_MIPS\": nMips\n\t\t\t\t},\n\n\t\t\t\tuniforms: {\n\t\t\t\t\t\"blurTexture1\": { value: null },\n\t\t\t\t\t\"blurTexture2\": { value: null },\n\t\t\t\t\t\"blurTexture3\": { value: null },\n\t\t\t\t\t\"blurTexture4\": { value: null },\n\t\t\t\t\t\"blurTexture5\": { value: null },\n\t\t\t\t\t\"dirtTexture\": { value: null },\n\t\t\t\t\t\"bloomStrength\": { value: 1.0 },\n\t\t\t\t\t\"bloomFactors\": { value: null },\n\t\t\t\t\t\"bloomTintColors\": { value: null },\n\t\t\t\t\t\"bloomRadius\": { value: 0.0 }\n\t\t\t\t},\n\n\t\t\t\tvertexShader:\n\t\t\t\t\t\"varying vec2 vUv;\\n\\\n\t\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t\t}\",\n\n\t\t\t\tfragmentShader:\n\t\t\t\t\t\"varying vec2 vUv;\\\n\t\t\t\t\tuniform sampler2D blurTexture1;\\\n\t\t\t\t\tuniform sampler2D blurTexture2;\\\n\t\t\t\t\tuniform sampler2D blurTexture3;\\\n\t\t\t\t\tuniform sampler2D blurTexture4;\\\n\t\t\t\t\tuniform sampler2D blurTexture5;\\\n\t\t\t\t\tuniform sampler2D dirtTexture;\\\n\t\t\t\t\tuniform float bloomStrength;\\\n\t\t\t\t\tuniform float bloomRadius;\\\n\t\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\n\t\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\n\t\t\t\t\t\\\n\t\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\n\t\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\n\t\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\n\t\t\t\t\t}\\\n\t\t\t\t\t\\\n\t\t\t\t\tvoid main() {\\\n\t\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\n\t\t\t\t\t}\"\n\t\t\t} );\n\n\t\t}\n\n\t} );\n\n\tTHREE.UnrealBloomPass.BlurDirectionX = new THREE.Vector2( 1.0, 0.0 );\n\tTHREE.UnrealBloomPass.BlurDirectionY = new THREE.Vector2( 0.0, 1.0 );\n\t\n\treturn THREE.UnrealBloomPass;\n});\n"]}