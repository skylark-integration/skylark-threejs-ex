{"version":3,"sources":["postprocessing/EffectComposer.js"],"names":["define","THREE","CopyShader","ShaderPass","MaskPass","EffectComposer","renderer","renderTarget","this","undefined","parameters","minFilter","LinearFilter","magFilter","format","RGBAFormat","stencilBuffer","size","getSize","Vector2","_pixelRatio","getPixelRatio","_width","width","_height","height","WebGLRenderTarget","texture","name","renderTarget1","renderTarget2","clone","writeBuffer","readBuffer","renderToScreen","passes","console","error","copyPass","clock","Clock","Object","assign","prototype","swapBuffers","tmp","addPass","pass","push","setSize","insertPass","index","splice","isLastEnabledPass","passIndex","i","length","enabled","render","deltaTime","getDelta","currentRenderTarget","getRenderTarget","maskActive","il","needsSwap","context","getContext","stencil","state","buffers","setFunc","NOTEQUAL","EQUAL","ClearMaskPass","setRenderTarget","reset","dispose","effectiveWidth","effectiveHeight","setPixelRatio","pixelRatio"],"mappings":"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","file":"../../postprocessing/EffectComposer.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    '../shaders/CopyShader',\n    '../postprocessing/ShaderPass',\n    '../postprocessing/MaskPass'\n], function (\n    THREE, \n    CopyShader, \n    ShaderPass, \n    MaskPass\n) {\n    'use strict';\n    var EffectComposer = function (renderer, renderTarget) {\n        this.renderer = renderer;\n        if (renderTarget === undefined) {\n            var parameters = {\n                minFilter: THREE.LinearFilter,\n                magFilter: THREE.LinearFilter,\n                format: THREE.RGBAFormat,\n                stencilBuffer: false\n            };\n            var size = renderer.getSize(new THREE.Vector2());\n            this._pixelRatio = renderer.getPixelRatio();\n            this._width = size.width;\n            this._height = size.height;\n            renderTarget = new THREE.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);\n            renderTarget.texture.name = 'EffectComposer.rt1';\n        } else {\n            this._pixelRatio = 1;\n            this._width = renderTarget.width;\n            this._height = renderTarget.height;\n        }\n        this.renderTarget1 = renderTarget;\n        this.renderTarget2 = renderTarget.clone();\n        this.renderTarget2.texture.name = 'EffectComposer.rt2';\n        this.writeBuffer = this.renderTarget1;\n        this.readBuffer = this.renderTarget2;\n        this.renderToScreen = true;\n        this.passes = [];\n        if (CopyShader === undefined) {\n            console.error('THREE.EffectComposer relies on CopyShader');\n        }\n        if (ShaderPass === undefined) {\n            console.error('THREE.EffectComposer relies on ShaderPass');\n        }\n        this.copyPass = new ShaderPass(CopyShader);\n        this.clock = new THREE.Clock();\n    };\n    Object.assign(EffectComposer.prototype, {\n        swapBuffers: function () {\n            var tmp = this.readBuffer;\n            this.readBuffer = this.writeBuffer;\n            this.writeBuffer = tmp;\n        },\n        addPass: function (pass) {\n            this.passes.push(pass);\n            pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);\n        },\n        insertPass: function (pass, index) {\n            this.passes.splice(index, 0, pass);\n        },\n        isLastEnabledPass: function (passIndex) {\n            for (var i = passIndex + 1; i < this.passes.length; i++) {\n                if (this.passes[i].enabled) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        render: function (deltaTime) {\n            if (deltaTime === undefined) {\n                deltaTime = this.clock.getDelta();\n            }\n            var currentRenderTarget = this.renderer.getRenderTarget();\n            var maskActive = false;\n            var pass, i, il = this.passes.length;\n            for (i = 0; i < il; i++) {\n                pass = this.passes[i];\n                if (pass.enabled === false)\n                    continue;\n                pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);\n                pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);\n                if (pass.needsSwap) {\n                    if (maskActive) {\n                        var context = this.renderer.getContext();\n                        var stencil = this.renderer.state.buffers.stencil;\n                        stencil.setFunc(context.NOTEQUAL, 1, 4294967295);\n                        this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);\n                        stencil.setFunc(context.EQUAL, 1, 4294967295);\n                    }\n                    this.swapBuffers();\n                }\n                if (MaskPass !== undefined) {\n                    if (pass instanceof MaskPass) {\n                        maskActive = true;\n                    } else if (pass instanceof ClearMaskPass) {\n                        maskActive = false;\n                    }\n                }\n            }\n            this.renderer.setRenderTarget(currentRenderTarget);\n        },\n        reset: function (renderTarget) {\n            if (renderTarget === undefined) {\n                var size = this.renderer.getSize(new THREE.Vector2());\n                this._pixelRatio = this.renderer.getPixelRatio();\n                this._width = size.width;\n                this._height = size.height;\n                renderTarget = this.renderTarget1.clone();\n                renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);\n            }\n            this.renderTarget1.dispose();\n            this.renderTarget2.dispose();\n            this.renderTarget1 = renderTarget;\n            this.renderTarget2 = renderTarget.clone();\n            this.writeBuffer = this.renderTarget1;\n            this.readBuffer = this.renderTarget2;\n        },\n        setSize: function (width, height) {\n            this._width = width;\n            this._height = height;\n            var effectiveWidth = this._width * this._pixelRatio;\n            var effectiveHeight = this._height * this._pixelRatio;\n            this.renderTarget1.setSize(effectiveWidth, effectiveHeight);\n            this.renderTarget2.setSize(effectiveWidth, effectiveHeight);\n            for (var i = 0; i < this.passes.length; i++) {\n                this.passes[i].setSize(effectiveWidth, effectiveHeight);\n            }\n        },\n        setPixelRatio: function (pixelRatio) {\n            this._pixelRatio = pixelRatio;\n            this.setSize(this._width, this._height);\n        }\n    });\n\n    return  EffectComposer;\n});"]}