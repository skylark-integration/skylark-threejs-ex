{"version":3,"sources":["postprocessing/AdaptiveToneMappingPass.js"],"names":["define","THREE","threex","Pass","CopyShader","LuminosityShader","ToneMapShader","AdaptiveToneMappingPass","adaptive","resolution","call","this","undefined","needsInit","luminanceRT","previousLuminanceRT","currentLuminanceRT","console","error","copyShader","copyUniforms","UniformsUtils","clone","uniforms","materialCopy","ShaderMaterial","vertexShader","fragmentShader","blending","NoBlending","depthTest","materialLuminance","adaptLuminanceShader","defines","MIP_LEVEL_1X1","Math","log","toFixed","lastLum","value","currentLum","minLuminance","delta","tau","join","materialAdaptiveLum","Object","assign","materialToneMap","fsQuad","FullScreenQuad","prototype","create","constructor","render","renderer","writeBuffer","readBuffer","deltaTime","reset","texture","type","material","tDiffuse","setRenderTarget","renderToScreen","clear","dispose","pars","minFilter","LinearFilter","magFilter","format","RGBAFormat","WebGLRenderTarget","name","generateMipmaps","LinearMipmapLinearFilter","luminanceMap","MeshBasicMaterial","color","needsUpdate","setAdaptive","setAdaptionRate","rate","abs","setMinLuminance","minLum","setMaxLuminance","maxLum","maxLuminance","setAverageLuminance","avgLum","averageLuminance","setMiddleGrey","middleGrey","postprocessing"],"mappings":"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","file":"../../postprocessing/AdaptiveToneMappingPass.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\",\r\n    '../postprocessing/Pass',\r\n    '../shaders/CopyShader',\r\n    '../shaders/LuminosityShader',\r\n    '../shaders/ToneMapShader'\r\n], function (\r\n    THREE, \r\n    threex,\r\n    Pass, \r\n    CopyShader, \r\n    LuminosityShader, \r\n    ToneMapShader\r\n) {\r\n    'use strict';\r\n    var AdaptiveToneMappingPass = function (adaptive, resolution) {\r\n        Pass.call(this);\r\n        this.resolution = resolution !== undefined ? resolution : 256;\r\n        this.needsInit = true;\r\n        this.adaptive = adaptive !== undefined ? !!adaptive : true;\r\n        this.luminanceRT = null;\r\n        this.previousLuminanceRT = null;\r\n        this.currentLuminanceRT = null;\r\n        if (CopyShader === undefined)\r\n            console.error('AdaptiveToneMappingPass relies on CopyShader');\r\n        var copyShader = CopyShader;\r\n        this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\r\n        this.materialCopy = new THREE.ShaderMaterial({\r\n            uniforms: this.copyUniforms,\r\n            vertexShader: copyShader.vertexShader,\r\n            fragmentShader: copyShader.fragmentShader,\r\n            blending: THREE.NoBlending,\r\n            depthTest: false\r\n        });\r\n        if (LuminosityShader === undefined)\r\n            console.error('AdaptiveToneMappingPass relies on LuminosityShader');\r\n        this.materialLuminance = new THREE.ShaderMaterial({\r\n            uniforms: THREE.UniformsUtils.clone(LuminosityShader.uniforms),\r\n            vertexShader: LuminosityShader.vertexShader,\r\n            fragmentShader: LuminosityShader.fragmentShader,\r\n            blending: THREE.NoBlending\r\n        });\r\n        this.adaptLuminanceShader = {\r\n            defines: { 'MIP_LEVEL_1X1': (Math.log(this.resolution) / Math.log(2)).toFixed(1) },\r\n            uniforms: {\r\n                'lastLum': { value: null },\r\n                'currentLum': { value: null },\r\n                'minLuminance': { value: 0.01 },\r\n                'delta': { value: 0.016 },\r\n                'tau': { value: 1 }\r\n            },\r\n            vertexShader: [\r\n                'varying vec2 vUv;',\r\n                'void main() {',\r\n                '\\tvUv = uv;',\r\n                '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n                '}'\r\n            ].join('\\n'),\r\n            fragmentShader: [\r\n                'varying vec2 vUv;',\r\n                'uniform sampler2D lastLum;',\r\n                'uniform sampler2D currentLum;',\r\n                'uniform float minLuminance;',\r\n                'uniform float delta;',\r\n                'uniform float tau;',\r\n                'void main() {',\r\n                '\\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );',\r\n                '\\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );',\r\n                '\\tfloat fLastLum = max( minLuminance, lastLum.r );',\r\n                '\\tfloat fCurrentLum = max( minLuminance, currentLum.r );',\r\n                '\\tfCurrentLum *= fCurrentLum;',\r\n                '\\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));',\r\n                '\\tgl_FragColor.r = fAdaptedLum;',\r\n                '}'\r\n            ].join('\\n')\r\n        };\r\n        this.materialAdaptiveLum = new THREE.ShaderMaterial({\r\n            uniforms: THREE.UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\r\n            vertexShader: this.adaptLuminanceShader.vertexShader,\r\n            fragmentShader: this.adaptLuminanceShader.fragmentShader,\r\n            defines: Object.assign({}, this.adaptLuminanceShader.defines),\r\n            blending: THREE.NoBlending\r\n        });\r\n        if (ToneMapShader === undefined)\r\n            console.error('AdaptiveToneMappingPass relies on ToneMapShader');\r\n        this.materialToneMap = new THREE.ShaderMaterial({\r\n            uniforms: THREE.UniformsUtils.clone(ToneMapShader.uniforms),\r\n            vertexShader: ToneMapShader.vertexShader,\r\n            fragmentShader: ToneMapShader.fragmentShader,\r\n            blending: THREE.NoBlending\r\n        });\r\n        this.fsQuad = new Pass.FullScreenQuad(null);\r\n    };\r\n    AdaptiveToneMappingPass.prototype = Object.assign(Object.create(Pass.prototype), {\r\n        constructor: AdaptiveToneMappingPass,\r\n        render: function (renderer, writeBuffer, readBuffer, deltaTime) {\r\n            if (this.needsInit) {\r\n                this.reset(renderer);\r\n                this.luminanceRT.texture.type = readBuffer.texture.type;\r\n                this.previousLuminanceRT.texture.type = readBuffer.texture.type;\r\n                this.currentLuminanceRT.texture.type = readBuffer.texture.type;\r\n                this.needsInit = false;\r\n            }\r\n            if (this.adaptive) {\r\n                this.fsQuad.material = this.materialLuminance;\r\n                this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\r\n                renderer.setRenderTarget(this.currentLuminanceRT);\r\n                this.fsQuad.render(renderer);\r\n                this.fsQuad.material = this.materialAdaptiveLum;\r\n                this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\r\n                this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\r\n                this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\r\n                renderer.setRenderTarget(this.luminanceRT);\r\n                this.fsQuad.render(renderer);\r\n                this.fsQuad.material = this.materialCopy;\r\n                this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\r\n                renderer.setRenderTarget(this.previousLuminanceRT);\r\n                this.fsQuad.render(renderer);\r\n            }\r\n            this.fsQuad.material = this.materialToneMap;\r\n            this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\r\n            if (this.renderToScreen) {\r\n                renderer.setRenderTarget(null);\r\n                this.fsQuad.render(renderer);\r\n            } else {\r\n                renderer.setRenderTarget(writeBuffer);\r\n                if (this.clear)\r\n                    renderer.clear();\r\n                this.fsQuad.render(renderer);\r\n            }\r\n        },\r\n        reset: function () {\r\n            if (this.luminanceRT) {\r\n                this.luminanceRT.dispose();\r\n            }\r\n            if (this.currentLuminanceRT) {\r\n                this.currentLuminanceRT.dispose();\r\n            }\r\n            if (this.previousLuminanceRT) {\r\n                this.previousLuminanceRT.dispose();\r\n            }\r\n            var pars = {\r\n                minFilter: THREE.LinearFilter,\r\n                magFilter: THREE.LinearFilter,\r\n                format: THREE.RGBAFormat\r\n            };\r\n            this.luminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);\r\n            this.luminanceRT.texture.name = 'AdaptiveToneMappingPass.l';\r\n            this.luminanceRT.texture.generateMipmaps = false;\r\n            this.previousLuminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);\r\n            this.previousLuminanceRT.texture.name = 'AdaptiveToneMappingPass.pl';\r\n            this.previousLuminanceRT.texture.generateMipmaps = false;\r\n            pars.minFilter = THREE.LinearMipmapLinearFilter;\r\n            pars.generateMipmaps = true;\r\n            this.currentLuminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);\r\n            this.currentLuminanceRT.texture.name = 'AdaptiveToneMappingPass.cl';\r\n            if (this.adaptive) {\r\n                this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\r\n                this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\r\n            }\r\n            this.fsQuad.material = new THREE.MeshBasicMaterial({ color: 7829367 });\r\n            this.materialLuminance.needsUpdate = true;\r\n            this.materialAdaptiveLum.needsUpdate = true;\r\n            this.materialToneMap.needsUpdate = true;\r\n        },\r\n        setAdaptive: function (adaptive) {\r\n            if (adaptive) {\r\n                this.adaptive = true;\r\n                this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\r\n                this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\r\n            } else {\r\n                this.adaptive = false;\r\n                delete this.materialToneMap.defines['ADAPTED_LUMINANCE'];\r\n                this.materialToneMap.uniforms.luminanceMap.value = null;\r\n            }\r\n            this.materialToneMap.needsUpdate = true;\r\n        },\r\n        setAdaptionRate: function (rate) {\r\n            if (rate) {\r\n                this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\r\n            }\r\n        },\r\n        setMinLuminance: function (minLum) {\r\n            if (minLum) {\r\n                this.materialToneMap.uniforms.minLuminance.value = minLum;\r\n                this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\r\n            }\r\n        },\r\n        setMaxLuminance: function (maxLum) {\r\n            if (maxLum) {\r\n                this.materialToneMap.uniforms.maxLuminance.value = maxLum;\r\n            }\r\n        },\r\n        setAverageLuminance: function (avgLum) {\r\n            if (avgLum) {\r\n                this.materialToneMap.uniforms.averageLuminance.value = avgLum;\r\n            }\r\n        },\r\n        setMiddleGrey: function (middleGrey) {\r\n            if (middleGrey) {\r\n                this.materialToneMap.uniforms.middleGrey.value = middleGrey;\r\n            }\r\n        },\r\n        dispose: function () {\r\n            if (this.luminanceRT) {\r\n                this.luminanceRT.dispose();\r\n            }\r\n            if (this.previousLuminanceRT) {\r\n                this.previousLuminanceRT.dispose();\r\n            }\r\n            if (this.currentLuminanceRT) {\r\n                this.currentLuminanceRT.dispose();\r\n            }\r\n            if (this.materialLuminance) {\r\n                this.materialLuminance.dispose();\r\n            }\r\n            if (this.materialAdaptiveLum) {\r\n                this.materialAdaptiveLum.dispose();\r\n            }\r\n            if (this.materialCopy) {\r\n                this.materialCopy.dispose();\r\n            }\r\n            if (this.materialToneMap) {\r\n                this.materialToneMap.dispose();\r\n            }\r\n        }\r\n    });\r\n    return threex.postprocessing.AdaptiveToneMappingPass = AdaptiveToneMappingPass;\r\n});"]}