{"version":3,"sources":["postprocessing/AdaptiveToneMappingPass.js"],"names":["define","THREE","AdaptiveToneMappingPass","adaptive","resolution","Pass","call","this","undefined","needsInit","luminanceRT","previousLuminanceRT","currentLuminanceRT","CopyShader","console","error","copyShader","copyUniforms","UniformsUtils","clone","uniforms","materialCopy","ShaderMaterial","vertexShader","fragmentShader","blending","NoBlending","depthTest","LuminosityShader","materialLuminance","adaptLuminanceShader","defines","MIP_LEVEL_1X1","Math","log","toFixed","lastLum","value","currentLum","minLuminance","delta","tau","join","materialAdaptiveLum","Object","assign","ToneMapShader","materialToneMap","fsQuad","FullScreenQuad","prototype","create","constructor","render","renderer","writeBuffer","readBuffer","deltaTime","reset","texture","type","material","tDiffuse","setRenderTarget","renderToScreen","clear","dispose","pars","minFilter","LinearFilter","magFilter","format","RGBAFormat","WebGLRenderTarget","name","generateMipmaps","LinearMipmapLinearFilter","luminanceMap","MeshBasicMaterial","color","needsUpdate","setAdaptive","setAdaptionRate","rate","abs","setMinLuminance","minLum","setMaxLuminance","maxLum","maxLuminance","setAverageLuminance","avgLum","averageLuminance","setMiddleGrey","middleGrey"],"mappings":"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","file":"../../postprocessing/AdaptiveToneMappingPass.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author miibond\n\t * Generate a texture that represents the luminosity of the current scene, adapted over time\n\t * to simulate the optic nerve responding to the amount of light it is receiving.\n\t * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n\t *\n\t * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n\t */\n\n\tTHREE.AdaptiveToneMappingPass = function ( adaptive, resolution ) {\n\n\t\tTHREE.Pass.call( this );\n\n\t\tthis.resolution = ( resolution !== undefined ) ? resolution : 256;\n\t\tthis.needsInit = true;\n\t\tthis.adaptive = adaptive !== undefined ? !! adaptive : true;\n\n\t\tthis.luminanceRT = null;\n\t\tthis.previousLuminanceRT = null;\n\t\tthis.currentLuminanceRT = null;\n\n\t\tif ( THREE.CopyShader === undefined )\n\t\t\tconsole.error( \"THREE.AdaptiveToneMappingPass relies on THREE.CopyShader\" );\n\n\t\tvar copyShader = THREE.CopyShader;\n\n\t\tthis.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );\n\n\t\tthis.materialCopy = new THREE.ShaderMaterial( {\n\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: THREE.NoBlending,\n\t\t\tdepthTest: false\n\n\t\t} );\n\n\t\tif ( THREE.LuminosityShader === undefined )\n\t\t\tconsole.error( \"THREE.AdaptiveToneMappingPass relies on THREE.LuminosityShader\" );\n\n\t\tthis.materialLuminance = new THREE.ShaderMaterial( {\n\n\t\t\tuniforms: THREE.UniformsUtils.clone( THREE.LuminosityShader.uniforms ),\n\t\t\tvertexShader: THREE.LuminosityShader.vertexShader,\n\t\t\tfragmentShader: THREE.LuminosityShader.fragmentShader,\n\t\t\tblending: THREE.NoBlending\n\t\t} );\n\n\t\tthis.adaptLuminanceShader = {\n\t\t\tdefines: {\n\t\t\t\t\"MIP_LEVEL_1X1\": ( Math.log( this.resolution ) / Math.log( 2.0 ) ).toFixed( 1 )\n\t\t\t},\n\t\t\tuniforms: {\n\t\t\t\t\"lastLum\": { value: null },\n\t\t\t\t\"currentLum\": { value: null },\n\t\t\t\t\"minLuminance\": { value: 0.01 },\n\t\t\t\t\"delta\": { value: 0.016 },\n\t\t\t\t\"tau\": { value: 1.0 }\n\t\t\t},\n\t\t\tvertexShader: [\n\t\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\"\tvUv = uv;\",\n\t\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\t\"}\"\n\t\t\t].join( '\\n' ),\n\t\t\tfragmentShader: [\n\t\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\t\"uniform sampler2D lastLum;\",\n\t\t\t\t\"uniform sampler2D currentLum;\",\n\t\t\t\t\"uniform float minLuminance;\",\n\t\t\t\t\"uniform float delta;\",\n\t\t\t\t\"uniform float tau;\",\n\n\t\t\t\t\"void main() {\",\n\n\t\t\t\t\"\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\",\n\t\t\t\t\"\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\",\n\n\t\t\t\t\"\tfloat fLastLum = max( minLuminance, lastLum.r );\",\n\t\t\t\t\"\tfloat fCurrentLum = max( minLuminance, currentLum.r );\",\n\n\t\t\t\t//The adaption seems to work better in extreme lighting differences\n\t\t\t\t//if the input luminance is squared.\n\t\t\t\t\"\tfCurrentLum *= fCurrentLum;\",\n\n\t\t\t\t// Adapt the luminance using Pattanaik's technique\n\t\t\t\t\"\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\",\n\t\t\t\t// \"fAdaptedLum = sqrt(fAdaptedLum);\",\n\t\t\t\t\"\tgl_FragColor.r = fAdaptedLum;\",\n\t\t\t\t\"}\"\n\t\t\t].join( '\\n' )\n\t\t};\n\n\t\tthis.materialAdaptiveLum = new THREE.ShaderMaterial( {\n\n\t\t\tuniforms: THREE.UniformsUtils.clone( this.adaptLuminanceShader.uniforms ),\n\t\t\tvertexShader: this.adaptLuminanceShader.vertexShader,\n\t\t\tfragmentShader: this.adaptLuminanceShader.fragmentShader,\n\t\t\tdefines: Object.assign( {}, this.adaptLuminanceShader.defines ),\n\t\t\tblending: THREE.NoBlending\n\t\t} );\n\n\t\tif ( THREE.ToneMapShader === undefined )\n\t\t\tconsole.error( \"THREE.AdaptiveToneMappingPass relies on THREE.ToneMapShader\" );\n\n\t\tthis.materialToneMap = new THREE.ShaderMaterial( {\n\n\t\t\tuniforms: THREE.UniformsUtils.clone( THREE.ToneMapShader.uniforms ),\n\t\t\tvertexShader: THREE.ToneMapShader.vertexShader,\n\t\t\tfragmentShader: THREE.ToneMapShader.fragmentShader,\n\t\t\tblending: THREE.NoBlending\n\t\t} );\n\n\t\tthis.fsQuad = new THREE.Pass.FullScreenQuad( null );\n\n\t};\n\n\tTHREE.AdaptiveToneMappingPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\n\t\tconstructor: THREE.AdaptiveToneMappingPass,\n\n\t\trender: function ( renderer, writeBuffer, readBuffer, deltaTime/*, maskActive*/ ) {\n\n\t\t\tif ( this.needsInit ) {\n\n\t\t\t\tthis.reset( renderer );\n\n\t\t\t\tthis.luminanceRT.texture.type = readBuffer.texture.type;\n\t\t\t\tthis.previousLuminanceRT.texture.type = readBuffer.texture.type;\n\t\t\t\tthis.currentLuminanceRT.texture.type = readBuffer.texture.type;\n\t\t\t\tthis.needsInit = false;\n\n\t\t\t}\n\n\t\t\tif ( this.adaptive ) {\n\n\t\t\t\t//Render the luminance of the current scene into a render target with mipmapping enabled\n\t\t\t\tthis.fsQuad.material = this.materialLuminance;\n\t\t\t\tthis.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n\t\t\t\trenderer.setRenderTarget( this.currentLuminanceRT );\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t\t//Use the new luminance values, the previous luminance and the frame delta to\n\t\t\t\t//adapt the luminance over time.\n\t\t\t\tthis.fsQuad.material = this.materialAdaptiveLum;\n\t\t\t\tthis.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n\t\t\t\tthis.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n\t\t\t\tthis.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n\t\t\t\trenderer.setRenderTarget( this.luminanceRT );\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t\t//Copy the new adapted luminance value so that it can be used by the next frame.\n\t\t\t\tthis.fsQuad.material = this.materialCopy;\n\t\t\t\tthis.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n\t\t\t\trenderer.setRenderTarget( this.previousLuminanceRT );\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t}\n\n\t\t\tthis.fsQuad.material = this.materialToneMap;\n\t\t\tthis.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n\n\t\t\tif ( this.renderToScreen ) {\n\n\t\t\t\trenderer.setRenderTarget( null );\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.setRenderTarget( writeBuffer );\n\n\t\t\t\tif ( this.clear ) renderer.clear();\n\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t}\n\n\t\t},\n\n\t\treset: function () {\n\n\t\t\t// render targets\n\t\t\tif ( this.luminanceRT ) {\n\n\t\t\t\tthis.luminanceRT.dispose();\n\n\t\t\t}\n\t\t\tif ( this.currentLuminanceRT ) {\n\n\t\t\t\tthis.currentLuminanceRT.dispose();\n\n\t\t\t}\n\t\t\tif ( this.previousLuminanceRT ) {\n\n\t\t\t\tthis.previousLuminanceRT.dispose();\n\n\t\t\t}\n\n\t\t\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450\n\n\t\t\tthis.luminanceRT = new THREE.WebGLRenderTarget( this.resolution, this.resolution, pars );\n\t\t\tthis.luminanceRT.texture.name = \"AdaptiveToneMappingPass.l\";\n\t\t\tthis.luminanceRT.texture.generateMipmaps = false;\n\n\t\t\tthis.previousLuminanceRT = new THREE.WebGLRenderTarget( this.resolution, this.resolution, pars );\n\t\t\tthis.previousLuminanceRT.texture.name = \"AdaptiveToneMappingPass.pl\";\n\t\t\tthis.previousLuminanceRT.texture.generateMipmaps = false;\n\n\t\t\t// We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\t\t\tpars.minFilter = THREE.LinearMipmapLinearFilter;\n\t\t\tpars.generateMipmaps = true;\n\t\t\tthis.currentLuminanceRT = new THREE.WebGLRenderTarget( this.resolution, this.resolution, pars );\n\t\t\tthis.currentLuminanceRT.texture.name = \"AdaptiveToneMappingPass.cl\";\n\n\t\t\tif ( this.adaptive ) {\n\n\t\t\t\tthis.materialToneMap.defines[ \"ADAPTED_LUMINANCE\" ] = \"\";\n\t\t\t\tthis.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n\n\t\t\t}\n\t\t\t//Put something in the adaptive luminance texture so that the scene can render initially\n\t\t\tthis.fsQuad.material = new THREE.MeshBasicMaterial( { color: 0x777777 } );\n\t\t\tthis.materialLuminance.needsUpdate = true;\n\t\t\tthis.materialAdaptiveLum.needsUpdate = true;\n\t\t\tthis.materialToneMap.needsUpdate = true;\n\t\t\t// renderer.render( this.scene, this.camera, this.luminanceRT );\n\t\t\t// renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n\t\t\t// renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n\n\t\t},\n\n\t\tsetAdaptive: function ( adaptive ) {\n\n\t\t\tif ( adaptive ) {\n\n\t\t\t\tthis.adaptive = true;\n\t\t\t\tthis.materialToneMap.defines[ \"ADAPTED_LUMINANCE\" ] = \"\";\n\t\t\t\tthis.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n\n\t\t\t} else {\n\n\t\t\t\tthis.adaptive = false;\n\t\t\t\tdelete this.materialToneMap.defines[ \"ADAPTED_LUMINANCE\" ];\n\t\t\t\tthis.materialToneMap.uniforms.luminanceMap.value = null;\n\n\t\t\t}\n\t\t\tthis.materialToneMap.needsUpdate = true;\n\n\t\t},\n\n\t\tsetAdaptionRate: function ( rate ) {\n\n\t\t\tif ( rate ) {\n\n\t\t\t\tthis.materialAdaptiveLum.uniforms.tau.value = Math.abs( rate );\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetMinLuminance: function ( minLum ) {\n\n\t\t\tif ( minLum ) {\n\n\t\t\t\tthis.materialToneMap.uniforms.minLuminance.value = minLum;\n\t\t\t\tthis.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetMaxLuminance: function ( maxLum ) {\n\n\t\t\tif ( maxLum ) {\n\n\t\t\t\tthis.materialToneMap.uniforms.maxLuminance.value = maxLum;\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetAverageLuminance: function ( avgLum ) {\n\n\t\t\tif ( avgLum ) {\n\n\t\t\t\tthis.materialToneMap.uniforms.averageLuminance.value = avgLum;\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetMiddleGrey: function ( middleGrey ) {\n\n\t\t\tif ( middleGrey ) {\n\n\t\t\t\tthis.materialToneMap.uniforms.middleGrey.value = middleGrey;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tif ( this.luminanceRT ) {\n\n\t\t\t\tthis.luminanceRT.dispose();\n\n\t\t\t}\n\t\t\tif ( this.previousLuminanceRT ) {\n\n\t\t\t\tthis.previousLuminanceRT.dispose();\n\n\t\t\t}\n\t\t\tif ( this.currentLuminanceRT ) {\n\n\t\t\t\tthis.currentLuminanceRT.dispose();\n\n\t\t\t}\n\t\t\tif ( this.materialLuminance ) {\n\n\t\t\t\tthis.materialLuminance.dispose();\n\n\t\t\t}\n\t\t\tif ( this.materialAdaptiveLum ) {\n\n\t\t\t\tthis.materialAdaptiveLum.dispose();\n\n\t\t\t}\n\t\t\tif ( this.materialCopy ) {\n\n\t\t\t\tthis.materialCopy.dispose();\n\n\t\t\t}\n\t\t\tif ( this.materialToneMap ) {\n\n\t\t\t\tthis.materialToneMap.dispose();\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\t\n\treturn THREE.AdaptiveToneMappingPass;\n});\n"]}