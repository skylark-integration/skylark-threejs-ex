{"version":3,"sources":["postprocessing/AdaptiveToneMappingPass.js"],"names":["define","THREE","threex","Pass","CopyShader","LuminosityShader","ToneMapShader","AdaptiveToneMappingPass","adaptive","resolution","call","this","undefined","needsInit","luminanceRT","previousLuminanceRT","currentLuminanceRT","console","error","copyShader","copyUniforms","UniformsUtils","clone","uniforms","materialCopy","ShaderMaterial","vertexShader","fragmentShader","blending","NoBlending","depthTest","materialLuminance","adaptLuminanceShader","defines","MIP_LEVEL_1X1","Math","log","toFixed","lastLum","value","currentLum","minLuminance","delta","tau","join","materialAdaptiveLum","Object","assign","materialToneMap","fsQuad","FullScreenQuad","prototype","create","constructor","render","renderer","writeBuffer","readBuffer","deltaTime","reset","texture","type","material","tDiffuse","setRenderTarget","renderToScreen","clear","dispose","pars","minFilter","LinearFilter","magFilter","format","RGBAFormat","WebGLRenderTarget","name","generateMipmaps","LinearMipmapLinearFilter","luminanceMap","MeshBasicMaterial","color","needsUpdate","setAdaptive","setAdaptionRate","rate","abs","setMinLuminance","minLum","setMaxLuminance","maxLum","maxLuminance","setAverageLuminance","avgLum","averageLuminance","setMiddleGrey","middleGrey","postprocessing"],"mappings":"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","file":"../../postprocessing/AdaptiveToneMappingPass.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\",\n    '../postprocessing/Pass',\n    '../shaders/CopyShader',\n    '../shaders/LuminosityShader',\n    '../shaders/ToneMapShader'\n], function (\n    THREE, \n    threex,\n    Pass, \n    CopyShader, \n    LuminosityShader, \n    ToneMapShader\n) {\n    'use strict';\n    var AdaptiveToneMappingPass = function (adaptive, resolution) {\n        Pass.call(this);\n        this.resolution = resolution !== undefined ? resolution : 256;\n        this.needsInit = true;\n        this.adaptive = adaptive !== undefined ? !!adaptive : true;\n        this.luminanceRT = null;\n        this.previousLuminanceRT = null;\n        this.currentLuminanceRT = null;\n        if (CopyShader === undefined)\n            console.error('AdaptiveToneMappingPass relies on CopyShader');\n        var copyShader = CopyShader;\n        this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n        this.materialCopy = new THREE.ShaderMaterial({\n            uniforms: this.copyUniforms,\n            vertexShader: copyShader.vertexShader,\n            fragmentShader: copyShader.fragmentShader,\n            blending: THREE.NoBlending,\n            depthTest: false\n        });\n        if (LuminosityShader === undefined)\n            console.error('AdaptiveToneMappingPass relies on LuminosityShader');\n        this.materialLuminance = new THREE.ShaderMaterial({\n            uniforms: THREE.UniformsUtils.clone(LuminosityShader.uniforms),\n            vertexShader: LuminosityShader.vertexShader,\n            fragmentShader: LuminosityShader.fragmentShader,\n            blending: THREE.NoBlending\n        });\n        this.adaptLuminanceShader = {\n            defines: { 'MIP_LEVEL_1X1': (Math.log(this.resolution) / Math.log(2)).toFixed(1) },\n            uniforms: {\n                'lastLum': { value: null },\n                'currentLum': { value: null },\n                'minLuminance': { value: 0.01 },\n                'delta': { value: 0.016 },\n                'tau': { value: 1 }\n            },\n            vertexShader: [\n                'varying vec2 vUv;',\n                'void main() {',\n                '\\tvUv = uv;',\n                '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n                '}'\n            ].join('\\n'),\n            fragmentShader: [\n                'varying vec2 vUv;',\n                'uniform sampler2D lastLum;',\n                'uniform sampler2D currentLum;',\n                'uniform float minLuminance;',\n                'uniform float delta;',\n                'uniform float tau;',\n                'void main() {',\n                '\\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );',\n                '\\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );',\n                '\\tfloat fLastLum = max( minLuminance, lastLum.r );',\n                '\\tfloat fCurrentLum = max( minLuminance, currentLum.r );',\n                '\\tfCurrentLum *= fCurrentLum;',\n                '\\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));',\n                '\\tgl_FragColor.r = fAdaptedLum;',\n                '}'\n            ].join('\\n')\n        };\n        this.materialAdaptiveLum = new THREE.ShaderMaterial({\n            uniforms: THREE.UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n            vertexShader: this.adaptLuminanceShader.vertexShader,\n            fragmentShader: this.adaptLuminanceShader.fragmentShader,\n            defines: Object.assign({}, this.adaptLuminanceShader.defines),\n            blending: THREE.NoBlending\n        });\n        if (ToneMapShader === undefined)\n            console.error('AdaptiveToneMappingPass relies on ToneMapShader');\n        this.materialToneMap = new THREE.ShaderMaterial({\n            uniforms: THREE.UniformsUtils.clone(ToneMapShader.uniforms),\n            vertexShader: ToneMapShader.vertexShader,\n            fragmentShader: ToneMapShader.fragmentShader,\n            blending: THREE.NoBlending\n        });\n        this.fsQuad = new Pass.FullScreenQuad(null);\n    };\n    AdaptiveToneMappingPass.prototype = Object.assign(Object.create(Pass.prototype), {\n        constructor: AdaptiveToneMappingPass,\n        render: function (renderer, writeBuffer, readBuffer, deltaTime) {\n            if (this.needsInit) {\n                this.reset(renderer);\n                this.luminanceRT.texture.type = readBuffer.texture.type;\n                this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n                this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n                this.needsInit = false;\n            }\n            if (this.adaptive) {\n                this.fsQuad.material = this.materialLuminance;\n                this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n                renderer.setRenderTarget(this.currentLuminanceRT);\n                this.fsQuad.render(renderer);\n                this.fsQuad.material = this.materialAdaptiveLum;\n                this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n                this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n                this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n                renderer.setRenderTarget(this.luminanceRT);\n                this.fsQuad.render(renderer);\n                this.fsQuad.material = this.materialCopy;\n                this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n                renderer.setRenderTarget(this.previousLuminanceRT);\n                this.fsQuad.render(renderer);\n            }\n            this.fsQuad.material = this.materialToneMap;\n            this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n            if (this.renderToScreen) {\n                renderer.setRenderTarget(null);\n                this.fsQuad.render(renderer);\n            } else {\n                renderer.setRenderTarget(writeBuffer);\n                if (this.clear)\n                    renderer.clear();\n                this.fsQuad.render(renderer);\n            }\n        },\n        reset: function () {\n            if (this.luminanceRT) {\n                this.luminanceRT.dispose();\n            }\n            if (this.currentLuminanceRT) {\n                this.currentLuminanceRT.dispose();\n            }\n            if (this.previousLuminanceRT) {\n                this.previousLuminanceRT.dispose();\n            }\n            var pars = {\n                minFilter: THREE.LinearFilter,\n                magFilter: THREE.LinearFilter,\n                format: THREE.RGBAFormat\n            };\n            this.luminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);\n            this.luminanceRT.texture.name = 'AdaptiveToneMappingPass.l';\n            this.luminanceRT.texture.generateMipmaps = false;\n            this.previousLuminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);\n            this.previousLuminanceRT.texture.name = 'AdaptiveToneMappingPass.pl';\n            this.previousLuminanceRT.texture.generateMipmaps = false;\n            pars.minFilter = THREE.LinearMipmapLinearFilter;\n            pars.generateMipmaps = true;\n            this.currentLuminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);\n            this.currentLuminanceRT.texture.name = 'AdaptiveToneMappingPass.cl';\n            if (this.adaptive) {\n                this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n                this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n            }\n            this.fsQuad.material = new THREE.MeshBasicMaterial({ color: 7829367 });\n            this.materialLuminance.needsUpdate = true;\n            this.materialAdaptiveLum.needsUpdate = true;\n            this.materialToneMap.needsUpdate = true;\n        },\n        setAdaptive: function (adaptive) {\n            if (adaptive) {\n                this.adaptive = true;\n                this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n                this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n            } else {\n                this.adaptive = false;\n                delete this.materialToneMap.defines['ADAPTED_LUMINANCE'];\n                this.materialToneMap.uniforms.luminanceMap.value = null;\n            }\n            this.materialToneMap.needsUpdate = true;\n        },\n        setAdaptionRate: function (rate) {\n            if (rate) {\n                this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n            }\n        },\n        setMinLuminance: function (minLum) {\n            if (minLum) {\n                this.materialToneMap.uniforms.minLuminance.value = minLum;\n                this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n            }\n        },\n        setMaxLuminance: function (maxLum) {\n            if (maxLum) {\n                this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n            }\n        },\n        setAverageLuminance: function (avgLum) {\n            if (avgLum) {\n                this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n            }\n        },\n        setMiddleGrey: function (middleGrey) {\n            if (middleGrey) {\n                this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n            }\n        },\n        dispose: function () {\n            if (this.luminanceRT) {\n                this.luminanceRT.dispose();\n            }\n            if (this.previousLuminanceRT) {\n                this.previousLuminanceRT.dispose();\n            }\n            if (this.currentLuminanceRT) {\n                this.currentLuminanceRT.dispose();\n            }\n            if (this.materialLuminance) {\n                this.materialLuminance.dispose();\n            }\n            if (this.materialAdaptiveLum) {\n                this.materialAdaptiveLum.dispose();\n            }\n            if (this.materialCopy) {\n                this.materialCopy.dispose();\n            }\n            if (this.materialToneMap) {\n                this.materialToneMap.dispose();\n            }\n        }\n    });\n    return threex.postprocessing.AdaptiveToneMappingPass = AdaptiveToneMappingPass;\n});"]}