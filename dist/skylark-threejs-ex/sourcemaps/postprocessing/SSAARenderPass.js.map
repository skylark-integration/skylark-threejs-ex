{"version":3,"sources":["postprocessing/SSAARenderPass.js"],"names":["define","THREE","SSAARenderPass","scene","camera","clearColor","clearAlpha","Pass","call","this","sampleLevel","unbiased","undefined","CopyShader","console","error","copyShader","copyUniforms","UniformsUtils","clone","uniforms","copyMaterial","ShaderMaterial","vertexShader","fragmentShader","premultipliedAlpha","transparent","blending","AdditiveBlending","depthTest","depthWrite","fsQuad","FullScreenQuad","prototype","Object","assign","create","constructor","dispose","sampleRenderTarget","setSize","width","height","render","renderer","writeBuffer","readBuffer","WebGLRenderTarget","minFilter","LinearFilter","magFilter","format","RGBAFormat","texture","name","jitterOffsets","JitterVectors","Math","max","min","autoClear","oldClearColor","getClearColor","getHex","oldClearAlpha","getClearAlpha","baseSampleWeight","length","value","i","jitterOffset","setViewOffset","sampleWeight","setClearColor","setRenderTarget","clear","renderToScreen","clearViewOffset"],"mappings":"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","file":"../../postprocessing/SSAARenderPass.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"../shaders/CopyShader\",\n\t\"./Pass\"\n],function(THREE){\n\t/**\n\t*\n\t* Supersample Anti-Aliasing Render Pass\n\t*\n\t* @author bhouston / http://clara.io/\n\t*\n\t* This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\n\t*\n\t* References: https://en.wikipedia.org/wiki/Supersampling\n\t*\n\t*/\n\n\tTHREE.SSAARenderPass = function ( scene, camera, clearColor, clearAlpha ) {\n\n\t\tTHREE.Pass.call( this );\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\n\t\tthis.unbiased = true;\n\n\t\t// as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\n\t\tthis.clearColor = ( clearColor !== undefined ) ? clearColor : 0x000000;\n\t\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\n\n\t\tif ( THREE.CopyShader === undefined ) console.error( \"THREE.SSAARenderPass relies on THREE.CopyShader\" );\n\n\t\tvar copyShader = THREE.CopyShader;\n\t\tthis.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );\n\n\t\tthis.copyMaterial = new THREE.ShaderMaterial(\t{\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tpremultipliedAlpha: true,\n\t\t\ttransparent: true,\n\t\t\tblending: THREE.AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\t\t} );\n\n\t\tthis.fsQuad = new THREE.Pass.FullScreenQuad( this.copyMaterial );\n\n\t};\n\n\tTHREE.SSAARenderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\n\t\tconstructor: THREE.SSAARenderPass,\n\n\t\tdispose: function () {\n\n\t\t\tif ( this.sampleRenderTarget ) {\n\n\t\t\t\tthis.sampleRenderTarget.dispose();\n\t\t\t\tthis.sampleRenderTarget = null;\n\n\t\t\t}\n\n\t\t},\n\n\t\tsetSize: function ( width, height ) {\n\n\t\t\tif ( this.sampleRenderTarget )\tthis.sampleRenderTarget.setSize( width, height );\n\n\t\t},\n\n\t\trender: function ( renderer, writeBuffer, readBuffer ) {\n\n\t\t\tif ( ! this.sampleRenderTarget ) {\n\n\t\t\t\tthis.sampleRenderTarget = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );\n\t\t\t\tthis.sampleRenderTarget.texture.name = \"SSAARenderPass.sample\";\n\n\t\t\t}\n\n\t\t\tvar jitterOffsets = THREE.SSAARenderPass.JitterVectors[ Math.max( 0, Math.min( this.sampleLevel, 5 ) ) ];\n\n\t\t\tvar autoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\n\t\t\tvar oldClearColor = renderer.getClearColor().getHex();\n\t\t\tvar oldClearAlpha = renderer.getClearAlpha();\n\n\t\t\tvar baseSampleWeight = 1.0 / jitterOffsets.length;\n\t\t\tvar roundingRange = 1 / 32;\n\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.sampleRenderTarget.texture;\n\n\t\t\tvar width = readBuffer.width, height = readBuffer.height;\n\n\t\t\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\t\t\tfor ( var i = 0; i < jitterOffsets.length; i ++ ) {\n\n\t\t\t\tvar jitterOffset = jitterOffsets[ i ];\n\n\t\t\t\tif ( this.camera.setViewOffset ) {\n\n\t\t\t\t\tthis.camera.setViewOffset( width, height,\n\t\t\t\t\t\tjitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16\n\t\t\t\t\t\twidth, height );\n\n\t\t\t\t}\n\n\t\t\t\tvar sampleWeight = baseSampleWeight;\n\n\t\t\t\tif ( this.unbiased ) {\n\n\t\t\t\t\t// the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n\t\t\t\t\t// The following equation varies the sampleWeight per sample so that it is uniformly distributed\n\t\t\t\t\t// across a range of values whose rounding errors cancel each other out.\n\n\t\t\t\t\tvar uniformCenteredDistribution = ( - 0.5 + ( i + 0.5 ) / jitterOffsets.length );\n\t\t\t\t\tsampleWeight += roundingRange * uniformCenteredDistribution;\n\n\t\t\t\t}\n\n\t\t\t\tthis.copyUniforms[ \"opacity\" ].value = sampleWeight;\n\t\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\n\t\t\t\trenderer.setRenderTarget( this.sampleRenderTarget );\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\t\trenderer.setRenderTarget( this.renderToScreen ? null : writeBuffer );\n\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\trenderer.setClearColor( 0x000000, 0.0 );\n\t\t\t\t\trenderer.clear();\n\n\t\t\t\t}\n\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t}\n\n\t\t\tif ( this.camera.clearViewOffset ) this.camera.clearViewOffset();\n\n\t\t\trenderer.autoClear = autoClear;\n\t\t\trenderer.setClearColor( oldClearColor, oldClearAlpha );\n\n\t\t}\n\n\t} );\n\n\n\t// These jitter vectors are specified in integers because it is easier.\n\t// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n\t// before being used, thus these integers need to be scaled by 1/16.\n\t//\n\t// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\n\tTHREE.SSAARenderPass.JitterVectors = [\n\t\t[\n\t\t\t[ 0, 0 ]\n\t\t],\n\t\t[\n\t\t\t[ 4, 4 ], [ - 4, - 4 ]\n\t\t],\n\t\t[\n\t\t\t[ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]\n\t\t],\n\t\t[\n\t\t\t[ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],\n\t\t\t[ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]\n\t\t],\n\t\t[\n\t\t\t[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],\n\t\t\t[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],\n\t\t\t[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],\n\t\t\t[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]\n\t\t],\n\t\t[\n\t\t\t[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],\n\t\t\t[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],\n\t\t\t[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],\n\t\t\t[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],\n\t\t\t[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],\n\t\t\t[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],\n\t\t\t[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],\n\t\t\t[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]\n\t\t]\n\t];\n\t\n\treturn THREE.SSAARenderPass;\n});\n"]}