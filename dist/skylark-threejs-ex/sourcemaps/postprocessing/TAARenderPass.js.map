{"version":3,"sources":["postprocessing/TAARenderPass.js"],"names":["define","THREE","threex","SSAARenderPass","TAARenderPass","scene","camera","clearColor","clearAlpha","undefined","console","error","call","this","sampleLevel","accumulate","JitterVectors","prototype","Object","assign","create","constructor","render","renderer","writeBuffer","readBuffer","deltaTime","accumulateIndex","jitterOffsets","sampleRenderTarget","WebGLRenderTarget","width","height","params","texture","name","holdRenderTarget","autoClear","sampleWeight","length","copyUniforms","value","numSamplesPerFrame","Math","pow","i","jitterOffset","setViewOffset","setRenderTarget","clear","fsQuad","clearViewOffset","accumulationWeight","postprocessing"],"mappings":";;;;;;;AAAAA,QACI,kBACA,YACA,oBACD,SACCC,EACAC,EACAC,GAEA,aACA,IAAIC,EAAgB,SAAUC,EAAOC,EAAQC,EAAYC,QAC9BC,IAAnBN,GACAO,QAAQC,MAAM,0CAElBR,EAAeS,KAAKC,KAAMR,EAAOC,EAAQC,EAAYC,GACrDK,KAAKC,YAAc,EACnBD,KAAKE,YAAa,GAsEtB,OApEAX,EAAcY,cAAgBb,EAAea,cAC7CZ,EAAca,UAAYC,OAAOC,OAAOD,OAAOE,OAAOjB,EAAec,YACjEI,YAAajB,EACbkB,OAAQ,SAAUC,EAAUC,EAAaC,EAAYC,GACjD,IAAKb,KAAKE,WAGN,OAFAZ,EAAec,UAAUK,OAAOV,KAAKC,KAAMU,EAAUC,EAAaC,EAAYC,QAC9Eb,KAAKc,iBAAmB,GAG5B,IAAIC,EAAgBxB,EAAcY,cAAc,GAC3CH,KAAKgB,qBACNhB,KAAKgB,mBAAqB,IAAI5B,EAAM6B,kBAAkBL,EAAWM,MAAON,EAAWO,OAAQnB,KAAKoB,QAChGpB,KAAKgB,mBAAmBK,QAAQC,KAAO,wBAEtCtB,KAAKuB,mBACNvB,KAAKuB,iBAAmB,IAAInC,EAAM6B,kBAAkBL,EAAWM,MAAON,EAAWO,OAAQnB,KAAKoB,QAC9FpB,KAAKuB,iBAAiBF,QAAQC,KAAO,sBAErCtB,KAAKE,aAAwC,IAA1BF,KAAKc,kBACxBxB,EAAec,UAAUK,OAAOV,KAAKC,KAAMU,EAAUV,KAAKuB,iBAAkBX,EAAYC,GACxFb,KAAKc,gBAAkB,GAE3B,IAAIU,EAAYd,EAASc,UACzBd,EAASc,WAAY,EACrB,IAAIC,EAAe,EAAIV,EAAcW,OACrC,GAAI1B,KAAKc,iBAAmB,GAAKd,KAAKc,gBAAkBC,EAAcW,OAAQ,CAC1E1B,KAAK2B,aAAsB,QAAEC,MAAQH,EACrCzB,KAAK2B,aAAuB,SAAEC,MAAQjB,EAAYU,QAElD,IADA,IAAIQ,EAAqBC,KAAKC,IAAI,EAAG/B,KAAKC,aACjC+B,EAAI,EAAGA,EAAIH,EAAoBG,IAAK,CACzC,IACIC,EAAelB,EADXf,KAAKc,iBAab,GAXId,KAAKP,OAAOyC,eACZlC,KAAKP,OAAOyC,cAActB,EAAWM,MAAON,EAAWO,OAA0B,MAAlBc,EAAa,GAA+B,MAAlBA,EAAa,GAAarB,EAAWM,MAAON,EAAWO,QAEpJT,EAASyB,gBAAgBxB,GACzBD,EAAS0B,QACT1B,EAASD,OAAOT,KAAKR,MAAOQ,KAAKP,QACjCiB,EAASyB,gBAAgBnC,KAAKgB,oBACD,IAAzBhB,KAAKc,iBACLJ,EAAS0B,QACbpC,KAAKqC,OAAO5B,OAAOC,GACnBV,KAAKc,kBACDd,KAAKc,iBAAmBC,EAAcW,OACtC,MAEJ1B,KAAKP,OAAO6C,iBACZtC,KAAKP,OAAO6C,kBAEpB,IAAIC,EAAqBvC,KAAKc,gBAAkBW,EAC5Cc,EAAqB,IACrBvC,KAAK2B,aAAsB,QAAEC,MAAQ,EACrC5B,KAAK2B,aAAuB,SAAEC,MAAQ5B,KAAKgB,mBAAmBK,QAC9DX,EAASyB,gBAAgBxB,GACzBD,EAAS0B,QACTpC,KAAKqC,OAAO5B,OAAOC,IAEnB6B,EAAqB,IACrBvC,KAAK2B,aAAsB,QAAEC,MAAQ,EAAIW,EACzCvC,KAAK2B,aAAuB,SAAEC,MAAQ5B,KAAKuB,iBAAiBF,QAC5DX,EAASyB,gBAAgBxB,GACE,IAAvB4B,GACA7B,EAAS0B,QACbpC,KAAKqC,OAAO5B,OAAOC,IAEvBA,EAASc,UAAYA,KAGtBnC,EAAOmD,eAAejD,cAAgBA","file":"../../postprocessing/TAARenderPass.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\",\n    './SSAARenderPass'\n], function (\n    THREE, \n    threex,\n    SSAARenderPass\n) {\n    'use strict';\n    var TAARenderPass = function (scene, camera, clearColor, clearAlpha) {\n        if (SSAARenderPass === undefined) {\n            console.error('TAARenderPass relies on SSAARenderPass');\n        }\n        SSAARenderPass.call(this, scene, camera, clearColor, clearAlpha);\n        this.sampleLevel = 0;\n        this.accumulate = false;\n    };\n    TAARenderPass.JitterVectors = SSAARenderPass.JitterVectors;\n    TAARenderPass.prototype = Object.assign(Object.create(SSAARenderPass.prototype), {\n        constructor: TAARenderPass,\n        render: function (renderer, writeBuffer, readBuffer, deltaTime) {\n            if (!this.accumulate) {\n                SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, deltaTime);\n                this.accumulateIndex = -1;\n                return;\n            }\n            var jitterOffsets = TAARenderPass.JitterVectors[5];\n            if (!this.sampleRenderTarget) {\n                this.sampleRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n                this.sampleRenderTarget.texture.name = 'TAARenderPass.sample';\n            }\n            if (!this.holdRenderTarget) {\n                this.holdRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n                this.holdRenderTarget.texture.name = 'TAARenderPass.hold';\n            }\n            if (this.accumulate && this.accumulateIndex === -1) {\n                SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);\n                this.accumulateIndex = 0;\n            }\n            var autoClear = renderer.autoClear;\n            renderer.autoClear = false;\n            var sampleWeight = 1 / jitterOffsets.length;\n            if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\n                this.copyUniforms['opacity'].value = sampleWeight;\n                this.copyUniforms['tDiffuse'].value = writeBuffer.texture;\n                var numSamplesPerFrame = Math.pow(2, this.sampleLevel);\n                for (var i = 0; i < numSamplesPerFrame; i++) {\n                    var j = this.accumulateIndex;\n                    var jitterOffset = jitterOffsets[j];\n                    if (this.camera.setViewOffset) {\n                        this.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, readBuffer.width, readBuffer.height);\n                    }\n                    renderer.setRenderTarget(writeBuffer);\n                    renderer.clear();\n                    renderer.render(this.scene, this.camera);\n                    renderer.setRenderTarget(this.sampleRenderTarget);\n                    if (this.accumulateIndex === 0)\n                        renderer.clear();\n                    this.fsQuad.render(renderer);\n                    this.accumulateIndex++;\n                    if (this.accumulateIndex >= jitterOffsets.length)\n                        break;\n                }\n                if (this.camera.clearViewOffset)\n                    this.camera.clearViewOffset();\n            }\n            var accumulationWeight = this.accumulateIndex * sampleWeight;\n            if (accumulationWeight > 0) {\n                this.copyUniforms['opacity'].value = 1;\n                this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\n                renderer.setRenderTarget(writeBuffer);\n                renderer.clear();\n                this.fsQuad.render(renderer);\n            }\n            if (accumulationWeight < 1) {\n                this.copyUniforms['opacity'].value = 1 - accumulationWeight;\n                this.copyUniforms['tDiffuse'].value = this.holdRenderTarget.texture;\n                renderer.setRenderTarget(writeBuffer);\n                if (accumulationWeight === 0)\n                    renderer.clear();\n                this.fsQuad.render(renderer);\n            }\n            renderer.autoClear = autoClear;\n        }\n    });\n    return threex.postprocessing.TAARenderPass = TAARenderPass;\n});"]}