{"version":3,"sources":["postprocessing/TAARenderPass.js"],"names":["define","THREE","TAARenderPass","scene","camera","clearColor","clearAlpha","undefined","SSAARenderPass","console","error","call","this","sampleLevel","accumulate","JitterVectors","prototype","Object","assign","create","constructor","render","renderer","writeBuffer","readBuffer","deltaTime","accumulateIndex","jitterOffsets","sampleRenderTarget","WebGLRenderTarget","width","height","params","texture","name","holdRenderTarget","autoClear","sampleWeight","length","copyUniforms","value","numSamplesPerFrame","Math","pow","i","jitterOffset","setViewOffset","setRenderTarget","clear","fsQuad","clearViewOffset","accumulationWeight"],"mappings":";;;;;;;AAAAA,QACC,kBACA,oBACC,SAASC,GA8IV,OA/HAA,EAAMC,cAAgB,SAAWC,EAAOC,EAAQC,EAAYC,QAE7BC,IAAzBN,EAAMO,gBAEVC,QAAQC,MAAO,sDAIhBT,EAAMO,eAAeG,KAAMC,KAAMT,EAAOC,EAAQC,EAAYC,GAE5DM,KAAKC,YAAc,EACnBD,KAAKE,YAAa,GAInBb,EAAMC,cAAca,cAAgBd,EAAMO,eAAeO,cAEzDd,EAAMC,cAAcc,UAAYC,OAAOC,OAAQD,OAAOE,OAAQlB,EAAMO,eAAeQ,YAElFI,YAAanB,EAAMC,cAEnBmB,OAAQ,SAAWC,EAAUC,EAAaC,EAAYC,GAErD,IAAOb,KAAKE,WAKX,OAHAb,EAAMO,eAAeQ,UAAUK,OAAOV,KAAMC,KAAMU,EAAUC,EAAaC,EAAYC,QAErFb,KAAKc,iBAAoB,GAK1B,IAAIC,EAAgB1B,EAAMC,cAAca,cAAe,GAEhDH,KAAKgB,qBAEXhB,KAAKgB,mBAAqB,IAAI3B,EAAM4B,kBAAmBL,EAAWM,MAAON,EAAWO,OAAQnB,KAAKoB,QACjGpB,KAAKgB,mBAAmBK,QAAQC,KAAO,wBAIjCtB,KAAKuB,mBAEXvB,KAAKuB,iBAAmB,IAAIlC,EAAM4B,kBAAmBL,EAAWM,MAAON,EAAWO,OAAQnB,KAAKoB,QAC/FpB,KAAKuB,iBAAiBF,QAAQC,KAAO,sBAIjCtB,KAAKE,aAAyC,IAA3BF,KAAKc,kBAE5BzB,EAAMO,eAAeQ,UAAUK,OAAOV,KAAMC,KAAMU,EAAUV,KAAKuB,iBAAkBX,EAAYC,GAE/Fb,KAAKc,gBAAkB,GAIxB,IAAIU,EAAYd,EAASc,UACzBd,EAASc,WAAY,EAErB,IAAIC,EAAe,EAAQV,EAAqB,OAEhD,GAAKf,KAAKc,iBAAmB,GAAKd,KAAKc,gBAAkBC,EAAcW,OAAS,CAE/E1B,KAAK2B,aAAwB,QAAEC,MAAQH,EACvCzB,KAAK2B,aAAyB,SAAEC,MAAQjB,EAAYU,QAIpD,IADA,IAAIQ,EAAqBC,KAAKC,IAAK,EAAG/B,KAAKC,aACjC+B,EAAI,EAAGA,EAAIH,EAAoBG,IAAO,CAE/C,IACIC,EAAelB,EADXf,KAAKc,iBAqBb,GAlBKd,KAAKR,OAAO0C,eAEhBlC,KAAKR,OAAO0C,cAAetB,EAAWM,MAAON,EAAWO,OACnC,MAApBc,EAAc,GAAkC,MAApBA,EAAc,GAC1CrB,EAAWM,MAAON,EAAWO,QAI/BT,EAASyB,gBAAiBxB,GAC1BD,EAAS0B,QACT1B,EAASD,OAAQT,KAAKT,MAAOS,KAAKR,QAElCkB,EAASyB,gBAAiBnC,KAAKgB,oBACD,IAAzBhB,KAAKc,iBAAwBJ,EAAS0B,QAC3CpC,KAAKqC,OAAO5B,OAAQC,GAEpBV,KAAKc,kBAEAd,KAAKc,iBAAmBC,EAAcW,OAAS,MAIhD1B,KAAKR,OAAO8C,iBAAkBtC,KAAKR,OAAO8C,kBAIhD,IAAIC,EAAqBvC,KAAKc,gBAAkBW,EAE3Cc,EAAqB,IAEzBvC,KAAK2B,aAAwB,QAAEC,MAAQ,EACvC5B,KAAK2B,aAAyB,SAAEC,MAAQ5B,KAAKgB,mBAAmBK,QAChEX,EAASyB,gBAAiBxB,GAC1BD,EAAS0B,QACTpC,KAAKqC,OAAO5B,OAAQC,IAIhB6B,EAAqB,IAEzBvC,KAAK2B,aAAwB,QAAEC,MAAQ,EAAMW,EAC7CvC,KAAK2B,aAAyB,SAAEC,MAAQ5B,KAAKuB,iBAAiBF,QAC9DX,EAASyB,gBAAiBxB,GACE,IAAvB4B,GAA2B7B,EAAS0B,QACzCpC,KAAKqC,OAAO5B,OAAQC,IAIrBA,EAASc,UAAYA,KAMhBnC,EAAMC","file":"../../postprocessing/TAARenderPass.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"./SSAARenderPass\"\n],function(THREE){\n\t/**\n\t *\n\t * Temporal Anti-Aliasing Render Pass\n\t *\n\t * @author bhouston / http://clara.io/\n\t *\n\t * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\n\t *\n\t * References:\n\t *\n\t * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\n\t *\n\t */\n\n\tTHREE.TAARenderPass = function ( scene, camera, clearColor, clearAlpha ) {\n\n\t\tif ( THREE.SSAARenderPass === undefined ) {\n\n\t\t\tconsole.error( \"THREE.TAARenderPass relies on THREE.SSAARenderPass\" );\n\n\t\t}\n\n\t\tTHREE.SSAARenderPass.call( this, scene, camera, clearColor, clearAlpha );\n\n\t\tthis.sampleLevel = 0;\n\t\tthis.accumulate = false;\n\n\t};\n\n\tTHREE.TAARenderPass.JitterVectors = THREE.SSAARenderPass.JitterVectors;\n\n\tTHREE.TAARenderPass.prototype = Object.assign( Object.create( THREE.SSAARenderPass.prototype ), {\n\n\t\tconstructor: THREE.TAARenderPass,\n\n\t\trender: function ( renderer, writeBuffer, readBuffer, deltaTime ) {\n\n\t\t\tif ( ! this.accumulate ) {\n\n\t\t\t\tTHREE.SSAARenderPass.prototype.render.call( this, renderer, writeBuffer, readBuffer, deltaTime );\n\n\t\t\t\tthis.accumulateIndex = - 1;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar jitterOffsets = THREE.TAARenderPass.JitterVectors[ 5 ];\n\n\t\t\tif ( ! this.sampleRenderTarget ) {\n\n\t\t\t\tthis.sampleRenderTarget = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height, this.params );\n\t\t\t\tthis.sampleRenderTarget.texture.name = \"TAARenderPass.sample\";\n\n\t\t\t}\n\n\t\t\tif ( ! this.holdRenderTarget ) {\n\n\t\t\t\tthis.holdRenderTarget = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height, this.params );\n\t\t\t\tthis.holdRenderTarget.texture.name = \"TAARenderPass.hold\";\n\n\t\t\t}\n\n\t\t\tif ( this.accumulate && this.accumulateIndex === - 1 ) {\n\n\t\t\t\tTHREE.SSAARenderPass.prototype.render.call( this, renderer, this.holdRenderTarget, readBuffer, deltaTime );\n\n\t\t\t\tthis.accumulateIndex = 0;\n\n\t\t\t}\n\n\t\t\tvar autoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\n\t\t\tvar sampleWeight = 1.0 / ( jitterOffsets.length );\n\n\t\t\tif ( this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length ) {\n\n\t\t\t\tthis.copyUniforms[ \"opacity\" ].value = sampleWeight;\n\t\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = writeBuffer.texture;\n\n\t\t\t\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\t\t\t\tvar numSamplesPerFrame = Math.pow( 2, this.sampleLevel );\n\t\t\t\tfor ( var i = 0; i < numSamplesPerFrame; i ++ ) {\n\n\t\t\t\t\tvar j = this.accumulateIndex;\n\t\t\t\t\tvar jitterOffset = jitterOffsets[ j ];\n\n\t\t\t\t\tif ( this.camera.setViewOffset ) {\n\n\t\t\t\t\t\tthis.camera.setViewOffset( readBuffer.width, readBuffer.height,\n\t\t\t\t\t\t\tjitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16\n\t\t\t\t\t\t\treadBuffer.width, readBuffer.height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t\t\trenderer.clear();\n\t\t\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\t\t\trenderer.setRenderTarget( this.sampleRenderTarget );\n\t\t\t\t\tif ( this.accumulateIndex === 0 ) renderer.clear();\n\t\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t\t\tthis.accumulateIndex ++;\n\n\t\t\t\t\tif ( this.accumulateIndex >= jitterOffsets.length ) break;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.camera.clearViewOffset ) this.camera.clearViewOffset();\n\n\t\t\t}\n\n\t\t\tvar accumulationWeight = this.accumulateIndex * sampleWeight;\n\n\t\t\tif ( accumulationWeight > 0 ) {\n\n\t\t\t\tthis.copyUniforms[ \"opacity\" ].value = 1.0;\n\t\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.sampleRenderTarget.texture;\n\t\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t\trenderer.clear();\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t}\n\n\t\t\tif ( accumulationWeight < 1.0 ) {\n\n\t\t\t\tthis.copyUniforms[ \"opacity\" ].value = 1.0 - accumulationWeight;\n\t\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.holdRenderTarget.texture;\n\t\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t\tif ( accumulationWeight === 0 ) renderer.clear();\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t}\n\n\t\t\trenderer.autoClear = autoClear;\n\n\t\t}\n\n\t} );\n\n\treturn THREE.TAARenderPass;\n});"]}