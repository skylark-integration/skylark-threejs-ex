{"version":3,"sources":["postprocessing/TAARenderPass.js"],"names":["define","THREE","threex","SSAARenderPass","TAARenderPass","scene","camera","clearColor","clearAlpha","undefined","console","error","call","this","sampleLevel","accumulate","JitterVectors","prototype","Object","assign","create","constructor","render","renderer","writeBuffer","readBuffer","deltaTime","accumulateIndex","jitterOffsets","sampleRenderTarget","WebGLRenderTarget","width","height","params","texture","name","holdRenderTarget","autoClear","sampleWeight","length","copyUniforms","value","numSamplesPerFrame","Math","pow","i","jitterOffset","setViewOffset","setRenderTarget","clear","fsQuad","clearViewOffset","accumulationWeight","postprocessing"],"mappings":";;;;;;;AAAAA,QACI,kBACA,YACA,oBACD,SACCC,EACAC,EACAC,GAEA,aACA,IAAIC,EAAgB,SAAUC,EAAOC,EAAQC,EAAYC,QAC9BC,IAAnBN,GACAO,QAAQC,MAAM,0CAElBR,EAAeS,KAAKC,KAAMR,EAAOC,EAAQC,EAAYC,GACrDK,KAAKC,YAAc,EACnBD,KAAKE,YAAa,GAsEtB,OApEAX,EAAcY,cAAgBb,EAAea,cAC7CZ,EAAca,UAAYC,OAAOC,OAAOD,OAAOE,OAAOjB,EAAec,YACjEI,YAAajB,EACbkB,OAAQ,SAAUC,EAAUC,EAAaC,EAAYC,GACjD,IAAKb,KAAKE,WAGN,OAFAZ,EAAec,UAAUK,OAAOV,KAAKC,KAAMU,EAAUC,EAAaC,EAAYC,QAC9Eb,KAAKc,iBAAmB,GAG5B,IAAIC,EAAgBxB,EAAcY,cAAc,GAC3CH,KAAKgB,qBACNhB,KAAKgB,mBAAqB,IAAI5B,EAAM6B,kBAAkBL,EAAWM,MAAON,EAAWO,OAAQnB,KAAKoB,QAChGpB,KAAKgB,mBAAmBK,QAAQC,KAAO,wBAEtCtB,KAAKuB,mBACNvB,KAAKuB,iBAAmB,IAAInC,EAAM6B,kBAAkBL,EAAWM,MAAON,EAAWO,OAAQnB,KAAKoB,QAC9FpB,KAAKuB,iBAAiBF,QAAQC,KAAO,sBAErCtB,KAAKE,aAAwC,IAA1BF,KAAKc,kBACxBxB,EAAec,UAAUK,OAAOV,KAAKC,KAAMU,EAAUV,KAAKuB,iBAAkBX,EAAYC,GACxFb,KAAKc,gBAAkB,GAE3B,IAAIU,EAAYd,EAASc,UACzBd,EAASc,WAAY,EACrB,IAAIC,EAAe,EAAIV,EAAcW,OACrC,GAAI1B,KAAKc,iBAAmB,GAAKd,KAAKc,gBAAkBC,EAAcW,OAAQ,CAC1E1B,KAAK2B,aAAsB,QAAEC,MAAQH,EACrCzB,KAAK2B,aAAuB,SAAEC,MAAQjB,EAAYU,QAElD,IADA,IAAIQ,EAAqBC,KAAKC,IAAI,EAAG/B,KAAKC,aACjC+B,EAAI,EAAGA,EAAIH,EAAoBG,IAAK,CACzC,IACIC,EAAelB,EADXf,KAAKc,iBAab,GAXId,KAAKP,OAAOyC,eACZlC,KAAKP,OAAOyC,cAActB,EAAWM,MAAON,EAAWO,OAA0B,MAAlBc,EAAa,GAA+B,MAAlBA,EAAa,GAAarB,EAAWM,MAAON,EAAWO,QAEpJT,EAASyB,gBAAgBxB,GACzBD,EAAS0B,QACT1B,EAASD,OAAOT,KAAKR,MAAOQ,KAAKP,QACjCiB,EAASyB,gBAAgBnC,KAAKgB,oBACD,IAAzBhB,KAAKc,iBACLJ,EAAS0B,QACbpC,KAAKqC,OAAO5B,OAAOC,GACnBV,KAAKc,kBACDd,KAAKc,iBAAmBC,EAAcW,OACtC,MAEJ1B,KAAKP,OAAO6C,iBACZtC,KAAKP,OAAO6C,kBAEpB,IAAIC,EAAqBvC,KAAKc,gBAAkBW,EAC5Cc,EAAqB,IACrBvC,KAAK2B,aAAsB,QAAEC,MAAQ,EACrC5B,KAAK2B,aAAuB,SAAEC,MAAQ5B,KAAKgB,mBAAmBK,QAC9DX,EAASyB,gBAAgBxB,GACzBD,EAAS0B,QACTpC,KAAKqC,OAAO5B,OAAOC,IAEnB6B,EAAqB,IACrBvC,KAAK2B,aAAsB,QAAEC,MAAQ,EAAIW,EACzCvC,KAAK2B,aAAuB,SAAEC,MAAQ5B,KAAKuB,iBAAiBF,QAC5DX,EAASyB,gBAAgBxB,GACE,IAAvB4B,GACA7B,EAAS0B,QACbpC,KAAKqC,OAAO5B,OAAOC,IAEvBA,EAASc,UAAYA,KAGtBnC,EAAOmD,eAAejD,cAAgBA","file":"../../postprocessing/TAARenderPass.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\",\r\n    './SSAARenderPass'\r\n], function (\r\n    THREE, \r\n    threex,\r\n    SSAARenderPass\r\n) {\r\n    'use strict';\r\n    var TAARenderPass = function (scene, camera, clearColor, clearAlpha) {\r\n        if (SSAARenderPass === undefined) {\r\n            console.error('TAARenderPass relies on SSAARenderPass');\r\n        }\r\n        SSAARenderPass.call(this, scene, camera, clearColor, clearAlpha);\r\n        this.sampleLevel = 0;\r\n        this.accumulate = false;\r\n    };\r\n    TAARenderPass.JitterVectors = SSAARenderPass.JitterVectors;\r\n    TAARenderPass.prototype = Object.assign(Object.create(SSAARenderPass.prototype), {\r\n        constructor: TAARenderPass,\r\n        render: function (renderer, writeBuffer, readBuffer, deltaTime) {\r\n            if (!this.accumulate) {\r\n                SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, deltaTime);\r\n                this.accumulateIndex = -1;\r\n                return;\r\n            }\r\n            var jitterOffsets = TAARenderPass.JitterVectors[5];\r\n            if (!this.sampleRenderTarget) {\r\n                this.sampleRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\r\n                this.sampleRenderTarget.texture.name = 'TAARenderPass.sample';\r\n            }\r\n            if (!this.holdRenderTarget) {\r\n                this.holdRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\r\n                this.holdRenderTarget.texture.name = 'TAARenderPass.hold';\r\n            }\r\n            if (this.accumulate && this.accumulateIndex === -1) {\r\n                SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);\r\n                this.accumulateIndex = 0;\r\n            }\r\n            var autoClear = renderer.autoClear;\r\n            renderer.autoClear = false;\r\n            var sampleWeight = 1 / jitterOffsets.length;\r\n            if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\r\n                this.copyUniforms['opacity'].value = sampleWeight;\r\n                this.copyUniforms['tDiffuse'].value = writeBuffer.texture;\r\n                var numSamplesPerFrame = Math.pow(2, this.sampleLevel);\r\n                for (var i = 0; i < numSamplesPerFrame; i++) {\r\n                    var j = this.accumulateIndex;\r\n                    var jitterOffset = jitterOffsets[j];\r\n                    if (this.camera.setViewOffset) {\r\n                        this.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, readBuffer.width, readBuffer.height);\r\n                    }\r\n                    renderer.setRenderTarget(writeBuffer);\r\n                    renderer.clear();\r\n                    renderer.render(this.scene, this.camera);\r\n                    renderer.setRenderTarget(this.sampleRenderTarget);\r\n                    if (this.accumulateIndex === 0)\r\n                        renderer.clear();\r\n                    this.fsQuad.render(renderer);\r\n                    this.accumulateIndex++;\r\n                    if (this.accumulateIndex >= jitterOffsets.length)\r\n                        break;\r\n                }\r\n                if (this.camera.clearViewOffset)\r\n                    this.camera.clearViewOffset();\r\n            }\r\n            var accumulationWeight = this.accumulateIndex * sampleWeight;\r\n            if (accumulationWeight > 0) {\r\n                this.copyUniforms['opacity'].value = 1;\r\n                this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\r\n                renderer.setRenderTarget(writeBuffer);\r\n                renderer.clear();\r\n                this.fsQuad.render(renderer);\r\n            }\r\n            if (accumulationWeight < 1) {\r\n                this.copyUniforms['opacity'].value = 1 - accumulationWeight;\r\n                this.copyUniforms['tDiffuse'].value = this.holdRenderTarget.texture;\r\n                renderer.setRenderTarget(writeBuffer);\r\n                if (accumulationWeight === 0)\r\n                    renderer.clear();\r\n                this.fsQuad.render(renderer);\r\n            }\r\n            renderer.autoClear = autoClear;\r\n        }\r\n    });\r\n    return threex.postprocessing.TAARenderPass = TAARenderPass;\r\n});"]}