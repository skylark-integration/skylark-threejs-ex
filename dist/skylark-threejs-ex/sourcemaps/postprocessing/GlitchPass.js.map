{"version":3,"sources":["postprocessing/GlitchPass.js"],"names":["define","THREE","threex","Pass","DigitalGlitch","GlitchPass","dt_size","call","this","undefined","console","error","shader","uniforms","UniformsUtils","clone","value","generateHeightmap","material","ShaderMaterial","vertexShader","fragmentShader","fsQuad","FullScreenQuad","goWild","curF","generateTrigger","prototype","Object","assign","create","constructor","render","renderer","writeBuffer","readBuffer","texture","Math","random","randX","MathUtils","randFloat","PI","renderToScreen","setRenderTarget","clear","randInt","data_arr","Float32Array","length","i","val","DataTexture","RGBFormat","FloatType","postprocessing"],"mappings":"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","file":"../../postprocessing/GlitchPass.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\",\n    './Pass',\n    '../shaders/DigitalGlitch'\n], function (\n    THREE, \n    threex,\n    Pass, \n    DigitalGlitch\n) {\n    'use strict';\n    var GlitchPass = function (dt_size) {\n        Pass.call(this);\n        if (DigitalGlitch === undefined)\n            console.error('GlitchPass relies on DigitalGlitch');\n        var shader = DigitalGlitch;\n        this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n        if (dt_size == undefined)\n            dt_size = 64;\n        this.uniforms['tDisp'].value = this.generateHeightmap(dt_size);\n        this.material = new THREE.ShaderMaterial({\n            uniforms: this.uniforms,\n            vertexShader: shader.vertexShader,\n            fragmentShader: shader.fragmentShader\n        });\n        this.fsQuad = new Pass.FullScreenQuad(this.material);\n        this.goWild = false;\n        this.curF = 0;\n        this.generateTrigger();\n    };\n    GlitchPass.prototype = Object.assign(Object.create(Pass.prototype), {\n        constructor: GlitchPass,\n        render: function (renderer, writeBuffer, readBuffer) {\n            this.uniforms['tDiffuse'].value = readBuffer.texture;\n            this.uniforms['seed'].value = Math.random();\n            this.uniforms['byp'].value = 0;\n            if (this.curF % this.randX == 0 || this.goWild == true) {\n                this.uniforms['amount'].value = Math.random() / 30;\n                this.uniforms['angle'].value = THREE.MathUtils.randFloat(-Math.PI, Math.PI);\n                this.uniforms['seed_x'].value = THREE.MathUtils.randFloat(-1, 1);\n                this.uniforms['seed_y'].value = THREE.MathUtils.randFloat(-1, 1);\n                this.uniforms['distortion_x'].value = THREE.MathUtils.randFloat(0, 1);\n                this.uniforms['distortion_y'].value = THREE.MathUtils.randFloat(0, 1);\n                this.curF = 0;\n                this.generateTrigger();\n            } else if (this.curF % this.randX < this.randX / 5) {\n                this.uniforms['amount'].value = Math.random() / 90;\n                this.uniforms['angle'].value = THREE.MathUtils.randFloat(-Math.PI, Math.PI);\n                this.uniforms['distortion_x'].value = THREE.MathUtils.randFloat(0, 1);\n                this.uniforms['distortion_y'].value = THREE.MathUtils.randFloat(0, 1);\n                this.uniforms['seed_x'].value = THREE.MathUtils.randFloat(-0.3, 0.3);\n                this.uniforms['seed_y'].value = THREE.MathUtils.randFloat(-0.3, 0.3);\n            } else if (this.goWild == false) {\n                this.uniforms['byp'].value = 1;\n            }\n            this.curF++;\n            if (this.renderToScreen) {\n                renderer.setRenderTarget(null);\n                this.fsQuad.render(renderer);\n            } else {\n                renderer.setRenderTarget(writeBuffer);\n                if (this.clear)\n                    renderer.clear();\n                this.fsQuad.render(renderer);\n            }\n        },\n        generateTrigger: function () {\n            this.randX = THREE.MathUtils.randInt(120, 240);\n        },\n        generateHeightmap: function (dt_size) {\n            var data_arr = new Float32Array(dt_size * dt_size * 3);\n            var length = dt_size * dt_size;\n            for (var i = 0; i < length; i++) {\n                var val = THREE.MathUtils.randFloat(0, 1);\n                data_arr[i * 3 + 0] = val;\n                data_arr[i * 3 + 1] = val;\n                data_arr[i * 3 + 2] = val;\n            }\n            return new THREE.DataTexture(data_arr, dt_size, dt_size, THREE.RGBFormat, THREE.FloatType);\n        }\n    });\n    return threex.postprocessing.GlitchPass = GlitchPass;\n});"]}