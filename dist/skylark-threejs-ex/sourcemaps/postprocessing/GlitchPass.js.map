{"version":3,"sources":["postprocessing/GlitchPass.js"],"names":["define","THREE","threex","Pass","DigitalGlitch","GlitchPass","dt_size","call","this","undefined","console","error","shader","uniforms","UniformsUtils","clone","value","generateHeightmap","material","ShaderMaterial","vertexShader","fragmentShader","fsQuad","FullScreenQuad","goWild","curF","generateTrigger","prototype","Object","assign","create","constructor","render","renderer","writeBuffer","readBuffer","texture","Math","random","randX","MathUtils","randFloat","PI","renderToScreen","setRenderTarget","clear","randInt","data_arr","Float32Array","length","i","val","DataTexture","RGBFormat","FloatType","postprocessing"],"mappings":"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","file":"../../postprocessing/GlitchPass.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\",\r\n    './Pass',\r\n    '../shaders/DigitalGlitch'\r\n], function (\r\n    THREE, \r\n    threex,\r\n    Pass, \r\n    DigitalGlitch\r\n) {\r\n    'use strict';\r\n    var GlitchPass = function (dt_size) {\r\n        Pass.call(this);\r\n        if (DigitalGlitch === undefined)\r\n            console.error('GlitchPass relies on DigitalGlitch');\r\n        var shader = DigitalGlitch;\r\n        this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\r\n        if (dt_size == undefined)\r\n            dt_size = 64;\r\n        this.uniforms['tDisp'].value = this.generateHeightmap(dt_size);\r\n        this.material = new THREE.ShaderMaterial({\r\n            uniforms: this.uniforms,\r\n            vertexShader: shader.vertexShader,\r\n            fragmentShader: shader.fragmentShader\r\n        });\r\n        this.fsQuad = new Pass.FullScreenQuad(this.material);\r\n        this.goWild = false;\r\n        this.curF = 0;\r\n        this.generateTrigger();\r\n    };\r\n    GlitchPass.prototype = Object.assign(Object.create(Pass.prototype), {\r\n        constructor: GlitchPass,\r\n        render: function (renderer, writeBuffer, readBuffer) {\r\n            this.uniforms['tDiffuse'].value = readBuffer.texture;\r\n            this.uniforms['seed'].value = Math.random();\r\n            this.uniforms['byp'].value = 0;\r\n            if (this.curF % this.randX == 0 || this.goWild == true) {\r\n                this.uniforms['amount'].value = Math.random() / 30;\r\n                this.uniforms['angle'].value = THREE.MathUtils.randFloat(-Math.PI, Math.PI);\r\n                this.uniforms['seed_x'].value = THREE.MathUtils.randFloat(-1, 1);\r\n                this.uniforms['seed_y'].value = THREE.MathUtils.randFloat(-1, 1);\r\n                this.uniforms['distortion_x'].value = THREE.MathUtils.randFloat(0, 1);\r\n                this.uniforms['distortion_y'].value = THREE.MathUtils.randFloat(0, 1);\r\n                this.curF = 0;\r\n                this.generateTrigger();\r\n            } else if (this.curF % this.randX < this.randX / 5) {\r\n                this.uniforms['amount'].value = Math.random() / 90;\r\n                this.uniforms['angle'].value = THREE.MathUtils.randFloat(-Math.PI, Math.PI);\r\n                this.uniforms['distortion_x'].value = THREE.MathUtils.randFloat(0, 1);\r\n                this.uniforms['distortion_y'].value = THREE.MathUtils.randFloat(0, 1);\r\n                this.uniforms['seed_x'].value = THREE.MathUtils.randFloat(-0.3, 0.3);\r\n                this.uniforms['seed_y'].value = THREE.MathUtils.randFloat(-0.3, 0.3);\r\n            } else if (this.goWild == false) {\r\n                this.uniforms['byp'].value = 1;\r\n            }\r\n            this.curF++;\r\n            if (this.renderToScreen) {\r\n                renderer.setRenderTarget(null);\r\n                this.fsQuad.render(renderer);\r\n            } else {\r\n                renderer.setRenderTarget(writeBuffer);\r\n                if (this.clear)\r\n                    renderer.clear();\r\n                this.fsQuad.render(renderer);\r\n            }\r\n        },\r\n        generateTrigger: function () {\r\n            this.randX = THREE.MathUtils.randInt(120, 240);\r\n        },\r\n        generateHeightmap: function (dt_size) {\r\n            var data_arr = new Float32Array(dt_size * dt_size * 3);\r\n            var length = dt_size * dt_size;\r\n            for (var i = 0; i < length; i++) {\r\n                var val = THREE.MathUtils.randFloat(0, 1);\r\n                data_arr[i * 3 + 0] = val;\r\n                data_arr[i * 3 + 1] = val;\r\n                data_arr[i * 3 + 2] = val;\r\n            }\r\n            return new THREE.DataTexture(data_arr, dt_size, dt_size, THREE.RGBFormat, THREE.FloatType);\r\n        }\r\n    });\r\n    return threex.postprocessing.GlitchPass = GlitchPass;\r\n});"]}