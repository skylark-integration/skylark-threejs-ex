{"version":3,"sources":["helpers/LightProbeHelper.js"],"names":["define","THREE","threex","LightProbeHelper","lightProbe","size","this","material","ShaderMaterial","type","uniforms","sh","value","coefficients","intensity","vertexShader","join","fragmentShader","geometry","SphereBufferGeometry","Mesh","call","onBeforeRender","prototype","Object","create","constructor","dispose","position","copy","scale","set","multiplyScalar","helpers"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aACA,SAASC,EAAiBC,EAAYC,GAClCC,KAAKF,WAAaA,EAClBE,KAAKD,KAAOA,EACZ,IAAIE,EAAW,IAAIN,EAAMO,gBACrBC,KAAM,2BACNC,UACIC,IAAMC,MAAON,KAAKF,WAAWO,GAAGE,cAChCC,WAAaF,MAAON,KAAKF,WAAWU,YAExCC,cACI,wBACA,gBACA,kDACA,8EACA,KACFC,KAAK,MACPC,gBACI,oCACA,qEACA,0CACA,8DACA,IACA,oEACA,0EACA,6CACA,oDACA,cACA,kDACA,cACA,wDACA,wDACA,wDACA,cACA,4DACA,4DACA,qEACA,4DACA,kEACA,mBACA,IACA,2CACA,oDACA,wBACA,gBACA,wCACA,wEACA,4DACA,iEACA,sEACA,KACFD,KAAK,QAEPE,EAAW,IAAIjB,EAAMkB,qBAAqB,EAAG,GAAI,IACrDlB,EAAMmB,KAAKC,KAAKf,KAAMY,EAAUX,GAChCD,KAAKgB,iBAcT,OAZAnB,EAAiBoB,UAAYC,OAAOC,OAAOxB,EAAMmB,KAAKG,WACtDpB,EAAiBoB,UAAUG,YAAcvB,EACzCA,EAAiBoB,UAAUI,QAAU,WACjCrB,KAAKY,SAASS,UACdrB,KAAKC,SAASoB,WAElBxB,EAAiBoB,UAAUD,eAAiB,WACxChB,KAAKsB,SAASC,KAAKvB,KAAKF,WAAWwB,UACnCtB,KAAKwB,MAAMC,IAAI,EAAG,EAAG,GAAGC,eAAe1B,KAAKD,MAC5CC,KAAKC,SAASG,SAASI,UAAUF,MAAQN,KAAKF,WAAWU,WAGtDZ,EAAO+B,QAAQ9B,iBAAmBA","file":"../../helpers/LightProbeHelper.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    function LightProbeHelper(lightProbe, size) {\r\n        this.lightProbe = lightProbe;\r\n        this.size = size;\r\n        var material = new THREE.ShaderMaterial({\r\n            type: 'LightProbeHelperMaterial',\r\n            uniforms: {\r\n                sh: { value: this.lightProbe.sh.coefficients },\r\n                intensity: { value: this.lightProbe.intensity }\r\n            },\r\n            vertexShader: [\r\n                'varying vec3 vNormal;',\r\n                'void main() {',\r\n                '\\tvNormal = normalize( normalMatrix * normal );',\r\n                '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n                '}'\r\n            ].join('\\n'),\r\n            fragmentShader: [\r\n                '#define RECIPROCAL_PI 0.318309886',\r\n                'vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {',\r\n                '\\t// matrix is assumed to be orthogonal',\r\n                '\\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );',\r\n                '}',\r\n                '// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf',\r\n                'vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {',\r\n                '\\t// normal is assumed to have unit length',\r\n                '\\tfloat x = normal.x, y = normal.y, z = normal.z;',\r\n                '\\t// band 0',\r\n                '\\tvec3 result = shCoefficients[ 0 ] * 0.886227;',\r\n                '\\t// band 1',\r\n                '\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;',\r\n                '\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;',\r\n                '\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;',\r\n                '\\t// band 2',\r\n                '\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;',\r\n                '\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;',\r\n                '\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );',\r\n                '\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;',\r\n                '\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );',\r\n                '\\treturn result;',\r\n                '}',\r\n                'uniform vec3 sh[ 9 ]; // sh coefficients',\r\n                'uniform float intensity; // light probe intensity',\r\n                'varying vec3 vNormal;',\r\n                'void main() {',\r\n                '\\tvec3 normal = normalize( vNormal );',\r\n                '\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );',\r\n                '\\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );',\r\n                '\\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;',\r\n                '\\tgl_FragColor = linearToOutputTexel( vec4( outgoingLight, 1.0 ) );',\r\n                '}'\r\n            ].join('\\n')\r\n        });\r\n        var geometry = new THREE.SphereBufferGeometry(1, 32, 16);\r\n        THREE.Mesh.call(this, geometry, material);\r\n        this.onBeforeRender();\r\n    }\r\n    LightProbeHelper.prototype = Object.create(THREE.Mesh.prototype);\r\n    LightProbeHelper.prototype.constructor = LightProbeHelper;\r\n    LightProbeHelper.prototype.dispose = function () {\r\n        this.geometry.dispose();\r\n        this.material.dispose();\r\n    };\r\n    LightProbeHelper.prototype.onBeforeRender = function () {\r\n        this.position.copy(this.lightProbe.position);\r\n        this.scale.set(1, 1, 1).multiplyScalar(this.size);\r\n        this.material.uniforms.intensity.value = this.lightProbe.intensity;\r\n    };\r\n    \r\n    return threex.helpers.LightProbeHelper = LightProbeHelper;\r\n});"]}