{"version":3,"sources":["helpers/LightProbeHelper.js"],"names":["define","THREE","LightProbeHelper","lightProbe","size","this","material","ShaderMaterial","type","uniforms","sh","value","coefficients","intensity","vertexShader","join","fragmentShader","geometry","SphereBufferGeometry","Mesh","call","onBeforeRender","prototype","Object","create","constructor","dispose","position","copy","scale","set","multiplyScalar"],"mappings":";;;;;;;AAAAA,QACI,mBACD,SAAUC,GACT,aACA,SAASC,EAAiBC,EAAYC,GAClCC,KAAKF,WAAaA,EAClBE,KAAKD,KAAOA,EACZ,IAAIE,EAAW,IAAIL,EAAMM,gBACrBC,KAAM,2BACNC,UACIC,IAAMC,MAAON,KAAKF,WAAWO,GAAGE,cAChCC,WAAaF,MAAON,KAAKF,WAAWU,YAExCC,cACI,wBACA,gBACA,kDACA,8EACA,KACFC,KAAK,MACPC,gBACI,oCACA,qEACA,0CACA,8DACA,IACA,oEACA,0EACA,6CACA,oDACA,cACA,kDACA,cACA,wDACA,wDACA,wDACA,cACA,4DACA,4DACA,qEACA,4DACA,kEACA,mBACA,IACA,2CACA,oDACA,wBACA,gBACA,wCACA,wEACA,4DACA,iEACA,sEACA,KACFD,KAAK,QAEPE,EAAW,IAAIhB,EAAMiB,qBAAqB,EAAG,GAAI,IACrDjB,EAAMkB,KAAKC,KAAKf,KAAMY,EAAUX,GAChCD,KAAKgB,iBAcT,OAZAnB,EAAiBoB,UAAYC,OAAOC,OAAOvB,EAAMkB,KAAKG,WACtDpB,EAAiBoB,UAAUG,YAAcvB,EACzCA,EAAiBoB,UAAUI,QAAU,WACjCrB,KAAKY,SAASS,UACdrB,KAAKC,SAASoB,WAElBxB,EAAiBoB,UAAUD,eAAiB,WACxChB,KAAKsB,SAASC,KAAKvB,KAAKF,WAAWwB,UACnCtB,KAAKwB,MAAMC,IAAI,EAAG,EAAG,GAAGC,eAAe1B,KAAKD,MAC5CC,KAAKC,SAASG,SAASI,UAAUF,MAAQN,KAAKF,WAAWU,WAGtDX","file":"../../helpers/LightProbeHelper.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    function LightProbeHelper(lightProbe, size) {\n        this.lightProbe = lightProbe;\n        this.size = size;\n        var material = new THREE.ShaderMaterial({\n            type: 'LightProbeHelperMaterial',\n            uniforms: {\n                sh: { value: this.lightProbe.sh.coefficients },\n                intensity: { value: this.lightProbe.intensity }\n            },\n            vertexShader: [\n                'varying vec3 vNormal;',\n                'void main() {',\n                '\\tvNormal = normalize( normalMatrix * normal );',\n                '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n                '}'\n            ].join('\\n'),\n            fragmentShader: [\n                '#define RECIPROCAL_PI 0.318309886',\n                'vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {',\n                '\\t// matrix is assumed to be orthogonal',\n                '\\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );',\n                '}',\n                '// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf',\n                'vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {',\n                '\\t// normal is assumed to have unit length',\n                '\\tfloat x = normal.x, y = normal.y, z = normal.z;',\n                '\\t// band 0',\n                '\\tvec3 result = shCoefficients[ 0 ] * 0.886227;',\n                '\\t// band 1',\n                '\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;',\n                '\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;',\n                '\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;',\n                '\\t// band 2',\n                '\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;',\n                '\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;',\n                '\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );',\n                '\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;',\n                '\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );',\n                '\\treturn result;',\n                '}',\n                'uniform vec3 sh[ 9 ]; // sh coefficients',\n                'uniform float intensity; // light probe intensity',\n                'varying vec3 vNormal;',\n                'void main() {',\n                '\\tvec3 normal = normalize( vNormal );',\n                '\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );',\n                '\\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );',\n                '\\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;',\n                '\\tgl_FragColor = linearToOutputTexel( vec4( outgoingLight, 1.0 ) );',\n                '}'\n            ].join('\\n')\n        });\n        var geometry = new THREE.SphereBufferGeometry(1, 32, 16);\n        THREE.Mesh.call(this, geometry, material);\n        this.onBeforeRender();\n    }\n    LightProbeHelper.prototype = Object.create(THREE.Mesh.prototype);\n    LightProbeHelper.prototype.constructor = LightProbeHelper;\n    LightProbeHelper.prototype.dispose = function () {\n        this.geometry.dispose();\n        this.material.dispose();\n    };\n    LightProbeHelper.prototype.onBeforeRender = function () {\n        this.position.copy(this.lightProbe.position);\n        this.scale.set(1, 1, 1).multiplyScalar(this.size);\n        this.material.uniforms.intensity.value = this.lightProbe.intensity;\n    };\n    \n    return LightProbeHelper;\n});"]}