{"version":3,"sources":["utils/SkeletonUtils.js"],"names":["define","THREE","threex","targetParentPos","targetPos","sourceParentPos","sourcePos","targetDir","sourceDir","pos","quat","scale","bindBoneMatrix","relativeMatrix","globalMatrix","SkeletonUtils","retarget","Vector3","Quaternion","Matrix4","target","source","options","preserveMatrix","undefined","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","bindBones","bone","name","boneTo","bonesPosition","i","sourceBones","isObject3D","skeleton","bones","this","getBones","pose","length","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","getInverse","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","positionOffset","boneData","j","numFrames","Math","round","duration","delta","convertedTracks","mixer","AnimationMixer","boneDatas","clipAction","play","update","time","times","Float32Array","values","sub","toArray","VectorKeyframeTrack","QuaternionKeyframeTrack","uncacheAction","AnimationClip","SkeletonHelper","getSkeletonOffsets","Vector2","nameKeys","Object","keys","nameValues","boneParent","getNearestBone","boneToParent","setFromMatrixPosition","subVectors","normalize","laterialAngle","angle","offset","makeRotationFromEuler","Euler","renameBones","Array","isArray","findBoneTrackData","tracks","regexp","result","trackData","exec","getEqualsBonesNames","targetSkeleton","targetBones","search","boneName","sourceLookup","Map","cloneLookup","parallelTraverse","a","b","callback","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind","utils"],"mappings":"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","file":"../../utils/SkeletonUtils.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var SkeletonUtils = {\r\n        retarget: function () {\r\n            var pos = new THREE.Vector3(), quat = new THREE.Quaternion(), scale = new THREE.Vector3(), bindBoneMatrix = new THREE.Matrix4(), relativeMatrix = new THREE.Matrix4(), globalMatrix = new THREE.Matrix4();\r\n            return function (target, source, options) {\r\n                options = options || {};\r\n                options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\r\n                options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\r\n                options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\r\n                options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\r\n                options.hip = options.hip !== undefined ? options.hip : 'hip';\r\n                options.names = options.names || {};\r\n                var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source), bones = target.isObject3D ? target.skeleton.bones : this.getBones(target), bindBones, bone, name, boneTo, bonesPosition, i;\r\n                if (target.isObject3D) {\r\n                    target.skeleton.pose();\r\n                } else {\r\n                    options.useTargetMatrix = true;\r\n                    options.preserveMatrix = false;\r\n                }\r\n                if (options.preservePosition) {\r\n                    bonesPosition = [];\r\n                    for (i = 0; i < bones.length; i++) {\r\n                        bonesPosition.push(bones[i].position.clone());\r\n                    }\r\n                }\r\n                if (options.preserveMatrix) {\r\n                    target.updateMatrixWorld();\r\n                    target.matrixWorld.identity();\r\n                    for (i = 0; i < target.children.length; ++i) {\r\n                        target.children[i].updateMatrixWorld(true);\r\n                    }\r\n                }\r\n                if (options.offsets) {\r\n                    bindBones = [];\r\n                    for (i = 0; i < bones.length; ++i) {\r\n                        bone = bones[i];\r\n                        name = options.names[bone.name] || bone.name;\r\n                        if (options.offsets && options.offsets[name]) {\r\n                            bone.matrix.multiply(options.offsets[name]);\r\n                            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\r\n                            bone.updateMatrixWorld();\r\n                        }\r\n                        bindBones.push(bone.matrixWorld.clone());\r\n                    }\r\n                }\r\n                for (i = 0; i < bones.length; ++i) {\r\n                    bone = bones[i];\r\n                    name = options.names[bone.name] || bone.name;\r\n                    boneTo = this.getBoneByName(name, sourceBones);\r\n                    globalMatrix.copy(bone.matrixWorld);\r\n                    if (boneTo) {\r\n                        boneTo.updateMatrixWorld();\r\n                        if (options.useTargetMatrix) {\r\n                            relativeMatrix.copy(boneTo.matrixWorld);\r\n                        } else {\r\n                            relativeMatrix.getInverse(target.matrixWorld);\r\n                            relativeMatrix.multiply(boneTo.matrixWorld);\r\n                        }\r\n                        scale.setFromMatrixScale(relativeMatrix);\r\n                        relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\r\n                        globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\r\n                        if (target.isObject3D) {\r\n                            var boneIndex = bones.indexOf(bone), wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.getInverse(target.skeleton.boneInverses[boneIndex]);\r\n                            globalMatrix.multiply(wBindMatrix);\r\n                        }\r\n                        globalMatrix.copyPosition(relativeMatrix);\r\n                    }\r\n                    if (bone.parent && bone.parent.isBone) {\r\n                        bone.matrix.getInverse(bone.parent.matrixWorld);\r\n                        bone.matrix.multiply(globalMatrix);\r\n                    } else {\r\n                        bone.matrix.copy(globalMatrix);\r\n                    }\r\n                    if (options.preserveHipPosition && name === options.hip) {\r\n                        bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\r\n                    }\r\n                    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\r\n                    bone.updateMatrixWorld();\r\n                }\r\n                if (options.preservePosition) {\r\n                    for (i = 0; i < bones.length; ++i) {\r\n                        bone = bones[i];\r\n                        name = options.names[bone.name] || bone.name;\r\n                        if (name !== options.hip) {\r\n                            bone.position.copy(bonesPosition[i]);\r\n                        }\r\n                    }\r\n                }\r\n                if (options.preserveMatrix) {\r\n                    target.updateMatrixWorld(true);\r\n                }\r\n            };\r\n        }(),\r\n        retargetClip: function (target, source, clip, options) {\r\n            options = options || {};\r\n            options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\r\n            options.fps = options.fps !== undefined ? options.fps : 30;\r\n            options.names = options.names || [];\r\n            if (!source.isObject3D) {\r\n                source = this.getHelperFromSkeleton(source);\r\n            }\r\n            var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000), delta = 1 / options.fps, convertedTracks = [], mixer = new THREE.AnimationMixer(source), bones = this.getBones(target.skeleton), boneDatas = [], positionOffset, bone, boneTo, boneData, name, i, j;\r\n            mixer.clipAction(clip).play();\r\n            mixer.update(0);\r\n            source.updateMatrixWorld();\r\n            for (i = 0; i < numFrames; ++i) {\r\n                var time = i * delta;\r\n                this.retarget(target, source, options);\r\n                for (j = 0; j < bones.length; ++j) {\r\n                    name = options.names[bones[j].name] || bones[j].name;\r\n                    boneTo = this.getBoneByName(name, source.skeleton);\r\n                    if (boneTo) {\r\n                        bone = bones[j];\r\n                        boneData = boneDatas[j] = boneDatas[j] || { bone: bone };\r\n                        if (options.hip === name) {\r\n                            if (!boneData.pos) {\r\n                                boneData.pos = {\r\n                                    times: new Float32Array(numFrames),\r\n                                    values: new Float32Array(numFrames * 3)\r\n                                };\r\n                            }\r\n                            if (options.useFirstFramePosition) {\r\n                                if (i === 0) {\r\n                                    positionOffset = bone.position.clone();\r\n                                }\r\n                                bone.position.sub(positionOffset);\r\n                            }\r\n                            boneData.pos.times[i] = time;\r\n                            bone.position.toArray(boneData.pos.values, i * 3);\r\n                        }\r\n                        if (!boneData.quat) {\r\n                            boneData.quat = {\r\n                                times: new Float32Array(numFrames),\r\n                                values: new Float32Array(numFrames * 4)\r\n                            };\r\n                        }\r\n                        boneData.quat.times[i] = time;\r\n                        bone.quaternion.toArray(boneData.quat.values, i * 4);\r\n                    }\r\n                }\r\n                mixer.update(delta);\r\n                source.updateMatrixWorld();\r\n            }\r\n            for (i = 0; i < boneDatas.length; ++i) {\r\n                boneData = boneDatas[i];\r\n                if (boneData) {\r\n                    if (boneData.pos) {\r\n                        convertedTracks.push(new THREE.VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\r\n                    }\r\n                    convertedTracks.push(new THREE.QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\r\n                }\r\n            }\r\n            mixer.uncacheAction(clip);\r\n            return new THREE.AnimationClip(clip.name, -1, convertedTracks);\r\n        },\r\n        getHelperFromSkeleton: function (skeleton) {\r\n            var source = new THREE.SkeletonHelper(skeleton.bones[0]);\r\n            source.skeleton = skeleton;\r\n            return source;\r\n        },\r\n        getSkeletonOffsets: function () {\r\n            var targetParentPos = new THREE.Vector3(), targetPos = new THREE.Vector3(), sourceParentPos = new THREE.Vector3(), sourcePos = new THREE.Vector3(), targetDir = new THREE.Vector2(), sourceDir = new THREE.Vector2();\r\n            return function (target, source, options) {\r\n                options = options || {};\r\n                options.hip = options.hip !== undefined ? options.hip : 'hip';\r\n                options.names = options.names || {};\r\n                if (!source.isObject3D) {\r\n                    source = this.getHelperFromSkeleton(source);\r\n                }\r\n                var nameKeys = Object.keys(options.names), nameValues = Object.values(options.names), sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source), bones = target.isObject3D ? target.skeleton.bones : this.getBones(target), offsets = [], bone, boneTo, name, i;\r\n                target.skeleton.pose();\r\n                for (i = 0; i < bones.length; ++i) {\r\n                    bone = bones[i];\r\n                    name = options.names[bone.name] || bone.name;\r\n                    boneTo = this.getBoneByName(name, sourceBones);\r\n                    if (boneTo && name !== options.hip) {\r\n                        var boneParent = this.getNearestBone(bone.parent, nameKeys), boneToParent = this.getNearestBone(boneTo.parent, nameValues);\r\n                        boneParent.updateMatrixWorld();\r\n                        boneToParent.updateMatrixWorld();\r\n                        targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\r\n                        targetPos.setFromMatrixPosition(bone.matrixWorld);\r\n                        sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\r\n                        sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\r\n                        targetDir.subVectors(new THREE.Vector2(targetPos.x, targetPos.y), new THREE.Vector2(targetParentPos.x, targetParentPos.y)).normalize();\r\n                        sourceDir.subVectors(new THREE.Vector2(sourcePos.x, sourcePos.y), new THREE.Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\r\n                        var laterialAngle = targetDir.angle() - sourceDir.angle();\r\n                        var offset = new THREE.Matrix4().makeRotationFromEuler(new THREE.Euler(0, 0, laterialAngle));\r\n                        bone.matrix.multiply(offset);\r\n                        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\r\n                        bone.updateMatrixWorld();\r\n                        offsets[name] = offset;\r\n                    }\r\n                }\r\n                return offsets;\r\n            };\r\n        }(),\r\n        renameBones: function (skeleton, names) {\r\n            var bones = this.getBones(skeleton);\r\n            for (var i = 0; i < bones.length; ++i) {\r\n                var bone = bones[i];\r\n                if (names[bone.name]) {\r\n                    bone.name = names[bone.name];\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n        getBones: function (skeleton) {\r\n            return Array.isArray(skeleton) ? skeleton : skeleton.bones;\r\n        },\r\n        getBoneByName: function (name, skeleton) {\r\n            for (var i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\r\n                if (name === bones[i].name)\r\n                    return bones[i];\r\n            }\r\n        },\r\n        getNearestBone: function (bone, names) {\r\n            while (bone.isBone) {\r\n                if (names.indexOf(bone.name) !== -1) {\r\n                    return bone;\r\n                }\r\n                bone = bone.parent;\r\n            }\r\n        },\r\n        findBoneTrackData: function (name, tracks) {\r\n            var regexp = /\\[(.*)\\]\\.(.*)/, result = { name: name };\r\n            for (var i = 0; i < tracks.length; ++i) {\r\n                var trackData = regexp.exec(tracks[i].name);\r\n                if (trackData && name === trackData[1]) {\r\n                    result[trackData[2]] = i;\r\n                }\r\n            }\r\n            return result;\r\n        },\r\n        getEqualsBonesNames: function (skeleton, targetSkeleton) {\r\n            var sourceBones = this.getBones(skeleton), targetBones = this.getBones(targetSkeleton), bones = [];\r\n            search:\r\n                for (var i = 0; i < sourceBones.length; i++) {\r\n                    var boneName = sourceBones[i].name;\r\n                    for (var j = 0; j < targetBones.length; j++) {\r\n                        if (boneName === targetBones[j].name) {\r\n                            bones.push(boneName);\r\n                            continue search;\r\n                        }\r\n                    }\r\n                }\r\n            return bones;\r\n        },\r\n        clone: function (source) {\r\n            var sourceLookup = new Map();\r\n            var cloneLookup = new Map();\r\n            var clone = source.clone();\r\n            parallelTraverse(source, clone, function (sourceNode, clonedNode) {\r\n                sourceLookup.set(clonedNode, sourceNode);\r\n                cloneLookup.set(sourceNode, clonedNode);\r\n            });\r\n            clone.traverse(function (node) {\r\n                if (!node.isSkinnedMesh)\r\n                    return;\r\n                var clonedMesh = node;\r\n                var sourceMesh = sourceLookup.get(node);\r\n                var sourceBones = sourceMesh.skeleton.bones;\r\n                clonedMesh.skeleton = sourceMesh.skeleton.clone();\r\n                clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\r\n                clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\r\n                    return cloneLookup.get(bone);\r\n                });\r\n                clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\r\n            });\r\n            return clone;\r\n        }\r\n    };\r\n    function parallelTraverse(a, b, callback) {\r\n        callback(a, b);\r\n        for (var i = 0; i < a.children.length; i++) {\r\n            parallelTraverse(a.children[i], b.children[i], callback);\r\n        }\r\n    }\r\n    return threex.utils.SkeletonUtils = SkeletonUtils;\r\n});"]}