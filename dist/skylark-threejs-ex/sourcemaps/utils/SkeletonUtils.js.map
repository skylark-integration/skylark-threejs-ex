{"version":3,"sources":["utils/SkeletonUtils.js"],"names":["define","THREE","targetParentPos","targetPos","sourceParentPos","sourcePos","targetDir","sourceDir","pos","quat","scale","bindBoneMatrix","relativeMatrix","globalMatrix","SkeletonUtils","retarget","Vector3","Quaternion","Matrix4","target","source","options","preserveMatrix","undefined","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","bindBones","bone","name","boneTo","bonesPosition","i","sourceBones","isObject3D","skeleton","bones","this","getBones","pose","length","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","getInverse","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","positionOffset","boneData","j","numFrames","Math","round","duration","delta","convertedTracks","mixer","AnimationMixer","boneDatas","clipAction","play","update","time","times","Float32Array","values","sub","toArray","VectorKeyframeTrack","QuaternionKeyframeTrack","uncacheAction","AnimationClip","SkeletonHelper","getSkeletonOffsets","Vector2","nameKeys","Object","keys","nameValues","boneParent","getNearestBone","boneToParent","setFromMatrixPosition","subVectors","normalize","laterialAngle","angle","offset","makeRotationFromEuler","Euler","renameBones","Array","isArray","findBoneTrackData","tracks","regexp","result","trackData","exec","getEqualsBonesNames","targetSkeleton","targetBones","search","boneName","sourceLookup","Map","cloneLookup","parallelTraverse","a","b","callback","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind"],"mappings":";;;;;;;AAAAA,QACC,mBACC,SAASC,GAgVW,IAEfC,EACHC,EACAC,EACAC,EACAC,EACAC,EA9UGC,EACHC,EACAC,EACAC,EACAC,EACAC,EA2jBH,OApkBAZ,EAAMa,eAELC,UAEKP,EAAM,IAAIP,EAAMe,QACnBP,EAAO,IAAIR,EAAMgB,WACjBP,EAAQ,IAAIT,EAAMe,QAClBL,EAAiB,IAAIV,EAAMiB,QAC3BN,EAAiB,IAAIX,EAAMiB,QAC3BL,EAAe,IAAIZ,EAAMiB,QAEnB,SAAWC,EAAQC,EAAQC,IAEjCA,EAAUA,OACFC,oBAA4CC,IAA3BF,EAAQC,gBAA+BD,EAAQC,eACxED,EAAQG,sBAAgDD,IAA7BF,EAAQG,kBAAiCH,EAAQG,iBAC5EH,EAAQI,yBAAsDF,IAAhCF,EAAQI,qBAAoCJ,EAAQI,oBAClFJ,EAAQK,qBAA8CH,IAA5BF,EAAQK,iBAAgCL,EAAQK,gBAC1EL,EAAQM,SAAsBJ,IAAhBF,EAAQM,IAAoBN,EAAQM,IAAM,MACxDN,EAAQO,MAAQP,EAAQO,UAExB,IAECC,EACAC,EAAMC,EAAMC,EACZC,EAAeC,EAJZC,EAAcf,EAAOgB,WAAahB,EAAOiB,SAASC,MAAQC,KAAKC,SAAUpB,GAC5EkB,EAAQnB,EAAOiB,WAAajB,EAAOkB,SAASC,MAAQC,KAAKC,SAAUrB,GAkBpE,GAXKA,EAAOiB,WAEXjB,EAAOkB,SAASI,QAIhBpB,EAAQK,iBAAkB,EAC1BL,EAAQC,gBAAiB,GAIrBD,EAAQG,iBAIZ,IAFAS,KAEMC,EAAI,EAAGA,EAAII,EAAMI,OAAQR,IAE9BD,EAAcU,KAAML,EAAOJ,GAAIU,SAASC,SAM1C,GAAKxB,EAAQC,eAUZ,IANAH,EAAO2B,oBAEP3B,EAAO4B,YAAYC,WAIbd,EAAI,EAAGA,EAAIf,EAAO8B,SAASP,SAAWR,EAE3Cf,EAAO8B,SAAUf,GAAIY,mBAAmB,GAM1C,GAAKzB,EAAQ6B,QAIZ,IAFArB,KAEMK,EAAI,EAAGA,EAAII,EAAMI,SAAWR,EAEjCJ,EAAOQ,EAAOJ,GACdH,EAAOV,EAAQO,MAAOE,EAAKC,OAAUD,EAAKC,KAErCV,EAAQ6B,SAAW7B,EAAQ6B,QAASnB,KAExCD,EAAKqB,OAAOC,SAAU/B,EAAQ6B,QAASnB,IAEvCD,EAAKqB,OAAOE,UAAWvB,EAAKc,SAAUd,EAAKwB,WAAYxB,EAAKpB,OAE5DoB,EAAKgB,qBAINjB,EAAUc,KAAMb,EAAKiB,YAAYF,SAMnC,IAAMX,EAAI,EAAGA,EAAII,EAAMI,SAAWR,EAAI,CASrC,GAPAJ,EAAOQ,EAAOJ,GACdH,EAAOV,EAAQO,MAAOE,EAAKC,OAAUD,EAAKC,KAE1CC,EAASO,KAAKgB,cAAexB,EAAMI,GAEnCtB,EAAa2C,KAAM1B,EAAKiB,aAEnBf,EAAS,CAwBb,GAtBAA,EAAOc,oBAEFzB,EAAQK,gBAEZd,EAAe4C,KAAMxB,EAAOe,cAI5BnC,EAAe6C,WAAYtC,EAAO4B,aAClCnC,EAAewC,SAAUpB,EAAOe,cAMjCrC,EAAMgD,mBAAoB9C,GAC1BA,EAAeF,MAAOA,EAAMiD,IAAK,EAAIjD,EAAMkD,EAAG,EAAIlD,EAAMmD,EAAG,EAAInD,EAAMoD,IAIrEjD,EAAakD,2BAA4BtD,EAAKuD,sBAAuBpD,IAEhEO,EAAOiB,WAAa,CAExB,IAAI6B,EAAY3B,EAAM4B,QAASpC,GAC9BqC,EAActC,EAAYA,EAAWoC,GAActD,EAAe8C,WAAYtC,EAAOkB,SAAS+B,aAAcH,IAE7GpD,EAAauC,SAAUe,GAIxBtD,EAAawD,aAAczD,GAIvBkB,EAAKwC,QAAUxC,EAAKwC,OAAOC,QAE/BzC,EAAKqB,OAAOM,WAAY3B,EAAKwC,OAAOvB,aACpCjB,EAAKqB,OAAOC,SAAUvC,IAItBiB,EAAKqB,OAAOK,KAAM3C,GAIdQ,EAAQI,qBAAuBM,IAASV,EAAQM,KAEpDG,EAAKqB,OAAOqB,YAAahE,EAAImD,IAAK,EAAG7B,EAAKc,SAASiB,EAAG,IAIvD/B,EAAKqB,OAAOE,UAAWvB,EAAKc,SAAUd,EAAKwB,WAAYxB,EAAKpB,OAE5DoB,EAAKgB,oBAIN,GAAKzB,EAAQG,iBAEZ,IAAMU,EAAI,EAAGA,EAAII,EAAMI,SAAWR,EAEjCJ,EAAOQ,EAAOJ,IACdH,EAAOV,EAAQO,MAAOE,EAAKC,OAAUD,EAAKC,QAE5BV,EAAQM,KAErBG,EAAKc,SAASY,KAAMvB,EAAeC,IAQjCb,EAAQC,gBAIZH,EAAO2B,mBAAmB,KAQ7B2B,aAAc,SAAWtD,EAAQC,EAAQsD,EAAMrD,IAE9CA,EAAUA,OACFsD,2BAA0DpD,IAAlCF,EAAQsD,uBAAsCtD,EAAQsD,sBACtFtD,EAAQuD,SAAsBrD,IAAhBF,EAAQuD,IAAoBvD,EAAQuD,IAAM,GACxDvD,EAAQO,MAAQP,EAAQO,UAEjBR,EAAOgB,aAEbhB,EAASmB,KAAKsC,sBAAuBzD,IAItC,IAMC0D,EACAhD,EAAciD,EACdhD,EAAMG,EAAG8C,EARNC,EAAYC,KAAKC,MAAOT,EAAKU,UAAa/D,EAAQuD,IAAM,KAAS,KACpES,EAAQ,EAAIhE,EAAQuD,IACpBU,KACAC,EAAQ,IAAItF,EAAMuF,eAAgBpE,GAClCkB,EAAQC,KAAKC,SAAUrB,EAAOkB,UAC9BoD,KAUD,IALAF,EAAMG,WAAYhB,GAAOiB,OACzBJ,EAAMK,OAAQ,GAEdxE,EAAO0B,oBAEDZ,EAAI,EAAGA,EAAI+C,IAAc/C,EAAI,CAElC,IAAI2D,EAAO3D,EAAImD,EAIf,IAFA9C,KAAKxB,SAAUI,EAAQC,EAAQC,GAEzB2D,EAAI,EAAGA,EAAI1C,EAAMI,SAAWsC,EAEjCjD,EAAOV,EAAQO,MAAOU,EAAO0C,GAAIjD,OAAUO,EAAO0C,GAAIjD,KAE7CQ,KAAKgB,cAAexB,EAAMX,EAAOiB,YAIzCP,EAAOQ,EAAO0C,GACdD,EAAWU,EAAWT,GAAMS,EAAWT,KAASlD,KAAMA,GAEjDT,EAAQM,MAAQI,IAEbgD,EAASvE,MAEfuE,EAASvE,KACRsF,MAAO,IAAIC,aAAcd,GACzBe,OAAQ,IAAID,aAA0B,EAAZd,KAKvB5D,EAAQsD,wBAED,IAANzC,IAEJ4C,EAAiBhD,EAAKc,SAASC,SAIhCf,EAAKc,SAASqD,IAAKnB,IAIpBC,EAASvE,IAAIsF,MAAO5D,GAAM2D,EAE1B/D,EAAKc,SAASsD,QAASnB,EAASvE,IAAIwF,OAAY,EAAJ9D,IAItC6C,EAAStE,OAEfsE,EAAStE,MACRqF,MAAO,IAAIC,aAAcd,GACzBe,OAAQ,IAAID,aAA0B,EAAZd,KAK5BF,EAAStE,KAAKqF,MAAO5D,GAAM2D,EAE3B/D,EAAKwB,WAAW4C,QAASnB,EAAStE,KAAKuF,OAAY,EAAJ9D,IAMjDqD,EAAMK,OAAQP,GAEdjE,EAAO0B,oBAIR,IAAMZ,EAAI,EAAGA,EAAIuD,EAAU/C,SAAWR,GAErC6C,EAAWU,EAAWvD,MAIhB6C,EAASvE,KAEb8E,EAAgB3C,KAAM,IAAI1C,EAAMkG,oBAC/B,UAAYpB,EAASjD,KAAKC,KAAO,aACjCgD,EAASvE,IAAIsF,MACbf,EAASvE,IAAIwF,SAKfV,EAAgB3C,KAAM,IAAI1C,EAAMmG,wBAC/B,UAAYrB,EAASjD,KAAKC,KAAO,eACjCgD,EAAStE,KAAKqF,MACdf,EAAStE,KAAKuF,UASjB,OAFAT,EAAMc,cAAe3B,GAEd,IAAIzE,EAAMqG,cAAe5B,EAAK3C,MAAQ,EAAGuD,IAIjDT,sBAAuB,SAAWxC,GAEjC,IAAIjB,EAAS,IAAInB,EAAMsG,eAAgBlE,EAASC,MAAO,IAGvD,OAFAlB,EAAOiB,SAAWA,EAEXjB,GAIRoF,oBAEKtG,EAAkB,IAAID,EAAMe,QAC/Bb,EAAY,IAAIF,EAAMe,QACtBZ,EAAkB,IAAIH,EAAMe,QAC5BX,EAAY,IAAIJ,EAAMe,QACtBV,EAAY,IAAIL,EAAMwG,QACtBlG,EAAY,IAAIN,EAAMwG,QAEhB,SAAWtF,EAAQC,EAAQC,IAEjCA,EAAUA,OACFM,SAAsBJ,IAAhBF,EAAQM,IAAoBN,EAAQM,IAAM,MACxDN,EAAQO,MAAQP,EAAQO,UAEjBR,EAAOgB,aAEbhB,EAASmB,KAAKsC,sBAAuBzD,IAItC,IAKCU,EAAME,EACND,EAAMG,EANHwE,EAAWC,OAAOC,KAAMvF,EAAQO,OACnCiF,EAAaF,OAAOX,OAAQ3E,EAAQO,OACpCO,EAAcf,EAAOgB,WAAahB,EAAOiB,SAASC,MAAQC,KAAKC,SAAUpB,GACzEkB,EAAQnB,EAAOiB,WAAajB,EAAOkB,SAASC,MAAQC,KAAKC,SAAUrB,GACnE+B,KAMD,IAFA/B,EAAOkB,SAASI,OAEVP,EAAI,EAAGA,EAAII,EAAMI,SAAWR,EAOjC,GALAJ,EAAOQ,EAAOJ,GACdH,EAAOV,EAAQO,MAAOE,EAAKC,OAAUD,EAAKC,MAE1CC,EAASO,KAAKgB,cAAexB,EAAMI,KAEpBJ,IAASV,EAAQM,IAAM,CAErC,IAAImF,EAAavE,KAAKwE,eAAgBjF,EAAKwC,OAAQoC,GAClDM,EAAezE,KAAKwE,eAAgB/E,EAAOsC,OAAQuC,GAEpDC,EAAWhE,oBACXkE,EAAalE,oBAEb5C,EAAgB+G,sBAAuBH,EAAW/D,aAClD5C,EAAU8G,sBAAuBnF,EAAKiB,aAEtC3C,EAAgB6G,sBAAuBD,EAAajE,aACpD1C,EAAU4G,sBAAuBjF,EAAOe,aAExCzC,EAAU4G,WACT,IAAIjH,EAAMwG,QAAStG,EAAUyD,EAAGzD,EAAU0D,GAC1C,IAAI5D,EAAMwG,QAASvG,EAAgB0D,EAAG1D,EAAgB2D,IACrDsD,YAEF5G,EAAU2G,WACT,IAAIjH,EAAMwG,QAASpG,EAAUuD,EAAGvD,EAAUwD,GAC1C,IAAI5D,EAAMwG,QAASrG,EAAgBwD,EAAGxD,EAAgByD,IACrDsD,YAEF,IAAIC,EAAgB9G,EAAU+G,QAAU9G,EAAU8G,QAE9CC,GAAS,IAAIrH,EAAMiB,SAAUqG,sBAChC,IAAItH,EAAMuH,MACT,EACA,EACAJ,IAIFtF,EAAKqB,OAAOC,SAAUkE,GAEtBxF,EAAKqB,OAAOE,UAAWvB,EAAKc,SAAUd,EAAKwB,WAAYxB,EAAKpB,OAE5DoB,EAAKgB,oBAELI,EAASnB,GAASuF,EAMpB,OAAOpE,IAMTuE,YAAa,SAAWpF,EAAUT,GAIjC,IAFA,IAAIU,EAAQC,KAAKC,SAAUH,GAEjBH,EAAI,EAAGA,EAAII,EAAMI,SAAWR,EAAI,CAEzC,IAAIJ,EAAOQ,EAAOJ,GAEbN,EAAOE,EAAKC,QAEhBD,EAAKC,KAAOH,EAAOE,EAAKC,OAM1B,OAAOQ,MAIRC,SAAU,SAAWH,GAEpB,OAAOqF,MAAMC,QAAStF,GAAaA,EAAWA,EAASC,OAIxDiB,cAAe,SAAWxB,EAAMM,GAE/B,IAAM,IAAIH,EAAI,EAAGI,EAAQC,KAAKC,SAAUH,GAAYH,EAAII,EAAMI,OAAQR,IAErE,GAAKH,IAASO,EAAOJ,GAAIH,KAExB,OAAOO,EAAOJ,IAMjB6E,eAAgB,SAAWjF,EAAMF,GAEhC,KAAQE,EAAKyC,QAAS,CAErB,IAAsC,IAAjC3C,EAAMsC,QAASpC,EAAKC,MAExB,OAAOD,EAIRA,EAAOA,EAAKwC,SAMdsD,kBAAmB,SAAW7F,EAAM8F,GAKnC,IAHA,IAAIC,EAAS,iBACZC,GAAWhG,KAAMA,GAERG,EAAI,EAAGA,EAAI2F,EAAOnF,SAAWR,EAAI,CAI1C,IAAI8F,EAAYF,EAAOG,KAAMJ,EAAQ3F,GAAIH,MAEpCiG,GAAajG,IAASiG,EAAW,KAErCD,EAAQC,EAAW,IAAQ9F,GAM7B,OAAO6F,GAIRG,oBAAqB,SAAW7F,EAAU8F,GAEzC,IAAIhG,EAAcI,KAAKC,SAAUH,GAChC+F,EAAc7F,KAAKC,SAAU2F,GAC7B7F,KAED+F,EAAS,IAAM,IAAInG,EAAI,EAAGA,EAAIC,EAAYO,OAAQR,IAIjD,IAFA,IAAIoG,EAAWnG,EAAaD,GAAIH,KAEtBiD,EAAI,EAAGA,EAAIoD,EAAY1F,OAAQsC,IAExC,GAAKsD,IAAaF,EAAapD,GAAIjD,KAAO,CAEzCO,EAAMK,KAAM2F,GAEZ,SAASD,EAQZ,OAAO/F,GAIRO,MAAO,SAAWzB,GAEjB,IAAImH,EAAe,IAAIC,IACnBC,EAAc,IAAID,IAElB3F,EAAQzB,EAAOyB,QA8BnB,OAOF,SAAS6F,EAAkBC,EAAGC,EAAGC,GAEhCA,EAAUF,EAAGC,GAEb,IAAM,IAAI1G,EAAI,EAAGA,EAAIyG,EAAE1F,SAASP,OAAQR,IAEvCwG,EAAkBC,EAAE1F,SAAUf,GAAK0G,EAAE3F,SAAUf,GAAK2G,GAzCpDH,CAAkBtH,EAAQyB,EAAO,SAAWiG,EAAYC,GAEvDR,EAAa5E,IAAKoF,EAAYD,GAC9BL,EAAY9E,IAAKmF,EAAYC,KAI9BlG,EAAMmG,SAAU,SAAWC,GAE1B,GAAOA,EAAKC,cAAZ,CAEA,IAAIC,EAAaF,EACbG,EAAab,EAAac,IAAKJ,GAC/B9G,EAAciH,EAAW/G,SAASC,MAEtC6G,EAAW9G,SAAW+G,EAAW/G,SAASQ,QAC1CsG,EAAWG,WAAW9F,KAAM4F,EAAWE,YAEvCH,EAAW9G,SAASC,MAAQH,EAAYoH,IAAK,SAAWzH,GAEvD,OAAO2G,EAAYY,IAAKvH,KAIzBqH,EAAWK,KAAML,EAAW9G,SAAU8G,EAAWG,eAI3CzG,IAmBF5C,EAAMa","file":"../../utils/SkeletonUtils.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author sunag / http://www.sunag.com.br\n\t */\n\n\tTHREE.SkeletonUtils = {\n\n\t\tretarget: function () {\n\n\t\t\tvar pos = new THREE.Vector3(),\n\t\t\t\tquat = new THREE.Quaternion(),\n\t\t\t\tscale = new THREE.Vector3(),\n\t\t\t\tbindBoneMatrix = new THREE.Matrix4(),\n\t\t\t\trelativeMatrix = new THREE.Matrix4(),\n\t\t\t\tglobalMatrix = new THREE.Matrix4();\n\n\t\t\treturn function ( target, source, options ) {\n\n\t\t\t\toptions = options || {};\n\t\t\t\toptions.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n\t\t\t\toptions.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n\t\t\t\toptions.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n\t\t\t\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n\t\t\t\toptions.hip = options.hip !== undefined ? options.hip : \"hip\";\n\t\t\t\toptions.names = options.names || {};\n\n\t\t\t\tvar sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones( source ),\n\t\t\t\t\tbones = target.isObject3D ? target.skeleton.bones : this.getBones( target ),\n\t\t\t\t\tbindBones,\n\t\t\t\t\tbone, name, boneTo,\n\t\t\t\t\tbonesPosition, i;\n\n\t\t\t\t// reset bones\n\n\t\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\t\ttarget.skeleton.pose();\n\n\t\t\t\t} else {\n\n\t\t\t\t\toptions.useTargetMatrix = true;\n\t\t\t\t\toptions.preserveMatrix = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( options.preservePosition ) {\n\n\t\t\t\t\tbonesPosition = [];\n\n\t\t\t\t\tfor ( i = 0; i < bones.length; i ++ ) {\n\n\t\t\t\t\t\tbonesPosition.push( bones[ i ].position.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( options.preserveMatrix ) {\n\n\t\t\t\t\t// reset matrix\n\n\t\t\t\t\ttarget.updateMatrixWorld();\n\n\t\t\t\t\ttarget.matrixWorld.identity();\n\n\t\t\t\t\t// reset children matrix\n\n\t\t\t\t\tfor ( i = 0; i < target.children.length; ++ i ) {\n\n\t\t\t\t\t\ttarget.children[ i ].updateMatrixWorld( true );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( options.offsets ) {\n\n\t\t\t\t\tbindBones = [];\n\n\t\t\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\t\t\tbone = bones[ i ];\n\t\t\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\t\t\tif ( options.offsets && options.offsets[ name ] ) {\n\n\t\t\t\t\t\t\tbone.matrix.multiply( options.offsets[ name ] );\n\n\t\t\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbindBones.push( bone.matrixWorld.clone() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\t\tbone = bones[ i ];\n\t\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\t\tboneTo = this.getBoneByName( name, sourceBones );\n\n\t\t\t\t\tglobalMatrix.copy( bone.matrixWorld );\n\n\t\t\t\t\tif ( boneTo ) {\n\n\t\t\t\t\t\tboneTo.updateMatrixWorld();\n\n\t\t\t\t\t\tif ( options.useTargetMatrix ) {\n\n\t\t\t\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\trelativeMatrix.getInverse( target.matrixWorld );\n\t\t\t\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// ignore scale to extract rotation\n\n\t\t\t\t\t\tscale.setFromMatrixScale( relativeMatrix );\n\t\t\t\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\n\n\t\t\t\t\t\t// apply to global matrix\n\n\t\t\t\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\n\n\t\t\t\t\t\tif ( target.isObject3D ) {\n\n\t\t\t\t\t\t\tvar boneIndex = bones.indexOf( bone ),\n\t\t\t\t\t\t\t\twBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.getInverse( target.skeleton.boneInverses[ boneIndex ] );\n\n\t\t\t\t\t\t\tglobalMatrix.multiply( wBindMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tglobalMatrix.copyPosition( relativeMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\n\t\t\t\t\t\tbone.matrix.multiply( globalMatrix );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbone.matrix.copy( globalMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( options.preserveHipPosition && name === options.hip ) {\n\n\t\t\t\t\t\tbone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t\tif ( options.preservePosition ) {\n\n\t\t\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\t\t\tbone = bones[ i ];\n\t\t\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\t\t\tif ( name !== options.hip ) {\n\n\t\t\t\t\t\t\tbone.position.copy( bonesPosition[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( options.preserveMatrix ) {\n\n\t\t\t\t\t// restore matrix\n\n\t\t\t\t\ttarget.updateMatrixWorld( true );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tretargetClip: function ( target, source, clip, options ) {\n\n\t\t\toptions = options || {};\n\t\t\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n\t\t\toptions.fps = options.fps !== undefined ? options.fps : 30;\n\t\t\toptions.names = options.names || [];\n\n\t\t\tif ( ! source.isObject3D ) {\n\n\t\t\t\tsource = this.getHelperFromSkeleton( source );\n\n\t\t\t}\n\n\t\t\tvar numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\n\t\t\t\tdelta = 1 / options.fps,\n\t\t\t\tconvertedTracks = [],\n\t\t\t\tmixer = new THREE.AnimationMixer( source ),\n\t\t\t\tbones = this.getBones( target.skeleton ),\n\t\t\t\tboneDatas = [],\n\t\t\t\tpositionOffset,\n\t\t\t\tbone, boneTo, boneData,\n\t\t\t\tname, i, j;\n\n\t\t\tmixer.clipAction( clip ).play();\n\t\t\tmixer.update( 0 );\n\n\t\t\tsource.updateMatrixWorld();\n\n\t\t\tfor ( i = 0; i < numFrames; ++ i ) {\n\n\t\t\t\tvar time = i * delta;\n\n\t\t\t\tthis.retarget( target, source, options );\n\n\t\t\t\tfor ( j = 0; j < bones.length; ++ j ) {\n\n\t\t\t\t\tname = options.names[ bones[ j ].name ] || bones[ j ].name;\n\n\t\t\t\t\tboneTo = this.getBoneByName( name, source.skeleton );\n\n\t\t\t\t\tif ( boneTo ) {\n\n\t\t\t\t\t\tbone = bones[ j ];\n\t\t\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\n\n\t\t\t\t\t\tif ( options.hip === name ) {\n\n\t\t\t\t\t\t\tif ( ! boneData.pos ) {\n\n\t\t\t\t\t\t\t\tboneData.pos = {\n\t\t\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 3 )\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( options.useFirstFramePosition ) {\n\n\t\t\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbone.position.sub( positionOffset );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tboneData.pos.times[ i ] = time;\n\n\t\t\t\t\t\t\tbone.position.toArray( boneData.pos.values, i * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! boneData.quat ) {\n\n\t\t\t\t\t\t\tboneData.quat = {\n\t\t\t\t\t\t\t\ttimes: new Float32Array( numFrames ),\n\t\t\t\t\t\t\t\tvalues: new Float32Array( numFrames * 4 )\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tboneData.quat.times[ i ] = time;\n\n\t\t\t\t\t\tbone.quaternion.toArray( boneData.quat.values, i * 4 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmixer.update( delta );\n\n\t\t\t\tsource.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < boneDatas.length; ++ i ) {\n\n\t\t\t\tboneData = boneDatas[ i ];\n\n\t\t\t\tif ( boneData ) {\n\n\t\t\t\t\tif ( boneData.pos ) {\n\n\t\t\t\t\t\tconvertedTracks.push( new THREE.VectorKeyframeTrack(\n\t\t\t\t\t\t\t\".bones[\" + boneData.bone.name + \"].position\",\n\t\t\t\t\t\t\tboneData.pos.times,\n\t\t\t\t\t\t\tboneData.pos.values\n\t\t\t\t\t\t) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconvertedTracks.push( new THREE.QuaternionKeyframeTrack(\n\t\t\t\t\t\t\".bones[\" + boneData.bone.name + \"].quaternion\",\n\t\t\t\t\t\tboneData.quat.times,\n\t\t\t\t\t\tboneData.quat.values\n\t\t\t\t\t) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmixer.uncacheAction( clip );\n\n\t\t\treturn new THREE.AnimationClip( clip.name, - 1, convertedTracks );\n\n\t\t},\n\n\t\tgetHelperFromSkeleton: function ( skeleton ) {\n\n\t\t\tvar source = new THREE.SkeletonHelper( skeleton.bones[ 0 ] );\n\t\t\tsource.skeleton = skeleton;\n\n\t\t\treturn source;\n\n\t\t},\n\n\t\tgetSkeletonOffsets: function () {\n\n\t\t\tvar targetParentPos = new THREE.Vector3(),\n\t\t\t\ttargetPos = new THREE.Vector3(),\n\t\t\t\tsourceParentPos = new THREE.Vector3(),\n\t\t\t\tsourcePos = new THREE.Vector3(),\n\t\t\t\ttargetDir = new THREE.Vector2(),\n\t\t\t\tsourceDir = new THREE.Vector2();\n\n\t\t\treturn function ( target, source, options ) {\n\n\t\t\t\toptions = options || {};\n\t\t\t\toptions.hip = options.hip !== undefined ? options.hip : \"hip\";\n\t\t\t\toptions.names = options.names || {};\n\n\t\t\t\tif ( ! source.isObject3D ) {\n\n\t\t\t\t\tsource = this.getHelperFromSkeleton( source );\n\n\t\t\t\t}\n\n\t\t\t\tvar nameKeys = Object.keys( options.names ),\n\t\t\t\t\tnameValues = Object.values( options.names ),\n\t\t\t\t\tsourceBones = source.isObject3D ? source.skeleton.bones : this.getBones( source ),\n\t\t\t\t\tbones = target.isObject3D ? target.skeleton.bones : this.getBones( target ),\n\t\t\t\t\toffsets = [],\n\t\t\t\t\tbone, boneTo,\n\t\t\t\t\tname, i;\n\n\t\t\t\ttarget.skeleton.pose();\n\n\t\t\t\tfor ( i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\t\tbone = bones[ i ];\n\t\t\t\t\tname = options.names[ bone.name ] || bone.name;\n\n\t\t\t\t\tboneTo = this.getBoneByName( name, sourceBones );\n\n\t\t\t\t\tif ( boneTo && name !== options.hip ) {\n\n\t\t\t\t\t\tvar boneParent = this.getNearestBone( bone.parent, nameKeys ),\n\t\t\t\t\t\t\tboneToParent = this.getNearestBone( boneTo.parent, nameValues );\n\n\t\t\t\t\t\tboneParent.updateMatrixWorld();\n\t\t\t\t\t\tboneToParent.updateMatrixWorld();\n\n\t\t\t\t\t\ttargetParentPos.setFromMatrixPosition( boneParent.matrixWorld );\n\t\t\t\t\t\ttargetPos.setFromMatrixPosition( bone.matrixWorld );\n\n\t\t\t\t\t\tsourceParentPos.setFromMatrixPosition( boneToParent.matrixWorld );\n\t\t\t\t\t\tsourcePos.setFromMatrixPosition( boneTo.matrixWorld );\n\n\t\t\t\t\t\ttargetDir.subVectors(\n\t\t\t\t\t\t\tnew THREE.Vector2( targetPos.x, targetPos.y ),\n\t\t\t\t\t\t\tnew THREE.Vector2( targetParentPos.x, targetParentPos.y )\n\t\t\t\t\t\t).normalize();\n\n\t\t\t\t\t\tsourceDir.subVectors(\n\t\t\t\t\t\t\tnew THREE.Vector2( sourcePos.x, sourcePos.y ),\n\t\t\t\t\t\t\tnew THREE.Vector2( sourceParentPos.x, sourceParentPos.y )\n\t\t\t\t\t\t).normalize();\n\n\t\t\t\t\t\tvar laterialAngle = targetDir.angle() - sourceDir.angle();\n\n\t\t\t\t\t\tvar offset = new THREE.Matrix4().makeRotationFromEuler(\n\t\t\t\t\t\t\tnew THREE.Euler(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tlaterialAngle\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbone.matrix.multiply( offset );\n\n\t\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t\t\t\tbone.updateMatrixWorld();\n\n\t\t\t\t\t\toffsets[ name ] = offset;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn offsets;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\trenameBones: function ( skeleton, names ) {\n\n\t\t\tvar bones = this.getBones( skeleton );\n\n\t\t\tfor ( var i = 0; i < bones.length; ++ i ) {\n\n\t\t\t\tvar bone = bones[ i ];\n\n\t\t\t\tif ( names[ bone.name ] ) {\n\n\t\t\t\t\tbone.name = names[ bone.name ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tgetBones: function ( skeleton ) {\n\n\t\t\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\n\n\t\t},\n\n\t\tgetBoneByName: function ( name, skeleton ) {\n\n\t\t\tfor ( var i = 0, bones = this.getBones( skeleton ); i < bones.length; i ++ ) {\n\n\t\t\t\tif ( name === bones[ i ].name )\n\n\t\t\t\t\treturn bones[ i ];\n\n\t\t\t}\n\n\t\t},\n\n\t\tgetNearestBone: function ( bone, names ) {\n\n\t\t\twhile ( bone.isBone ) {\n\n\t\t\t\tif ( names.indexOf( bone.name ) !== - 1 ) {\n\n\t\t\t\t\treturn bone;\n\n\t\t\t\t}\n\n\t\t\t\tbone = bone.parent;\n\n\t\t\t}\n\n\t\t},\n\n\t\tfindBoneTrackData: function ( name, tracks ) {\n\n\t\t\tvar regexp = /\\[(.*)\\]\\.(.*)/,\n\t\t\t\tresult = { name: name };\n\n\t\t\tfor ( var i = 0; i < tracks.length; ++ i ) {\n\n\t\t\t\t// 1 is track name\n\t\t\t\t// 2 is track type\n\t\t\t\tvar trackData = regexp.exec( tracks[ i ].name );\n\n\t\t\t\tif ( trackData && name === trackData[ 1 ] ) {\n\n\t\t\t\t\tresult[ trackData[ 2 ] ] = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\tgetEqualsBonesNames: function ( skeleton, targetSkeleton ) {\n\n\t\t\tvar sourceBones = this.getBones( skeleton ),\n\t\t\t\ttargetBones = this.getBones( targetSkeleton ),\n\t\t\t\tbones = [];\n\n\t\t\tsearch : for ( var i = 0; i < sourceBones.length; i ++ ) {\n\n\t\t\t\tvar boneName = sourceBones[ i ].name;\n\n\t\t\t\tfor ( var j = 0; j < targetBones.length; j ++ ) {\n\n\t\t\t\t\tif ( boneName === targetBones[ j ].name ) {\n\n\t\t\t\t\t\tbones.push( boneName );\n\n\t\t\t\t\t\tcontinue search;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bones;\n\n\t\t},\n\n\t\tclone: function ( source ) {\n\n\t\t\tvar sourceLookup = new Map();\n\t\t\tvar cloneLookup = new Map();\n\n\t\t\tvar clone = source.clone();\n\n\t\t\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\n\n\t\t\t\tsourceLookup.set( clonedNode, sourceNode );\n\t\t\t\tcloneLookup.set( sourceNode, clonedNode );\n\n\t\t\t} );\n\n\t\t\tclone.traverse( function ( node ) {\n\n\t\t\t\tif ( ! node.isSkinnedMesh ) return;\n\n\t\t\t\tvar clonedMesh = node;\n\t\t\t\tvar sourceMesh = sourceLookup.get( node );\n\t\t\t\tvar sourceBones = sourceMesh.skeleton.bones;\n\n\t\t\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\t\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\n\n\t\t\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\n\n\t\t\t\t\treturn cloneLookup.get( bone );\n\n\t\t\t\t} );\n\n\t\t\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\n\n\t\t\t} );\n\n\t\t\treturn clone;\n\n\t\t}\n\n\t};\n\n\n\tfunction parallelTraverse( a, b, callback ) {\n\n\t\tcallback( a, b );\n\n\t\tfor ( var i = 0; i < a.children.length; i ++ ) {\n\n\t\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\n\n\t\t}\n\n\t}\n\t\n\treturn THREE.SkeletonUtils;\n});\n"]}