{"version":3,"sources":["utils/UVsDebug.js"],"names":["define","THREE","UVsDebug","geometry","size","abc","a","Vector2","b","uvs","face","canvas","document","createElement","width","height","ctx","getContext","lineWidth","strokeStyle","textAlign","fillStyle","fillRect","isGeometry","faces","uvSet","faceVertexUvs","i","il","length","uv","c","copy","processFace","index","uvAttribute","attributes","count","getX","fromBufferAttribute","beginPath","set","j","jl","x","y","moveTo","lineTo","closePath","stroke","divideScalar","font","fillText","addVectors","vnum"],"mappings":"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","file":"../../utils/UVsDebug.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author zz85 / http://github.com/zz85\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * tool for \"unwrapping\" and debugging three.js geometries UV mapping\n\t *\n\t * Sample usage:\n\t *\tdocument.body.appendChild( THREE.UVsDebug( new THREE.SphereBufferGeometry( 10, 10, 10, 10 ) );\n\t *\n\t */\n\n\tTHREE.UVsDebug = function ( geometry, size ) {\n\n\t\t// handles wrapping of uv.x > 1 only\n\n\t\tvar abc = 'abc';\n\t\tvar a = new THREE.Vector2();\n\t\tvar b = new THREE.Vector2();\n\n\t\tvar uvs = [\n\t\t\tnew THREE.Vector2(),\n\t\t\tnew THREE.Vector2(),\n\t\t\tnew THREE.Vector2()\n\t\t];\n\n\t\tvar face = [];\n\n\t\tvar canvas = document.createElement( 'canvas' );\n\t\tvar width = size || 1024; // power of 2 required for wrapping\n\t\tvar height = size || 1024;\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tvar ctx = canvas.getContext( '2d' );\n\t\tctx.lineWidth = 2;\n\t\tctx.strokeStyle = 'rgba( 0, 0, 0, 1.0 )';\n\t\tctx.textAlign = 'center';\n\n\t\t// paint background white\n\n\t\tctx.fillStyle = 'rgba( 255, 255, 255, 1.0 )';\n\t\tctx.fillRect( 0, 0, width, height );\n\n\t\tif ( geometry.isGeometry ) {\n\n\t\t\tvar faces = geometry.faces;\n\t\t\tvar uvSet = geometry.faceVertexUvs[ 0 ];\n\n\t\t\tfor ( var i = 0, il = uvSet.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\t\t\t\tvar uv = uvSet[ i ];\n\n\t\t\t\tface[ 0 ] = face.a;\n\t\t\t\tface[ 1 ] = face.b;\n\t\t\t\tface[ 2 ] = face.c;\n\n\t\t\t\tuvs[ 0 ].copy( uv[ 0 ] );\n\t\t\t\tuvs[ 1 ].copy( uv[ 1 ] );\n\t\t\t\tuvs[ 2 ].copy( uv[ 2 ] );\n\n\t\t\t\tprocessFace( face, uvs, i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar uvAttribute = geometry.attributes.uv;\n\n\t\t\tif ( index ) {\n\n\t\t\t\t// indexed geometry\n\n\t\t\t\tfor ( var i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tface[ 0 ] = index.getX( i );\n\t\t\t\t\tface[ 1 ] = index.getX( i + 1 );\n\t\t\t\t\tface[ 2 ] = index.getX( i + 2 );\n\n\t\t\t\t\tuvs[ 0 ].fromBufferAttribute( uvAttribute, face[ 0 ] );\n\t\t\t\t\tuvs[ 1 ].fromBufferAttribute( uvAttribute, face[ 1 ] );\n\t\t\t\t\tuvs[ 2 ].fromBufferAttribute( uvAttribute, face[ 2 ] );\n\n\t\t\t\t\tprocessFace( face, uvs, i / 3 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed geometry\n\n\t\t\t\tfor ( var i = 0, il = uvAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tface[ 0 ] = i;\n\t\t\t\t\tface[ 1 ] = i + 1;\n\t\t\t\t\tface[ 2 ] = i + 2;\n\n\t\t\t\t\tuvs[ 0 ].fromBufferAttribute( uvAttribute, face[ 0 ] );\n\t\t\t\t\tuvs[ 1 ].fromBufferAttribute( uvAttribute, face[ 1 ] );\n\t\t\t\t\tuvs[ 2 ].fromBufferAttribute( uvAttribute, face[ 2 ] );\n\n\t\t\t\t\tprocessFace( face, uvs, i / 3 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn canvas;\n\n\t\tfunction processFace( face, uvs, index ) {\n\n\t\t\t// draw contour of face\n\n\t\t\tctx.beginPath();\n\n\t\t\ta.set( 0, 0 );\n\n\t\t\tfor ( var j = 0, jl = uvs.length; j < jl; j ++ ) {\n\n\t\t\t\tvar uv = uvs[ j ];\n\n\t\t\t\ta.x += uv.x;\n\t\t\t\ta.y += uv.y;\n\n\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\tctx.moveTo( uv.x * width, ( 1 - uv.y ) * height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tctx.lineTo( uv.x * width, ( 1 - uv.y ) * height );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tctx.closePath();\n\t\t\tctx.stroke();\n\n\t\t\t// calculate center of face\n\n\t\t\ta.divideScalar( uvs.length );\n\n\t\t\t// label the face number\n\n\t\t\tctx.font = '12pt Arial bold';\n\t\t\tctx.fillStyle = 'rgba( 0, 0, 0, 1.0 )';\n\t\t\tctx.fillText( index, a.x * width, ( 1 - a.y ) * height );\n\n\t\t\tif ( a.x > 0.95 ) {\n\n\t\t\t\t// wrap x // 0.95 is arbitrary\n\n\t\t\t\tctx.fillText( index, ( a.x % 1 ) * width, ( 1 - a.y ) * height );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tctx.font = '8pt Arial bold';\n\t\t\tctx.fillStyle = 'rgba( 0, 0, 0, 1.0 )';\n\n\t\t\t// label uv edge orders\n\n\t\t\tfor ( j = 0, jl = uvs.length; j < jl; j ++ ) {\n\n\t\t\t\tvar uv = uvs[ j ];\n\t\t\t\tb.addVectors( a, uv ).divideScalar( 2 );\n\n\t\t\t\tvar vnum = face[ j ];\n\t\t\t\tctx.fillText( abc[ j ] + vnum, b.x * width, ( 1 - b.y ) * height );\n\n\t\t\t\tif ( b.x > 0.95 ) {\n\n\t\t\t\t\t// wrap x\n\n\t\t\t\t\tctx.fillText( abc[ j ] + vnum, ( b.x % 1 ) * width, ( 1 - b.y ) * height );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.UVsDebug;\n});\n"]}