{"version":3,"sources":["utils/GeometryCompressionUtils.js"],"names":["define","THREE","threex","GeometryCompressionUtils","compressNormals","mesh","encodeMethod","geometry","console","error","normal","attributes","isPacked","itemSize","result","array","count","Uint8Array","idx","length","encoded","this","EncodingFuncs","defaultEncode","setAttribute","BufferAttribute","bytes","Int8Array","octEncodeBest","Int16Array","Uint16Array","anglesEncode","needsUpdate","packingMethod","material","PackedPhongMaterial","copy","defines","USE_PACKED_NORMAL","compressPositions","position","quantizedEncode","quantized","decodeMat","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","USE_PACKED_POSITION","uniforms","quantizeMatPos","value","compressUvs","uvs","uv","range","min","Infinity","max","i","Math","USE_PACKED_UV","quantizedEncodeUV","quantizeMatUV","x","y","z","tmpx","round","tmpy","tmpz","defaultDecode","normal0","parseInt","atan2","PI","normal1","oct","dec","best","currentCos","bestCos","octEncodeVec3","octDecodeVec2","dot","x0","y0","z0","xfunc","yfunc","abs","tempx","tempy","diff","sqrt","vec3","segments","Matrix4","Float32Array","Number","MAX_VALUE","scale","Vector3","elements","transpose","multiplier","floor","Matrix3","parameters","MeshPhongMaterial","call","type","UniformsUtils","merge","ShaderLib","phong","vertexShader","ShaderChunk","common","uv_pars_vertex","uv2_pars_vertex","displacementmap_pars_vertex","envmap_pars_vertex","color_pars_vertex","fog_pars_vertex","morphtarget_pars_vertex","skinning_pars_vertex","shadowmap_pars_vertex","logdepthbuf_pars_vertex","clipping_planes_pars_vertex","uv_vertex","uv2_vertex","color_vertex","beginnormal_vertex","morphnormal_vertex","skinbase_vertex","skinnormal_vertex","defaultnormal_vertex","begin_vertex","morphtarget_vertex","skinning_vertex","displacementmap_vertex","project_vertex","logdepthbuf_vertex","clipping_planes_vertex","worldpos_vertex","envmap_vertex","shadowmap_vertex","fog_vertex","join","fragmentShader","packing","dithering_pars_fragment","color_pars_fragment","uv_pars_fragment","uv2_pars_fragment","map_pars_fragment","alphamap_pars_fragment","aomap_pars_fragment","lightmap_pars_fragment","emissivemap_pars_fragment","envmap_common_pars_fragment","envmap_pars_fragment","cube_uv_reflection_fragment","fog_pars_fragment","bsdfs","lights_pars_begin","lights_phong_pars_fragment","shadowmap_pars_fragment","bumpmap_pars_fragment","normalmap_pars_fragment","specularmap_pars_fragment","logdepthbuf_pars_fragment","clipping_planes_pars_fragment","clipping_planes_fragment","logdepthbuf_fragment","map_fragment","color_fragment","alphamap_fragment","alphatest_fragment","specularmap_fragment","normal_fragment_begin","normal_fragment_maps","emissivemap_fragment","lights_phong_fragment","lights_fragment_begin","lights_fragment_maps","lights_fragment_end","aomap_fragment","envmap_fragment","tonemapping_fragment","encodings_fragment","fog_fragment","premultiplied_alpha_fragment","dithering_fragment","setValues","prototype","Object","create","utils"],"mappings":"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","file":"../../utils/GeometryCompressionUtils.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var GeometryCompressionUtils = {\r\n        compressNormals: function (mesh, encodeMethod) {\r\n            if (!mesh.geometry) {\r\n                console.error('Mesh must contain geometry. ');\r\n            }\r\n            let normal = mesh.geometry.attributes.normal;\r\n            if (!normal) {\r\n                console.error('Geometry must contain normal attribute. ');\r\n            }\r\n            if (normal.isPacked)\r\n                return;\r\n            if (normal.itemSize != 3) {\r\n                console.error('normal.itemSize is not 3, which cannot be encoded. ');\r\n            }\r\n            let array = normal.array;\r\n            let count = normal.count;\r\n            let result;\r\n            if (encodeMethod == 'DEFAULT') {\r\n                result = new Uint8Array(count * 3);\r\n                for (let idx = 0; idx < array.length; idx += 3) {\r\n                    let encoded;\r\n                    encoded = this.EncodingFuncs.defaultEncode(array[idx], array[idx + 1], array[idx + 2], 1);\r\n                    result[idx + 0] = encoded[0];\r\n                    result[idx + 1] = encoded[1];\r\n                    result[idx + 2] = encoded[2];\r\n                }\r\n                mesh.geometry.setAttribute('normal', new THREE.BufferAttribute(result, 3, true));\r\n                mesh.geometry.attributes.normal.bytes = result.length * 1;\r\n            } else if (encodeMethod == 'OCT1Byte') {\r\n                result = new Int8Array(count * 2);\r\n                for (let idx = 0; idx < array.length; idx += 3) {\r\n                    let encoded;\r\n                    encoded = this.EncodingFuncs.octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 1);\r\n                    result[idx / 3 * 2 + 0] = encoded[0];\r\n                    result[idx / 3 * 2 + 1] = encoded[1];\r\n                }\r\n                mesh.geometry.setAttribute('normal', new THREE.BufferAttribute(result, 2, true));\r\n                mesh.geometry.attributes.normal.bytes = result.length * 1;\r\n            } else if (encodeMethod == 'OCT2Byte') {\r\n                result = new Int16Array(count * 2);\r\n                for (let idx = 0; idx < array.length; idx += 3) {\r\n                    let encoded;\r\n                    encoded = this.EncodingFuncs.octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 2);\r\n                    result[idx / 3 * 2 + 0] = encoded[0];\r\n                    result[idx / 3 * 2 + 1] = encoded[1];\r\n                }\r\n                mesh.geometry.setAttribute('normal', new THREE.BufferAttribute(result, 2, true));\r\n                mesh.geometry.attributes.normal.bytes = result.length * 2;\r\n            } else if (encodeMethod == 'ANGLES') {\r\n                result = new Uint16Array(count * 2);\r\n                for (let idx = 0; idx < array.length; idx += 3) {\r\n                    let encoded;\r\n                    encoded = this.EncodingFuncs.anglesEncode(array[idx], array[idx + 1], array[idx + 2]);\r\n                    result[idx / 3 * 2 + 0] = encoded[0];\r\n                    result[idx / 3 * 2 + 1] = encoded[1];\r\n                }\r\n                mesh.geometry.setAttribute('normal', new THREE.BufferAttribute(result, 2, true));\r\n                mesh.geometry.attributes.normal.bytes = result.length * 2;\r\n            } else {\r\n                console.error('Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ');\r\n            }\r\n            mesh.geometry.attributes.normal.needsUpdate = true;\r\n            mesh.geometry.attributes.normal.isPacked = true;\r\n            mesh.geometry.attributes.normal.packingMethod = encodeMethod;\r\n            if (!(mesh.material instanceof PackedPhongMaterial)) {\r\n                mesh.material = new PackedPhongMaterial().copy(mesh.material);\r\n            }\r\n            if (encodeMethod == 'ANGLES') {\r\n                mesh.material.defines.USE_PACKED_NORMAL = 0;\r\n            }\r\n            if (encodeMethod == 'OCT1Byte') {\r\n                mesh.material.defines.USE_PACKED_NORMAL = 1;\r\n            }\r\n            if (encodeMethod == 'OCT2Byte') {\r\n                mesh.material.defines.USE_PACKED_NORMAL = 1;\r\n            }\r\n            if (encodeMethod == 'DEFAULT') {\r\n                mesh.material.defines.USE_PACKED_NORMAL = 2;\r\n            }\r\n        },\r\n        compressPositions: function (mesh) {\r\n            if (!mesh.geometry) {\r\n                console.error('Mesh must contain geometry. ');\r\n            }\r\n            let position = mesh.geometry.attributes.position;\r\n            if (!position) {\r\n                console.error('Geometry must contain position attribute. ');\r\n            }\r\n            if (position.isPacked)\r\n                return;\r\n            if (position.itemSize != 3) {\r\n                console.error('position.itemSize is not 3, which cannot be packed. ');\r\n            }\r\n            let array = position.array;\r\n            let encodingBytes = 2;\r\n            let result = this.EncodingFuncs.quantizedEncode(array, encodingBytes);\r\n            let quantized = result.quantized;\r\n            let decodeMat = result.decodeMat;\r\n            if (mesh.geometry.boundingBox == null)\r\n                mesh.geometry.computeBoundingBox();\r\n            if (mesh.geometry.boundingSphere == null)\r\n                mesh.geometry.computeBoundingSphere();\r\n            mesh.geometry.setAttribute('position', new THREE.BufferAttribute(quantized, 3));\r\n            mesh.geometry.attributes.position.isPacked = true;\r\n            mesh.geometry.attributes.position.needsUpdate = true;\r\n            mesh.geometry.attributes.position.bytes = quantized.length * encodingBytes;\r\n            if (!(mesh.material instanceof PackedPhongMaterial)) {\r\n                mesh.material = new PackedPhongMaterial().copy(mesh.material);\r\n            }\r\n            mesh.material.defines.USE_PACKED_POSITION = 0;\r\n            mesh.material.uniforms.quantizeMatPos.value = decodeMat;\r\n            mesh.material.uniforms.quantizeMatPos.needsUpdate = true;\r\n        },\r\n        compressUvs: function (mesh) {\r\n            if (!mesh.geometry) {\r\n                console.error('Mesh must contain geometry property. ');\r\n            }\r\n            let uvs = mesh.geometry.attributes.uv;\r\n            if (!uvs) {\r\n                console.error('Geometry must contain uv attribute. ');\r\n            }\r\n            if (uvs.isPacked)\r\n                return;\r\n            let range = {\r\n                min: Infinity,\r\n                max: -Infinity\r\n            };\r\n            let array = uvs.array;\r\n            for (let i = 0; i < array.length; i++) {\r\n                range.min = Math.min(range.min, array[i]);\r\n                range.max = Math.max(range.max, array[i]);\r\n            }\r\n            let result;\r\n            if (range.min >= -1 && range.max <= 1) {\r\n                result = new Uint16Array(array.length);\r\n                for (let i = 0; i < array.length; i += 2) {\r\n                    let encoded = this.EncodingFuncs.defaultEncode(array[i], array[i + 1], 0, 2);\r\n                    result[i] = encoded[0];\r\n                    result[i + 1] = encoded[1];\r\n                }\r\n                mesh.geometry.setAttribute('uv', new THREE.BufferAttribute(result, 2, true));\r\n                mesh.geometry.attributes.uv.isPacked = true;\r\n                mesh.geometry.attributes.uv.needsUpdate = true;\r\n                mesh.geometry.attributes.uv.bytes = result.length * 2;\r\n                if (!(mesh.material instanceof PackedPhongMaterial)) {\r\n                    mesh.material = new PackedPhongMaterial().copy(mesh.material);\r\n                }\r\n                mesh.material.defines.USE_PACKED_UV = 0;\r\n            } else {\r\n                result = this.EncodingFuncs.quantizedEncodeUV(array, 2);\r\n                mesh.geometry.setAttribute('uv', new THREE.BufferAttribute(result.quantized, 2));\r\n                mesh.geometry.attributes.uv.isPacked = true;\r\n                mesh.geometry.attributes.uv.needsUpdate = true;\r\n                mesh.geometry.attributes.uv.bytes = result.quantized.length * 2;\r\n                if (!(mesh.material instanceof PackedPhongMaterial)) {\r\n                    mesh.material = new PackedPhongMaterial().copy(mesh.material);\r\n                }\r\n                mesh.material.defines.USE_PACKED_UV = 1;\r\n                mesh.material.uniforms.quantizeMatUV.value = result.decodeMat;\r\n                mesh.material.uniforms.quantizeMatUV.needsUpdate = true;\r\n            }\r\n        },\r\n        EncodingFuncs: {\r\n            defaultEncode: function (x, y, z, bytes) {\r\n                if (bytes == 1) {\r\n                    let tmpx = Math.round((x + 1) * 0.5 * 255);\r\n                    let tmpy = Math.round((y + 1) * 0.5 * 255);\r\n                    let tmpz = Math.round((z + 1) * 0.5 * 255);\r\n                    return new Uint8Array([\r\n                        tmpx,\r\n                        tmpy,\r\n                        tmpz\r\n                    ]);\r\n                } else if (bytes == 2) {\r\n                    let tmpx = Math.round((x + 1) * 0.5 * 65535);\r\n                    let tmpy = Math.round((y + 1) * 0.5 * 65535);\r\n                    let tmpz = Math.round((z + 1) * 0.5 * 65535);\r\n                    return new Uint16Array([\r\n                        tmpx,\r\n                        tmpy,\r\n                        tmpz\r\n                    ]);\r\n                } else {\r\n                    console.error('number of bytes must be 1 or 2');\r\n                }\r\n            },\r\n            defaultDecode: function (array, bytes) {\r\n                if (bytes == 1) {\r\n                    return [\r\n                        array[0] / 255 * 2 - 1,\r\n                        array[1] / 255 * 2 - 1,\r\n                        array[2] / 255 * 2 - 1\r\n                    ];\r\n                } else if (bytes == 2) {\r\n                    return [\r\n                        array[0] / 65535 * 2 - 1,\r\n                        array[1] / 65535 * 2 - 1,\r\n                        array[2] / 65535 * 2 - 1\r\n                    ];\r\n                } else {\r\n                    console.error('number of bytes must be 1 or 2');\r\n                }\r\n            },\r\n            anglesEncode: function (x, y, z) {\r\n                let normal0 = parseInt(0.5 * (1 + Math.atan2(y, x) / Math.PI) * 65535);\r\n                let normal1 = parseInt(0.5 * (1 + z) * 65535);\r\n                return new Uint16Array([\r\n                    normal0,\r\n                    normal1\r\n                ]);\r\n            },\r\n            octEncodeBest: function (x, y, z, bytes) {\r\n                var oct, dec, best, currentCos, bestCos;\r\n                best = oct = octEncodeVec3(x, y, z, 'floor', 'floor');\r\n                dec = octDecodeVec2(oct);\r\n                bestCos = dot(x, y, z, dec);\r\n                oct = octEncodeVec3(x, y, z, 'ceil', 'floor');\r\n                dec = octDecodeVec2(oct);\r\n                currentCos = dot(x, y, z, dec);\r\n                if (currentCos > bestCos) {\r\n                    best = oct;\r\n                    bestCos = currentCos;\r\n                }\r\n                oct = octEncodeVec3(x, y, z, 'floor', 'ceil');\r\n                dec = octDecodeVec2(oct);\r\n                currentCos = dot(x, y, z, dec);\r\n                if (currentCos > bestCos) {\r\n                    best = oct;\r\n                    bestCos = currentCos;\r\n                }\r\n                oct = octEncodeVec3(x, y, z, 'ceil', 'ceil');\r\n                dec = octDecodeVec2(oct);\r\n                currentCos = dot(x, y, z, dec);\r\n                if (currentCos > bestCos) {\r\n                    best = oct;\r\n                }\r\n                return best;\r\n                function octEncodeVec3(x0, y0, z0, xfunc, yfunc) {\r\n                    var x = x0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\r\n                    var y = y0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\r\n                    if (z < 0) {\r\n                        var tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\r\n                        var tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\r\n                        x = tempx;\r\n                        y = tempy;\r\n                        var diff = 1 - Math.abs(x) - Math.abs(y);\r\n                        if (diff > 0) {\r\n                            diff += 0.001;\r\n                            x += x > 0 ? diff / 2 : -diff / 2;\r\n                            y += y > 0 ? diff / 2 : -diff / 2;\r\n                        }\r\n                    }\r\n                    if (bytes == 1) {\r\n                        return new Int8Array([\r\n                            Math[xfunc](x * 127.5 + (x < 0 ? 1 : 0)),\r\n                            Math[yfunc](y * 127.5 + (y < 0 ? 1 : 0))\r\n                        ]);\r\n                    }\r\n                    if (bytes == 2) {\r\n                        return new Int16Array([\r\n                            Math[xfunc](x * 32767.5 + (x < 0 ? 1 : 0)),\r\n                            Math[yfunc](y * 32767.5 + (y < 0 ? 1 : 0))\r\n                        ]);\r\n                    }\r\n                }\r\n                function octDecodeVec2(oct) {\r\n                    var x = oct[0];\r\n                    var y = oct[1];\r\n                    if (bytes == 1) {\r\n                        x /= x < 0 ? 127 : 128;\r\n                        y /= y < 0 ? 127 : 128;\r\n                    } else if (bytes == 2) {\r\n                        x /= x < 0 ? 32767 : 32768;\r\n                        y /= y < 0 ? 32767 : 32768;\r\n                    }\r\n                    var z = 1 - Math.abs(x) - Math.abs(y);\r\n                    if (z < 0) {\r\n                        var tmpx = x;\r\n                        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\r\n                        y = (1 - Math.abs(tmpx)) * (y >= 0 ? 1 : -1);\r\n                    }\r\n                    var length = Math.sqrt(x * x + y * y + z * z);\r\n                    return [\r\n                        x / length,\r\n                        y / length,\r\n                        z / length\r\n                    ];\r\n                }\r\n                function dot(x, y, z, vec3) {\r\n                    return x * vec3[0] + y * vec3[1] + z * vec3[2];\r\n                }\r\n            },\r\n            quantizedEncode: function (array, bytes) {\r\n                let quantized, segments;\r\n                if (bytes == 1) {\r\n                    quantized = new Uint8Array(array.length);\r\n                    segments = 255;\r\n                } else if (bytes == 2) {\r\n                    quantized = new Uint16Array(array.length);\r\n                    segments = 65535;\r\n                } else {\r\n                    console.error('number of bytes error! ');\r\n                }\r\n                let decodeMat = new THREE.Matrix4();\r\n                let min = new Float32Array(3);\r\n                let max = new Float32Array(3);\r\n                min[0] = min[1] = min[2] = Number.MAX_VALUE;\r\n                max[0] = max[1] = max[2] = -Number.MAX_VALUE;\r\n                for (let i = 0; i < array.length; i += 3) {\r\n                    min[0] = Math.min(min[0], array[i + 0]);\r\n                    min[1] = Math.min(min[1], array[i + 1]);\r\n                    min[2] = Math.min(min[2], array[i + 2]);\r\n                    max[0] = Math.max(max[0], array[i + 0]);\r\n                    max[1] = Math.max(max[1], array[i + 1]);\r\n                    max[2] = Math.max(max[2], array[i + 2]);\r\n                }\r\n                decodeMat.scale(new THREE.Vector3((max[0] - min[0]) / segments, (max[1] - min[1]) / segments, (max[2] - min[2]) / segments));\r\n                decodeMat.elements[12] = min[0];\r\n                decodeMat.elements[13] = min[1];\r\n                decodeMat.elements[14] = min[2];\r\n                decodeMat.transpose();\r\n                let multiplier = new Float32Array([\r\n                    max[0] !== min[0] ? segments / (max[0] - min[0]) : 0,\r\n                    max[1] !== min[1] ? segments / (max[1] - min[1]) : 0,\r\n                    max[2] !== min[2] ? segments / (max[2] - min[2]) : 0\r\n                ]);\r\n                for (let i = 0; i < array.length; i += 3) {\r\n                    quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\r\n                    quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\r\n                    quantized[i + 2] = Math.floor((array[i + 2] - min[2]) * multiplier[2]);\r\n                }\r\n                return {\r\n                    quantized: quantized,\r\n                    decodeMat: decodeMat\r\n                };\r\n            },\r\n            quantizedEncodeUV: function (array, bytes) {\r\n                let quantized, segments;\r\n                if (bytes == 1) {\r\n                    quantized = new Uint8Array(array.length);\r\n                    segments = 255;\r\n                } else if (bytes == 2) {\r\n                    quantized = new Uint16Array(array.length);\r\n                    segments = 65535;\r\n                } else {\r\n                    console.error('number of bytes error! ');\r\n                }\r\n                let decodeMat = new THREE.Matrix3();\r\n                let min = new Float32Array(2);\r\n                let max = new Float32Array(2);\r\n                min[0] = min[1] = Number.MAX_VALUE;\r\n                max[0] = max[1] = -Number.MAX_VALUE;\r\n                for (let i = 0; i < array.length; i += 2) {\r\n                    min[0] = Math.min(min[0], array[i + 0]);\r\n                    min[1] = Math.min(min[1], array[i + 1]);\r\n                    max[0] = Math.max(max[0], array[i + 0]);\r\n                    max[1] = Math.max(max[1], array[i + 1]);\r\n                }\r\n                decodeMat.scale((max[0] - min[0]) / segments, (max[1] - min[1]) / segments);\r\n                decodeMat.elements[6] = min[0];\r\n                decodeMat.elements[7] = min[1];\r\n                decodeMat.transpose();\r\n                let multiplier = new Float32Array([\r\n                    max[0] !== min[0] ? segments / (max[0] - min[0]) : 0,\r\n                    max[1] !== min[1] ? segments / (max[1] - min[1]) : 0\r\n                ]);\r\n                for (let i = 0; i < array.length; i += 2) {\r\n                    quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\r\n                    quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\r\n                }\r\n                return {\r\n                    quantized: quantized,\r\n                    decodeMat: decodeMat\r\n                };\r\n            }\r\n        }\r\n    };\r\n    function PackedPhongMaterial(parameters) {\r\n        THREE.MeshPhongMaterial.call(this);\r\n        this.defines = {};\r\n        this.type = 'PackedPhongMaterial';\r\n        this.uniforms = THREE.UniformsUtils.merge([\r\n            THREE.ShaderLib.phong.uniforms,\r\n            {\r\n                quantizeMatPos: { value: null },\r\n                quantizeMatUV: { value: null }\r\n            }\r\n        ]);\r\n        this.vertexShader = [\r\n            '#define PHONG',\r\n            'varying vec3 vViewPosition;',\r\n            '#ifndef FLAT_SHADED',\r\n            'varying vec3 vNormal;',\r\n            '#endif',\r\n            THREE.ShaderChunk.common,\r\n            THREE.ShaderChunk.uv_pars_vertex,\r\n            THREE.ShaderChunk.uv2_pars_vertex,\r\n            THREE.ShaderChunk.displacementmap_pars_vertex,\r\n            THREE.ShaderChunk.envmap_pars_vertex,\r\n            THREE.ShaderChunk.color_pars_vertex,\r\n            THREE.ShaderChunk.fog_pars_vertex,\r\n            THREE.ShaderChunk.morphtarget_pars_vertex,\r\n            THREE.ShaderChunk.skinning_pars_vertex,\r\n            THREE.ShaderChunk.shadowmap_pars_vertex,\r\n            THREE.ShaderChunk.logdepthbuf_pars_vertex,\r\n            THREE.ShaderChunk.clipping_planes_pars_vertex,\r\n            `#ifdef USE_PACKED_NORMAL\r\n\t\t\t#if USE_PACKED_NORMAL == 0\r\n\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat x = packedNormal.x * 2.0 - 1.0;\r\n\t\t\t\t\tfloat y = packedNormal.y * 2.0 - 1.0;\r\n\t\t\t\t\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\r\n\t\t\t\t\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\r\n\t\t\t\t\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\r\n\t\t\t#if USE_PACKED_NORMAL == 1\r\n\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\r\n\t\t\t\t{\r\n\t\t\t\t\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\r\n\t\t\t\t\tif (v.z < 0.0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn normalize(v);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\r\n\t\t\t#if USE_PACKED_NORMAL == 2\r\n\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\r\n\t\t\t\t{\r\n\t\t\t\t\tvec3 v = (packedNormal * 2.0) - 1.0;\r\n\t\t\t\t\treturn normalize(v);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif`,\r\n            `#ifdef USE_PACKED_POSITION\r\n\t\t\t#if USE_PACKED_POSITION == 0\r\n\t\t\t\tuniform mat4 quantizeMatPos;\r\n\t\t\t#endif\r\n\t\t#endif`,\r\n            `#ifdef USE_PACKED_UV\r\n\t\t\t#if USE_PACKED_UV == 1\r\n\t\t\t\tuniform mat3 quantizeMatUV;\r\n\t\t\t#endif\r\n\t\t#endif`,\r\n            `#ifdef USE_PACKED_UV\r\n\t\t\t#if USE_PACKED_UV == 0\r\n\t\t\t\tvec2 decodeUV(vec2 packedUV)\r\n\t\t\t\t{\r\n\t\t\t\t\tvec2 uv = (packedUV * 2.0) - 1.0;\r\n\t\t\t\t\treturn uv;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\r\n\t\t\t#if USE_PACKED_UV == 1\r\n\t\t\t\tvec2 decodeUV(vec2 packedUV)\r\n\t\t\t\t{\r\n\t\t\t\t\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\r\n\t\t\t\t\treturn uv;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif`,\r\n            'void main() {',\r\n            THREE.ShaderChunk.uv_vertex,\r\n            `#ifdef USE_UV\r\n\t\t\t#ifdef USE_PACKED_UV\r\n\t\t\t\tvUv = decodeUV(vUv);\r\n\t\t\t#endif\r\n\t\t#endif`,\r\n            THREE.ShaderChunk.uv2_vertex,\r\n            THREE.ShaderChunk.color_vertex,\r\n            THREE.ShaderChunk.beginnormal_vertex,\r\n            `#ifdef USE_PACKED_NORMAL\r\n\t\t\tobjectNormal = decodeNormal(objectNormal);\r\n\t\t#endif\r\n\r\n\t\t#ifdef USE_TANGENT\r\n\t\t\tvec3 objectTangent = vec3( tangent.xyz );\r\n\t\t#endif\r\n\t\t`,\r\n            THREE.ShaderChunk.morphnormal_vertex,\r\n            THREE.ShaderChunk.skinbase_vertex,\r\n            THREE.ShaderChunk.skinnormal_vertex,\r\n            THREE.ShaderChunk.defaultnormal_vertex,\r\n            '#ifndef FLAT_SHADED',\r\n            '\\tvNormal = normalize( transformedNormal );',\r\n            '#endif',\r\n            THREE.ShaderChunk.begin_vertex,\r\n            `#ifdef USE_PACKED_POSITION\r\n\t\t\t#if USE_PACKED_POSITION == 0\r\n\t\t\t\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\r\n\t\t\t#endif\r\n\t\t#endif`,\r\n            THREE.ShaderChunk.morphtarget_vertex,\r\n            THREE.ShaderChunk.skinning_vertex,\r\n            THREE.ShaderChunk.displacementmap_vertex,\r\n            THREE.ShaderChunk.project_vertex,\r\n            THREE.ShaderChunk.logdepthbuf_vertex,\r\n            THREE.ShaderChunk.clipping_planes_vertex,\r\n            'vViewPosition = - mvPosition.xyz;',\r\n            THREE.ShaderChunk.worldpos_vertex,\r\n            THREE.ShaderChunk.envmap_vertex,\r\n            THREE.ShaderChunk.shadowmap_vertex,\r\n            THREE.ShaderChunk.fog_vertex,\r\n            '}'\r\n        ].join('\\n');\r\n        this.fragmentShader = [\r\n            '#define PHONG',\r\n            'uniform vec3 diffuse;',\r\n            'uniform vec3 emissive;',\r\n            'uniform vec3 specular;',\r\n            'uniform float shininess;',\r\n            'uniform float opacity;',\r\n            THREE.ShaderChunk.common,\r\n            THREE.ShaderChunk.packing,\r\n            THREE.ShaderChunk.dithering_pars_fragment,\r\n            THREE.ShaderChunk.color_pars_fragment,\r\n            THREE.ShaderChunk.uv_pars_fragment,\r\n            THREE.ShaderChunk.uv2_pars_fragment,\r\n            THREE.ShaderChunk.map_pars_fragment,\r\n            THREE.ShaderChunk.alphamap_pars_fragment,\r\n            THREE.ShaderChunk.aomap_pars_fragment,\r\n            THREE.ShaderChunk.lightmap_pars_fragment,\r\n            THREE.ShaderChunk.emissivemap_pars_fragment,\r\n            THREE.ShaderChunk.envmap_common_pars_fragment,\r\n            THREE.ShaderChunk.envmap_pars_fragment,\r\n            THREE.ShaderChunk.cube_uv_reflection_fragment,\r\n            THREE.ShaderChunk.fog_pars_fragment,\r\n            THREE.ShaderChunk.bsdfs,\r\n            THREE.ShaderChunk.lights_pars_begin,\r\n            THREE.ShaderChunk.lights_phong_pars_fragment,\r\n            THREE.ShaderChunk.shadowmap_pars_fragment,\r\n            THREE.ShaderChunk.bumpmap_pars_fragment,\r\n            THREE.ShaderChunk.normalmap_pars_fragment,\r\n            THREE.ShaderChunk.specularmap_pars_fragment,\r\n            THREE.ShaderChunk.logdepthbuf_pars_fragment,\r\n            THREE.ShaderChunk.clipping_planes_pars_fragment,\r\n            'void main() {',\r\n            THREE.ShaderChunk.clipping_planes_fragment,\r\n            'vec4 diffuseColor = vec4( diffuse, opacity );',\r\n            'ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );',\r\n            'vec3 totalEmissiveRadiance = emissive;',\r\n            THREE.ShaderChunk.logdepthbuf_fragment,\r\n            THREE.ShaderChunk.map_fragment,\r\n            THREE.ShaderChunk.color_fragment,\r\n            THREE.ShaderChunk.alphamap_fragment,\r\n            THREE.ShaderChunk.alphatest_fragment,\r\n            THREE.ShaderChunk.specularmap_fragment,\r\n            THREE.ShaderChunk.normal_fragment_begin,\r\n            THREE.ShaderChunk.normal_fragment_maps,\r\n            THREE.ShaderChunk.emissivemap_fragment,\r\n            THREE.ShaderChunk.lights_phong_fragment,\r\n            THREE.ShaderChunk.lights_fragment_begin,\r\n            THREE.ShaderChunk.lights_fragment_maps,\r\n            THREE.ShaderChunk.lights_fragment_end,\r\n            THREE.ShaderChunk.aomap_fragment,\r\n            'vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;',\r\n            THREE.ShaderChunk.envmap_fragment,\r\n            'gl_FragColor = vec4( outgoingLight, diffuseColor.a );',\r\n            THREE.ShaderChunk.tonemapping_fragment,\r\n            THREE.ShaderChunk.encodings_fragment,\r\n            THREE.ShaderChunk.fog_fragment,\r\n            THREE.ShaderChunk.premultiplied_alpha_fragment,\r\n            THREE.ShaderChunk.dithering_fragment,\r\n            '}'\r\n        ].join('\\n');\r\n        this.setValues(parameters);\r\n    }\r\n    PackedPhongMaterial.prototype = Object.create(THREE.MeshPhongMaterial.prototype);\r\n\r\n    GeometryCompressionUtils.PackedPhongMaterial = PackedPhongMaterial;\r\n\r\n    return threex.utils.GeometryCompressionUtils = GeometryCompressionUtils;\r\n});"]}