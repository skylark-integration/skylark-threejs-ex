{"version":3,"sources":["utils/GeometryCompressionUtils.js"],"names":["define","THREE","GeometryCompressionUtils","compressNormals","mesh","encodeMethod","geometry","console","error","normal","attributes","isPacked","itemSize","result","array","count","Uint8Array","idx","length","encoded","this","EncodingFuncs","defaultEncode","setAttribute","BufferAttribute","bytes","Int8Array","octEncodeBest","Int16Array","Uint16Array","anglesEncode","needsUpdate","packingMethod","material","PackedPhongMaterial","copy","defines","USE_PACKED_NORMAL","compressPositions","position","quantizedEncode","quantized","decodeMat","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","USE_PACKED_POSITION","uniforms","quantizeMatPos","value","compressUvs","uvs","uv","range","min","Infinity","max","i","Math","USE_PACKED_UV","quantizedEncodeUV","quantizeMatUV","x","y","z","tmpx","round","tmpy","tmpz","defaultDecode","normal0","parseInt","atan2","PI","normal1","oct","dec","best","currentCos","bestCos","octEncodeVec3","octDecodeVec2","dot","x0","y0","z0","xfunc","yfunc","abs","tempx","tempy","diff","sqrt","vec3","segments","Matrix4","Float32Array","Number","MAX_VALUE","scale","Vector3","elements","transpose","multiplier","floor","Matrix3","parameters","MeshPhongMaterial","call","type","UniformsUtils","merge","ShaderLib","phong","vertexShader","ShaderChunk","common","uv_pars_vertex","uv2_pars_vertex","displacementmap_pars_vertex","envmap_pars_vertex","color_pars_vertex","fog_pars_vertex","morphtarget_pars_vertex","skinning_pars_vertex","shadowmap_pars_vertex","logdepthbuf_pars_vertex","clipping_planes_pars_vertex","uv_vertex","uv2_vertex","color_vertex","beginnormal_vertex","morphnormal_vertex","skinbase_vertex","skinnormal_vertex","defaultnormal_vertex","begin_vertex","morphtarget_vertex","skinning_vertex","displacementmap_vertex","project_vertex","logdepthbuf_vertex","clipping_planes_vertex","worldpos_vertex","envmap_vertex","shadowmap_vertex","fog_vertex","join","fragmentShader","packing","dithering_pars_fragment","color_pars_fragment","uv_pars_fragment","uv2_pars_fragment","map_pars_fragment","alphamap_pars_fragment","aomap_pars_fragment","lightmap_pars_fragment","emissivemap_pars_fragment","envmap_common_pars_fragment","envmap_pars_fragment","cube_uv_reflection_fragment","fog_pars_fragment","bsdfs","lights_pars_begin","lights_phong_pars_fragment","shadowmap_pars_fragment","bumpmap_pars_fragment","normalmap_pars_fragment","specularmap_pars_fragment","logdepthbuf_pars_fragment","clipping_planes_pars_fragment","clipping_planes_fragment","logdepthbuf_fragment","map_fragment","color_fragment","alphamap_fragment","alphatest_fragment","specularmap_fragment","normal_fragment_begin","normal_fragment_maps","emissivemap_fragment","lights_phong_fragment","lights_fragment_begin","lights_fragment_maps","lights_fragment_end","aomap_fragment","envmap_fragment","tonemapping_fragment","encodings_fragment","fog_fragment","premultiplied_alpha_fragment","dithering_fragment","setValues","prototype","Object","create"],"mappings":"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","file":"../../utils/GeometryCompressionUtils.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var GeometryCompressionUtils = {\n        compressNormals: function (mesh, encodeMethod) {\n            if (!mesh.geometry) {\n                console.error('Mesh must contain geometry. ');\n            }\n            let normal = mesh.geometry.attributes.normal;\n            if (!normal) {\n                console.error('Geometry must contain normal attribute. ');\n            }\n            if (normal.isPacked)\n                return;\n            if (normal.itemSize != 3) {\n                console.error('normal.itemSize is not 3, which cannot be encoded. ');\n            }\n            let array = normal.array;\n            let count = normal.count;\n            let result;\n            if (encodeMethod == 'DEFAULT') {\n                result = new Uint8Array(count * 3);\n                for (let idx = 0; idx < array.length; idx += 3) {\n                    let encoded;\n                    encoded = this.EncodingFuncs.defaultEncode(array[idx], array[idx + 1], array[idx + 2], 1);\n                    result[idx + 0] = encoded[0];\n                    result[idx + 1] = encoded[1];\n                    result[idx + 2] = encoded[2];\n                }\n                mesh.geometry.setAttribute('normal', new THREE.BufferAttribute(result, 3, true));\n                mesh.geometry.attributes.normal.bytes = result.length * 1;\n            } else if (encodeMethod == 'OCT1Byte') {\n                result = new Int8Array(count * 2);\n                for (let idx = 0; idx < array.length; idx += 3) {\n                    let encoded;\n                    encoded = this.EncodingFuncs.octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 1);\n                    result[idx / 3 * 2 + 0] = encoded[0];\n                    result[idx / 3 * 2 + 1] = encoded[1];\n                }\n                mesh.geometry.setAttribute('normal', new THREE.BufferAttribute(result, 2, true));\n                mesh.geometry.attributes.normal.bytes = result.length * 1;\n            } else if (encodeMethod == 'OCT2Byte') {\n                result = new Int16Array(count * 2);\n                for (let idx = 0; idx < array.length; idx += 3) {\n                    let encoded;\n                    encoded = this.EncodingFuncs.octEncodeBest(array[idx], array[idx + 1], array[idx + 2], 2);\n                    result[idx / 3 * 2 + 0] = encoded[0];\n                    result[idx / 3 * 2 + 1] = encoded[1];\n                }\n                mesh.geometry.setAttribute('normal', new THREE.BufferAttribute(result, 2, true));\n                mesh.geometry.attributes.normal.bytes = result.length * 2;\n            } else if (encodeMethod == 'ANGLES') {\n                result = new Uint16Array(count * 2);\n                for (let idx = 0; idx < array.length; idx += 3) {\n                    let encoded;\n                    encoded = this.EncodingFuncs.anglesEncode(array[idx], array[idx + 1], array[idx + 2]);\n                    result[idx / 3 * 2 + 0] = encoded[0];\n                    result[idx / 3 * 2 + 1] = encoded[1];\n                }\n                mesh.geometry.setAttribute('normal', new THREE.BufferAttribute(result, 2, true));\n                mesh.geometry.attributes.normal.bytes = result.length * 2;\n            } else {\n                console.error('Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ');\n            }\n            mesh.geometry.attributes.normal.needsUpdate = true;\n            mesh.geometry.attributes.normal.isPacked = true;\n            mesh.geometry.attributes.normal.packingMethod = encodeMethod;\n            if (!(mesh.material instanceof PackedPhongMaterial)) {\n                mesh.material = new PackedPhongMaterial().copy(mesh.material);\n            }\n            if (encodeMethod == 'ANGLES') {\n                mesh.material.defines.USE_PACKED_NORMAL = 0;\n            }\n            if (encodeMethod == 'OCT1Byte') {\n                mesh.material.defines.USE_PACKED_NORMAL = 1;\n            }\n            if (encodeMethod == 'OCT2Byte') {\n                mesh.material.defines.USE_PACKED_NORMAL = 1;\n            }\n            if (encodeMethod == 'DEFAULT') {\n                mesh.material.defines.USE_PACKED_NORMAL = 2;\n            }\n        },\n        compressPositions: function (mesh) {\n            if (!mesh.geometry) {\n                console.error('Mesh must contain geometry. ');\n            }\n            let position = mesh.geometry.attributes.position;\n            if (!position) {\n                console.error('Geometry must contain position attribute. ');\n            }\n            if (position.isPacked)\n                return;\n            if (position.itemSize != 3) {\n                console.error('position.itemSize is not 3, which cannot be packed. ');\n            }\n            let array = position.array;\n            let encodingBytes = 2;\n            let result = this.EncodingFuncs.quantizedEncode(array, encodingBytes);\n            let quantized = result.quantized;\n            let decodeMat = result.decodeMat;\n            if (mesh.geometry.boundingBox == null)\n                mesh.geometry.computeBoundingBox();\n            if (mesh.geometry.boundingSphere == null)\n                mesh.geometry.computeBoundingSphere();\n            mesh.geometry.setAttribute('position', new THREE.BufferAttribute(quantized, 3));\n            mesh.geometry.attributes.position.isPacked = true;\n            mesh.geometry.attributes.position.needsUpdate = true;\n            mesh.geometry.attributes.position.bytes = quantized.length * encodingBytes;\n            if (!(mesh.material instanceof PackedPhongMaterial)) {\n                mesh.material = new PackedPhongMaterial().copy(mesh.material);\n            }\n            mesh.material.defines.USE_PACKED_POSITION = 0;\n            mesh.material.uniforms.quantizeMatPos.value = decodeMat;\n            mesh.material.uniforms.quantizeMatPos.needsUpdate = true;\n        },\n        compressUvs: function (mesh) {\n            if (!mesh.geometry) {\n                console.error('Mesh must contain geometry property. ');\n            }\n            let uvs = mesh.geometry.attributes.uv;\n            if (!uvs) {\n                console.error('Geometry must contain uv attribute. ');\n            }\n            if (uvs.isPacked)\n                return;\n            let range = {\n                min: Infinity,\n                max: -Infinity\n            };\n            let array = uvs.array;\n            for (let i = 0; i < array.length; i++) {\n                range.min = Math.min(range.min, array[i]);\n                range.max = Math.max(range.max, array[i]);\n            }\n            let result;\n            if (range.min >= -1 && range.max <= 1) {\n                result = new Uint16Array(array.length);\n                for (let i = 0; i < array.length; i += 2) {\n                    let encoded = this.EncodingFuncs.defaultEncode(array[i], array[i + 1], 0, 2);\n                    result[i] = encoded[0];\n                    result[i + 1] = encoded[1];\n                }\n                mesh.geometry.setAttribute('uv', new THREE.BufferAttribute(result, 2, true));\n                mesh.geometry.attributes.uv.isPacked = true;\n                mesh.geometry.attributes.uv.needsUpdate = true;\n                mesh.geometry.attributes.uv.bytes = result.length * 2;\n                if (!(mesh.material instanceof PackedPhongMaterial)) {\n                    mesh.material = new PackedPhongMaterial().copy(mesh.material);\n                }\n                mesh.material.defines.USE_PACKED_UV = 0;\n            } else {\n                result = this.EncodingFuncs.quantizedEncodeUV(array, 2);\n                mesh.geometry.setAttribute('uv', new THREE.BufferAttribute(result.quantized, 2));\n                mesh.geometry.attributes.uv.isPacked = true;\n                mesh.geometry.attributes.uv.needsUpdate = true;\n                mesh.geometry.attributes.uv.bytes = result.quantized.length * 2;\n                if (!(mesh.material instanceof PackedPhongMaterial)) {\n                    mesh.material = new PackedPhongMaterial().copy(mesh.material);\n                }\n                mesh.material.defines.USE_PACKED_UV = 1;\n                mesh.material.uniforms.quantizeMatUV.value = result.decodeMat;\n                mesh.material.uniforms.quantizeMatUV.needsUpdate = true;\n            }\n        },\n        EncodingFuncs: {\n            defaultEncode: function (x, y, z, bytes) {\n                if (bytes == 1) {\n                    let tmpx = Math.round((x + 1) * 0.5 * 255);\n                    let tmpy = Math.round((y + 1) * 0.5 * 255);\n                    let tmpz = Math.round((z + 1) * 0.5 * 255);\n                    return new Uint8Array([\n                        tmpx,\n                        tmpy,\n                        tmpz\n                    ]);\n                } else if (bytes == 2) {\n                    let tmpx = Math.round((x + 1) * 0.5 * 65535);\n                    let tmpy = Math.round((y + 1) * 0.5 * 65535);\n                    let tmpz = Math.round((z + 1) * 0.5 * 65535);\n                    return new Uint16Array([\n                        tmpx,\n                        tmpy,\n                        tmpz\n                    ]);\n                } else {\n                    console.error('number of bytes must be 1 or 2');\n                }\n            },\n            defaultDecode: function (array, bytes) {\n                if (bytes == 1) {\n                    return [\n                        array[0] / 255 * 2 - 1,\n                        array[1] / 255 * 2 - 1,\n                        array[2] / 255 * 2 - 1\n                    ];\n                } else if (bytes == 2) {\n                    return [\n                        array[0] / 65535 * 2 - 1,\n                        array[1] / 65535 * 2 - 1,\n                        array[2] / 65535 * 2 - 1\n                    ];\n                } else {\n                    console.error('number of bytes must be 1 or 2');\n                }\n            },\n            anglesEncode: function (x, y, z) {\n                let normal0 = parseInt(0.5 * (1 + Math.atan2(y, x) / Math.PI) * 65535);\n                let normal1 = parseInt(0.5 * (1 + z) * 65535);\n                return new Uint16Array([\n                    normal0,\n                    normal1\n                ]);\n            },\n            octEncodeBest: function (x, y, z, bytes) {\n                var oct, dec, best, currentCos, bestCos;\n                best = oct = octEncodeVec3(x, y, z, 'floor', 'floor');\n                dec = octDecodeVec2(oct);\n                bestCos = dot(x, y, z, dec);\n                oct = octEncodeVec3(x, y, z, 'ceil', 'floor');\n                dec = octDecodeVec2(oct);\n                currentCos = dot(x, y, z, dec);\n                if (currentCos > bestCos) {\n                    best = oct;\n                    bestCos = currentCos;\n                }\n                oct = octEncodeVec3(x, y, z, 'floor', 'ceil');\n                dec = octDecodeVec2(oct);\n                currentCos = dot(x, y, z, dec);\n                if (currentCos > bestCos) {\n                    best = oct;\n                    bestCos = currentCos;\n                }\n                oct = octEncodeVec3(x, y, z, 'ceil', 'ceil');\n                dec = octDecodeVec2(oct);\n                currentCos = dot(x, y, z, dec);\n                if (currentCos > bestCos) {\n                    best = oct;\n                }\n                return best;\n                function octEncodeVec3(x0, y0, z0, xfunc, yfunc) {\n                    var x = x0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n                    var y = y0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));\n                    if (z < 0) {\n                        var tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n                        var tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n                        x = tempx;\n                        y = tempy;\n                        var diff = 1 - Math.abs(x) - Math.abs(y);\n                        if (diff > 0) {\n                            diff += 0.001;\n                            x += x > 0 ? diff / 2 : -diff / 2;\n                            y += y > 0 ? diff / 2 : -diff / 2;\n                        }\n                    }\n                    if (bytes == 1) {\n                        return new Int8Array([\n                            Math[xfunc](x * 127.5 + (x < 0 ? 1 : 0)),\n                            Math[yfunc](y * 127.5 + (y < 0 ? 1 : 0))\n                        ]);\n                    }\n                    if (bytes == 2) {\n                        return new Int16Array([\n                            Math[xfunc](x * 32767.5 + (x < 0 ? 1 : 0)),\n                            Math[yfunc](y * 32767.5 + (y < 0 ? 1 : 0))\n                        ]);\n                    }\n                }\n                function octDecodeVec2(oct) {\n                    var x = oct[0];\n                    var y = oct[1];\n                    if (bytes == 1) {\n                        x /= x < 0 ? 127 : 128;\n                        y /= y < 0 ? 127 : 128;\n                    } else if (bytes == 2) {\n                        x /= x < 0 ? 32767 : 32768;\n                        y /= y < 0 ? 32767 : 32768;\n                    }\n                    var z = 1 - Math.abs(x) - Math.abs(y);\n                    if (z < 0) {\n                        var tmpx = x;\n                        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n                        y = (1 - Math.abs(tmpx)) * (y >= 0 ? 1 : -1);\n                    }\n                    var length = Math.sqrt(x * x + y * y + z * z);\n                    return [\n                        x / length,\n                        y / length,\n                        z / length\n                    ];\n                }\n                function dot(x, y, z, vec3) {\n                    return x * vec3[0] + y * vec3[1] + z * vec3[2];\n                }\n            },\n            quantizedEncode: function (array, bytes) {\n                let quantized, segments;\n                if (bytes == 1) {\n                    quantized = new Uint8Array(array.length);\n                    segments = 255;\n                } else if (bytes == 2) {\n                    quantized = new Uint16Array(array.length);\n                    segments = 65535;\n                } else {\n                    console.error('number of bytes error! ');\n                }\n                let decodeMat = new THREE.Matrix4();\n                let min = new Float32Array(3);\n                let max = new Float32Array(3);\n                min[0] = min[1] = min[2] = Number.MAX_VALUE;\n                max[0] = max[1] = max[2] = -Number.MAX_VALUE;\n                for (let i = 0; i < array.length; i += 3) {\n                    min[0] = Math.min(min[0], array[i + 0]);\n                    min[1] = Math.min(min[1], array[i + 1]);\n                    min[2] = Math.min(min[2], array[i + 2]);\n                    max[0] = Math.max(max[0], array[i + 0]);\n                    max[1] = Math.max(max[1], array[i + 1]);\n                    max[2] = Math.max(max[2], array[i + 2]);\n                }\n                decodeMat.scale(new THREE.Vector3((max[0] - min[0]) / segments, (max[1] - min[1]) / segments, (max[2] - min[2]) / segments));\n                decodeMat.elements[12] = min[0];\n                decodeMat.elements[13] = min[1];\n                decodeMat.elements[14] = min[2];\n                decodeMat.transpose();\n                let multiplier = new Float32Array([\n                    max[0] !== min[0] ? segments / (max[0] - min[0]) : 0,\n                    max[1] !== min[1] ? segments / (max[1] - min[1]) : 0,\n                    max[2] !== min[2] ? segments / (max[2] - min[2]) : 0\n                ]);\n                for (let i = 0; i < array.length; i += 3) {\n                    quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n                    quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n                    quantized[i + 2] = Math.floor((array[i + 2] - min[2]) * multiplier[2]);\n                }\n                return {\n                    quantized: quantized,\n                    decodeMat: decodeMat\n                };\n            },\n            quantizedEncodeUV: function (array, bytes) {\n                let quantized, segments;\n                if (bytes == 1) {\n                    quantized = new Uint8Array(array.length);\n                    segments = 255;\n                } else if (bytes == 2) {\n                    quantized = new Uint16Array(array.length);\n                    segments = 65535;\n                } else {\n                    console.error('number of bytes error! ');\n                }\n                let decodeMat = new THREE.Matrix3();\n                let min = new Float32Array(2);\n                let max = new Float32Array(2);\n                min[0] = min[1] = Number.MAX_VALUE;\n                max[0] = max[1] = -Number.MAX_VALUE;\n                for (let i = 0; i < array.length; i += 2) {\n                    min[0] = Math.min(min[0], array[i + 0]);\n                    min[1] = Math.min(min[1], array[i + 1]);\n                    max[0] = Math.max(max[0], array[i + 0]);\n                    max[1] = Math.max(max[1], array[i + 1]);\n                }\n                decodeMat.scale((max[0] - min[0]) / segments, (max[1] - min[1]) / segments);\n                decodeMat.elements[6] = min[0];\n                decodeMat.elements[7] = min[1];\n                decodeMat.transpose();\n                let multiplier = new Float32Array([\n                    max[0] !== min[0] ? segments / (max[0] - min[0]) : 0,\n                    max[1] !== min[1] ? segments / (max[1] - min[1]) : 0\n                ]);\n                for (let i = 0; i < array.length; i += 2) {\n                    quantized[i + 0] = Math.floor((array[i + 0] - min[0]) * multiplier[0]);\n                    quantized[i + 1] = Math.floor((array[i + 1] - min[1]) * multiplier[1]);\n                }\n                return {\n                    quantized: quantized,\n                    decodeMat: decodeMat\n                };\n            }\n        }\n    };\n    function PackedPhongMaterial(parameters) {\n        THREE.MeshPhongMaterial.call(this);\n        this.defines = {};\n        this.type = 'PackedPhongMaterial';\n        this.uniforms = THREE.UniformsUtils.merge([\n            THREE.ShaderLib.phong.uniforms,\n            {\n                quantizeMatPos: { value: null },\n                quantizeMatUV: { value: null }\n            }\n        ]);\n        this.vertexShader = [\n            '#define PHONG',\n            'varying vec3 vViewPosition;',\n            '#ifndef FLAT_SHADED',\n            'varying vec3 vNormal;',\n            '#endif',\n            THREE.ShaderChunk.common,\n            THREE.ShaderChunk.uv_pars_vertex,\n            THREE.ShaderChunk.uv2_pars_vertex,\n            THREE.ShaderChunk.displacementmap_pars_vertex,\n            THREE.ShaderChunk.envmap_pars_vertex,\n            THREE.ShaderChunk.color_pars_vertex,\n            THREE.ShaderChunk.fog_pars_vertex,\n            THREE.ShaderChunk.morphtarget_pars_vertex,\n            THREE.ShaderChunk.skinning_pars_vertex,\n            THREE.ShaderChunk.shadowmap_pars_vertex,\n            THREE.ShaderChunk.logdepthbuf_pars_vertex,\n            THREE.ShaderChunk.clipping_planes_pars_vertex,\n            `#ifdef USE_PACKED_NORMAL\n\t\t\t#if USE_PACKED_NORMAL == 0\n\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t{\n\t\t\t\t\tfloat x = packedNormal.x * 2.0 - 1.0;\n\t\t\t\t\tfloat y = packedNormal.y * 2.0 - 1.0;\n\t\t\t\t\tvec2 scth = vec2(sin(x * PI), cos(x * PI));\n\t\t\t\t\tvec2 scphi = vec2(sqrt(1.0 - y * y), y);\n\t\t\t\t\treturn normalize( vec3(scth.y * scphi.x, scth.x * scphi.x, scphi.y) );\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t#if USE_PACKED_NORMAL == 1\n\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t{\n\t\t\t\t\tvec3 v = vec3(packedNormal.xy, 1.0 - abs(packedNormal.x) - abs(packedNormal.y));\n\t\t\t\t\tif (v.z < 0.0)\n\t\t\t\t\t{\n\t\t\t\t\t\tv.xy = (1.0 - abs(v.yx)) * vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n\t\t\t\t\t}\n\t\t\t\t\treturn normalize(v);\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t#if USE_PACKED_NORMAL == 2\n\t\t\t\tvec3 decodeNormal(vec3 packedNormal)\n\t\t\t\t{\n\t\t\t\t\tvec3 v = (packedNormal * 2.0) - 1.0;\n\t\t\t\t\treturn normalize(v);\n\t\t\t\t}\n\t\t\t#endif\n\t\t#endif`,\n            `#ifdef USE_PACKED_POSITION\n\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\tuniform mat4 quantizeMatPos;\n\t\t\t#endif\n\t\t#endif`,\n            `#ifdef USE_PACKED_UV\n\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\tuniform mat3 quantizeMatUV;\n\t\t\t#endif\n\t\t#endif`,\n            `#ifdef USE_PACKED_UV\n\t\t\t#if USE_PACKED_UV == 0\n\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t{\n\t\t\t\t\tvec2 uv = (packedUV * 2.0) - 1.0;\n\t\t\t\t\treturn uv;\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t#if USE_PACKED_UV == 1\n\t\t\t\tvec2 decodeUV(vec2 packedUV)\n\t\t\t\t{\n\t\t\t\t\tvec2 uv = ( vec3(packedUV, 1.0) * quantizeMatUV ).xy;\n\t\t\t\t\treturn uv;\n\t\t\t\t}\n\t\t\t#endif\n\t\t#endif`,\n            'void main() {',\n            THREE.ShaderChunk.uv_vertex,\n            `#ifdef USE_UV\n\t\t\t#ifdef USE_PACKED_UV\n\t\t\t\tvUv = decodeUV(vUv);\n\t\t\t#endif\n\t\t#endif`,\n            THREE.ShaderChunk.uv2_vertex,\n            THREE.ShaderChunk.color_vertex,\n            THREE.ShaderChunk.beginnormal_vertex,\n            `#ifdef USE_PACKED_NORMAL\n\t\t\tobjectNormal = decodeNormal(objectNormal);\n\t\t#endif\n\n\t\t#ifdef USE_TANGENT\n\t\t\tvec3 objectTangent = vec3( tangent.xyz );\n\t\t#endif\n\t\t`,\n            THREE.ShaderChunk.morphnormal_vertex,\n            THREE.ShaderChunk.skinbase_vertex,\n            THREE.ShaderChunk.skinnormal_vertex,\n            THREE.ShaderChunk.defaultnormal_vertex,\n            '#ifndef FLAT_SHADED',\n            '\\tvNormal = normalize( transformedNormal );',\n            '#endif',\n            THREE.ShaderChunk.begin_vertex,\n            `#ifdef USE_PACKED_POSITION\n\t\t\t#if USE_PACKED_POSITION == 0\n\t\t\t\ttransformed = ( vec4(transformed, 1.0) * quantizeMatPos ).xyz;\n\t\t\t#endif\n\t\t#endif`,\n            THREE.ShaderChunk.morphtarget_vertex,\n            THREE.ShaderChunk.skinning_vertex,\n            THREE.ShaderChunk.displacementmap_vertex,\n            THREE.ShaderChunk.project_vertex,\n            THREE.ShaderChunk.logdepthbuf_vertex,\n            THREE.ShaderChunk.clipping_planes_vertex,\n            'vViewPosition = - mvPosition.xyz;',\n            THREE.ShaderChunk.worldpos_vertex,\n            THREE.ShaderChunk.envmap_vertex,\n            THREE.ShaderChunk.shadowmap_vertex,\n            THREE.ShaderChunk.fog_vertex,\n            '}'\n        ].join('\\n');\n        this.fragmentShader = [\n            '#define PHONG',\n            'uniform vec3 diffuse;',\n            'uniform vec3 emissive;',\n            'uniform vec3 specular;',\n            'uniform float shininess;',\n            'uniform float opacity;',\n            THREE.ShaderChunk.common,\n            THREE.ShaderChunk.packing,\n            THREE.ShaderChunk.dithering_pars_fragment,\n            THREE.ShaderChunk.color_pars_fragment,\n            THREE.ShaderChunk.uv_pars_fragment,\n            THREE.ShaderChunk.uv2_pars_fragment,\n            THREE.ShaderChunk.map_pars_fragment,\n            THREE.ShaderChunk.alphamap_pars_fragment,\n            THREE.ShaderChunk.aomap_pars_fragment,\n            THREE.ShaderChunk.lightmap_pars_fragment,\n            THREE.ShaderChunk.emissivemap_pars_fragment,\n            THREE.ShaderChunk.envmap_common_pars_fragment,\n            THREE.ShaderChunk.envmap_pars_fragment,\n            THREE.ShaderChunk.cube_uv_reflection_fragment,\n            THREE.ShaderChunk.fog_pars_fragment,\n            THREE.ShaderChunk.bsdfs,\n            THREE.ShaderChunk.lights_pars_begin,\n            THREE.ShaderChunk.lights_phong_pars_fragment,\n            THREE.ShaderChunk.shadowmap_pars_fragment,\n            THREE.ShaderChunk.bumpmap_pars_fragment,\n            THREE.ShaderChunk.normalmap_pars_fragment,\n            THREE.ShaderChunk.specularmap_pars_fragment,\n            THREE.ShaderChunk.logdepthbuf_pars_fragment,\n            THREE.ShaderChunk.clipping_planes_pars_fragment,\n            'void main() {',\n            THREE.ShaderChunk.clipping_planes_fragment,\n            'vec4 diffuseColor = vec4( diffuse, opacity );',\n            'ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );',\n            'vec3 totalEmissiveRadiance = emissive;',\n            THREE.ShaderChunk.logdepthbuf_fragment,\n            THREE.ShaderChunk.map_fragment,\n            THREE.ShaderChunk.color_fragment,\n            THREE.ShaderChunk.alphamap_fragment,\n            THREE.ShaderChunk.alphatest_fragment,\n            THREE.ShaderChunk.specularmap_fragment,\n            THREE.ShaderChunk.normal_fragment_begin,\n            THREE.ShaderChunk.normal_fragment_maps,\n            THREE.ShaderChunk.emissivemap_fragment,\n            THREE.ShaderChunk.lights_phong_fragment,\n            THREE.ShaderChunk.lights_fragment_begin,\n            THREE.ShaderChunk.lights_fragment_maps,\n            THREE.ShaderChunk.lights_fragment_end,\n            THREE.ShaderChunk.aomap_fragment,\n            'vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;',\n            THREE.ShaderChunk.envmap_fragment,\n            'gl_FragColor = vec4( outgoingLight, diffuseColor.a );',\n            THREE.ShaderChunk.tonemapping_fragment,\n            THREE.ShaderChunk.encodings_fragment,\n            THREE.ShaderChunk.fog_fragment,\n            THREE.ShaderChunk.premultiplied_alpha_fragment,\n            THREE.ShaderChunk.dithering_fragment,\n            '}'\n        ].join('\\n');\n        this.setValues(parameters);\n    }\n    PackedPhongMaterial.prototype = Object.create(THREE.MeshPhongMaterial.prototype);\n\n    GeometryCompressionUtils.PackedPhongMaterial = PackedPhongMaterial;\n\n    return GeometryCompressionUtils;\n});"]}