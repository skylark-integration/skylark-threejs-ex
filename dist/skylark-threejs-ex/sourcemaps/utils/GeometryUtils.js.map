{"version":3,"sources":["utils/GeometryUtils.js"],"names":["define","THREE","GeometryUtils","hilbert2D","center","size","iterations","v0","v1","v2","v3","undefined","Vector3","half","vec_s","x","y","z","vec","tmp","Array","prototype","push","apply","hilbert3D","v4","v5","v6","v7"],"mappings":"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","file":"../../utils/GeometryUtils.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\n\tTHREE.GeometryUtils = {\n\n\t\t/**\n\t\t * Generates 2D-Coordinates in a very fast way.\n\t\t *\n\t\t * @author Dylan Grafmyre\n\t\t *\n\t\t * Based on work by:\n\t\t * @author Thomas Diewald\n\t\t * @link http://www.openprocessing.org/sketch/15493\n\t\t *\n\t\t * @param center     Center of Hilbert curve.\n\t\t * @param size       Total width of Hilbert curve.\n\t\t * @param iterations Number of subdivisions.\n\t\t * @param v0         Corner index -X, -Z.\n\t\t * @param v1         Corner index -X, +Z.\n\t\t * @param v2         Corner index +X, +Z.\n\t\t * @param v3         Corner index +X, -Z.\n\t\t */\n\t\thilbert2D: function ( center, size, iterations, v0, v1, v2, v3 ) {\n\n\t\t\t// Default Vars\n\t\t\tvar center = center !== undefined ? center : new THREE.Vector3( 0, 0, 0 ),\n\t\t\t\tsize = size !== undefined ? size : 10,\n\t\t\t\thalf = size / 2,\n\t\t\t\titerations = iterations !== undefined ? iterations : 1,\n\t\t\t\tv0 = v0 !== undefined ? v0 : 0,\n\t\t\t\tv1 = v1 !== undefined ? v1 : 1,\n\t\t\t\tv2 = v2 !== undefined ? v2 : 2,\n\t\t\t\tv3 = v3 !== undefined ? v3 : 3\n\t\t\t;\n\n\t\t\tvar vec_s = [\n\t\t\t\tnew THREE.Vector3( center.x - half, center.y, center.z - half ),\n\t\t\t\tnew THREE.Vector3( center.x - half, center.y, center.z + half ),\n\t\t\t\tnew THREE.Vector3( center.x + half, center.y, center.z + half ),\n\t\t\t\tnew THREE.Vector3( center.x + half, center.y, center.z - half )\n\t\t\t];\n\n\t\t\tvar vec = [\n\t\t\t\tvec_s[ v0 ],\n\t\t\t\tvec_s[ v1 ],\n\t\t\t\tvec_s[ v2 ],\n\t\t\t\tvec_s[ v3 ]\n\t\t\t];\n\n\t\t\t// Recurse iterations\n\t\t\tif ( 0 <= -- iterations ) {\n\n\t\t\t\tvar tmp = [];\n\n\t\t\t\tArray.prototype.push.apply( tmp, THREE.GeometryUtils.hilbert2D( vec[ 0 ], half, iterations, v0, v3, v2, v1 ) );\n\t\t\t\tArray.prototype.push.apply( tmp, THREE.GeometryUtils.hilbert2D( vec[ 1 ], half, iterations, v0, v1, v2, v3 ) );\n\t\t\t\tArray.prototype.push.apply( tmp, THREE.GeometryUtils.hilbert2D( vec[ 2 ], half, iterations, v0, v1, v2, v3 ) );\n\t\t\t\tArray.prototype.push.apply( tmp, THREE.GeometryUtils.hilbert2D( vec[ 3 ], half, iterations, v2, v1, v0, v3 ) );\n\n\t\t\t\t// Return recursive call\n\t\t\t\treturn tmp;\n\n\t\t\t}\n\n\t\t\t// Return complete Hilbert Curve.\n\t\t\treturn vec;\n\n\t\t},\n\n\t\t/**\n\t\t * Generates 3D-Coordinates in a very fast way.\n\t\t *\n\t\t * @author Dylan Grafmyre\n\t\t *\n\t\t * Based on work by:\n\t\t * @author Thomas Diewald\n\t\t * @link http://www.openprocessing.org/visuals/?visualID=15599\n\t\t *\n\t\t * @param center     Center of Hilbert curve.\n\t\t * @param size       Total width of Hilbert curve.\n\t\t * @param iterations Number of subdivisions.\n\t\t * @param v0         Corner index -X, +Y, -Z.\n\t\t * @param v1         Corner index -X, +Y, +Z.\n\t\t * @param v2         Corner index -X, -Y, +Z.\n\t\t * @param v3         Corner index -X, -Y, -Z.\n\t\t * @param v4         Corner index +X, -Y, -Z.\n\t\t * @param v5         Corner index +X, -Y, +Z.\n\t\t * @param v6         Corner index +X, +Y, +Z.\n\t\t * @param v7         Corner index +X, +Y, -Z.\n\t\t */\n\t\thilbert3D: function ( center, size, iterations, v0, v1, v2, v3, v4, v5, v6, v7 ) {\n\n\t\t\t// Default Vars\n\t\t\tvar center = center !== undefined ? center : new THREE.Vector3( 0, 0, 0 ),\n\t\t\t\tsize = size !== undefined ? size : 10,\n\t\t\t\thalf = size / 2,\n\t\t\t\titerations = iterations !== undefined ? iterations : 1,\n\t\t\t\tv0 = v0 !== undefined ? v0 : 0,\n\t\t\t\tv1 = v1 !== undefined ? v1 : 1,\n\t\t\t\tv2 = v2 !== undefined ? v2 : 2,\n\t\t\t\tv3 = v3 !== undefined ? v3 : 3,\n\t\t\t\tv4 = v4 !== undefined ? v4 : 4,\n\t\t\t\tv5 = v5 !== undefined ? v5 : 5,\n\t\t\t\tv6 = v6 !== undefined ? v6 : 6,\n\t\t\t\tv7 = v7 !== undefined ? v7 : 7\n\t\t\t;\n\n\t\t\tvar vec_s = [\n\t\t\t\tnew THREE.Vector3( center.x - half, center.y + half, center.z - half ),\n\t\t\t\tnew THREE.Vector3( center.x - half, center.y + half, center.z + half ),\n\t\t\t\tnew THREE.Vector3( center.x - half, center.y - half, center.z + half ),\n\t\t\t\tnew THREE.Vector3( center.x - half, center.y - half, center.z - half ),\n\t\t\t\tnew THREE.Vector3( center.x + half, center.y - half, center.z - half ),\n\t\t\t\tnew THREE.Vector3( center.x + half, center.y - half, center.z + half ),\n\t\t\t\tnew THREE.Vector3( center.x + half, center.y + half, center.z + half ),\n\t\t\t\tnew THREE.Vector3( center.x + half, center.y + half, center.z - half )\n\t\t\t];\n\n\t\t\tvar vec = [\n\t\t\t\tvec_s[ v0 ],\n\t\t\t\tvec_s[ v1 ],\n\t\t\t\tvec_s[ v2 ],\n\t\t\t\tvec_s[ v3 ],\n\t\t\t\tvec_s[ v4 ],\n\t\t\t\tvec_s[ v5 ],\n\t\t\t\tvec_s[ v6 ],\n\t\t\t\tvec_s[ v7 ]\n\t\t\t];\n\n\t\t\t// Recurse iterations\n\t\t\tif ( -- iterations >= 0 ) {\n\n\t\t\t\tvar tmp = [];\n\n\t\t\t\tArray.prototype.push.apply( tmp, THREE.GeometryUtils.hilbert3D( vec[ 0 ], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1 ) );\n\t\t\t\tArray.prototype.push.apply( tmp, THREE.GeometryUtils.hilbert3D( vec[ 1 ], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3 ) );\n\t\t\t\tArray.prototype.push.apply( tmp, THREE.GeometryUtils.hilbert3D( vec[ 2 ], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3 ) );\n\t\t\t\tArray.prototype.push.apply( tmp, THREE.GeometryUtils.hilbert3D( vec[ 3 ], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5 ) );\n\t\t\t\tArray.prototype.push.apply( tmp, THREE.GeometryUtils.hilbert3D( vec[ 4 ], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5 ) );\n\t\t\t\tArray.prototype.push.apply( tmp, THREE.GeometryUtils.hilbert3D( vec[ 5 ], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7 ) );\n\t\t\t\tArray.prototype.push.apply( tmp, THREE.GeometryUtils.hilbert3D( vec[ 6 ], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7 ) );\n\t\t\t\tArray.prototype.push.apply( tmp, THREE.GeometryUtils.hilbert3D( vec[ 7 ], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7 ) );\n\n\t\t\t\t// Return recursive call\n\t\t\t\treturn tmp;\n\n\t\t\t}\n\n\t\t\t// Return complete Hilbert Curve.\n\t\t\treturn vec;\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.GeometryUtils;\n});\n"]}