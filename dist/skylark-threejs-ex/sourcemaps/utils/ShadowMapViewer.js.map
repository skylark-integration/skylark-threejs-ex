{"version":3,"sources":["utils/ShadowMapViewer.js"],"names":["define","THREE","ShadowMapViewer","light","userAutoClearSetting","scope","this","doRenderLabel","undefined","name","frame","camera","OrthographicCamera","window","innerWidth","innerHeight","position","set","labelCanvas","labelMesh","scene","Scene","shader","UnpackDepthRGBAShader","uniforms","UniformsUtils","clone","material","ShaderMaterial","vertexShader","fragmentShader","plane","PlaneBufferGeometry","mesh","Mesh","add","context","document","createElement","getContext","font","labelWidth","measureText","width","height","fillStyle","fillText","labelTexture","Texture","magFilter","LinearFilter","minFilter","needsUpdate","labelMaterial","MeshBasicMaterial","map","side","DoubleSide","transparent","labelPlane","enabled","size","scale","x","y","render","renderer","tDiffuse","value","shadow","texture","autoClear","clearDepth","updateForWindowResize","left","right","top","bottom","updateProjectionMatrix","update","prototype","constructor"],"mappings":";;;;;;;AAAAA,QACC,kBACA,oCACC,SAASC,GAmMV,OArKAA,EAAMC,gBAAkB,SAAWC,GAGlC,IAEIC,EAFAC,EAAQC,KACRC,OAAiCC,IAAfL,EAAMM,MAAqC,KAAfN,EAAMM,KAIpDC,EACA,GADAA,EAEA,GAFAA,EAGI,IAHJA,EAIK,IAGLC,EAAS,IAAIV,EAAMW,mBAAoBC,OAAOC,YAAe,EAAGD,OAAOC,WAAa,EAAGD,OAAOE,YAAc,EAAGF,OAAOE,aAAgB,EAAG,EAAG,IAChJJ,EAAOK,SAASC,IAAK,EAAG,EAAG,GAC3B,IAkBIC,EAAaC,EAlBbC,EAAQ,IAAInB,EAAMoB,MAGlBC,EAASrB,EAAMsB,sBAEfC,EAAWvB,EAAMwB,cAAcC,MAAOJ,EAAOE,UAC7CG,EAAW,IAAI1B,EAAM2B,gBACxBJ,SAAUA,EACVK,aAAcP,EAAOO,aACrBC,eAAgBR,EAAOQ,iBAEpBC,EAAQ,IAAI9B,EAAM+B,oBAAqBtB,EAAaA,GACpDuB,EAAO,IAAIhC,EAAMiC,KAAMH,EAAOJ,GAQlC,GANAP,EAAMe,IAAKF,GAMN1B,EAAgB,CAIpB,IAAI6B,GAFJlB,EAAcmB,SAASC,cAAe,WAEZC,WAAY,MACtCH,EAAQI,KAAO,kBAEf,IAAIC,EAAaL,EAAQM,YAAavC,EAAMM,MAAOkC,MACnDzB,EAAYyB,MAAQF,EACpBvB,EAAY0B,OAAS,GAErBR,EAAQI,KAAO,kBACfJ,EAAQS,UAAY,uBACpBT,EAAQU,SAAU3C,EAAMM,KAAM,EAAG,IAEjC,IAAIsC,EAAe,IAAI9C,EAAM+C,QAAS9B,GACtC6B,EAAaE,UAAYhD,EAAMiD,aAC/BH,EAAaI,UAAYlD,EAAMiD,aAC/BH,EAAaK,aAAc,EAE3B,IAAIC,EAAgB,IAAIpD,EAAMqD,mBAAqBC,IAAKR,EAAcS,KAAMvD,EAAMwD,aAClFJ,EAAcK,aAAc,EAE5B,IAAIC,EAAa,IAAI1D,EAAM+B,oBAAqBd,EAAYyB,MAAOzB,EAAY0B,QAC/EzB,EAAY,IAAIlB,EAAMiC,KAAMyB,EAAYN,GAExCjC,EAAMe,IAAKhB,GAaZb,KAAKsD,SAAU,EAGftD,KAAKuD,MACJlB,MAAOjC,EACPkC,OAAQlC,EACRO,IAAK,SAAW0B,EAAOC,GAEtBtC,KAAKqC,MAAQA,EACbrC,KAAKsC,OAASA,EAEdX,EAAK6B,MAAM7C,IAAKX,KAAKqC,MAAQjC,EAAaJ,KAAKsC,OAASlC,EAAc,GAjBvEL,EAAMW,SAASC,IAAKZ,EAAMW,SAAS+C,EAAG1D,EAAMW,SAASgD,KA0BtD1D,KAAKU,UACJ+C,EAAGrD,EACHsD,EAAGtD,EACHO,IAAK,SAAW8C,EAAGC,GAElB1D,KAAKyD,EAAIA,EACTzD,KAAK0D,EAAIA,EAET,IAAIrB,EAAQtC,EAAMwD,KAAKlB,MACnBC,EAASvC,EAAMwD,KAAKjB,OAExBX,EAAKjB,SAASC,KAAOJ,OAAOC,WAAa,EAAI6B,EAAQ,EAAIrC,KAAKyD,EAAGlD,OAAOE,YAAc,EAAI6B,EAAS,EAAItC,KAAK0D,EAAG,GAE1GzD,GAAgBY,EAAUH,SAASC,IAAKgB,EAAKjB,SAAS+C,EAAG9B,EAAKjB,SAASgD,EAAI3D,EAAMwD,KAAKjB,OAAS,EAAI1B,EAAY0B,OAAS,EAAG,KAKlItC,KAAK2D,OAAS,SAAWC,GAEnB5D,KAAKsD,UAOTpC,EAAS2C,SAASC,MAAQjE,EAAMkE,OAAOd,IAAIe,QAE3ClE,EAAuB8D,EAASK,UAChCL,EAASK,WAAY,EACrBL,EAASM,aACTN,EAASD,OAAQ7C,EAAOT,GACxBuD,EAASK,UAAYnE,IAMvBE,KAAKmE,sBAAwB,WAEvBnE,KAAKsD,UAERjD,EAAO+D,KAAO7D,OAAOC,YAAe,EACpCH,EAAOgE,MAAQ9D,OAAOC,WAAa,EACnCH,EAAOiE,IAAM/D,OAAOE,YAAc,EAClCJ,EAAOkE,OAAShE,OAAOE,aAAgB,EACvCJ,EAAOmE,yBAEPxE,KAAKyE,WAMRzE,KAAKyE,OAAS,WAEbzE,KAAKU,SAASC,IAAKX,KAAKU,SAAS+C,EAAGzD,KAAKU,SAASgD,GAClD1D,KAAKuD,KAAK5C,IAAKX,KAAKuD,KAAKlB,MAAOrC,KAAKuD,KAAKjB,SAK3CtC,KAAKyE,UAIN9E,EAAMC,gBAAgB8E,UAAUC,YAAchF,EAAMC,gBAE7CD,EAAMC","file":"../../utils/ShadowMapViewer.js","sourcesContent":["define([\n\t\"skylark-threejs\",\n\t\"../shaders/UnpackDepthRGBAShader\"\n],function(THREE){\n\t/**\n\t * @author arya-s / https://github.com/arya-s\n\t *\n\t * This is a helper for visualising a given light's shadow map.\n\t * It works for shadow casting lights: DirectionalLight and SpotLight.\n\t * It renders out the shadow map and displays it on a HUD.\n\t *\n\t * Example usage:\n\t *\t1) Import ShadowMapViewer into your app.\n\t *\n\t *\t2) Create a shadow casting light and name it optionally:\n\t *\t\tvar light = new DirectionalLight( 0xffffff, 1 );\n\t *\t\tlight.castShadow = true;\n\t *\t\tlight.name = 'Sun';\n\t *\n\t *\t3) Create a shadow map viewer for that light and set its size and position optionally:\n\t *\t\tvar shadowMapViewer = new ShadowMapViewer( light );\n\t *\t\tshadowMapViewer.size.set( 128, 128 );\t//width, height  default: 256, 256\n\t *\t\tshadowMapViewer.position.set( 10, 10 );\t//x, y in pixel\t default: 0, 0 (top left corner)\n\t *\n\t *\t4) Render the shadow map viewer in your render loop:\n\t *\t\tshadowMapViewer.render( renderer );\n\t *\n\t *\t5) Optionally: Update the shadow map viewer on window resize:\n\t *\t\tshadowMapViewer.updateForWindowResize();\n\t *\n\t *\t6) If you set the position or size members directly, you need to call shadowMapViewer.update();\n\t */\n\n\tTHREE.ShadowMapViewer = function ( light ) {\n\n\t\t//- Internals\n\t\tvar scope = this;\n\t\tvar doRenderLabel = ( light.name !== undefined && light.name !== '' );\n\t\tvar userAutoClearSetting;\n\n\t\t//Holds the initial position and dimension of the HUD\n\t\tvar frame = {\n\t\t\tx: 10,\n\t\t\ty: 10,\n\t\t\twidth: 256,\n\t\t\theight: 256\n\t\t};\n\n\t\tvar camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 10 );\n\t\tcamera.position.set( 0, 0, 2 );\n\t\tvar scene = new THREE.Scene();\n\n\t\t//HUD for shadow map\n\t\tvar shader = THREE.UnpackDepthRGBAShader;\n\n\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: uniforms,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader\n\t\t} );\n\t\tvar plane = new THREE.PlaneBufferGeometry( frame.width, frame.height );\n\t\tvar mesh = new THREE.Mesh( plane, material );\n\n\t\tscene.add( mesh );\n\n\n\t\t//Label for light's name\n\t\tvar labelCanvas, labelMesh;\n\n\t\tif ( doRenderLabel ) {\n\n\t\t\tlabelCanvas = document.createElement( 'canvas' );\n\n\t\t\tvar context = labelCanvas.getContext( '2d' );\n\t\t\tcontext.font = 'Bold 20px Arial';\n\n\t\t\tvar labelWidth = context.measureText( light.name ).width;\n\t\t\tlabelCanvas.width = labelWidth;\n\t\t\tlabelCanvas.height = 25;\t//25 to account for g, p, etc.\n\n\t\t\tcontext.font = 'Bold 20px Arial';\n\t\t\tcontext.fillStyle = 'rgba( 255, 0, 0, 1 )';\n\t\t\tcontext.fillText( light.name, 0, 20 );\n\n\t\t\tvar labelTexture = new THREE.Texture( labelCanvas );\n\t\t\tlabelTexture.magFilter = THREE.LinearFilter;\n\t\t\tlabelTexture.minFilter = THREE.LinearFilter;\n\t\t\tlabelTexture.needsUpdate = true;\n\n\t\t\tvar labelMaterial = new THREE.MeshBasicMaterial( { map: labelTexture, side: THREE.DoubleSide } );\n\t\t\tlabelMaterial.transparent = true;\n\n\t\t\tvar labelPlane = new THREE.PlaneBufferGeometry( labelCanvas.width, labelCanvas.height );\n\t\t\tlabelMesh = new THREE.Mesh( labelPlane, labelMaterial );\n\n\t\t\tscene.add( labelMesh );\n\n\t\t}\n\n\n\t\tfunction resetPosition() {\n\n\t\t\tscope.position.set( scope.position.x, scope.position.y );\n\n\t\t}\n\n\t\t//- API\n\t\t// Set to false to disable displaying this shadow map\n\t\tthis.enabled = true;\n\n\t\t// Set the size of the displayed shadow map on the HUD\n\t\tthis.size = {\n\t\t\twidth: frame.width,\n\t\t\theight: frame.height,\n\t\t\tset: function ( width, height ) {\n\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\n\t\t\t\tmesh.scale.set( this.width / frame.width, this.height / frame.height, 1 );\n\n\t\t\t\t//Reset the position as it is off when we scale stuff\n\t\t\t\tresetPosition();\n\n\t\t\t}\n\t\t};\n\n\t\t// Set the position of the displayed shadow map on the HUD\n\t\tthis.position = {\n\t\t\tx: frame.x,\n\t\t\ty: frame.y,\n\t\t\tset: function ( x, y ) {\n\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\n\t\t\t\tvar width = scope.size.width;\n\t\t\t\tvar height = scope.size.height;\n\n\t\t\t\tmesh.position.set( - window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0 );\n\n\t\t\t\tif ( doRenderLabel ) labelMesh.position.set( mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0 );\n\n\t\t\t}\n\t\t};\n\n\t\tthis.render = function ( renderer ) {\n\n\t\t\tif ( this.enabled ) {\n\n\t\t\t\t//Because a light's .shadowMap is only initialised after the first render pass\n\t\t\t\t//we have to make sure the correct map is sent into the shader, otherwise we\n\t\t\t\t//always end up with the scene's first added shadow casting light's shadowMap\n\t\t\t\t//in the shader\n\t\t\t\t//See: https://github.com/mrdoob/three.js/issues/5932\n\t\t\t\tuniforms.tDiffuse.value = light.shadow.map.texture;\n\n\t\t\t\tuserAutoClearSetting = renderer.autoClear;\n\t\t\t\trenderer.autoClear = false; // To allow render overlay\n\t\t\t\trenderer.clearDepth();\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\trenderer.autoClear = userAutoClearSetting;\t//Restore user's setting\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.updateForWindowResize = function () {\n\n\t\t\tif ( this.enabled ) {\n\n\t\t\t\t camera.left = window.innerWidth / - 2;\n\t\t\t\t camera.right = window.innerWidth / 2;\n\t\t\t\t camera.top = window.innerHeight / 2;\n\t\t\t\t camera.bottom = window.innerHeight / - 2;\n\t\t\t\t camera.updateProjectionMatrix();\n\n\t\t\t\t this.update();\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.update = function () {\n\n\t\t\tthis.position.set( this.position.x, this.position.y );\n\t\t\tthis.size.set( this.size.width, this.size.height );\n\n\t\t};\n\n\t\t//Force an update to set position/size\n\t\tthis.update();\n\n\t};\n\n\tTHREE.ShadowMapViewer.prototype.constructor = THREE.ShadowMapViewer;\n\t\n\treturn THREE.ShadowMapViewer;\n});\n"]}