{"version":3,"sources":["utils/BufferGeometryUtils.js"],"names":["define","THREE","BufferGeometryUtils","computeTangents","geometry","index","attributes","undefined","position","normal","uv","indices","array","positions","normals","uvs","nVertices","length","tangent","setAttribute","BufferAttribute","Float32Array","tangents","tan1","tan2","i","Vector3","vA","vB","vC","uvA","Vector2","uvB","uvC","sdir","tdir","groups","start","count","il","j","group","jl","handleTriangle","w","t","test","tmp","tmp2","n","n2","handleVertex","console","warn","a","b","c","fromArray","sub","r","x","y","isFinite","copy","multiplyScalar","addScaledVector","add","v","dot","normalize","crossVectors","z","mergeBufferGeometries","geometries","useGroups","isIndexed","attributesUsed","Set","Object","keys","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","BufferGeometry","offset","name","has","push","userData","mergedUserData","addGroup","indexOffset","mergedIndex","getX","setIndex","mergedAttribute","this","mergeBufferAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","arrayLength","attribute","isInterleavedBufferAttribute","constructor","set","interleaveAttributes","stride","l","interleavedBuffer","InterleavedBuffer","res","getters","setters","iba","InterleavedBufferAttribute","k","estimateBytesUsed","mem","attr","getAttribute","BYTES_PER_ELEMENT","getIndex","mergeVertices","tolerance","Math","max","Number","EPSILON","hashToIndex","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","Array","fill","map","decimalShift","log10","shiftMultiplier","pow","hash","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","oldMorphAttribute","morphAttribute","toTrianglesDrawMode","drawMode","TrianglesDrawMode","TriangleFanDrawMode","TriangleStripDrawMode","error","numberOfTriangles","newGeometry","clearGroups"],"mappings":"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","file":"../../utils/BufferGeometryUtils.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\tTHREE.BufferGeometryUtils = {\n\n\t\tcomputeTangents: function ( geometry ) {\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar attributes = geometry.attributes;\n\n\t\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t\t// (per vertex tangents)\n\n\t\t\tif ( index === null ||\n\t\t\t\t attributes.position === undefined ||\n\t\t\t\t attributes.normal === undefined ||\n\t\t\t\t attributes.uv === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar indices = index.array;\n\t\t\tvar positions = attributes.position.array;\n\t\t\tvar normals = attributes.normal.array;\n\t\t\tvar uvs = attributes.uv.array;\n\n\t\t\tvar nVertices = positions.length / 3;\n\n\t\t\tif ( attributes.tangent === undefined ) {\n\n\t\t\t\tgeometry.setAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\n\n\t\t\t}\n\n\t\t\tvar tangents = attributes.tangent.array;\n\n\t\t\tvar tan1 = [], tan2 = [];\n\n\t\t\tfor ( var i = 0; i < nVertices; i ++ ) {\n\n\t\t\t\ttan1[ i ] = new THREE.Vector3();\n\t\t\t\ttan2[ i ] = new THREE.Vector3();\n\n\t\t\t}\n\n\t\t\tvar vA = new THREE.Vector3(),\n\t\t\t\tvB = new THREE.Vector3(),\n\t\t\t\tvC = new THREE.Vector3(),\n\n\t\t\t\tuvA = new THREE.Vector2(),\n\t\t\t\tuvB = new THREE.Vector2(),\n\t\t\t\tuvC = new THREE.Vector2(),\n\n\t\t\t\tsdir = new THREE.Vector3(),\n\t\t\t\ttdir = new THREE.Vector3();\n\n\t\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\t\tvB.sub( vA );\n\t\t\t\tvC.sub( vA );\n\n\t\t\t\tuvB.sub( uvA );\n\t\t\t\tuvC.sub( uvA );\n\n\t\t\t\tvar r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\t\ttan1[ a ].add( sdir );\n\t\t\t\ttan1[ b ].add( sdir );\n\t\t\t\ttan1[ c ].add( sdir );\n\n\t\t\t\ttan2[ a ].add( tdir );\n\t\t\t\ttan2[ b ].add( tdir );\n\t\t\t\ttan2[ c ].add( tdir );\n\n\t\t\t}\n\n\t\t\tvar groups = geometry.groups;\n\n\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\tgroups = [ {\n\t\t\t\t\tstart: 0,\n\t\t\t\t\tcount: indices.length\n\t\t\t\t} ];\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\tvar start = group.start;\n\t\t\t\tvar count = group.count;\n\n\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\thandleTriangle(\n\t\t\t\t\t\tindices[ j + 0 ],\n\t\t\t\t\t\tindices[ j + 1 ],\n\t\t\t\t\t\tindices[ j + 2 ]\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\n\t\t\tvar n = new THREE.Vector3(), n2 = new THREE.Vector3();\n\t\t\tvar w, t, test;\n\n\t\t\tfunction handleVertex( v ) {\n\n\t\t\t\tn.fromArray( normals, v * 3 );\n\t\t\t\tn2.copy( n );\n\n\t\t\t\tt = tan1[ v ];\n\n\t\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\t\ttmp.copy( t );\n\t\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t\t// Calculate handedness\n\n\t\t\t\ttmp2.crossVectors( n2, t );\n\t\t\t\ttest = tmp2.dot( tan2[ v ] );\n\t\t\t\tw = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\t\ttangents[ v * 4 ] = tmp.x;\n\t\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\t\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\t\t\t\ttangents[ v * 4 + 3 ] = w;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\t\tvar group = groups[ i ];\n\n\t\t\t\tvar start = group.start;\n\t\t\t\tvar count = group.count;\n\n\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\thandleVertex( indices[ j + 0 ] );\n\t\t\t\t\thandleVertex( indices[ j + 1 ] );\n\t\t\t\t\thandleVertex( indices[ j + 2 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\t/**\n\t\t * @param  {Array<THREE.BufferGeometry>} geometries\n\t\t * @param  {Boolean} useGroups\n\t\t * @return {THREE.BufferGeometry}\n\t\t */\n\t\tmergeBufferGeometries: function ( geometries, useGroups ) {\n\n\t\t\tvar isIndexed = geometries[ 0 ].index !== null;\n\n\t\t\tvar attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\t\t\tvar morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\t\t\tvar attributes = {};\n\t\t\tvar morphAttributes = {};\n\n\t\t\tvar morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\t\t\tvar mergedGeometry = new THREE.BufferGeometry();\n\n\t\t\tvar offset = 0;\n\n\t\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tvar geometry = geometries[ i ];\n\n\t\t\t\t// ensure that all geometries are indexed, or none\n\n\t\t\t\tif ( isIndexed !== ( geometry.index !== null ) ) return null;\n\n\t\t\t\t// gather attributes, exit early if they're different\n\n\t\t\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\t\t\tif ( ! attributesUsed.has( name ) ) return null;\n\n\t\t\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\t\t}\n\n\t\t\t\t// gather morph attributes, exit early if they're different\n\n\t\t\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) return null;\n\n\t\t\t\tfor ( var name in geometry.morphAttributes ) {\n\n\t\t\t\t\tif ( ! morphAttributesUsed.has( name ) ) return null;\n\n\t\t\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t\t\t}\n\n\t\t\t\t// gather .userData\n\n\t\t\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\t\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\t\t\tif ( useGroups ) {\n\n\t\t\t\t\tvar count;\n\n\t\t\t\t\tif ( isIndexed ) {\n\n\t\t\t\t\t\tcount = geometry.index.count;\n\n\t\t\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\t\t\toffset += count;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// merge indices\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tvar indexOffset = 0;\n\t\t\t\tvar mergedIndex = [];\n\n\t\t\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\t\tvar index = geometries[ i ].index;\n\n\t\t\t\t\tfor ( var j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t\t\t}\n\n\t\t\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t\t\t}\n\n\t\t\t// merge attributes\n\n\t\t\tfor ( var name in attributes ) {\n\n\t\t\t\tvar mergedAttribute = this.mergeBufferAttributes( attributes[ name ] );\n\n\t\t\t\tif ( ! mergedAttribute ) return null;\n\n\t\t\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t\t\t}\n\n\t\t\t// merge morph attributes\n\n\t\t\tfor ( var name in morphAttributes ) {\n\n\t\t\t\tvar numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\t\t\tif ( numMorphTargets === 0 ) break;\n\n\t\t\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\t\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\t\t\tfor ( var i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\t\t\tvar morphAttributesToMerge = [];\n\n\t\t\t\t\tfor ( var j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar mergedMorphAttribute = this.mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\t\t\tif ( ! mergedMorphAttribute ) return null;\n\n\t\t\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn mergedGeometry;\n\n\t\t},\n\n\t\t/**\n\t\t * @param {Array<THREE.BufferAttribute>} attributes\n\t\t * @return {THREE.BufferAttribute}\n\t\t */\n\t\tmergeBufferAttributes: function ( attributes ) {\n\n\t\t\tvar TypedArray;\n\t\t\tvar itemSize;\n\t\t\tvar normalized;\n\t\t\tvar arrayLength = 0;\n\n\t\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\t\tvar attribute = attributes[ i ];\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) return null;\n\n\t\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\t\tif ( TypedArray !== attribute.array.constructor ) return null;\n\n\t\t\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\t\t\tif ( itemSize !== attribute.itemSize ) return null;\n\n\t\t\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\t\t\tif ( normalized !== attribute.normalized ) return null;\n\n\t\t\t\tarrayLength += attribute.array.length;\n\n\t\t\t}\n\n\t\t\tvar array = new TypedArray( arrayLength );\n\t\t\tvar offset = 0;\n\n\t\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\t\tarray.set( attributes[ i ].array, offset );\n\n\t\t\t\toffset += attributes[ i ].array.length;\n\n\t\t\t}\n\n\t\t\treturn new THREE.BufferAttribute( array, itemSize, normalized );\n\n\t\t},\n\n\t\t/**\n\t\t * @param {Array<THREE.BufferAttribute>} attributes\n\t\t * @return {Array<THREE.InterleavedBufferAttribute>}\n\t\t */\n\t\tinterleaveAttributes: function ( attributes ) {\n\n\t\t\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t\t\t// a set of InterleavedBufferAttributes for each attribute\n\t\t\tvar TypedArray;\n\t\t\tvar arrayLength = 0;\n\t\t\tvar stride = 0;\n\n\t\t\t// calculate the the length and type of the interleavedBuffer\n\t\t\tfor ( var i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\t\t\tvar attribute = attributes[ i ];\n\n\t\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\t\t\tconsole.warn( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tarrayLength += attribute.array.length;\n\t\t\t\tstride += attribute.itemSize;\n\n\t\t\t}\n\n\t\t\t// Create the set of buffer attributes\n\t\t\tvar interleavedBuffer = new THREE.InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\t\t\tvar offset = 0;\n\t\t\tvar res = [];\n\t\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\t\t\tvar setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t\t\tfor ( var j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\t\t\tvar attribute = attributes[ j ];\n\t\t\t\tvar itemSize = attribute.itemSize;\n\t\t\t\tvar count = attribute.count;\n\t\t\t\tvar iba = new THREE.InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\t\t\tres.push( iba );\n\n\t\t\t\toffset += itemSize;\n\n\t\t\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t\t\t// at the appropriate offset\n\t\t\t\tfor ( var c = 0; c < count; c ++ ) {\n\n\t\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn res;\n\n\t\t},\n\n\t\t/**\n\t\t * @param {Array<THREE.BufferGeometry>} geometry\n\t\t * @return {number}\n\t\t */\n\t\testimateBytesUsed: function ( geometry ) {\n\n\t\t\t// Return the estimated memory used by this geometry in bytes\n\t\t\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t\t\t// for InterleavedBufferAttributes.\n\t\t\tvar mem = 0;\n\t\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\t\tvar attr = geometry.getAttribute( name );\n\t\t\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t\t\t}\n\n\t\t\tvar indices = geometry.getIndex();\n\t\t\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\t\t\treturn mem;\n\n\t\t},\n\n\t\t/**\n\t\t * @param {THREE.BufferGeometry} geometry\n\t\t * @param {number} tolerance\n\t\t * @return {THREE.BufferGeometry>}\n\t\t */\n\t\tmergeVertices: function ( geometry, tolerance = 1e-4 ) {\n\n\t\t\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t\t\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t\t\t// if it's already available.\n\t\t\tvar hashToIndex = {};\n\t\t\tvar indices = geometry.getIndex();\n\t\t\tvar positions = geometry.getAttribute( 'position' );\n\t\t\tvar vertexCount = indices ? indices.count : positions.count;\n\n\t\t\t// next value for triangle indices\n\t\t\tvar nextIndex = 0;\n\n\t\t\t// attributes and new attribute arrays\n\t\t\tvar attributeNames = Object.keys( geometry.attributes );\n\t\t\tvar attrArrays = {};\n\t\t\tvar morphAttrsArrays = {};\n\t\t\tvar newIndices = [];\n\t\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t\t\t// initialize the arrays\n\t\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\t\tvar name = attributeNames[ i ];\n\n\t\t\t\tattrArrays[ name ] = [];\n\n\t\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// convert the error tolerance to an amount of decimal places to truncate to\n\t\t\tvar decimalShift = Math.log10( 1 / tolerance );\n\t\t\tvar shiftMultiplier = Math.pow( 10, decimalShift );\n\t\t\tfor ( var i = 0; i < vertexCount; i ++ ) {\n\n\t\t\t\tvar index = indices ? indices.getX( i ) : i;\n\n\t\t\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\t\t\tvar hash = '';\n\t\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Add another reference to the vertex if it's already\n\t\t\t\t// used by another index\n\t\t\t\tif ( hash in hashToIndex ) {\n\n\t\t\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// copy data to the new index in the attribute arrays\n\t\t\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\t\t\tvar itemSize = attribute.itemSize;\n\t\t\t\t\t\tvar newarray = attrArrays[ name ];\n\t\t\t\t\t\tvar newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t\t\tvar getterFunc = getters[ k ];\n\t\t\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\t\t\tfor ( var m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\t\t\tnewIndices.push( nextIndex );\n\t\t\t\t\tnextIndex ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Generate typed arrays from new attribute arrays and update\n\t\t\t// the attributeBuffers\n\t\t\tconst result = geometry.clone();\n\t\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\t\tvar name = attributeNames[ i ];\n\t\t\t\tvar oldAttribute = geometry.getAttribute( name );\n\n\t\t\t\tvar buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\t\t\tvar attribute = new THREE.BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\t\t\tresult.setAttribute( name, attribute );\n\n\t\t\t\t// Update the attribute arrays\n\t\t\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\t\t\tfor ( var j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\t\t\tvar oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\t\t\tvar buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\t\t\tvar morphAttribute = new THREE.BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\tresult.setIndex( newIndices );\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\t/**\n\t\t * @param {THREE.BufferGeometry} geometry\n\t\t * @param {number} drawMode\n\t\t * @return {THREE.BufferGeometry>}\n\t\t */\n\t\ttoTrianglesDrawMode: function ( geometry, drawMode ) {\n\n\t\t\tif ( drawMode === THREE.TrianglesDrawMode ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\tif ( drawMode === THREE.TriangleFanDrawMode || drawMode === THREE.TriangleStripDrawMode ) {\n\n\t\t\t\tvar index = geometry.getIndex();\n\n\t\t\t\t// generate index if not present\n\n\t\t\t\tif ( index === null ) {\n\n\t\t\t\t\tvar indices = [];\n\n\t\t\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\t\t\tif ( position !== undefined ) {\n\n\t\t\t\t\t\tfor ( var i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\t\t\tindices.push( i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\t\t\treturn geometry;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar numberOfTriangles = index.count - 2;\n\t\t\t\tvar newIndices = [];\n\n\t\t\t\tif ( drawMode === THREE.TriangleFanDrawMode ) {\n\n\t\t\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\t\t\tfor ( var i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\t\t\tfor ( var i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t\t\t}\n\n\t\t\t\t// build final geometry\n\n\t\t\t\tvar newGeometry = geometry.clone();\n\t\t\t\tnewGeometry.setIndex( newIndices );\n\t\t\t\tnewGeometry.clearGroups();\n\n\t\t\t\treturn newGeometry;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.BufferGeometryUtils;\n});\n"]}