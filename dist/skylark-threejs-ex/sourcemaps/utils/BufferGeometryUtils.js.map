{"version":3,"sources":["utils/BufferGeometryUtils.js"],"names":["define","THREE","threex","BufferGeometryUtils","computeTangents","geometry","index","attributes","undefined","position","normal","uv","indices","array","positions","normals","uvs","nVertices","length","tangent","setAttribute","BufferAttribute","Float32Array","tangents","tan1","tan2","i","Vector3","vA","vB","vC","uvA","Vector2","uvB","uvC","sdir","tdir","groups","start","count","il","j","group","jl","handleTriangle","w","t","test","tmp","tmp2","n","n2","handleVertex","console","warn","a","b","c","fromArray","sub","r","x","y","isFinite","copy","multiplyScalar","addScaledVector","add","v","dot","normalize","crossVectors","z","mergeBufferGeometries","geometries","useGroups","isIndexed","attributesUsed","Set","Object","keys","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","BufferGeometry","offset","name","has","push","userData","mergedUserData","addGroup","indexOffset","mergedIndex","getX","setIndex","mergedAttribute","this","mergeBufferAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","arrayLength","attribute","isInterleavedBufferAttribute","constructor","set","interleaveAttributes","stride","l","interleavedBuffer","InterleavedBuffer","res","getters","setters","iba","InterleavedBufferAttribute","k","estimateBytesUsed","mem","attr","getAttribute","BYTES_PER_ELEMENT","getIndex","mergeVertices","tolerance","Math","max","Number","EPSILON","hashToIndex","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","Array","fill","map","decimalShift","log10","shiftMultiplier","pow","hash","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","oldMorphAttribute","morphAttribute","toTrianglesDrawMode","drawMode","TrianglesDrawMode","TriangleFanDrawMode","TriangleStripDrawMode","error","numberOfTriangles","newGeometry","clearGroups","utils"],"mappings":"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","file":"../../utils/BufferGeometryUtils.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var BufferGeometryUtils = {\r\n        computeTangents: function (geometry) {\r\n            var index = geometry.index;\r\n            var attributes = geometry.attributes;\r\n            if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\r\n                console.warn('THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()');\r\n                return;\r\n            }\r\n            var indices = index.array;\r\n            var positions = attributes.position.array;\r\n            var normals = attributes.normal.array;\r\n            var uvs = attributes.uv.array;\r\n            var nVertices = positions.length / 3;\r\n            if (attributes.tangent === undefined) {\r\n                geometry.setAttribute('tangent', new THREE.BufferAttribute(new Float32Array(4 * nVertices), 4));\r\n            }\r\n            var tangents = attributes.tangent.array;\r\n            var tan1 = [], tan2 = [];\r\n            for (var i = 0; i < nVertices; i++) {\r\n                tan1[i] = new THREE.Vector3();\r\n                tan2[i] = new THREE.Vector3();\r\n            }\r\n            var vA = new THREE.Vector3(), vB = new THREE.Vector3(), vC = new THREE.Vector3(), uvA = new THREE.Vector2(), uvB = new THREE.Vector2(), uvC = new THREE.Vector2(), sdir = new THREE.Vector3(), tdir = new THREE.Vector3();\r\n            function handleTriangle(a, b, c) {\r\n                vA.fromArray(positions, a * 3);\r\n                vB.fromArray(positions, b * 3);\r\n                vC.fromArray(positions, c * 3);\r\n                uvA.fromArray(uvs, a * 2);\r\n                uvB.fromArray(uvs, b * 2);\r\n                uvC.fromArray(uvs, c * 2);\r\n                vB.sub(vA);\r\n                vC.sub(vA);\r\n                uvB.sub(uvA);\r\n                uvC.sub(uvA);\r\n                var r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);\r\n                if (!isFinite(r))\r\n                    return;\r\n                sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\r\n                tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\r\n                tan1[a].add(sdir);\r\n                tan1[b].add(sdir);\r\n                tan1[c].add(sdir);\r\n                tan2[a].add(tdir);\r\n                tan2[b].add(tdir);\r\n                tan2[c].add(tdir);\r\n            }\r\n            var groups = geometry.groups;\r\n            if (groups.length === 0) {\r\n                groups = [{\r\n                        start: 0,\r\n                        count: indices.length\r\n                    }];\r\n            }\r\n            for (var i = 0, il = groups.length; i < il; ++i) {\r\n                var group = groups[i];\r\n                var start = group.start;\r\n                var count = group.count;\r\n                for (var j = start, jl = start + count; j < jl; j += 3) {\r\n                    handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\r\n                }\r\n            }\r\n            var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\r\n            var n = new THREE.Vector3(), n2 = new THREE.Vector3();\r\n            var w, t, test;\r\n            function handleVertex(v) {\r\n                n.fromArray(normals, v * 3);\r\n                n2.copy(n);\r\n                t = tan1[v];\r\n                tmp.copy(t);\r\n                tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\r\n                tmp2.crossVectors(n2, t);\r\n                test = tmp2.dot(tan2[v]);\r\n                w = test < 0 ? -1 : 1;\r\n                tangents[v * 4] = tmp.x;\r\n                tangents[v * 4 + 1] = tmp.y;\r\n                tangents[v * 4 + 2] = tmp.z;\r\n                tangents[v * 4 + 3] = w;\r\n            }\r\n            for (var i = 0, il = groups.length; i < il; ++i) {\r\n                var group = groups[i];\r\n                var start = group.start;\r\n                var count = group.count;\r\n                for (var j = start, jl = start + count; j < jl; j += 3) {\r\n                    handleVertex(indices[j + 0]);\r\n                    handleVertex(indices[j + 1]);\r\n                    handleVertex(indices[j + 2]);\r\n                }\r\n            }\r\n        },\r\n        mergeBufferGeometries: function (geometries, useGroups) {\r\n            var isIndexed = geometries[0].index !== null;\r\n            var attributesUsed = new Set(Object.keys(geometries[0].attributes));\r\n            var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\r\n            var attributes = {};\r\n            var morphAttributes = {};\r\n            var morphTargetsRelative = geometries[0].morphTargetsRelative;\r\n            var mergedGeometry = new THREE.BufferGeometry();\r\n            var offset = 0;\r\n            for (var i = 0; i < geometries.length; ++i) {\r\n                var geometry = geometries[i];\r\n                if (isIndexed !== (geometry.index !== null))\r\n                    return null;\r\n                for (var name in geometry.attributes) {\r\n                    if (!attributesUsed.has(name))\r\n                        return null;\r\n                    if (attributes[name] === undefined)\r\n                        attributes[name] = [];\r\n                    attributes[name].push(geometry.attributes[name]);\r\n                }\r\n                if (morphTargetsRelative !== geometry.morphTargetsRelative)\r\n                    return null;\r\n                for (var name in geometry.morphAttributes) {\r\n                    if (!morphAttributesUsed.has(name))\r\n                        return null;\r\n                    if (morphAttributes[name] === undefined)\r\n                        morphAttributes[name] = [];\r\n                    morphAttributes[name].push(geometry.morphAttributes[name]);\r\n                }\r\n                mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\r\n                mergedGeometry.userData.mergedUserData.push(geometry.userData);\r\n                if (useGroups) {\r\n                    var count;\r\n                    if (isIndexed) {\r\n                        count = geometry.index.count;\r\n                    } else if (geometry.attributes.position !== undefined) {\r\n                        count = geometry.attributes.position.count;\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                    mergedGeometry.addGroup(offset, count, i);\r\n                    offset += count;\r\n                }\r\n            }\r\n            if (isIndexed) {\r\n                var indexOffset = 0;\r\n                var mergedIndex = [];\r\n                for (var i = 0; i < geometries.length; ++i) {\r\n                    var index = geometries[i].index;\r\n                    for (var j = 0; j < index.count; ++j) {\r\n                        mergedIndex.push(index.getX(j) + indexOffset);\r\n                    }\r\n                    indexOffset += geometries[i].attributes.position.count;\r\n                }\r\n                mergedGeometry.setIndex(mergedIndex);\r\n            }\r\n            for (var name in attributes) {\r\n                var mergedAttribute = this.mergeBufferAttributes(attributes[name]);\r\n                if (!mergedAttribute)\r\n                    return null;\r\n                mergedGeometry.setAttribute(name, mergedAttribute);\r\n            }\r\n            for (var name in morphAttributes) {\r\n                var numMorphTargets = morphAttributes[name][0].length;\r\n                if (numMorphTargets === 0)\r\n                    break;\r\n                mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\r\n                mergedGeometry.morphAttributes[name] = [];\r\n                for (var i = 0; i < numMorphTargets; ++i) {\r\n                    var morphAttributesToMerge = [];\r\n                    for (var j = 0; j < morphAttributes[name].length; ++j) {\r\n                        morphAttributesToMerge.push(morphAttributes[name][j][i]);\r\n                    }\r\n                    var mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);\r\n                    if (!mergedMorphAttribute)\r\n                        return null;\r\n                    mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\r\n                }\r\n            }\r\n            return mergedGeometry;\r\n        },\r\n        mergeBufferAttributes: function (attributes) {\r\n            var TypedArray;\r\n            var itemSize;\r\n            var normalized;\r\n            var arrayLength = 0;\r\n            for (var i = 0; i < attributes.length; ++i) {\r\n                var attribute = attributes[i];\r\n                if (attribute.isInterleavedBufferAttribute)\r\n                    return null;\r\n                if (TypedArray === undefined)\r\n                    TypedArray = attribute.array.constructor;\r\n                if (TypedArray !== attribute.array.constructor)\r\n                    return null;\r\n                if (itemSize === undefined)\r\n                    itemSize = attribute.itemSize;\r\n                if (itemSize !== attribute.itemSize)\r\n                    return null;\r\n                if (normalized === undefined)\r\n                    normalized = attribute.normalized;\r\n                if (normalized !== attribute.normalized)\r\n                    return null;\r\n                arrayLength += attribute.array.length;\r\n            }\r\n            var array = new TypedArray(arrayLength);\r\n            var offset = 0;\r\n            for (var i = 0; i < attributes.length; ++i) {\r\n                array.set(attributes[i].array, offset);\r\n                offset += attributes[i].array.length;\r\n            }\r\n            return new THREE.BufferAttribute(array, itemSize, normalized);\r\n        },\r\n        interleaveAttributes: function (attributes) {\r\n            var TypedArray;\r\n            var arrayLength = 0;\r\n            var stride = 0;\r\n            for (var i = 0, l = attributes.length; i < l; ++i) {\r\n                var attribute = attributes[i];\r\n                if (TypedArray === undefined)\r\n                    TypedArray = attribute.array.constructor;\r\n                if (TypedArray !== attribute.array.constructor) {\r\n                    console.warn('AttributeBuffers of different types cannot be interleaved');\r\n                    return null;\r\n                }\r\n                arrayLength += attribute.array.length;\r\n                stride += attribute.itemSize;\r\n            }\r\n            var interleavedBuffer = new THREE.InterleavedBuffer(new TypedArray(arrayLength), stride);\r\n            var offset = 0;\r\n            var res = [];\r\n            var getters = [\r\n                'getX',\r\n                'getY',\r\n                'getZ',\r\n                'getW'\r\n            ];\r\n            var setters = [\r\n                'setX',\r\n                'setY',\r\n                'setZ',\r\n                'setW'\r\n            ];\r\n            for (var j = 0, l = attributes.length; j < l; j++) {\r\n                var attribute = attributes[j];\r\n                var itemSize = attribute.itemSize;\r\n                var count = attribute.count;\r\n                var iba = new THREE.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\r\n                res.push(iba);\r\n                offset += itemSize;\r\n                for (var c = 0; c < count; c++) {\r\n                    for (var k = 0; k < itemSize; k++) {\r\n                        iba[setters[k]](c, attribute[getters[k]](c));\r\n                    }\r\n                }\r\n            }\r\n            return res;\r\n        },\r\n        estimateBytesUsed: function (geometry) {\r\n            var mem = 0;\r\n            for (var name in geometry.attributes) {\r\n                var attr = geometry.getAttribute(name);\r\n                mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\r\n            }\r\n            var indices = geometry.getIndex();\r\n            mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\r\n            return mem;\r\n        },\r\n        mergeVertices: function (geometry, tolerance = 0.0001) {\r\n            tolerance = Math.max(tolerance, Number.EPSILON);\r\n            var hashToIndex = {};\r\n            var indices = geometry.getIndex();\r\n            var positions = geometry.getAttribute('position');\r\n            var vertexCount = indices ? indices.count : positions.count;\r\n            var nextIndex = 0;\r\n            var attributeNames = Object.keys(geometry.attributes);\r\n            var attrArrays = {};\r\n            var morphAttrsArrays = {};\r\n            var newIndices = [];\r\n            var getters = [\r\n                'getX',\r\n                'getY',\r\n                'getZ',\r\n                'getW'\r\n            ];\r\n            for (var i = 0, l = attributeNames.length; i < l; i++) {\r\n                var name = attributeNames[i];\r\n                attrArrays[name] = [];\r\n                var morphAttr = geometry.morphAttributes[name];\r\n                if (morphAttr) {\r\n                    morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(() => []);\r\n                }\r\n            }\r\n            var decimalShift = Math.log10(1 / tolerance);\r\n            var shiftMultiplier = Math.pow(10, decimalShift);\r\n            for (var i = 0; i < vertexCount; i++) {\r\n                var index = indices ? indices.getX(i) : i;\r\n                var hash = '';\r\n                for (var j = 0, l = attributeNames.length; j < l; j++) {\r\n                    var name = attributeNames[j];\r\n                    var attribute = geometry.getAttribute(name);\r\n                    var itemSize = attribute.itemSize;\r\n                    for (var k = 0; k < itemSize; k++) {\r\n                        hash += `${ ~~(attribute[getters[k]](index) * shiftMultiplier) },`;\r\n                    }\r\n                }\r\n                if (hash in hashToIndex) {\r\n                    newIndices.push(hashToIndex[hash]);\r\n                } else {\r\n                    for (var j = 0, l = attributeNames.length; j < l; j++) {\r\n                        var name = attributeNames[j];\r\n                        var attribute = geometry.getAttribute(name);\r\n                        var morphAttr = geometry.morphAttributes[name];\r\n                        var itemSize = attribute.itemSize;\r\n                        var newarray = attrArrays[name];\r\n                        var newMorphArrays = morphAttrsArrays[name];\r\n                        for (var k = 0; k < itemSize; k++) {\r\n                            var getterFunc = getters[k];\r\n                            newarray.push(attribute[getterFunc](index));\r\n                            if (morphAttr) {\r\n                                for (var m = 0, ml = morphAttr.length; m < ml; m++) {\r\n                                    newMorphArrays[m].push(morphAttr[m][getterFunc](index));\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    hashToIndex[hash] = nextIndex;\r\n                    newIndices.push(nextIndex);\r\n                    nextIndex++;\r\n                }\r\n            }\r\n            const result = geometry.clone();\r\n            for (var i = 0, l = attributeNames.length; i < l; i++) {\r\n                var name = attributeNames[i];\r\n                var oldAttribute = geometry.getAttribute(name);\r\n                var buffer = new oldAttribute.array.constructor(attrArrays[name]);\r\n                var attribute = new THREE.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\r\n                result.setAttribute(name, attribute);\r\n                if (name in morphAttrsArrays) {\r\n                    for (var j = 0; j < morphAttrsArrays[name].length; j++) {\r\n                        var oldMorphAttribute = geometry.morphAttributes[name][j];\r\n                        var buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\r\n                        var morphAttribute = new THREE.BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\r\n                        result.morphAttributes[name][j] = morphAttribute;\r\n                    }\r\n                }\r\n            }\r\n            result.setIndex(newIndices);\r\n            return result;\r\n        },\r\n        toTrianglesDrawMode: function (geometry, drawMode) {\r\n            if (drawMode === THREE.TrianglesDrawMode) {\r\n                console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\r\n                return geometry;\r\n            }\r\n            if (drawMode === THREE.TriangleFanDrawMode || drawMode === THREE.TriangleStripDrawMode) {\r\n                var index = geometry.getIndex();\r\n                if (index === null) {\r\n                    var indices = [];\r\n                    var position = geometry.getAttribute('position');\r\n                    if (position !== undefined) {\r\n                        for (var i = 0; i < position.count; i++) {\r\n                            indices.push(i);\r\n                        }\r\n                        geometry.setIndex(indices);\r\n                        index = geometry.getIndex();\r\n                    } else {\r\n                        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\r\n                        return geometry;\r\n                    }\r\n                }\r\n                var numberOfTriangles = index.count - 2;\r\n                var newIndices = [];\r\n                if (drawMode === THREE.TriangleFanDrawMode) {\r\n                    for (var i = 1; i <= numberOfTriangles; i++) {\r\n                        newIndices.push(index.getX(0));\r\n                        newIndices.push(index.getX(i));\r\n                        newIndices.push(index.getX(i + 1));\r\n                    }\r\n                } else {\r\n                    for (var i = 0; i < numberOfTriangles; i++) {\r\n                        if (i % 2 === 0) {\r\n                            newIndices.push(index.getX(i));\r\n                            newIndices.push(index.getX(i + 1));\r\n                            newIndices.push(index.getX(i + 2));\r\n                        } else {\r\n                            newIndices.push(index.getX(i + 2));\r\n                            newIndices.push(index.getX(i + 1));\r\n                            newIndices.push(index.getX(i));\r\n                        }\r\n                    }\r\n                }\r\n                if (newIndices.length / 3 !== numberOfTriangles) {\r\n                    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\r\n                }\r\n                var newGeometry = geometry.clone();\r\n                newGeometry.setIndex(newIndices);\r\n                newGeometry.clearGroups();\r\n                return newGeometry;\r\n            } else {\r\n                console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\r\n                return geometry;\r\n            }\r\n        }\r\n    };\r\n    return threex.utils.BufferGeometryUtils = BufferGeometryUtils;\r\n});"]}