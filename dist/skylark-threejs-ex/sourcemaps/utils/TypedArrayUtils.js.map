{"version":3,"sources":["utils/TypedArrayUtils.js"],"names":["define","TypedArrayUtils","quicksortIP","arr","eleSize","orderElement","i","j","stack","sp","left","right","length","tmp","x","y","swapF","a","b","swap","Float32Array","temp","Kdtree","points","metric","self","this","maxDepth","getPointSet","pos","subarray","root","buildTree","depth","parent","median","node","dim","plength","Node","Math","floor","getMaxDepth","nearest","point","maxNodes","maxDistance","result","bestNodes","BinaryHeap","e","push","nearestSearch","bestChild","linearDistance","otherChild","dimension","ownDistance","obj","linearPoint","saveNode","distance","size","pop","peek","abs","content","prototype","scoreFunction","element","bubbleUp","end","sinkDown","remove","len","Error","n","parentN","elemScore","child2N","child1N","child1","child1Score","child2"],"mappings":"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","file":"../../utils/TypedArrayUtils.js","sourcesContent":["define(function () {\n    'use strict';\n    var TypedArrayUtils = {};\n    TypedArrayUtils.quicksortIP = function (arr, eleSize, orderElement) {\n        var stack = [];\n        var sp = -1;\n        var left = 0;\n        var right = arr.length / eleSize - 1;\n        var tmp = 0, x = 0, y = 0;\n        var swapF = function (a, b) {\n            a *= eleSize;\n            b *= eleSize;\n            for (y = 0; y < eleSize; y++) {\n                tmp = arr[a + y];\n                arr[a + y] = arr[b + y];\n                arr[b + y] = tmp;\n            }\n        };\n        var i, j, swap = new Float32Array(eleSize), temp = new Float32Array(eleSize);\n        while (true) {\n            if (right - left <= 25) {\n                for (j = left + 1; j <= right; j++) {\n                    for (x = 0; x < eleSize; x++) {\n                        swap[x] = arr[j * eleSize + x];\n                    }\n                    i = j - 1;\n                    while (i >= left && arr[i * eleSize + orderElement] > swap[orderElement]) {\n                        for (x = 0; x < eleSize; x++) {\n                            arr[(i + 1) * eleSize + x] = arr[i * eleSize + x];\n                        }\n                        i--;\n                    }\n                    for (x = 0; x < eleSize; x++) {\n                        arr[(i + 1) * eleSize + x] = swap[x];\n                    }\n                }\n                if (sp == -1)\n                    break;\n                right = stack[sp--];\n                left = stack[sp--];\n            } else {\n                var median = left + right >> 1;\n                i = left + 1;\n                j = right;\n                swapF(median, i);\n                if (arr[left * eleSize + orderElement] > arr[right * eleSize + orderElement]) {\n                    swapF(left, right);\n                }\n                if (arr[i * eleSize + orderElement] > arr[right * eleSize + orderElement]) {\n                    swapF(i, right);\n                }\n                if (arr[left * eleSize + orderElement] > arr[i * eleSize + orderElement]) {\n                    swapF(left, i);\n                }\n                for (x = 0; x < eleSize; x++) {\n                    temp[x] = arr[i * eleSize + x];\n                }\n                while (true) {\n                    do\n                        i++;\n                    while (arr[i * eleSize + orderElement] < temp[orderElement]);\n                    do\n                        j--;\n                    while (arr[j * eleSize + orderElement] > temp[orderElement]);\n                    if (j < i)\n                        break;\n                    swapF(i, j);\n                }\n                for (x = 0; x < eleSize; x++) {\n                    arr[(left + 1) * eleSize + x] = arr[j * eleSize + x];\n                    arr[j * eleSize + x] = temp[x];\n                }\n                if (right - i + 1 >= j - left) {\n                    stack[++sp] = i;\n                    stack[++sp] = right;\n                    right = j - 1;\n                } else {\n                    stack[++sp] = left;\n                    stack[++sp] = j - 1;\n                    left = i;\n                }\n            }\n        }\n        return arr;\n    };\n    TypedArrayUtils.Kdtree = function (points, metric, eleSize) {\n        var self = this;\n        var maxDepth = 0;\n        var getPointSet = function (points, pos) {\n            return points.subarray(pos * eleSize, pos * eleSize + eleSize);\n        };\n        function buildTree(points, depth, parent, pos) {\n            var dim = depth % eleSize, median, node, plength = points.length / eleSize;\n            if (depth > maxDepth)\n                maxDepth = depth;\n            if (plength === 0)\n                return null;\n            if (plength === 1) {\n                return new self.Node(getPointSet(points, 0), depth, parent, pos);\n            }\n            TypedArrayUtils.quicksortIP(points, eleSize, dim);\n            median = Math.floor(plength / 2);\n            node = new self.Node(getPointSet(points, median), depth, parent, median + pos);\n            node.left = buildTree(points.subarray(0, median * eleSize), depth + 1, node, pos);\n            node.right = buildTree(points.subarray((median + 1) * eleSize, points.length), depth + 1, node, pos + median + 1);\n            return node;\n        }\n        this.root = buildTree(points, 0, null, 0);\n        this.getMaxDepth = function () {\n            return maxDepth;\n        };\n        this.nearest = function (point, maxNodes, maxDistance) {\n            var i, result, bestNodes;\n            bestNodes = new TypedArrayUtils.Kdtree.BinaryHeap(function (e) {\n                return -e[1];\n            });\n            function nearestSearch(node) {\n                var bestChild, dimension = node.depth % eleSize, ownDistance = metric(point, node.obj), linearDistance = 0, otherChild, i, linearPoint = [];\n                function saveNode(node, distance) {\n                    bestNodes.push([\n                        node,\n                        distance\n                    ]);\n                    if (bestNodes.size() > maxNodes) {\n                        bestNodes.pop();\n                    }\n                }\n                for (i = 0; i < eleSize; i += 1) {\n                    if (i === node.depth % eleSize) {\n                        linearPoint[i] = point[i];\n                    } else {\n                        linearPoint[i] = node.obj[i];\n                    }\n                }\n                linearDistance = metric(linearPoint, node.obj);\n                if (node.right === null && node.left === null) {\n                    if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n                        saveNode(node, ownDistance);\n                    }\n                    return;\n                }\n                if (node.right === null) {\n                    bestChild = node.left;\n                } else if (node.left === null) {\n                    bestChild = node.right;\n                } else {\n                    if (point[dimension] < node.obj[dimension]) {\n                        bestChild = node.left;\n                    } else {\n                        bestChild = node.right;\n                    }\n                }\n                nearestSearch(bestChild);\n                if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n                    saveNode(node, ownDistance);\n                }\n                if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {\n                    if (bestChild === node.left) {\n                        otherChild = node.right;\n                    } else {\n                        otherChild = node.left;\n                    }\n                    if (otherChild !== null) {\n                        nearestSearch(otherChild);\n                    }\n                }\n            }\n            if (maxDistance) {\n                for (i = 0; i < maxNodes; i += 1) {\n                    bestNodes.push([\n                        null,\n                        maxDistance\n                    ]);\n                }\n            }\n            nearestSearch(self.root);\n            result = [];\n            for (i = 0; i < maxNodes; i += 1) {\n                if (bestNodes.content[i][0]) {\n                    result.push([\n                        bestNodes.content[i][0],\n                        bestNodes.content[i][1]\n                    ]);\n                }\n            }\n            return result;\n        };\n    };\n    TypedArrayUtils.Kdtree.prototype.Node = function (obj, depth, parent, pos) {\n        this.obj = obj;\n        this.left = null;\n        this.right = null;\n        this.parent = parent;\n        this.depth = depth;\n        this.pos = pos;\n    };\n    TypedArrayUtils.Kdtree.BinaryHeap = function (scoreFunction) {\n        this.content = [];\n        this.scoreFunction = scoreFunction;\n    };\n    TypedArrayUtils.Kdtree.BinaryHeap.prototype = {\n        push: function (element) {\n            this.content.push(element);\n            this.bubbleUp(this.content.length - 1);\n        },\n        pop: function () {\n            var result = this.content[0];\n            var end = this.content.pop();\n            if (this.content.length > 0) {\n                this.content[0] = end;\n                this.sinkDown(0);\n            }\n            return result;\n        },\n        peek: function () {\n            return this.content[0];\n        },\n        remove: function (node) {\n            var len = this.content.length;\n            for (var i = 0; i < len; i++) {\n                if (this.content[i] == node) {\n                    var end = this.content.pop();\n                    if (i != len - 1) {\n                        this.content[i] = end;\n                        if (this.scoreFunction(end) < this.scoreFunction(node)) {\n                            this.bubbleUp(i);\n                        } else {\n                            this.sinkDown(i);\n                        }\n                    }\n                    return;\n                }\n            }\n            throw new Error('Node not found.');\n        },\n        size: function () {\n            return this.content.length;\n        },\n        bubbleUp: function (n) {\n            var element = this.content[n];\n            while (n > 0) {\n                var parentN = Math.floor((n + 1) / 2) - 1, parent = this.content[parentN];\n                if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n                    this.content[parentN] = element;\n                    this.content[n] = parent;\n                    n = parentN;\n                } else {\n                    break;\n                }\n            }\n        },\n        sinkDown: function (n) {\n            var length = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);\n            while (true) {\n                var child2N = (n + 1) * 2, child1N = child2N - 1;\n                var swap = null;\n                if (child1N < length) {\n                    var child1 = this.content[child1N], child1Score = this.scoreFunction(child1);\n                    if (child1Score < elemScore)\n                        swap = child1N;\n                }\n                if (child2N < length) {\n                    var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);\n                    if (child2Score < (swap === null ? elemScore : child1Score))\n                        swap = child2N;\n                }\n                if (swap !== null) {\n                    this.content[n] = this.content[swap];\n                    this.content[swap] = element;\n                    n = swap;\n                } else {\n                    break;\n                }\n            }\n        }\n    };\n    return TypedArrayUtils;\n});"]}