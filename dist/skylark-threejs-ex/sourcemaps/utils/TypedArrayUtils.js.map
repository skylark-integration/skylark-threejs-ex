{"version":3,"sources":["utils/TypedArrayUtils.js"],"names":["define","threex","TypedArrayUtils","quicksortIP","arr","eleSize","orderElement","i","j","stack","sp","left","right","length","tmp","x","y","swapF","a","b","swap","Float32Array","temp","Kdtree","points","metric","self","this","maxDepth","getPointSet","pos","subarray","root","buildTree","depth","parent","median","node","dim","plength","Node","Math","floor","getMaxDepth","nearest","point","maxNodes","maxDistance","result","bestNodes","BinaryHeap","e","push","nearestSearch","bestChild","linearDistance","otherChild","dimension","ownDistance","obj","linearPoint","saveNode","distance","size","pop","peek","abs","content","prototype","scoreFunction","element","bubbleUp","end","sinkDown","remove","len","Error","n","parentN","elemScore","child2N","child1N","child1","child1Score","child2","utils"],"mappings":"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","file":"../../utils/TypedArrayUtils.js","sourcesContent":["define([\r\n    \"../threex\"\r\n],function (threex) {\r\n    'use strict';\r\n    var TypedArrayUtils = {};\r\n    TypedArrayUtils.quicksortIP = function (arr, eleSize, orderElement) {\r\n        var stack = [];\r\n        var sp = -1;\r\n        var left = 0;\r\n        var right = arr.length / eleSize - 1;\r\n        var tmp = 0, x = 0, y = 0;\r\n        var swapF = function (a, b) {\r\n            a *= eleSize;\r\n            b *= eleSize;\r\n            for (y = 0; y < eleSize; y++) {\r\n                tmp = arr[a + y];\r\n                arr[a + y] = arr[b + y];\r\n                arr[b + y] = tmp;\r\n            }\r\n        };\r\n        var i, j, swap = new Float32Array(eleSize), temp = new Float32Array(eleSize);\r\n        while (true) {\r\n            if (right - left <= 25) {\r\n                for (j = left + 1; j <= right; j++) {\r\n                    for (x = 0; x < eleSize; x++) {\r\n                        swap[x] = arr[j * eleSize + x];\r\n                    }\r\n                    i = j - 1;\r\n                    while (i >= left && arr[i * eleSize + orderElement] > swap[orderElement]) {\r\n                        for (x = 0; x < eleSize; x++) {\r\n                            arr[(i + 1) * eleSize + x] = arr[i * eleSize + x];\r\n                        }\r\n                        i--;\r\n                    }\r\n                    for (x = 0; x < eleSize; x++) {\r\n                        arr[(i + 1) * eleSize + x] = swap[x];\r\n                    }\r\n                }\r\n                if (sp == -1)\r\n                    break;\r\n                right = stack[sp--];\r\n                left = stack[sp--];\r\n            } else {\r\n                var median = left + right >> 1;\r\n                i = left + 1;\r\n                j = right;\r\n                swapF(median, i);\r\n                if (arr[left * eleSize + orderElement] > arr[right * eleSize + orderElement]) {\r\n                    swapF(left, right);\r\n                }\r\n                if (arr[i * eleSize + orderElement] > arr[right * eleSize + orderElement]) {\r\n                    swapF(i, right);\r\n                }\r\n                if (arr[left * eleSize + orderElement] > arr[i * eleSize + orderElement]) {\r\n                    swapF(left, i);\r\n                }\r\n                for (x = 0; x < eleSize; x++) {\r\n                    temp[x] = arr[i * eleSize + x];\r\n                }\r\n                while (true) {\r\n                    do\r\n                        i++;\r\n                    while (arr[i * eleSize + orderElement] < temp[orderElement]);\r\n                    do\r\n                        j--;\r\n                    while (arr[j * eleSize + orderElement] > temp[orderElement]);\r\n                    if (j < i)\r\n                        break;\r\n                    swapF(i, j);\r\n                }\r\n                for (x = 0; x < eleSize; x++) {\r\n                    arr[(left + 1) * eleSize + x] = arr[j * eleSize + x];\r\n                    arr[j * eleSize + x] = temp[x];\r\n                }\r\n                if (right - i + 1 >= j - left) {\r\n                    stack[++sp] = i;\r\n                    stack[++sp] = right;\r\n                    right = j - 1;\r\n                } else {\r\n                    stack[++sp] = left;\r\n                    stack[++sp] = j - 1;\r\n                    left = i;\r\n                }\r\n            }\r\n        }\r\n        return arr;\r\n    };\r\n    TypedArrayUtils.Kdtree = function (points, metric, eleSize) {\r\n        var self = this;\r\n        var maxDepth = 0;\r\n        var getPointSet = function (points, pos) {\r\n            return points.subarray(pos * eleSize, pos * eleSize + eleSize);\r\n        };\r\n        function buildTree(points, depth, parent, pos) {\r\n            var dim = depth % eleSize, median, node, plength = points.length / eleSize;\r\n            if (depth > maxDepth)\r\n                maxDepth = depth;\r\n            if (plength === 0)\r\n                return null;\r\n            if (plength === 1) {\r\n                return new self.Node(getPointSet(points, 0), depth, parent, pos);\r\n            }\r\n            TypedArrayUtils.quicksortIP(points, eleSize, dim);\r\n            median = Math.floor(plength / 2);\r\n            node = new self.Node(getPointSet(points, median), depth, parent, median + pos);\r\n            node.left = buildTree(points.subarray(0, median * eleSize), depth + 1, node, pos);\r\n            node.right = buildTree(points.subarray((median + 1) * eleSize, points.length), depth + 1, node, pos + median + 1);\r\n            return node;\r\n        }\r\n        this.root = buildTree(points, 0, null, 0);\r\n        this.getMaxDepth = function () {\r\n            return maxDepth;\r\n        };\r\n        this.nearest = function (point, maxNodes, maxDistance) {\r\n            var i, result, bestNodes;\r\n            bestNodes = new TypedArrayUtils.Kdtree.BinaryHeap(function (e) {\r\n                return -e[1];\r\n            });\r\n            function nearestSearch(node) {\r\n                var bestChild, dimension = node.depth % eleSize, ownDistance = metric(point, node.obj), linearDistance = 0, otherChild, i, linearPoint = [];\r\n                function saveNode(node, distance) {\r\n                    bestNodes.push([\r\n                        node,\r\n                        distance\r\n                    ]);\r\n                    if (bestNodes.size() > maxNodes) {\r\n                        bestNodes.pop();\r\n                    }\r\n                }\r\n                for (i = 0; i < eleSize; i += 1) {\r\n                    if (i === node.depth % eleSize) {\r\n                        linearPoint[i] = point[i];\r\n                    } else {\r\n                        linearPoint[i] = node.obj[i];\r\n                    }\r\n                }\r\n                linearDistance = metric(linearPoint, node.obj);\r\n                if (node.right === null && node.left === null) {\r\n                    if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\r\n                        saveNode(node, ownDistance);\r\n                    }\r\n                    return;\r\n                }\r\n                if (node.right === null) {\r\n                    bestChild = node.left;\r\n                } else if (node.left === null) {\r\n                    bestChild = node.right;\r\n                } else {\r\n                    if (point[dimension] < node.obj[dimension]) {\r\n                        bestChild = node.left;\r\n                    } else {\r\n                        bestChild = node.right;\r\n                    }\r\n                }\r\n                nearestSearch(bestChild);\r\n                if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\r\n                    saveNode(node, ownDistance);\r\n                }\r\n                if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {\r\n                    if (bestChild === node.left) {\r\n                        otherChild = node.right;\r\n                    } else {\r\n                        otherChild = node.left;\r\n                    }\r\n                    if (otherChild !== null) {\r\n                        nearestSearch(otherChild);\r\n                    }\r\n                }\r\n            }\r\n            if (maxDistance) {\r\n                for (i = 0; i < maxNodes; i += 1) {\r\n                    bestNodes.push([\r\n                        null,\r\n                        maxDistance\r\n                    ]);\r\n                }\r\n            }\r\n            nearestSearch(self.root);\r\n            result = [];\r\n            for (i = 0; i < maxNodes; i += 1) {\r\n                if (bestNodes.content[i][0]) {\r\n                    result.push([\r\n                        bestNodes.content[i][0],\r\n                        bestNodes.content[i][1]\r\n                    ]);\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n    };\r\n    TypedArrayUtils.Kdtree.prototype.Node = function (obj, depth, parent, pos) {\r\n        this.obj = obj;\r\n        this.left = null;\r\n        this.right = null;\r\n        this.parent = parent;\r\n        this.depth = depth;\r\n        this.pos = pos;\r\n    };\r\n    TypedArrayUtils.Kdtree.BinaryHeap = function (scoreFunction) {\r\n        this.content = [];\r\n        this.scoreFunction = scoreFunction;\r\n    };\r\n    TypedArrayUtils.Kdtree.BinaryHeap.prototype = {\r\n        push: function (element) {\r\n            this.content.push(element);\r\n            this.bubbleUp(this.content.length - 1);\r\n        },\r\n        pop: function () {\r\n            var result = this.content[0];\r\n            var end = this.content.pop();\r\n            if (this.content.length > 0) {\r\n                this.content[0] = end;\r\n                this.sinkDown(0);\r\n            }\r\n            return result;\r\n        },\r\n        peek: function () {\r\n            return this.content[0];\r\n        },\r\n        remove: function (node) {\r\n            var len = this.content.length;\r\n            for (var i = 0; i < len; i++) {\r\n                if (this.content[i] == node) {\r\n                    var end = this.content.pop();\r\n                    if (i != len - 1) {\r\n                        this.content[i] = end;\r\n                        if (this.scoreFunction(end) < this.scoreFunction(node)) {\r\n                            this.bubbleUp(i);\r\n                        } else {\r\n                            this.sinkDown(i);\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n            throw new Error('Node not found.');\r\n        },\r\n        size: function () {\r\n            return this.content.length;\r\n        },\r\n        bubbleUp: function (n) {\r\n            var element = this.content[n];\r\n            while (n > 0) {\r\n                var parentN = Math.floor((n + 1) / 2) - 1, parent = this.content[parentN];\r\n                if (this.scoreFunction(element) < this.scoreFunction(parent)) {\r\n                    this.content[parentN] = element;\r\n                    this.content[n] = parent;\r\n                    n = parentN;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        },\r\n        sinkDown: function (n) {\r\n            var length = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);\r\n            while (true) {\r\n                var child2N = (n + 1) * 2, child1N = child2N - 1;\r\n                var swap = null;\r\n                if (child1N < length) {\r\n                    var child1 = this.content[child1N], child1Score = this.scoreFunction(child1);\r\n                    if (child1Score < elemScore)\r\n                        swap = child1N;\r\n                }\r\n                if (child2N < length) {\r\n                    var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);\r\n                    if (child2Score < (swap === null ? elemScore : child1Score))\r\n                        swap = child2N;\r\n                }\r\n                if (swap !== null) {\r\n                    this.content[n] = this.content[swap];\r\n                    this.content[swap] = element;\r\n                    n = swap;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    return threex.utils.TypedArrayUtils = TypedArrayUtils;\r\n});"]}