{"version":3,"sources":["utils/TypedArrayUtils.js"],"names":["define","THREE","TypedArrayUtils","quicksortIP","arr","eleSize","orderElement","i","j","stack","sp","left","right","length","tmp","x","y","swapF","a","b","swap","Float32Array","temp","Kdtree","points","metric","self","this","maxDepth","getPointSet","pos","subarray","root","buildTree","depth","parent","median","node","dim","plength","Node","Math","floor","getMaxDepth","nearest","point","maxNodes","maxDistance","result","bestNodes","BinaryHeap","e","push","nearestSearch","bestChild","linearDistance","otherChild","dimension","ownDistance","obj","linearPoint","saveNode","distance","size","pop","peek","abs","content","prototype","scoreFunction","element","bubbleUp","end","sinkDown","remove","len","Error","n","parentN","elemScore","child2N","child1N","child1","child1Score","child2"],"mappings":"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","file":"../../utils/TypedArrayUtils.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\n\tTHREE.TypedArrayUtils = {};\n\n\t/**\n\t * In-place quicksort for typed arrays (e.g. for Float32Array)\n\t * provides fast sorting\n\t * useful e.g. for a custom shader and/or BufferGeometry\n\t *\n\t * @author Roman Bolzern <roman.bolzern@fhnw.ch>, 2013\n\t * @author I4DS http://www.fhnw.ch/i4ds, 2013\n\t * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n\t *\n\t * Complexity: http://bigocheatsheet.com/ see Quicksort\n\t *\n\t * Example:\n\t * points: [x, y, z, x, y, z, x, y, z, ...]\n\t * eleSize: 3 //because of (x, y, z)\n\t * orderElement: 0 //order according to x\n\t */\n\n\tTHREE.TypedArrayUtils.quicksortIP = function ( arr, eleSize, orderElement ) {\n\n\t\tvar stack = [];\n\t\tvar sp = - 1;\n\t\tvar left = 0;\n\t\tvar right = arr.length / eleSize - 1;\n\t\tvar tmp = 0.0, x = 0, y = 0;\n\n\t\tvar swapF = function ( a, b ) {\n\n\t\t\ta *= eleSize; b *= eleSize;\n\n\t\t\tfor ( y = 0; y < eleSize; y ++ ) {\n\n\t\t\t\ttmp = arr[ a + y ];\n\t\t\t\tarr[ a + y ] = arr[ b + y ];\n\t\t\t\tarr[ b + y ] = tmp;\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar i, j, swap = new Float32Array( eleSize ), temp = new Float32Array( eleSize );\n\n\t\twhile ( true ) {\n\n\t\t\tif ( right - left <= 25 ) {\n\n\t\t\t\tfor ( j = left + 1; j <= right; j ++ ) {\n\n\t\t\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\n\n\t\t\t\t\t\tswap[ x ] = arr[ j * eleSize + x ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\ti = j - 1;\n\n\t\t\t\t\twhile ( i >= left && arr[ i * eleSize + orderElement ] > swap[ orderElement ] ) {\n\n\t\t\t\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\n\n\t\t\t\t\t\t\tarr[ ( i + 1 ) * eleSize + x ] = arr[ i * eleSize + x ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti --;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\n\n\t\t\t\t\t\tarr[ ( i + 1 ) * eleSize + x ] = swap[ x ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( sp == - 1 ) break;\n\n\t\t\t\tright = stack[ sp -- ]; //?\n\t\t\t\tleft = stack[ sp -- ];\n\n\t\t\t} else {\n\n\t\t\t\tvar median = ( left + right ) >> 1;\n\n\t\t\t\ti = left + 1;\n\t\t\t\tj = right;\n\n\t\t\t\tswapF( median, i );\n\n\t\t\t\tif ( arr[ left * eleSize + orderElement ] > arr[ right * eleSize + orderElement ] ) {\n\n\t\t\t\t\tswapF( left, right );\n\n\t\t\t\t}\n\n\t\t\t\tif ( arr[ i * eleSize + orderElement ] > arr[ right * eleSize + orderElement ] ) {\n\n\t\t\t\t\tswapF( i, right );\n\n\t\t\t\t}\n\n\t\t\t\tif ( arr[ left * eleSize + orderElement ] > arr[ i * eleSize + orderElement ] ) {\n\n\t\t\t\t\tswapF( left, i );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\n\n\t\t\t\t\ttemp[ x ] = arr[ i * eleSize + x ];\n\n\t\t\t\t}\n\n\t\t\t\twhile ( true ) {\n\n\t\t\t\t\tdo i ++; while ( arr[ i * eleSize + orderElement ] < temp[ orderElement ] );\n\t\t\t\t\tdo j --; while ( arr[ j * eleSize + orderElement ] > temp[ orderElement ] );\n\n\t\t\t\t\tif ( j < i ) break;\n\n\t\t\t\t\tswapF( i, j );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\n\n\t\t\t\t\tarr[ ( left + 1 ) * eleSize + x ] = arr[ j * eleSize + x ];\n\t\t\t\t\tarr[ j * eleSize + x ] = temp[ x ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( right - i + 1 >= j - left ) {\n\n\t\t\t\t\tstack[ ++ sp ] = i;\n\t\t\t\t\tstack[ ++ sp ] = right;\n\t\t\t\t\tright = j - 1;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack[ ++ sp ] = left;\n\t\t\t\t\tstack[ ++ sp ] = j - 1;\n\t\t\t\t\tleft = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn arr;\n\n\t};\n\n\n\t/**\n\t * k-d Tree for typed arrays (e.g. for Float32Array), in-place\n\t * provides fast nearest neighbour search\n\t * useful e.g. for a custom shader and/or BufferGeometry, saves tons of memory\n\t * has no insert and remove, only buildup and neares neighbour search\n\t *\n\t * Based on https://github.com/ubilabs/kd-tree-javascript by Ubilabs\n\t *\n\t * @author Roman Bolzern <roman.bolzern@fhnw.ch>, 2013\n\t * @author I4DS http://www.fhnw.ch/i4ds, 2013\n\t * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n\t *\n\t * Requires typed array quicksort\n\t *\n\t * Example:\n\t * points: [x, y, z, x, y, z, x, y, z, ...]\n\t * metric: function(a, b){\treturn Math.pow(a[0] - b[0], 2) +  Math.pow(a[1] - b[1], 2) +  Math.pow(a[2] - b[2], 2); }  //Manhatten distance\n\t * eleSize: 3 //because of (x, y, z)\n\t *\n\t * Further information (including mathematical properties)\n\t * http://en.wikipedia.org/wiki/Binary_tree\n\t * http://en.wikipedia.org/wiki/K-d_tree\n\t *\n\t * If you want to further minimize memory usage, remove Node.depth and replace in search algorithm with a traversal to root node (see comments at THREE.TypedArrayUtils.Kdtree.prototype.Node)\n\t */\n\n\tTHREE.TypedArrayUtils.Kdtree = function ( points, metric, eleSize ) {\n\n\t\tvar self = this;\n\n\t\tvar maxDepth = 0;\n\n\t\tvar getPointSet = function ( points, pos ) {\n\n\t\t\treturn points.subarray( pos * eleSize, pos * eleSize + eleSize );\n\n\t\t};\n\n\t\tfunction buildTree( points, depth, parent, pos ) {\n\n\t\t\tvar dim = depth % eleSize,\n\t\t\t\tmedian,\n\t\t\t\tnode,\n\t\t\t\tplength = points.length / eleSize;\n\n\t\t\tif ( depth > maxDepth ) maxDepth = depth;\n\n\t\t\tif ( plength === 0 ) return null;\n\t\t\tif ( plength === 1 ) {\n\n\t\t\t\treturn new self.Node( getPointSet( points, 0 ), depth, parent, pos );\n\n\t\t\t}\n\n\t\t\tTHREE.TypedArrayUtils.quicksortIP( points, eleSize, dim );\n\n\t\t\tmedian = Math.floor( plength / 2 );\n\n\t\t\tnode = new self.Node( getPointSet( points, median ), depth, parent, median + pos );\n\t\t\tnode.left = buildTree( points.subarray( 0, median * eleSize ), depth + 1, node, pos );\n\t\t\tnode.right = buildTree( points.subarray( ( median + 1 ) * eleSize, points.length ), depth + 1, node, pos + median + 1 );\n\n\t\t\treturn node;\n\n\t\t}\n\n\t\tthis.root = buildTree( points, 0, null, 0 );\n\n\t\tthis.getMaxDepth = function () {\n\n\t\t\treturn maxDepth;\n\n\t\t};\n\n\t\tthis.nearest = function ( point, maxNodes, maxDistance ) {\n\n\t\t\t /* point: array of size eleSize\n\t\t\t\tmaxNodes: max amount of nodes to return\n\t\t\t\tmaxDistance: maximum distance to point result nodes should have\n\t\t\t\tcondition (not implemented): function to test node before it's added to the result list, e.g. test for view frustum\n\t\t\t*/\n\n\t\t\tvar i,\n\t\t\t\tresult,\n\t\t\t\tbestNodes;\n\n\t\t\tbestNodes = new THREE.TypedArrayUtils.Kdtree.BinaryHeap(\n\n\t\t\t\tfunction ( e ) {\n\n\t\t\t\t\treturn - e[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t);\n\n\t\t\tfunction nearestSearch( node ) {\n\n\t\t\t\tvar bestChild,\n\t\t\t\t\tdimension = node.depth % eleSize,\n\t\t\t\t\townDistance = metric( point, node.obj ),\n\t\t\t\t\tlinearDistance = 0,\n\t\t\t\t\totherChild,\n\t\t\t\t\ti,\n\t\t\t\t\tlinearPoint = [];\n\n\t\t\t\tfunction saveNode( node, distance ) {\n\n\t\t\t\t\tbestNodes.push( [ node, distance ] );\n\n\t\t\t\t\tif ( bestNodes.size() > maxNodes ) {\n\n\t\t\t\t\t\tbestNodes.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0; i < eleSize; i += 1 ) {\n\n\t\t\t\t\tif ( i === node.depth % eleSize ) {\n\n\t\t\t\t\t\tlinearPoint[ i ] = point[ i ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlinearPoint[ i ] = node.obj[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tlinearDistance = metric( linearPoint, node.obj );\n\n\t\t\t\t// if it's a leaf\n\n\t\t\t\tif ( node.right === null && node.left === null ) {\n\n\t\t\t\t\tif ( bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[ 1 ] ) {\n\n\t\t\t\t\t\tsaveNode( node, ownDistance );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( node.right === null ) {\n\n\t\t\t\t\tbestChild = node.left;\n\n\t\t\t\t} else if ( node.left === null ) {\n\n\t\t\t\t\tbestChild = node.right;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( point[ dimension ] < node.obj[ dimension ] ) {\n\n\t\t\t\t\t\tbestChild = node.left;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbestChild = node.right;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// recursive search\n\n\t\t\t\tnearestSearch( bestChild );\n\n\t\t\t\tif ( bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[ 1 ] ) {\n\n\t\t\t\t\tsaveNode( node, ownDistance );\n\n\t\t\t\t}\n\n\t\t\t\t// if there's still room or the current distance is nearer than the best distance\n\n\t\t\t\tif ( bestNodes.size() < maxNodes || Math.abs( linearDistance ) < bestNodes.peek()[ 1 ] ) {\n\n\t\t\t\t\tif ( bestChild === node.left ) {\n\n\t\t\t\t\t\totherChild = node.right;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\totherChild = node.left;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherChild !== null ) {\n\n\t\t\t\t\t\tnearestSearch( otherChild );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( maxDistance ) {\n\n\t\t\t\tfor ( i = 0; i < maxNodes; i += 1 ) {\n\n\t\t\t\t\tbestNodes.push( [ null, maxDistance ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnearestSearch( self.root );\n\n\t\t\tresult = [];\n\n\t\t\tfor ( i = 0; i < maxNodes; i += 1 ) {\n\n\t\t\t\tif ( bestNodes.content[ i ][ 0 ] ) {\n\n\t\t\t\t\tresult.push( [ bestNodes.content[ i ][ 0 ], bestNodes.content[ i ][ 1 ] ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t};\n\n\t};\n\n\n\t/**\n\t * If you need to free up additional memory and agree with an additional O( log n ) traversal time you can get rid of \"depth\" and \"pos\" in Node:\n\t * Depth can be easily done by adding 1 for every parent (care: root node has depth 0, not 1)\n\t * Pos is a bit tricky: Assuming the tree is balanced (which is the case when after we built it up), perform the following steps:\n\t *   By traversing to the root store the path e.g. in a bit pattern (01001011, 0 is left, 1 is right)\n\t *   From buildTree we know that \"median = Math.floor( plength / 2 );\", therefore for each bit...\n\t *     0: amountOfNodesRelevantForUs = Math.floor( (pamountOfNodesRelevantForUs - 1) / 2 );\n\t *     1: amountOfNodesRelevantForUs = Math.ceil( (pamountOfNodesRelevantForUs - 1) / 2 );\n\t *        pos += Math.floor( (pamountOfNodesRelevantForUs - 1) / 2 );\n\t *     when recursion done, we still need to add all left children of target node:\n\t *        pos += Math.floor( (pamountOfNodesRelevantForUs - 1) / 2 );\n\t *        and I think you need to +1 for the current position, not sure.. depends, try it out ^^\n\t *\n\t * I experienced that for 200'000 nodes you can get rid of 4 MB memory each, leading to 8 MB memory saved.\n\t */\n\tTHREE.TypedArrayUtils.Kdtree.prototype.Node = function ( obj, depth, parent, pos ) {\n\n\t\tthis.obj = obj;\n\t\tthis.left = null;\n\t\tthis.right = null;\n\t\tthis.parent = parent;\n\t\tthis.depth = depth;\n\t\tthis.pos = pos;\n\n\t};\n\n\n\t/**\n\t * Binary heap implementation\n\t * @author http://eloquentjavascript.net/appendix2.htm\n\t */\n\n\tTHREE.TypedArrayUtils.Kdtree.BinaryHeap = function ( scoreFunction ) {\n\n\t\tthis.content = [];\n\t\tthis.scoreFunction = scoreFunction;\n\n\t};\n\n\tTHREE.TypedArrayUtils.Kdtree.BinaryHeap.prototype = {\n\n\t\tpush: function ( element ) {\n\n\t\t\t// Add the new element to the end of the array.\n\t\t\tthis.content.push( element );\n\n\t\t\t// Allow it to bubble up.\n\t\t\tthis.bubbleUp( this.content.length - 1 );\n\n\t\t},\n\n\t\tpop: function () {\n\n\t\t\t// Store the first element so we can return it later.\n\t\t\tvar result = this.content[ 0 ];\n\n\t\t\t// Get the element at the end of the array.\n\t\t\tvar end = this.content.pop();\n\n\t\t\t// If there are any elements left, put the end element at the\n\t\t\t// start, and let it sink down.\n\t\t\tif ( this.content.length > 0 ) {\n\n\t\t\t\tthis.content[ 0 ] = end;\n\t\t\t\tthis.sinkDown( 0 );\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t},\n\n\t\tpeek: function () {\n\n\t\t\treturn this.content[ 0 ];\n\n\t\t},\n\n\t\tremove: function ( node ) {\n\n\t\t\tvar len = this.content.length;\n\n\t\t\t// To remove a value, we must search through the array to find it.\n\t\t\tfor ( var i = 0; i < len; i ++ ) {\n\n\t\t\t\tif ( this.content[ i ] == node ) {\n\n\t\t\t\t\t// When it is found, the process seen in 'pop' is repeated\n\t\t\t\t\t// to fill up the hole.\n\t\t\t\t\tvar end = this.content.pop();\n\n\t\t\t\t\tif ( i != len - 1 ) {\n\n\t\t\t\t\t\tthis.content[ i ] = end;\n\n\t\t\t\t\t\tif ( this.scoreFunction( end ) < this.scoreFunction( node ) ) {\n\n\t\t\t\t\t\t\tthis.bubbleUp( i );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthis.sinkDown( i );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthrow new Error( \"Node not found.\" );\n\n\t\t},\n\n\t\tsize: function () {\n\n\t\t\treturn this.content.length;\n\n\t\t},\n\n\t\tbubbleUp: function ( n ) {\n\n\t\t\t// Fetch the element that has to be moved.\n\t\t\tvar element = this.content[ n ];\n\n\t\t\t// When at 0, an element can not go up any further.\n\t\t\twhile ( n > 0 ) {\n\n\t\t\t\t// Compute the parent element's index, and fetch it.\n\t\t\t\tvar parentN = Math.floor( ( n + 1 ) / 2 ) - 1,\n\t\t\t\t\tparent = this.content[ parentN ];\n\n\t\t\t\t// Swap the elements if the parent is greater.\n\t\t\t\tif ( this.scoreFunction( element ) < this.scoreFunction( parent ) ) {\n\n\t\t\t\t\tthis.content[ parentN ] = element;\n\t\t\t\t\tthis.content[ n ] = parent;\n\n\t\t\t\t\t// Update 'n' to continue at the new position.\n\t\t\t\t\tn = parentN;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Found a parent that is less, no need to move it further.\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t},\n\n\t\tsinkDown: function ( n ) {\n\n\t\t\t// Look up the target element and its score.\n\t\t\tvar length = this.content.length,\n\t\t\t\telement = this.content[ n ],\n\t\t\t\telemScore = this.scoreFunction( element );\n\n\t\t\twhile ( true ) {\n\n\t\t\t\t// Compute the indices of the child elements.\n\t\t\t\tvar child2N = ( n + 1 ) * 2, child1N = child2N - 1;\n\n\t\t\t\t// This is used to store the new position of the element, if any.\n\t\t\t\tvar swap = null;\n\n\t\t\t\t// If the first child exists (is inside the array)...\n\t\t\t\tif ( child1N < length ) {\n\n\t\t\t\t\t// Look it up and compute its score.\n\t\t\t\t\tvar child1 = this.content[ child1N ],\n\t\t\t\t\t\tchild1Score = this.scoreFunction( child1 );\n\n\t\t\t\t\t// If the score is less than our element's, we need to swap.\n\t\t\t\t\tif ( child1Score < elemScore ) swap = child1N;\n\n\t\t\t\t}\n\n\t\t\t\t// Do the same checks for the other child.\n\t\t\t\tif ( child2N < length ) {\n\n\t\t\t\t\tvar child2 = this.content[ child2N ],\n\t\t\t\t\t\tchild2Score = this.scoreFunction( child2 );\n\n\t\t\t\t\tif ( child2Score < ( swap === null ? elemScore : child1Score ) ) swap = child2N;\n\n\t\t\t\t}\n\n\t\t\t\t// If the element needs to be moved, swap it, and continue.\n\t\t\t\tif ( swap !== null ) {\n\n\t\t\t\t\tthis.content[ n ] = this.content[ swap ];\n\t\t\t\t\tthis.content[ swap ] = element;\n\t\t\t\t\tn = swap;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise, we are done.\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\t\n\treturn THREE.TypedArrayUtils;\n});\n"]}