{"version":3,"sources":["utils/RoughnessMipmapper.js"],"names":["define","THREE","threex","RoughnessMipmapper","shaderMaterial","_mipmapMaterial","RawShaderMaterial","uniforms","roughnessMap","value","normalMap","texelSize","Vector2","vertexShader","fragmentShader","blending","NoBlending","depthTest","depthWrite","type","_scene","Scene","add","Mesh","PlaneBufferGeometry","_flatCamera","OrthographicCamera","_tempTarget","_renderer","renderer","compile","prototype","constructor","generateMipmaps","material","userData","roughnessUpdated","width","Math","max","image","height","MathUtils","isPowerOfTwo","oldTarget","getRenderTarget","autoClear","dispose","WebGLRenderTarget","depthBuffer","stencilBuffer","scissorTest","newRoughnessTarget","minFilter","LinearMipMapLinearFilter","texture","setRenderTarget","metalnessMap","aoMap","position","mip","set","viewport","x","y","scissor","render","copyFramebufferToTexture","children","geometry","utils"],"mappings":"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","file":"../../utils/RoughnessMipmapper.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var RoughnessMipmapper = function () {\r\n        var _mipmapMaterial = _getMipmapMaterial();\r\n        var _scene = new THREE.Scene();\r\n        _scene.add(new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), _mipmapMaterial));\r\n        var _flatCamera = new THREE.OrthographicCamera(0, 1, 0, 1, 0, 1);\r\n        var _tempTarget = null;\r\n        var _renderer = null;\r\n        var RoughnessMipmapper = function (renderer) {\r\n            _renderer = renderer;\r\n            _renderer.compile(_scene, _flatCamera);\r\n        };\r\n        RoughnessMipmapper.prototype = {\r\n            constructor: RoughnessMipmapper,\r\n            generateMipmaps: function (material) {\r\n                var {roughnessMap, normalMap} = material;\r\n                if (roughnessMap == null || normalMap == null || !roughnessMap.generateMipmaps || material.userData.roughnessUpdated)\r\n                    return;\r\n                material.userData.roughnessUpdated = true;\r\n                var width = Math.max(roughnessMap.image.width, normalMap.image.width);\r\n                var height = Math.max(roughnessMap.image.height, normalMap.image.height);\r\n                if (!THREE.MathUtils.isPowerOfTwo(width) || !THREE.MathUtils.isPowerOfTwo(height))\r\n                    return;\r\n                var oldTarget = _renderer.getRenderTarget();\r\n                var autoClear = _renderer.autoClear;\r\n                _renderer.autoClear = false;\r\n                if (_tempTarget == null || _tempTarget.width !== width || _tempTarget.height !== height) {\r\n                    if (_tempTarget != null)\r\n                        _tempTarget.dispose();\r\n                    _tempTarget = new THREE.WebGLRenderTarget(width, height, {\r\n                        depthBuffer: false,\r\n                        stencilBuffer: false\r\n                    });\r\n                    _tempTarget.scissorTest = true;\r\n                }\r\n                if (width !== roughnessMap.image.width || height !== roughnessMap.image.height) {\r\n                    var newRoughnessTarget = new THREE.WebGLRenderTarget(width, height, {\r\n                        minFilter: THREE.LinearMipMapLinearFilter,\r\n                        depthBuffer: false,\r\n                        stencilBuffer: false\r\n                    });\r\n                    newRoughnessTarget.texture.generateMipmaps = true;\r\n                    _renderer.setRenderTarget(newRoughnessTarget);\r\n                    material.roughnessMap = newRoughnessTarget.texture;\r\n                    if (material.metalnessMap == roughnessMap)\r\n                        material.metalnessMap = material.roughnessMap;\r\n                    if (material.aoMap == roughnessMap)\r\n                        material.aoMap = material.roughnessMap;\r\n                }\r\n                _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;\r\n                _mipmapMaterial.uniforms.normalMap.value = normalMap;\r\n                var position = new THREE.Vector2(0, 0);\r\n                var texelSize = _mipmapMaterial.uniforms.texelSize.value;\r\n                for (var mip = 0; width >= 1 && height >= 1; ++mip, width /= 2, height /= 2) {\r\n                    texelSize.set(1 / width, 1 / height);\r\n                    if (mip == 0)\r\n                        texelSize.set(0, 0);\r\n                    _tempTarget.viewport.set(position.x, position.y, width, height);\r\n                    _tempTarget.scissor.set(position.x, position.y, width, height);\r\n                    _renderer.setRenderTarget(_tempTarget);\r\n                    _renderer.render(_scene, _flatCamera);\r\n                    _renderer.copyFramebufferToTexture(position, material.roughnessMap, mip);\r\n                    _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;\r\n                }\r\n                if (roughnessMap !== material.roughnessMap)\r\n                    roughnessMap.dispose();\r\n                _renderer.setRenderTarget(oldTarget);\r\n                _renderer.autoClear = autoClear;\r\n            },\r\n            dispose: function () {\r\n                _mipmapMaterial.dispose();\r\n                _scene.children[0].geometry.dispose();\r\n                if (_tempTarget != null)\r\n                    _tempTarget.dispose();\r\n            }\r\n        };\r\n        function _getMipmapMaterial() {\r\n            var shaderMaterial = new THREE.RawShaderMaterial({\r\n                uniforms: {\r\n                    roughnessMap: { value: null },\r\n                    normalMap: { value: null },\r\n                    texelSize: { value: new THREE.Vector2(1, 1) }\r\n                },\r\n                vertexShader: `\r\nprecision mediump float;\r\nprecision mediump int;\r\nattribute vec3 position;\r\nattribute vec2 uv;\r\nvarying vec2 vUv;\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = vec4( position, 1.0 );\r\n}\r\n              `,\r\n                fragmentShader: `\r\nprecision mediump float;\r\nprecision mediump int;\r\nvarying vec2 vUv;\r\nuniform sampler2D roughnessMap;\r\nuniform sampler2D normalMap;\r\nuniform vec2 texelSize;\r\n\r\n#define ENVMAP_TYPE_CUBE_UV\r\nvec4 envMapTexelToLinear(vec4 a){return a;}\r\n#include <cube_uv_reflection_fragment>\r\n\r\nfloat roughnessToVariance(float roughness) {\r\n  float variance = 0.0;\r\n  if (roughness >= r1) {\r\n    variance = (r0 - roughness) * (v1 - v0) / (r0 - r1) + v0;\r\n  } else if (roughness >= r4) {\r\n    variance = (r1 - roughness) * (v4 - v1) / (r1 - r4) + v1;\r\n  } else if (roughness >= r5) {\r\n    variance = (r4 - roughness) * (v5 - v4) / (r4 - r5) + v4;\r\n  } else {\r\n    float roughness2 = roughness * roughness;\r\n    variance = 1.79 * roughness2 * roughness2;\r\n  }\r\n  return variance;\r\n}\r\nfloat varianceToRoughness(float variance) {\r\n  float roughness = 0.0;\r\n  if (variance >= v1) {\r\n    roughness = (v0 - variance) * (r1 - r0) / (v0 - v1) + r0;\r\n  } else if (variance >= v4) {\r\n    roughness = (v1 - variance) * (r4 - r1) / (v1 - v4) + r1;\r\n  } else if (variance >= v5) {\r\n    roughness = (v4 - variance) * (r5 - r4) / (v4 - v5) + r4;\r\n  } else {\r\n    roughness = pow(0.559 * variance, 0.25);// 0.559 = 1.0 / 1.79\r\n  }\r\n  return roughness;\r\n}\r\n\r\nvoid main() {\r\n    gl_FragColor = texture2D(roughnessMap, vUv, -1.0);\r\n    if (texelSize.x == 0.0) return;\r\n    float roughness = gl_FragColor.g;\r\n    float variance = roughnessToVariance(roughness);\r\n    vec3 avgNormal;\r\n    for (float x = -1.0; x < 2.0; x += 2.0) {\r\n    for (float y = -1.0; y < 2.0; y += 2.0) {\r\n        vec2 uv = vUv + vec2(x, y) * 0.25 * texelSize;\r\n        avgNormal += normalize(texture2D(normalMap, uv, -1.0).xyz - 0.5);\r\n    }\r\n    }\r\n    variance += 1.0 - 0.25 * length(avgNormal);\r\n    gl_FragColor.g = varianceToRoughness(variance);\r\n}\r\n              `,\r\n                blending: THREE.NoBlending,\r\n                depthTest: false,\r\n                depthWrite: false\r\n            });\r\n            shaderMaterial.type = 'RoughnessMipmapper';\r\n            return shaderMaterial;\r\n        }\r\n        return RoughnessMipmapper;\r\n    }();\r\n\r\n\r\n    return threex.utils.RoughnessMipmapper = RoughnessMipmapper;\r\n});"]}