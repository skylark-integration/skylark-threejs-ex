{"version":3,"sources":["utils/RoughnessMipmapper.js"],"names":["define","THREE","shaderMaterial","_mipmapMaterial","RawShaderMaterial","uniforms","roughnessMap","value","normalMap","texelSize","Vector2","vertexShader","fragmentShader","blending","NoBlending","depthTest","depthWrite","type","_scene","Scene","add","Mesh","PlaneBufferGeometry","_flatCamera","OrthographicCamera","_tempTarget","_renderer","RoughnessMipmapper","renderer","compile","prototype","constructor","generateMipmaps","material","userData","roughnessUpdated","width","Math","max","image","height","MathUtils","isPowerOfTwo","oldTarget","getRenderTarget","autoClear","dispose","WebGLRenderTarget","depthBuffer","stencilBuffer","scissorTest","newRoughnessTarget","minFilter","LinearMipMapLinearFilter","texture","setRenderTarget","metalnessMap","aoMap","position","mip","set","viewport","x","y","scissor","render","copyFramebufferToTexture","children","geometry"],"mappings":"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","file":"../../utils/RoughnessMipmapper.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var RoughnessMipmapper = function () {\n        var _mipmapMaterial = _getMipmapMaterial();\n        var _scene = new THREE.Scene();\n        _scene.add(new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), _mipmapMaterial));\n        var _flatCamera = new THREE.OrthographicCamera(0, 1, 0, 1, 0, 1);\n        var _tempTarget = null;\n        var _renderer = null;\n        var RoughnessMipmapper = function (renderer) {\n            _renderer = renderer;\n            _renderer.compile(_scene, _flatCamera);\n        };\n        RoughnessMipmapper.prototype = {\n            constructor: RoughnessMipmapper,\n            generateMipmaps: function (material) {\n                var {roughnessMap, normalMap} = material;\n                if (roughnessMap == null || normalMap == null || !roughnessMap.generateMipmaps || material.userData.roughnessUpdated)\n                    return;\n                material.userData.roughnessUpdated = true;\n                var width = Math.max(roughnessMap.image.width, normalMap.image.width);\n                var height = Math.max(roughnessMap.image.height, normalMap.image.height);\n                if (!THREE.MathUtils.isPowerOfTwo(width) || !THREE.MathUtils.isPowerOfTwo(height))\n                    return;\n                var oldTarget = _renderer.getRenderTarget();\n                var autoClear = _renderer.autoClear;\n                _renderer.autoClear = false;\n                if (_tempTarget == null || _tempTarget.width !== width || _tempTarget.height !== height) {\n                    if (_tempTarget != null)\n                        _tempTarget.dispose();\n                    _tempTarget = new THREE.WebGLRenderTarget(width, height, {\n                        depthBuffer: false,\n                        stencilBuffer: false\n                    });\n                    _tempTarget.scissorTest = true;\n                }\n                if (width !== roughnessMap.image.width || height !== roughnessMap.image.height) {\n                    var newRoughnessTarget = new THREE.WebGLRenderTarget(width, height, {\n                        minFilter: THREE.LinearMipMapLinearFilter,\n                        depthBuffer: false,\n                        stencilBuffer: false\n                    });\n                    newRoughnessTarget.texture.generateMipmaps = true;\n                    _renderer.setRenderTarget(newRoughnessTarget);\n                    material.roughnessMap = newRoughnessTarget.texture;\n                    if (material.metalnessMap == roughnessMap)\n                        material.metalnessMap = material.roughnessMap;\n                    if (material.aoMap == roughnessMap)\n                        material.aoMap = material.roughnessMap;\n                }\n                _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;\n                _mipmapMaterial.uniforms.normalMap.value = normalMap;\n                var position = new THREE.Vector2(0, 0);\n                var texelSize = _mipmapMaterial.uniforms.texelSize.value;\n                for (var mip = 0; width >= 1 && height >= 1; ++mip, width /= 2, height /= 2) {\n                    texelSize.set(1 / width, 1 / height);\n                    if (mip == 0)\n                        texelSize.set(0, 0);\n                    _tempTarget.viewport.set(position.x, position.y, width, height);\n                    _tempTarget.scissor.set(position.x, position.y, width, height);\n                    _renderer.setRenderTarget(_tempTarget);\n                    _renderer.render(_scene, _flatCamera);\n                    _renderer.copyFramebufferToTexture(position, material.roughnessMap, mip);\n                    _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;\n                }\n                if (roughnessMap !== material.roughnessMap)\n                    roughnessMap.dispose();\n                _renderer.setRenderTarget(oldTarget);\n                _renderer.autoClear = autoClear;\n            },\n            dispose: function () {\n                _mipmapMaterial.dispose();\n                _scene.children[0].geometry.dispose();\n                if (_tempTarget != null)\n                    _tempTarget.dispose();\n            }\n        };\n        function _getMipmapMaterial() {\n            var shaderMaterial = new THREE.RawShaderMaterial({\n                uniforms: {\n                    roughnessMap: { value: null },\n                    normalMap: { value: null },\n                    texelSize: { value: new THREE.Vector2(1, 1) }\n                },\n                vertexShader: `\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = vec4( position, 1.0 );\n}\n              `,\n                fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec2 vUv;\nuniform sampler2D roughnessMap;\nuniform sampler2D normalMap;\nuniform vec2 texelSize;\n\n#define ENVMAP_TYPE_CUBE_UV\nvec4 envMapTexelToLinear(vec4 a){return a;}\n#include <cube_uv_reflection_fragment>\n\nfloat roughnessToVariance(float roughness) {\n  float variance = 0.0;\n  if (roughness >= r1) {\n    variance = (r0 - roughness) * (v1 - v0) / (r0 - r1) + v0;\n  } else if (roughness >= r4) {\n    variance = (r1 - roughness) * (v4 - v1) / (r1 - r4) + v1;\n  } else if (roughness >= r5) {\n    variance = (r4 - roughness) * (v5 - v4) / (r4 - r5) + v4;\n  } else {\n    float roughness2 = roughness * roughness;\n    variance = 1.79 * roughness2 * roughness2;\n  }\n  return variance;\n}\nfloat varianceToRoughness(float variance) {\n  float roughness = 0.0;\n  if (variance >= v1) {\n    roughness = (v0 - variance) * (r1 - r0) / (v0 - v1) + r0;\n  } else if (variance >= v4) {\n    roughness = (v1 - variance) * (r4 - r1) / (v1 - v4) + r1;\n  } else if (variance >= v5) {\n    roughness = (v4 - variance) * (r5 - r4) / (v4 - v5) + r4;\n  } else {\n    roughness = pow(0.559 * variance, 0.25);// 0.559 = 1.0 / 1.79\n  }\n  return roughness;\n}\n\nvoid main() {\n    gl_FragColor = texture2D(roughnessMap, vUv, -1.0);\n    if (texelSize.x == 0.0) return;\n    float roughness = gl_FragColor.g;\n    float variance = roughnessToVariance(roughness);\n    vec3 avgNormal;\n    for (float x = -1.0; x < 2.0; x += 2.0) {\n    for (float y = -1.0; y < 2.0; y += 2.0) {\n        vec2 uv = vUv + vec2(x, y) * 0.25 * texelSize;\n        avgNormal += normalize(texture2D(normalMap, uv, -1.0).xyz - 0.5);\n    }\n    }\n    variance += 1.0 - 0.25 * length(avgNormal);\n    gl_FragColor.g = varianceToRoughness(variance);\n}\n              `,\n                blending: THREE.NoBlending,\n                depthTest: false,\n                depthWrite: false\n            });\n            shaderMaterial.type = 'RoughnessMipmapper';\n            return shaderMaterial;\n        }\n        return RoughnessMipmapper;\n    }();\n\n\n    return RoughnessMipmapper;\n});"]}