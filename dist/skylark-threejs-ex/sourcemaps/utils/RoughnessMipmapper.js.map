{"version":3,"sources":["utils/RoughnessMipmapper.js"],"names":["define","THREE","threex","RoughnessMipmapper","shaderMaterial","_mipmapMaterial","RawShaderMaterial","uniforms","roughnessMap","value","normalMap","texelSize","Vector2","vertexShader","fragmentShader","blending","NoBlending","depthTest","depthWrite","type","_scene","Scene","add","Mesh","PlaneBufferGeometry","_flatCamera","OrthographicCamera","_tempTarget","_renderer","renderer","compile","prototype","constructor","generateMipmaps","material","userData","roughnessUpdated","width","Math","max","image","height","MathUtils","isPowerOfTwo","oldTarget","getRenderTarget","autoClear","dispose","WebGLRenderTarget","depthBuffer","stencilBuffer","scissorTest","newRoughnessTarget","minFilter","LinearMipMapLinearFilter","texture","setRenderTarget","metalnessMap","aoMap","position","mip","set","viewport","x","y","scissor","render","copyFramebufferToTexture","children","geometry","utils"],"mappings":"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","file":"../../utils/RoughnessMipmapper.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    \"../threex\"\n], function (\n    THREE,\n    threex\n) {\n    'use strict';\n    var RoughnessMipmapper = function () {\n        var _mipmapMaterial = _getMipmapMaterial();\n        var _scene = new THREE.Scene();\n        _scene.add(new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), _mipmapMaterial));\n        var _flatCamera = new THREE.OrthographicCamera(0, 1, 0, 1, 0, 1);\n        var _tempTarget = null;\n        var _renderer = null;\n        var RoughnessMipmapper = function (renderer) {\n            _renderer = renderer;\n            _renderer.compile(_scene, _flatCamera);\n        };\n        RoughnessMipmapper.prototype = {\n            constructor: RoughnessMipmapper,\n            generateMipmaps: function (material) {\n                var {roughnessMap, normalMap} = material;\n                if (roughnessMap == null || normalMap == null || !roughnessMap.generateMipmaps || material.userData.roughnessUpdated)\n                    return;\n                material.userData.roughnessUpdated = true;\n                var width = Math.max(roughnessMap.image.width, normalMap.image.width);\n                var height = Math.max(roughnessMap.image.height, normalMap.image.height);\n                if (!THREE.MathUtils.isPowerOfTwo(width) || !THREE.MathUtils.isPowerOfTwo(height))\n                    return;\n                var oldTarget = _renderer.getRenderTarget();\n                var autoClear = _renderer.autoClear;\n                _renderer.autoClear = false;\n                if (_tempTarget == null || _tempTarget.width !== width || _tempTarget.height !== height) {\n                    if (_tempTarget != null)\n                        _tempTarget.dispose();\n                    _tempTarget = new THREE.WebGLRenderTarget(width, height, {\n                        depthBuffer: false,\n                        stencilBuffer: false\n                    });\n                    _tempTarget.scissorTest = true;\n                }\n                if (width !== roughnessMap.image.width || height !== roughnessMap.image.height) {\n                    var newRoughnessTarget = new THREE.WebGLRenderTarget(width, height, {\n                        minFilter: THREE.LinearMipMapLinearFilter,\n                        depthBuffer: false,\n                        stencilBuffer: false\n                    });\n                    newRoughnessTarget.texture.generateMipmaps = true;\n                    _renderer.setRenderTarget(newRoughnessTarget);\n                    material.roughnessMap = newRoughnessTarget.texture;\n                    if (material.metalnessMap == roughnessMap)\n                        material.metalnessMap = material.roughnessMap;\n                    if (material.aoMap == roughnessMap)\n                        material.aoMap = material.roughnessMap;\n                }\n                _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;\n                _mipmapMaterial.uniforms.normalMap.value = normalMap;\n                var position = new THREE.Vector2(0, 0);\n                var texelSize = _mipmapMaterial.uniforms.texelSize.value;\n                for (var mip = 0; width >= 1 && height >= 1; ++mip, width /= 2, height /= 2) {\n                    texelSize.set(1 / width, 1 / height);\n                    if (mip == 0)\n                        texelSize.set(0, 0);\n                    _tempTarget.viewport.set(position.x, position.y, width, height);\n                    _tempTarget.scissor.set(position.x, position.y, width, height);\n                    _renderer.setRenderTarget(_tempTarget);\n                    _renderer.render(_scene, _flatCamera);\n                    _renderer.copyFramebufferToTexture(position, material.roughnessMap, mip);\n                    _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;\n                }\n                if (roughnessMap !== material.roughnessMap)\n                    roughnessMap.dispose();\n                _renderer.setRenderTarget(oldTarget);\n                _renderer.autoClear = autoClear;\n            },\n            dispose: function () {\n                _mipmapMaterial.dispose();\n                _scene.children[0].geometry.dispose();\n                if (_tempTarget != null)\n                    _tempTarget.dispose();\n            }\n        };\n        function _getMipmapMaterial() {\n            var shaderMaterial = new THREE.RawShaderMaterial({\n                uniforms: {\n                    roughnessMap: { value: null },\n                    normalMap: { value: null },\n                    texelSize: { value: new THREE.Vector2(1, 1) }\n                },\n                vertexShader: `\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = vec4( position, 1.0 );\n}\n              `,\n                fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec2 vUv;\nuniform sampler2D roughnessMap;\nuniform sampler2D normalMap;\nuniform vec2 texelSize;\n\n#define ENVMAP_TYPE_CUBE_UV\nvec4 envMapTexelToLinear(vec4 a){return a;}\n#include <cube_uv_reflection_fragment>\n\nfloat roughnessToVariance(float roughness) {\n  float variance = 0.0;\n  if (roughness >= r1) {\n    variance = (r0 - roughness) * (v1 - v0) / (r0 - r1) + v0;\n  } else if (roughness >= r4) {\n    variance = (r1 - roughness) * (v4 - v1) / (r1 - r4) + v1;\n  } else if (roughness >= r5) {\n    variance = (r4 - roughness) * (v5 - v4) / (r4 - r5) + v4;\n  } else {\n    float roughness2 = roughness * roughness;\n    variance = 1.79 * roughness2 * roughness2;\n  }\n  return variance;\n}\nfloat varianceToRoughness(float variance) {\n  float roughness = 0.0;\n  if (variance >= v1) {\n    roughness = (v0 - variance) * (r1 - r0) / (v0 - v1) + r0;\n  } else if (variance >= v4) {\n    roughness = (v1 - variance) * (r4 - r1) / (v1 - v4) + r1;\n  } else if (variance >= v5) {\n    roughness = (v4 - variance) * (r5 - r4) / (v4 - v5) + r4;\n  } else {\n    roughness = pow(0.559 * variance, 0.25);// 0.559 = 1.0 / 1.79\n  }\n  return roughness;\n}\n\nvoid main() {\n    gl_FragColor = texture2D(roughnessMap, vUv, -1.0);\n    if (texelSize.x == 0.0) return;\n    float roughness = gl_FragColor.g;\n    float variance = roughnessToVariance(roughness);\n    vec3 avgNormal;\n    for (float x = -1.0; x < 2.0; x += 2.0) {\n    for (float y = -1.0; y < 2.0; y += 2.0) {\n        vec2 uv = vUv + vec2(x, y) * 0.25 * texelSize;\n        avgNormal += normalize(texture2D(normalMap, uv, -1.0).xyz - 0.5);\n    }\n    }\n    variance += 1.0 - 0.25 * length(avgNormal);\n    gl_FragColor.g = varianceToRoughness(variance);\n}\n              `,\n                blending: THREE.NoBlending,\n                depthTest: false,\n                depthWrite: false\n            });\n            shaderMaterial.type = 'RoughnessMipmapper';\n            return shaderMaterial;\n        }\n        return RoughnessMipmapper;\n    }();\n\n\n    return threex.utils.RoughnessMipmapper = RoughnessMipmapper;\n});"]}