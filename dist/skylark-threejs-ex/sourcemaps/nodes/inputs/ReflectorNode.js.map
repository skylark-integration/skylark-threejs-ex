{"version":3,"sources":["nodes/inputs/ReflectorNode.js"],"names":["define","TempNode","InputNode","PositionNode","OperatorNode","TextureNode","Matrix4Node","ReflectorNode","mirror","call","this","setMirror","prototype","Object","create","constructor","nodeType","textureMatrix","material","uniforms","value","localPosition","LOCAL","uv","MUL","uvResult","ADD","texture","tDiffuse","generate","builder","output","isShader","a","offset","build","format","type","console","warn","shader","copy","source","scope","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":";;;;;;;AAAAA,QACI,mBACA,oBACA,4BACA,uBACA,gBACA,iBACD,SACCC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,aACA,SAASC,EAAcC,GACnBP,EAASQ,KAAKC,KAAM,MAChBF,GACAE,KAAKC,UAAUH,GAyCvB,OAvCAD,EAAcK,UAAYC,OAAOC,OAAOb,EAASW,WACjDL,EAAcK,UAAUG,YAAcR,EACtCA,EAAcK,UAAUI,SAAW,YACnCT,EAAcK,UAAUD,UAAY,SAAUH,GAC1CE,KAAKF,OAASA,EACdE,KAAKO,cAAgB,IAAIX,EAAYI,KAAKF,OAAOU,SAASC,SAASF,cAAcG,OACjFV,KAAKW,cAAgB,IAAIlB,EAAaA,EAAamB,OACnDZ,KAAKa,GAAK,IAAInB,EAAaM,KAAKO,cAAeP,KAAKW,cAAejB,EAAaoB,KAChFd,KAAKe,SAAW,IAAIrB,EAAa,KAAMM,KAAKa,GAAInB,EAAasB,KAC7DhB,KAAKiB,QAAU,IAAItB,EAAYK,KAAKF,OAAOU,SAASC,SAASS,SAASR,MAAOV,KAAKa,GAAI,MAAM,IAEhGhB,EAAcK,UAAUiB,SAAW,SAAUC,EAASC,GAClD,OAAID,EAAQE,SAAS,aACjBtB,KAAKe,SAASQ,EAAIvB,KAAKwB,OACvBxB,KAAKiB,QAAQJ,GAAKb,KAAKwB,OAASxB,KAAKe,SAAWf,KAAKa,GACtC,cAAXQ,EACOrB,KAAKiB,QAAQQ,MAAML,EAASC,GAEhCD,EAAQM,OAAO1B,KAAKiB,QAAQQ,MAAML,EAASpB,KAAK2B,MAAO3B,KAAK2B,KAAMN,KAEzEO,QAAQC,KAAK,8CAAgDT,EAAQU,OAAS,YACvEV,EAAQM,OAAO,cAAe1B,KAAK2B,KAAMN,KAGxDxB,EAAcK,UAAU6B,KAAO,SAAUC,GAGrC,OAFAxC,EAAUU,UAAU6B,KAAKhC,KAAKC,KAAMgC,GACpChC,KAAKiC,MAAMnC,OAASkC,EAAOlC,OACpBE,MAEXH,EAAcK,UAAUgC,OAAS,SAAUC,GACvC,IAAIC,EAAOpC,KAAKqC,YAAYF,GAO5B,OANKC,KACDA,EAAOpC,KAAKsC,eAAeH,IACtBrC,OAASE,KAAKF,OAAOyC,KACtBvC,KAAKwB,SACLY,EAAKZ,OAASxB,KAAKwB,OAAOU,OAAOC,GAAMI,OAExCH,GAEJvC","file":"../../../nodes/inputs/ReflectorNode.js","sourcesContent":["define([\n    '../core/TempNode',\n    '../core/InputNode',\n    '../accessors/PositionNode',\n    '../math/OperatorNode',\n    './TextureNode',\n    './Matrix4Node'\n], function (\n    TempNode, \n    InputNode, \n    PositionNode, \n    OperatorNode, \n    TextureNode, \n    Matrix4Node\n) {\n    'use strict';\n    function ReflectorNode(mirror) {\n        TempNode.call(this, 'v4');\n        if (mirror)\n            this.setMirror(mirror);\n    }\n    ReflectorNode.prototype = Object.create(TempNode.prototype);\n    ReflectorNode.prototype.constructor = ReflectorNode;\n    ReflectorNode.prototype.nodeType = 'Reflector';\n    ReflectorNode.prototype.setMirror = function (mirror) {\n        this.mirror = mirror;\n        this.textureMatrix = new Matrix4Node(this.mirror.material.uniforms.textureMatrix.value);\n        this.localPosition = new PositionNode(PositionNode.LOCAL);\n        this.uv = new OperatorNode(this.textureMatrix, this.localPosition, OperatorNode.MUL);\n        this.uvResult = new OperatorNode(null, this.uv, OperatorNode.ADD);\n        this.texture = new TextureNode(this.mirror.material.uniforms.tDiffuse.value, this.uv, null, true);\n    };\n    ReflectorNode.prototype.generate = function (builder, output) {\n        if (builder.isShader('fragment')) {\n            this.uvResult.a = this.offset;\n            this.texture.uv = this.offset ? this.uvResult : this.uv;\n            if (output === 'sampler2D') {\n                return this.texture.build(builder, output);\n            }\n            return builder.format(this.texture.build(builder, this.type), this.type, output);\n        } else {\n            console.warn('THREE.ReflectorNode is not compatible with ' + builder.shader + ' shader.');\n            return builder.format('vec4( 0.0 )', this.type, output);\n        }\n    };\n    ReflectorNode.prototype.copy = function (source) {\n        InputNode.prototype.copy.call(this, source);\n        this.scope.mirror = source.mirror;\n        return this;\n    };\n    ReflectorNode.prototype.toJSON = function (meta) {\n        var data = this.getJSONNode(meta);\n        if (!data) {\n            data = this.createJSONNode(meta);\n            data.mirror = this.mirror.uuid;\n            if (this.offset)\n                data.offset = this.offset.toJSON(meta).uuid;\n        }\n        return data;\n    };\n    return ReflectorNode;\n});"]}