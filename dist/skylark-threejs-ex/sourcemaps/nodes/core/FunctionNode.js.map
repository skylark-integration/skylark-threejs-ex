{"version":3,"sources":["nodes/core/FunctionNode.js"],"names":["define","TempNode","NodeLib","declarationRegexp","propertiesRegexp","FunctionNode","src","includes","extensions","keywords","type","this","isMethod","undefined","isInterface","call","parse","prototype","Object","create","constructor","nodeType","useKeywords","getShared","getType","builder","getTypeByFormat","getInputByName","name","i","inputs","length","getIncludeByName","generate","output","offset","include","ext","matches","match","exec","push","prop","isGlobal","reference","containsKeyword","node","keyword","getKeywordData","cache","getKeyword","build","substring","index","contains","get","format","qualifier","indexOf","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","JSON","stringify","uuid"],"mappings":"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","file":"../../../nodes/core/FunctionNode.js","sourcesContent":["define([\n    './TempNode',\n    './NodeLib'\n], function (TempNode,NodeLib) {\n    'use strict';\n    var declarationRegexp = /^\\s*([a-z_0-9]+)\\s([a-z_0-9]+)\\s*\\((.*?)\\)/i, propertiesRegexp = /[a-z_0-9]+/ig;\n    function FunctionNode(src, includes, extensions, keywords, type) {\n        this.isMethod = type === undefined;\n        this.isInterface = false;\n        TempNode.call(this, type);\n        this.parse(src, includes, extensions, keywords);\n    }\n    FunctionNode.prototype = Object.create(TempNode.prototype);\n    FunctionNode.prototype.constructor = FunctionNode;\n    FunctionNode.prototype.nodeType = 'Function';\n    FunctionNode.prototype.useKeywords = true;\n    FunctionNode.prototype.getShared = function () {\n        return !this.isMethod;\n    };\n    FunctionNode.prototype.getType = function (builder) {\n        return builder.getTypeByFormat(this.type);\n    };\n    FunctionNode.prototype.getInputByName = function (name) {\n        var i = this.inputs.length;\n        while (i--) {\n            if (this.inputs[i].name === name) {\n                return this.inputs[i];\n            }\n        }\n    };\n    FunctionNode.prototype.getIncludeByName = function (name) {\n        var i = this.includes.length;\n        while (i--) {\n            if (this.includes[i].name === name) {\n                return this.includes[i];\n            }\n        }\n    };\n    FunctionNode.prototype.generate = function (builder, output) {\n        var match, offset = 0, src = this.src;\n        for (var i = 0; i < this.includes.length; i++) {\n            builder.include(this.includes[i], this);\n        }\n        for (var ext in this.extensions) {\n            builder.extensions[ext] = true;\n        }\n        var matches = [];\n        while (match = propertiesRegexp.exec(this.src))\n            matches.push(match);\n        for (var i = 0; i < matches.length; i++) {\n            var match = matches[i];\n            var prop = match[0], isGlobal = this.isMethod ? !this.getInputByName(prop) : true, reference = prop;\n            if (this.keywords[prop] || this.useKeywords && isGlobal && NodeLib.containsKeyword(prop)) {\n                var node = this.keywords[prop];\n                if (!node) {\n                    var keyword = NodeLib.getKeywordData(prop);\n                    if (keyword.cache)\n                        node = builder.keywords[prop];\n                    node = node || NodeLib.getKeyword(prop, builder);\n                    if (keyword.cache)\n                        builder.keywords[prop] = node;\n                }\n                reference = node.build(builder);\n            }\n            if (prop !== reference) {\n                src = src.substring(0, match.index + offset) + reference + src.substring(match.index + prop.length + offset);\n                offset += reference.length - prop.length;\n            }\n            if (this.getIncludeByName(reference) === undefined && NodeLib.contains(reference)) {\n                builder.include(NodeLib.get(reference));\n            }\n        }\n        if (output === 'source') {\n            return src;\n        } else if (this.isMethod) {\n            if (!this.isInterface) {\n                builder.include(this, false, src);\n            }\n            return this.name;\n        } else {\n            return builder.format('( ' + src + ' )', this.getType(builder), output);\n        }\n    };\n    FunctionNode.prototype.parse = function (src, includes, extensions, keywords) {\n        this.src = src || '';\n        this.includes = includes || [];\n        this.extensions = extensions || {};\n        this.keywords = keywords || {};\n        if (this.isMethod) {\n            var match = this.src.match(declarationRegexp);\n            this.inputs = [];\n            if (match && match.length == 4) {\n                this.type = match[1];\n                this.name = match[2];\n                var inputs = match[3].match(propertiesRegexp);\n                if (inputs) {\n                    var i = 0;\n                    while (i < inputs.length) {\n                        var qualifier = inputs[i++];\n                        var type, name;\n                        if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {\n                            type = inputs[i++];\n                        } else {\n                            type = qualifier;\n                            qualifier = '';\n                        }\n                        name = inputs[i++];\n                        this.inputs.push({\n                            name: name,\n                            type: type,\n                            qualifier: qualifier\n                        });\n                    }\n                }\n                this.isInterface = this.src.indexOf('{') === -1;\n            } else {\n                this.type = '';\n                this.name = '';\n            }\n        }\n    };\n    FunctionNode.prototype.copy = function (source) {\n        TempNode.prototype.copy.call(this, source);\n        this.isMethod = source.isMethod;\n        this.useKeywords = source.useKeywords;\n        this.parse(source.src, source.includes, source.extensions, source.keywords);\n        if (source.type !== undefined)\n            this.type = source.type;\n        return this;\n    };\n    FunctionNode.prototype.toJSON = function (meta) {\n        var data = this.getJSONNode(meta);\n        if (!data) {\n            data = this.createJSONNode(meta);\n            data.src = this.src;\n            data.isMethod = this.isMethod;\n            data.useKeywords = this.useKeywords;\n            if (!this.isMethod)\n                data.type = this.type;\n            data.extensions = JSON.parse(JSON.stringify(this.extensions));\n            data.keywords = {};\n            for (var keyword in this.keywords) {\n                data.keywords[keyword] = this.keywords[keyword].toJSON(meta).uuid;\n            }\n            if (this.includes.length) {\n                data.includes = [];\n                for (var i = 0; i < this.includes.length; i++) {\n                    data.includes.push(this.includes[i].toJSON(meta).uuid);\n                }\n            }\n        }\n        return data;\n    };\n    return FunctionNode;\n});"]}