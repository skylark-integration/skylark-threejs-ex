{"version":3,"sources":["nodes/core/FunctionNode.js"],"names":["define","TempNode","NodeLib","declarationRegexp","propertiesRegexp","FunctionNode","src","includes","extensions","keywords","type","this","isMethod","undefined","isInterface","call","parse","prototype","Object","create","constructor","nodeType","useKeywords","getShared","getType","builder","getTypeByFormat","getInputByName","name","i","inputs","length","getIncludeByName","generate","output","offset","include","ext","matches","match","exec","push","prop","isGlobal","reference","containsKeyword","node","keyword","getKeywordData","cache","getKeyword","build","substring","index","contains","get","format","qualifier","indexOf","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","JSON","stringify","uuid"],"mappings":"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","file":"../../../nodes/core/FunctionNode.js","sourcesContent":["define([\r\n    './TempNode',\r\n    './NodeLib'\r\n], function (TempNode,NodeLib) {\r\n    'use strict';\r\n    var declarationRegexp = /^\\s*([a-z_0-9]+)\\s([a-z_0-9]+)\\s*\\((.*?)\\)/i, propertiesRegexp = /[a-z_0-9]+/ig;\r\n    function FunctionNode(src, includes, extensions, keywords, type) {\r\n        this.isMethod = type === undefined;\r\n        this.isInterface = false;\r\n        TempNode.call(this, type);\r\n        this.parse(src, includes, extensions, keywords);\r\n    }\r\n    FunctionNode.prototype = Object.create(TempNode.prototype);\r\n    FunctionNode.prototype.constructor = FunctionNode;\r\n    FunctionNode.prototype.nodeType = 'Function';\r\n    FunctionNode.prototype.useKeywords = true;\r\n    FunctionNode.prototype.getShared = function () {\r\n        return !this.isMethod;\r\n    };\r\n    FunctionNode.prototype.getType = function (builder) {\r\n        return builder.getTypeByFormat(this.type);\r\n    };\r\n    FunctionNode.prototype.getInputByName = function (name) {\r\n        var i = this.inputs.length;\r\n        while (i--) {\r\n            if (this.inputs[i].name === name) {\r\n                return this.inputs[i];\r\n            }\r\n        }\r\n    };\r\n    FunctionNode.prototype.getIncludeByName = function (name) {\r\n        var i = this.includes.length;\r\n        while (i--) {\r\n            if (this.includes[i].name === name) {\r\n                return this.includes[i];\r\n            }\r\n        }\r\n    };\r\n    FunctionNode.prototype.generate = function (builder, output) {\r\n        var match, offset = 0, src = this.src;\r\n        for (var i = 0; i < this.includes.length; i++) {\r\n            builder.include(this.includes[i], this);\r\n        }\r\n        for (var ext in this.extensions) {\r\n            builder.extensions[ext] = true;\r\n        }\r\n        var matches = [];\r\n        while (match = propertiesRegexp.exec(this.src))\r\n            matches.push(match);\r\n        for (var i = 0; i < matches.length; i++) {\r\n            var match = matches[i];\r\n            var prop = match[0], isGlobal = this.isMethod ? !this.getInputByName(prop) : true, reference = prop;\r\n            if (this.keywords[prop] || this.useKeywords && isGlobal && NodeLib.containsKeyword(prop)) {\r\n                var node = this.keywords[prop];\r\n                if (!node) {\r\n                    var keyword = NodeLib.getKeywordData(prop);\r\n                    if (keyword.cache)\r\n                        node = builder.keywords[prop];\r\n                    node = node || NodeLib.getKeyword(prop, builder);\r\n                    if (keyword.cache)\r\n                        builder.keywords[prop] = node;\r\n                }\r\n                reference = node.build(builder);\r\n            }\r\n            if (prop !== reference) {\r\n                src = src.substring(0, match.index + offset) + reference + src.substring(match.index + prop.length + offset);\r\n                offset += reference.length - prop.length;\r\n            }\r\n            if (this.getIncludeByName(reference) === undefined && NodeLib.contains(reference)) {\r\n                builder.include(NodeLib.get(reference));\r\n            }\r\n        }\r\n        if (output === 'source') {\r\n            return src;\r\n        } else if (this.isMethod) {\r\n            if (!this.isInterface) {\r\n                builder.include(this, false, src);\r\n            }\r\n            return this.name;\r\n        } else {\r\n            return builder.format('( ' + src + ' )', this.getType(builder), output);\r\n        }\r\n    };\r\n    FunctionNode.prototype.parse = function (src, includes, extensions, keywords) {\r\n        this.src = src || '';\r\n        this.includes = includes || [];\r\n        this.extensions = extensions || {};\r\n        this.keywords = keywords || {};\r\n        if (this.isMethod) {\r\n            var match = this.src.match(declarationRegexp);\r\n            this.inputs = [];\r\n            if (match && match.length == 4) {\r\n                this.type = match[1];\r\n                this.name = match[2];\r\n                var inputs = match[3].match(propertiesRegexp);\r\n                if (inputs) {\r\n                    var i = 0;\r\n                    while (i < inputs.length) {\r\n                        var qualifier = inputs[i++];\r\n                        var type, name;\r\n                        if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {\r\n                            type = inputs[i++];\r\n                        } else {\r\n                            type = qualifier;\r\n                            qualifier = '';\r\n                        }\r\n                        name = inputs[i++];\r\n                        this.inputs.push({\r\n                            name: name,\r\n                            type: type,\r\n                            qualifier: qualifier\r\n                        });\r\n                    }\r\n                }\r\n                this.isInterface = this.src.indexOf('{') === -1;\r\n            } else {\r\n                this.type = '';\r\n                this.name = '';\r\n            }\r\n        }\r\n    };\r\n    FunctionNode.prototype.copy = function (source) {\r\n        TempNode.prototype.copy.call(this, source);\r\n        this.isMethod = source.isMethod;\r\n        this.useKeywords = source.useKeywords;\r\n        this.parse(source.src, source.includes, source.extensions, source.keywords);\r\n        if (source.type !== undefined)\r\n            this.type = source.type;\r\n        return this;\r\n    };\r\n    FunctionNode.prototype.toJSON = function (meta) {\r\n        var data = this.getJSONNode(meta);\r\n        if (!data) {\r\n            data = this.createJSONNode(meta);\r\n            data.src = this.src;\r\n            data.isMethod = this.isMethod;\r\n            data.useKeywords = this.useKeywords;\r\n            if (!this.isMethod)\r\n                data.type = this.type;\r\n            data.extensions = JSON.parse(JSON.stringify(this.extensions));\r\n            data.keywords = {};\r\n            for (var keyword in this.keywords) {\r\n                data.keywords[keyword] = this.keywords[keyword].toJSON(meta).uuid;\r\n            }\r\n            if (this.includes.length) {\r\n                data.includes = [];\r\n                for (var i = 0; i < this.includes.length; i++) {\r\n                    data.includes.push(this.includes[i].toJSON(meta).uuid);\r\n                }\r\n            }\r\n        }\r\n        return data;\r\n    };\r\n    return FunctionNode;\r\n});"]}