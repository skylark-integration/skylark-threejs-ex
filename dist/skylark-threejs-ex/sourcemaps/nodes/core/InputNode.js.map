{"version":3,"sources":["nodes/core/InputNode.js"],"names":["define","TempNode","InputNode","type","params","shared","undefined","call","this","readonly","prototype","Object","create","constructor","setReadonly","value","getReadonly","copy","source","createJSONNode","meta","data","generate","builder","output","uuid","ns","needsUpdate","getUuid","getType","getNodeData","generateReadonly","isShader","vertex","createVertexUniform","getLabel","format","name","fragment","createFragmentUniform"],"mappings":";;;;;;;AAAAA,QACI,cACD,SAAUC,GACT,aACA,SAASC,EAAUC,EAAMC,IACrBA,EAASA,OACFC,YAA2BC,IAAlBF,EAAOC,QAAuBD,EAAOC,OACrDJ,EAASM,KAAKC,KAAML,EAAMC,GAC1BI,KAAKC,UAAW,EA2CpB,OAzCAP,EAAUQ,UAAYC,OAAOC,OAAOX,EAASS,WAC7CR,EAAUQ,UAAUG,YAAcX,EAClCA,EAAUQ,UAAUI,YAAc,SAAUC,GAExC,OADAP,KAAKC,SAAWM,EACTP,MAEXN,EAAUQ,UAAUM,YAAc,WAC9B,OAAOR,KAAKC,UAEhBP,EAAUQ,UAAUO,KAAO,SAAUC,GAIjC,OAHAjB,EAASS,UAAUO,KAAKV,KAAKC,KAAMU,QACXZ,IAApBY,EAAOT,WACPD,KAAKC,SAAWS,EAAOT,UACpBD,MAEXN,EAAUQ,UAAUS,eAAiB,SAAUC,GAC3C,IAAIC,EAAOpB,EAASS,UAAUS,eAAeZ,KAAKC,KAAMY,GAGxD,OAFsB,IAAlBZ,KAAKC,WACLY,EAAKZ,SAAWD,KAAKC,UAClBY,GAEXnB,EAAUQ,UAAUY,SAAW,SAAUC,EAASC,EAAQC,EAAMtB,EAAMuB,EAAIC,GACtEF,EAAOF,EAAQK,QAAQH,GAAQjB,KAAKoB,WACpCzB,EAAOA,GAAQK,KAAKqB,QAAQN,GAC5B,IAAIF,EAAOE,EAAQO,YAAYL,GAC/B,OADiDjB,KAAKQ,YAAYO,SAAsCjB,IAA1BE,KAAKuB,iBAExEvB,KAAKuB,iBAAiBR,EAASC,EAAQC,EAAMtB,EAAMuB,EAAIC,GAE1DJ,EAAQS,SAAS,WACZX,EAAKY,SACNZ,EAAKY,OAASV,EAAQW,oBAAoB/B,EAAMK,KAAMkB,EAAIC,EAAanB,KAAK2B,aAEzEZ,EAAQa,OAAOf,EAAKY,OAAOI,KAAMlC,EAAMqB,KAEzCH,EAAKiB,WACNjB,EAAKiB,SAAWf,EAAQgB,sBAAsBpC,EAAMK,KAAMkB,EAAIC,EAAanB,KAAK2B,aAE7EZ,EAAQa,OAAOf,EAAKiB,SAASD,KAAMlC,EAAMqB,KAIrDtB","file":"../../../nodes/core/InputNode.js","sourcesContent":["define([\r\n    './TempNode'\r\n], function (TempNode) {\r\n    'use strict';\r\n    function InputNode(type, params) {\r\n        params = params || {};\r\n        params.shared = params.shared !== undefined ? params.shared : false;\r\n        TempNode.call(this, type, params);\r\n        this.readonly = false;\r\n    }\r\n    InputNode.prototype = Object.create(TempNode.prototype);\r\n    InputNode.prototype.constructor = InputNode;\r\n    InputNode.prototype.setReadonly = function (value) {\r\n        this.readonly = value;\r\n        return this;\r\n    };\r\n    InputNode.prototype.getReadonly = function () {\r\n        return this.readonly;\r\n    };\r\n    InputNode.prototype.copy = function (source) {\r\n        TempNode.prototype.copy.call(this, source);\r\n        if (source.readonly !== undefined)\r\n            this.readonly = source.readonly;\r\n        return this;\r\n    };\r\n    InputNode.prototype.createJSONNode = function (meta) {\r\n        var data = TempNode.prototype.createJSONNode.call(this, meta);\r\n        if (this.readonly === true)\r\n            data.readonly = this.readonly;\r\n        return data;\r\n    };\r\n    InputNode.prototype.generate = function (builder, output, uuid, type, ns, needsUpdate) {\r\n        uuid = builder.getUuid(uuid || this.getUuid());\r\n        type = type || this.getType(builder);\r\n        var data = builder.getNodeData(uuid), readonly = this.getReadonly(builder) && this.generateReadonly !== undefined;\r\n        if (readonly) {\r\n            return this.generateReadonly(builder, output, uuid, type, ns, needsUpdate);\r\n        } else {\r\n            if (builder.isShader('vertex')) {\r\n                if (!data.vertex) {\r\n                    data.vertex = builder.createVertexUniform(type, this, ns, needsUpdate, this.getLabel());\r\n                }\r\n                return builder.format(data.vertex.name, type, output);\r\n            } else {\r\n                if (!data.fragment) {\r\n                    data.fragment = builder.createFragmentUniform(type, this, ns, needsUpdate, this.getLabel());\r\n                }\r\n                return builder.format(data.fragment.name, type, output);\r\n            }\r\n        }\r\n    };\r\n    return InputNode;\r\n});"]}