{"version":3,"sources":["nodes/core/NodeBuilder.js"],"names":["define","THREE","NodeUniform","NodeUtils","NodeLib","FunctionNode","ConstNode","StructNode","Vector2Node","Vector3Node","Vector4Node","TextureNode","CubeTextureNode","elements","constructors","convertFormatToType","float","vec2","vec3","vec4","mat4","int","bool","convertTypeToFormat","t","tc","b","i","f","c","v2","v3","v4","m3","m4","NodeBuilder","this","slots","caches","contexts","keywords","nodeData","requires","uv","color","lights","fog","includes","consts","functions","structs","attributes","prefixCode","join","parsCode","vertex","fragment","code","nodeCode","resultCode","finalCode","inputs","uniforms","list","vars","varying","defines","extensions","updaters","nodes","analyzing","prototype","constructor","build","buildShader","length","uvIndex","addVaryCode","addVertexParsCode","addVertexFinalCode","position","worldPosition","normal","worldNormal","shader","node","setShader","setMaterial","material","renderer","mergeDefines","addFlow","slot","cache","context","addSlot","addCache","addContext","removeFlow","removeSlot","removeCache","removeContext","name","push","pop","Object","assign","extra","addVertexCode","addCode","addFragmentCode","addVertexNodeCode","addNodeCode","addFragmentNodeCode","clearNodeCode","clearVertexNodeCode","clearFragmentNodeCode","addFinalCode","addFragmentFinalCode","addParsCode","addFragmentParsCode","isCache","indexOf","isSlot","value","undefined","require","isDefined","getVar","uuid","type","ns","prefix","label","getVars","data","index","getTempVar","getAttribute","getCode","getVarListCode","getIncludesCode","l","nVar","formatType","getFormatByType","Error","getNodeData","isNode","createUniform","needsUpdate","uniform","createVertexUniform","createFragmentUniform","include","parent","source","includesStruct","get","included","deps","src","colorToVectorProperties","replace","colorToVector","getIncludes","sortByPosition","a","sort","getConstructorFromLength","len","isTypeMatrix","format","test","getTypeLength","parseInt","substr","getTypeFromLength","findNode","arguments","nodeCandidate","resolve","isTexture","mapping","CubeReflectionMapping","CubeRefractionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","TextureCubeNode","isVector2","isVector3","isVector4","from","to","getTypeByFormat","getUuid","useCache","getElementByIndex","getIndexByElement","elm","isShader","mergeUniform","getTextureEncodingFromMap","map","encoding","isWebGLRenderTarget","console","warn","texture","LinearEncoding","gamma","GammaEncoding"],"mappings":"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","file":"../../../nodes/core/NodeBuilder.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    './NodeUniform',\n    './NodeUtils',\n    './NodeLib',\n    './FunctionNode',\n    './ConstNode',\n    './StructNode',\n    '../inputs/Vector2Node',\n    '../inputs/Vector3Node',\n    '../inputs/Vector4Node',\n    '../inputs/TextureNode',\n    '../inputs/CubeTextureNode',\n    '../misc/TextureCubeNode'\n], function (\n    THREE, \n    NodeUniform, \n    NodeUtils, \n    NodeLib, \n    FunctionNode, \n    ConstNode, \n    StructNode, \n    Vector2Node, \n    Vector3Node, \n    Vector4Node, \n    TextureNode, \n    CubeTextureNode, \n    TextureNode\n) {\n    'use strict';\n    var elements = NodeUtils.elements, constructors = [\n            'float',\n            'vec2',\n            'vec3',\n            'vec4'\n        ], convertFormatToType = {\n            float: 'f',\n            vec2: 'v2',\n            vec3: 'v3',\n            vec4: 'v4',\n            mat4: 'v4',\n            int: 'i',\n            bool: 'b'\n        }, convertTypeToFormat = {\n            t: 'sampler2D',\n            tc: 'samplerCube',\n            b: 'bool',\n            i: 'int',\n            f: 'float',\n            c: 'vec3',\n            v2: 'vec2',\n            v3: 'vec3',\n            v4: 'vec4',\n            m3: 'mat3',\n            m4: 'mat4'\n        };\n    function NodeBuilder() {\n        this.slots = [];\n        this.caches = [];\n        this.contexts = [];\n        this.keywords = {};\n        this.nodeData = {};\n        this.requires = {\n            uv: [],\n            color: [],\n            lights: false,\n            fog: false\n        };\n        this.includes = {\n            consts: [],\n            functions: [],\n            structs: []\n        };\n        this.attributes = {};\n        this.prefixCode = [\n            '#ifdef TEXTURE_LOD_EXT',\n            '\\t#define texCube(a, b) textureCube(a, b)',\n            '\\t#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)',\n            '\\t#define tex2D(a, b) texture2D(a, b)',\n            '\\t#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)',\n            '#else',\n            '\\t#define texCube(a, b) textureCube(a, b)',\n            '\\t#define texCubeBias(a, b, c) textureCube(a, b, c)',\n            '\\t#define tex2D(a, b) texture2D(a, b)',\n            '\\t#define tex2DBias(a, b, c) texture2D(a, b, c)',\n            '#endif',\n            '#include <packing>',\n            '#include <common>'\n        ].join('\\n');\n        this.parsCode = {\n            vertex: '',\n            fragment: ''\n        };\n        this.code = {\n            vertex: '',\n            fragment: ''\n        };\n        this.nodeCode = {\n            vertex: '',\n            fragment: ''\n        };\n        this.resultCode = {\n            vertex: '',\n            fragment: ''\n        };\n        this.finalCode = {\n            vertex: '',\n            fragment: ''\n        };\n        this.inputs = {\n            uniforms: {\n                list: [],\n                vertex: [],\n                fragment: []\n            },\n            vars: {\n                varying: [],\n                vertex: [],\n                fragment: []\n            }\n        };\n        this.defines = {};\n        this.uniforms = {};\n        this.extensions = {};\n        this.updaters = [];\n        this.nodes = [];\n        this.analyzing = false;\n    }\n    NodeBuilder.prototype = {\n        constructor: NodeBuilder,\n        build: function (vertex, fragment) {\n            this.buildShader('vertex', vertex);\n            this.buildShader('fragment', fragment);\n            for (var i = 0; i < this.requires.uv.length; i++) {\n                if (this.requires.uv[i]) {\n                    var uvIndex = i > 0 ? i + 1 : '';\n                    this.addVaryCode('varying vec2 vUv' + uvIndex + ';');\n                    if (i > 0) {\n                        this.addVertexParsCode('attribute vec2 uv' + uvIndex + ';');\n                    }\n                    this.addVertexFinalCode('vUv' + uvIndex + ' = uv' + uvIndex + ';');\n                }\n            }\n            if (this.requires.color[0]) {\n                this.addVaryCode('varying vec4 vColor;');\n                this.addVertexParsCode('attribute vec4 color;');\n                this.addVertexFinalCode('vColor = color;');\n            }\n            if (this.requires.color[1]) {\n                this.addVaryCode('varying vec4 vColor2;');\n                this.addVertexParsCode('attribute vec4 color2;');\n                this.addVertexFinalCode('vColor2 = color2;');\n            }\n            if (this.requires.position) {\n                this.addVaryCode('varying vec3 vPosition;');\n                this.addVertexFinalCode('vPosition = transformed;');\n            }\n            if (this.requires.worldPosition) {\n                this.addVaryCode('varying vec3 vWPosition;');\n                this.addVertexFinalCode('vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;');\n            }\n            if (this.requires.normal) {\n                this.addVaryCode('varying vec3 vObjectNormal;');\n                this.addVertexFinalCode('vObjectNormal = normal;');\n            }\n            if (this.requires.worldNormal) {\n                this.addVaryCode('varying vec3 vWNormal;');\n                this.addVertexFinalCode('vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;');\n            }\n            return this;\n        },\n        buildShader: function (shader, node) {\n            this.resultCode[shader] = node.build(this.setShader(shader), 'v4');\n        },\n        setMaterial: function (material, renderer) {\n            this.material = material;\n            this.renderer = renderer;\n            this.requires.lights = material.lights;\n            this.requires.fog = material.fog;\n            this.mergeDefines(material.defines);\n            return this;\n        },\n        addFlow: function (slot, cache, context) {\n            return this.addSlot(slot).addCache(cache).addContext(context);\n        },\n        removeFlow: function () {\n            return this.removeSlot().removeCache().removeContext();\n        },\n        addCache: function (name) {\n            this.cache = name || '';\n            this.caches.push(this.cache);\n            return this;\n        },\n        removeCache: function () {\n            this.caches.pop();\n            this.cache = this.caches[this.caches.length - 1] || '';\n            return this;\n        },\n        addContext: function (context) {\n            this.context = Object.assign({}, this.context, context);\n            this.context.extra = this.context.extra || {};\n            this.contexts.push(this.context);\n            return this;\n        },\n        removeContext: function () {\n            this.contexts.pop();\n            this.context = this.contexts[this.contexts.length - 1] || {};\n            return this;\n        },\n        addSlot: function (name) {\n            this.slot = name || '';\n            this.slots.push(this.slot);\n            return this;\n        },\n        removeSlot: function () {\n            this.slots.pop();\n            this.slot = this.slots[this.slots.length - 1] || '';\n            return this;\n        },\n        addVertexCode: function (code) {\n            this.addCode(code, 'vertex');\n        },\n        addFragmentCode: function (code) {\n            this.addCode(code, 'fragment');\n        },\n        addCode: function (code, shader) {\n            this.code[shader || this.shader] += code + '\\n';\n        },\n        addVertexNodeCode: function (code) {\n            this.addNodeCode(code, 'vertex');\n        },\n        addFragmentNodeCode: function (code) {\n            this.addNodeCode(code, 'fragment');\n        },\n        addNodeCode: function (code, shader) {\n            this.nodeCode[shader || this.shader] += code + '\\n';\n        },\n        clearNodeCode: function (shader) {\n            shader = shader || this.shader;\n            var code = this.nodeCode[shader];\n            this.nodeCode[shader] = '';\n            return code;\n        },\n        clearVertexNodeCode: function () {\n            return this.clearNodeCode('vertex');\n        },\n        clearFragmentNodeCode: function () {\n            return this.clearNodeCode('fragment');\n        },\n        addVertexFinalCode: function (code) {\n            this.addFinalCode(code, 'vertex');\n        },\n        addFragmentFinalCode: function (code) {\n            this.addFinalCode(code, 'fragment');\n        },\n        addFinalCode: function (code, shader) {\n            this.finalCode[shader || this.shader] += code + '\\n';\n        },\n        addVertexParsCode: function (code) {\n            this.addParsCode(code, 'vertex');\n        },\n        addFragmentParsCode: function (code) {\n            this.addParsCode(code, 'fragment');\n        },\n        addParsCode: function (code, shader) {\n            this.parsCode[shader || this.shader] += code + '\\n';\n        },\n        addVaryCode: function (code) {\n            this.addVertexParsCode(code);\n            this.addFragmentParsCode(code);\n        },\n        isCache: function (name) {\n            return this.caches.indexOf(name) !== -1;\n        },\n        isSlot: function (name) {\n            return this.slots.indexOf(name) !== -1;\n        },\n        define: function (name, value) {\n            this.defines[name] = value === undefined ? 1 : value;\n        },\n        require: function (name) {\n            this.requires[name] = true;\n        },\n        isDefined: function (name) {\n            return this.defines[name] !== undefined;\n        },\n        getVar: function (uuid, type, ns, shader = 'varying', prefix = 'V', label = '') {\n            var vars = this.getVars(shader), data = vars[uuid];\n            if (!data) {\n                var index = vars.length, name = ns ? ns : 'node' + prefix + index + (label ? '_' + label : '');\n                data = {\n                    name: name,\n                    type: type\n                };\n                vars.push(data);\n                vars[uuid] = data;\n            }\n            return data;\n        },\n        getTempVar: function (uuid, type, ns, label) {\n            return this.getVar(uuid, type, ns, this.shader, 'T', label);\n        },\n        getAttribute: function (name, type) {\n            if (!this.attributes[name]) {\n                var varying = this.getVar(name, type);\n                this.addVertexParsCode('attribute ' + type + ' ' + name + ';');\n                this.addVertexFinalCode(varying.name + ' = ' + name + ';');\n                this.attributes[name] = {\n                    varying: varying,\n                    name: name,\n                    type: type\n                };\n            }\n            return this.attributes[name];\n        },\n        getCode: function (shader) {\n            return [\n                this.prefixCode,\n                this.parsCode[shader],\n                this.getVarListCode(this.getVars('varying'), 'varying'),\n                this.getVarListCode(this.inputs.uniforms[shader], 'uniform'),\n                this.getIncludesCode('consts', shader),\n                this.getIncludesCode('structs', shader),\n                this.getIncludesCode('functions', shader),\n                'void main() {',\n                this.getVarListCode(this.getVars(shader)),\n                this.code[shader],\n                this.resultCode[shader],\n                this.finalCode[shader],\n                '}'\n            ].join('\\n');\n        },\n        getVarListCode: function (vars, prefix) {\n            prefix = prefix || '';\n            var code = '';\n            for (var i = 0, l = vars.length; i < l; ++i) {\n                var nVar = vars[i], type = nVar.type, name = nVar.name;\n                var formatType = this.getFormatByType(type);\n                if (formatType === undefined) {\n                    throw new Error('Node pars ' + formatType + ' not found.');\n                }\n                code += prefix + ' ' + formatType + ' ' + name + ';\\n';\n            }\n            return code;\n        },\n        getVars: function (shader) {\n            return this.inputs.vars[shader || this.shader];\n        },\n        getNodeData: function (node) {\n            var uuid = node.isNode ? node.uuid : node;\n            return this.nodeData[uuid] = this.nodeData[uuid] || {};\n        },\n        createUniform: function (shader, type, node, ns, needsUpdate, label) {\n            var uniforms = this.inputs.uniforms, index = uniforms.list.length;\n            var uniform = new NodeUniform({\n                type: type,\n                name: ns ? ns : 'nodeU' + index + (label ? '_' + label : ''),\n                node: node,\n                needsUpdate: needsUpdate\n            });\n            uniforms.list.push(uniform);\n            uniforms[shader].push(uniform);\n            uniforms[shader][uniform.name] = uniform;\n            this.uniforms[uniform.name] = uniform;\n            return uniform;\n        },\n        createVertexUniform: function (type, node, ns, needsUpdate, label) {\n            return this.createUniform('vertex', type, node, ns, needsUpdate, label);\n        },\n        createFragmentUniform: function (type, node, ns, needsUpdate, label) {\n            return this.createUniform('fragment', type, node, ns, needsUpdate, label);\n        },\n        include: function (node, parent, source) {\n            var includesStruct;\n            node = typeof node === 'string' ? NodeLib.get(node) : node;\n            if (this.context.include === false) {\n                return node.name;\n            }\n            if (node instanceof FunctionNode) {\n                includesStruct = this.includes.functions;\n            } else if (node instanceof ConstNode) {\n                includesStruct = this.includes.consts;\n            } else if (node instanceof StructNode) {\n                includesStruct = this.includes.structs;\n            }\n            var includes = includesStruct[this.shader] = includesStruct[this.shader] || [];\n            if (node) {\n                var included = includes[node.name];\n                if (!included) {\n                    included = includes[node.name] = {\n                        node: node,\n                        deps: []\n                    };\n                    includes.push(included);\n                    included.src = node.build(this, 'source');\n                }\n                if (node instanceof FunctionNode && parent && includes[parent.name] && includes[parent.name].deps.indexOf(node) == -1) {\n                    includes[parent.name].deps.push(node);\n                    if (node.includes && node.includes.length) {\n                        var i = 0;\n                        do {\n                            this.include(node.includes[i++], parent);\n                        } while (i < node.includes.length);\n                    }\n                }\n                if (source) {\n                    included.src = source;\n                }\n                return node.name;\n            } else {\n                throw new Error('Include not found.');\n            }\n        },\n        colorToVectorProperties: function (color) {\n            return color.replace('r', 'x').replace('g', 'y').replace('b', 'z').replace('a', 'w');\n        },\n        colorToVector: function (color) {\n            return color.replace(/c/g, 'v3');\n        },\n        getIncludes: function (type, shader) {\n            return this.includes[type][shader || this.shader];\n        },\n        getIncludesCode: function () {\n            function sortByPosition(a, b) {\n                return a.deps.length - b.deps.length;\n            }\n            return function getIncludesCode(type, shader) {\n                var includes = this.getIncludes(type, shader);\n                if (!includes)\n                    return '';\n                var code = '', includes = includes.sort(sortByPosition);\n                for (var i = 0; i < includes.length; i++) {\n                    if (includes[i].src)\n                        code += includes[i].src + '\\n';\n                }\n                return code;\n            };\n        }(),\n        getConstructorFromLength: function (len) {\n            return constructors[len - 1];\n        },\n        isTypeMatrix: function (format) {\n            return /^m/.test(format);\n        },\n        getTypeLength: function (type) {\n            if (type === 'f')\n                return 1;\n            return parseInt(this.colorToVector(type).substr(1));\n        },\n        getTypeFromLength: function (len) {\n            if (len === 1)\n                return 'f';\n            return 'v' + len;\n        },\n        findNode: function () {\n            for (var i = 0; i < arguments.length; i++) {\n                var nodeCandidate = arguments[i];\n                if (nodeCandidate !== undefined && nodeCandidate.isNode) {\n                    return nodeCandidate;\n                }\n            }\n        },\n        resolve: function () {\n            for (var i = 0; i < arguments.length; i++) {\n                var nodeCandidate = arguments[i];\n                if (nodeCandidate !== undefined) {\n                    if (nodeCandidate.isNode) {\n                        return nodeCandidate;\n                    } else if (nodeCandidate.isTexture) {\n                        switch (nodeCandidate.mapping) {\n                        case THREE.CubeReflectionMapping:\n                        case THREE.CubeRefractionMapping:\n                            return new CubeTextureNode(nodeCandidate);\n                            break;\n                        case THREE.CubeUVReflectionMapping:\n                        case THREE.CubeUVRefractionMapping:\n                            return new TextureCubeNode(new TextureNode(nodeCandidate));\n                            break;\n                        default:\n                            return new TextureNode(nodeCandidate);\n                        }\n                    } else if (nodeCandidate.isVector2) {\n                        return new Vector2Node(nodeCandidate);\n                    } else if (nodeCandidate.isVector3) {\n                        return new Vector3Node(nodeCandidate);\n                    } else if (nodeCandidate.isVector4) {\n                        return new Vector4Node(nodeCandidate);\n                    }\n                }\n            }\n        },\n        format: function (code, from, to) {\n            var typeToType = this.colorToVector(to + ' <- ' + from);\n            switch (typeToType) {\n            case 'f <- v2':\n                return code + '.x';\n            case 'f <- v3':\n                return code + '.x';\n            case 'f <- v4':\n                return code + '.x';\n            case 'f <- i':\n            case 'f <- b':\n                return 'float( ' + code + ' )';\n            case 'v2 <- f':\n                return 'vec2( ' + code + ' )';\n            case 'v2 <- v3':\n                return code + '.xy';\n            case 'v2 <- v4':\n                return code + '.xy';\n            case 'v2 <- i':\n            case 'v2 <- b':\n                return 'vec2( float( ' + code + ' ) )';\n            case 'v3 <- f':\n                return 'vec3( ' + code + ' )';\n            case 'v3 <- v2':\n                return 'vec3( ' + code + ', 0.0 )';\n            case 'v3 <- v4':\n                return code + '.xyz';\n            case 'v3 <- i':\n            case 'v3 <- b':\n                return 'vec2( float( ' + code + ' ) )';\n            case 'v4 <- f':\n                return 'vec4( ' + code + ' )';\n            case 'v4 <- v2':\n                return 'vec4( ' + code + ', 0.0, 1.0 )';\n            case 'v4 <- v3':\n                return 'vec4( ' + code + ', 1.0 )';\n            case 'v4 <- i':\n            case 'v4 <- b':\n                return 'vec4( float( ' + code + ' ) )';\n            case 'i <- f':\n            case 'i <- b':\n                return 'int( ' + code + ' )';\n            case 'i <- v2':\n                return 'int( ' + code + '.x )';\n            case 'i <- v3':\n                return 'int( ' + code + '.x )';\n            case 'i <- v4':\n                return 'int( ' + code + '.x )';\n            case 'b <- f':\n                return '( ' + code + ' != 0.0 )';\n            case 'b <- v2':\n                return '( ' + code + ' != vec2( 0.0 ) )';\n            case 'b <- v3':\n                return '( ' + code + ' != vec3( 0.0 ) )';\n            case 'b <- v4':\n                return '( ' + code + ' != vec4( 0.0 ) )';\n            case 'b <- i':\n                return '( ' + code + ' != 0 )';\n            }\n            return code;\n        },\n        getTypeByFormat: function (format) {\n            return convertFormatToType[format] || format;\n        },\n        getFormatByType: function (type) {\n            return convertTypeToFormat[type] || type;\n        },\n        getUuid: function (uuid, useCache) {\n            useCache = useCache !== undefined ? useCache : true;\n            if (useCache && this.cache)\n                uuid = this.cache + '-' + uuid;\n            return uuid;\n        },\n        getElementByIndex: function (index) {\n            return elements[index];\n        },\n        getIndexByElement: function (elm) {\n            return elements.indexOf(elm);\n        },\n        isShader: function (shader) {\n            return this.shader === shader;\n        },\n        setShader: function (shader) {\n            this.shader = shader;\n            return this;\n        },\n        mergeDefines: function (defines) {\n            for (var name in defines) {\n                this.defines[name] = defines[name];\n            }\n            return this.defines;\n        },\n        mergeUniform: function (uniforms) {\n            for (var name in uniforms) {\n                this.uniforms[name] = uniforms[name];\n            }\n            return this.uniforms;\n        },\n        getTextureEncodingFromMap: function (map) {\n            var encoding;\n            if (!map) {\n                encoding = THREE.LinearEncoding;\n            } else if (map.isTexture) {\n                encoding = map.encoding;\n            } else if (map.isWebGLRenderTarget) {\n                console.warn(\"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\");\n                encoding = map.texture.encoding;\n            }\n            if (encoding === THREE.LinearEncoding && this.context.gamma) {\n                encoding = THREE.GammaEncoding;\n            }\n            return encoding;\n        }\n    };\n    return NodeBuilder;\n});"]}