{"version":3,"sources":["nodes/misc/NormalMapNode.js"],"names":["define","THREE","TempNode","Vector2Node","FunctionNode","UVNode","NormalNode","PositionNode","NormalMapNode","value","scale","call","this","Nodes","perturbNormal2Arb","derivatives","prototype","Object","create","constructor","nodeType","generate","builder","output","isShader","include","normal","position","VIEW","uv","build","material","side","BackSide","format","getType","console","warn","shader","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":";;;;;;;AAAAA,QACI,kBACA,mBACA,wBACA,uBACA,sBACA,0BACA,6BACD,SACCC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,aACA,SAASC,EAAcC,EAAOC,GAC1BR,EAASS,KAAKC,KAAM,MACpBA,KAAKH,MAAQA,EACbG,KAAKF,MAAQA,GAAS,IAAIP,EAAY,EAAG,GA0E7C,OAxEAK,EAAcK,OAoCDC,kBAnCe,IAAIV,EAAa,qiCAkC5C,MAAQW,aAAa,KAGtBP,EAAcQ,UAAYC,OAAOC,OAAOhB,EAASc,WACjDR,EAAcQ,UAAUG,YAAcX,EACtCA,EAAcQ,UAAUI,SAAW,YACnCZ,EAAcQ,UAAUK,SAAW,SAAUC,EAASC,GAClD,GAAID,EAAQE,SAAS,YAAa,CAC9B,IAAIV,EAAoBQ,EAAQG,QAAQjB,EAAcK,MAAMC,mBAC5DF,KAAKc,OAASd,KAAKc,QAAU,IAAIpB,EACjCM,KAAKe,SAAWf,KAAKe,UAAY,IAAIpB,EAAaA,EAAaqB,MAC/DhB,KAAKiB,GAAKjB,KAAKiB,IAAM,IAAIxB,EACzB,IAAIK,EAAQE,KAAKF,MAAMoB,MAAMR,EAAS,MAItC,OAHIA,EAAQS,SAASC,OAAS/B,EAAMgC,WAChCvB,EAAQ,IAAMA,GAEXY,EAAQY,OAAOpB,EAAoB,MAAQF,KAAKe,SAASG,MAAMR,EAAS,MAAQ,KAAOV,KAAKc,OAAOI,MAAMR,EAAS,MAAQ,KAAOV,KAAKH,MAAMqB,MAAMR,EAAS,MAAQ,KAAOV,KAAKiB,GAAGC,MAAMR,EAAS,MAAQ,KAAOZ,EAAQ,KAAME,KAAKuB,QAAQb,GAAUC,GAG5P,OADAa,QAAQC,KAAK,8CAAgDf,EAAQgB,OAAS,YACvEhB,EAAQY,OAAO,cAAetB,KAAKuB,QAAQb,GAAUC,IAGpEf,EAAcQ,UAAUuB,KAAO,SAAUC,GAIrC,OAHAtC,EAASc,UAAUuB,KAAK5B,KAAKC,KAAM4B,GACnC5B,KAAKH,MAAQ+B,EAAO/B,MACpBG,KAAKF,MAAQ8B,EAAO9B,MACbE,MAEXJ,EAAcQ,UAAUyB,OAAS,SAAUC,GACvC,IAAIC,EAAO/B,KAAKgC,YAAYF,GAM5B,OALKC,KACDA,EAAO/B,KAAKiC,eAAeH,IACtBjC,MAAQG,KAAKH,MAAMgC,OAAOC,GAAMI,KACrCH,EAAKjC,MAAQE,KAAKF,MAAM+B,OAAOC,GAAMI,MAElCH,GAEJnC","file":"../../../nodes/misc/NormalMapNode.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    '../core/TempNode',\r\n    '../inputs/Vector2Node',\r\n    '../core/FunctionNode',\r\n    '../accessors/UVNode',\r\n    '../accessors/NormalNode',\r\n    '../accessors/PositionNode'\r\n], function (\r\n    THREE, \r\n    TempNode, \r\n    Vector2Node, \r\n    FunctionNode, \r\n    UVNode, \r\n    NormalNode, \r\n    PositionNode\r\n) {\r\n    'use strict';\r\n    function NormalMapNode(value, scale) {\r\n        TempNode.call(this, 'v3');\r\n        this.value = value;\r\n        this.scale = scale || new Vector2Node(1, 1);\r\n    }\r\n    NormalMapNode.Nodes = function () {\r\n        var perturbNormal2Arb = new FunctionNode(`vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 map, vec2 vUv, vec2 normalScale ) {\r\n\r\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\r\n\r\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\r\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\r\n\t\tvec2 st0 = dFdx( vUv.st );\r\n\t\tvec2 st1 = dFdy( vUv.st );\r\n\r\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\r\n\r\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\r\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\r\n\t\tvec3 N = normalize( surf_norm );\r\n\r\n\t\tvec3 mapN = map * 2.0 - 1.0;\r\n\r\n\t\tmapN.xy *= normalScale;\r\n\r\n\t\t#ifdef DOUBLE_SIDED\r\n\r\n\t\t\t// Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\r\n\r\n\t\t\tif ( dot( cross( S, T ), N ) < 0.0 ) mapN.xy *= - 1.0;\r\n\r\n\t\t#else\r\n\r\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\r\n\r\n\t\t#endif\r\n\r\n\t\tmat3 tsn = mat3( S, T, N );\r\n\t\treturn normalize( tsn * mapN );\r\n\r\n\t}`, null, { derivatives: true });\r\n        return { perturbNormal2Arb: perturbNormal2Arb };\r\n    }();\r\n    NormalMapNode.prototype = Object.create(TempNode.prototype);\r\n    NormalMapNode.prototype.constructor = NormalMapNode;\r\n    NormalMapNode.prototype.nodeType = 'NormalMap';\r\n    NormalMapNode.prototype.generate = function (builder, output) {\r\n        if (builder.isShader('fragment')) {\r\n            var perturbNormal2Arb = builder.include(NormalMapNode.Nodes.perturbNormal2Arb);\r\n            this.normal = this.normal || new NormalNode();\r\n            this.position = this.position || new PositionNode(PositionNode.VIEW);\r\n            this.uv = this.uv || new UVNode();\r\n            var scale = this.scale.build(builder, 'v2');\r\n            if (builder.material.side === THREE.BackSide) {\r\n                scale = '-' + scale;\r\n            }\r\n            return builder.format(perturbNormal2Arb + '( -' + this.position.build(builder, 'v3') + ', ' + this.normal.build(builder, 'v3') + ', ' + this.value.build(builder, 'v3') + ', ' + this.uv.build(builder, 'v2') + ', ' + scale + ' )', this.getType(builder), output);\r\n        } else {\r\n            console.warn('THREE.NormalMapNode is not compatible with ' + builder.shader + ' shader.');\r\n            return builder.format('vec3( 0.0 )', this.getType(builder), output);\r\n        }\r\n    };\r\n    NormalMapNode.prototype.copy = function (source) {\r\n        TempNode.prototype.copy.call(this, source);\r\n        this.value = source.value;\r\n        this.scale = source.scale;\r\n        return this;\r\n    };\r\n    NormalMapNode.prototype.toJSON = function (meta) {\r\n        var data = this.getJSONNode(meta);\r\n        if (!data) {\r\n            data = this.createJSONNode(meta);\r\n            data.value = this.value.toJSON(meta).uuid;\r\n            data.scale = this.scale.toJSON(meta).uuid;\r\n        }\r\n        return data;\r\n    };\r\n    return NormalMapNode;\r\n});"]}