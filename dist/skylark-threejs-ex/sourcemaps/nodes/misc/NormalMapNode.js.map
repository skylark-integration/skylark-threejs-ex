{"version":3,"sources":["nodes/misc/NormalMapNode.js"],"names":["define","THREE","TempNode","Vector2Node","FunctionNode","UVNode","NormalNode","PositionNode","NormalMapNode","value","scale","call","this","Nodes","perturbNormal2Arb","derivatives","prototype","Object","create","constructor","nodeType","generate","builder","output","isShader","include","normal","position","VIEW","uv","build","material","side","BackSide","format","getType","console","warn","shader","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":";;;;;;;AAAAA,QACI,kBACA,mBACA,wBACA,uBACA,sBACA,0BACA,6BACD,SACCC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,aACA,SAASC,EAAcC,EAAOC,GAC1BR,EAASS,KAAKC,KAAM,MACpBA,KAAKH,MAAQA,EACbG,KAAKF,MAAQA,GAAS,IAAIP,EAAY,EAAG,GA0E7C,OAxEAK,EAAcK,OAoCDC,kBAnCe,IAAIV,EAAa,qiCAkC5C,MAAQW,aAAa,KAGtBP,EAAcQ,UAAYC,OAAOC,OAAOhB,EAASc,WACjDR,EAAcQ,UAAUG,YAAcX,EACtCA,EAAcQ,UAAUI,SAAW,YACnCZ,EAAcQ,UAAUK,SAAW,SAAUC,EAASC,GAClD,GAAID,EAAQE,SAAS,YAAa,CAC9B,IAAIV,EAAoBQ,EAAQG,QAAQjB,EAAcK,MAAMC,mBAC5DF,KAAKc,OAASd,KAAKc,QAAU,IAAIpB,EACjCM,KAAKe,SAAWf,KAAKe,UAAY,IAAIpB,EAAaA,EAAaqB,MAC/DhB,KAAKiB,GAAKjB,KAAKiB,IAAM,IAAIxB,EACzB,IAAIK,EAAQE,KAAKF,MAAMoB,MAAMR,EAAS,MAItC,OAHIA,EAAQS,SAASC,OAAS/B,EAAMgC,WAChCvB,EAAQ,IAAMA,GAEXY,EAAQY,OAAOpB,EAAoB,MAAQF,KAAKe,SAASG,MAAMR,EAAS,MAAQ,KAAOV,KAAKc,OAAOI,MAAMR,EAAS,MAAQ,KAAOV,KAAKH,MAAMqB,MAAMR,EAAS,MAAQ,KAAOV,KAAKiB,GAAGC,MAAMR,EAAS,MAAQ,KAAOZ,EAAQ,KAAME,KAAKuB,QAAQb,GAAUC,GAG5P,OADAa,QAAQC,KAAK,8CAAgDf,EAAQgB,OAAS,YACvEhB,EAAQY,OAAO,cAAetB,KAAKuB,QAAQb,GAAUC,IAGpEf,EAAcQ,UAAUuB,KAAO,SAAUC,GAIrC,OAHAtC,EAASc,UAAUuB,KAAK5B,KAAKC,KAAM4B,GACnC5B,KAAKH,MAAQ+B,EAAO/B,MACpBG,KAAKF,MAAQ8B,EAAO9B,MACbE,MAEXJ,EAAcQ,UAAUyB,OAAS,SAAUC,GACvC,IAAIC,EAAO/B,KAAKgC,YAAYF,GAM5B,OALKC,KACDA,EAAO/B,KAAKiC,eAAeH,IACtBjC,MAAQG,KAAKH,MAAMgC,OAAOC,GAAMI,KACrCH,EAAKjC,MAAQE,KAAKF,MAAM+B,OAAOC,GAAMI,MAElCH,GAEJnC","file":"../../../nodes/misc/NormalMapNode.js","sourcesContent":["define([\n    \"skylark-threejs\",\n    '../core/TempNode',\n    '../inputs/Vector2Node',\n    '../core/FunctionNode',\n    '../accessors/UVNode',\n    '../accessors/NormalNode',\n    '../accessors/PositionNode'\n], function (\n    THREE, \n    TempNode, \n    Vector2Node, \n    FunctionNode, \n    UVNode, \n    NormalNode, \n    PositionNode\n) {\n    'use strict';\n    function NormalMapNode(value, scale) {\n        TempNode.call(this, 'v3');\n        this.value = value;\n        this.scale = scale || new Vector2Node(1, 1);\n    }\n    NormalMapNode.Nodes = function () {\n        var perturbNormal2Arb = new FunctionNode(`vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 map, vec2 vUv, vec2 normalScale ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tvec3 mapN = map * 2.0 - 1.0;\n\n\t\tmapN.xy *= normalScale;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t// Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\n\n\t\t\tif ( dot( cross( S, T ), N ) < 0.0 ) mapN.xy *= - 1.0;\n\n\t\t#else\n\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t#endif\n\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\n\t}`, null, { derivatives: true });\n        return { perturbNormal2Arb: perturbNormal2Arb };\n    }();\n    NormalMapNode.prototype = Object.create(TempNode.prototype);\n    NormalMapNode.prototype.constructor = NormalMapNode;\n    NormalMapNode.prototype.nodeType = 'NormalMap';\n    NormalMapNode.prototype.generate = function (builder, output) {\n        if (builder.isShader('fragment')) {\n            var perturbNormal2Arb = builder.include(NormalMapNode.Nodes.perturbNormal2Arb);\n            this.normal = this.normal || new NormalNode();\n            this.position = this.position || new PositionNode(PositionNode.VIEW);\n            this.uv = this.uv || new UVNode();\n            var scale = this.scale.build(builder, 'v2');\n            if (builder.material.side === THREE.BackSide) {\n                scale = '-' + scale;\n            }\n            return builder.format(perturbNormal2Arb + '( -' + this.position.build(builder, 'v3') + ', ' + this.normal.build(builder, 'v3') + ', ' + this.value.build(builder, 'v3') + ', ' + this.uv.build(builder, 'v2') + ', ' + scale + ' )', this.getType(builder), output);\n        } else {\n            console.warn('THREE.NormalMapNode is not compatible with ' + builder.shader + ' shader.');\n            return builder.format('vec3( 0.0 )', this.getType(builder), output);\n        }\n    };\n    NormalMapNode.prototype.copy = function (source) {\n        TempNode.prototype.copy.call(this, source);\n        this.value = source.value;\n        this.scale = source.scale;\n        return this;\n    };\n    NormalMapNode.prototype.toJSON = function (meta) {\n        var data = this.getJSONNode(meta);\n        if (!data) {\n            data = this.createJSONNode(meta);\n            data.value = this.value.toJSON(meta).uuid;\n            data.scale = this.scale.toJSON(meta).uuid;\n        }\n        return data;\n    };\n    return NormalMapNode;\n});"]}