{"version":3,"sources":["nodes/misc/TextureCubeNode.js"],"names":["define","TempNode","FloatNode","TextureCubeNode","ReflectNode","NormalNode","value","uv","bias","call","this","radianceNode","TextureCubeUVNode","VECTOR","irradianceNode","WORLD","setReadonly","prototype","Object","create","constructor","nodeType","generate","builder","output","isShader","require","context","setTexture","slot","build","console","warn","shader","format","getType","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":";;;;;;;AAAAA,QACI,mBACA,sBACA,sBACA,2BACA,2BACD,SACCC,EACAC,EACAC,EACAC,EACAC,GAEA,aACA,SAASF,EAAgBG,EAAOC,EAAIC,GAChCP,EAASQ,KAAKC,KAAM,MACpBA,KAAKJ,MAAQA,EACbI,KAAKC,aAAe,IAAIC,kBAAkBF,KAAKJ,MAAOC,GAAM,IAAIH,EAAYA,EAAYS,QAASL,GACjGE,KAAKI,eAAiB,IAAIF,kBAAkBF,KAAKJ,MAAO,IAAID,EAAWA,EAAWU,OAAQ,IAAIb,EAAU,GAAGc,aAAY,IA+B3H,OA7BAb,EAAgBc,UAAYC,OAAOC,OAAOlB,EAASgB,WACnDd,EAAgBc,UAAUG,YAAcjB,EACxCA,EAAgBc,UAAUI,SAAW,cACrClB,EAAgBc,UAAUK,SAAW,SAAUC,EAASC,GACpD,OAAID,EAAQE,SAAS,aACjBF,EAAQG,QAAQ,cACZH,EAAQI,QAAQnB,MAChBe,EAAQI,QAAQnB,KAAKoB,WAAWlB,KAAKJ,QAER,eAAjBiB,EAAQM,KAAwBnB,KAAKI,eAAiBJ,KAAKC,cAC1DmB,MAAMP,EAASC,KAEhCO,QAAQC,KAAK,gDAAkDT,EAAQU,OAAS,YACzEV,EAAQW,OAAO,cAAexB,KAAKyB,QAAQZ,GAAUC,KAGpErB,EAAgBc,UAAUmB,KAAO,SAAUC,GAGvC,OAFApC,EAASgB,UAAUmB,KAAK3B,KAAKC,KAAM2B,GACnC3B,KAAKJ,MAAQ+B,EAAO/B,MACbI,MAEXP,EAAgBc,UAAUqB,OAAS,SAAUC,GACzC,IAAIC,EAAO9B,KAAK+B,YAAYF,GAK5B,OAJKC,KACDA,EAAO9B,KAAKgC,eAAeH,IACtBjC,MAAQI,KAAKJ,MAAMgC,OAAOC,GAAMI,MAElCH,GAEJrC","file":"../../../nodes/misc/TextureCubeNode.js","sourcesContent":["define([\r\n    '../core/TempNode',\r\n    '../inputs/FloatNode',\r\n    './TextureCubeUVNode',\r\n    '../accessors/ReflectNode',\r\n    '../accessors/NormalNode'\r\n], function (\r\n    TempNode, \r\n    FloatNode, \r\n    TextureCubeNode, \r\n    ReflectNode, \r\n    NormalNode\r\n) {\r\n    'use strict';\r\n    function TextureCubeNode(value, uv, bias) {\r\n        TempNode.call(this, 'v4');\r\n        this.value = value;\r\n        this.radianceNode = new TextureCubeUVNode(this.value, uv || new ReflectNode(ReflectNode.VECTOR), bias);\r\n        this.irradianceNode = new TextureCubeUVNode(this.value, new NormalNode(NormalNode.WORLD), new FloatNode(1).setReadonly(true));\r\n    }\r\n    TextureCubeNode.prototype = Object.create(TempNode.prototype);\r\n    TextureCubeNode.prototype.constructor = TextureCubeNode;\r\n    TextureCubeNode.prototype.nodeType = 'TextureCube';\r\n    TextureCubeNode.prototype.generate = function (builder, output) {\r\n        if (builder.isShader('fragment')) {\r\n            builder.require('irradiance');\r\n            if (builder.context.bias) {\r\n                builder.context.bias.setTexture(this.value);\r\n            }\r\n            var scopeNode = builder.slot === 'irradiance' ? this.irradianceNode : this.radianceNode;\r\n            return scopeNode.build(builder, output);\r\n        } else {\r\n            console.warn('THREE.TextureCubeNode is not compatible with ' + builder.shader + ' shader.');\r\n            return builder.format('vec4( 0.0 )', this.getType(builder), output);\r\n        }\r\n    };\r\n    TextureCubeNode.prototype.copy = function (source) {\r\n        TempNode.prototype.copy.call(this, source);\r\n        this.value = source.value;\r\n        return this;\r\n    };\r\n    TextureCubeNode.prototype.toJSON = function (meta) {\r\n        var data = this.getJSONNode(meta);\r\n        if (!data) {\r\n            data = this.createJSONNode(meta);\r\n            data.value = this.value.toJSON(meta).uuid;\r\n        }\r\n        return data;\r\n    };\r\n    return TextureCubeNode;\r\n});"]}