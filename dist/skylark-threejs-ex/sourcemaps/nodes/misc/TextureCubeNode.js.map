{"version":3,"sources":["nodes/misc/TextureCubeNode.js"],"names":["define","TempNode","FloatNode","TextureCubeNode","ReflectNode","NormalNode","value","uv","bias","call","this","radianceNode","TextureCubeUVNode","VECTOR","irradianceNode","WORLD","setReadonly","prototype","Object","create","constructor","nodeType","generate","builder","output","isShader","require","context","setTexture","slot","build","console","warn","shader","format","getType","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":";;;;;;;AAAAA,QACI,mBACA,sBACA,sBACA,2BACA,2BACD,SACCC,EACAC,EACAC,EACAC,EACAC,GAEA,aACA,SAASF,EAAgBG,EAAOC,EAAIC,GAChCP,EAASQ,KAAKC,KAAM,MACpBA,KAAKJ,MAAQA,EACbI,KAAKC,aAAe,IAAIC,kBAAkBF,KAAKJ,MAAOC,GAAM,IAAIH,EAAYA,EAAYS,QAASL,GACjGE,KAAKI,eAAiB,IAAIF,kBAAkBF,KAAKJ,MAAO,IAAID,EAAWA,EAAWU,OAAQ,IAAIb,EAAU,GAAGc,aAAY,IA+B3H,OA7BAb,EAAgBc,UAAYC,OAAOC,OAAOlB,EAASgB,WACnDd,EAAgBc,UAAUG,YAAcjB,EACxCA,EAAgBc,UAAUI,SAAW,cACrClB,EAAgBc,UAAUK,SAAW,SAAUC,EAASC,GACpD,OAAID,EAAQE,SAAS,aACjBF,EAAQG,QAAQ,cACZH,EAAQI,QAAQnB,MAChBe,EAAQI,QAAQnB,KAAKoB,WAAWlB,KAAKJ,QAER,eAAjBiB,EAAQM,KAAwBnB,KAAKI,eAAiBJ,KAAKC,cAC1DmB,MAAMP,EAASC,KAEhCO,QAAQC,KAAK,gDAAkDT,EAAQU,OAAS,YACzEV,EAAQW,OAAO,cAAexB,KAAKyB,QAAQZ,GAAUC,KAGpErB,EAAgBc,UAAUmB,KAAO,SAAUC,GAGvC,OAFApC,EAASgB,UAAUmB,KAAK3B,KAAKC,KAAM2B,GACnC3B,KAAKJ,MAAQ+B,EAAO/B,MACbI,MAEXP,EAAgBc,UAAUqB,OAAS,SAAUC,GACzC,IAAIC,EAAO9B,KAAK+B,YAAYF,GAK5B,OAJKC,KACDA,EAAO9B,KAAKgC,eAAeH,IACtBjC,MAAQI,KAAKJ,MAAMgC,OAAOC,GAAMI,MAElCH,GAEJrC","file":"../../../nodes/misc/TextureCubeNode.js","sourcesContent":["define([\n    '../core/TempNode',\n    '../inputs/FloatNode',\n    './TextureCubeUVNode',\n    '../accessors/ReflectNode',\n    '../accessors/NormalNode'\n], function (\n    TempNode, \n    FloatNode, \n    TextureCubeNode, \n    ReflectNode, \n    NormalNode\n) {\n    'use strict';\n    function TextureCubeNode(value, uv, bias) {\n        TempNode.call(this, 'v4');\n        this.value = value;\n        this.radianceNode = new TextureCubeUVNode(this.value, uv || new ReflectNode(ReflectNode.VECTOR), bias);\n        this.irradianceNode = new TextureCubeUVNode(this.value, new NormalNode(NormalNode.WORLD), new FloatNode(1).setReadonly(true));\n    }\n    TextureCubeNode.prototype = Object.create(TempNode.prototype);\n    TextureCubeNode.prototype.constructor = TextureCubeNode;\n    TextureCubeNode.prototype.nodeType = 'TextureCube';\n    TextureCubeNode.prototype.generate = function (builder, output) {\n        if (builder.isShader('fragment')) {\n            builder.require('irradiance');\n            if (builder.context.bias) {\n                builder.context.bias.setTexture(this.value);\n            }\n            var scopeNode = builder.slot === 'irradiance' ? this.irradianceNode : this.radianceNode;\n            return scopeNode.build(builder, output);\n        } else {\n            console.warn('THREE.TextureCubeNode is not compatible with ' + builder.shader + ' shader.');\n            return builder.format('vec4( 0.0 )', this.getType(builder), output);\n        }\n    };\n    TextureCubeNode.prototype.copy = function (source) {\n        TempNode.prototype.copy.call(this, source);\n        this.value = source.value;\n        return this;\n    };\n    TextureCubeNode.prototype.toJSON = function (meta) {\n        var data = this.getJSONNode(meta);\n        if (!data) {\n            data = this.createJSONNode(meta);\n            data.value = this.value.toJSON(meta).uuid;\n        }\n        return data;\n    };\n    return TextureCubeNode;\n});"]}