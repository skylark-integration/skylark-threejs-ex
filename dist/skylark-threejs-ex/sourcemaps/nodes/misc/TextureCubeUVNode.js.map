{"version":3,"sources":["nodes/misc/TextureCubeUVNode.js"],"names":["define","TempNode","ConstNode","StructNode","FunctionNode","FunctionCallNode","ExpressionNode","FloatNode","OperatorNode","MathNode","ColorSpaceNode","TextureCubeUVNode","value","uv","bias","call","this","Nodes","TextureCubeUVData","cubeUV_maxMipLevel","cubeUV_minMipLevel","cubeUV_maxTileSize","cubeUV_minTileSize","getFace","useKeywords","getUV","bilinearCubeUV","r0","v0","m0","r1","v1","m1","r4","v4","m4","r5","v5","m5","r6","v6","m6","roughnessToMip","prototype","Object","create","constructor","nodeType","builder","texture","mipInt","colorSpaceTL","fromDecoding","getTextureEncodingFromMap","input","parse","build","colorSpaceTR","colorSpaceBL","colorSpaceBR","context","include","isShader","ignoreCache","addContext","colorSpaceTLExp","colorSpaceTRExp","colorSpaceBLExp","colorSpaceBRExp","removeContext","output","keywords","generate","roughness","mipV","mip","CLAMP","FLOOR","mipF","FRACT","color0","color1","setReadonly","ADD","color1Mix","MIX","format","console","warn","shader","getType","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":"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","file":"../../../nodes/misc/TextureCubeUVNode.js","sourcesContent":["define([\r\n    '../core/TempNode',\r\n    '../core/ConstNode',\r\n    '../core/StructNode',\r\n    '../core/FunctionNode',\r\n    '../core/FunctionCallNode',\r\n    '../core/ExpressionNode',\r\n    '../inputs/FloatNode',\r\n    '../math/OperatorNode',\r\n    '../math/MathNode',\r\n    '../utils/ColorSpaceNode'\r\n], function (\r\n    TempNode, \r\n    ConstNode, \r\n    StructNode, \r\n    FunctionNode, \r\n    FunctionCallNode, \r\n    ExpressionNode, \r\n    FloatNode, \r\n    OperatorNode, \r\n    MathNode, \r\n    ColorSpaceNode\r\n) {\r\n    'use strict';\r\n    function TextureCubeUVNode(value, uv, bias) {\r\n        TempNode.call(this, 'v4');\r\n        this.value = value, this.uv = uv;\r\n        this.bias = bias;\r\n    }\r\n    TextureCubeUVNode.Nodes = function () {\r\n        var TextureCubeUVData = new StructNode(`struct TextureCubeUVData {\r\n\t\t\tvec4 tl;\r\n\t\t\tvec4 tr;\r\n\t\t\tvec4 br;\r\n\t\t\tvec4 bl;\r\n\t\t\tvec2 f;\r\n\t\t}`);\r\n        var cubeUV_maxMipLevel = new ConstNode(`float cubeUV_maxMipLevel 8.0`, true);\r\n        var cubeUV_minMipLevel = new ConstNode(`float cubeUV_minMipLevel 4.0`, true);\r\n        var cubeUV_maxTileSize = new ConstNode(`float cubeUV_maxTileSize 256.0`, true);\r\n        var cubeUV_minTileSize = new ConstNode(`float cubeUV_minTileSize 16.0`, true);\r\n        var getFace = new FunctionNode(`float getFace(vec3 direction) {\r\n\t\t\t\tvec3 absDirection = abs(direction);\r\n\t\t\t\tfloat face = -1.0;\r\n\t\t\t\tif (absDirection.x > absDirection.z) {\r\n\t\t\t\t\tif (absDirection.x > absDirection.y)\r\n\t\t\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (absDirection.z > absDirection.y)\r\n\t\t\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\r\n\t\t\t\t}\r\n\t\t\t\treturn face;\r\n\t\t}`);\r\n        getFace.useKeywords = false;\r\n        var getUV = new FunctionNode(`vec2 getUV(vec3 direction, float face) {\r\n\t\t\t\tvec2 uv;\r\n\t\t\t\tif (face == 0.0) {\r\n\t\t\t\t\tuv = vec2(-direction.z, direction.y) / abs(direction.x);\r\n\t\t\t\t} else if (face == 1.0) {\r\n\t\t\t\t\tuv = vec2(direction.x, -direction.z) / abs(direction.y);\r\n\t\t\t\t} else if (face == 2.0) {\r\n\t\t\t\t\tuv = direction.xy / abs(direction.z);\r\n\t\t\t\t} else if (face == 3.0) {\r\n\t\t\t\t\tuv = vec2(direction.z, direction.y) / abs(direction.x);\r\n\t\t\t\t} else if (face == 4.0) {\r\n\t\t\t\t\tuv = direction.xz / abs(direction.y);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tuv = vec2(-direction.x, direction.y) / abs(direction.z);\r\n\t\t\t\t}\r\n\t\t\t\treturn 0.5 * (uv + 1.0);\r\n\t\t}`);\r\n        getUV.useKeywords = false;\r\n        var bilinearCubeUV = new FunctionNode(`TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\r\n\r\n\t\t\tfloat face = getFace(direction);\r\n\t\t\tfloat filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\r\n\t\t\tmipInt = max(mipInt, cubeUV_minMipLevel);\r\n\t\t\tfloat faceSize = exp2(mipInt);\r\n\r\n\t\t\tfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\r\n\r\n\t\t\tvec2 uv = getUV(direction, face) * (faceSize - 1.0);\r\n\t\t\tvec2 f = fract(uv);\r\n\t\t\tuv += 0.5 - f;\r\n\t\t\tif (face > 2.0) {\r\n\t\t\t\tuv.y += faceSize;\r\n\t\t\t\tface -= 3.0;\r\n\t\t\t}\r\n\t\t\tuv.x += face * faceSize;\r\n\t\t\tif(mipInt < cubeUV_maxMipLevel){\r\n\t\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\r\n\t\t\t}\r\n\t\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\r\n\t\t\tuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\r\n\t\t\tuv *= texelSize;\r\n \r\n\t\t\tvec4 tl = texture2D(envMap, uv);\r\n\t\t\tuv.x += texelSize;\r\n\t\t\tvec4 tr = texture2D(envMap, uv);\r\n\t\t\tuv.y += texelSize;\r\n\t\t\tvec4 br = texture2D(envMap, uv);\r\n\t\t\tuv.x -= texelSize;\r\n\t\t\tvec4 bl = texture2D(envMap, uv);\r\n\r\n\t\t\treturn TextureCubeUVData( tl, tr, br, bl, f );\r\n\t\t}`, [\r\n            TextureCubeUVData,\r\n            getFace,\r\n            getUV,\r\n            cubeUV_maxMipLevel,\r\n            cubeUV_minMipLevel,\r\n            cubeUV_maxTileSize,\r\n            cubeUV_minTileSize\r\n        ]);\r\n        bilinearCubeUV.useKeywords = false;\r\n        var r0 = new ConstNode(`float r0 1.0`, true);\r\n        var v0 = new ConstNode(`float v0 0.339`, true);\r\n        var m0 = new ConstNode(`float m0 -2.0`, true);\r\n        var r1 = new ConstNode(`float r1 0.8`, true);\r\n        var v1 = new ConstNode(`float v1 0.276`, true);\r\n        var m1 = new ConstNode(`float m1 -1.0`, true);\r\n        var r4 = new ConstNode(`float r4 0.4`, true);\r\n        var v4 = new ConstNode(`float v4 0.046`, true);\r\n        var m4 = new ConstNode(`float m4 2.0`, true);\r\n        var r5 = new ConstNode(`float r5 0.305`, true);\r\n        var v5 = new ConstNode(`float v5 0.016`, true);\r\n        var m5 = new ConstNode(`float m5 3.0`, true);\r\n        var r6 = new ConstNode(`float r6 0.21`, true);\r\n        var v6 = new ConstNode(`float v6 0.0038`, true);\r\n        var m6 = new ConstNode(`float m6 4.0`, true);\r\n        var defines = [\r\n            r0,\r\n            v0,\r\n            m0,\r\n            r1,\r\n            v1,\r\n            m1,\r\n            r4,\r\n            v4,\r\n            m4,\r\n            r5,\r\n            v5,\r\n            m5,\r\n            r6,\r\n            v6,\r\n            m6\r\n        ];\r\n        var roughnessToMip = new FunctionNode(`float roughnessToMip(float roughness) {\r\n\t\t\tfloat mip = 0.0;\r\n\t\t\tif (roughness >= r1) {\r\n\t\t\t\tmip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\r\n\t\t\t} else if (roughness >= r4) {\r\n\t\t\t\tmip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\r\n\t\t\t} else if (roughness >= r5) {\r\n\t\t\t\tmip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\r\n\t\t\t} else if (roughness >= r6) {\r\n\t\t\t\tmip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\r\n\t\t\t} else {\r\n\t\t\t\tmip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\r\n\t\t\t}\r\n\t\t\treturn mip;\r\n\t\t}`, defines);\r\n        return {\r\n            bilinearCubeUV: bilinearCubeUV,\r\n            roughnessToMip: roughnessToMip,\r\n            m0: m0,\r\n            cubeUV_maxMipLevel: cubeUV_maxMipLevel\r\n        };\r\n    }();\r\n    TextureCubeUVNode.prototype = Object.create(TempNode.prototype);\r\n    TextureCubeUVNode.prototype.constructor = TextureCubeUVNode;\r\n    TextureCubeUVNode.prototype.nodeType = 'TextureCubeUV';\r\n    TextureCubeUVNode.prototype.bilinearCubeUV = function (builder, texture, uv, mipInt) {\r\n        var bilinearCubeUV = new FunctionCallNode(TextureCubeUVNode.Nodes.bilinearCubeUV, [\r\n            texture,\r\n            uv,\r\n            mipInt\r\n        ]);\r\n        this.colorSpaceTL = this.colorSpaceTL || new ColorSpaceNode(new ExpressionNode('', 'v4'));\r\n        this.colorSpaceTL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\r\n        this.colorSpaceTL.input.parse(bilinearCubeUV.build(builder) + '.tl');\r\n        this.colorSpaceTR = this.colorSpaceTR || new ColorSpaceNode(new ExpressionNode('', 'v4'));\r\n        this.colorSpaceTR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\r\n        this.colorSpaceTR.input.parse(bilinearCubeUV.build(builder) + '.tr');\r\n        this.colorSpaceBL = this.colorSpaceBL || new ColorSpaceNode(new ExpressionNode('', 'v4'));\r\n        this.colorSpaceBL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\r\n        this.colorSpaceBL.input.parse(bilinearCubeUV.build(builder) + '.bl');\r\n        this.colorSpaceBR = this.colorSpaceBR || new ColorSpaceNode(new ExpressionNode('', 'v4'));\r\n        this.colorSpaceBR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\r\n        this.colorSpaceBR.input.parse(bilinearCubeUV.build(builder) + '.br');\r\n        var context = {\r\n            include: builder.isShader('vertex'),\r\n            ignoreCache: true\r\n        };\r\n        builder.addContext(context);\r\n        this.colorSpaceTLExp = new ExpressionNode(this.colorSpaceTL.build(builder, 'v4'), 'v4');\r\n        this.colorSpaceTRExp = new ExpressionNode(this.colorSpaceTR.build(builder, 'v4'), 'v4');\r\n        this.colorSpaceBLExp = new ExpressionNode(this.colorSpaceBL.build(builder, 'v4'), 'v4');\r\n        this.colorSpaceBRExp = new ExpressionNode(this.colorSpaceBR.build(builder, 'v4'), 'v4');\r\n        builder.removeContext();\r\n        var output = new ExpressionNode(`mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )`, 'v4');\r\n        output.keywords['cubeUV_TL'] = this.colorSpaceTLExp;\r\n        output.keywords['cubeUV_TR'] = this.colorSpaceTRExp;\r\n        output.keywords['cubeUV_BL'] = this.colorSpaceBLExp;\r\n        output.keywords['cubeUV_BR'] = this.colorSpaceBRExp;\r\n        output.keywords['cubeUV'] = bilinearCubeUV;\r\n        return output;\r\n    };\r\n    TextureCubeUVNode.prototype.generate = function (builder, output) {\r\n        if (builder.isShader('fragment')) {\r\n            var uv = this.uv;\r\n            var bias = this.bias || builder.context.roughness;\r\n            var mipV = new FunctionCallNode(TextureCubeUVNode.Nodes.roughnessToMip, [bias]);\r\n            var mip = new MathNode(mipV, TextureCubeUVNode.Nodes.m0, TextureCubeUVNode.Nodes.cubeUV_maxMipLevel, MathNode.CLAMP);\r\n            var mipInt = new MathNode(mip, MathNode.FLOOR);\r\n            var mipF = new MathNode(mip, MathNode.FRACT);\r\n            var color0 = this.bilinearCubeUV(builder, this.value, uv, mipInt);\r\n            var color1 = this.bilinearCubeUV(builder, this.value, uv, new OperatorNode(mipInt, new FloatNode(1).setReadonly(true), OperatorNode.ADD));\r\n            var color1Mix = new MathNode(color0, color1, mipF, MathNode.MIX);\r\n            return builder.format(color1Mix.build(builder), 'v4', output);\r\n        } else {\r\n            console.warn('THREE.TextureCubeUVNode is not compatible with ' + builder.shader + ' shader.');\r\n            return builder.format('vec4( 0.0 )', this.getType(builder), output);\r\n        }\r\n    };\r\n    TextureCubeUVNode.prototype.toJSON = function (meta) {\r\n        var data = this.getJSONNode(meta);\r\n        if (!data) {\r\n            data = this.createJSONNode(meta);\r\n            data.value = this.value.toJSON(meta).uuid;\r\n            data.uv = this.uv.toJSON(meta).uuid;\r\n            data.bias = this.bias.toJSON(meta).uuid;\r\n        }\r\n        return data;\r\n    };\r\n    return TextureCubeUVNode;\r\n});"]}