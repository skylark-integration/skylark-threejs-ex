{"version":3,"sources":["nodes/misc/TextureCubeUVNode.js"],"names":["define","TempNode","ConstNode","StructNode","FunctionNode","FunctionCallNode","ExpressionNode","FloatNode","OperatorNode","MathNode","ColorSpaceNode","TextureCubeUVNode","value","uv","bias","call","this","Nodes","TextureCubeUVData","cubeUV_maxMipLevel","cubeUV_minMipLevel","cubeUV_maxTileSize","cubeUV_minTileSize","getFace","useKeywords","getUV","bilinearCubeUV","r0","v0","m0","r1","v1","m1","r4","v4","m4","r5","v5","m5","r6","v6","m6","roughnessToMip","prototype","Object","create","constructor","nodeType","builder","texture","mipInt","colorSpaceTL","fromDecoding","getTextureEncodingFromMap","input","parse","build","colorSpaceTR","colorSpaceBL","colorSpaceBR","context","include","isShader","ignoreCache","addContext","colorSpaceTLExp","colorSpaceTRExp","colorSpaceBLExp","colorSpaceBRExp","removeContext","output","keywords","generate","roughness","mipV","mip","CLAMP","FLOOR","mipF","FRACT","color0","color1","setReadonly","ADD","color1Mix","MIX","format","console","warn","shader","getType","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":"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","file":"../../../nodes/misc/TextureCubeUVNode.js","sourcesContent":["define([\n    '../core/TempNode',\n    '../core/ConstNode',\n    '../core/StructNode',\n    '../core/FunctionNode',\n    '../core/FunctionCallNode',\n    '../core/ExpressionNode',\n    '../inputs/FloatNode',\n    '../math/OperatorNode',\n    '../math/MathNode',\n    '../utils/ColorSpaceNode'\n], function (\n    TempNode, \n    ConstNode, \n    StructNode, \n    FunctionNode, \n    FunctionCallNode, \n    ExpressionNode, \n    FloatNode, \n    OperatorNode, \n    MathNode, \n    ColorSpaceNode\n) {\n    'use strict';\n    function TextureCubeUVNode(value, uv, bias) {\n        TempNode.call(this, 'v4');\n        this.value = value, this.uv = uv;\n        this.bias = bias;\n    }\n    TextureCubeUVNode.Nodes = function () {\n        var TextureCubeUVData = new StructNode(`struct TextureCubeUVData {\n\t\t\tvec4 tl;\n\t\t\tvec4 tr;\n\t\t\tvec4 br;\n\t\t\tvec4 bl;\n\t\t\tvec2 f;\n\t\t}`);\n        var cubeUV_maxMipLevel = new ConstNode(`float cubeUV_maxMipLevel 8.0`, true);\n        var cubeUV_minMipLevel = new ConstNode(`float cubeUV_minMipLevel 4.0`, true);\n        var cubeUV_maxTileSize = new ConstNode(`float cubeUV_maxTileSize 256.0`, true);\n        var cubeUV_minTileSize = new ConstNode(`float cubeUV_minTileSize 16.0`, true);\n        var getFace = new FunctionNode(`float getFace(vec3 direction) {\n\t\t\t\tvec3 absDirection = abs(direction);\n\t\t\t\tfloat face = -1.0;\n\t\t\t\tif (absDirection.x > absDirection.z) {\n\t\t\t\t\tif (absDirection.x > absDirection.y)\n\t\t\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t} else {\n\t\t\t\t\tif (absDirection.z > absDirection.y)\n\t\t\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t}\n\t\t\t\treturn face;\n\t\t}`);\n        getFace.useKeywords = false;\n        var getUV = new FunctionNode(`vec2 getUV(vec3 direction, float face) {\n\t\t\t\tvec2 uv;\n\t\t\t\tif (face == 0.0) {\n\t\t\t\t\tuv = vec2(-direction.z, direction.y) / abs(direction.x);\n\t\t\t\t} else if (face == 1.0) {\n\t\t\t\t\tuv = vec2(direction.x, -direction.z) / abs(direction.y);\n\t\t\t\t} else if (face == 2.0) {\n\t\t\t\t\tuv = direction.xy / abs(direction.z);\n\t\t\t\t} else if (face == 3.0) {\n\t\t\t\t\tuv = vec2(direction.z, direction.y) / abs(direction.x);\n\t\t\t\t} else if (face == 4.0) {\n\t\t\t\t\tuv = direction.xz / abs(direction.y);\n\t\t\t\t} else {\n\t\t\t\t\tuv = vec2(-direction.x, direction.y) / abs(direction.z);\n\t\t\t\t}\n\t\t\t\treturn 0.5 * (uv + 1.0);\n\t\t}`);\n        getUV.useKeywords = false;\n        var bilinearCubeUV = new FunctionNode(`TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n\n\t\t\tfloat face = getFace(direction);\n\t\t\tfloat filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n\t\t\tmipInt = max(mipInt, cubeUV_minMipLevel);\n\t\t\tfloat faceSize = exp2(mipInt);\n\n\t\t\tfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n\n\t\t\tvec2 uv = getUV(direction, face) * (faceSize - 1.0);\n\t\t\tvec2 f = fract(uv);\n\t\t\tuv += 0.5 - f;\n\t\t\tif (face > 2.0) {\n\t\t\t\tuv.y += faceSize;\n\t\t\t\tface -= 3.0;\n\t\t\t}\n\t\t\tuv.x += face * faceSize;\n\t\t\tif(mipInt < cubeUV_maxMipLevel){\n\t\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t\t}\n\t\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\t\tuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n\t\t\tuv *= texelSize;\n \n\t\t\tvec4 tl = texture2D(envMap, uv);\n\t\t\tuv.x += texelSize;\n\t\t\tvec4 tr = texture2D(envMap, uv);\n\t\t\tuv.y += texelSize;\n\t\t\tvec4 br = texture2D(envMap, uv);\n\t\t\tuv.x -= texelSize;\n\t\t\tvec4 bl = texture2D(envMap, uv);\n\n\t\t\treturn TextureCubeUVData( tl, tr, br, bl, f );\n\t\t}`, [\n            TextureCubeUVData,\n            getFace,\n            getUV,\n            cubeUV_maxMipLevel,\n            cubeUV_minMipLevel,\n            cubeUV_maxTileSize,\n            cubeUV_minTileSize\n        ]);\n        bilinearCubeUV.useKeywords = false;\n        var r0 = new ConstNode(`float r0 1.0`, true);\n        var v0 = new ConstNode(`float v0 0.339`, true);\n        var m0 = new ConstNode(`float m0 -2.0`, true);\n        var r1 = new ConstNode(`float r1 0.8`, true);\n        var v1 = new ConstNode(`float v1 0.276`, true);\n        var m1 = new ConstNode(`float m1 -1.0`, true);\n        var r4 = new ConstNode(`float r4 0.4`, true);\n        var v4 = new ConstNode(`float v4 0.046`, true);\n        var m4 = new ConstNode(`float m4 2.0`, true);\n        var r5 = new ConstNode(`float r5 0.305`, true);\n        var v5 = new ConstNode(`float v5 0.016`, true);\n        var m5 = new ConstNode(`float m5 3.0`, true);\n        var r6 = new ConstNode(`float r6 0.21`, true);\n        var v6 = new ConstNode(`float v6 0.0038`, true);\n        var m6 = new ConstNode(`float m6 4.0`, true);\n        var defines = [\n            r0,\n            v0,\n            m0,\n            r1,\n            v1,\n            m1,\n            r4,\n            v4,\n            m4,\n            r5,\n            v5,\n            m5,\n            r6,\n            v6,\n            m6\n        ];\n        var roughnessToMip = new FunctionNode(`float roughnessToMip(float roughness) {\n\t\t\tfloat mip = 0.0;\n\t\t\tif (roughness >= r1) {\n\t\t\t\tmip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n\t\t\t} else if (roughness >= r4) {\n\t\t\t\tmip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n\t\t\t} else if (roughness >= r5) {\n\t\t\t\tmip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n\t\t\t} else if (roughness >= r6) {\n\t\t\t\tmip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n\t\t\t} else {\n\t\t\t\tmip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\n\t\t\t}\n\t\t\treturn mip;\n\t\t}`, defines);\n        return {\n            bilinearCubeUV: bilinearCubeUV,\n            roughnessToMip: roughnessToMip,\n            m0: m0,\n            cubeUV_maxMipLevel: cubeUV_maxMipLevel\n        };\n    }();\n    TextureCubeUVNode.prototype = Object.create(TempNode.prototype);\n    TextureCubeUVNode.prototype.constructor = TextureCubeUVNode;\n    TextureCubeUVNode.prototype.nodeType = 'TextureCubeUV';\n    TextureCubeUVNode.prototype.bilinearCubeUV = function (builder, texture, uv, mipInt) {\n        var bilinearCubeUV = new FunctionCallNode(TextureCubeUVNode.Nodes.bilinearCubeUV, [\n            texture,\n            uv,\n            mipInt\n        ]);\n        this.colorSpaceTL = this.colorSpaceTL || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n        this.colorSpaceTL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n        this.colorSpaceTL.input.parse(bilinearCubeUV.build(builder) + '.tl');\n        this.colorSpaceTR = this.colorSpaceTR || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n        this.colorSpaceTR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n        this.colorSpaceTR.input.parse(bilinearCubeUV.build(builder) + '.tr');\n        this.colorSpaceBL = this.colorSpaceBL || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n        this.colorSpaceBL.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n        this.colorSpaceBL.input.parse(bilinearCubeUV.build(builder) + '.bl');\n        this.colorSpaceBR = this.colorSpaceBR || new ColorSpaceNode(new ExpressionNode('', 'v4'));\n        this.colorSpaceBR.fromDecoding(builder.getTextureEncodingFromMap(this.value.value));\n        this.colorSpaceBR.input.parse(bilinearCubeUV.build(builder) + '.br');\n        var context = {\n            include: builder.isShader('vertex'),\n            ignoreCache: true\n        };\n        builder.addContext(context);\n        this.colorSpaceTLExp = new ExpressionNode(this.colorSpaceTL.build(builder, 'v4'), 'v4');\n        this.colorSpaceTRExp = new ExpressionNode(this.colorSpaceTR.build(builder, 'v4'), 'v4');\n        this.colorSpaceBLExp = new ExpressionNode(this.colorSpaceBL.build(builder, 'v4'), 'v4');\n        this.colorSpaceBRExp = new ExpressionNode(this.colorSpaceBR.build(builder, 'v4'), 'v4');\n        builder.removeContext();\n        var output = new ExpressionNode(`mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )`, 'v4');\n        output.keywords['cubeUV_TL'] = this.colorSpaceTLExp;\n        output.keywords['cubeUV_TR'] = this.colorSpaceTRExp;\n        output.keywords['cubeUV_BL'] = this.colorSpaceBLExp;\n        output.keywords['cubeUV_BR'] = this.colorSpaceBRExp;\n        output.keywords['cubeUV'] = bilinearCubeUV;\n        return output;\n    };\n    TextureCubeUVNode.prototype.generate = function (builder, output) {\n        if (builder.isShader('fragment')) {\n            var uv = this.uv;\n            var bias = this.bias || builder.context.roughness;\n            var mipV = new FunctionCallNode(TextureCubeUVNode.Nodes.roughnessToMip, [bias]);\n            var mip = new MathNode(mipV, TextureCubeUVNode.Nodes.m0, TextureCubeUVNode.Nodes.cubeUV_maxMipLevel, MathNode.CLAMP);\n            var mipInt = new MathNode(mip, MathNode.FLOOR);\n            var mipF = new MathNode(mip, MathNode.FRACT);\n            var color0 = this.bilinearCubeUV(builder, this.value, uv, mipInt);\n            var color1 = this.bilinearCubeUV(builder, this.value, uv, new OperatorNode(mipInt, new FloatNode(1).setReadonly(true), OperatorNode.ADD));\n            var color1Mix = new MathNode(color0, color1, mipF, MathNode.MIX);\n            return builder.format(color1Mix.build(builder), 'v4', output);\n        } else {\n            console.warn('THREE.TextureCubeUVNode is not compatible with ' + builder.shader + ' shader.');\n            return builder.format('vec4( 0.0 )', this.getType(builder), output);\n        }\n    };\n    TextureCubeUVNode.prototype.toJSON = function (meta) {\n        var data = this.getJSONNode(meta);\n        if (!data) {\n            data = this.createJSONNode(meta);\n            data.value = this.value.toJSON(meta).uuid;\n            data.uv = this.uv.toJSON(meta).uuid;\n            data.bias = this.bias.toJSON(meta).uuid;\n        }\n        return data;\n    };\n    return TextureCubeUVNode;\n});"]}