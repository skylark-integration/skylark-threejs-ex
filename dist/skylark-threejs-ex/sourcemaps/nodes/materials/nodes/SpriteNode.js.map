{"version":3,"sources":["nodes/materials/nodes/SpriteNode.js"],"names":["define","THREE","Node","ColorNode","SpriteNode","call","this","color","spherical","prototype","Object","create","constructor","nodeType","build","builder","requires","lights","transparent","undefined","alpha","isShader","position","analyzeAndFlow","cache","mergeUniform","UniformsUtils","merge","UniformsLib","fog","addParsCode","join","output","push","code","result","addCode","mask","analyze","slot","flow","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":"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","file":"../../../../nodes/materials/nodes/SpriteNode.js","sourcesContent":["define([\r\n    'skylark-threejs',\r\n    '../../core/Node',\r\n    '../../inputs/ColorNode'\r\n], function (\r\n    THREE, \r\n    Node, \r\n    ColorNode\r\n) {\r\n    'use strict';\r\n    function SpriteNode() {\r\n        Node.call(this);\r\n        this.color = new ColorNode(15658734);\r\n        this.spherical = true;\r\n    }\r\n    SpriteNode.prototype = Object.create(Node.prototype);\r\n    SpriteNode.prototype.constructor = SpriteNode;\r\n    SpriteNode.prototype.nodeType = 'Sprite';\r\n    SpriteNode.prototype.build = function (builder) {\r\n        var output;\r\n        builder.define('SPRITE');\r\n        builder.requires.lights = false;\r\n        builder.requires.transparent = this.alpha !== undefined;\r\n        if (builder.isShader('vertex')) {\r\n            var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', { cache: 'position' }) : undefined;\r\n            builder.mergeUniform(THREE.UniformsUtils.merge([THREE.UniformsLib.fog]));\r\n            builder.addParsCode([\r\n                '#include <fog_pars_vertex>',\r\n                '#include <logdepthbuf_pars_vertex>',\r\n                '#include <clipping_planes_pars_vertex>'\r\n            ].join('\\n'));\r\n            output = [\r\n                '#include <clipping_planes_fragment>',\r\n                '#include <begin_vertex>'\r\n            ];\r\n            if (position) {\r\n                output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\r\n            }\r\n            output.push('#include <project_vertex>', '#include <fog_vertex>', 'mat4 modelViewMtx = modelViewMatrix;', 'mat4 modelMtx = modelMatrix;', 'modelMtx[3][0] = 0.0;', 'modelMtx[3][1] = 0.0;', 'modelMtx[3][2] = 0.0;');\r\n            if (!this.spherical) {\r\n                output.push('modelMtx[1][1] = 1.0;');\r\n            }\r\n            output.push('modelViewMtx[0][0] = 1.0;', 'modelViewMtx[0][1] = 0.0;', 'modelViewMtx[0][2] = 0.0;');\r\n            if (this.spherical) {\r\n                output.push('modelViewMtx[1][0] = 0.0;', 'modelViewMtx[1][1] = 1.0;', 'modelViewMtx[1][2] = 0.0;');\r\n            }\r\n            output.push('modelViewMtx[2][0] = 0.0;', 'modelViewMtx[2][1] = 0.0;', 'modelViewMtx[2][2] = 1.0;', 'gl_Position = projectionMatrix * modelViewMtx * modelMtx * vec4( transformed, 1.0 );', '#include <logdepthbuf_vertex>', '#include <clipping_planes_vertex>', '#include <fog_vertex>');\r\n        } else {\r\n            builder.addParsCode([\r\n                '#include <fog_pars_fragment>',\r\n                '#include <logdepthbuf_pars_fragment>',\r\n                '#include <clipping_planes_pars_fragment>'\r\n            ].join('\\n'));\r\n            builder.addCode([\r\n                '#include <clipping_planes_fragment>',\r\n                '#include <logdepthbuf_fragment>'\r\n            ].join('\\n'));\r\n            if (this.mask)\r\n                this.mask.analyze(builder);\r\n            if (this.alpha)\r\n                this.alpha.analyze(builder);\r\n            this.color.analyze(builder, { slot: 'color' });\r\n            var mask = this.mask ? this.mask.flow(builder, 'b') : undefined, alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined, color = this.color.flow(builder, 'c', { slot: 'color' }), output = [];\r\n            if (mask) {\r\n                output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\r\n            }\r\n            if (alpha) {\r\n                output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif', color.code, 'gl_FragColor = vec4( ' + color.result + ', ' + alpha.result + ' );');\r\n            } else {\r\n                output.push(color.code, 'gl_FragColor = vec4( ' + color.result + ', 1.0 );');\r\n            }\r\n            output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>');\r\n        }\r\n        return output.join('\\n');\r\n    };\r\n    SpriteNode.prototype.copy = function (source) {\r\n        Node.prototype.copy.call(this, source);\r\n        if (source.position)\r\n            this.position = source.position;\r\n        this.color = source.color;\r\n        if (source.spherical !== undefined)\r\n            this.spherical = source.spherical;\r\n        if (source.mask)\r\n            this.mask = source.mask;\r\n        if (source.alpha)\r\n            this.alpha = source.alpha;\r\n        return this;\r\n    };\r\n    SpriteNode.prototype.toJSON = function (meta) {\r\n        var data = this.getJSONNode(meta);\r\n        if (!data) {\r\n            data = this.createJSONNode(meta);\r\n            if (this.position)\r\n                data.position = this.position.toJSON(meta).uuid;\r\n            data.color = this.color.toJSON(meta).uuid;\r\n            if (this.spherical === false)\r\n                data.spherical = false;\r\n            if (this.mask)\r\n                data.mask = this.mask.toJSON(meta).uuid;\r\n            if (this.alpha)\r\n                data.alpha = this.alpha.toJSON(meta).uuid;\r\n        }\r\n        return data;\r\n    };\r\n    return SpriteNode;\r\n});"]}