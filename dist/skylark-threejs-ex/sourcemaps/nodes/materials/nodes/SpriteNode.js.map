{"version":3,"sources":["nodes/materials/nodes/SpriteNode.js"],"names":["define","THREE","Node","ColorNode","SpriteNode","call","this","color","spherical","prototype","Object","create","constructor","nodeType","build","builder","requires","lights","transparent","undefined","alpha","isShader","position","analyzeAndFlow","cache","mergeUniform","UniformsUtils","merge","UniformsLib","fog","addParsCode","join","output","push","code","result","addCode","mask","analyze","slot","flow","copy","source","toJSON","meta","data","getJSONNode","createJSONNode","uuid"],"mappings":"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","file":"../../../../nodes/materials/nodes/SpriteNode.js","sourcesContent":["define([\n    'skylark-threejs',\n    '../../core/Node',\n    '../../inputs/ColorNode'\n], function (\n    THREE, \n    Node, \n    ColorNode\n) {\n    'use strict';\n    function SpriteNode() {\n        Node.call(this);\n        this.color = new ColorNode(15658734);\n        this.spherical = true;\n    }\n    SpriteNode.prototype = Object.create(Node.prototype);\n    SpriteNode.prototype.constructor = SpriteNode;\n    SpriteNode.prototype.nodeType = 'Sprite';\n    SpriteNode.prototype.build = function (builder) {\n        var output;\n        builder.define('SPRITE');\n        builder.requires.lights = false;\n        builder.requires.transparent = this.alpha !== undefined;\n        if (builder.isShader('vertex')) {\n            var position = this.position ? this.position.analyzeAndFlow(builder, 'v3', { cache: 'position' }) : undefined;\n            builder.mergeUniform(THREE.UniformsUtils.merge([THREE.UniformsLib.fog]));\n            builder.addParsCode([\n                '#include <fog_pars_vertex>',\n                '#include <logdepthbuf_pars_vertex>',\n                '#include <clipping_planes_pars_vertex>'\n            ].join('\\n'));\n            output = [\n                '#include <clipping_planes_fragment>',\n                '#include <begin_vertex>'\n            ];\n            if (position) {\n                output.push(position.code, position.result ? 'transformed = ' + position.result + ';' : '');\n            }\n            output.push('#include <project_vertex>', '#include <fog_vertex>', 'mat4 modelViewMtx = modelViewMatrix;', 'mat4 modelMtx = modelMatrix;', 'modelMtx[3][0] = 0.0;', 'modelMtx[3][1] = 0.0;', 'modelMtx[3][2] = 0.0;');\n            if (!this.spherical) {\n                output.push('modelMtx[1][1] = 1.0;');\n            }\n            output.push('modelViewMtx[0][0] = 1.0;', 'modelViewMtx[0][1] = 0.0;', 'modelViewMtx[0][2] = 0.0;');\n            if (this.spherical) {\n                output.push('modelViewMtx[1][0] = 0.0;', 'modelViewMtx[1][1] = 1.0;', 'modelViewMtx[1][2] = 0.0;');\n            }\n            output.push('modelViewMtx[2][0] = 0.0;', 'modelViewMtx[2][1] = 0.0;', 'modelViewMtx[2][2] = 1.0;', 'gl_Position = projectionMatrix * modelViewMtx * modelMtx * vec4( transformed, 1.0 );', '#include <logdepthbuf_vertex>', '#include <clipping_planes_vertex>', '#include <fog_vertex>');\n        } else {\n            builder.addParsCode([\n                '#include <fog_pars_fragment>',\n                '#include <logdepthbuf_pars_fragment>',\n                '#include <clipping_planes_pars_fragment>'\n            ].join('\\n'));\n            builder.addCode([\n                '#include <clipping_planes_fragment>',\n                '#include <logdepthbuf_fragment>'\n            ].join('\\n'));\n            if (this.mask)\n                this.mask.analyze(builder);\n            if (this.alpha)\n                this.alpha.analyze(builder);\n            this.color.analyze(builder, { slot: 'color' });\n            var mask = this.mask ? this.mask.flow(builder, 'b') : undefined, alpha = this.alpha ? this.alpha.flow(builder, 'f') : undefined, color = this.color.flow(builder, 'c', { slot: 'color' }), output = [];\n            if (mask) {\n                output.push(mask.code, 'if ( ! ' + mask.result + ' ) discard;');\n            }\n            if (alpha) {\n                output.push(alpha.code, '#ifdef ALPHATEST', 'if ( ' + alpha.result + ' <= ALPHATEST ) discard;', '#endif', color.code, 'gl_FragColor = vec4( ' + color.result + ', ' + alpha.result + ' );');\n            } else {\n                output.push(color.code, 'gl_FragColor = vec4( ' + color.result + ', 1.0 );');\n            }\n            output.push('#include <tonemapping_fragment>', '#include <encodings_fragment>', '#include <fog_fragment>');\n        }\n        return output.join('\\n');\n    };\n    SpriteNode.prototype.copy = function (source) {\n        Node.prototype.copy.call(this, source);\n        if (source.position)\n            this.position = source.position;\n        this.color = source.color;\n        if (source.spherical !== undefined)\n            this.spherical = source.spherical;\n        if (source.mask)\n            this.mask = source.mask;\n        if (source.alpha)\n            this.alpha = source.alpha;\n        return this;\n    };\n    SpriteNode.prototype.toJSON = function (meta) {\n        var data = this.getJSONNode(meta);\n        if (!data) {\n            data = this.createJSONNode(meta);\n            if (this.position)\n                data.position = this.position.toJSON(meta).uuid;\n            data.color = this.color.toJSON(meta).uuid;\n            if (this.spherical === false)\n                data.spherical = false;\n            if (this.mask)\n                data.mask = this.mask.toJSON(meta).uuid;\n            if (this.alpha)\n                data.alpha = this.alpha.toJSON(meta).uuid;\n        }\n        return data;\n    };\n    return SpriteNode;\n});"]}