{"version":3,"sources":["nodes/accessors/ReflectNode.js"],"names":["define","TempNode","PositionNode","NormalNode","ReflectNode","scope","call","this","CUBE","SPHERE","VECTOR","prototype","Object","create","constructor","nodeType","getUnique","builder","context","viewNormal","getType","type","generate","output","isUnique","isShader","result","viewNormalNode","VIEW","roughnessNode","roughness","build","viewPosition","undefined","method","code","addNodeCode","reflectVec","format","console","warn","shader","toJSON","meta","data","getJSONNode","createJSONNode"],"mappings":";;;;;;;AAAAA,QACI,mBACA,iBACA,gBACD,SAAUC,EAAUC,EAAcC,GACjC,aACA,SAASC,EAAYC,GACjBJ,EAASK,KAAKC,KAAM,MACpBA,KAAKF,MAAQA,GAASD,EAAYI,KA4EtC,OA1EAJ,EAAYI,KAAO,OACnBJ,EAAYK,OAAS,SACrBL,EAAYM,OAAS,SACrBN,EAAYO,UAAYC,OAAOC,OAAOZ,EAASU,WAC/CP,EAAYO,UAAUG,YAAcV,EACpCA,EAAYO,UAAUI,SAAW,UACjCX,EAAYO,UAAUK,UAAY,SAAUC,GACxC,OAAQA,EAAQC,QAAQC,YAE5Bf,EAAYO,UAAUS,QAAU,WAC5B,OAAQb,KAAKF,OACb,KAAKD,EAAYK,OACb,MAAO,KAEX,OAAOF,KAAKc,MAEhBjB,EAAYO,UAAUW,SAAW,SAAUL,EAASM,GAChD,IAAIC,EAAWjB,KAAKS,UAAUC,GAC9B,GAAIA,EAAQQ,SAAS,YAAa,CAC9B,IAAIC,EACJ,OAAQnB,KAAKF,OACb,KAAKD,EAAYM,OACb,IAAIiB,EAAiB,IAAIxB,EAAWA,EAAWyB,MAC3CC,EAAgBZ,EAAQC,QAAQY,UAChCX,EAAaQ,EAAeI,MAAMd,EAAS,MAC3Ce,EAAe,IAAI9B,EAAaA,EAAa0B,MAAMG,MAAMd,EAAS,MAClEa,EAAYD,EAAgBA,EAAcE,MAAMd,EAAS,UAAOgB,EAChEC,0BAAkCF,QAAqBb,MACvDW,IACAI,qBAA6BA,MAAaf,MAAiBW,OAAiBA,SAEhF,IAAIK,gCAAsCD,kBACtCV,GACAP,EAAQmB,iCAAkCD,MAC1CT,EAAS,cAETA,EAASS,EAEb,MACJ,KAAK/B,EAAYI,KAET2B,EAAO,WADPE,EAAa,IAAIjC,EAAYA,EAAYM,QAAQqB,MAAMd,EAAS,OAChC,OAASoB,EAAa,QACtDb,GACAP,EAAQmB,qCAAsCD,MAC9CT,EAAS,kBAETA,EAASS,EAEb,MACJ,KAAK/B,EAAYK,OACb,IAAI4B,EACAF,EAAO,oCADPE,EAAa,IAAIjC,EAAYA,EAAYM,QAAQqB,MAAMd,EAAS,OACP,yDACzDO,GACAP,EAAQmB,uCAAwCD,MAChDT,EAAS,oBAETA,EAASS,EAIjB,OAAOlB,EAAQqB,OAAOZ,EAAQnB,KAAKa,QAAQH,GAAUM,GAGrD,OADAgB,QAAQC,KAAK,4CAA8CvB,EAAQwB,OAAS,YACrExB,EAAQqB,OAAO,cAAe/B,KAAKc,KAAME,IAGxDnB,EAAYO,UAAU+B,OAAS,SAAUC,GACrC,IAAIC,EAAOrC,KAAKsC,YAAYF,GAK5B,OAJKC,KACDA,EAAOrC,KAAKuC,eAAeH,IACtBtC,MAAQE,KAAKF,OAEfuC,GAEJxC","file":"../../../nodes/accessors/ReflectNode.js","sourcesContent":["define([\n    '../core/TempNode',\n    './PositionNode',\n    './NormalNode'\n], function (TempNode, PositionNode, NormalNode) {\n    'use strict';\n    function ReflectNode(scope) {\n        TempNode.call(this, 'v3');\n        this.scope = scope || ReflectNode.CUBE;\n    }\n    ReflectNode.CUBE = 'cube';\n    ReflectNode.SPHERE = 'sphere';\n    ReflectNode.VECTOR = 'vector';\n    ReflectNode.prototype = Object.create(TempNode.prototype);\n    ReflectNode.prototype.constructor = ReflectNode;\n    ReflectNode.prototype.nodeType = 'Reflect';\n    ReflectNode.prototype.getUnique = function (builder) {\n        return !builder.context.viewNormal;\n    };\n    ReflectNode.prototype.getType = function () {\n        switch (this.scope) {\n        case ReflectNode.SPHERE:\n            return 'v2';\n        }\n        return this.type;\n    };\n    ReflectNode.prototype.generate = function (builder, output) {\n        var isUnique = this.getUnique(builder);\n        if (builder.isShader('fragment')) {\n            var result;\n            switch (this.scope) {\n            case ReflectNode.VECTOR:\n                var viewNormalNode = new NormalNode(NormalNode.VIEW);\n                var roughnessNode = builder.context.roughness;\n                var viewNormal = viewNormalNode.build(builder, 'v3');\n                var viewPosition = new PositionNode(PositionNode.VIEW).build(builder, 'v3');\n                var roughness = roughnessNode ? roughnessNode.build(builder, 'f') : undefined;\n                var method = `reflect( -normalize( ${ viewPosition } ), ${ viewNormal } )`;\n                if (roughness) {\n                    method = `normalize( mix( ${ method }, ${ viewNormal }, ${ roughness } * ${ roughness } ) )`;\n                }\n                var code = `inverseTransformDirection( ${ method }, viewMatrix )`;\n                if (isUnique) {\n                    builder.addNodeCode(`vec3 reflectVec = ${ code };`);\n                    result = 'reflectVec';\n                } else {\n                    result = code;\n                }\n                break;\n            case ReflectNode.CUBE:\n                var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n                var code = 'vec3( -' + reflectVec + '.x, ' + reflectVec + '.yz )';\n                if (isUnique) {\n                    builder.addNodeCode(`vec3 reflectCubeVec = ${ code };`);\n                    result = 'reflectCubeVec';\n                } else {\n                    result = code;\n                }\n                break;\n            case ReflectNode.SPHERE:\n                var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\n                var code = 'normalize( ( viewMatrix * vec4( ' + reflectVec + ', 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5';\n                if (isUnique) {\n                    builder.addNodeCode(`vec2 reflectSphereVec = ${ code };`);\n                    result = 'reflectSphereVec';\n                } else {\n                    result = code;\n                }\n                break;\n            }\n            return builder.format(result, this.getType(builder), output);\n        } else {\n            console.warn('THREE.ReflectNode is not compatible with ' + builder.shader + ' shader.');\n            return builder.format('vec3( 0.0 )', this.type, output);\n        }\n    };\n    ReflectNode.prototype.toJSON = function (meta) {\n        var data = this.getJSONNode(meta);\n        if (!data) {\n            data = this.createJSONNode(meta);\n            data.scope = this.scope;\n        }\n        return data;\n    };\n    return ReflectNode;\n});"]}