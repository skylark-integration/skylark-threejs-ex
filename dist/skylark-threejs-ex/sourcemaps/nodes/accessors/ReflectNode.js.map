{"version":3,"sources":["nodes/accessors/ReflectNode.js"],"names":["define","TempNode","PositionNode","NormalNode","ReflectNode","scope","call","this","CUBE","SPHERE","VECTOR","prototype","Object","create","constructor","nodeType","getUnique","builder","context","viewNormal","getType","type","generate","output","isUnique","isShader","result","viewNormalNode","VIEW","roughnessNode","roughness","build","viewPosition","undefined","method","code","addNodeCode","reflectVec","format","console","warn","shader","toJSON","meta","data","getJSONNode","createJSONNode"],"mappings":";;;;;;;AAAAA,QACI,mBACA,iBACA,gBACD,SAAUC,EAAUC,EAAcC,GACjC,aACA,SAASC,EAAYC,GACjBJ,EAASK,KAAKC,KAAM,MACpBA,KAAKF,MAAQA,GAASD,EAAYI,KA4EtC,OA1EAJ,EAAYI,KAAO,OACnBJ,EAAYK,OAAS,SACrBL,EAAYM,OAAS,SACrBN,EAAYO,UAAYC,OAAOC,OAAOZ,EAASU,WAC/CP,EAAYO,UAAUG,YAAcV,EACpCA,EAAYO,UAAUI,SAAW,UACjCX,EAAYO,UAAUK,UAAY,SAAUC,GACxC,OAAQA,EAAQC,QAAQC,YAE5Bf,EAAYO,UAAUS,QAAU,WAC5B,OAAQb,KAAKF,OACb,KAAKD,EAAYK,OACb,MAAO,KAEX,OAAOF,KAAKc,MAEhBjB,EAAYO,UAAUW,SAAW,SAAUL,EAASM,GAChD,IAAIC,EAAWjB,KAAKS,UAAUC,GAC9B,GAAIA,EAAQQ,SAAS,YAAa,CAC9B,IAAIC,EACJ,OAAQnB,KAAKF,OACb,KAAKD,EAAYM,OACb,IAAIiB,EAAiB,IAAIxB,EAAWA,EAAWyB,MAC3CC,EAAgBZ,EAAQC,QAAQY,UAChCX,EAAaQ,EAAeI,MAAMd,EAAS,MAC3Ce,EAAe,IAAI9B,EAAaA,EAAa0B,MAAMG,MAAMd,EAAS,MAClEa,EAAYD,EAAgBA,EAAcE,MAAMd,EAAS,UAAOgB,EAChEC,0BAAkCF,QAAqBb,MACvDW,IACAI,qBAA6BA,MAAaf,MAAiBW,OAAiBA,SAEhF,IAAIK,gCAAsCD,kBACtCV,GACAP,EAAQmB,iCAAkCD,MAC1CT,EAAS,cAETA,EAASS,EAEb,MACJ,KAAK/B,EAAYI,KAET2B,EAAO,WADPE,EAAa,IAAIjC,EAAYA,EAAYM,QAAQqB,MAAMd,EAAS,OAChC,OAASoB,EAAa,QACtDb,GACAP,EAAQmB,qCAAsCD,MAC9CT,EAAS,kBAETA,EAASS,EAEb,MACJ,KAAK/B,EAAYK,OACb,IAAI4B,EACAF,EAAO,oCADPE,EAAa,IAAIjC,EAAYA,EAAYM,QAAQqB,MAAMd,EAAS,OACP,yDACzDO,GACAP,EAAQmB,uCAAwCD,MAChDT,EAAS,oBAETA,EAASS,EAIjB,OAAOlB,EAAQqB,OAAOZ,EAAQnB,KAAKa,QAAQH,GAAUM,GAGrD,OADAgB,QAAQC,KAAK,4CAA8CvB,EAAQwB,OAAS,YACrExB,EAAQqB,OAAO,cAAe/B,KAAKc,KAAME,IAGxDnB,EAAYO,UAAU+B,OAAS,SAAUC,GACrC,IAAIC,EAAOrC,KAAKsC,YAAYF,GAK5B,OAJKC,KACDA,EAAOrC,KAAKuC,eAAeH,IACtBtC,MAAQE,KAAKF,OAEfuC,GAEJxC","file":"../../../nodes/accessors/ReflectNode.js","sourcesContent":["define([\r\n    '../core/TempNode',\r\n    './PositionNode',\r\n    './NormalNode'\r\n], function (TempNode, PositionNode, NormalNode) {\r\n    'use strict';\r\n    function ReflectNode(scope) {\r\n        TempNode.call(this, 'v3');\r\n        this.scope = scope || ReflectNode.CUBE;\r\n    }\r\n    ReflectNode.CUBE = 'cube';\r\n    ReflectNode.SPHERE = 'sphere';\r\n    ReflectNode.VECTOR = 'vector';\r\n    ReflectNode.prototype = Object.create(TempNode.prototype);\r\n    ReflectNode.prototype.constructor = ReflectNode;\r\n    ReflectNode.prototype.nodeType = 'Reflect';\r\n    ReflectNode.prototype.getUnique = function (builder) {\r\n        return !builder.context.viewNormal;\r\n    };\r\n    ReflectNode.prototype.getType = function () {\r\n        switch (this.scope) {\r\n        case ReflectNode.SPHERE:\r\n            return 'v2';\r\n        }\r\n        return this.type;\r\n    };\r\n    ReflectNode.prototype.generate = function (builder, output) {\r\n        var isUnique = this.getUnique(builder);\r\n        if (builder.isShader('fragment')) {\r\n            var result;\r\n            switch (this.scope) {\r\n            case ReflectNode.VECTOR:\r\n                var viewNormalNode = new NormalNode(NormalNode.VIEW);\r\n                var roughnessNode = builder.context.roughness;\r\n                var viewNormal = viewNormalNode.build(builder, 'v3');\r\n                var viewPosition = new PositionNode(PositionNode.VIEW).build(builder, 'v3');\r\n                var roughness = roughnessNode ? roughnessNode.build(builder, 'f') : undefined;\r\n                var method = `reflect( -normalize( ${ viewPosition } ), ${ viewNormal } )`;\r\n                if (roughness) {\r\n                    method = `normalize( mix( ${ method }, ${ viewNormal }, ${ roughness } * ${ roughness } ) )`;\r\n                }\r\n                var code = `inverseTransformDirection( ${ method }, viewMatrix )`;\r\n                if (isUnique) {\r\n                    builder.addNodeCode(`vec3 reflectVec = ${ code };`);\r\n                    result = 'reflectVec';\r\n                } else {\r\n                    result = code;\r\n                }\r\n                break;\r\n            case ReflectNode.CUBE:\r\n                var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\r\n                var code = 'vec3( -' + reflectVec + '.x, ' + reflectVec + '.yz )';\r\n                if (isUnique) {\r\n                    builder.addNodeCode(`vec3 reflectCubeVec = ${ code };`);\r\n                    result = 'reflectCubeVec';\r\n                } else {\r\n                    result = code;\r\n                }\r\n                break;\r\n            case ReflectNode.SPHERE:\r\n                var reflectVec = new ReflectNode(ReflectNode.VECTOR).build(builder, 'v3');\r\n                var code = 'normalize( ( viewMatrix * vec4( ' + reflectVec + ', 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5';\r\n                if (isUnique) {\r\n                    builder.addNodeCode(`vec2 reflectSphereVec = ${ code };`);\r\n                    result = 'reflectSphereVec';\r\n                } else {\r\n                    result = code;\r\n                }\r\n                break;\r\n            }\r\n            return builder.format(result, this.getType(builder), output);\r\n        } else {\r\n            console.warn('THREE.ReflectNode is not compatible with ' + builder.shader + ' shader.');\r\n            return builder.format('vec3( 0.0 )', this.type, output);\r\n        }\r\n    };\r\n    ReflectNode.prototype.toJSON = function (meta) {\r\n        var data = this.getJSONNode(meta);\r\n        if (!data) {\r\n            data = this.createJSONNode(meta);\r\n            data.scope = this.scope;\r\n        }\r\n        return data;\r\n    };\r\n    return ReflectNode;\r\n});"]}