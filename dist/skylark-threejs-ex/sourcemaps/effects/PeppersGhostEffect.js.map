{"version":3,"sources":["effects/PeppersGhostEffect.js"],"names":["define","THREE","PeppersGhostEffect","renderer","_halfWidth","_width","_height","scope","this","cameraDistance","reflectFromAbove","_cameraF","PerspectiveCamera","_cameraB","_cameraL","_cameraR","_position","Vector3","_quaternion","Quaternion","_scale","autoClear","setSize","width","height","render","scene","camera","updateMatrixWorld","parent","matrixWorld","decompose","position","copy","quaternion","translateZ","lookAt","rotation","z","Math","PI","translateX","x","clear","setScissorTest","setScissor","setViewport"],"mappings":";;;;;;;AAAAA,QACC,mBACC,SAASC,GAkJV,OA3IAA,EAAMC,mBAAqB,SAAWC,GAErC,IAMIC,EAAYC,EAAQC,EANpBC,EAAQC,KAEZD,EAAME,eAAiB,GACvBF,EAAMG,kBAAmB,EAKzB,IAAIC,EAAW,IAAIV,EAAMW,kBACrBC,EAAW,IAAIZ,EAAMW,kBACrBE,EAAW,IAAIb,EAAMW,kBACrBG,EAAW,IAAId,EAAMW,kBAErBI,EAAY,IAAIf,EAAMgB,QACtBC,EAAc,IAAIjB,EAAMkB,WACxBC,EAAS,IAAInB,EAAMgB,QAGvBd,EAASkB,WAAY,EAErBb,KAAKc,QAAU,SAAWC,EAAOC,GAEhCpB,EAAamB,EAAQ,EAChBA,EAAQC,GAEZnB,EAASkB,EAAQ,EACjBjB,EAAUiB,EAAQ,IAIlBlB,EAASmB,EAAS,EAClBlB,EAAUkB,EAAS,GAGpBrB,EAASmB,QAASC,EAAOC,IAI1BhB,KAAKiB,OAAS,SAAWC,EAAOC,GAE/BD,EAAME,oBAEiB,OAAlBD,EAAOE,QAAkBF,EAAOC,oBAErCD,EAAOG,YAAYC,UAAWf,EAAWE,EAAaE,GAGtDT,EAASqB,SAASC,KAAMjB,GACxBL,EAASuB,WAAWD,KAAMf,GAC1BP,EAASwB,WAAY5B,EAAME,gBAC3BE,EAASyB,OAAQV,EAAMM,UAGvBnB,EAASmB,SAASC,KAAMjB,GACxBH,EAASqB,WAAWD,KAAMf,GAC1BL,EAASsB,YAAgB5B,EAAqB,gBAC9CM,EAASuB,OAAQV,EAAMM,UACvBnB,EAASwB,SAASC,GAAaC,KAAKC,GAAK,IAAlB,IAGvB1B,EAASkB,SAASC,KAAMjB,GACxBF,EAASoB,WAAWD,KAAMf,GAC1BJ,EAAS2B,YAAgBlC,EAAqB,gBAC9CO,EAASsB,OAAQV,EAAMM,UACvBlB,EAASuB,SAASK,GAAYH,KAAKC,GAAK,IAAjB,GAGvBzB,EAASiB,SAASC,KAAMjB,GACxBD,EAASmB,WAAWD,KAAMf,GAC1BH,EAAS0B,WAAYlC,EAAME,gBAC3BM,EAASqB,OAAQV,EAAMM,UACvBjB,EAASsB,SAASK,GAAYH,KAAKC,GAAK,IAAjB,GAGvBrC,EAASwC,QACTxC,EAASyC,gBAAgB,GAEzBzC,EAAS0C,WAAYzC,EAAeC,EAAS,EAAiB,EAAVC,EAAeD,EAAQC,GAC3EH,EAAS2C,YAAa1C,EAAeC,EAAS,EAAiB,EAAVC,EAAeD,EAAQC,GAEvEC,EAAMG,iBAEVP,EAASsB,OAAQC,EAAOb,GAIxBV,EAASsB,OAAQC,EAAOf,GAIzBR,EAAS0C,WAAYzC,EAAeC,EAAS,EAAK,EAAGA,EAAQC,GAC7DH,EAAS2C,YAAa1C,EAAeC,EAAS,EAAK,EAAGA,EAAQC,GAEzDC,EAAMG,iBAEVP,EAASsB,OAAQC,EAAOf,GAIxBR,EAASsB,OAAQC,EAAOb,GAIzBV,EAAS0C,WAAYzC,EAAeC,EAAS,EAAMA,EAAQC,EAASD,EAAQC,GAC5EH,EAAS2C,YAAa1C,EAAeC,EAAS,EAAMA,EAAQC,EAASD,EAAQC,GAExEC,EAAMG,iBAEVP,EAASsB,OAAQC,EAAOX,GAIxBZ,EAASsB,OAAQC,EAAOZ,GAIzBX,EAAS0C,WAAYzC,EAAeC,EAAS,EAAKC,EAASD,EAAQC,GACnEH,EAAS2C,YAAa1C,EAAeC,EAAS,EAAKC,EAASD,EAAQC,GAE/DC,EAAMG,iBAEVP,EAASsB,OAAQC,EAAOZ,GAIxBX,EAASsB,OAAQC,EAAOX,GAIzBZ,EAASyC,gBAAgB,KAQpB3C,EAAMC","file":"../../effects/PeppersGhostEffect.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * Created by tpowellmeto on 29/10/2015.\n\t *\n\t * peppers ghost effect based on http://www.instructables.com/id/Reflective-Prism/?ALLSTEPS\n\t */\n\n\tTHREE.PeppersGhostEffect = function ( renderer ) {\n\n\t\tvar scope = this;\n\n\t\tscope.cameraDistance = 15;\n\t\tscope.reflectFromAbove = false;\n\n\t\t// Internals\n\t\tvar _halfWidth, _width, _height;\n\n\t\tvar _cameraF = new THREE.PerspectiveCamera(); //front\n\t\tvar _cameraB = new THREE.PerspectiveCamera(); //back\n\t\tvar _cameraL = new THREE.PerspectiveCamera(); //left\n\t\tvar _cameraR = new THREE.PerspectiveCamera(); //right\n\n\t\tvar _position = new THREE.Vector3();\n\t\tvar _quaternion = new THREE.Quaternion();\n\t\tvar _scale = new THREE.Vector3();\n\n\t\t// Initialization\n\t\trenderer.autoClear = false;\n\n\t\tthis.setSize = function ( width, height ) {\n\n\t\t\t_halfWidth = width / 2;\n\t\t\tif ( width < height ) {\n\n\t\t\t\t_width = width / 3;\n\t\t\t\t_height = width / 3;\n\n\t\t\t} else {\n\n\t\t\t\t_width = height / 3;\n\t\t\t\t_height = height / 3;\n\n\t\t\t}\n\t\t\trenderer.setSize( width, height );\n\n\t\t};\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tscene.updateMatrixWorld();\n\n\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\n\n\t\t\tcamera.matrixWorld.decompose( _position, _quaternion, _scale );\n\n\t\t\t// front\n\t\t\t_cameraF.position.copy( _position );\n\t\t\t_cameraF.quaternion.copy( _quaternion );\n\t\t\t_cameraF.translateZ( scope.cameraDistance );\n\t\t\t_cameraF.lookAt( scene.position );\n\n\t\t\t// back\n\t\t\t_cameraB.position.copy( _position );\n\t\t\t_cameraB.quaternion.copy( _quaternion );\n\t\t\t_cameraB.translateZ( - ( scope.cameraDistance ) );\n\t\t\t_cameraB.lookAt( scene.position );\n\t\t\t_cameraB.rotation.z += 180 * ( Math.PI / 180 );\n\n\t\t\t// left\n\t\t\t_cameraL.position.copy( _position );\n\t\t\t_cameraL.quaternion.copy( _quaternion );\n\t\t\t_cameraL.translateX( - ( scope.cameraDistance ) );\n\t\t\t_cameraL.lookAt( scene.position );\n\t\t\t_cameraL.rotation.x += 90 * ( Math.PI / 180 );\n\n\t\t\t// right\n\t\t\t_cameraR.position.copy( _position );\n\t\t\t_cameraR.quaternion.copy( _quaternion );\n\t\t\t_cameraR.translateX( scope.cameraDistance );\n\t\t\t_cameraR.lookAt( scene.position );\n\t\t\t_cameraR.rotation.x += 90 * ( Math.PI / 180 );\n\n\n\t\t\trenderer.clear();\n\t\t\trenderer.setScissorTest( true );\n\n\t\t\trenderer.setScissor( _halfWidth - ( _width / 2 ), ( _height * 2 ), _width, _height );\n\t\t\trenderer.setViewport( _halfWidth - ( _width / 2 ), ( _height * 2 ), _width, _height );\n\n\t\t\tif ( scope.reflectFromAbove ) {\n\n\t\t\t\trenderer.render( scene, _cameraB );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( scene, _cameraF );\n\n\t\t\t}\n\n\t\t\trenderer.setScissor( _halfWidth - ( _width / 2 ), 0, _width, _height );\n\t\t\trenderer.setViewport( _halfWidth - ( _width / 2 ), 0, _width, _height );\n\n\t\t\tif ( scope.reflectFromAbove ) {\n\n\t\t\t\trenderer.render( scene, _cameraF );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( scene, _cameraB );\n\n\t\t\t}\n\n\t\t\trenderer.setScissor( _halfWidth - ( _width / 2 ) - _width, _height, _width, _height );\n\t\t\trenderer.setViewport( _halfWidth - ( _width / 2 ) - _width, _height, _width, _height );\n\n\t\t\tif ( scope.reflectFromAbove ) {\n\n\t\t\t\trenderer.render( scene, _cameraR );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( scene, _cameraL );\n\n\t\t\t}\n\n\t\t\trenderer.setScissor( _halfWidth + ( _width / 2 ), _height, _width, _height );\n\t\t\trenderer.setViewport( _halfWidth + ( _width / 2 ), _height, _width, _height );\n\n\t\t\tif ( scope.reflectFromAbove ) {\n\n\t\t\t\trenderer.render( scene, _cameraL );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( scene, _cameraR );\n\n\t\t\t}\n\n\t\t\trenderer.setScissorTest( false );\n\n\t\t};\n\n\n\t};\n\n\t\n\treturn THREE.PeppersGhostEffect;\n});\n"]}