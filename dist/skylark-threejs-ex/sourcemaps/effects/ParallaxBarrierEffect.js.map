{"version":3,"sources":["effects/ParallaxBarrierEffect.js"],"names":["define","THREE","renderer","_camera","OrthographicCamera","_scene","Scene","_stereo","StereoCamera","_params","minFilter","LinearFilter","magFilter","NearestFilter","format","RGBAFormat","_renderTargetL","WebGLRenderTarget","_renderTargetR","_material","ShaderMaterial","uniforms","mapLeft","value","texture","mapRight","vertexShader","join","fragmentShader","mesh","Mesh","PlaneBufferGeometry","add","this","setSize","width","height","pixelRatio","getPixelRatio","render","scene","camera","updateMatrixWorld","parent","update","setRenderTarget","clear","cameraL","cameraR"],"mappings":";;;;;;;AAAAA,QACI,mBACD,SAAUC,GACT,aA8DA,OA7D4B,SAAUC,GAClC,IAAIC,EAAU,IAAIF,EAAMG,oBAAoB,EAAG,EAAG,GAAI,EAAG,EAAG,GACxDC,EAAS,IAAIJ,EAAMK,MACnBC,EAAU,IAAIN,EAAMO,aACpBC,GACAC,UAAWT,EAAMU,aACjBC,UAAWX,EAAMY,cACjBC,OAAQb,EAAMc,YAEdC,EAAiB,IAAIf,EAAMgB,kBAAkB,IAAK,IAAKR,GACvDS,EAAiB,IAAIjB,EAAMgB,kBAAkB,IAAK,IAAKR,GACvDU,EAAY,IAAIlB,EAAMmB,gBACtBC,UACIC,SAAaC,MAAOP,EAAeQ,SACnCC,UAAcF,MAAOL,EAAeM,UAExCE,cACI,oBACA,gBACA,8BACA,8EACA,KACFC,KAAK,MACPC,gBACI,6BACA,8BACA,oBACA,gBACA,mBACA,mDACA,+CACA,aACA,gDACA,MACA,KACFD,KAAK,QAEPE,EAAO,IAAI5B,EAAM6B,KAAK,IAAI7B,EAAM8B,oBAAoB,EAAG,GAAIZ,GAC/Dd,EAAO2B,IAAIH,GACXI,KAAKC,QAAU,SAAUC,EAAOC,GAC5BlC,EAASgC,QAAQC,EAAOC,GACxB,IAAIC,EAAanC,EAASoC,gBAC1BtB,EAAekB,QAAQC,EAAQE,EAAYD,EAASC,GACpDnB,EAAegB,QAAQC,EAAQE,EAAYD,EAASC,IAExDJ,KAAKM,OAAS,SAAUC,EAAOC,GAC3BD,EAAME,oBACgB,OAAlBD,EAAOE,QACPF,EAAOC,oBACXnC,EAAQqC,OAAOH,GACfvC,EAAS2C,gBAAgB7B,GACzBd,EAAS4C,QACT5C,EAASqC,OAAOC,EAAOjC,EAAQwC,SAC/B7C,EAAS2C,gBAAgB3B,GACzBhB,EAAS4C,QACT5C,EAASqC,OAAOC,EAAOjC,EAAQyC,SAC/B9C,EAAS2C,gBAAgB,MACzB3C,EAASqC,OAAOlC,EAAQF","file":"../../effects/ParallaxBarrierEffect.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var ParallaxBarrierEffect = function (renderer) {\n        var _camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        var _scene = new THREE.Scene();\n        var _stereo = new THREE.StereoCamera();\n        var _params = {\n            minFilter: THREE.LinearFilter,\n            magFilter: THREE.NearestFilter,\n            format: THREE.RGBAFormat\n        };\n        var _renderTargetL = new THREE.WebGLRenderTarget(512, 512, _params);\n        var _renderTargetR = new THREE.WebGLRenderTarget(512, 512, _params);\n        var _material = new THREE.ShaderMaterial({\n            uniforms: {\n                'mapLeft': { value: _renderTargetL.texture },\n                'mapRight': { value: _renderTargetR.texture }\n            },\n            vertexShader: [\n                'varying vec2 vUv;',\n                'void main() {',\n                '\\tvUv = vec2( uv.x, uv.y );',\n                '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n                '}'\n            ].join('\\n'),\n            fragmentShader: [\n                'uniform sampler2D mapLeft;',\n                'uniform sampler2D mapRight;',\n                'varying vec2 vUv;',\n                'void main() {',\n                '\\tvec2 uv = vUv;',\n                '\\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {',\n                '\\t\\tgl_FragColor = texture2D( mapLeft, uv );',\n                '\\t} else {',\n                '\\t\\tgl_FragColor = texture2D( mapRight, uv );',\n                '\\t}',\n                '}'\n            ].join('\\n')\n        });\n        var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), _material);\n        _scene.add(mesh);\n        this.setSize = function (width, height) {\n            renderer.setSize(width, height);\n            var pixelRatio = renderer.getPixelRatio();\n            _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\n            _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\n        };\n        this.render = function (scene, camera) {\n            scene.updateMatrixWorld();\n            if (camera.parent === null)\n                camera.updateMatrixWorld();\n            _stereo.update(camera);\n            renderer.setRenderTarget(_renderTargetL);\n            renderer.clear();\n            renderer.render(scene, _stereo.cameraL);\n            renderer.setRenderTarget(_renderTargetR);\n            renderer.clear();\n            renderer.render(scene, _stereo.cameraR);\n            renderer.setRenderTarget(null);\n            renderer.render(_scene, _camera);\n        };\n    };\n    \n    return ParallaxBarrierEffect;\n});"]}