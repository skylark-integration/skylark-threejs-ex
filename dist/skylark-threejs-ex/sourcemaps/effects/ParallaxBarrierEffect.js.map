{"version":3,"sources":["effects/ParallaxBarrierEffect.js"],"names":["define","THREE","threex","effects","ParallaxBarrierEffect","renderer","_camera","OrthographicCamera","_scene","Scene","_stereo","StereoCamera","_params","minFilter","LinearFilter","magFilter","NearestFilter","format","RGBAFormat","_renderTargetL","WebGLRenderTarget","_renderTargetR","_material","ShaderMaterial","uniforms","mapLeft","value","texture","mapRight","vertexShader","join","fragmentShader","mesh","Mesh","PlaneBufferGeometry","add","this","setSize","width","height","pixelRatio","getPixelRatio","render","scene","camera","updateMatrixWorld","parent","update","setRenderTarget","clear","cameraL","cameraR"],"mappings":";;;;;;;AAAAA,QACI,kBACA,aACD,SACCC,EACAC,GAEA,aA8DA,OAAOA,EAAOC,QAAQC,sBA7DM,SAAUC,GAClC,IAAIC,EAAU,IAAIL,EAAMM,oBAAoB,EAAG,EAAG,GAAI,EAAG,EAAG,GACxDC,EAAS,IAAIP,EAAMQ,MACnBC,EAAU,IAAIT,EAAMU,aACpBC,GACAC,UAAWZ,EAAMa,aACjBC,UAAWd,EAAMe,cACjBC,OAAQhB,EAAMiB,YAEdC,EAAiB,IAAIlB,EAAMmB,kBAAkB,IAAK,IAAKR,GACvDS,EAAiB,IAAIpB,EAAMmB,kBAAkB,IAAK,IAAKR,GACvDU,EAAY,IAAIrB,EAAMsB,gBACtBC,UACIC,SAAaC,MAAOP,EAAeQ,SACnCC,UAAcF,MAAOL,EAAeM,UAExCE,cACI,oBACA,gBACA,8BACA,8EACA,KACFC,KAAK,MACPC,gBACI,6BACA,8BACA,oBACA,gBACA,mBACA,mDACA,+CACA,aACA,gDACA,MACA,KACFD,KAAK,QAEPE,EAAO,IAAI/B,EAAMgC,KAAK,IAAIhC,EAAMiC,oBAAoB,EAAG,GAAIZ,GAC/Dd,EAAO2B,IAAIH,GACXI,KAAKC,QAAU,SAAUC,EAAOC,GAC5BlC,EAASgC,QAAQC,EAAOC,GACxB,IAAIC,EAAanC,EAASoC,gBAC1BtB,EAAekB,QAAQC,EAAQE,EAAYD,EAASC,GACpDnB,EAAegB,QAAQC,EAAQE,EAAYD,EAASC,IAExDJ,KAAKM,OAAS,SAAUC,EAAOC,GAC3BD,EAAME,oBACgB,OAAlBD,EAAOE,QACPF,EAAOC,oBACXnC,EAAQqC,OAAOH,GACfvC,EAAS2C,gBAAgB7B,GACzBd,EAAS4C,QACT5C,EAASqC,OAAOC,EAAOjC,EAAQwC,SAC/B7C,EAAS2C,gBAAgB3B,GACzBhB,EAAS4C,QACT5C,EAASqC,OAAOC,EAAOjC,EAAQyC,SAC/B9C,EAAS2C,gBAAgB,MACzB3C,EAASqC,OAAOlC,EAAQF","file":"../../effects/ParallaxBarrierEffect.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var ParallaxBarrierEffect = function (renderer) {\r\n        var _camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\r\n        var _scene = new THREE.Scene();\r\n        var _stereo = new THREE.StereoCamera();\r\n        var _params = {\r\n            minFilter: THREE.LinearFilter,\r\n            magFilter: THREE.NearestFilter,\r\n            format: THREE.RGBAFormat\r\n        };\r\n        var _renderTargetL = new THREE.WebGLRenderTarget(512, 512, _params);\r\n        var _renderTargetR = new THREE.WebGLRenderTarget(512, 512, _params);\r\n        var _material = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                'mapLeft': { value: _renderTargetL.texture },\r\n                'mapRight': { value: _renderTargetR.texture }\r\n            },\r\n            vertexShader: [\r\n                'varying vec2 vUv;',\r\n                'void main() {',\r\n                '\\tvUv = vec2( uv.x, uv.y );',\r\n                '\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\r\n                '}'\r\n            ].join('\\n'),\r\n            fragmentShader: [\r\n                'uniform sampler2D mapLeft;',\r\n                'uniform sampler2D mapRight;',\r\n                'varying vec2 vUv;',\r\n                'void main() {',\r\n                '\\tvec2 uv = vUv;',\r\n                '\\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {',\r\n                '\\t\\tgl_FragColor = texture2D( mapLeft, uv );',\r\n                '\\t} else {',\r\n                '\\t\\tgl_FragColor = texture2D( mapRight, uv );',\r\n                '\\t}',\r\n                '}'\r\n            ].join('\\n')\r\n        });\r\n        var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), _material);\r\n        _scene.add(mesh);\r\n        this.setSize = function (width, height) {\r\n            renderer.setSize(width, height);\r\n            var pixelRatio = renderer.getPixelRatio();\r\n            _renderTargetL.setSize(width * pixelRatio, height * pixelRatio);\r\n            _renderTargetR.setSize(width * pixelRatio, height * pixelRatio);\r\n        };\r\n        this.render = function (scene, camera) {\r\n            scene.updateMatrixWorld();\r\n            if (camera.parent === null)\r\n                camera.updateMatrixWorld();\r\n            _stereo.update(camera);\r\n            renderer.setRenderTarget(_renderTargetL);\r\n            renderer.clear();\r\n            renderer.render(scene, _stereo.cameraL);\r\n            renderer.setRenderTarget(_renderTargetR);\r\n            renderer.clear();\r\n            renderer.render(scene, _stereo.cameraR);\r\n            renderer.setRenderTarget(null);\r\n            renderer.render(_scene, _camera);\r\n        };\r\n    };\r\n    \r\n    return threex.effects.ParallaxBarrierEffect = ParallaxBarrierEffect;\r\n});"]}