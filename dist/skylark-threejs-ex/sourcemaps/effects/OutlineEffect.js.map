{"version":3,"sources":["effects/OutlineEffect.js"],"names":["define","THREE","OutlineEffect","renderer","parameters","this","enabled","defaultThickness","undefined","defaultColor","Color","fromArray","defaultAlpha","defaultKeepAlive","cache","removeThresholdCount","originalMaterials","originalOnBeforeRenders","uniformsOutline","outlineThickness","value","outlineColor","outlineAlpha","vertexShader","join","fragmentShader","getOutlineMaterialFromCache","originalMaterial","data","uuid","material","ShaderMaterial","type","uniforms","UniformsUtils","merge","UniformsLib","side","BackSide","used","keepAlive","count","getOutlineMaterial","outlineMaterial","name","outlineParameters","userData","skinning","morphTargets","morphNormals","fog","toneMapped","premultipliedAlpha","displacementMap","visible","transparent","alpha","wireframe","depthTest","clippingPlanes","clipping","clipIntersection","clipShadows","version","updateOutlineMaterial","isCompatible","object","geometry","hasNormals","isBufferGeometry","attributes","normal","isMesh","setOutlineMaterial","Array","isArray","i","il","length","onBeforeRender","restoreOriginalMaterial","scene","camera","opacity","thickness","color","displacementScale","displacementBias","updateUniforms","render","renderTarget","forceClear","arguments","console","warn","setRenderTarget","clear","currentAutoClear","autoClear","renderOutline","currentSceneAutoUpdate","autoUpdate","currentSceneBackground","background","currentShadowMapEnabled","shadowMap","traverse","keys","Object","key","cleanupCache","domElement","depth","stencil","getPixelRatio","setPixelRatio","getSize","target","setSize","width","height","updateStyle","setViewport","x","y","setScissor","setScissorTest","boolean"],"mappings":"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","file":"../../effects/OutlineEffect.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t * @author takahirox / http://github.com/takahirox/\n\t *\n\t * Reference: https://en.wikipedia.org/wiki/Cel_shading\n\t *\n\t * API\n\t *\n\t * 1. Traditional\n\t *\n\t * var effect = new THREE.OutlineEffect( renderer );\n\t *\n\t * function render() {\n\t *\n\t * \teffect.render( scene, camera );\n\t *\n\t * }\n\t *\n\t * 2. VR compatible\n\t *\n\t * var effect = new THREE.OutlineEffect( renderer );\n\t * var renderingOutline = false;\n\t *\n\t * scene.onAfterRender = function () {\n\t *\n\t * \tif ( renderingOutline ) return;\n\t *\n\t * \trenderingOutline = true;\n\t *\n\t * \teffect.renderOutline( scene, camera );\n\t *\n\t * \trenderingOutline = false;\n\t *\n\t * };\n\t *\n\t * function render() {\n\t *\n\t * \trenderer.render( scene, camera );\n\t *\n\t * }\n\t *\n\t * // How to set default outline parameters\n\t * new THREE.OutlineEffect( renderer, {\n\t * \tdefaultThickness: 0.01,\n\t * \tdefaultColor: [ 0, 0, 0 ],\n\t * \tdefaultAlpha: 0.8,\n\t * \tdefaultKeepAlive: true // keeps outline material in cache even if material is removed from scene\n\t * } );\n\t *\n\t * // How to set outline parameters for each material\n\t * material.userData.outlineParameters = {\n\t * \tthickness: 0.01,\n\t * \tcolor: [ 0, 0, 0 ]\n\t * \talpha: 0.8,\n\t * \tvisible: true,\n\t * \tkeepAlive: true\n\t * };\n\t */\n\n\tTHREE.OutlineEffect = function ( renderer, parameters ) {\n\n\t\tparameters = parameters || {};\n\n\t\tthis.enabled = true;\n\n\t\tvar defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\n\t\tvar defaultColor = new THREE.Color().fromArray( parameters.defaultColor !== undefined ? parameters.defaultColor : [ 0, 0, 0 ] );\n\t\tvar defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;\n\t\tvar defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false;\n\n\t\t// object.material.uuid -> outlineMaterial or\n\t\t// object.material[ n ].uuid -> outlineMaterial\n\t\t// save at the outline material creation and release\n\t\t// if it's unused removeThresholdCount frames\n\t\t// unless keepAlive is true.\n\t\tvar cache = {};\n\n\t\tvar removeThresholdCount = 60;\n\n\t\t// outlineMaterial.uuid -> object.material or\n\t\t// outlineMaterial.uuid -> object.material[ n ]\n\t\t// save before render and release after render.\n\t\tvar originalMaterials = {};\n\n\t\t// object.uuid -> originalOnBeforeRender\n\t\t// save before render and release after render.\n\t\tvar originalOnBeforeRenders = {};\n\n\t\t//this.cache = cache;  // for debug\n\n\t\tvar uniformsOutline = {\n\t\t\toutlineThickness: { value: defaultThickness },\n\t\t\toutlineColor: { value: defaultColor },\n\t\t\toutlineAlpha: { value: defaultAlpha }\n\t\t};\n\n\t\tvar vertexShader = [\n\t\t\t\"#include <common>\",\n\t\t\t\"#include <uv_pars_vertex>\",\n\t\t\t\"#include <displacementmap_pars_vertex>\",\n\t\t\t\"#include <fog_pars_vertex>\",\n\t\t\t\"#include <morphtarget_pars_vertex>\",\n\t\t\t\"#include <skinning_pars_vertex>\",\n\t\t\t\"#include <logdepthbuf_pars_vertex>\",\n\t\t\t\"#include <clipping_planes_pars_vertex>\",\n\n\t\t\t\"uniform float outlineThickness;\",\n\n\t\t\t\"vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {\",\n\t\t\t\"\tfloat thickness = outlineThickness;\",\n\t\t\t\"\tconst float ratio = 1.0;\", // TODO: support outline thickness ratio for each vertex\n\t\t\t\"\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );\",\n\t\t\t// NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n\t\t\t\"\tvec4 norm = normalize( pos - pos2 );\",\n\t\t\t\"\treturn pos + norm * thickness * pos.w * ratio;\",\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\t#include <uv_vertex>\",\n\n\t\t\t\"\t#include <beginnormal_vertex>\",\n\t\t\t\"\t#include <morphnormal_vertex>\",\n\t\t\t\"\t#include <skinbase_vertex>\",\n\t\t\t\"\t#include <skinnormal_vertex>\",\n\n\t\t\t\"\t#include <begin_vertex>\",\n\t\t\t\"\t#include <morphtarget_vertex>\",\n\t\t\t\"\t#include <skinning_vertex>\",\n\t\t\t\"\t#include <displacementmap_vertex>\",\n\t\t\t\"\t#include <project_vertex>\",\n\n\t\t\t\"\tvec3 outlineNormal = - objectNormal;\", // the outline material is always rendered with THREE.BackSide\n\n\t\t\t\"\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );\",\n\n\t\t\t\"\t#include <logdepthbuf_vertex>\",\n\t\t\t\"\t#include <clipping_planes_vertex>\",\n\t\t\t\"\t#include <fog_vertex>\",\n\n\t\t\t\"}\",\n\n\t\t].join( \"\\n\" );\n\n\t\tvar fragmentShader = [\n\n\t\t\t\"#include <common>\",\n\t\t\t\"#include <fog_pars_fragment>\",\n\t\t\t\"#include <logdepthbuf_pars_fragment>\",\n\t\t\t\"#include <clipping_planes_pars_fragment>\",\n\n\t\t\t\"uniform vec3 outlineColor;\",\n\t\t\t\"uniform float outlineAlpha;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\t#include <clipping_planes_fragment>\",\n\t\t\t\"\t#include <logdepthbuf_fragment>\",\n\n\t\t\t\"\tgl_FragColor = vec4( outlineColor, outlineAlpha );\",\n\n\t\t\t\"\t#include <tonemapping_fragment>\",\n\t\t\t\"\t#include <encodings_fragment>\",\n\t\t\t\"\t#include <fog_fragment>\",\n\t\t\t\"\t#include <premultiplied_alpha_fragment>\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" );\n\n\t\tfunction createMaterial() {\n\n\t\t\treturn new THREE.ShaderMaterial( {\n\t\t\t\ttype: 'OutlineEffect',\n\t\t\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\t\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\n\t\t\t\t\tuniformsOutline\n\t\t\t\t] ),\n\t\t\t\tvertexShader: vertexShader,\n\t\t\t\tfragmentShader: fragmentShader,\n\t\t\t\tside: THREE.BackSide\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction getOutlineMaterialFromCache( originalMaterial ) {\n\n\t\t\tvar data = cache[ originalMaterial.uuid ];\n\n\t\t\tif ( data === undefined ) {\n\n\t\t\t\tdata = {\n\t\t\t\t\tmaterial: createMaterial(),\n\t\t\t\t\tused: true,\n\t\t\t\t\tkeepAlive: defaultKeepAlive,\n\t\t\t\t\tcount: 0\n\t\t\t\t};\n\n\t\t\t\tcache[ originalMaterial.uuid ] = data;\n\n\t\t\t}\n\n\t\t\tdata.used = true;\n\n\t\t\treturn data.material;\n\n\t\t}\n\n\t\tfunction getOutlineMaterial( originalMaterial ) {\n\n\t\t\tvar outlineMaterial = getOutlineMaterialFromCache( originalMaterial );\n\n\t\t\toriginalMaterials[ outlineMaterial.uuid ] = originalMaterial;\n\n\t\t\tupdateOutlineMaterial( outlineMaterial, originalMaterial );\n\n\t\t\treturn outlineMaterial;\n\n\t\t}\n\n\t\tfunction isCompatible( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\t\t\tvar hasNormals = false;\n\n\t\t\tif ( object.geometry !== undefined ) {\n\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\thasNormals = geometry.attributes.normal !== undefined;\n\n\t\t\t\t} else {\n\n\t\t\t\t\thasNormals = true; // the renderer always produces a normal attribute for Geometry\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn ( object.isMesh === true && object.material !== undefined && hasNormals === true );\n\n\t\t}\n\n\t\tfunction setOutlineMaterial( object ) {\n\n\t\t\tif ( isCompatible( object ) === false ) return;\n\n\t\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\t\tobject.material[ i ] = getOutlineMaterial( object.material[ i ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = getOutlineMaterial( object.material );\n\n\t\t\t}\n\n\t\t\toriginalOnBeforeRenders[ object.uuid ] = object.onBeforeRender;\n\t\t\tobject.onBeforeRender = onBeforeRender;\n\n\t\t}\n\n\t\tfunction restoreOriginalMaterial( object ) {\n\n\t\t\tif ( isCompatible( object ) === false ) return;\n\n\t\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\t\tobject.material[ i ] = originalMaterials[ object.material[ i ].uuid ];\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = originalMaterials[ object.material.uuid ];\n\n\t\t\t}\n\n\t\t\tobject.onBeforeRender = originalOnBeforeRenders[ object.uuid ];\n\n\t\t}\n\n\t\tfunction onBeforeRender( renderer, scene, camera, geometry, material ) {\n\n\t\t\tvar originalMaterial = originalMaterials[ material.uuid ];\n\n\t\t\t// just in case\n\t\t\tif ( originalMaterial === undefined ) return;\n\n\t\t\tupdateUniforms( material, originalMaterial );\n\n\t\t}\n\n\t\tfunction updateUniforms( material, originalMaterial ) {\n\n\t\t\tvar outlineParameters = originalMaterial.userData.outlineParameters;\n\n\t\t\tmaterial.uniforms.outlineAlpha.value = originalMaterial.opacity;\n\n\t\t\tif ( outlineParameters !== undefined ) {\n\n\t\t\t\tif ( outlineParameters.thickness !== undefined ) material.uniforms.outlineThickness.value = outlineParameters.thickness;\n\t\t\t\tif ( outlineParameters.color !== undefined ) material.uniforms.outlineColor.value.fromArray( outlineParameters.color );\n\t\t\t\tif ( outlineParameters.alpha !== undefined ) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n\n\t\t\t}\n\n\t\t\tif ( originalMaterial.displacementMap ) {\n\n\t\t\t\tmaterial.uniforms.displacementMap.value = originalMaterial.displacementMap;\n\t\t\t\tmaterial.uniforms.displacementScale.value = originalMaterial.displacementScale;\n\t\t\t\tmaterial.uniforms.displacementBias.value = originalMaterial.displacementBias;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction updateOutlineMaterial( material, originalMaterial ) {\n\n\t\t\tif ( material.name === 'invisible' ) return;\n\n\t\t\tvar outlineParameters = originalMaterial.userData.outlineParameters;\n\n\t\t\tmaterial.skinning = originalMaterial.skinning;\n\t\t\tmaterial.morphTargets = originalMaterial.morphTargets;\n\t\t\tmaterial.morphNormals = originalMaterial.morphNormals;\n\t\t\tmaterial.fog = originalMaterial.fog;\n\t\t\tmaterial.toneMapped = originalMaterial.toneMapped;\n\t\t\tmaterial.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n\t\t\tmaterial.displacementMap = originalMaterial.displacementMap;\n\n\t\t\tif ( outlineParameters !== undefined ) {\n\n\t\t\t\tif ( originalMaterial.visible === false ) {\n\n\t\t\t\t\tmaterial.visible = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial.visible = ( outlineParameters.visible !== undefined ) ? outlineParameters.visible : true;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.transparent = ( outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ) ? true : originalMaterial.transparent;\n\n\t\t\t\tif ( outlineParameters.keepAlive !== undefined ) cache[ originalMaterial.uuid ].keepAlive = outlineParameters.keepAlive;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.transparent = originalMaterial.transparent;\n\t\t\t\tmaterial.visible = originalMaterial.visible;\n\n\t\t\t}\n\n\t\t\tif ( originalMaterial.wireframe === true || originalMaterial.depthTest === false ) material.visible = false;\n\n\t\t\tif ( originalMaterial.clippingPlanes ) {\n\n\t\t\t\tmaterial.clipping = true;\n\n\t\t\t\tmaterial.clippingPlanes = originalMaterial.clippingPlanes;\n\t\t\t\tmaterial.clipIntersection = originalMaterial.clipIntersection;\n\t\t\t\tmaterial.clipShadows = originalMaterial.clipShadows;\n\n\t\t\t}\n\n\t\t\tmaterial.version = originalMaterial.version; // update outline material if necessary\n\n\t\t}\n\n\t\tfunction cleanupCache() {\n\n\t\t\tvar keys;\n\n\t\t\t// clear originialMaterials\n\t\t\tkeys = Object.keys( originalMaterials );\n\n\t\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\toriginalMaterials[ keys[ i ] ] = undefined;\n\n\t\t\t}\n\n\t\t\t// clear originalOnBeforeRenders\n\t\t\tkeys = Object.keys( originalOnBeforeRenders );\n\n\t\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\toriginalOnBeforeRenders[ keys[ i ] ] = undefined;\n\n\t\t\t}\n\n\t\t\t// remove unused outlineMaterial from cache\n\t\t\tkeys = Object.keys( cache );\n\n\t\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\t\tvar key = keys[ i ];\n\n\t\t\t\tif ( cache[ key ].used === false ) {\n\n\t\t\t\t\tcache[ key ].count ++;\n\n\t\t\t\t\tif ( cache[ key ].keepAlive === false && cache[ key ].count > removeThresholdCount ) {\n\n\t\t\t\t\t\tdelete cache[ key ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcache[ key ].used = false;\n\t\t\t\t\tcache[ key ].count = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tvar renderTarget;\n\t\t\tvar forceClear = false;\n\n\t\t\tif ( arguments[ 2 ] !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.OutlineEffect.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );\n\t\t\t\trenderTarget = arguments[ 2 ];\n\n\t\t\t}\n\n\t\t\tif ( arguments[ 3 ] !== undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.OutlineEffect.render(): the forceClear argument has been removed. Use .clear() instead.' );\n\t\t\t\tforceClear = arguments[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( renderTarget !== undefined ) renderer.setRenderTarget( renderTarget );\n\n\t\t\tif ( forceClear ) renderer.clear();\n\n\t\t\tif ( this.enabled === false ) {\n\n\t\t\t\trenderer.render( scene, camera );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar currentAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = this.autoClear;\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t\trenderer.autoClear = currentAutoClear;\n\n\t\t\tthis.renderOutline( scene, camera );\n\n\t\t};\n\n\t\tthis.renderOutline = function ( scene, camera ) {\n\n\t\t\tvar currentAutoClear = renderer.autoClear;\n\t\t\tvar currentSceneAutoUpdate = scene.autoUpdate;\n\t\t\tvar currentSceneBackground = scene.background;\n\t\t\tvar currentShadowMapEnabled = renderer.shadowMap.enabled;\n\n\t\t\tscene.autoUpdate = false;\n\t\t\tscene.background = null;\n\t\t\trenderer.autoClear = false;\n\t\t\trenderer.shadowMap.enabled = false;\n\n\t\t\tscene.traverse( setOutlineMaterial );\n\n\t\t\trenderer.render( scene, camera );\n\n\t\t\tscene.traverse( restoreOriginalMaterial );\n\n\t\t\tcleanupCache();\n\n\t\t\tscene.autoUpdate = currentSceneAutoUpdate;\n\t\t\tscene.background = currentSceneBackground;\n\t\t\trenderer.autoClear = currentAutoClear;\n\t\t\trenderer.shadowMap.enabled = currentShadowMapEnabled;\n\n\t\t};\n\n\t\t/*\n\t\t * See #9918\n\t\t *\n\t\t * The following property copies and wrapper methods enable\n\t\t * THREE.OutlineEffect to be called from other *Effect, like\n\t\t *\n\t\t * effect = new THREE.StereoEffect( new THREE.OutlineEffect( renderer ) );\n\t\t *\n\t\t * function render () {\n\t\t *\n\t \t * \teffect.render( scene, camera );\n\t\t *\n\t\t * }\n\t\t */\n\t\tthis.autoClear = renderer.autoClear;\n\t\tthis.domElement = renderer.domElement;\n\t\tthis.shadowMap = renderer.shadowMap;\n\n\t\tthis.clear = function ( color, depth, stencil ) {\n\n\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\n\t\t\treturn renderer.getPixelRatio();\n\n\t\t};\n\n\t\tthis.setPixelRatio = function ( value ) {\n\n\t\t\trenderer.setPixelRatio( value );\n\n\t\t};\n\n\t\tthis.getSize = function ( target ) {\n\n\t\t\treturn renderer.getSize( target );\n\n\t\t};\n\n\t\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t\trenderer.setSize( width, height, updateStyle );\n\n\t\t};\n\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t\trenderer.setViewport( x, y, width, height );\n\n\t\t};\n\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t\trenderer.setScissor( x, y, width, height );\n\n\t\t};\n\n\t\tthis.setScissorTest = function ( boolean ) {\n\n\t\t\trenderer.setScissorTest( boolean );\n\n\t\t};\n\n\t\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t};\n\n\t};\n\treturn THREE.OutlineEffect;\n});\n"]}