{"version":3,"sources":["effects/OutlineEffect.js"],"names":["define","THREE","threex","effects","OutlineEffect","renderer","parameters","this","enabled","defaultThickness","undefined","defaultColor","Color","fromArray","defaultAlpha","defaultKeepAlive","cache","removeThresholdCount","originalMaterials","originalOnBeforeRenders","uniformsOutline","outlineThickness","value","outlineColor","outlineAlpha","vertexShader","join","fragmentShader","getOutlineMaterialFromCache","originalMaterial","data","uuid","material","ShaderMaterial","type","uniforms","UniformsUtils","merge","UniformsLib","side","BackSide","used","keepAlive","count","getOutlineMaterial","outlineMaterial","name","outlineParameters","userData","skinning","morphTargets","morphNormals","fog","toneMapped","premultipliedAlpha","displacementMap","visible","transparent","alpha","wireframe","depthTest","clippingPlanes","clipping","clipIntersection","clipShadows","version","updateOutlineMaterial","isCompatible","object","geometry","hasNormals","isBufferGeometry","attributes","normal","isMesh","setOutlineMaterial","Array","isArray","i","il","length","onBeforeRender","restoreOriginalMaterial","scene","camera","opacity","thickness","color","displacementScale","displacementBias","updateUniforms","render","renderTarget","forceClear","arguments","console","warn","setRenderTarget","clear","currentAutoClear","autoClear","renderOutline","currentSceneAutoUpdate","autoUpdate","currentSceneBackground","background","currentShadowMapEnabled","shadowMap","traverse","keys","Object","key","cleanupCache","domElement","depth","stencil","getPixelRatio","setPixelRatio","getSize","target","setSize","width","height","updateStyle","setViewport","x","y","setScissor","setScissorTest","boolean"],"mappings":"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","file":"../../effects/OutlineEffect.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var OutlineEffect = function (renderer, parameters) {\r\n        parameters = parameters || {};\r\n        this.enabled = true;\r\n        var defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\r\n        var defaultColor = new THREE.Color().fromArray(parameters.defaultColor !== undefined ? parameters.defaultColor : [\r\n            0,\r\n            0,\r\n            0\r\n        ]);\r\n        var defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1;\r\n        var defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false;\r\n        var cache = {};\r\n        var removeThresholdCount = 60;\r\n        var originalMaterials = {};\r\n        var originalOnBeforeRenders = {};\r\n        var uniformsOutline = {\r\n            outlineThickness: { value: defaultThickness },\r\n            outlineColor: { value: defaultColor },\r\n            outlineAlpha: { value: defaultAlpha }\r\n        };\r\n        var vertexShader = [\r\n            '#include <common>',\r\n            '#include <uv_pars_vertex>',\r\n            '#include <displacementmap_pars_vertex>',\r\n            '#include <fog_pars_vertex>',\r\n            '#include <morphtarget_pars_vertex>',\r\n            '#include <skinning_pars_vertex>',\r\n            '#include <logdepthbuf_pars_vertex>',\r\n            '#include <clipping_planes_pars_vertex>',\r\n            'uniform float outlineThickness;',\r\n            'vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {',\r\n            '\\tfloat thickness = outlineThickness;',\r\n            '\\tconst float ratio = 1.0;',\r\n            '\\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );',\r\n            '\\tvec4 norm = normalize( pos - pos2 );',\r\n            '\\treturn pos + norm * thickness * pos.w * ratio;',\r\n            '}',\r\n            'void main() {',\r\n            '\\t#include <uv_vertex>',\r\n            '\\t#include <beginnormal_vertex>',\r\n            '\\t#include <morphnormal_vertex>',\r\n            '\\t#include <skinbase_vertex>',\r\n            '\\t#include <skinnormal_vertex>',\r\n            '\\t#include <begin_vertex>',\r\n            '\\t#include <morphtarget_vertex>',\r\n            '\\t#include <skinning_vertex>',\r\n            '\\t#include <displacementmap_vertex>',\r\n            '\\t#include <project_vertex>',\r\n            '\\tvec3 outlineNormal = - objectNormal;',\r\n            '\\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );',\r\n            '\\t#include <logdepthbuf_vertex>',\r\n            '\\t#include <clipping_planes_vertex>',\r\n            '\\t#include <fog_vertex>',\r\n            '}'\r\n        ].join('\\n');\r\n        var fragmentShader = [\r\n            '#include <common>',\r\n            '#include <fog_pars_fragment>',\r\n            '#include <logdepthbuf_pars_fragment>',\r\n            '#include <clipping_planes_pars_fragment>',\r\n            'uniform vec3 outlineColor;',\r\n            'uniform float outlineAlpha;',\r\n            'void main() {',\r\n            '\\t#include <clipping_planes_fragment>',\r\n            '\\t#include <logdepthbuf_fragment>',\r\n            '\\tgl_FragColor = vec4( outlineColor, outlineAlpha );',\r\n            '\\t#include <tonemapping_fragment>',\r\n            '\\t#include <encodings_fragment>',\r\n            '\\t#include <fog_fragment>',\r\n            '\\t#include <premultiplied_alpha_fragment>',\r\n            '}'\r\n        ].join('\\n');\r\n        function createMaterial() {\r\n            return new THREE.ShaderMaterial({\r\n                type: 'OutlineEffect',\r\n                uniforms: THREE.UniformsUtils.merge([\r\n                    THREE.UniformsLib['fog'],\r\n                    THREE.UniformsLib['displacementmap'],\r\n                    uniformsOutline\r\n                ]),\r\n                vertexShader: vertexShader,\r\n                fragmentShader: fragmentShader,\r\n                side: THREE.BackSide\r\n            });\r\n        }\r\n        function getOutlineMaterialFromCache(originalMaterial) {\r\n            var data = cache[originalMaterial.uuid];\r\n            if (data === undefined) {\r\n                data = {\r\n                    material: createMaterial(),\r\n                    used: true,\r\n                    keepAlive: defaultKeepAlive,\r\n                    count: 0\r\n                };\r\n                cache[originalMaterial.uuid] = data;\r\n            }\r\n            data.used = true;\r\n            return data.material;\r\n        }\r\n        function getOutlineMaterial(originalMaterial) {\r\n            var outlineMaterial = getOutlineMaterialFromCache(originalMaterial);\r\n            originalMaterials[outlineMaterial.uuid] = originalMaterial;\r\n            updateOutlineMaterial(outlineMaterial, originalMaterial);\r\n            return outlineMaterial;\r\n        }\r\n        function isCompatible(object) {\r\n            var geometry = object.geometry;\r\n            var hasNormals = false;\r\n            if (object.geometry !== undefined) {\r\n                if (geometry.isBufferGeometry) {\r\n                    hasNormals = geometry.attributes.normal !== undefined;\r\n                } else {\r\n                    hasNormals = true;\r\n                }\r\n            }\r\n            return object.isMesh === true && object.material !== undefined && hasNormals === true;\r\n        }\r\n        function setOutlineMaterial(object) {\r\n            if (isCompatible(object) === false)\r\n                return;\r\n            if (Array.isArray(object.material)) {\r\n                for (var i = 0, il = object.material.length; i < il; i++) {\r\n                    object.material[i] = getOutlineMaterial(object.material[i]);\r\n                }\r\n            } else {\r\n                object.material = getOutlineMaterial(object.material);\r\n            }\r\n            originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\r\n            object.onBeforeRender = onBeforeRender;\r\n        }\r\n        function restoreOriginalMaterial(object) {\r\n            if (isCompatible(object) === false)\r\n                return;\r\n            if (Array.isArray(object.material)) {\r\n                for (var i = 0, il = object.material.length; i < il; i++) {\r\n                    object.material[i] = originalMaterials[object.material[i].uuid];\r\n                }\r\n            } else {\r\n                object.material = originalMaterials[object.material.uuid];\r\n            }\r\n            object.onBeforeRender = originalOnBeforeRenders[object.uuid];\r\n        }\r\n        function onBeforeRender(renderer, scene, camera, geometry, material) {\r\n            var originalMaterial = originalMaterials[material.uuid];\r\n            if (originalMaterial === undefined)\r\n                return;\r\n            updateUniforms(material, originalMaterial);\r\n        }\r\n        function updateUniforms(material, originalMaterial) {\r\n            var outlineParameters = originalMaterial.userData.outlineParameters;\r\n            material.uniforms.outlineAlpha.value = originalMaterial.opacity;\r\n            if (outlineParameters !== undefined) {\r\n                if (outlineParameters.thickness !== undefined)\r\n                    material.uniforms.outlineThickness.value = outlineParameters.thickness;\r\n                if (outlineParameters.color !== undefined)\r\n                    material.uniforms.outlineColor.value.fromArray(outlineParameters.color);\r\n                if (outlineParameters.alpha !== undefined)\r\n                    material.uniforms.outlineAlpha.value = outlineParameters.alpha;\r\n            }\r\n            if (originalMaterial.displacementMap) {\r\n                material.uniforms.displacementMap.value = originalMaterial.displacementMap;\r\n                material.uniforms.displacementScale.value = originalMaterial.displacementScale;\r\n                material.uniforms.displacementBias.value = originalMaterial.displacementBias;\r\n            }\r\n        }\r\n        function updateOutlineMaterial(material, originalMaterial) {\r\n            if (material.name === 'invisible')\r\n                return;\r\n            var outlineParameters = originalMaterial.userData.outlineParameters;\r\n            material.skinning = originalMaterial.skinning;\r\n            material.morphTargets = originalMaterial.morphTargets;\r\n            material.morphNormals = originalMaterial.morphNormals;\r\n            material.fog = originalMaterial.fog;\r\n            material.toneMapped = originalMaterial.toneMapped;\r\n            material.premultipliedAlpha = originalMaterial.premultipliedAlpha;\r\n            material.displacementMap = originalMaterial.displacementMap;\r\n            if (outlineParameters !== undefined) {\r\n                if (originalMaterial.visible === false) {\r\n                    material.visible = false;\r\n                } else {\r\n                    material.visible = outlineParameters.visible !== undefined ? outlineParameters.visible : true;\r\n                }\r\n                material.transparent = outlineParameters.alpha !== undefined && outlineParameters.alpha < 1 ? true : originalMaterial.transparent;\r\n                if (outlineParameters.keepAlive !== undefined)\r\n                    cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\r\n            } else {\r\n                material.transparent = originalMaterial.transparent;\r\n                material.visible = originalMaterial.visible;\r\n            }\r\n            if (originalMaterial.wireframe === true || originalMaterial.depthTest === false)\r\n                material.visible = false;\r\n            if (originalMaterial.clippingPlanes) {\r\n                material.clipping = true;\r\n                material.clippingPlanes = originalMaterial.clippingPlanes;\r\n                material.clipIntersection = originalMaterial.clipIntersection;\r\n                material.clipShadows = originalMaterial.clipShadows;\r\n            }\r\n            material.version = originalMaterial.version;\r\n        }\r\n        function cleanupCache() {\r\n            var keys;\r\n            keys = Object.keys(originalMaterials);\r\n            for (var i = 0, il = keys.length; i < il; i++) {\r\n                originalMaterials[keys[i]] = undefined;\r\n            }\r\n            keys = Object.keys(originalOnBeforeRenders);\r\n            for (var i = 0, il = keys.length; i < il; i++) {\r\n                originalOnBeforeRenders[keys[i]] = undefined;\r\n            }\r\n            keys = Object.keys(cache);\r\n            for (var i = 0, il = keys.length; i < il; i++) {\r\n                var key = keys[i];\r\n                if (cache[key].used === false) {\r\n                    cache[key].count++;\r\n                    if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {\r\n                        delete cache[key];\r\n                    }\r\n                } else {\r\n                    cache[key].used = false;\r\n                    cache[key].count = 0;\r\n                }\r\n            }\r\n        }\r\n        this.render = function (scene, camera) {\r\n            var renderTarget;\r\n            var forceClear = false;\r\n            if (arguments[2] !== undefined) {\r\n                console.warn('THREE.OutlineEffect.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');\r\n                renderTarget = arguments[2];\r\n            }\r\n            if (arguments[3] !== undefined) {\r\n                console.warn('THREE.OutlineEffect.render(): the forceClear argument has been removed. Use .clear() instead.');\r\n                forceClear = arguments[3];\r\n            }\r\n            if (renderTarget !== undefined)\r\n                renderer.setRenderTarget(renderTarget);\r\n            if (forceClear)\r\n                renderer.clear();\r\n            if (this.enabled === false) {\r\n                renderer.render(scene, camera);\r\n                return;\r\n            }\r\n            var currentAutoClear = renderer.autoClear;\r\n            renderer.autoClear = this.autoClear;\r\n            renderer.render(scene, camera);\r\n            renderer.autoClear = currentAutoClear;\r\n            this.renderOutline(scene, camera);\r\n        };\r\n        this.renderOutline = function (scene, camera) {\r\n            var currentAutoClear = renderer.autoClear;\r\n            var currentSceneAutoUpdate = scene.autoUpdate;\r\n            var currentSceneBackground = scene.background;\r\n            var currentShadowMapEnabled = renderer.shadowMap.enabled;\r\n            scene.autoUpdate = false;\r\n            scene.background = null;\r\n            renderer.autoClear = false;\r\n            renderer.shadowMap.enabled = false;\r\n            scene.traverse(setOutlineMaterial);\r\n            renderer.render(scene, camera);\r\n            scene.traverse(restoreOriginalMaterial);\r\n            cleanupCache();\r\n            scene.autoUpdate = currentSceneAutoUpdate;\r\n            scene.background = currentSceneBackground;\r\n            renderer.autoClear = currentAutoClear;\r\n            renderer.shadowMap.enabled = currentShadowMapEnabled;\r\n        };\r\n        this.autoClear = renderer.autoClear;\r\n        this.domElement = renderer.domElement;\r\n        this.shadowMap = renderer.shadowMap;\r\n        this.clear = function (color, depth, stencil) {\r\n            renderer.clear(color, depth, stencil);\r\n        };\r\n        this.getPixelRatio = function () {\r\n            return renderer.getPixelRatio();\r\n        };\r\n        this.setPixelRatio = function (value) {\r\n            renderer.setPixelRatio(value);\r\n        };\r\n        this.getSize = function (target) {\r\n            return renderer.getSize(target);\r\n        };\r\n        this.setSize = function (width, height, updateStyle) {\r\n            renderer.setSize(width, height, updateStyle);\r\n        };\r\n        this.setViewport = function (x, y, width, height) {\r\n            renderer.setViewport(x, y, width, height);\r\n        };\r\n        this.setScissor = function (x, y, width, height) {\r\n            renderer.setScissor(x, y, width, height);\r\n        };\r\n        this.setScissorTest = function (boolean) {\r\n            renderer.setScissorTest(boolean);\r\n        };\r\n        this.setRenderTarget = function (renderTarget) {\r\n            renderer.setRenderTarget(renderTarget);\r\n        };\r\n    };\r\n\r\n    return threex.effects.OutlineEffect = OutlineEffect;\r\n});"]}