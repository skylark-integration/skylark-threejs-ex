{"version":3,"sources":["modifiers/SubdivisionModifier.js"],"names":["define","THREE","SubdivisionModifier","subdivisions","this","undefined","prototype","modify","geometry","isBufferGeometry","Geometry","fromBufferGeometry","clone","mergeVertices","repeats","smooth","computeFaceNormals","computeVertexNormals","ABC","getEdge","a","b","map","Math","min","max","processEdge","vertices","face","metaVertices","edge","vertexIndexA","vertexIndexB","key","newEdge","faces","push","edges","newFace","newFaces","c","materialIndex","Face3","midpoint","abs","newUv","newUvs","oldVertices","oldFaces","oldUvs","newVertices","n","i","il","k","sourceEdges","newEdgeVertices","newSourceVertices","tmp","Vector3","newUVs","other","currentEdge","edgeVertexWeight","adjacentVertexWeight","connectedFaces","beta","sourceVertexWeight","connectingVertexWeight","connectingEdge","connectingEdges","oldVertex","newSourceVertex","hasUvs","faceVertexUvs","length","j","generateLookups","Array","addVectors","multiplyScalar","set","add","concat","edge1","edge2","edge3","uv","x0","x1","x2","sl","x3","Vector2","x4","x5","x","y"],"mappings":"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","file":"../../modifiers/SubdivisionModifier.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n\t *\t@author centerionware / http://www.centerionware.com\n\t *\n\t *\tSubdivision Geometry Modifier\n\t *\t\tusing Loop Subdivision Scheme\n\t *\n\t *\tReferences:\n\t *\t\thttp://graphics.stanford.edu/~mdfisher/subdivision.html\n\t *\t\thttp://www.holmes3d.net/graphics/subdivision/\n\t *\t\thttp://www.cs.rutgers.edu/~decarlo/readings/subdiv-sg00c.pdf\n\t *\n\t *\tKnown Issues:\n\t *\t\t- currently doesn't handle \"Sharp Edges\"\n\t */\n\n\tTHREE.SubdivisionModifier = function ( subdivisions ) {\n\n\t\tthis.subdivisions = ( subdivisions === undefined ) ? 1 : subdivisions;\n\n\t};\n\n\t// Applies the \"modify\" pattern\n\tTHREE.SubdivisionModifier.prototype.modify = function ( geometry ) {\n\n\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry( geometry );\n\n\t\t} else {\n\n\t\t\tgeometry = geometry.clone();\n\n\t\t}\n\n\t\tgeometry.mergeVertices();\n\n\t\tvar repeats = this.subdivisions;\n\n\t\twhile ( repeats -- > 0 ) {\n\n\t\t\tthis.smooth( geometry );\n\n\t\t}\n\n\t\tgeometry.computeFaceNormals();\n\t\tgeometry.computeVertexNormals();\n\n\t\treturn geometry;\n\n\t};\n\n\t( function () {\n\n\t\t// Some constants\n\t\tvar ABC = [ 'a', 'b', 'c' ];\n\n\n\t\tfunction getEdge( a, b, map ) {\n\n\t\t\tvar vertexIndexA = Math.min( a, b );\n\t\t\tvar vertexIndexB = Math.max( a, b );\n\n\t\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\n\n\t\t\treturn map[ key ];\n\n\t\t}\n\n\n\t\tfunction processEdge( a, b, vertices, map, face, metaVertices ) {\n\n\t\t\tvar vertexIndexA = Math.min( a, b );\n\t\t\tvar vertexIndexB = Math.max( a, b );\n\n\t\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\n\n\t\t\tvar edge;\n\n\t\t\tif ( key in map ) {\n\n\t\t\t\tedge = map[ key ];\n\n\t\t\t} else {\n\n\t\t\t\tvar vertexA = vertices[ vertexIndexA ];\n\t\t\t\tvar vertexB = vertices[ vertexIndexB ];\n\n\t\t\t\tedge = {\n\n\t\t\t\t\ta: vertexA, // pointer reference\n\t\t\t\t\tb: vertexB,\n\t\t\t\t\tnewEdge: null,\n\t\t\t\t\t// aIndex: a, // numbered reference\n\t\t\t\t\t// bIndex: b,\n\t\t\t\t\tfaces: [] // pointers to face\n\n\t\t\t\t};\n\n\t\t\t\tmap[ key ] = edge;\n\n\t\t\t}\n\n\t\t\tedge.faces.push( face );\n\n\t\t\tmetaVertices[ a ].edges.push( edge );\n\t\t\tmetaVertices[ b ].edges.push( edge );\n\n\n\t\t}\n\n\t\tfunction generateLookups( vertices, faces, metaVertices, edges ) {\n\n\t\t\tvar i, il, face;\n\n\t\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tmetaVertices[ i ] = { edges: [] };\n\n\t\t\t}\n\n\t\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\n\t\t\t\tprocessEdge( face.a, face.b, vertices, edges, face, metaVertices );\n\t\t\t\tprocessEdge( face.b, face.c, vertices, edges, face, metaVertices );\n\t\t\t\tprocessEdge( face.c, face.a, vertices, edges, face, metaVertices );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction newFace( newFaces, a, b, c, materialIndex ) {\n\n\t\t\tnewFaces.push( new THREE.Face3( a, b, c, undefined, undefined, materialIndex ) );\n\n\t\t}\n\n\t\tfunction midpoint( a, b ) {\n\n\t\t\treturn ( Math.abs( b - a ) / 2 ) + Math.min( a, b );\n\n\t\t}\n\n\t\tfunction newUv( newUvs, a, b, c ) {\n\n\t\t\tnewUvs.push( [ a.clone(), b.clone(), c.clone() ] );\n\n\t\t}\n\n\t\t/////////////////////////////\n\n\t\t// Performs one iteration of Subdivision\n\t\tTHREE.SubdivisionModifier.prototype.smooth = function ( geometry ) {\n\n\t\t\tvar tmp = new THREE.Vector3();\n\n\t\t\tvar oldVertices, oldFaces, oldUvs;\n\t\t\tvar newVertices, newFaces, newUVs = [];\n\n\t\t\tvar n, i, il, j, k;\n\t\t\tvar metaVertices, sourceEdges;\n\n\t\t\t// new stuff.\n\t\t\tvar sourceEdges, newEdgeVertices, newSourceVertices;\n\n\t\t\toldVertices = geometry.vertices; // { x, y, z}\n\t\t\toldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }\n\t\t\toldUvs = geometry.faceVertexUvs;\n\n\t\t\tvar hasUvs = oldUvs[ 0 ] !== undefined && oldUvs[ 0 ].length > 0;\n\n\t\t\tif ( hasUvs ) {\n\n\t\t\t\tfor ( var j = 0; j < oldUvs.length; j ++ ) {\n\n\t\t\t\t\tnewUVs.push( [] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/******************************************************\n\t\t\t *\n\t\t\t * Step 0: Preprocess Geometry to Generate edges Lookup\n\t\t\t *\n\t\t\t *******************************************************/\n\n\t\t\tmetaVertices = new Array( oldVertices.length );\n\t\t\tsourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }\n\n\t\t\tgenerateLookups( oldVertices, oldFaces, metaVertices, sourceEdges );\n\n\n\t\t\t/******************************************************\n\t\t\t *\n\t\t\t *\tStep 1.\n\t\t\t *\tFor each edge, create a new Edge Vertex,\n\t\t\t *\tthen position it.\n\t\t\t *\n\t\t\t *******************************************************/\n\n\t\t\tnewEdgeVertices = [];\n\t\t\tvar other, currentEdge, newEdge, face;\n\t\t\tvar edgeVertexWeight, adjacentVertexWeight, connectedFaces;\n\n\t\t\tfor ( i in sourceEdges ) {\n\n\t\t\t\tcurrentEdge = sourceEdges[ i ];\n\t\t\t\tnewEdge = new THREE.Vector3();\n\n\t\t\t\tedgeVertexWeight = 3 / 8;\n\t\t\t\tadjacentVertexWeight = 1 / 8;\n\n\t\t\t\tconnectedFaces = currentEdge.faces.length;\n\n\t\t\t\t// check how many linked faces. 2 should be correct.\n\t\t\t\tif ( connectedFaces != 2 ) {\n\n\t\t\t\t\t// if length is not 2, handle condition\n\t\t\t\t\tedgeVertexWeight = 0.5;\n\t\t\t\t\tadjacentVertexWeight = 0;\n\n\t\t\t\t\tif ( connectedFaces != 1 ) {\n\n\t\t\t\t\t\t// console.warn( 'Subdivision Modifier: Number of connected faces != 2, is: ', connectedFaces, currentEdge );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnewEdge.addVectors( currentEdge.a, currentEdge.b ).multiplyScalar( edgeVertexWeight );\n\n\t\t\t\ttmp.set( 0, 0, 0 );\n\n\t\t\t\tfor ( j = 0; j < connectedFaces; j ++ ) {\n\n\t\t\t\t\tface = currentEdge.faces[ j ];\n\n\t\t\t\t\tfor ( k = 0; k < 3; k ++ ) {\n\n\t\t\t\t\t\tother = oldVertices[ face[ ABC[ k ] ] ];\n\t\t\t\t\t\tif ( other !== currentEdge.a && other !== currentEdge.b ) break;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttmp.add( other );\n\n\t\t\t\t}\n\n\t\t\t\ttmp.multiplyScalar( adjacentVertexWeight );\n\t\t\t\tnewEdge.add( tmp );\n\n\t\t\t\tcurrentEdge.newEdge = newEdgeVertices.length;\n\t\t\t\tnewEdgeVertices.push( newEdge );\n\n\t\t\t\t// console.log(currentEdge, newEdge);\n\n\t\t\t}\n\n\t\t\t/******************************************************\n\t\t\t *\n\t\t\t *\tStep 2.\n\t\t\t *\tReposition each source vertices.\n\t\t\t *\n\t\t\t *******************************************************/\n\n\t\t\tvar beta, sourceVertexWeight, connectingVertexWeight;\n\t\t\tvar connectingEdge, connectingEdges, oldVertex, newSourceVertex;\n\t\t\tnewSourceVertices = [];\n\n\t\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\n\n\t\t\t\toldVertex = oldVertices[ i ];\n\n\t\t\t\t// find all connecting edges (using lookupTable)\n\t\t\t\tconnectingEdges = metaVertices[ i ].edges;\n\t\t\t\tn = connectingEdges.length;\n\n\t\t\t\tif ( n == 3 ) {\n\n\t\t\t\t\tbeta = 3 / 16;\n\n\t\t\t\t} else if ( n > 3 ) {\n\n\t\t\t\t\tbeta = 3 / ( 8 * n ); // Warren's modified formula\n\n\t\t\t\t}\n\n\t\t\t\t// Loop's original beta formula\n\t\t\t\t// beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );\n\n\t\t\t\tsourceVertexWeight = 1 - n * beta;\n\t\t\t\tconnectingVertexWeight = beta;\n\n\t\t\t\tif ( n <= 2 ) {\n\n\t\t\t\t\t// crease and boundary rules\n\t\t\t\t\t// console.warn('crease and boundary rules');\n\n\t\t\t\t\tif ( n == 2 ) {\n\n\t\t\t\t\t\t// console.warn( '2 connecting edges', connectingEdges );\n\t\t\t\t\t\tsourceVertexWeight = 3 / 4;\n\t\t\t\t\t\tconnectingVertexWeight = 1 / 8;\n\n\t\t\t\t\t\t// sourceVertexWeight = 1;\n\t\t\t\t\t\t// connectingVertexWeight = 0;\n\n\t\t\t\t\t} else if ( n == 1 ) {\n\n\t\t\t\t\t\t// console.warn( 'only 1 connecting edge' );\n\n\t\t\t\t\t} else if ( n == 0 ) {\n\n\t\t\t\t\t\t// console.warn( '0 connecting edges' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnewSourceVertex = oldVertex.clone().multiplyScalar( sourceVertexWeight );\n\n\t\t\t\ttmp.set( 0, 0, 0 );\n\n\t\t\t\tfor ( j = 0; j < n; j ++ ) {\n\n\t\t\t\t\tconnectingEdge = connectingEdges[ j ];\n\t\t\t\t\tother = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\n\t\t\t\t\ttmp.add( other );\n\n\t\t\t\t}\n\n\t\t\t\ttmp.multiplyScalar( connectingVertexWeight );\n\t\t\t\tnewSourceVertex.add( tmp );\n\n\t\t\t\tnewSourceVertices.push( newSourceVertex );\n\n\t\t\t}\n\n\n\t\t\t/******************************************************\n\t\t\t *\n\t\t\t *\tStep 3.\n\t\t\t *\tGenerate Faces between source vertices\n\t\t\t *\tand edge vertices.\n\t\t\t *\n\t\t\t *******************************************************/\n\n\t\t\tnewVertices = newSourceVertices.concat( newEdgeVertices );\n\t\t\tvar sl = newSourceVertices.length, edge1, edge2, edge3;\n\t\t\tnewFaces = [];\n\n\t\t\tvar uv, x0, x1, x2;\n\t\t\tvar x3 = new THREE.Vector2();\n\t\t\tvar x4 = new THREE.Vector2();\n\t\t\tvar x5 = new THREE.Vector2();\n\n\t\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\n\n\t\t\t\tface = oldFaces[ i ];\n\n\t\t\t\t// find the 3 new edges vertex of each old face\n\n\t\t\t\tedge1 = getEdge( face.a, face.b, sourceEdges ).newEdge + sl;\n\t\t\t\tedge2 = getEdge( face.b, face.c, sourceEdges ).newEdge + sl;\n\t\t\t\tedge3 = getEdge( face.c, face.a, sourceEdges ).newEdge + sl;\n\n\t\t\t\t// create 4 faces.\n\n\t\t\t\tnewFace( newFaces, edge1, edge2, edge3, face.materialIndex );\n\t\t\t\tnewFace( newFaces, face.a, edge1, edge3, face.materialIndex );\n\t\t\t\tnewFace( newFaces, face.b, edge2, edge1, face.materialIndex );\n\t\t\t\tnewFace( newFaces, face.c, edge3, edge2, face.materialIndex );\n\n\t\t\t\t// create 4 new uv's\n\n\t\t\t\tif ( hasUvs ) {\n\n\t\t\t\t\tfor ( var j = 0; j < oldUvs.length; j ++ ) {\n\n\t\t\t\t\t\tuv = oldUvs[ j ][ i ];\n\n\t\t\t\t\t\tx0 = uv[ 0 ];\n\t\t\t\t\t\tx1 = uv[ 1 ];\n\t\t\t\t\t\tx2 = uv[ 2 ];\n\n\t\t\t\t\t\tx3.set( midpoint( x0.x, x1.x ), midpoint( x0.y, x1.y ) );\n\t\t\t\t\t\tx4.set( midpoint( x1.x, x2.x ), midpoint( x1.y, x2.y ) );\n\t\t\t\t\t\tx5.set( midpoint( x0.x, x2.x ), midpoint( x0.y, x2.y ) );\n\n\t\t\t\t\t\tnewUv( newUVs[ j ], x3, x4, x5 );\n\t\t\t\t\t\tnewUv( newUVs[ j ], x0, x3, x5 );\n\n\t\t\t\t\t\tnewUv( newUVs[ j ], x1, x4, x3 );\n\t\t\t\t\t\tnewUv( newUVs[ j ], x2, x5, x4 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Overwrite old arrays\n\t\t\tgeometry.vertices = newVertices;\n\t\t\tgeometry.faces = newFaces;\n\t\t\tif ( hasUvs ) geometry.faceVertexUvs = newUVs;\n\n\t\t\t// console.log('done');\n\n\t\t};\n\n\t} )();\n\t\n\treturn THREE.SubdivisionModifier;\n});\n"]}