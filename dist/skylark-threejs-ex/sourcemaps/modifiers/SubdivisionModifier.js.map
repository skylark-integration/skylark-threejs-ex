{"version":3,"sources":["modifiers/SubdivisionModifier.js"],"names":["define","THREE","threex","SubdivisionModifier","subdivisions","this","undefined","prototype","modify","geometry","isBufferGeometry","Geometry","fromBufferGeometry","clone","mergeVertices","repeats","smooth","computeFaceNormals","computeVertexNormals","ABC","getEdge","a","b","map","Math","min","max","processEdge","vertices","face","metaVertices","edge","vertexIndexA","vertexIndexB","key","newEdge","faces","push","edges","newFace","newFaces","c","materialIndex","Face3","midpoint","abs","newUv","newUvs","oldVertices","oldFaces","oldUvs","newVertices","n","i","il","k","sourceEdges","newEdgeVertices","newSourceVertices","tmp","Vector3","newUVs","other","currentEdge","edgeVertexWeight","adjacentVertexWeight","connectedFaces","beta","sourceVertexWeight","connectingVertexWeight","connectingEdge","connectingEdges","oldVertex","newSourceVertex","hasUvs","faceVertexUvs","length","j","generateLookups","Array","addVectors","multiplyScalar","set","add","concat","edge1","edge2","edge3","uv","x0","x1","x2","sl","x3","Vector2","x4","x5","x","y","modifiers"],"mappings":"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","file":"../../modifiers/SubdivisionModifier.js","sourcesContent":["define([\r\n    \"skylark-threejs\",\r\n    \"../threex\"\r\n], function (\r\n    THREE,\r\n    threex\r\n) {\r\n    'use strict';\r\n    var SubdivisionModifier = function (subdivisions) {\r\n        this.subdivisions = subdivisions === undefined ? 1 : subdivisions;\r\n    };\r\n    SubdivisionModifier.prototype.modify = function (geometry) {\r\n        if (geometry.isBufferGeometry) {\r\n            geometry = new THREE.Geometry().fromBufferGeometry(geometry);\r\n        } else {\r\n            geometry = geometry.clone();\r\n        }\r\n        geometry.mergeVertices();\r\n        var repeats = this.subdivisions;\r\n        while (repeats-- > 0) {\r\n            this.smooth(geometry);\r\n        }\r\n        geometry.computeFaceNormals();\r\n        geometry.computeVertexNormals();\r\n        return geometry;\r\n    };\r\n    (function () {\r\n        var ABC = [\r\n            'a',\r\n            'b',\r\n            'c'\r\n        ];\r\n        function getEdge(a, b, map) {\r\n            var vertexIndexA = Math.min(a, b);\r\n            var vertexIndexB = Math.max(a, b);\r\n            var key = vertexIndexA + '_' + vertexIndexB;\r\n            return map[key];\r\n        }\r\n        function processEdge(a, b, vertices, map, face, metaVertices) {\r\n            var vertexIndexA = Math.min(a, b);\r\n            var vertexIndexB = Math.max(a, b);\r\n            var key = vertexIndexA + '_' + vertexIndexB;\r\n            var edge;\r\n            if (key in map) {\r\n                edge = map[key];\r\n            } else {\r\n                var vertexA = vertices[vertexIndexA];\r\n                var vertexB = vertices[vertexIndexB];\r\n                edge = {\r\n                    a: vertexA,\r\n                    b: vertexB,\r\n                    newEdge: null,\r\n                    faces: []\r\n                };\r\n                map[key] = edge;\r\n            }\r\n            edge.faces.push(face);\r\n            metaVertices[a].edges.push(edge);\r\n            metaVertices[b].edges.push(edge);\r\n        }\r\n        function generateLookups(vertices, faces, metaVertices, edges) {\r\n            var i, il, face;\r\n            for (i = 0, il = vertices.length; i < il; i++) {\r\n                metaVertices[i] = { edges: [] };\r\n            }\r\n            for (i = 0, il = faces.length; i < il; i++) {\r\n                face = faces[i];\r\n                processEdge(face.a, face.b, vertices, edges, face, metaVertices);\r\n                processEdge(face.b, face.c, vertices, edges, face, metaVertices);\r\n                processEdge(face.c, face.a, vertices, edges, face, metaVertices);\r\n            }\r\n        }\r\n        function newFace(newFaces, a, b, c, materialIndex) {\r\n            newFaces.push(new THREE.Face3(a, b, c, undefined, undefined, materialIndex));\r\n        }\r\n        function midpoint(a, b) {\r\n            return Math.abs(b - a) / 2 + Math.min(a, b);\r\n        }\r\n        function newUv(newUvs, a, b, c) {\r\n            newUvs.push([\r\n                THREE.clone(),\r\n                b.clone(),\r\n                c.clone()\r\n            ]);\r\n        }\r\n        SubdivisionModifier.prototype.smooth = function (geometry) {\r\n            var tmp = new THREE.Vector3();\r\n            var oldVertices, oldFaces, oldUvs;\r\n            var newVertices, newFaces, newUVs = [];\r\n            var n, i, il, j, k;\r\n            var metaVertices, sourceEdges;\r\n            var sourceEdges, newEdgeVertices, newSourceVertices;\r\n            oldVertices = geometry.vertices;\r\n            oldFaces = geometry.faces;\r\n            oldUvs = geometry.faceVertexUvs;\r\n            var hasUvs = oldUvs[0] !== undefined && oldUvs[0].length > 0;\r\n            if (hasUvs) {\r\n                for (var j = 0; j < oldUvs.length; j++) {\r\n                    newUVs.push([]);\r\n                }\r\n            }\r\n            metaVertices = new Array(oldVertices.length);\r\n            sourceEdges = {};\r\n            generateLookups(oldVertices, oldFaces, metaVertices, sourceEdges);\r\n            newEdgeVertices = [];\r\n            var other, currentEdge, newEdge, face;\r\n            var edgeVertexWeight, adjacentVertexWeight, connectedFaces;\r\n            for (i in sourceEdges) {\r\n                currentEdge = sourceEdges[i];\r\n                newEdge = new THREE.Vector3();\r\n                edgeVertexWeight = 3 / 8;\r\n                adjacentVertexWeight = 1 / 8;\r\n                connectedFaces = currentEdge.faces.length;\r\n                if (connectedFaces != 2) {\r\n                    edgeVertexWeight = 0.5;\r\n                    adjacentVertexWeight = 0;\r\n                    if (connectedFaces != 1) {\r\n                    }\r\n                }\r\n                newEdge.addVectors(currentEdge.a, currentEdge.b).multiplyScalar(edgeVertexWeight);\r\n                tmp.set(0, 0, 0);\r\n                for (j = 0; j < connectedFaces; j++) {\r\n                    face = currentEdge.faces[j];\r\n                    for (k = 0; k < 3; k++) {\r\n                        other = oldVertices[face[ABC[k]]];\r\n                        if (other !== currentEdge.a && other !== currentEdge.b)\r\n                            break;\r\n                    }\r\n                    tmp.add(other);\r\n                }\r\n                tmp.multiplyScalar(adjacentVertexWeight);\r\n                newEdge.add(tmp);\r\n                currentEdge.newEdge = newEdgeVertices.length;\r\n                newEdgeVertices.push(newEdge);\r\n            }\r\n            var beta, sourceVertexWeight, connectingVertexWeight;\r\n            var connectingEdge, connectingEdges, oldVertex, newSourceVertex;\r\n            newSourceVertices = [];\r\n            for (i = 0, il = oldVertices.length; i < il; i++) {\r\n                oldVertex = oldVertices[i];\r\n                connectingEdges = metaVertices[i].edges;\r\n                n = connectingEdges.length;\r\n                if (n == 3) {\r\n                    beta = 3 / 16;\r\n                } else if (n > 3) {\r\n                    beta = 3 / (8 * n);\r\n                }\r\n                sourceVertexWeight = 1 - n * beta;\r\n                connectingVertexWeight = beta;\r\n                if (n <= 2) {\r\n                    if (n == 2) {\r\n                        sourceVertexWeight = 3 / 4;\r\n                        connectingVertexWeight = 1 / 8;\r\n                    } else if (n == 1) {\r\n                    } else if (n == 0) {\r\n                    }\r\n                }\r\n                newSourceVertex = oldVertex.clone().multiplyScalar(sourceVertexWeight);\r\n                tmp.set(0, 0, 0);\r\n                for (j = 0; j < n; j++) {\r\n                    connectingEdge = connectingEdges[j];\r\n                    other = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\r\n                    tmp.add(other);\r\n                }\r\n                tmp.multiplyScalar(connectingVertexWeight);\r\n                newSourceVertex.add(tmp);\r\n                newSourceVertices.push(newSourceVertex);\r\n            }\r\n            newVertices = newSourceVertices.concat(newEdgeVertices);\r\n            var sl = newSourceVertices.length, edge1, edge2, edge3;\r\n            newFaces = [];\r\n            var uv, x0, x1, x2;\r\n            var x3 = new THREE.Vector2();\r\n            var x4 = new THREE.Vector2();\r\n            var x5 = new THREE.Vector2();\r\n            for (i = 0, il = oldFaces.length; i < il; i++) {\r\n                face = oldFaces[i];\r\n                edge1 = getEdge(face.a, face.b, sourceEdges).newEdge + sl;\r\n                edge2 = getEdge(face.b, face.c, sourceEdges).newEdge + sl;\r\n                edge3 = getEdge(face.c, face.a, sourceEdges).newEdge + sl;\r\n                newFace(newFaces, edge1, edge2, edge3, face.materialIndex);\r\n                newFace(newFaces, face.a, edge1, edge3, face.materialIndex);\r\n                newFace(newFaces, face.b, edge2, edge1, face.materialIndex);\r\n                newFace(newFaces, face.c, edge3, edge2, face.materialIndex);\r\n                if (hasUvs) {\r\n                    for (var j = 0; j < oldUvs.length; j++) {\r\n                        uv = oldUvs[j][i];\r\n                        x0 = uv[0];\r\n                        x1 = uv[1];\r\n                        x2 = uv[2];\r\n                        x3.set(midpoint(x0.x, x1.x), midpoint(x0.y, x1.y));\r\n                        x4.set(midpoint(x1.x, x2.x), midpoint(x1.y, x2.y));\r\n                        x5.set(midpoint(x0.x, x2.x), midpoint(x0.y, x2.y));\r\n                        newUv(newUVs[j], x3, x4, x5);\r\n                        newUv(newUVs[j], x0, x3, x5);\r\n                        newUv(newUVs[j], x1, x4, x3);\r\n                        newUv(newUVs[j], x2, x5, x4);\r\n                    }\r\n                }\r\n            }\r\n            geometry.vertices = newVertices;\r\n            geometry.faces = newFaces;\r\n            if (hasUvs)\r\n                geometry.faceVertexUvs = newUVs;\r\n        };\r\n    }());\r\n\r\n    return threex.modifiers.SubdivisionModifier = SubdivisionModifier;\r\n});"]}