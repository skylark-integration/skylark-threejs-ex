{"version":3,"sources":["modifiers/SubdivisionModifier.js"],"names":["define","THREE","SubdivisionModifier","subdivisions","this","undefined","prototype","modify","geometry","isBufferGeometry","Geometry","fromBufferGeometry","clone","mergeVertices","repeats","smooth","computeFaceNormals","computeVertexNormals","ABC","getEdge","a","b","map","Math","min","max","processEdge","vertices","face","metaVertices","edge","vertexIndexA","vertexIndexB","key","newEdge","faces","push","edges","newFace","newFaces","c","materialIndex","Face3","midpoint","abs","newUv","newUvs","oldVertices","oldFaces","oldUvs","newVertices","n","i","il","k","sourceEdges","newEdgeVertices","newSourceVertices","tmp","Vector3","newUVs","other","currentEdge","edgeVertexWeight","adjacentVertexWeight","connectedFaces","beta","sourceVertexWeight","connectingVertexWeight","connectingEdge","connectingEdges","oldVertex","newSourceVertex","hasUvs","faceVertexUvs","length","j","generateLookups","Array","addVectors","multiplyScalar","set","add","concat","edge1","edge2","edge3","uv","x0","x1","x2","sl","x3","Vector2","x4","x5","x","y"],"mappings":"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","file":"../../modifiers/SubdivisionModifier.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var SubdivisionModifier = function (subdivisions) {\n        this.subdivisions = subdivisions === undefined ? 1 : subdivisions;\n    };\n    SubdivisionModifier.prototype.modify = function (geometry) {\n        if (geometry.isBufferGeometry) {\n            geometry = new THREE.Geometry().fromBufferGeometry(geometry);\n        } else {\n            geometry = geometry.clone();\n        }\n        geometry.mergeVertices();\n        var repeats = this.subdivisions;\n        while (repeats-- > 0) {\n            this.smooth(geometry);\n        }\n        geometry.computeFaceNormals();\n        geometry.computeVertexNormals();\n        return geometry;\n    };\n    (function () {\n        var ABC = [\n            'a',\n            'b',\n            'c'\n        ];\n        function getEdge(a, b, map) {\n            var vertexIndexA = Math.min(a, b);\n            var vertexIndexB = Math.max(a, b);\n            var key = vertexIndexA + '_' + vertexIndexB;\n            return map[key];\n        }\n        function processEdge(a, b, vertices, map, face, metaVertices) {\n            var vertexIndexA = Math.min(a, b);\n            var vertexIndexB = Math.max(a, b);\n            var key = vertexIndexA + '_' + vertexIndexB;\n            var edge;\n            if (key in map) {\n                edge = map[key];\n            } else {\n                var vertexA = vertices[vertexIndexA];\n                var vertexB = vertices[vertexIndexB];\n                edge = {\n                    a: vertexA,\n                    b: vertexB,\n                    newEdge: null,\n                    faces: []\n                };\n                map[key] = edge;\n            }\n            edge.faces.push(face);\n            metaVertices[a].edges.push(edge);\n            metaVertices[b].edges.push(edge);\n        }\n        function generateLookups(vertices, faces, metaVertices, edges) {\n            var i, il, face;\n            for (i = 0, il = vertices.length; i < il; i++) {\n                metaVertices[i] = { edges: [] };\n            }\n            for (i = 0, il = faces.length; i < il; i++) {\n                face = faces[i];\n                processEdge(face.a, face.b, vertices, edges, face, metaVertices);\n                processEdge(face.b, face.c, vertices, edges, face, metaVertices);\n                processEdge(face.c, face.a, vertices, edges, face, metaVertices);\n            }\n        }\n        function newFace(newFaces, a, b, c, materialIndex) {\n            newFaces.push(new THREE.Face3(a, b, c, undefined, undefined, materialIndex));\n        }\n        function midpoint(a, b) {\n            return Math.abs(b - a) / 2 + Math.min(a, b);\n        }\n        function newUv(newUvs, a, b, c) {\n            newUvs.push([\n                THREE.clone(),\n                b.clone(),\n                c.clone()\n            ]);\n        }\n        SubdivisionModifier.prototype.smooth = function (geometry) {\n            var tmp = new THREE.Vector3();\n            var oldVertices, oldFaces, oldUvs;\n            var newVertices, newFaces, newUVs = [];\n            var n, i, il, j, k;\n            var metaVertices, sourceEdges;\n            var sourceEdges, newEdgeVertices, newSourceVertices;\n            oldVertices = geometry.vertices;\n            oldFaces = geometry.faces;\n            oldUvs = geometry.faceVertexUvs;\n            var hasUvs = oldUvs[0] !== undefined && oldUvs[0].length > 0;\n            if (hasUvs) {\n                for (var j = 0; j < oldUvs.length; j++) {\n                    newUVs.push([]);\n                }\n            }\n            metaVertices = new Array(oldVertices.length);\n            sourceEdges = {};\n            generateLookups(oldVertices, oldFaces, metaVertices, sourceEdges);\n            newEdgeVertices = [];\n            var other, currentEdge, newEdge, face;\n            var edgeVertexWeight, adjacentVertexWeight, connectedFaces;\n            for (i in sourceEdges) {\n                currentEdge = sourceEdges[i];\n                newEdge = new THREE.Vector3();\n                edgeVertexWeight = 3 / 8;\n                adjacentVertexWeight = 1 / 8;\n                connectedFaces = currentEdge.faces.length;\n                if (connectedFaces != 2) {\n                    edgeVertexWeight = 0.5;\n                    adjacentVertexWeight = 0;\n                    if (connectedFaces != 1) {\n                    }\n                }\n                newEdge.addVectors(currentEdge.a, currentEdge.b).multiplyScalar(edgeVertexWeight);\n                tmp.set(0, 0, 0);\n                for (j = 0; j < connectedFaces; j++) {\n                    face = currentEdge.faces[j];\n                    for (k = 0; k < 3; k++) {\n                        other = oldVertices[face[ABC[k]]];\n                        if (other !== currentEdge.a && other !== currentEdge.b)\n                            break;\n                    }\n                    tmp.add(other);\n                }\n                tmp.multiplyScalar(adjacentVertexWeight);\n                newEdge.add(tmp);\n                currentEdge.newEdge = newEdgeVertices.length;\n                newEdgeVertices.push(newEdge);\n            }\n            var beta, sourceVertexWeight, connectingVertexWeight;\n            var connectingEdge, connectingEdges, oldVertex, newSourceVertex;\n            newSourceVertices = [];\n            for (i = 0, il = oldVertices.length; i < il; i++) {\n                oldVertex = oldVertices[i];\n                connectingEdges = metaVertices[i].edges;\n                n = connectingEdges.length;\n                if (n == 3) {\n                    beta = 3 / 16;\n                } else if (n > 3) {\n                    beta = 3 / (8 * n);\n                }\n                sourceVertexWeight = 1 - n * beta;\n                connectingVertexWeight = beta;\n                if (n <= 2) {\n                    if (n == 2) {\n                        sourceVertexWeight = 3 / 4;\n                        connectingVertexWeight = 1 / 8;\n                    } else if (n == 1) {\n                    } else if (n == 0) {\n                    }\n                }\n                newSourceVertex = oldVertex.clone().multiplyScalar(sourceVertexWeight);\n                tmp.set(0, 0, 0);\n                for (j = 0; j < n; j++) {\n                    connectingEdge = connectingEdges[j];\n                    other = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\n                    tmp.add(other);\n                }\n                tmp.multiplyScalar(connectingVertexWeight);\n                newSourceVertex.add(tmp);\n                newSourceVertices.push(newSourceVertex);\n            }\n            newVertices = newSourceVertices.concat(newEdgeVertices);\n            var sl = newSourceVertices.length, edge1, edge2, edge3;\n            newFaces = [];\n            var uv, x0, x1, x2;\n            var x3 = new THREE.Vector2();\n            var x4 = new THREE.Vector2();\n            var x5 = new THREE.Vector2();\n            for (i = 0, il = oldFaces.length; i < il; i++) {\n                face = oldFaces[i];\n                edge1 = getEdge(face.a, face.b, sourceEdges).newEdge + sl;\n                edge2 = getEdge(face.b, face.c, sourceEdges).newEdge + sl;\n                edge3 = getEdge(face.c, face.a, sourceEdges).newEdge + sl;\n                newFace(newFaces, edge1, edge2, edge3, face.materialIndex);\n                newFace(newFaces, face.a, edge1, edge3, face.materialIndex);\n                newFace(newFaces, face.b, edge2, edge1, face.materialIndex);\n                newFace(newFaces, face.c, edge3, edge2, face.materialIndex);\n                if (hasUvs) {\n                    for (var j = 0; j < oldUvs.length; j++) {\n                        uv = oldUvs[j][i];\n                        x0 = uv[0];\n                        x1 = uv[1];\n                        x2 = uv[2];\n                        x3.set(midpoint(x0.x, x1.x), midpoint(x0.y, x1.y));\n                        x4.set(midpoint(x1.x, x2.x), midpoint(x1.y, x2.y));\n                        x5.set(midpoint(x0.x, x2.x), midpoint(x0.y, x2.y));\n                        newUv(newUVs[j], x3, x4, x5);\n                        newUv(newUVs[j], x0, x3, x5);\n                        newUv(newUVs[j], x1, x4, x3);\n                        newUv(newUVs[j], x2, x5, x4);\n                    }\n                }\n            }\n            geometry.vertices = newVertices;\n            geometry.faces = newFaces;\n            if (hasUvs)\n                geometry.faceVertexUvs = newUVs;\n        };\n    }());\n    return SubdivisionModifier;\n});"]}