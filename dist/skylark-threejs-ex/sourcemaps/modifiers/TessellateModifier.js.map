{"version":3,"sources":["modifiers/TessellateModifier.js"],"names":["define","THREE","TessellateModifier","maxEdgeLength","this","prototype","modify","geometry","edge","faces","faceVertexUvs","maxEdgeLengthSquared","i","il","length","face","Face3","a","b","c","va","vertices","vb","vc","dab","distanceToSquared","dbc","dac","m","triA","clone","triB","vm","lerp","vertexNormals","vnm","copy","vertexColors","vcm","push","j","jl","uvs","uvA","uvB","uvC","uvM","uvsTriA","uvsTriB"],"mappings":"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","file":"../../modifiers/TessellateModifier.js","sourcesContent":["define([\n    \"skylark-threejs\"\n], function (THREE) {\n    'use strict';\n    var TessellateModifier = function (maxEdgeLength) {\n        this.maxEdgeLength = maxEdgeLength;\n    };\n    TessellateModifier.prototype.modify = function (geometry) {\n        var edge;\n        var faces = [];\n        var faceVertexUvs = [];\n        var maxEdgeLengthSquared = this.maxEdgeLength * this.maxEdgeLength;\n        for (var i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n            faceVertexUvs[i] = [];\n        }\n        for (var i = 0, il = geometry.faces.length; i < il; i++) {\n            var face = geometry.faces[i];\n            if (face instanceof THREE.Face3) {\n                var a = face.a;\n                var b = face.b;\n                var c = face.c;\n                var va = geometry.vertices[a];\n                var vb = geometry.vertices[b];\n                var vc = geometry.vertices[c];\n                var dab = va.distanceToSquared(vb);\n                var dbc = vb.distanceToSquared(vc);\n                var dac = va.distanceToSquared(vc);\n                if (dab > maxEdgeLengthSquared || dbc > maxEdgeLengthSquared || dac > maxEdgeLengthSquared) {\n                    var m = geometry.vertices.length;\n                    var triA = face.clone();\n                    var triB = face.clone();\n                    if (dab >= dbc && dab >= dac) {\n                        var vm = va.clone();\n                        vm.lerp(vb, 0.5);\n                        triA.a = a;\n                        triA.b = m;\n                        triA.c = c;\n                        triB.a = m;\n                        triB.b = b;\n                        triB.c = c;\n                        if (face.vertexNormals.length === 3) {\n                            var vnm = face.vertexNormals[0].clone();\n                            vnm.lerp(face.vertexNormals[1], 0.5);\n                            triA.vertexNormals[1].copy(vnm);\n                            triB.vertexNormals[0].copy(vnm);\n                        }\n                        if (face.vertexColors.length === 3) {\n                            var vcm = face.vertexColors[0].clone();\n                            vcm.lerp(face.vertexColors[1], 0.5);\n                            triA.vertexColors[1].copy(vcm);\n                            triB.vertexColors[0].copy(vcm);\n                        }\n                        edge = 0;\n                    } else if (dbc >= dab && dbc >= dac) {\n                        var vm = vb.clone();\n                        vm.lerp(vc, 0.5);\n                        triA.a = a;\n                        triA.b = b;\n                        triA.c = m;\n                        triB.a = m;\n                        triB.b = c;\n                        triB.c = a;\n                        if (face.vertexNormals.length === 3) {\n                            var vnm = face.vertexNormals[1].clone();\n                            vnm.lerp(face.vertexNormals[2], 0.5);\n                            triA.vertexNormals[2].copy(vnm);\n                            triB.vertexNormals[0].copy(vnm);\n                            triB.vertexNormals[1].copy(face.vertexNormals[2]);\n                            triB.vertexNormals[2].copy(face.vertexNormals[0]);\n                        }\n                        if (face.vertexColors.length === 3) {\n                            var vcm = face.vertexColors[1].clone();\n                            vcm.lerp(face.vertexColors[2], 0.5);\n                            triA.vertexColors[2].copy(vcm);\n                            triB.vertexColors[0].copy(vcm);\n                            triB.vertexColors[1].copy(face.vertexColors[2]);\n                            triB.vertexColors[2].copy(face.vertexColors[0]);\n                        }\n                        edge = 1;\n                    } else {\n                        var vm = va.clone();\n                        vm.lerp(vc, 0.5);\n                        triA.a = a;\n                        triA.b = b;\n                        triA.c = m;\n                        triB.a = m;\n                        triB.b = b;\n                        triB.c = c;\n                        if (face.vertexNormals.length === 3) {\n                            var vnm = face.vertexNormals[0].clone();\n                            vnm.lerp(face.vertexNormals[2], 0.5);\n                            triA.vertexNormals[2].copy(vnm);\n                            triB.vertexNormals[0].copy(vnm);\n                        }\n                        if (face.vertexColors.length === 3) {\n                            var vcm = face.vertexColors[0].clone();\n                            vcm.lerp(face.vertexColors[2], 0.5);\n                            triA.vertexColors[2].copy(vcm);\n                            triB.vertexColors[0].copy(vcm);\n                        }\n                        edge = 2;\n                    }\n                    faces.push(triA, triB);\n                    geometry.vertices.push(vm);\n                    for (var j = 0, jl = geometry.faceVertexUvs.length; j < jl; j++) {\n                        if (geometry.faceVertexUvs[j].length) {\n                            var uvs = geometry.faceVertexUvs[j][i];\n                            var uvA = uvs[0];\n                            var uvB = uvs[1];\n                            var uvC = uvs[2];\n                            if (edge === 0) {\n                                var uvM = uvA.clone();\n                                uvM.lerp(uvB, 0.5);\n                                var uvsTriA = [\n                                    uvA.clone(),\n                                    uvM.clone(),\n                                    uvC.clone()\n                                ];\n                                var uvsTriB = [\n                                    uvM.clone(),\n                                    uvB.clone(),\n                                    uvC.clone()\n                                ];\n                            } else if (edge === 1) {\n                                var uvM = uvB.clone();\n                                uvM.lerp(uvC, 0.5);\n                                var uvsTriA = [\n                                    uvA.clone(),\n                                    uvB.clone(),\n                                    uvM.clone()\n                                ];\n                                var uvsTriB = [\n                                    uvM.clone(),\n                                    uvC.clone(),\n                                    uvA.clone()\n                                ];\n                            } else {\n                                var uvM = uvA.clone();\n                                uvM.lerp(uvC, 0.5);\n                                var uvsTriA = [\n                                    uvA.clone(),\n                                    uvB.clone(),\n                                    uvM.clone()\n                                ];\n                                var uvsTriB = [\n                                    uvM.clone(),\n                                    uvB.clone(),\n                                    uvC.clone()\n                                ];\n                            }\n                            faceVertexUvs[j].push(uvsTriA, uvsTriB);\n                        }\n                    }\n                } else {\n                    faces.push(face);\n                    for (var j = 0, jl = geometry.faceVertexUvs.length; j < jl; j++) {\n                        faceVertexUvs[j].push(geometry.faceVertexUvs[j][i]);\n                    }\n                }\n            }\n        }\n        geometry.faces = faces;\n        geometry.faceVertexUvs = faceVertexUvs;\n    };\n    return TessellateModifier;\n});"]}