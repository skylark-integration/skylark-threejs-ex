{"version":3,"sources":["modifiers/SimplifyModifier.js"],"names":["define","THREE","SimplifyModifier","cb","Vector3","ab","removeFromArray","array","object","k","indexOf","splice","computeEdgeCollapseCost","u","v","i","face","sideFace","edgelength","position","distanceTo","curvature","sideFaces","il","faces","length","hasVertex","push","minCurvature","j","dotProd","normal","dot","Math","min","max","computeEdgeCostAtVertex","neighbors","collapseNeighbor","collapseCost","minCost","totalCost","costCount","removeVertex","vertices","console","assert","pop","removeFace","f","v1","v2","v3","vs","removeIfNonNeighbor","collapse","tmpVertices","replaceVertex","minimumCostEdge","least","Triangle","a","b","c","this","computeNormal","addUniqueNeighbor","Vertex","id","prototype","vA","vB","vC","subVectors","cross","normalize","copy","oldv","newv","vertex","n","offset","modify","geometry","count","isBufferGeometry","Geometry","fromBufferGeometry","mergeVertices","nextVertex","oldVertices","oldFaces","triangle","z","log","simplifiedGeometry","BufferGeometry","index","x","y","setAttribute","Float32BufferAttribute","setIndex"],"mappings":"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","file":"../../modifiers/SimplifyModifier.js","sourcesContent":["define([\n\t\"skylark-threejs\"\n],function(THREE){\n\t/**\n\t *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n\t *\n\t *\tSimplification Geometry Modifier\n\t *    - based on code and technique\n\t *\t  - by Stan Melax in 1998\n\t *\t  - Progressive Mesh type Polygon Reduction Algorithm\n\t *    - http://www.melax.com/polychop/\n\t */\n\n\tTHREE.SimplifyModifier = function () {};\n\n\t( function () {\n\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\tfunction pushIfUnique( array, object ) {\n\n\t\t\tif ( array.indexOf( object ) === - 1 ) array.push( object );\n\n\t\t}\n\n\t\tfunction removeFromArray( array, object ) {\n\n\t\t\tvar k = array.indexOf( object );\n\t\t\tif ( k > - 1 ) array.splice( k, 1 );\n\n\t\t}\n\n\t\tfunction computeEdgeCollapseCost( u, v ) {\n\n\t\t\t// if we collapse edge uv by moving u to v then how\n\t\t\t// much different will the model change, i.e. the \"error\".\n\n\t\t\tvar edgelength = v.position.distanceTo( u.position );\n\t\t\tvar curvature = 0;\n\n\t\t\tvar sideFaces = [];\n\t\t\tvar i, il = u.faces.length, face, sideFace;\n\n\t\t\t// find the \"sides\" triangles that are on the edge uv\n\t\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\t\tface = u.faces[ i ];\n\n\t\t\t\tif ( face.hasVertex( v ) ) {\n\n\t\t\t\t\tsideFaces.push( face );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// use the triangle facing most away from the sides\n\t\t\t// to determine our curvature term\n\t\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\t\tvar minCurvature = 1;\n\t\t\t\tface = u.faces[ i ];\n\n\t\t\t\tfor ( var j = 0; j < sideFaces.length; j ++ ) {\n\n\t\t\t\t\tsideFace = sideFaces[ j ];\n\t\t\t\t\t// use dot product of face normals.\n\t\t\t\t\tvar dotProd = face.normal.dot( sideFace.normal );\n\t\t\t\t\tminCurvature = Math.min( minCurvature, ( 1.001 - dotProd ) / 2 );\n\n\t\t\t\t}\n\n\t\t\t\tcurvature = Math.max( curvature, minCurvature );\n\n\t\t\t}\n\n\t\t\t// crude approach in attempt to preserve borders\n\t\t\t// though it seems not to be totally correct\n\t\t\tvar borders = 0;\n\t\t\tif ( sideFaces.length < 2 ) {\n\n\t\t\t\t// we add some arbitrary cost for borders,\n\t\t\t\t// borders += 10;\n\t\t\t\tcurvature = 1;\n\n\t\t\t}\n\n\t\t\tvar amt = edgelength * curvature + borders;\n\n\t\t\treturn amt;\n\n\t\t}\n\n\t\tfunction computeEdgeCostAtVertex( v ) {\n\n\t\t\t// compute the edge collapse cost for all edges that start\n\t\t\t// from vertex v.  Since we are only interested in reducing\n\t\t\t// the object by selecting the min cost edge at each step, we\n\t\t\t// only cache the cost of the least cost edge at this vertex\n\t\t\t// (in member variable collapse) as well as the value of the\n\t\t\t// cost (in member variable collapseCost).\n\n\t\t\tif ( v.neighbors.length === 0 ) {\n\n\t\t\t\t// collapse if no neighbors.\n\t\t\t\tv.collapseNeighbor = null;\n\t\t\t\tv.collapseCost = - 0.01;\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tv.collapseCost = 100000;\n\t\t\tv.collapseNeighbor = null;\n\n\t\t\t// search all neighboring edges for \"least cost\" edge\n\t\t\tfor ( var i = 0; i < v.neighbors.length; i ++ ) {\n\n\t\t\t\tvar collapseCost = computeEdgeCollapseCost( v, v.neighbors[ i ] );\n\n\t\t\t\tif ( ! v.collapseNeighbor ) {\n\n\t\t\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\t\t\tv.collapseCost = collapseCost;\n\t\t\t\t\tv.minCost = collapseCost;\n\t\t\t\t\tv.totalCost = 0;\n\t\t\t\t\tv.costCount = 0;\n\n\t\t\t\t}\n\n\t\t\t\tv.costCount ++;\n\t\t\t\tv.totalCost += collapseCost;\n\n\t\t\t\tif ( collapseCost < v.minCost ) {\n\n\t\t\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\t\t\tv.minCost = collapseCost;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// we average the cost of collapsing at this vertex\n\t\t\tv.collapseCost = v.totalCost / v.costCount;\n\t\t\t// v.collapseCost = v.minCost;\n\n\t\t}\n\n\t\tfunction removeVertex( v, vertices ) {\n\n\t\t\tconsole.assert( v.faces.length === 0 );\n\n\t\t\twhile ( v.neighbors.length ) {\n\n\t\t\t\tvar n = v.neighbors.pop();\n\t\t\t\tremoveFromArray( n.neighbors, v );\n\n\t\t\t}\n\n\t\t\tremoveFromArray( vertices, v );\n\n\t\t}\n\n\t\tfunction removeFace( f, faces ) {\n\n\t\t\tremoveFromArray( faces, f );\n\n\t\t\tif ( f.v1 ) removeFromArray( f.v1.faces, f );\n\t\t\tif ( f.v2 ) removeFromArray( f.v2.faces, f );\n\t\t\tif ( f.v3 ) removeFromArray( f.v3.faces, f );\n\n\t\t\t// TODO optimize this!\n\t\t\tvar vs = [ f.v1, f.v2, f.v3 ];\n\t\t\tvar v1, v2;\n\n\t\t\tfor ( var i = 0; i < 3; i ++ ) {\n\n\t\t\t\tv1 = vs[ i ];\n\t\t\t\tv2 = vs[ ( i + 1 ) % 3 ];\n\n\t\t\t\tif ( ! v1 || ! v2 ) continue;\n\n\t\t\t\tv1.removeIfNonNeighbor( v2 );\n\t\t\t\tv2.removeIfNonNeighbor( v1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction collapse( vertices, faces, u, v ) { // u and v are pointers to vertices of an edge\n\n\t\t\t// Collapse the edge uv by moving vertex u onto v\n\n\t\t\tif ( ! v ) {\n\n\t\t\t\t// u is a vertex all by itself so just delete it..\n\t\t\t\tremoveVertex( u, vertices );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar i;\n\t\t\tvar tmpVertices = [];\n\n\t\t\tfor ( i = 0; i < u.neighbors.length; i ++ ) {\n\n\t\t\t\ttmpVertices.push( u.neighbors[ i ] );\n\n\t\t\t}\n\n\n\t\t\t// delete triangles on edge uv:\n\t\t\tfor ( i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tif ( u.faces[ i ].hasVertex( v ) ) {\n\n\t\t\t\t\tremoveFace( u.faces[ i ], faces );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update remaining triangles to have v instead of u\n\t\t\tfor ( i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\t\t\tu.faces[ i ].replaceVertex( u, v );\n\n\t\t\t}\n\n\n\t\t\tremoveVertex( u, vertices );\n\n\t\t\t// recompute the edge collapse costs in neighborhood\n\t\t\tfor ( i = 0; i < tmpVertices.length; i ++ ) {\n\n\t\t\t\tcomputeEdgeCostAtVertex( tmpVertices[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\n\n\t\tfunction minimumCostEdge( vertices ) {\n\n\t\t\t// O(n * n) approach. TODO optimize this\n\n\t\t\tvar least = vertices[ 0 ];\n\n\t\t\tfor ( var i = 0; i < vertices.length; i ++ ) {\n\n\t\t\t\tif ( vertices[ i ].collapseCost < least.collapseCost ) {\n\n\t\t\t\t\tleast = vertices[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn least;\n\n\t\t}\n\n\t\t// we use a triangle class to represent structure of face slightly differently\n\n\t\tfunction Triangle( v1, v2, v3, a, b, c ) {\n\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\n\t\t\tthis.normal = new THREE.Vector3();\n\n\t\t\tthis.computeNormal();\n\n\t\t\tv1.faces.push( this );\n\t\t\tv1.addUniqueNeighbor( v2 );\n\t\t\tv1.addUniqueNeighbor( v3 );\n\n\t\t\tv2.faces.push( this );\n\t\t\tv2.addUniqueNeighbor( v1 );\n\t\t\tv2.addUniqueNeighbor( v3 );\n\n\n\t\t\tv3.faces.push( this );\n\t\t\tv3.addUniqueNeighbor( v1 );\n\t\t\tv3.addUniqueNeighbor( v2 );\n\n\t\t}\n\n\t\tTriangle.prototype.computeNormal = function () {\n\n\t\t\tvar vA = this.v1.position;\n\t\t\tvar vB = this.v2.position;\n\t\t\tvar vC = this.v3.position;\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab ).normalize();\n\n\t\t\tthis.normal.copy( cb );\n\n\t\t};\n\n\t\tTriangle.prototype.hasVertex = function ( v ) {\n\n\t\t\treturn v === this.v1 || v === this.v2 || v === this.v3;\n\n\t\t};\n\n\t\tTriangle.prototype.replaceVertex = function ( oldv, newv ) {\n\n\t\t\tif ( oldv === this.v1 ) this.v1 = newv;\n\t\t\telse if ( oldv === this.v2 ) this.v2 = newv;\n\t\t\telse if ( oldv === this.v3 ) this.v3 = newv;\n\n\t\t\tremoveFromArray( oldv.faces, this );\n\t\t\tnewv.faces.push( this );\n\n\n\t\t\toldv.removeIfNonNeighbor( this.v1 );\n\t\t\tthis.v1.removeIfNonNeighbor( oldv );\n\n\t\t\toldv.removeIfNonNeighbor( this.v2 );\n\t\t\tthis.v2.removeIfNonNeighbor( oldv );\n\n\t\t\toldv.removeIfNonNeighbor( this.v3 );\n\t\t\tthis.v3.removeIfNonNeighbor( oldv );\n\n\t\t\tthis.v1.addUniqueNeighbor( this.v2 );\n\t\t\tthis.v1.addUniqueNeighbor( this.v3 );\n\n\t\t\tthis.v2.addUniqueNeighbor( this.v1 );\n\t\t\tthis.v2.addUniqueNeighbor( this.v3 );\n\n\t\t\tthis.v3.addUniqueNeighbor( this.v1 );\n\t\t\tthis.v3.addUniqueNeighbor( this.v2 );\n\n\t\t\tthis.computeNormal();\n\n\t\t};\n\n\t\tfunction Vertex( v, id ) {\n\n\t\t\tthis.position = v;\n\n\t\t\tthis.id = id; // old index id\n\n\t\t\tthis.faces = []; // faces vertex is connected\n\t\t\tthis.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n\n\t\t\t// these will be computed in computeEdgeCostAtVertex()\n\t\t\tthis.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\t\t\tthis.collapseNeighbor = null; // best candinate for collapsing\n\n\t\t}\n\n\t\tVertex.prototype.addUniqueNeighbor = function ( vertex ) {\n\n\t\t\tpushIfUnique( this.neighbors, vertex );\n\n\t\t};\n\n\t\tVertex.prototype.removeIfNonNeighbor = function ( n ) {\n\n\t\t\tvar neighbors = this.neighbors;\n\t\t\tvar faces = this.faces;\n\n\t\t\tvar offset = neighbors.indexOf( n );\n\t\t\tif ( offset === - 1 ) return;\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tif ( faces[ i ].hasVertex( n ) ) return;\n\n\t\t\t}\n\n\t\t\tneighbors.splice( offset, 1 );\n\n\t\t};\n\n\t\tTHREE.SimplifyModifier.prototype.modify = function ( geometry, count ) {\n\n\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry( geometry );\n\n\t\t\t}\n\n\t\t\tgeometry.mergeVertices();\n\n\t\t\tvar oldVertices = geometry.vertices; // Three Position\n\t\t\tvar oldFaces = geometry.faces; // Three Face\n\n\t\t\t// conversion\n\t\t\tvar vertices = [];\n\t\t\tvar faces = [];\n\n\t\t\tvar i, il;\n\n\t\t\t//\n\t\t\t// put data of original geometry in different data structures\n\t\t\t//\n\n\t\t\t// add vertices\n\n\t\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\n\n\t\t\t\tvar vertex = new Vertex( oldVertices[ i ], i );\n\t\t\t\tvertices.push( vertex );\n\n\t\t\t}\n\n\t\t\t// add faces\n\n\t\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\n\n\t\t\t\tvar face = oldFaces[ i ];\n\n\t\t\t\tvar a = face.a;\n\t\t\t\tvar b = face.b;\n\t\t\t\tvar c = face.c;\n\n\t\t\t\tvar triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\n\t\t\t\tfaces.push( triangle );\n\n\t\t\t}\n\n\t\t\t// compute all edge collapse costs\n\n\t\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\t\tcomputeEdgeCostAtVertex( vertices[ i ] );\n\n\t\t\t}\n\n\t\t\tvar nextVertex;\n\n\t\t\tvar z = count;\n\n\t\t\twhile ( z -- ) {\n\n\t\t\t\tnextVertex = minimumCostEdge( vertices );\n\n\t\t\t\tif ( ! nextVertex ) {\n\n\t\t\t\t\tconsole.log( 'THREE.SimplifyModifier: No next vertex' );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcollapse( vertices, faces, nextVertex, nextVertex.collapseNeighbor );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar simplifiedGeometry = new THREE.BufferGeometry();\n\t\t\tvar position = [];\n\t\t\tvar index = [];\n\n\t\t\t//\n\n\t\t\tfor ( i = 0; i < vertices.length; i ++ ) {\n\n\t\t\t\tvar vertex = vertices[ i ].position;\n\t\t\t\tposition.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfor ( i = 0; i < faces.length; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\tvar a = vertices.indexOf( face.v1 );\n\t\t\t\tvar b = vertices.indexOf( face.v2 );\n\t\t\t\tvar c = vertices.indexOf( face.v3 );\n\n\t\t\t\tindex.push( a, b, c );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tsimplifiedGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( position, 3 ) );\n\t\t\tsimplifiedGeometry.setIndex( index );\n\n\t\t\treturn simplifiedGeometry;\n\n\t\t};\n\n\t} )();\n\t\n\treturn THREE.SimplifyModifier;\n});\n"]}