/**
 * skylark-threejs-ex - A version of threejs extentions library that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-threejs-ex/
 * @license MIT
 */
define(["skylark-threejs"],function(e){"use strict";const t=function(e){this.logging={enabled:!1,debug:!1},this.callbacks={onProgress:null,onMeshAlter:null},this.materialHandler=e};return t.prototype={constructor:t,setLogging:function(e,t){this.logging.enabled=!0===e,this.logging.debug=!0===t},_setCallbacks:function(e,t){null!==e&&void 0!==e&&e instanceof Function&&(this.callbacks.onProgress=e),null!==t&&void 0!==t&&t instanceof Function&&(this.callbacks.onMeshAlter=t)},buildMeshes:function(t){let s,r,n,i=t.params.meshName,l=t.buffers,o=new e.BufferGeometry;void 0!==l.vertices&&null!==l.vertices&&o.setAttribute("position",new e.BufferAttribute(new Float32Array(l.vertices),3)),void 0!==l.indices&&null!==l.indices&&o.setIndex(new e.BufferAttribute(new Uint32Array(l.indices),1)),void 0!==l.colors&&null!==l.colors&&o.setAttribute("color",new e.BufferAttribute(new Float32Array(l.colors),3)),void 0!==l.normals&&null!==l.normals?o.setAttribute("normal",new e.BufferAttribute(new Float32Array(l.normals),3)):o.computeVertexNormals(),void 0!==l.uvs&&null!==l.uvs&&o.setAttribute("uv",new e.BufferAttribute(new Float32Array(l.uvs),2)),void 0!==l.skinIndex&&null!==l.skinIndex&&o.setAttribute("skinIndex",new e.BufferAttribute(new Uint16Array(l.skinIndex),4)),void 0!==l.skinWeight&&null!==l.skinWeight&&o.setAttribute("skinWeight",new e.BufferAttribute(new Float32Array(l.skinWeight),4));let a=t.materials.materialNames,u=t.materials.multiMaterial,c=[];for(n in a)r=a[n],s=this.materialHandler.getMaterial(r),u&&c.push(s);if(u){s=c;let e,r=t.materials.materialGroups;for(n in r)e=r[n],o.addGroup(e.start,e.count,e.index)}let m,d,h=[],f=!0,g=null===t.geometryType?0:t.geometryType;if(this.callbacks.onMeshAlter&&(d=this.callbacks.onMeshAlter({detail:{meshName:i,bufferGeometry:o,material:s,geometryType:g}})),d)if(d.isDisregardMesh())f=!1;else if(d.providesAlteredMeshes()){for(let e in d.meshes)h.push(d.meshes[e]);f=!1}f&&(t.computeBoundingSphere&&o.computeBoundingSphere(),(m=0===g?new e.Mesh(o,s):1===g?new e.LineSegments(o,s):new e.Points(o,s)).name=i,h.push(m));let b=t.params.meshName;if(h.length>0){let e=[];for(let t in h)m=h[t],e[t]=m.name;b+=": Adding mesh(es) ("+e.length+": "+e+") from input mesh: "+i,b+=" ("+(100*t.progress.numericalValue).toFixed(2)+"%)"}else b+=": Not adding mesh: "+i,b+=" ("+(100*t.progress.numericalValue).toFixed(2)+"%)";return this.callbacks.onProgress&&this.callbacks.onProgress("progress",b,t.progress.numericalValue),h}},t});
//# sourceMappingURL=../../../sourcemaps/loaders/obj2/shared/MeshReceiver.js.map
