/**
 * skylark-threejs-ex - A version of threejs extentions library that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-threejs-ex/
 * @license MIT
 */
define(["skylark-threejs","../threex"],function(t,e){"use strict";return function(){var r=/^[og]\s*(.+)?/,i=/^mtllib /,s=/^usemtl /,a=/^usemap /;function o(e){t.Loader.call(this,e),this.materials=null}return o.prototype=Object.assign(Object.create(t.Loader.prototype),{constructor:o,load:function(e,r,i,s){var a=this,o=new t.FileLoader(a.manager);o.setPath(this.path),o.load(e,function(t){r(a.parse(t))},i,s)},setMaterials:function(t){return this.materials=t,this},parse:function(e){var o=new function(){var t={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(t,e){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=t,void(this.object.fromDeclaration=!1!==e);var r=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:t||"",fromDeclaration:!1!==e,geometry:{vertices:[],normals:[],colors:[],uvs:[]},materials:[],smooth:!0,startMaterial:function(t,e){var r=this._finalize(!1);r&&(r.inherited||r.groupCount<=0)&&this.materials.splice(r.index,1);var i={index:this.materials.length,name:t||"",mtllib:Array.isArray(e)&&e.length>0?e[e.length-1]:"",smooth:void 0!==r?r.smooth:this.smooth,groupStart:void 0!==r?r.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(t){var e={index:"number"==typeof t?t:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return e.clone=this.clone.bind(e),e}};return this.materials.push(i),i},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(t){var e=this.currentMaterial();if(e&&-1===e.groupEnd&&(e.groupEnd=this.geometry.vertices.length/3,e.groupCount=e.groupEnd-e.groupStart,e.inherited=!1),t&&this.materials.length>1)for(var r=this.materials.length-1;r>=0;r--)this.materials[r].groupCount<=0&&this.materials.splice(r,1);return t&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),e}},r&&r.name&&"function"==typeof r.clone){var i=r.clone(0);i.inherited=!0,this.object.materials.push(i)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(t,e){var r=parseInt(t,10);return 3*(r>=0?r-1:r+e/3)},parseNormalIndex:function(t,e){var r=parseInt(t,10);return 3*(r>=0?r-1:r+e/3)},parseUVIndex:function(t,e){var r=parseInt(t,10);return 2*(r>=0?r-1:r+e/2)},addVertex:function(t,e,r){var i=this.vertices,s=this.object.geometry.vertices;s.push(i[t+0],i[t+1],i[t+2]),s.push(i[e+0],i[e+1],i[e+2]),s.push(i[r+0],i[r+1],i[r+2])},addVertexPoint:function(t){var e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addVertexLine:function(t){var e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addNormal:function(t,e,r){var i=this.normals,s=this.object.geometry.normals;s.push(i[t+0],i[t+1],i[t+2]),s.push(i[e+0],i[e+1],i[e+2]),s.push(i[r+0],i[r+1],i[r+2])},addColor:function(t,e,r){var i=this.colors,s=this.object.geometry.colors;s.push(i[t+0],i[t+1],i[t+2]),s.push(i[e+0],i[e+1],i[e+2]),s.push(i[r+0],i[r+1],i[r+2])},addUV:function(t,e,r){var i=this.uvs,s=this.object.geometry.uvs;s.push(i[t+0],i[t+1]),s.push(i[e+0],i[e+1]),s.push(i[r+0],i[r+1])},addUVLine:function(t){var e=this.uvs;this.object.geometry.uvs.push(e[t+0],e[t+1])},addFace:function(t,e,r,i,s,a,o,n,l){var h=this.vertices.length,u=this.parseVertexIndex(t,h),c=this.parseVertexIndex(e,h),p=this.parseVertexIndex(r,h);if(this.addVertex(u,c,p),this.colors.length>0&&this.addColor(u,c,p),void 0!==i&&""!==i){var m=this.uvs.length;u=this.parseUVIndex(i,m),c=this.parseUVIndex(s,m),p=this.parseUVIndex(a,m),this.addUV(u,c,p)}if(void 0!==o&&""!==o){var f=this.normals.length;u=this.parseNormalIndex(o,f),c=o===n?u:this.parseNormalIndex(n,f),p=o===l?u:this.parseNormalIndex(l,f),this.addNormal(u,c,p)}},addPointGeometry:function(t){this.object.geometry.type="Points";for(var e=this.vertices.length,r=0,i=t.length;r<i;r++)this.addVertexPoint(this.parseVertexIndex(t[r],e))},addLineGeometry:function(t,e){this.object.geometry.type="Line";for(var r=this.vertices.length,i=this.uvs.length,s=0,a=t.length;s<a;s++)this.addVertexLine(this.parseVertexIndex(t[s],r));var o=0;for(a=e.length;o<a;o++)this.addUVLine(this.parseUVIndex(e[o],i))}};return t.startObject("",!1),t};-1!==e.indexOf("\r\n")&&(e=e.replace(/\r\n/g,"\n")),-1!==e.indexOf("\\\n")&&(e=e.replace(/\\\n/g,""));for(var n=e.split("\n"),l="",h="",u=[],c="function"==typeof"".trimLeft,p=0,m=n.length;p<m;p++)if(l=n[p],0!==(l=c?l.trimLeft():l.trim()).length&&"#"!==(h=l.charAt(0)))if("v"===h){var f=l.split(/\s+/);switch(f[0]){case"v":o.vertices.push(parseFloat(f[1]),parseFloat(f[2]),parseFloat(f[3])),f.length>=7&&o.colors.push(parseFloat(f[4]),parseFloat(f[5]),parseFloat(f[6]));break;case"vn":o.normals.push(parseFloat(f[1]),parseFloat(f[2]),parseFloat(f[3]));break;case"vt":o.uvs.push(parseFloat(f[1]),parseFloat(f[2]))}}else if("f"===h){for(var d=l.substr(1).trim().split(/\s+/),v=[],g=0,b=d.length;g<b;g++){var j=d[g];if(j.length>0){var x=j.split("/");v.push(x)}}var y=v[0];for(g=1,b=v.length-1;g<b;g++){var L=v[g],w=v[g+1];o.addFace(y[0],L[0],w[0],y[1],L[1],w[1],y[2],L[2],w[2])}}else if("l"===h){var V=l.substring(1).trim().split(" "),M=[],F=[];if(-1===l.indexOf("/"))M=V;else for(var I=0,A=V.length;I<A;I++){var P=V[I].split("/");""!==P[0]&&M.push(P[0]),""!==P[1]&&F.push(P[1])}o.addLineGeometry(M,F)}else if("p"===h){var z=l.substr(1).trim().split(" ");o.addPointGeometry(z)}else if(null!==(u=r.exec(l))){var B=(" "+u[0].substr(1).trim()).substr(1);o.startObject(B)}else if(s.test(l))o.object.startMaterial(l.substring(7).trim(),o.materialLibraries);else if(i.test(l))o.materialLibraries.push(l.substring(7).trim());else if(a.test(l))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===h){if((u=l.split(" ")).length>1){var O=u[1].trim().toLowerCase();o.object.smooth="0"!==O&&"off"!==O}else o.object.smooth=!0;(q=o.object.currentMaterial())&&(q.smooth=o.object.smooth)}else{if("\0"===l)continue;console.warn('THREE.OBJLoader: Unexpected line: "'+l+'"')}o.finalize();var C=new t.Group;C.materialLibraries=[].concat(o.materialLibraries);for(p=0,m=o.objects.length;p<m;p++){var E=o.objects[p],U=E.geometry,_=E.materials,G="Line"===U.type,N="Points"===U.type,S=!1;if(0!==U.vertices.length){var k=new t.BufferGeometry;k.setAttribute("position",new t.Float32BufferAttribute(U.vertices,3)),U.normals.length>0?k.setAttribute("normal",new t.Float32BufferAttribute(U.normals,3)):k.computeVertexNormals(),U.colors.length>0&&(S=!0,k.setAttribute("color",new t.Float32BufferAttribute(U.colors,3))),U.uvs.length>0&&k.setAttribute("uv",new t.Float32BufferAttribute(U.uvs,2));for(var T,D=[],J=0,R=_.length;J<R;J++){var H=(W=_[J]).name+"_"+W.smooth+"_"+S,q=o.materials[H];if(null!==this.materials)if(q=this.materials.create(W.name),!G||!q||q instanceof t.LineBasicMaterial){if(N&&q&&!(q instanceof t.PointsMaterial)){var K=new t.PointsMaterial({size:10,sizeAttenuation:!1});t.Material.prototype.copy.call(K,q),K.color.copy(q.color),K.map=q.map,q=K}}else{var Q=new t.LineBasicMaterial;t.Material.prototype.copy.call(Q,q),Q.color.copy(q.color),q=Q}void 0===q&&((q=G?new t.LineBasicMaterial:N?new t.PointsMaterial({size:1,sizeAttenuation:!1}):new t.MeshPhongMaterial).name=W.name,q.flatShading=!W.smooth,q.vertexColors=S,o.materials[H]=q),D.push(q)}if(D.length>1){for(J=0,R=_.length;J<R;J++){var W=_[J];k.addGroup(W.groupStart,W.groupCount,J)}T=G?new t.LineSegments(k,D):N?new t.Points(k,D):new t.Mesh(k,D)}else T=G?new t.LineSegments(k,D[0]):N?new t.Points(k,D[0]):new t.Mesh(k,D[0]);T.name=E.name,C.add(T)}}return C}}),e.loaders.OBJLoader=o}()});
//# sourceMappingURL=../sourcemaps/loaders/OBJLoader.js.map
