/**
 * skylark-threejs-ex - A version of threejs extentions library that ported to running on skylarkjs
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-threejs-ex/
 * @license MIT
 */
define(["../core/TempNode","../core/ConstNode","../core/StructNode","../core/FunctionNode","../core/FunctionCallNode","../core/ExpressionNode","../inputs/FloatNode","../math/OperatorNode","../math/MathNode","../utils/ColorSpaceNode"],function(t,e,n,i,o,r,c,a,u,s){"use strict";function l(e,n,i){t.call(this,"v4"),this.value=e,this.uv=n,this.bias=i}return l.Nodes=function(){var t=new n("struct TextureCubeUVData {\n\t\t\tvec4 tl;\n\t\t\tvec4 tr;\n\t\t\tvec4 br;\n\t\t\tvec4 bl;\n\t\t\tvec2 f;\n\t\t}"),o=new e("float cubeUV_maxMipLevel 8.0",!0),r=new e("float cubeUV_minMipLevel 4.0",!0),c=new e("float cubeUV_maxTileSize 256.0",!0),a=new e("float cubeUV_minTileSize 16.0",!0),u=new i("float getFace(vec3 direction) {\n\t\t\t\tvec3 absDirection = abs(direction);\n\t\t\t\tfloat face = -1.0;\n\t\t\t\tif (absDirection.x > absDirection.z) {\n\t\t\t\t\tif (absDirection.x > absDirection.y)\n\t\t\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t} else {\n\t\t\t\t\tif (absDirection.z > absDirection.y)\n\t\t\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\t\t\telse\n\t\t\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t\t\t}\n\t\t\t\treturn face;\n\t\t}");u.useKeywords=!1;var s=new i("vec2 getUV(vec3 direction, float face) {\n\t\t\t\tvec2 uv;\n\t\t\t\tif (face == 0.0) {\n\t\t\t\t\tuv = vec2(-direction.z, direction.y) / abs(direction.x);\n\t\t\t\t} else if (face == 1.0) {\n\t\t\t\t\tuv = vec2(direction.x, -direction.z) / abs(direction.y);\n\t\t\t\t} else if (face == 2.0) {\n\t\t\t\t\tuv = direction.xy / abs(direction.z);\n\t\t\t\t} else if (face == 3.0) {\n\t\t\t\t\tuv = vec2(direction.z, direction.y) / abs(direction.x);\n\t\t\t\t} else if (face == 4.0) {\n\t\t\t\t\tuv = direction.xz / abs(direction.y);\n\t\t\t\t} else {\n\t\t\t\t\tuv = vec2(-direction.x, direction.y) / abs(direction.z);\n\t\t\t\t}\n\t\t\t\treturn 0.5 * (uv + 1.0);\n\t\t}");s.useKeywords=!1;var l=new i("TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n\n\t\t\tfloat face = getFace(direction);\n\t\t\tfloat filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n\t\t\tmipInt = max(mipInt, cubeUV_minMipLevel);\n\t\t\tfloat faceSize = exp2(mipInt);\n\n\t\t\tfloat texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n\n\t\t\tvec2 uv = getUV(direction, face) * (faceSize - 1.0);\n\t\t\tvec2 f = fract(uv);\n\t\t\tuv += 0.5 - f;\n\t\t\tif (face > 2.0) {\n\t\t\t\tuv.y += faceSize;\n\t\t\t\tface -= 3.0;\n\t\t\t}\n\t\t\tuv.x += face * faceSize;\n\t\t\tif(mipInt < cubeUV_maxMipLevel){\n\t\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t\t}\n\t\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\t\tuv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n\t\t\tuv *= texelSize;\n \n\t\t\tvec4 tl = texture2D(envMap, uv);\n\t\t\tuv.x += texelSize;\n\t\t\tvec4 tr = texture2D(envMap, uv);\n\t\t\tuv.y += texelSize;\n\t\t\tvec4 br = texture2D(envMap, uv);\n\t\t\tuv.x -= texelSize;\n\t\t\tvec4 bl = texture2D(envMap, uv);\n\n\t\t\treturn TextureCubeUVData( tl, tr, br, bl, f );\n\t\t}",[t,u,s,o,r,c,a]);l.useKeywords=!1;var v=new e("float r0 1.0",!0),p=new e("float v0 0.339",!0),f=new e("float m0 -2.0",!0),d=new e("float r1 0.8",!0),b=new e("float v1 0.276",!0),h=new e("float m1 -1.0",!0),m=new e("float r4 0.4",!0),x=new e("float v4 0.046",!0),w=new e("float m4 2.0",!0),S=new e("float r5 0.305",!0),T=new e("float v5 0.016",!0),U=new e("float m5 3.0",!0),V=new e("float r6 0.21",!0),g=new e("float v6 0.0038",!0),y=new e("float m6 4.0",!0);return{bilinearCubeUV:l,roughnessToMip:new i("float roughnessToMip(float roughness) {\n\t\t\tfloat mip = 0.0;\n\t\t\tif (roughness >= r1) {\n\t\t\t\tmip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n\t\t\t} else if (roughness >= r4) {\n\t\t\t\tmip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n\t\t\t} else if (roughness >= r5) {\n\t\t\t\tmip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n\t\t\t} else if (roughness >= r6) {\n\t\t\t\tmip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n\t\t\t} else {\n\t\t\t\tmip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\n\t\t\t}\n\t\t\treturn mip;\n\t\t}",[v,p,f,d,b,h,m,x,w,S,T,U,V,g,y]),m0:f,cubeUV_maxMipLevel:o}}(),l.prototype=Object.create(t.prototype),l.prototype.constructor=l,l.prototype.nodeType="TextureCubeUV",l.prototype.bilinearCubeUV=function(t,e,n,i){var c=new o(l.Nodes.bilinearCubeUV,[e,n,i]);this.colorSpaceTL=this.colorSpaceTL||new s(new r("","v4")),this.colorSpaceTL.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceTL.input.parse(c.build(t)+".tl"),this.colorSpaceTR=this.colorSpaceTR||new s(new r("","v4")),this.colorSpaceTR.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceTR.input.parse(c.build(t)+".tr"),this.colorSpaceBL=this.colorSpaceBL||new s(new r("","v4")),this.colorSpaceBL.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceBL.input.parse(c.build(t)+".bl"),this.colorSpaceBR=this.colorSpaceBR||new s(new r("","v4")),this.colorSpaceBR.fromDecoding(t.getTextureEncodingFromMap(this.value.value)),this.colorSpaceBR.input.parse(c.build(t)+".br");var a={include:t.isShader("vertex"),ignoreCache:!0};t.addContext(a),this.colorSpaceTLExp=new r(this.colorSpaceTL.build(t,"v4"),"v4"),this.colorSpaceTRExp=new r(this.colorSpaceTR.build(t,"v4"),"v4"),this.colorSpaceBLExp=new r(this.colorSpaceBL.build(t,"v4"),"v4"),this.colorSpaceBRExp=new r(this.colorSpaceBR.build(t,"v4"),"v4"),t.removeContext();var u=new r("mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )","v4");return u.keywords.cubeUV_TL=this.colorSpaceTLExp,u.keywords.cubeUV_TR=this.colorSpaceTRExp,u.keywords.cubeUV_BL=this.colorSpaceBLExp,u.keywords.cubeUV_BR=this.colorSpaceBRExp,u.keywords.cubeUV=c,u},l.prototype.generate=function(t,e){if(t.isShader("fragment")){var n=this.uv,i=this.bias||t.context.roughness,r=new o(l.Nodes.roughnessToMip,[i]),s=new u(r,l.Nodes.m0,l.Nodes.cubeUV_maxMipLevel,u.CLAMP),v=new u(s,u.FLOOR),p=new u(s,u.FRACT),f=this.bilinearCubeUV(t,this.value,n,v),d=this.bilinearCubeUV(t,this.value,n,new a(v,new c(1).setReadonly(!0),a.ADD)),b=new u(f,d,p,u.MIX);return t.format(b.build(t),"v4",e)}return console.warn("THREE.TextureCubeUVNode is not compatible with "+t.shader+" shader."),t.format("vec4( 0.0 )",this.getType(t),e)},l.prototype.toJSON=function(t){var e=this.getJSONNode(t);return e||((e=this.createJSONNode(t)).value=this.value.toJSON(t).uuid,e.uv=this.uv.toJSON(t).uuid,e.bias=this.bias.toJSON(t).uuid),e},l});
//# sourceMappingURL=../../sourcemaps/nodes/misc/TextureCubeUVNode.js.map
